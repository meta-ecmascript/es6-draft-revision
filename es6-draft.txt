Contents Page

Introduction vii

1 Scope 

2 Conformance 

3 Normative references 

4 Overview 

4.1 Web Scripting 

4.2 Language Overview 

4.2.1 Objects 

4.2.2 The Strict Variant of ECMAScript 

4.3 Terms and definitions 

5 Notational Conventions 

5.1 Syntactic and Lexical Grammars 

5.1.1 Context-Free Grammars 

5.1.2 The Lexical and RegExp Grammars 

5.1.3 The Numeric String Grammar 

5.1.4 The Syntactic Grammar 

5.1.5 The JSON Grammar 

5.1.6 Grammar Notation 

5.2 Algorithm Conventions 

5.3 Static Semantic Rules 

6 Source Text 

7 Lexical Conventions 

7.1 Unicode Format-Control Characters 

7.2 White Space 

7.3 Line Terminators 

7.4 Comments 

7.5 Tokens 

7.6 Identifier Names and Identifiers 

7.6.1 Reserved Words 

7.7 Punctuators 

7.8 Literals 

7.8.1 Null Literals 

7.8.2 Boolean Literals 

7.8.3 Numeric Literals 

7.8.4 String Literals 

7.8.5 Regular Expression Literals 

7.9 Automatic Semicolon Insertion 

7.9.1 Rules of Automatic Semicolon Insertion 

7.9.2 Examples of Automatic Semicolon Insertion 

8 Types 

8.1 The Undefined Type 

8.2 The Null Type 

8.3 The Boolean Type 

8.4 The String Type 

8.5 The Number Type 

8.6 The Object Type 

8.6.1 Property Attributes 

8.6.2 Object Internal Properties and Methods 

8.7 The Reference Specification Type 

8.7.1 GetValue (V) 

8.7.2 PutValue (V, W) 

8.8 The List Specification Type 

8.9 The Completion Specification Type 

8.10 The Property Descriptor and Property Identifier Specification Types
3

8.10.1 IsAccessorDescriptor ( Desc ) 

8.10.2 IsDataDescriptor ( Desc ) 

8.10.3 IsGenericDescriptor ( Desc ) 

8.10.4 FromPropertyDescriptor ( Desc ) 

8.10.5 ToPropertyDescriptor ( Obj ) 

8.11 The Lexical Environment and Environment Record Specification Types
4

8.12 Algorithms for Object Internal Methods 

8.12.1 [[GetOwnProperty]] (P) 

8.12.2 [[GetProperty]] (P) 

8.12.3 [[Get]] (P) 

8.12.4 [[CanPut]] (P) 

8.12.5 [[Put]] ( P, V, Throw ) 

8.12.6 [[HasProperty]] (P) 

8.12.7 [[Delete]] (P, Throw) 

8.12.8 [[DefaultValue]] (hint) 

8.12.9 [[DefineOwnProperty]] (P, Desc, Throw) 

9 Type Conversion and Testing 

9.1 ToPrimitive 

9.2 ToBoolean 

9.3 ToNumber 

9.3.1 ToNumber Applied to the String Type 

9.4 ToInteger 

9.5 ToInt32: (Signed 32 Bit Integer) 

9.6 ToUint32: (Unsigned 32 Bit Integer) 

9.7 ToUint16: (Unsigned 16 Bit Integer) 

9.8 ToString 

9.8.1 ToString Applied to the Number Type 

9.9 ToObject 

9.10 CheckObjectCoercible 

9.11 IsCallable 

9.12 The SameValue Algorithm 

10 Executable Code and Execution Contexts 

10.1 Types of Executable Code 

10.1.1 Strict Mode Code 

10.1.2 Extended Code 

10.2 Lexical Environments 

10.2.1 Environment Records 

10.2.2 Lexical Environment Operations 

10.2.3 The Global Environment 

10.3 Execution Contexts 

10.3.1 Identifier Resolution 

10.4 Establishing an Execution Context 

10.4.1 Entering Global Code 

10.4.2 Entering Eval Code 

10.4.3 Entering Function Code 

10.5 Declaration Binding Instantiation 

10.5.XXX Block Declaration Instantiation 

10.6 Arguments Object 

11 Expressions 

11.1 Primary Expressions 

11.1.1 The this Keyword 

11.1.2 Identifier Reference 

11.1.3 Literal Reference 

11.1.4 Array Initialiser 

11.1.5 Object Initialiser 

11.1.6 The Grouping Operator 

11.2 Left-Hand-Side Expressions 

11.2.1 Property Accessors 

11.2.2 The new Operator 

11.2.3 Function Calls 

11.2.4 Argument Lists 

11.2.5 Function Expressions 

11.3 Postfix Expressions 

11.3.1 Postfix Increment Operator 

11.3.2 Postfix Decrement Operator 

11.4 Unary Operators 

11.4.1 The delete Operator 

11.4.2 The void Operator 

11.4.3 The typeof Operator 

11.4.4 Prefix Increment Operator 

11.4.5 Prefix Decrement Operator 

11.4.6 Unary + Operator 

11.4.7 Unary - Operator 

11.4.8 Bitwise NOT Operator ( ~ ) 

11.4.9 Logical NOT Operator ( ! ) 

11.5 Multiplicative Operators 

11.5.1 Applying the * Operator 

11.5.2 Applying the / Operator 

11.5.3 Applying the % Operator 

11.6 Additive Operators 

11.6.1 The Addition operator ( + ) 

11.6.2 The Subtraction Operator ( - ) 

11.6.3 Applying the Additive Operators to Numbers 

11.7 Bitwise Shift Operators 

11.7.1 The Left Shift Operator ( << ) 

11.7.2 The Signed Right Shift Operator ( >> ) 

11.7.3 The Unsigned Right Shift Operator ( >>> ) 

11.8 Relational Operators 

11.8.1 The Less-than Operator ( < ) 

11.8.2 The Greater-than Operator ( > ) 

11.8.3 The Less-than-or-equal Operator ( <= ) 

11.8.4 The Greater-than-or-equal Operator ( >= ) 

11.8.5 The Abstract Relational Comparison Algorithm 

11.8.6 The instanceof operator 

11.8.7 The in operator 

11.9 Equality Operators 

11.9.1 The Equals Operator ( == ) 

11.9.2 The Does-not-equals Operator ( != ) 

11.9.3 The Abstract Equality Comparison Algorithm 

11.9.4 The Strict Equals Operator ( === ) 

11.9.5 The Strict Does-not-equal Operator ( !== ) 

11.9.6 The Strict Equality Comparison Algorithm 

11.10 Binary Bitwise Operators 

11.11 Binary Logical Operators 

11.12 Conditional Operator ( ? : ) 

11.13 Assignment Operators 

11.13.1 Simple Assignment ( = ) 

11.13.2 Compound Assignment ( op= ) 

11.14 Comma Operator ( , ) 

12 Statements and Declarations 

12.1 Block 

12.2 Declarations and the Variable Statement 

12.2.1 Let Declaration 

12.2.2 Const Declaration 

12.2.3 Variable Statement 

12.2.4 Destructuring Binding Patterns 

12.3 Empty Statement 

12.4 Expression Statement 

12.5 The if Statement 

12.6 Iteration Statements 

12.6.1 The do-while Statement 

12.6.2 The while Statement 

12.6.3 The for Statement 

12.6.4 The for-in Statement 

12.7 The continue Statement 

12.8 The break Statement 

12.9 The return Statement 

12.10 The with Statement 

12.11 The switch Statement 

12.12 Labelled Statements 

12.13 The throw Statement 

12.14 The try Statement 

12.15 The debugger statement 

13 Function Definition 

13.2 Creating Function Objects 

13.2.1 [[Call]] 

13.2.2 [[Construct]] 

13.2.3 The [[ThrowTypeError]] Function Object 

14 Program 

14.1 Directive Prologues and the Use Strict Directive 

15 Standard Built-in ECMAScript Objects 

15.1 The Global Object 

15.1.1 Value Properties of the Global Object 

15.1.2 Function Properties of the Global Object 

15.1.3 URI Handling Function Properties 

15.1.4 Constructor Properties of the Global Object 

15.1.5 Other Properties of the Global Object 

15.2 Object Objects 

15.2.1 The Object Constructor Called as a Function 

15.2.2 The Object Constructor 

15.2.3 Properties of the Object Constructor 

15.2.4 Properties of the Object Prototype Object 

15.2.5 Properties of Object Instances 

15.3 Function Objects 

15.3.1 The Function Constructor Called as a Function 

15.3.2 The Function Constructor 

15.3.3 Properties of the Function Constructor 

15.3.4 Properties of the Function Prototype Object 

15.3.5 Properties of Function Instances 

15.4 Array Objects 

15.4.1 The Array Constructor Called as a Function 

15.4.2 The Array Constructor 

15.4.3 Properties of the Array Constructor 

15.4.4 Properties of the Array Prototype Object 

15.4.5 Properties of Array Instances 

15.5 String Objects 

15.5.1 The String Constructor Called as a Function 

15.5.2 The String Constructor 

15.5.3 Properties of the String Constructor 

15.5.4 Properties of the String Prototype Object 

15.5.5 Properties of String Instances 

15.6 Boolean Objects 

15.6.1 The Boolean Constructor Called as a Function 

15.6.2 The Boolean Constructor 

15.6.3 Properties of the Boolean Constructor 

15.6.4 Properties of the Boolean Prototype Object 

15.6.5 Properties of Boolean Instances 

15.7 Number Objects 

15.7.1 The Number Constructor Called as a Function 

15.7.2 The Number Constructor 

15.7.3 Properties of the Number Constructor 

15.7.4 Properties of the Number Prototype Object 

15.7.5 Properties of Number Instances 

15.8 The Math Object 

15.8.1 Value Properties of the Math Object 

15.8.2 Function Properties of the Math Object 

15.9 Date Objects 

15.9.1 Overview of Date Objects and Definitions of Abstract Operators
1

15.9.2 The Date Constructor Called as a Function 

15.9.3 The Date Constructor 

15.9.4 Properties of the Date Constructor 

15.9.5 Properties of the Date Prototype Object 

15.9.6 Properties of Date Instances 

15.10 RegExp (Regular Expression) Objects 

15.10.1 Patterns 

15.10.2 Pattern Semantics 

15.10.3 The RegExp Constructor Called as a Function 

15.10.4 The RegExp Constructor 

15.10.5 Properties of the RegExp Constructor 

15.10.6 Properties of the RegExp Prototype Object 

15.10.7 Properties of RegExp Instances 

15.11 Error Objects 

15.11.1 The Error Constructor Called as a Function 

15.11.2 The Error Constructor 

15.11.3 Properties of the Error Constructor 

15.11.4 Properties of the Error Prototype Object 

15.11.5 Properties of Error Instances 

15.11.6 Native Error Types Used in This Standard 

15.11.7 _NativeError_ Object Structure 

15.12 The JSON Object 

15.12.1 The JSON Grammar 

15.12.2 parse ( text [ , reviver ] ) 

15.12.3 stringify ( value [ , replacer [ , space ] ] ) 

16 Errors 

Annex A (informative) Grammar Summary 237

A.1 Lexical Grammar 237

A.2 Number Conversions 243

A.3 Expressions 244

A.4 Statements 248

A.5 Functions and Programs 250

A.6 Universal Resource Identifier Character Classes 251

A.7 Regular Expressions 251

A.8 JSON 254

A.8.1 JSON Lexical Grammar 254

A.8.2 JSON Syntactic Grammar 254

Annex B (normative) Additional ECMAScript Features for Web Browsers 257

B.1 Additional Syntax 257

B.1.1 Numeric Literals 257

B.1.2 String Literals 257

B.2 Additional Properties 258

B.2.1 escape (string) 258

B.2.2 unescape (string) 259

B.2.3 String.prototype.substr (start, length) 260

B.2.4 Date.prototype.getYear ( ) 260

B.2.5 Date.prototype.setYear (year) 260

B.2.6 Date.prototype.toGMTString ( ) 260

Annex C (informative) The Strict Mode of ECMAScript 261

Annex D (informative) Corrections and Clarifications in the 5^th^
Edition with Possible 3^rd^ Edition Compatibility Impact 263

Annex E (informative) Additions and Changes in the 5^th^ Edition that
Introduce Incompatibilities with the 3^rd^ Edition 265

Annex F (informative) Technically Significant Corrections and
Clarifications in the 5.1 Edition 269

Introduction

This Ecma Standard is based on several originating technologies, the
most well known being JavaScript (Netscape) and JScript (Microsoft). The
language was invented by Brendan Eich at Netscape and first appeared in
that company’s Navigator 2.0 browser. It has appeared in all subsequent
browsers from Netscape and in all browsers from Microsoft starting with
Internet Explorer 3.0.

The development of this Standard started in November 1996. The first
edition of this Ecma Standard was adopted by the Ecma General Assembly
of June 1997.

That Ecma Standard was submitted to ISO/IEC JTC 1 for adoption under the
fast-track procedure, and approved as international standard ISO/IEC
16262, in April 1998. The Ecma General Assembly of June 1998 approved
the second edition of ECMA-262 to keep it fully aligned with ISO/IEC
16262. Changes between the first and the second edition are editorial in
nature.

The third edition of the Standard introduced powerful regular
expressions, better string handling, new control statements, try/catch
exception handling, tighter definition of errors, formatting for numeric
output and minor changes in anticipation of forthcoming
internationalisation facilities and future language growth. The third
edition of the ECMAScript standard was adopted by the Ecma General
Assembly of December 1999 and published as ISO/IEC 16262:2002 in June
2002.

Since publication of the third edition, ECMAScript has achieved massive
adoption in conjunction with the World Wide Web where it has become the
programming language that is supported by essentially all web browsers.
Significant work was done to develop a fourth edition of ECMAScript.
Although that work was not completed and not published[1] as the fourth
edition of ECMAScript, it informs continuing evolution of the language.
The fifth edition of ECMAScript (published as ECMA-262 5^th^ edition)
codifies de facto interpretations of the language specification that
have become common among browser implementations and adds support for
new features that have emerged since the publication of the third
edition. Such features include accessor properties, reflective creation
and inspection of objects, program control of property attributes,
additional array manipulation functions, support for the JSON object
encoding format, and a strict mode that provides enhanced error checking
and program security.

The edition 5.1 of the ECMAScript Standard has been fully aligned with
the third edition of the international standard ISO/IEC 16262:2011.

This present sixth edition of the Standard………

ECMAScript is a vibrant language and the evolution of the language is
not complete. Significant technical enhancement will continue with
future editions of this specification.

This Ecma Standard has been adopted by the General Assembly of <month>
<year>.

_"DISCLAIMER

_This draft document may be copied and furnished to others, and
derivative works that comment on or otherwise explain it or assist in
its implementation may be prepared, copied, published, and distributed,
in whole or in part, without restriction of any kind, provided that the
above copyright notice and this section are included on all such copies
and derivative works. However, this document itself may not be modified
in any way, including by removing the copyright notice or references to
Ecma International, except as needed for the purpose of developing any
document or deliverable produced by Ecma International._

_This disclaimer is valid only prior to final version of this document.
After approval all rights on the standard are reserved by Ecma
International._

_The limited permissions are granted through the standardization phase
and will not be revoked by Ecma International or its successors or
assigns during this time._

_This document and the information contained herein is provided on an
"AS IS" basis and ECMA INTERNATIONAL DISCLAIMS ALL WARRANTIES, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
THE INFORMATION HEREIN WILL NOT INFRINGE ANY OWNERSHIP RIGHTS OR ANY
IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE."_

ECMAScript Language Specification



SCOPE


This Standard defines the ECMAScript scripting language.



CONFORMANCE


A conforming implementation of ECMAScript must provide and support all
the types, values, objects, properties, functions, and program syntax
and semantics described in this specification.

A conforming implementation of this Standard shall interpret characters
in conformance with the Unicode Standard, Version 3.0 or later and
ISO/IEC 10646-1 with either UCS-2 or UTF-16 as the adopted encoding
form, implementation level 3. If the adopted ISO/IEC 10646-1 subset is
not otherwise specified, it is presumed to be the BMP subset, collection
300. If the adopted encoding form is not otherwise specified, it
presumed to be the UTF-16 encoding form.

A conforming implementation of ECMAScript is permitted to provide
additional types, values, objects, properties, and functions beyond
those described in this specification. In particular, a conforming
implementation of ECMAScript is permitted to provide properties not
described in this specification, and values for those properties, for
objects that are described in this specification.

A conforming implementation of ECMAScript is permitted to support
program and regular expression syntax not described in this
specification. In particular, a conforming implementation of ECMAScript
is permitted to support program syntax that makes use of the “future
reserved words” listed in 7.6.1.2 of this specification.



NORMATIVE REFERENCES


The following referenced documents are indispensable for the application
of this document. For dated references, only the edition cited applies.
For undated references, the latest edition of the referenced document
(including any amendments) applies.

ISO/IEC 9899:1996_, Programming Languages – C, including amendment 1 and
technical corrigenda 1 and 2_

ISO/IEC 10646-1:1993_, Information Technology – Universal Multiple-Octet
Coded Character Set (UCS) plus its amendments and corrigenda_

This section contains a non-normative overview of the ECMAScript
language.

ECMAScript is an object-oriented programming language for performing
computations and manipulating computational objects within a host
environment. ECMAScript as defined here is not intended to be
computationally self-sufficient; indeed, there are no provisions in this
specification for input of external data or output of computed results.
Instead, it is expected that the computational environment of an
ECMAScript program will provide not only the objects and other
facilities described in this specification but also certain
environment-specific _host_ objects, whose description and behaviour are
beyond the scope of this specification except to indicate that they may
provide certain properties that can be accessed and certain functions
that can be called from an ECMAScript program.

A _SCRIPTING LANGUAGE_ is a programming language that is used to
manipulate, customise, and automate the facilities of an existing
system. In such systems, useful functionality is already available
through a user interface, and the scripting language is a mechanism for
exposing that functionality to program control. In this way, the
existing system is said to provide a host environment of objects and
facilities, which completes the capabilities of the scripting language.
A scripting language is intended for use by both professional and
non-professional programmers.

ECMAScript was originally designed to be a _WEB SCRIPTING LANGUAGE_,
providing a mechanism to enliven Web pages in browsers and to perform
server computation as part of a Web-based client-server architecture.
ECMAScript can provide core scripting capabilities for a variety of host
environments, and therefore the core scripting language is specified in
this document apart from any particular host environment.

Some of the facilities of ECMAScript are similar to those used in other
programming languages; in particular Java, Self, and Scheme as
described in:

Gosling, James, Bill Joy and Guy Steele. The Java^^ Language
Specification. Addison Wesley Publishing Co., 1996.

Ungar, David, and Smith, Randall B. Self: The Power of Simplicity.
OOPSLA '87 Conference Proceedings, pp. 227–241, Orlando, FL, October
1987.

IEEE Standard for the Scheme Programming Language. IEEE Std 1178-1990.

A web browser provides an ECMAScript host environment for client-side
computation including, for instance, objects that represent windows,
menus, pop-ups, dialog boxes, text areas, anchors, frames, history,
cookies, and input/output. Further, the host environment provides a
means to attach scripting code to events such as change of focus, page
and image loading, unloading, error and abort, selection, form
submission, and mouse actions. Scripting code appears within the HTML
and the displayed page is a combination of user interface elements and
fixed and computed text and images. The scripting code is reactive to
user interaction and there is no need for a main program.

A web server provides a different host environment for server-side
computation including objects representing requests, clients, and files;
and mechanisms to lock and share data. By using browser-side and
server-side scripting together, it is possible to distribute computation
between the client and server while providing a customised user
interface for a Web-based application.

Each Web browser and server that supports ECMAScript supplies its own
host environment, completing the ECMAScript execution environment.

The following is an informal overview of ECMAScript—not all parts of the
language are described. This overview is not part of the standard
proper.

ECMAScript is object-based: basic language and host facilities are
provided by objects, and an ECMAScript program is a cluster of
communicating objects. An ECMAScript _OBJECT_ is a collection of
_PROPERTIES_ each with zero or more _ATTRIBUTES_ that determine how each
property can be used—for example, when the Writable attribute for a
property is set to FALSE, any attempt by executed ECMAScript code to
change the value of the property fails. Properties are containers that
hold other objects, _PRIMITIVE VALUES_, or _FUNCTIONS_. A primitive
value is a member of one of the following built-in types: UNDEFINED,
NULL, BOOLEAN, NUMBER, and STRING; an object is a member of the
remaining built-in type OBJECT; and a function is a callable object. A
function that is associated with an object via a property is a _METHOD_.

ECMAScript defines a collection of _BUILT-IN OBJECTS_ that round out the
definition of ECMAScript entities. These built-in objects include the
global object, the OBJECT object, the FUNCTION object, the ARRAY object,
the STRING object, the BOOLEAN object, the NUMBER object, the MATH
object, the DATE object, the REGEXP object, the JSON object, and the
Error objects ERROR, EVALERROR, RANGEERROR, REFERENCEERROR, SYNTAXERROR,
TYPEERROR and URIERROR.

ECMAScript also defines a set of built-in _OPERATORS_. ECMAScript
operators include various unary operations, multiplicative operators,
additive operators, bitwise shift operators, relational operators,
equality operators, binary bitwise operators, binary logical operators,
assignment operators, and the comma operator.

ECMAScript syntax intentionally resembles Java syntax. ECMAScript syntax
is relaxed to enable it to serve as an easy-to-use scripting language.
For example, a variable is not required to have its type declared nor
are types associated with properties, and defined functions are not
required to have their declarations appear textually before calls to
them.

ECMAScript does not use classes such as those in C++, Smalltalk, or
Java. Instead objects may be created in various ways including via a
literal notation or via _CONSTRUCTORS_ which create objects and then
execute code that initialises all or part of them by assigning initial
values to their properties. Each constructor is a function that has a
property named “PROTOTYPE” that is used to implement _PROTOTYPE-BASED
INHERITANCE_ and _SHARED PROPERTIES_. Objects are created by using
constructors in NEW expressions; for example, NEW DATE(2009,11) creates
a new Date object. Invoking a constructor without using NEW has
consequences that depend on the constructor. For example, DATE()
produces a string representation of the current date and time rather
than an object.

Every object created by a constructor has an implicit reference (called
the object’s _prototype_) to the value of its constructor’s “PROTOTYPE”
property. Furthermore, a prototype may have a non-null implicit
reference to its prototype, and so on; this is called the _prototype
chain_. When a reference is made to a property in an object, that
reference is to the property of that name in the first object in the
prototype chain that contains a property of that name. In other words,
first the object mentioned directly is examined for such a property; if
that object contains the named property, that is the property to which
the reference refers; if that object does not contain the named
property, the prototype for that object is examined next; and so on.

Figure 1 — Object/Prototype Relationships

In a class-based object-oriented language, in general, state is carried
by instances, methods are carried by classes, and inheritance is only of
structure and behaviour. In ECMAScript, the state and methods are
carried by objects, and structure, behaviour, and state are all
inherited.

All objects that do not directly contain a particular property that
their prototype contains share that property and its value. Figure 1
illustrates this:

CF is a constructor (and also an object). Five objects have been created
by using NEW expressions: CF~1~, CF~2~, CF~3~, CF~4~, and CF~5~. Each of
these objects contains properties named q1 and q2. The dashed lines
represent the implicit prototype relationship; so, for example, CF~3~’s
prototype is CF~P~. The constructor, CF, has two properties itself,
named P1 and P2, which are not visible to CF~P~, CF~1~, CF~2~, CF~3~,
CF~4~, or CF~5~. The property named CFP1 in CF~P~ is shared by CF~1~,
CF~2~, CF~3~, CF~4~, and CF~5~ (but not by CF), as are any properties
found in CF~P~’s implicit prototype chain that are not named q1, q2, or
CFP1. Notice that there is no implicit prototype link between CF and
CF~P~.

Unlike class-based object languages, properties can be added to objects
dynamically by assigning values to them. That is, constructors are not
required to name or assign values to all or any of the constructed
object’s properties. In the above diagram, one could add a new shared
property for CF~1~, CF~2~, CF~3~, CF~4~, and CF~5\ ~by assigning a new
value to the property in CF~P~.

The ECMAScript Language recognises the possibility that some users of
the language may wish to restrict their usage of some features available
in the language. They might do so in the interests of security, to avoid
what they consider to be error-prone features, to get enhanced error
checking, or for other reasons of their choosing. In support of this
possibility, ECMAScript defines a strict variant of the language. The
strict variant of the language excludes some specific syntactic and
semantic features of the regular ECMAScript language and modifies the
detailed semantics of some features. The strict variant also specifies
additional error conditions that must be reported by throwing error
exceptions in situations that are not specified as errors by the
non-strict form of the language.

The strict variant of ECMAScript is commonly referred to as the _strict
mode_ of the language. Strict mode selection and use of the strict mode
syntax and semantics of ECMAScript is explicitly made at the level of
individual ECMAScript code units. Because strict mode is selected at the
level of a syntactic code unit, strict mode only imposes restrictions
that have local effect within such a code unit. Strict mode does not
restrict or modify any aspect of the ECMAScript semantics that must
operate consistently across multiple code units. A complete ECMAScript
program may be composed for both strict mode and non-strict mode
ECMAScript code units. In this case, strict mode only applies when
actually executing code that is defined within a strict mode code unit.

In order to conform to this specification, an ECMAScript implementation
must implement both the full unrestricted ECMAScript language and the
strict mode variant of the ECMAScript language as defined by this
specification. In addition, an implementation must support the
combination of unrestricted and strict mode code units into a single
composite program.

For the purposes of this document, the following terms and definitions
apply.

4.3.

type

set of data values as defined in Clause 8 of this specification

4.3.

primitive value

member of one of the types Undefined, Null, Boolean, Number, or String
as defined in Clause 8

NOTE A primitive value is a datum that is represented directly at the
lowest level of the language implementation.

4.3.

object

member of the type Object

NOTE An object is a collection of properties and has a single prototype
object. The prototype may be the null value.

4.3.

constructor

function object that creates and initialises objects

NOTE The value of a constructor’s “prototype” property is a prototype
object that is used to implement inheritance and shared properties.

4.3.

prototype

object that provides shared properties for other objects

NOTE When a constructor creates an object, that object implicitly
references the constructor’s “PROTOTYPE” property for the purpose of
resolving property references. The constructor’s “PROTOTYPE” property
can be referenced by the program expression _constructor_.PROTOTYPE, and
properties added to an object’s prototype are shared, through
inheritance, by all objects sharing the prototype. Alternatively, a new
object may be created with an explicitly specified prototype by using
the OBJECT.CREATE built-in function.

4.3.

native object

object in an ECMAScript implementation whose semantics are fully defined
by this specification rather than by the host environment

NOTE Standard native objects are defined in this specification. Some
native objects are built-in; others may be constructed during the course
of execution of an ECMAScript program.

4.3.

built-in object

object supplied by an ECMAScript implementation, independent of the host
environment, that is present at the start of the execution of an
ECMAScript program

NOTE Standard built-in objects are defined in this specification, and an
ECMAScript implementation may specify and define others. Every built-in
object is a native object. A _built-in constructor_ is a built-in object
that is also a constructor.

4.3.

host object

object supplied by the host environment to complete the execution
environment of ECMAScript

NOTE Any object that is not native is a host object.

4.3.

undefined value

primitive value used when a variable has not been assigned a value

4.3.

Undefined type

type whose sole value is the undefined value

4.3.

null value

primitive value that represents the intentional absence of any object
value

4.3.

Null type

type whose sole value is the null value

4.3.

Boolean value

member of the Boolean type

NOTE There are only two Boolean values, TRUE and FALSE.

4.3.

Boolean type

type consisting of the primitive values TRUE and FALSE

4.3.

Boolean object

member of the Object type that is an instance of the standard built-in
BOOLEAN constructor

NOTE A Boolean object is created by using the BOOLEAN constructor in a
NEW expression, supplying a Boolean value as an argument. The resulting
object has an internal property whose value is the Boolean value. A
Boolean object can be coerced to a Boolean value.

4.3.

String value

primitive value that is a finite ordered sequence of zero or more 16-bit
unsigned integer

NOTE A String value is a member of the String type. Each integer value
in the sequence usually represents a single 16-bit unit of UTF-16 text.
However, ECMAScript does not place any restrictions or requirements on
the values except that they must be 16-bit unsigned integers.

4.3.

String type

set of all possible String values

4.3.

String object

member of the Object type that is an instance of the standard built-in
STRING constructor

NOTE A String object is created by using the STRING constructor in a NEW
expression, supplying a String value as an argument. The resulting
object has an internal property whose value is the String value. A
String object can be coerced to a String value by calling the STRING
constructor as a function (15.5.1).

4.3.

Number value

primitive value corresponding to a double-precision 64-bit binary format
IEEE 754 value

NOTE A Number value is a member of the Number type and is a direct
representation of a number.

4.3.

Number type

set of all possible Number values including the special “Not-a-Number”
(NaN) values, positive infinity, and negative infinity

4.3.

Number object

member of the Object type that is an instance of the standard built-in
NUMBER constructor

NOTE A Number object is created by using the NUMBER constructor in a NEW
expression, supplying a Number value as an argument. The resulting
object has an internal property whose value is the Number value. A
Number object can be coerced to a Number value by calling the NUMBER
constructor as a function (15.7.1).

4.3.

Infinity

number value that is the positive infinite Number value

4.3.

NaN

number value that is a IEEE 754 “Not-a-Number” value

4.3.

function

member of the Object type that is an instance of the standard built-in
FUNCTION constructor and that may be invoked as a subroutine

NOTE In addition to its named properties, a function contains executable
code and state that determine how it behaves when invoked. A function’s
code may or may not be written in ECMAScript.

4.3.

built-in function

built-in object that is a function

NOTE Examples of built-in functions include PARSEINT and MATH.EXP. An
implementation may provide implementation-dependent built-in functions
that are not described in this specification.

4.3.

property

association between a name and a value that is a part of an object

NOTE Depending upon the form of the property the value may be
represented either directly as a data value (a primitive value, an
object, or a function object) or indirectly by a pair of accessor
functions.

4.3.

method

function that is the value of a property

NOTE When a function is called as a method of an object, the object is
passed to the function as its THIS value.

4.3.

built-in method

method that is a built-in function

NOTE Standard built-in methods are defined in this specification, and an
ECMAScript implementation may specify and provide other additional
built-in methods.

4.3.

attribute

internal value that defines some characteristic of a property

4.3.

own property

property that is directly contained by its object

4.3.

inherited property

property of an object that is not an own property but is a property
(either own or inherited) of the object’s prototype

A _context-free grammar_ consists of a number of _productions_. Each
production has an abstract symbol called a _nonterminal_ as its
_left-hand side_, and a sequence of zero or more nonterminal and
_terminal_ symbols as its _right-hand side_. For each grammar, the
terminal symbols are drawn from a specified alphabet.

Starting from a sentence consisting of a single distinguished
nonterminal, called the _goal symbol_, a given context-free grammar
specifies a _language_, namely, the (perhaps infinite) set of possible
sequences of terminal symbols that can result from repeatedly replacing
any nonterminal in the sequence with a right-hand side of a production
for which the nonterminal is the left-hand side.

A _lexical grammar_ for ECMAScript is given in clause 7. This grammar
has as its terminal symbols characters (Unicode code units) that conform
to the rules for _SourceCharacter_ defined in Clause 6. It defines a set
of productions, starting from the goal symbol _InputElementDiv_ or
_InputElementRegExp_, that describe how sequences of such characters are
translated into a sequence of input elements.

Input elements other than white space and comments form the terminal
symbols for the syntactic grammar for ECMAScript and are called
ECMAScript _tokens_. These tokens are the reserved words, identifiers,
literals, and punctuators of the ECMAScript language. Moreover, line
terminators, although not considered to be tokens, also become part of
the stream of input elements and guide the process of automatic
semicolon insertion (7.9). Simple white space and single-line comments
are discarded and do not appear in the stream of input elements for the
syntactic grammar. A _MultiLineComment_ (that is, a comment of the form
“/*…*/” regardless of whether it spans more than one line) is likewise
simply discarded if it contains no line terminator; but if a
_MultiLineComment_ contains one or more line terminators, then it is
replaced by a single line terminator, which becomes part of the stream
of input elements for the syntactic grammar.

A _RegExp grammar_ for ECMAScript is given in 15.10. This grammar also
has as its terminal symbols the characters as defined by
_SourceCharacter_. It defines a set of productions, starting from the
goal symbol _Pattern_, that describe how sequences of characters are
translated into regular expression patterns.

Productions of the lexical and RegExp grammars are distinguished by
having two colons “::” as separating punctuation. The lexical and RegExp
grammars share some productions.

Another grammar is used for translating Strings into numeric values.
This grammar is similar to the part of the lexical grammar having to do
with numeric literals and has as its terminal symbols _SourceCharacter_.
This grammar appears in 9.3.1.

Productions of the numeric string grammar are distinguished by having
three colons “:::” as punctuation.

The _syntactic grammar_ for ECMAScript is given in clauses 11, 12, 13
and 14. This grammar has ECMAScript tokens defined by the lexical
grammar as its terminal symbols (5.1.2). It defines a set of
productions, starting from the goal symbol _Program_, that describe how
sequences of tokens can form syntactically correct ECMAScript programs.

When a stream of characters is to be parsed as an ECMAScript program, it
is first converted to a stream of input elements by repeated application
of the lexical grammar; this stream of input elements is then parsed by
a single application of the syntactic grammar. The program is
syntactically in error if the tokens in the stream of input elements
cannot be parsed as a single instance of the goal nonterminal _Program_,
with no tokens left over.

Productions of the syntactic grammar are distinguished by having just
one colon “:” as punctuation.

The syntactic grammar as presented in clauses 11, 12, 13 and 14 is
actually not a complete account of which token sequences are accepted as
correct ECMAScript programs. Certain additional token sequences are also
accepted, namely, those that would be described by the grammar if only
semicolons were added to the sequence in certain places (such as before
line terminator characters). Furthermore, certain token sequences that
are described by the grammar are not considered acceptable if a
terminator character appears in certain “awkward” places.

In certain cases in order to avoid ambiguities the syntactic grammar
uses productions that permit token sequences that are not valid
ECMAScript programs. In such cases a more restrictive _supplemental_
_grammar_ is provided that further restricts the acceptable token
sequences. In such situations, when explicitly specific, the input
elements corresponding to such a production is parsed again using a goal
symbol of a supplemental grammar. The program is syntactically in error
if the tokens in the stream of input elements cannot be parsed as a
single instance of the supplemental goal symbol, with no tokens left
over.

The JSON grammar is used to translate a String describing a set of
ECMAScript objects into actual objects. The JSON grammar is given in
15.12.1.

The JSON grammar consists of the JSON lexical grammar and the JSON
syntactic grammar. The JSON lexical grammar is used to translate
character sequences into tokens and is similar to parts of the
ECMAScript lexical grammar. The JSON syntactic grammar describes how
sequences of tokens from the JSON lexical grammar can form syntactically
correct JSON object descriptions.

Productions of the JSON lexical grammar are distinguished by having two
colons “::” as separating punctuation. The JSON lexical grammar uses
some productions from the ECMAScript lexical grammar. The JSON syntactic
grammar is similar to parts of the ECMAScript syntactic grammar.
Productions of the JSON syntactic grammar are distinguished by using one
colon “:” as separating punctuation.

Terminal symbols of the lexical, RegExp, and numeric string grammars,
and some of the terminal symbols of the other grammars, are shown in
FIXED WIDTH font, both in the productions of the grammars and throughout
this specification whenever the text directly refers to such a terminal
symbol. These are to appear in a program exactly as written. All
terminal symbol characters specified in this way are to be understood as
the appropriate Unicode character from the ASCII range, as opposed to
any similar-looking characters from other Unicode ranges.

Nonterminal symbols are shown in _italic_ type. The definition of a
nonterminal is introduced by the name of the nonterminal being defined
followed by one or more colons. (The number of colons indicates to which
grammar the production belongs.) One or more alternative right-hand
sides for the nonterminal then follow on succeeding lines. For example,
the syntactic definition:

WhileStatement :

WHILE ( Expression ) Statement

states that the nonterminal _WhileStatement_ represents the token WHILE,
followed by a left parenthesis token, followed by an _Expression_,
followed by a right parenthesis token, followed by a _Statement_. The
occurrences of _Expression_ and _Statement_ are themselves nonterminals.
As another example, the syntactic definition:

ArgumentList :

AssignmentExpression
ArgumentList , AssignmentExpression

states that an _ArgumentList_ may represent either a single
_AssignmentExpression_ or an _ArgumentList_, followed by a comma,
followed by an _AssignmentExpression_. This definition of _ArgumentList_
is recursive, that is, it is defined in terms of itself. The result is
that an _ArgumentList_ may contain any positive number of arguments,
separated by commas, where each argument expression is an
_AssignmentExpression_. Such recursive definitions of nonterminals are
common.

The subscripted suffix “~opt~”, which may appear after a terminal or
nonterminal, indicates an optional symbol. The alternative containing
the optional symbol actually specifies two right-hand sides, one that
omits the optional element and one that includes it. This means that:

VariableDeclaration :

Identifier Initialiser~opt~

is a convenient abbreviation for:

VariableDeclaration :

Identifier
Identifier Initialiser

and that:

IterationStatement :

FOR ( ExpressionNoIn~opt~ ; Expression~opt~ ; Expression~opt~ )
Statement

is a convenient abbreviation for:

IterationStatement :

FOR ( ; Expression~opt~ ; Expression~opt~ ) Statement
FOR ( ExpressionNoIn ; Expression~opt~ ; Expression~opt~ ) Statement

which in turn is an abbreviation for:

IterationStatement :

FOR ( ; ; Expression~opt~ ) Statement
FOR ( ; Expression ; Expression~opt~ ) Statement
FOR ( ExpressionNoIn ; ; Expression~opt~ ) Statement
FOR ( ExpressionNoIn ; Expression ; Expression~opt~ ) Statement

which in turn is an abbreviation for:

IterationStatement :

FOR ( ; ; ) Statement
FOR ( ; ; Expression ) Statement
FOR ( ; Expression ; ) Statement
FOR ( ; Expression ; Expression ) Statement
FOR ( ExpressionNoIn ; ; ) Statement
FOR ( ExpressionNoIn ; ; Expression ) Statement
FOR ( ExpressionNoIn ; Expression ; ) Statement
FOR ( ExpressionNoIn ; Expression ; Expression ) Statement

so the nonterminal _IterationStatement_ actually has eight alternative
right-hand sides.

When the words “ONE OF” follow the colon(s) in a grammar definition,
they signify that each of the terminal symbols on the following line or
lines is an alternative definition. For example, the lexical grammar for
ECMAScript contains the production:

NonZeroDigit :: ONE OF

1 2 3 4 5 6 7 8 

which is merely a convenient abbreviation for:

NonZeroDigit ::

1
2
3
4
5
6
7
8
9

If the phrase “[empty]” appears as the right-hand side of a production,
it indicates that the production's right-hand side contains no terminals
or nonterminals.

If the phrase “[lookahead ∉ _set_]” appears in the right-hand side of a
production, it indicates that the production may not be used if the
immediately following input token is a member of the given _set_. The
_set_ can be written as a list of terminals enclosed in curly braces.
For convenience, the set can also be written as a nonterminal, in which
case it represents the set of all terminals to which that nonterminal
could expand. For example, given the definitions

DecimalDigit :: ONE OF

0 1 2 3 4 5 6 7 8 

DecimalDigits ::

DecimalDigit
DecimalDigits DecimalDigit

the definition

LookaheadExample ::

N [lookahead ∉ {1, 3, 5, 7, 9}] DecimalDigits
DecimalDigit [lookahead ∉ DecimalDigit ]

matches either the letter N followed by one or more decimal digits the
first of which is even, or a decimal digit not followed by another
decimal digit.

If the phrase “[no _LineTerminator_ here]” appears in the right-hand
side of a production of the syntactic grammar, it indicates that the
production is _a restricted production_: it may not be used if a
_LineTerminator_ occurs in the input stream at the indicated position.
For example, the production:

ThrowStatement :

THROW [no LineTerminator here] Expression ;

indicates that the production may not be used if a _LineTerminator_
occurs in the program between the THROW token and the _Expression_.

Unless the presence of a _LineTerminator_ is forbidden by a restricted
production, any number of occurrences of _LineTerminator_ may appear
between any two consecutive tokens in the stream of input elements
without affecting the syntactic acceptability of the program.

When an alternative in a production of the lexical grammar or the
numeric string grammar appears to be a multi-character token, it
represents the sequence of characters that would make up such a token.

The right-hand side of a production may specify that certain expansions
are not permitted by using the phrase “BUT NOT” and then indicating the
expansions to be excluded. For example, the production:

Identifier ::

IdentifierName BUT NOT ReservedWord

means that the nonterminal _Identifier_ may be replaced by any sequence
of characters that could replace _IdentifierName_ provided that the same
sequence of characters could not replace _ReservedWord_.

Finally, a few nonterminal symbols are described by a descriptive phrase
in sans-serif type in cases where it would be impractical to list all
the alternatives:

SourceCharacter ::

any Unicode code unit

The specification often uses a numbered list to specify steps in an
algorithm. These algorithms are used to precisely specify the required
semantics of ECMAScript language constructs. The algorithms are not
intended to imply the use of any specific implementation technique. In
practice, there may be more efficient algorithms available to implement
a given feature.

In order to facilitate their use in multiple parts of this
specification, some algorithms, called _abstract_ _operations_, are
named and written in parameterised functional form so that they may be
referenced by name from within other algorithms.

When an algorithm is to produce a value as a result, the directive
“return _x_” is used to indicate that the result of the algorithm is the
value of _x_ and that the algorithm should terminate. The notation
Result(_n_) is used as shorthand for “the result of step _n_”.

For clarity of expression, algorithm steps may be subdivided into
sequential substeps. Substeps are indented and may themselves be further
divided into indented substeps. Outline numbering conventions are used
to identify substeps with the first level of substeps labelled with
lower case alphabetic characters and the second level of substeps
labelled with lower case roman numerals. If more than three levels are
required these rules repeat with the fourth level using numeric labels.
For example:

A step or substep may be written as an “if” predicate that conditions
its substeps. In this case, the substeps are only applied if the
predicate is true. If a step or substep begins with the word “else”, it
is a predicate that is the negation of the preceding “if” predicate step
at the same level.

A step may specify the iterative application of its substeps.

A step may assert an invariant condition of its algorithm. Such
assertions are used to make explicit algorithmic invariants that would
otherwise be implicit. Such assertions add no additional semantic
requirements and hence need not be checked by an implementation. They
are used simply to clarify algorithms.

Mathematical operations such as addition, subtraction, negation,
multiplication, division, and the mathematical functions defined later
in this clause should always be understood as computing exact
mathematical results on mathematical real numbers, which do not include
infinities and do not include a negative zero that is distinguished from
positive zero. Algorithms in this standard that model floating-point
arithmetic include explicit steps, where necessary, to handle infinities
and signed zero and to perform rounding. If a mathematical operation or
function is applied to a floating-point number, it should be understood
as being applied to the exact mathematical value represented by that
floating-point number; such a floating-point number must be finite, and
if it is +0 or −0 then the corresponding mathematical value is simply 0.

The mathematical function abs(_x_) yields the absolute value of _x_,
which is −_x_ if _x_ is negative (less than zero) and otherwise is _x_
itself.

The mathematical function sign(_x_) yields 1 if _x_ is positive and −1
if _x_ is negative. The sign function is not used in this standard for
cases when _x_ is zero.

The notation “_x_ modulo _y_” (_y_ must be finite and nonzero) computes
a value _k_ of the same sign as _y_ (or zero) such that abs(_k_) <
abs(_y_) and _x_−_k_ = _q_ × _y_ for some integer _q_.

The mathematical function floor(_x_) yields the largest integer (closest
to positive infinity) that is not larger than _x_.

NOTE floor(_x_) = _x_−(_x_ modulo 1).

If an algorithm is defined to “throw an exception”, execution of the
algorithm is terminated and no result is returned. The calling
algorithms are also terminated, until an algorithm step is reached that
explicitly deals with the exception, using terminology such as “If an
exception was thrown…”. Once such an algorithm step has been encountered
the exception is no longer considered to have occurred.

Context-free grammars are not sufficiently powerful to express all the
rules that define whether a stream of input elements make up a valid
ECMAScript program that may be evaluated. In some situations additional
rules are needed that may be expressed using either ECMAScript algorithm
conventions or prose requirements. Such rules are always associated with
a production of a grammar and are called the _static semantics_ of the
production.

An implementation must validate all of the static semantic rules used to
parse a _Program_ prior to the first evaluation of that _Program_. If
any of the static semantic rules are violated the _Program_ is invalid
and can not be evaluated. Static semantic rule violations are early
errors (see clause 16) and reported in the same manner as syntax errors.

ECMAScript source text is represented as a sequence of characters in the
Unicode character encoding, version 3.0 or later. The text is expected
to have been normalised to Unicode Normalization Form C (canonical
composition), as described in Unicode Technical Report #15. Conforming
ECMAScript implementations are not required to perform any normalisation
of text, or behave as though they were performing normalisation of text,
themselves. ECMAScript source text is assumed to be a sequence of 16-bit
code units for the purposes of this specification. Such a source text
may include sequences of 16-bit code units that are not valid UTF-16
character encodings. If an actual source text is encoded in a form other
than 16-bit code units it must be processed as if it was first converted
to UTF-16.

Syntax

SourceCharacter ::

any Unicode code unit

Throughout the rest of this document, the phrase “code unit” and the
word “character” will be used to refer to a 16-bit unsigned value used
to represent a single 16-bit unit of text. The phrase “Unicode
character” will be used to refer to the abstract linguistic or
typographical unit represented by a single Unicode scalar value (which
may be longer than 16 bits and thus may be represented by more than one
code unit). The phrase “code point” refers to such a Unicode scalar
value. “Unicode character” only refers to entities represented by single
Unicode scalar values: the components of a combining character sequence
are still individual “Unicode characters,” even though a user might
think of the whole sequence as a single character.

In string literals, regular expression literals, and identifiers, any
character (code unit) may also be expressed as a Unicode escape sequence
consisting of six characters, namely \U plus four hexadecimal digits.
Within a comment, such an escape sequence is effectively ignored as part
of the comment. Within a string literal or regular expression literal,
the Unicode escape sequence contributes one character to the value of
the literal. Within an identifier, the escape sequence contributes one
character to the identifier.

NOTE Although this document sometimes refers to a “transformation”
between a “character” within a “string” and the 16-bit unsigned integer
that is the code unit of that character, there is actually no
transformation because a “character” within a “string” is actually
represented using that 16-bit unsigned value.

ECMAScript differs from the Java programming language in the behaviour
of Unicode escape sequences. In a Java program, if the Unicode escape
sequence \U000A, for example, occurs within a single-line comment, it is
interpreted as a line terminator (Unicode character 000A is line feed)
and therefore the next character is not part of the comment. Similarly,
if the Unicode escape sequence \U000A occurs within a string literal in
a Java program, it is likewise interpreted as a line terminator, which
is not allowed within a string literal—one must write \N instead of
\U000A to cause a line feed to be part of the string value of a string
literal. In an ECMAScript program, a Unicode escape sequence occurring
within a comment is never interpreted and therefore cannot contribute to
termination of the comment. Similarly, a Unicode escape sequence
occurring within a string literal in an ECMAScript program always
contributes a character to the String value of the literal and is never
interpreted as a line terminator or as a quote mark that might terminate
the string literal.

The source text of an ECMAScript program is first converted into a
sequence of input elements, which are tokens, line terminators,
comments, or white space. The source text is scanned from left to right,
repeatedly taking the longest possible sequence of characters as the
next input element.

There are two goal symbols for the lexical grammar. The
_InputElementDiv_ symbol is used in those syntactic grammar contexts
where a leading division (/) or division-assignment (/=) operator is
permitted. The _InputElementRegExp_ symbol is used in other syntactic
grammar contexts.

NOTE There are no syntactic grammar contexts where both a leading
division or division-assignment, and a leading
_RegularExpressionLiteral_ are permitted. This is not affected by
semicolon insertion (see 7.9); in examples such as the following:

  A = B
  /HI/G.EXEC(C).MAP(D);

where the first non-whitespace, non-comment character after a
_LineTerminator_ is slash (/) and the syntactic context allows division
or division-assignment, no semicolon is inserted at the
_LineTerminator_. That is, the above example is interpreted in the same
way as:

  A = B / HI / G.EXEC(C).MAP(D);

Syntax

InputElementDiv ::

WhiteSpace
LineTerminator
Comment
Token
DivPunctuator

InputElementRegExp ::

WhiteSpace
LineTerminator
Comment
Token
RegularExpressionLiteral

The Unicode format-control characters (i.e., the characters in category
“Cf” in the Unicode Character Database such as LEFT-TO-RIGHT MARK or
RIGHT-TO-LEFT MARK) are control codes used to control the formatting of
a range of text in the absence of higher-level protocols for this (such
as mark-up languages).

It is useful to allow format-control characters in source text to
facilitate editing and display. All format control characters may be
used within comments, and within string literals and regular expression
literals.

<ZWNJ> and <ZWJ> are format-control characters that are used to make
necessary distinctions when forming words or phrases in certain
languages. In ECMAScript source text, <ZWNJ> and <ZWJ> may also be used
in an identifier after the first character.

<BOM> is a format-control character used primarily at the start of a
text to mark it as Unicode and to allow detection of the text's encoding
and byte order. <BOM> characters intended for this purpose can sometimes
also appear after the start of a text, for example as a result of
concatenating files. <BOM> characters are treated as white space
characters (see 7.2).

The special treatment of certain format-control characters outside of
comments, string literals, and regular expression literals is summarised
in Table 1.

Table 1 — Format-Control Character Usage

  ------------------- ----------------------- --------------- ------------------
  _CODE UNIT VALUE_   _NAME_                  _FORMAL NAME_   _USAGE_
  \U200C              Zero width non-joiner   <ZWNJ>          _IdentifierPart_
  \U200D              Zero width joiner       <ZWJ>           _IdentifierPart_
  \UFEFF              Byte Order Mark         <BOM>           _Whitespace_
  ------------------- ----------------------- --------------- ------------------

White space characters are used to improve source text readability and
to separate tokens (indivisible lexical units) from each other, but are
otherwise insignificant. White space characters may occur between any
two tokens and at the start or end of input. White space characters may
also occur within a _StringLiteral_ or a _RegularExpressionLiteral_
(where they are considered significant characters forming part of the
literal value) or within a _Comment_, but cannot appear within any other
kind of token.

The ECMAScript white space characters are listed in Table 2.

Table 2 — Whitespace Characters

  --------------------- ------------------------------------- ---------------
  _CODE UNIT VALUE_     _NAME_                                _FORMAL NAME_

  \U0009                Tab                                   <TAB>

  \U000B                Vertical Tab                          <VT>

  \U000C                Form Feed                             <FF>

  \U0020                Space                                 <SP>

  \U00A0                No-break space                        <NBSP>

  \UFEFF                Byte Order Mark                       <BOM>
                                                              
  Other category “Zs”   Any other Unicode “space separator”   <USP>
  --------------------- ------------------------------------- ---------------

ECMAScript implementations must recognise all of the white space
characters defined in Unicode 3.0. Later editions of the Unicode
Standard may define other white space characters. ECMAScript
implementations may recognise white space characters from later editions
of the Unicode Standard.

Syntax

WhiteSpace ::

<TAB>
<VT>
<FF>
<SP>
<NBSP>
<BOM>
<USP>

Like white space characters, line terminator characters are used to
improve source text readability and to separate tokens (indivisible
lexical units) from each other. However, unlike white space characters,
line terminators have some influence over the behaviour of the syntactic
grammar. In general, line terminators may occur between any two tokens,
but there are a few places where they are forbidden by the syntactic
grammar. Line terminators also affect the process of automatic semicolon
insertion (7.9). A line terminator cannot occur within any token except
a _StringLiteral_. Line terminators may only occur within a
_StringLiteral_ token as part of a _LineContinuation_.

A line terminator can occur within a _MultiLineComment_ (7.4) but cannot
occur within a _SingleLineComment_.

Line terminators are included in the set of white space characters that
are matched by the \S class in regular expressions.

The ECMAScript line terminator characters are listed in Table 3.

Table 3 — Line Terminator Characters

  ------------------- --------------------- ---------------
  _CODE UNIT VALUE_   _NAME_                _FORMAL NAME_
  \U000A              Line Feed             <LF>
  \U000D              Carriage Return       <CR>
  \U2028              Line separator        <LS>
  \U2029              Paragraph separator   <PS>
  ------------------- --------------------- ---------------

Only the characters in Table 3 are treated as line terminators. Other
new line or line breaking characters are treated as white space but not
as line terminators. The character sequence <CR><LF> is commonly used as
a line terminator. It should be considered a single character for the
purpose of reporting line numbers.

Syntax

LineTerminator ::

<LF>
<CR>
<LS>
<PS>

LineTerminatorSequence ::

<LF>
<CR> [lookahead ∉ <LF> ]
<LS>
<PS>
<CR> <LF>

Comments can be either single or multi-line. Multi-line comments cannot
nest.

Because a single-line comment can contain any character except a
_LineTerminator_ character, and because of the general rule that a token
is always as long as possible, a single-line comment always consists of
all characters from the // marker to the end of the line. However, the
_LineTerminator_ at the end of the line is not considered to be part of
the single-line comment; it is recognised separately by the lexical
grammar and becomes part of the stream of input elements for the
syntactic grammar. This point is very important, because it implies that
the presence or absence of single-line comments does not affect the
process of automatic semicolon insertion (see 7.9).

Comments behave like white space and are discarded except that, if a
_MultiLineComment_ contains a line terminator character, then the entire
comment is considered to be a _LineTerminator_ for purposes of parsing
by the syntactic grammar.

Syntax

Comment ::

MultiLineComment
SingleLineComment

MultiLineComment ::

/* MultiLineCommentChars~opt~ */

MultiLineCommentChars ::

MultiLineNotAsteriskChar MultiLineCommentChars~opt~
* PostAsteriskCommentChars~opt~

PostAsteriskCommentChars ::

MultiLineNotForwardSlashOrAsteriskChar MultiLineCommentChars~opt~
* PostAsteriskCommentChars~opt~

MultiLineNotAsteriskChar ::

SourceCharacter BUT NOT *

MultiLineNotForwardSlashOrAsteriskChar ::

SourceCharacter BUT NOT ONE OF / OR *

SingleLineComment ::

// SingleLineCommentChars~opt~

SingleLineCommentChars ::

SingleLineCommentChar SingleLineCommentChars~opt~

SingleLineCommentChar ::

SourceCharacter BUT NOT LineTerminator

Syntax

Token ::

IdentifierName
Punctuator
NumericLiteral
StringLiteral

NOTE The _DivPunctuator_ and _RegularExpressionLiteral_ productions
define tokens, but are not included in the _Token_ production.

Identifier Names are tokens that are interpreted according to the
grammar given in the “Identifiers” section of chapter 5 of the Unicode
standard, with some small modifications. An _Identifier_ is an
_IdentifierName_ that is not a _ReservedWord_ (see 7.6.1). The Unicode
identifier grammar is based on both normative and informative character
categories specified by the Unicode Standard. The characters in the
specified categories in version 3.0 of the Unicode standard must be
treated as in those categories by all conforming ECMAScript
implementations.

This standard specifies specific character additions: The dollar sign
($) and the underscore (_) are permitted anywhere in an
_IdentifierName_.

Unicode escape sequences are also permitted in an _IdentifierName_,
where they contribute a single character to the _IdentifierName_, as
computed by the CV of the _UnicodeEscapeSequence_ (see 7.8.4). The \
preceding the _UnicodeEscapeSequence_ does not contribute a character to
the _IdentifierName_. A _UnicodeEscapeSequence_ cannot be used to put a
character into an _IdentifierName_ that would otherwise be illegal. In
other words, if a \ _UnicodeEscapeSequence_ sequence were replaced by
its _UnicodeEscapeSequence_'s CV, the result must still be a valid
_IdentifierName_ that has the exact same sequence of characters as the
original _IdentifierName_. All interpretations of identifiers within
this specification are based upon their actual characters regardless of
whether or not an escape sequence was used to contribute any particular
characters.

Two _IdentifierName_ that are canonically equivalent according to the
Unicode standard are _not_ equal unless they are represented by the
exact same sequence of code units (in other words, conforming ECMAScript
implementations are only required to do bitwise comparison on
IdentifierName values). The intent is that the incoming source text has
been converted to normalised form C before it reaches the compiler.

ECMAScript implementations may recognise identifier characters defined
in later editions of the Unicode Standard. If portability is a concern,
programmers should only employ identifier characters defined in Unicode
3.0.

Syntax

Identifier ::

IdentifierName BUT NOT ReservedWord

IdentifierName ::

IdentifierStart
IdentifierName IdentifierPart

IdentifierStart ::

UnicodeLetter
$
_
\ UnicodeEscapeSequence

IdentifierPart ::

IdentifierStart
UnicodeCombiningMark
UnicodeDigit
UnicodeConnectorPunctuation
<ZWNJ>
<ZWJ>

UnicodeLetter ::

any character in the Unicode categories “Uppercase letter (Lu)”,
“Lowercase letter (Ll)”, “Titlecase letter (Lt)”, “Modifier letter
(Lm)”, “Other letter (Lo)”, or “Letter number (Nl)”.

UnicodeCombiningMark ::

any character in the Unicode categories “Non-spacing mark (Mn)” or
“Combining spacing mark (Mc)”

UnicodeDigit ::

any character in the Unicode category “Decimal number (Nd)”

UnicodeConnectorPunctuation ::

any character in the Unicode category “Connector punctuation (Pc)”

The definitions of the nonterminal _UnicodeEscapeSequence_ is given in
7.8.

Semantics

The String value of the production _Identifier_ :: _IdentifierName_ BUT
NOT _ReservedWord_ is determined as follows:

1.  Return the String value consisting of _IdentifierName_.

The String value of _IdentifierName_ is determined as follows:

1.  Return the String value consisting of the sequence of characters
    corresponding to _IdentifierName_.

A reserved word is an _IdentifierName_ that cannot be used as an
_Identifier_.

Syntax

ReservedWord ::

Keyword
FutureReservedWord
NullLiteral
BooleanLiteral

The following tokens are ECMAScript keywords and may not be used as
_Identifiers_ in ECMAScript programs.

Syntax

Keyword :: ONE OF

  ---------- ---------- ------------ --------
  break      do         instanceof   typeof
  case       else       new          var
  catch      finally    return       void
  continue   for        switch       while
  debugger   function   this         with
  default    if         throw        
  delete     in         try          
  ---------- ---------- ------------ --------

The following words are used as keywords in proposed extensions and are
therefore reserved to allow for the possibility of future adoption of
those extensions.

Syntax

FutureReservedWord :: ONE OF

  ------- -------- --------- -------
  class   enum     extends   super
  const   export   import    
  ------- -------- --------- -------

The following tokens are also considered to be _FutureReservedWords_
when they occur within strict mode code (see 10.1.1). The occurrence of
any of these tokens within strict mode code in any context where the
occurrence of a _FutureReservedWord_ would produce an error must also
produce an equivalent error:

  ------------ --------- ----------- -------- -------
  implements   let       private     public   yield
  interface    package   protected   static   
  ------------ --------- ----------- -------- -------

Syntax

Punctuator :: ONE OF

  ----- ------ ----- ----- ----- -----
  {     }      (     )     [     ]
  .     ;      ,     <     >     <=
  >=    ==     !=    ===   !==   
  +     -      *     %     ++    --
  <<    >>     >>>   &     |     ^
  !     ~      &&    ||    ?     :
  =     +=     -=    *=    %=    <<=
  >>=   >>>=   &=    |=    ^=    
  ----- ------ ----- ----- ----- -----

DivPunctuator :: ONE OF

  --- ---- -- -- -- --
  /   /=            
  --- ---- -- -- -- --

Syntax

Literal ::

NullLiteral
BooleanLiteral
NumericLiteral
StringLiteral
RegularExpressionLiteral

Syntax

NullLiteral ::

NULL

Semantics

The value of the null literal NULL is the sole value of the Null type,
namely NULL.

Syntax

BooleanLiteral ::

TRUE
FALSE

Semantics

The value of the Boolean literal TRUE is a value of the Boolean type,
namely TRUE.

The value of the Boolean literal FALSE is a value of the Boolean type,
namely FALSE.

Syntax

NumericLiteral ::

DecimalLiteral
HexIntegerLiteral

DecimalLiteral ::

DecimalIntegerLiteral . DecimalDigits~opt~ ExponentPart~opt~
. DecimalDigits ExponentPart~opt~
DecimalIntegerLiteral ExponentPart~opt~

DecimalIntegerLiteral ::

0
NonZeroDigit DecimalDigits~opt~

DecimalDigits ::

DecimalDigit
DecimalDigits DecimalDigit

DecimalDigit :: ONE OF

0 1 2 3 4 5 6 7 8 

NonZeroDigit :: ONE OF

1 2 3 4 5 6 7 8 

ExponentPart ::

ExponentIndicator SignedInteger

ExponentIndicator :: ONE OF

E E

SignedInteger ::

DecimalDigits
+ DecimalDigits
- DecimalDigits

HexIntegerLiteral ::

0X HexDigit
0X HexDigit
HexIntegerLiteral HexDigit

HexDigit :: one of

0 1 2 3 4 5 6 7 8 9 A B C D E F A B C D E F

The source character immediately following a _NumericLiteral_ must not
be an _IdentifierStart_ or _DecimalDigit_.

NOTE For example:

  3in

is an error and not the two input elements 3 and IN.

Semantics

A numeric literal stands for a value of the Number type. This value is
determined in two steps: first, a mathematical value (MV) is derived
from the literal; second, this mathematical value is rounded as
described below.

-   The MV of _NumericLiteral_ :: _DecimalLiteral_ is the MV of
    _DecimalLiteral_.

-   The MV of _NumericLiteral_ :: _HexIntegerLiteral_ is the MV of
    _HexIntegerLiteral_.

-   The MV of _DecimalLiteral_ :: _DecimalIntegerLiteral_ . is the MV of
    _DecimalIntegerLiteral_.

-   The MV of _DecimalLiteral_ :: _DecimalIntegerLiteral_ .
    _DecimalDigits_ is the MV of _DecimalIntegerLiteral_ plus (the MV of
    _DecimalDigits_ times 10^–_n_^), where _n_ is the number of
    characters in _DecimalDigit_s.

-   The MV of _DecimalLiteral_ :: _DecimalIntegerLiteral_ .
    _ExponentPart_ is the MV of _DecimalIntegerLiteral_ times 10_^e^_,
    where _e_ is the MV of _ExponentPart_.

-   The MV of _DecimalLiteral_ :: _DecimalIntegerLiteral_ .
    _DecimalDigits ExponentPart_ is (the MV of _DecimalIntegerLiteral_
    plus (the MV of _DecimalDigits_ times 10^–_n_^)) times 10_^e^_,
    where _n_ is the number of characters in _DecimalDigit_s and e is
    the MV of _ExponentPart_.

-   The MV of _DecimalLiteral_ ::. _DecimalDigits_ is the MV of
    _DecimalDigits_ times 10^–_n_^, where _n_ is the number of
    characters in _DecimalDigit_s.

-   The MV of _DecimalLiteral_ ::. _DecimalDigits ExponentPart_ is the
    MV of _DecimalDigits_ times 10^_e_–_n_^, where _n_ is the number of
    characters in _DecimalDigit_s and _e_ is the MV of _ExponentPart_.

-   The MV of _DecimalLiteral_ :: _DecimalIntegerLiteral_ is the MV of
    _DecimalIntegerLiteral_.

-   The MV of _DecimalLiteral_ :: _DecimalIntegerLiteral ExponentPart_
    is the MV of _DecimalIntegerLiteral_ times 10_^e^_, where _e_ is the
    MV of _ExponentPart_.

-   The MV of _DecimalIntegerLiteral_ :: 0 is 0.

-   The MV of _DecimalIntegerLiteral_ :: _NonZeroDigit_ is the MV of
    _NonZeroDigit._

-   The MV of _DecimalIntegerLiteral_ :: _NonZeroDigit_ _DecimalDigits_
    is (the MV of _NonZeroDigit_ times 10_^n^_) plus the MV of
    _DecimalDigits_, where _n_ is the number of characters in
    _DecimalDigits_.

-   The MV of _DecimalDigits_ :: _DecimalDigit_ is the MV of
    _DecimalDigit_.

-   The MV of _DecimalDigits_ :: _DecimalDigits_ _DecimalDigit_ is (the
    MV of _DecimalDigits_ times 10) plus the MV of _DecimalDigit_.

-   The MV of _ExponentPart_ :: _ExponentIndicator SignedInteger_ is the
    MV of _SignedInteger_.

-   The MV of _SignedInteger_ :: _DecimalDigits_ is the MV of
    _DecimalDigits_.

-   The MV of _SignedInteger_ :: + _DecimalDigits_ is the MV of
    _DecimalDigits_.

-   The MV of _SignedInteger_ :: - _DecimalDigits_ is the negative of
    the MV of _DecimalDigits_.

-   The MV of _DecimalDigit_ :: 0 or of _HexDigit_ :: 0 is 0.

-   The MV of _DecimalDigit_ :: 1 or of _NonZeroDigit_ :: 1 or of
    _HexDigit_ :: 1 is 1.

-   The MV of _DecimalDigit_ :: 2 or of _NonZeroDigit_ :: 2 or of
    _HexDigit_ :: 2 is 2.

-   The MV of _DecimalDigit_ :: 3 or of _NonZeroDigit_ :: 3 or of
    _HexDigit_ :: 3 is 3.

-   The MV of _DecimalDigit_ :: 4 or of _NonZeroDigit_ :: 4 or of
    _HexDigit_ :: 4 is 4.

-   The MV of _DecimalDigit_ :: 5 or of _NonZeroDigit_ :: 5 or of
    _HexDigit_ :: 5 is 5.

-   The MV of _DecimalDigit_ :: 6 or of _NonZeroDigit_ :: 6 or of
    _HexDigit_ :: 6 is 6.

-   The MV of _DecimalDigit_ :: 7 or of _NonZeroDigit_ :: 7 or of
    _HexDigit_ :: 7 is 7.

-   The MV of _DecimalDigit_ :: 8 or of _NonZeroDigit_ :: 8 or of
    _HexDigit_ :: 8 is 8.

-   The MV of _DecimalDigit_ :: 9 or of _NonZeroDigit_ :: 9 or of
    _HexDigit_ :: 9 is 9.

-   The MV of _HexDigit_ :: A or of _HexDigit_ :: A is 10.

-   The MV of _HexDigit_ :: B or of _HexDigit_ :: B is 11.

-   The MV of _HexDigit_ :: C or of _HexDigit_ :: C is 12.

-   The MV of _HexDigit_ :: D or of _HexDigit_ :: D is 13.

-   The MV of _HexDigit_ :: E or of _HexDigit_ :: E is 14.

-   The MV of _HexDigit_ :: F or of _HexDigit_ :: F is 15.

-   The MV of _HexIntegerLiteral_ :: 0X _HexDigit_ is the MV of
    _HexDigit_.

-   The MV of _HexIntegerLiteral_ :: 0X _HexDigit_ is the MV of
    _HexDigit_.

-   The MV of _HexIntegerLiteral_ :: _HexIntegerLiteral_ _HexDigit_ is
    (the MV of _HexIntegerLiteral_ times 16) plus the MV of _HexDigit_.

Once the exact MV for a numeric literal has been determined, it is then
rounded to a value of the Number type. If the MV is 0, then the rounded
value is +0; otherwise, the rounded value must be the Number value for
the MV (as specified in 8.5), unless the literal is a _DecimalLiteral_
and the literal has more than 20 significant digits, in which case the
Number value may be either the Number value for the MV of a literal
produced by replacing each significant digit after the 20th with a 0
digit or the Number value for the MV of a literal produced by replacing
each significant digit after the 20th with a 0 digit and then
incrementing the literal at the 20th significant digit position. A digit
is _significant_ if it is not part of an _ExponentPart_ and

-   it is not 0; or

-   there is a nonzero digit to its left and there is a nonzero digit,
    not in the _ExponentPart_, to its right.

A conforming implementation, when processing strict mode code (see
10.1.1), must not extend the syntax of _NumericLiteral_ to include
_OctalIntegerLiteral_ as described in B.1.1.

A string literal is zero or more characters enclosed in single or double
quotes. Each character may be represented by an escape sequence. All
characters may appear literally in a string literal except for the
closing quote character, backslash, carriage return, line separator,
paragraph separator, and line feed. Any character may appear in the form
of an escape sequence.

Syntax

StringLiteral ::

" DoubleStringCharacters~opt~ "
' SingleStringCharacters~opt~ '

DoubleStringCharacters ::

DoubleStringCharacter DoubleStringCharacters~opt~

SingleStringCharacters ::

SingleStringCharacter SingleStringCharacters~opt~

DoubleStringCharacter ::

SourceCharacter BUT NOT ONE OF " OR \ OR LineTerminator
\ EscapeSequence
LineContinuation

SingleStringCharacter ::

SourceCharacter BUT NOT ONE OF ' OR \ OR LineTerminator
\ EscapeSequence
LineContinuation

LineContinuation ::

\ LineTerminatorSequence

EscapeSequence ::

CharacterEscapeSequence
0 [lookahead ∉ DecimalDigit]
HexEscapeSequence
UnicodeEscapeSequence

CharacterEscapeSequence ::

SingleEscapeCharacter
NonEscapeCharacter

SingleEscapeCharacter :: ONE OF

' " \ B F N R T V

NonEscapeCharacter ::

SourceCharacter BUT NOT ONE OF EscapeCharacter OR LineTerminator

EscapeCharacter ::

SingleEscapeCharacter
DecimalDigit
X
U

HexEscapeSequence ::

X HexDigit HexDigit

UnicodeEscapeSequence ::

U HexDigit HexDigit HexDigit HexDigit

The definition of the nonterminal _HexDigit_ is given in 7.8.3.
_SourceCharacter_ is defined in clause 6.

Semantics

A string literal stands for a value of the String type. The String value
(SV) of the literal is described in terms of character values (CV)
contributed by the various parts of the string literal. As part of this
process, some characters within the string literal are interpreted as
having a mathematical value (MV), as described below or in 7.8.3.

-   The SV of _StringLiteral_ :: "" is the empty character sequence.

-   The SV of _StringLiteral_ :: '' is the empty character sequence.

-   The SV of _StringLiteral_ :: " _DoubleStringCharacters_ " is the SV
    of _DoubleStringCharacters_.

-   The SV of _StringLiteral_ :: ' _SingleStringCharacters_ ' is the SV
    of _SingleStringCharacters_.

-   The SV of _DoubleStringCharacters_ :: _DoubleStringCharacter_ is a
    sequence of one character, the CV of _DoubleStringCharacter_.

-   The SV of _DoubleStringCharacters_ :: _DoubleStringCharacter_
    _DoubleStringCharacters_ is a sequence of the CV of
    _DoubleStringCharacter_ followed by all the characters in the SV of
    _DoubleStringCharacters_ in order.

-   The SV of _SingleStringCharacters_ :: _SingleStringCharacter_ is a
    sequence of one character, the CV of _SingleStringCharacter_.

-   The SV of _SingleStringCharacters_ :: _SingleStringCharacter_
    _SingleStringCharacters_ is a sequence of the CV of
    _SingleStringCharacter_ followed by all the characters in the SV of
    _SingleStringCharacters_ in order.

-   The SV of _LineContinuation_ :: \ _LineTerminatorSequence_ is the
    empty character sequence.

-   The CV of _DoubleStringCharacter_ :: _SourceCharacter_ BUT NOT ONE
    OF " OR \ OR _LineTerminator_ is the _SourceCharacter_ character
    itself.

-   The CV of _DoubleStringCharacter_ :: \ _EscapeSequence_ is the CV of
    the _EscapeSequence_.

-   The CV of _DoubleStringCharacter_ :: _LineContinuation_ is the empty
    character sequence.

-   The CV of _SingleStringCharacter_ :: _SourceCharacter_ BUT NOT ONE
    OF ' OR \ OR _LineTerminator_ is the _SourceCharacter_ character
    itself.

-   The CV of _SingleStringCharacter_ :: \ _EscapeSequence_ is the CV of
    the _EscapeSequence_.

-   The CV of _SingleStringCharacter_ :: _LineContinuation_ is the empty
    character sequence.

-   The CV of _EscapeSequence_ :: _CharacterEscapeSequence_ is the CV of
    the _CharacterEscapeSequence_.

-   The CV of _EscapeSequence_ :: 0 [lookahead ∉ _DecimalDigit_] is a
    <NUL> character (Unicode value 0000).

-   The CV of _EscapeSequence_ :: _HexEscapeSequence_ is the CV of the
    _HexEscapeSequence_.

-   The CV of _EscapeSequence_ :: _UnicodeEscapeSequence_ is the CV of
    the _UnicodeEscapeSequence_.

-   The CV of _CharacterEscapeSequence_ :: _SingleEscapeCharacter_ is
    the character whose code unit value is determined by the
    _SingleEscapeCharacter_ according to Table 4:

Table 4 — String Single Character Escape Sequences

  ------------------- ------------------- ---------------------- ----------
  _ESCAPE SEQUENCE_   _CODE UNIT VALUE_   _NAME_                 _SYMBOL_
  \B                  \U0008              backspace              <BS>
  \T                  \U0009              horizontal tab         <HT>
  \N                  \U000A              line feed (new line)   <LF>
  \V                  \U000B              vertical tab           <VT>
  \F                  \U000C              form feed              <FF>
  \R                  \U000D              carriage return        <CR>
  \"                  \U0022              double quote           "
  \'                  \U0027              single quote           '
  \\                  \U005C              backslash              \
  ------------------- ------------------- ---------------------- ----------

-   The CV of _CharacterEscapeSequence_ :: _NonEscapeCharacter_ is the
    CV of the _NonEscapeCharacter_.

-   The CV of _NonEscapeCharacter_ :: _SourceCharacter_ BUT NOT ONE OF
    _EscapeCharacter_ OR _LineTerminator_ is the _SourceCharacter_
    character itself.

-   The CV of _HexEscapeSequence_ :: X _HexDigit_ _HexDigit_ is the
    character whose code unit value is (16 times the MV of the first
    _HexDigit_) plus the MV of the second _HexDigit_.

-   The CV of _UnicodeEscapeSequence_ :: U _HexDigit_ _HexDigit_
    _HexDigit_ _HexDigit_ is the character whose code unit value is
    (4096 times the MV of the first _HexDigit_) plus (256 times the MV
    of the second _HexDigit_) plus (16 times the MV of the third
    _HexDigit_) plus the MV of the fourth _HexDigit_.

A conforming implementation, when processing strict mode code (see
10.1.1), may not extend the syntax of _EscapeSequence_ to include
_OctalEscapeSequence_ as described in B.1.2.

NOTE A line terminator character cannot appear in a string literal,
except as part of a _LineContinuation_ to produce the empty character
sequence. The correct way to cause a line terminator character to be
part of the String value of a string literal is to use an escape
sequence such as \N or \U000A.

A regular expression literal is an input element that is converted to a
RegExp object (see 15.10) each time the literal is evaluated. Two
regular expression literals in a program evaluate to regular expression
objects that never compare as === to each other even if the two
literals' contents are identical. A RegExp object may also be created at
runtime by NEW REGEXP (see 15.10.4) or calling the REGEXP constructor as
a function (15.10.3).

The productions below describe the syntax for a regular expression
literal and are used by the input element scanner to find the end of the
regular expression literal. The Strings of characters comprising the
_RegularExpressionBody_ and the _RegularExpressionFlags_ are passed
uninterpreted to the regular expression constructor, which interprets
them according to its own, more stringent grammar. An implementation may
extend the regular expression constructor's grammar, but it must not
extend the _RegularExpressionBody_ and _RegularExpressionFlags_
productions or the productions used by these productions.

Syntax

RegularExpressionLiteral ::

/ RegularExpressionBody / RegularExpressionFlags

RegularExpressionBody ::

RegularExpressionFirstChar RegularExpressionChars

RegularExpressionChars ::

[empty]
RegularExpressionChars RegularExpressionChar

RegularExpressionFirstChar ::

RegularExpressionNonTerminator BUT NOT ONE OF * OR \ OR / OR [
RegularExpressionBackslashSequence
RegularExpressionClass

RegularExpressionChar ::

RegularExpressionNonTerminator BUT NOT ONE OF \ OR / OR [
RegularExpressionBackslashSequence
RegularExpressionClass

RegularExpressionBackslashSequence ::

\ RegularExpressionNonTerminator

RegularExpressionNonTerminator ::

SourceCharacter BUT NOT LineTerminator

RegularExpressionClass ::

[ RegularExpressionClassChars ]

RegularExpressionClassChars ::

[empty]
RegularExpressionClassChars RegularExpressionClassChar

RegularExpressionClassChar ::

RegularExpressionNonTerminator BUT NOT ONE OF ] OR \
RegularExpressionBackslashSequence

RegularExpressionFlags ::

[empty]
RegularExpressionFlags IdentifierPart

NOTE Regular expression literals may not be empty; instead of
representing an empty regular expression literal, the characters //
start a single-line comment. To specify an empty regular expression,
use: /(?:)/.

Semantics

A regular expression literal evaluates to a value of the Object type
that is an instance of the standard built-in constructor RegExp. This
value is determined in two steps: first, the characters comprising the
regular expression's _RegularExpressionBody_ and
_RegularExpressionFlags_ production expansions are collected
uninterpreted into two Strings Pattern and Flags, respectively. Then
each time the literal is evaluated, a new object is created as if by the
expression NEW REGEXP(Pattern, Flags) where RegExp is the standard
built-in constructor with that name. The newly constructed object
becomes the value of the _RegularExpressionLiteral_. If the call to NEW
REGEXP would generate an error as specified in 15.10.4.1, the error must
be treated as an early error (Clause 16).

Certain ECMAScript statements (empty statement, variable statement,
expression statement, DO-WHILE statement, CONTINUE statement, BREAK
statement, RETURN statement, and THROW statement) must be terminated
with semicolons. Such semicolons may always appear explicitly in the
source text. For convenience, however, such semicolons may be omitted
from the source text in certain situations. These situations are
described by saying that semicolons are automatically inserted into the
source code token stream in those situations.

There are three basic rules of semicolon insertion:

1.  When, as the program is parsed from left to right, a token (called
    the _offending token_) is encountered that is not allowed by any
    production of the grammar, then a semicolon is automatically
    inserted before the offending token if one or more of the following
    conditions is true:

-   The offending token is separated from the previous token by at least
    one _LineTerminator_.

-   The offending token is }.

    1.  When, as the program is parsed from left to right, the end of
        the input stream of tokens is encountered and the parser is
        unable to parse the input token stream as a single complete
        ECMAScript _Program_, then a semicolon is automatically inserted
        at the end of the input stream.

    2.  When, as the program is parsed from left to right, a token is
        encountered that is allowed by some production of the grammar,
        but the production is a _restricted production_ and the token
        would be the first token for a terminal or nonterminal
        immediately following the annotation “[no _LineTerminator_
        here]” within the restricted production (and therefore such a
        token is called a restricted token), and the restricted token is
        separated from the previous token by at least one
        _LineTerminator_, then a semicolon is automatically inserted
        before the restricted token.

However, there is an additional overriding condition on the preceding
rules: a semicolon is never inserted automatically if the semicolon
would then be parsed as an empty statement or if that semicolon would
become one of the two semicolons in the header of a FOR statement (see
12.6.3).

NOTE The following are the only restricted productions in the grammar:

PostfixExpression :

LeftHandSideExpression [no LineTerminator here] ++
LeftHandSideExpression [no LineTerminator here] --

ContinueStatement :

CONTINUE [no LineTerminator here] Identifier ;

BreakStatement :

BREAK [no LineTerminator here] Identifier ;

ReturnStatement :

RETURN [no LineTerminator here] Expression ;

ThrowStatement :

THROW [no LineTerminator here] Expression ;

The practical effect of these restricted productions is as follows:

  When a ++ or -- token is encountered where the parser would treat it
  as a postfix operator, and at least one _LineTerminator_ occurred
  between the preceding token and the ++ or -- token, then a semicolon
  is automatically inserted before the ++ or -- token.

  When a CONTINUE, BREAK, RETURN, or THROW token is encountered and a
  _LineTerminator_ is encountered before the next token, a semicolon is
  automatically inserted after the CONTINUE, BREAK, RETURN, or THROW
  token.

  The resulting practical advice to ECMAScript programmers is:

  A postfix ++ or -- operator should appear on the same line as its
  operand.

  An _Expression_ in a RETURN or THROW statement should start on the
  same line as the RETURN or THROW token.

  An _Identifier_ in a BREAK or CONTINUE statement should be on the same
  line as the BREAK or CONTINUE token.

The source

  { 1 2 } 3

is not a valid sentence in the ECMAScript grammar, even with the
automatic semicolon insertion rules. In contrast, the source

  { 1
  2 } 3

is also not a valid ECMAScript sentence, but is transformed by automatic
semicolon insertion into the following:

  { 1
  ;2 ;} 3;

which is a valid ECMAScript sentence.

The source

  for (a; b
  )

is not a valid ECMAScript sentence and is not altered by automatic
semicolon insertion because the semicolon is needed for the header of a
FOR statement. Automatic semicolon insertion never inserts one of the
two semicolons in the header of a FOR statement.

The source

  return
  a + b

is transformed by automatic semicolon insertion into the following:

  return;
  a + b;

NOTE The expression A + B is not treated as a value to be returned by
the RETURN statement, because a _LineTerminator_ separates it from the
token RETURN.

The source

  a = b
  ++c

is transformed by automatic semicolon insertion into the following:

  a = b;
  ++c;

NOTE The token ++ is not treated as a postfix operator applying to the
variable B, because a _LineTerminator_ occurs between B and ++.

The source

  if (a > b)
  else c = d

is not a valid ECMAScript sentence and is not altered by automatic
semicolon insertion before the ELSE token, even though no production of
the grammar applies at that point, because an automatically inserted
semicolon would then be parsed as an empty statement.

The source

  a = b + c
  (d + e).print()

is _not_ transformed by automatic semicolon insertion, because the
parenthesised expression that begins the second line can be interpreted
as an argument list for a function call:

a = b + c(d + e).print()

In the circumstance that an assignment statement must begin with a left
parenthesis, it is a good idea for the programmer to provide an explicit
semicolon at the end of the preceding statement rather than to rely on
automatic semicolon insertion.

Algorithms within this specification manipulate values each of which has
an associated type. The possible value types are exactly those defined
in this clause. Types are further subclassified into ECMAScript language
types and specification types.

An ECMAScript language type corresponds to values that are directly
manipulated by an ECMAScript programmer using the ECMAScript language.
The ECMAScript language types are Undefined, Null, Boolean, String,
Number, and Object.

A specification type corresponds to meta-values that are used within
algorithms to describe the semantics of ECMAScript language constructs
and ECMAScript language types. The specification types are Reference,
List, Completion, Property Descriptor, Property Identifier, Lexical
Environment, and Environment Record. Specification type values are
specification artefacts that do not necessarily correspond to any
specific entity within an ECMAScript implementation. Specification type
values may be used to describe intermediate results of ECMAScript
expression evaluation but such values cannot be stored as properties of
objects or values of ECMAScript language variables.

Within this specification, the notation “Type(_x_)” is used as shorthand
for “the type of _x_” where “type” refers to the ECMAScript language and
specification types defined in this clause.

The Undefined type has exactly one value, called UNDEFINED. Any variable
that has not been assigned a value has the value UNDEFINED.

The Null type has exactly one value, called NULL.

The Boolean type represents a logical entity having two values, called
TRUE and FALSE.

The String type is the set of all finite ordered sequences of zero or
more 16-bit unsigned integer values (“elements”). The String type is
generally used to represent textual data in a running ECMAScript
program, in which case each element in the String is treated as a code
unit value (see Clause 6). Each element is regarded as occupying a
position within the sequence. These positions are indexed with
nonnegative integers. The first element (if any) is at position 0, the
next element (if any) at position 1, and so on. The length of a String
is the number of elements (i.e., 16-bit values) within it. The empty
String has length zero and therefore contains no elements.

When a String contains actual textual data, each element is considered
to be a single UTF-16 code unit. Whether or not this is the actual
storage format of a String, the characters within a String are numbered
by their initial code unit element position as though they were
represented using UTF-16. All operations on Strings (except as otherwise
stated) treat them as sequences of undifferentiated 16-bit unsigned
integers; they do not ensure the resulting String is in normalised form,
nor do they ensure language-sensitive results.

NOTE The rationale behind this design was to keep the implementation of
Strings as simple and high-performing as possible. The intent is that
textual data coming into the execution environment from outside (e.g.,
user input, text read from a file or received over the network, etc.) be
converted to Unicode Normalised Form C before the running program sees
it. Usually this would occur at the same time incoming text is converted
from its original character encoding to Unicode (and would impose no
additional overhead). Since it is recommended that ECMAScript source
code be in Normalised Form C, string literals are guaranteed to be
normalised (if source text is guaranteed to be normalised), as long as
they do not contain any Unicode escape sequences.

The Number type has exactly 18437736874454810627 (that is,
2^64^−2^53^+3) values, representing the double-precision 64-bit format
IEEE 754 values as specified in the IEEE Standard for Binary
Floating-Point Arithmetic, except that the 9007199254740990 (that is,
2^53^−2) distinct “Not-a-Number” values of the IEEE Standard are
represented in ECMAScript as a single special NAN value. (Note that the
NAN value is produced by the program expression NAN.) In some
implementations, external code might be able to detect a difference
between various Not-a-Number values, but such behaviour is
implementation-dependent; to ECMAScript code, all NaN values are
indistinguishable from each other.

There are two other special values, called POSITIVE INFINITY and
NEGATIVE INFINITY. For brevity, these values are also referred to for
expository purposes by the symbols +∞ and −∞, respectively. (Note that
these two infinite Number values are produced by the program expressions
+INFINITY (or simply INFINITY) and -INFINITY.)

The other 18437736874454810624 (that is, 2^64^−2^53^) values are called
the finite numbers. Half of these are positive numbers and half are
negative numbers; for every finite positive Number value there is a
corresponding negative value having the same magnitude.

Note that there is both a POSITIVE ZERO and a NEGATIVE ZERO. For
brevity, these values are also referred to for expository purposes by
the symbols +0 and −0, respectively. (Note that these two different zero
Number values are produced by the program expressions +0 (or simply 0)
and -0.)

The 18437736874454810622 (that is, 2^64^−2^53^−2) finite nonzero values
are of two kinds:

18428729675200069632 (that is, 2^64^−2^54^) of them are normalised,
having the form

  _s_ × _m_ × 2_^e^_

where _s_ is +1 or −1, _m_ is a positive integer less than 2^53^ but not
less than 2^52^, and _e_ is an integer ranging from −1074 to 971,
inclusive.

The remaining 9007199254740990 (that is, 2^53^−2) values are
denormalised, having the form

  _s_ × _m_ × 2_^e^_

where _s_ is +1 or −1, _m_ is a positive integer less than 2^52^, and
_e_ is −1074.

Note that all the positive and negative integers whose magnitude is no
greater than 2^53^ are representable in the Number type (indeed, the
integer 0 has two representations, +0 and -0).

A finite number has an _odd significand_ if it is nonzero and the
integer _m_ used to express it (in one of the two forms shown above) is
odd. Otherwise, it has an _even significand_.

In this specification, the phrase “the Number value for _x_” where _x_
represents an exact nonzero real mathematical quantity (which might even
be an irrational number such as π) means a Number value chosen in the
following manner. Consider the set of all finite values of the Number
type, with −0 removed and with two additional values added to it that
are not representable in the Number type, namely 2^1024^ (which is +1 ×
2^53^ × 2^971^) and −2^1024^ (which is −1 × 2^53^ × 2^971^). Choose the
member of this set that is closest in value to _x_. If two values of the
set are equally close, then the one with an even significand is chosen;
for this purpose, the two extra values 2^1024^ and −2^1024^ are
considered to have even significands. Finally, if 2^1024^ was chosen,
replace it with +∞; if −2^1024^ was chosen, replace it with −∞; if +0
was chosen, replace it with −0 if and only if _x_ is less than zero; any
other chosen value is used unchanged. The result is the Number value for
_x_. (This procedure corresponds exactly to the behaviour of the IEEE
754 “round to nearest” mode.)

Some ECMAScript operators deal only with integers in the range −2^31^
through 2^31^−1, inclusive, or in the range 0 through 2^32^−1,
inclusive. These operators accept any value of the Number type but first
convert each such value to one of 2^32^ integer values. See the
descriptions of the ToInt32 and ToUint32 operators in 9.5 and 9.6,
respectively.

An Object is a collection of properties. Each property is either a named
data property, a named accessor property, or an internal property:

-   A _named data property_ associates a name with an ECMAScript
    language value and a set of Boolean attributes.

-   A _named accessor property_ associates a name with one or two
    accessor functions, and a set of Boolean attributes. The accessor
    functions are used to store or retrieve an ECMAScript language value
    that is associated with the property.

-   An _internal property_ has no name and is not directly accessible
    via ECMAScript language operators. Internal properties exist purely
    for specification purposes.

There are two kinds of access for named (non-internal) properties: _get_
and _put_, corresponding to retrieval and assignment, respectively.

Attributes are used in this specification to define and explain the
state of named properties. A named data property associates a name with
the attributes listed in Table 5

Table 5 — Attributes of a Named Data Property

  _ATTRIBUTE NAME_   _VALUE DOMAIN_                 _DESCRIPTION_
  ------------------ ------------------------------ -------------------------------------------------------------------------------------------------------------------------------------------------------
  [[Value]]          Any ECMAScript language type   The value retrieved by reading the property.
  [[Writable]]       Boolean                        If FALSE, attempts by ECMAScript code to change the property’s [[Value]] attribute using [[Put]] will not succeed.
  [[Enumerable]]     Boolean                        If TRUE, the property will be enumerated by a for-in enumeration (see 12.6.4). Otherwise, the property is said to be non-enumerable.
  [[Configurable]]   Boolean                        If FALSE, attempts to delete the property, change the property to be an accessor property, or change its attributes (other than [[Value]]) will fail.

A named accessor property associates a name with the attributes listed
in Table 6.

Table 6 — Attributes of a Named Accessor Property

  _ATTRIBUTE NAME_   _VALUE DOMAIN_          _DESCRIPTION_
  ------------------ ----------------------- --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  [[Get]]            Object _or_ Undefined   If the value is an Object it must be a function Object. The function’s [[Call]] internal method (8.6.2) is called with an empty arguments list to return the property value each time a get access of the property is performed.
  [[Set]]            Object _or_ Undefined   If the value is an Object it must be a function Object. The function’s [[Call]] internal method (8.6.2) is called with an arguments list containing the assigned value as its sole argument each time a set access of the property is performed. The effect of a property's [[Set]] internal method may, but is not required to, have an effect on the value returned by subsequent calls to the property's [[Get]] internal method.
  [[Enumerable]]     Boolean                 If TRUE, the property is to be enumerated by a for-in enumeration (see 12.6.4). Otherwise, the property is said to be non-enumerable.
  [[Configurable]]   Boolean                 If FALSE, attempts to delete the property, change the property to be a data property, or change its attributes will fail.

If the value of an attribute is not explicitly specified by this
specification for a named property, the default value defined in Table 7
is used.

Table 7 — Default Attribute Values

  ATTRIBUTE NAME     DEFAULT VALUE
  ------------------ ---------------
  [[Value]]          UNDEFINED
  [[Get]]            UNDEFINED
  [[Set]]            UNDEFINED
  [[Writable]]       FALSE
  [[Enumerable]]     FALSE
  [[Configurable]]   FALSE

This specification uses various internal properties to define the
semantics of object values. These internal properties are not part of
the ECMAScript language. They are defined by this specification purely
for expository purposes. An implementation of ECMAScript must behave as
if it produced and operated upon internal properties in the manner
described here. The names of internal properties are enclosed in double
square brackets [[ ]]. When an algorithm uses an internal property of an
object and the object does not implement the indicated internal
property, a TYPEERROR exception is thrown.

The Table 8 summarises the internal properties used by this
specification that are applicable to all ECMAScript objects. The Table 9
summarises the internal properties used by this specification that are
only applicable to some ECMAScript objects. The descriptions in these
tables indicate their behaviour for native ECMAScript objects, unless
stated otherwise in this document for particular kinds of native
ECMAScript objects. Host objects may support these internal properties
with any implementation-dependent behaviour as long as it is consistent
with the specific host object restrictions stated in this document.

The “Value Type Domain” columns of the following tables define the types
of values associated with internal properties. The type names refer to
the types defined in Clause 8 augmented by the following additional
names. “_any_” means the value may be any ECMAScript language type.
“_primitive_” means Undefined, Null, Boolean, String, or Number.
“_SpecOp_” means the internal property is an internal method, an
implementation provided procedure defined by an abstract operation
specification. “SpecOp” is followed by a list of descriptive parameter
names. If a parameter name is the same as a type name then the name
describes the type of the parameter. If a “SpecOp” returns a value, its
parameter list is followed by the symbol “→” and the type of the
returned value.

Table 8 — Internal Properties Common to All Objects

  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  _INTERNAL PROPERTY_     _VALUE TYPE DOMAIN_                                                _DESCRIPTION_
  ----------------------- ------------------------------------------------------------------ ------------------------------------------------------------------------------------------------------------------------------------
  [[Prototype]]           Object _or_ Null                                                   The prototype of this object.

                                                                                             

  [[Extensible]]          Boolean                                                            If TRUE, own properties may be added to the object.

  [[Get]]                 SpecOp(_propertyName_) _→_ any                                     Returns the value of the named property.

  [[GetOwnProperty]]      SpecOp (_propertyName_) _→_                                        Returns the Property Descriptor of the named own property of this object, or UNDEFINED if absent.
                                                                                             
                          Undefined _or_ Property Descriptor                                 

  [[GetProperty]]         SpecOp (_propertyName_) _→_                                        Returns the fully populated Property Descriptor of the named property of this object, or UNDEFINED if absent.
                                                                                             
                          Undefined _or_ Property Descriptor                                 

  [[Put]]                 SpecOp (_propertyName_, _any, Boolean_)                            Sets the specified named property to the value of the second parameter. The flag controls failure handling.

  [[CanPut]]              SpecOp (_propertyName_) _→_ Boolean                                Returns a Boolean value indicating whether a [[Put]] operation with _PropertyName_ can be performed.

  [[HasProperty]]         SpecOp (_propertyName_) _→_ _Boolean_                              Returns a Boolean value indicating whether the object already has a property with the given name.

  [[Delete]]              SpecOp (_propertyName, Boolean_) _→_ Boolean                       Removes the specified named own property from the object. The flag controls failure handling.

  [[DefaultValue]]        SpecOp (_Hint_) _→_ _primitive_                                    Hint is a String. Returns a default value for the object.

  [[DefineOwnProperty]]   SpecOp (_propertyName, PropertyDescriptor, Boolean_) _→_ Boolean   Creates or alters the named own property to have the state described by a Property Descriptor. The flag controls failure handling.
  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Every object (including host objects) must implement all of the internal
properties listed in Table 8. However, the [[DefaultValue]] internal
method may, for some objects, simply throw a TYPEERROR exception.

All objects have an internal property called [[Prototype]]. The value of
this property is either NULL or an object and is used for implementing
inheritance. Whether or not a native object can have a host object as
its [[Prototype]] depends on the implementation. Every [[Prototype]]
chain must have finite length (that is, starting from any object,
recursively accessing the [[Prototype]] internal property must
eventually lead to a NULL value). Named data properties of the
[[Prototype]] object are inherited (are visible as properties of the
child object) for the purposes of get access, but not for put access.
Named accessor properties are inherited for both get access and put
access.

Every ECMAScript object has a Boolean-valued [[Extensible]] internal
property that controls whether or not named properties may be added to
the object. If the value of the [[Extensible]] internal property is
FALSE then additional named properties may not be added to the object.
In addition, if [[Extensible]] is FALSE the value of [[Prototype]]
internal properties of the object may not be modified. Once the value of
an [[Extensible]] internal property has been set to FALSE it may not be
subsequently changed to TRUE.

NOTE This specification defines no ECMAScript language operators or
built-in functions that permit a program to modify an object’s
[[Prototype]] internal properties or to change the value of
[[Extensible]] from FALSE to TRUE. Implementation specific extensions
that modify [[Prototype]] or [[Extensible]] must not violate the
invariants defined in the preceding paragraph.

Unless otherwise specified, the common internal methods of native
ECMAScript objects behave as described in 8.12. Array objects have a
slightly different implementation of the [[DefineOwnProperty]] internal
method (see 15.4.5.1) and String objects have a slightly different
implementation of the [[GetOwnProperty]] internal method (see 15.5.5.2).
Arguments objects (10.6) have different implementations of [[Get]],
[[GetOwnProperty]], [[DefineOwnProperty]], and [[Delete]]. Function
objects (15.3) have a different implementation of [[Get]].

Host objects may implement these internal methods in any manner unless
specified otherwise; for example, one possibility is that [[Get]] and
[[Put]] for a particular host object indeed fetch and store property
values but [[HasProperty]] always generates FALSE. However, if any
specified manipulation of a host object's internal properties is not
supported by an implementation, that manipulation must throw a TYPEERROR
exception when attempted.

The [[GetOwnProperty]] internal method of a host object must conform to
the following invariants for each property of the host object:

-   If a property is described as a data property and it may return
    different values over time, then either or both of the [[Writable]]
    and [[Configurable]] attributes must be TRUE even if no mechanism to
    change the value is exposed via the other internal methods.

-   If a property is described as a data property and its [[Writable]]
    and [[Configurable]] are both FALSE, then the SameValue (according
    to 9.12) must be returned for the [[Value]] attribute of the
    property on all calls to [[GetOwnProperty]].

-   If the attributes other than [[Writable]] may change over time or if
    the property might disappear, then the [[Configurable]] attribute
    must be TRUE.

-   If the [[Writable]] attribute may change from FALSE to TRUE, then
    the [[Configurable]] attribute must be TRUE.

-   If the value of the host object’s [[Extensible]] internal property
    has been observed by ECMAScript code to be FALSE, then if a call to
    [[GetOwnProperty]] describes a property as non-existent all
    subsequent calls must also describe that property as non-existent.

The [[DefineOwnProperty]] internal method of a host object must not
permit the addition of a new property to a host object if the
[[Extensible]] internal property of that host object has been observed
by ECMAScript code to be FALSE.

If the [[Extensible]] internal property of that host object has been
observed by ECMAScript code to be FALSE then it must not subsequently
become TRUE.

Table 9 — Internal Properties Only Defined for Some Objects

  _INTERNAL PROPERTY_    _VALUE TYPE DOMAIN_                                     _DESCRIPTION_
  ---------------------- ------------------------------------------------------- ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  [[NativeBrand]]        Members of the NativeBrand enumeration.                 A tag value used by this specification to categorize various kinds of native ECMAScript objects defined in this specification. Host objects do not have this internal property.
  [[PrimitiveValue]]     _primitive_                                             Internal state information associated with this object. Of the standard built-in ECMAScript objects, only Boolean, Date, Number, and String objects implement [[PrimitiveValue]].
  [[Construct]]          SpecOp(a List of _any_) _→_ Object                      Creates an object. Invoked via the NEW operator. The arguments to the SpecOp are the arguments passed to the NEW operator. Objects that implement this internal method are called _constructors_.
  [[Call]]               SpecOp(_any_, a List of _any_) _→_ _any_ or Reference   Executes code associated with the object. Invoked via a function call expression. The arguments to the SpecOp are this object and a list containing the arguments passed to the function call expression. Objects that implement this internal method are _callable_. Only callable objects that are host objects may return Reference values.
  [[HasInstance]]        SpecOp(_any_) _→_ Boolean                               Returns a Boolean value indicating whether the argument is likely an Object that was constructed by this object. Of the standard built-in ECMAScript objects, only Function objects implement [[HasInstance]].
  [[Scope]]              Lexical Environment                                     A lexical environment that defines the environment in which a Function object is executed. Of the standard built-in ECMAScript objects, only Function objects implement [[Scope]].
  [[FormalParameters]]   List of Strings                                         A possibly empty List containing the identifier Strings of a Function’s _FormalParameterList_. Of the standard built-in ECMAScript objects, only Function objects implement [[FormalParameterList]].
  [[Code]]               ECMAScript code                                         The ECMAScript code of a function. Of the standard built-in ECMAScript objects, only Function objects implement [[Code]].
  [[TargetFunction]]     Object                                                  The target function of a function object created using the standard built-in Function.prototype.bind method. Only ECMAScript objects created using Function.prototype.bind have a [[TargetFunction]] internal property.
  [[BoundThis]]          _any_                                                   The pre-bound this value of a function Object created using the standard built-in Function.prototype.bind method. Only ECMAScript objects created using Function.prototype.bind have a [[BoundThis]] internal property.
  [[BoundArguments]]     List of _any_                                           The pre-bound argument values of a function Object created using the standard built-in Function.prototype.bind method. Only ECMAScript objects created using Function.prototype.bind have a [[BoundArguments]] internal property.
  [[Match]]              SpecOp(_String_, _index_) _→_ _MatchResult_             Tests for a regular expression match and returns a MatchResult value (see 15.10.2.1). Of the standard built-in ECMAScript objects, only RegExp objects implement [[Match]].
  [[ParameterMap]]       Object                                                  Provides a mapping between the properties of an arguments object (see 10.6) and the formal parameters of the associated function. Only ECMAScript objects that are arguments objects have a [[ParameterMap]] internal property.

The [[NativeBrand]] internal property is used to identify native
ECMASCript objects as objects that conform to specific parts of this
specification. The value of a [[NativeBrand]] property is a single
member of this set of enumerated values: NativeFunction, NativeArray,
StringWrapper, BooleanWrapper, NumberWrapper, NativeMath, NativeDate,
NativeRegExp, NativeError, NativeJSON, NativeArguments. The actual value
of the [[NativeBrand]] internal property is only used to identify
specific kinds of native ECMAScript objects. Host objects do not have
this internal property,

Table 10 — Values of the [[NativeBrand]] Internal Property

  _INTERNAL PROPERTY_   _CATEGORY_          _DESCRIPTION_
  --------------------- ------------------- ---------------
  NativeFunction        Function objects    
  NativeArray           Array objects       
  StringWrapper         String objects      
  BooleanWrapper        Boolean objects     
  NumberWrapper         Number objects      
  NativeMath            The Math object     
  NativeDate            Date objects        
  NativeRegExp          RegExp objects      
  NativeError           Error objects       
  NativeJSON            The JSON object     
  NativeArguments       Arguments objects   
                                            

The Reference type is used to explain the behaviour of such operators as
DELETE, TYPEOF, and the assignment operators. For example, the left-hand
operand of an assignment is expected to produce a reference. The
behaviour of assignment could, instead, be explained entirely in terms
of a case analysis on the syntactic form of the left-hand operand of an
assignment operator, but for one difficulty: function calls are
permitted to return references. This possibility is admitted purely for
the sake of host objects. No built-in ECMAScript function defined by
this specification returns a reference and there is no provision for a
user-defined function to return a reference. (Another reason not to use
a syntactic case analysis is that it would be lengthy and awkward,
affecting many parts of the specification.)

A REFERENCE is a resolved name binding. A Reference consists of three
components, the _base_ value, the _referenced name_ and the Boolean
valued _strict reference_ flag. The base value is either UNDEFINED, an
Object, a Boolean, a String, a Number, or an environment record
(10.2.1). A base value of UNDEFINED indicates that the reference could
not be resolved to a binding. The referenced name is a String.

The following abstract operations are used in this specification to
access the components of references:

-   GetBase(V). Returns the base value component of the reference V.

-   GetReferencedName(V). Returns the referenced name component of the
    reference V.

-   IsStrictReference(V). Returns the strict reference component of the
    reference V.

-   HasPrimitiveBase(V). Returns TRUE if the base value is a Boolean,
    String, or Number.

-   IsPropertyReference(V). Returns TRUE if either the base value is an
    object or HasPrimitiveBase(V) is TRUE; otherwise returns FALSE.

-   IsUnresolvableReference(V). Returns TRUE if the base value is
    UNDEFINED and FALSE otherwise.

The following abstract operations are used in this specification to
operate on references:

The following [[Get]] internal method is used by GetValue when _V_ is a
property reference with a primitive base value. It is called using
_base_ as its THIS value and with property _P_ as its argument. The
following steps are taken:

NOTE The object that may be created in step 1 is not accessible outside
of the above method. An implementation might choose to avoid the actual
creation of the object. The only situation where such an actual property
access that uses this internal method can have visible effect is when it
invokes an accessor function.

The following [[Put]] internal method is used by PutValue when _V_ is a
property reference with a primitive base value. It is called using
_base_ as its THIS value and with property _P_, value _W_, and Boolean
flag _Throw_ as arguments. The following steps are taken:

NOTE The object that may be created in step 1 is not accessible outside
of the above method. An implementation might choose to avoid the actual
creation of that transient object. The only situations where such an
actual property assignment that uses this internal method can have
visible effect are when it either invokes an accessor function or is in
violation of a _Throw_ predicated error check. When _Throw_ is TRUE any
property assignment that would create a new property on the transient
object throws an error.

The List type is used to explain the evaluation of argument lists (see
11.2.4) in NEW expressions, in function calls, and in other algorithms
where a simple list of values is needed. Values of the List type are
simply ordered sequences of values. These sequences may be of any
length.

The Completion type is used to explain the behaviour of statements
(BREAK, CONTINUE, RETURN and THROW) that perform nonlocal transfers of
control. Values of the Completion type are triples of the form (_type_,
_value_, _target_), where _type_ is one of NORMAL, BREAK, CONTINUE,
RETURN, or THROW, _value_ is any ECMAScript language value or EMPTY, and
_target_ is any ECMAScript identifier or EMPTY. If _cv_ is a completion
value then _cv_.type, _cv_.value, and _cv_.target may be used to
directly refer to its constituent values.

The term “abrupt completion” refers to any completion with a _type_
other than NORMAL.

The Property Descriptor type is used to explain the manipulation and
reification of named property attributes. Values of the Property
Descriptor type are records composed of named fields where each field’s
name is an attribute name and its value is a corresponding attribute
value as specified in 8.6.1. In addition, any field may be present or
absent.

Property Descriptor values may be further classified as data property
descriptors and accessor property descriptors based upon the existence
or use of certain fields. A data property descriptor is one that
includes any fields named either [[Value]] or [[Writable]]. An accessor
property descriptor is one that includes any fields named either [[Get]]
or [[Set]]. Any property descriptor may have fields named [[Enumerable]]
and [[Configurable]]. A Property Descriptor value may not be both a data
property descriptor and an accessor property descriptor; however, it may
be neither. A generic property descriptor is a Property Descriptor value
that is neither a data property descriptor nor an accessor property
descriptor. A fully populated property descriptor is one that is either
an accessor property descriptor or a data property descriptor and that
has all of the fields that correspond to the property attributes defined
in either 8.6.1 Table 5 or Table 6.

For notational convenience within this specification, an object
literal-like syntax can be used to define a property descriptor value.
For example, Property Descriptor {[[Value]]: 42, [[Writable]]: FALSE,
[[Configurable]]: TRUE} defines a data property descriptor. Field name
order is not significant. Any fields that are not explicitly listed are
considered to be absent.

In specification text and algorithms, dot notation may be used to refer
to a specific field of a Property Descriptor. For example, if D is a
property descriptor then D.[[Value]] is shorthand for “the field of D
named [[Value]]”.

The Property Identifier type is used to associate a property name with a
Property Descriptor. Values of the Property Identifier type are pairs of
the form (name, descriptor), where name is a String and descriptor is a
Property Descriptor value.

The following abstract operations are used in this specification to
operate upon Property Descriptor values:

When the abstract operation IsAccessorDescriptor is called with property
descriptor _Desc_, the following steps are taken:

When the abstract operation IsDataDescriptor is called with property
descriptor _Desc_, the following steps are taken:

When the abstract operation IsGenericDescriptor is called with property
descriptor _Desc_, the following steps are taken:

When the abstract operation FromPropertyDescriptor is called with
property descriptor _Desc_, the following steps are taken:

The following algorithm assumes that _Desc_ is a fully populated
Property Descriptor, such as that returned from [[GetOwnProperty]] (see
8.12.1).

When the abstract operation ToPropertyDescriptor is called with object
_Obj_, the following steps are taken:

The Lexical Environment and Environment Record types are used to explain
the behaviour of name resolution in nested functions and blocks. These
types and the operations upon them are defined in Clause 10.

In the following algorithm descriptions, assume _O_ is a native
ECMAScript object, _P_ is a String, _Desc_ is a Property Description
record, and _Throw_ is a Boolean flag.

When the [[GetOwnProperty]] internal method of _O_ is called with
property name _P_, the following steps are taken:

However, if _O_ is a String object it has a more elaborate
[[GetOwnProperty]] internal method defined in 15.5.5.2.

When the [[GetProperty]] internal method of _O_ is called with property
name _P_, the following steps are taken:

When the [[Get]] internal method of _O_ is called with property name
_P_, the following steps are taken:

1.  Let _desc_ be the result of calling the [[GetProperty]] internal
    method of _O_ with property name _P_.

2.  If _desc_ is UNDEFINED, return UNDEFINED.

3.  If IsDataDescriptor(_desc_) is TRUE, return _desc_.[[Value]].

4.  Otherwise, IsAccessorDescriptor(_desc_) must be true so, let
    _getter_ be _desc_.[[Get]].

5.  If _getter_ is UNDEFINED, return UNDEFINED.

6.  Return the result calling the [[Call]] internal method of _getter
    providing _O_ as the THIS value and providing no arguments.

When the [[CanPut]] internal method of _O_ is called with property name
_P_, the following steps are taken:

Host objects may define additional constraints upon [[Put]] operations.
If possible, host objects should not allow [[Put]] operations in
situations where this definition of [[CanPut]] returns false.

When the [[Put]] internal method of _O_ is called with property _P_,
value _V_, and Boolean flag _Throw_, the following steps are taken:

When the [[HasProperty]] internal method of _O_ is called with property
name _P_, the following steps are taken:

When the [[Delete]] internal method of _O_ is called with property name
_P_ and the Boolean flag _Throw_, the following steps are taken:

When the [[DefaultValue]] internal method of _O_ is called with hint
String, the following steps are taken:

When the [[DefaultValue]] internal method of _O_ is called with hint
Number, the following steps are taken:

When the [[DefaultValue]] internal method of _O_ is called with no hint,
then it behaves as if the hint were Number, unless _O_ is a Date object
(see 15.9.6), in which case it behaves as if the hint were String.

The above specification of [[DefaultValue]] for native objects can
return only primitive values. If a host object implements its own
[[DefaultValue]] internal method, it must ensure that its
[[DefaultValue]] internal method can return only primitive values.

In the following algorithm, the term “Reject” means “If _Throw_ is TRUE,
then throw a TYPEERROR exception, otherwise return FALSE”. The algorithm
contains steps that test various fields of the Property Descriptor
_Desc_ for specific values. The fields that are tested in this manner
need not actually exist in _Desc_. If a field is absent then its value
is considered to be FALSE.

When the [[DefineOwnProperty]] internal method of _O_ is called with
property name _P_, property descriptor _Desc_, and Boolean flag _Throw_,
the following steps are taken:

However, if _O_ has an [[NativeBrand]] internal property whose value is
NativeArray _O_ also has a more elaborate [[DefineOwnProperty]] internal
method defined in 15.4.5.1.

NOTE Step 10.b allows any field of Desc to be different from the
corresponding field of current if current’s [[Configurable]] field is
TRUE. This even permits changing the [[Value]] of a property whose
[[Writable]] attribute is FALSE. This is allowed because a TRUE
[[Configurable]] attribute would permit an equivalent sequence of calls
where [[Writable]] is first set to TRUE, a new [[Value]] is set, and
then [[Writable]] is set to FALSE.

The ECMAScript runtime system performs automatic type conversion as
needed. To clarify the semantics of certain constructs it is useful to
define a set of conversion abstract operations. These abstract
operations are not a part of the language; they are defined here to aid
the specification of the semantics of the language. The conversion
abstract operations are polymorphic; that is, they can accept a value of
any ECMAScript language type, but not of specification types.

The abstract operation ToPrimitive takes an _input_ argument and an
optional argument _PreferredType_. The abstract operation ToPrimitive
converts its _input_ argument to a non-Object type. If an object is
capable of converting to more than one primitive type, it may use the
optional hint _PreferredType_ to favour that type. Conversion occurs
according to Table 11:

Table 11 — ToPrimitive Conversions

  -------------- ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  _INPUT TYPE_   _RESULT_
  Undefined      The result equals the _input_ argument (no conversion).
  Null           The result equals the _input_ argument (no conversion).
  Boolean        The result equals the _input_ argument (no conversion).
  Number         The result equals the _input_ argument (no conversion).
  String         The result equals the _input_ argument (no conversion).
  Object         Return a default value for the Object. The default value of an object is retrieved by calling the [[DefaultValue]] internal method of the object, passing the optional hint _PreferredType_. The behaviour of the [[DefaultValue]] internal method is defined by this specification for all native ECMAScript objects in 8.12.8.
  -------------- ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

The abstract operation ToBoolean converts its argument to a value of
type Boolean according to Table 12:

Table 12 — ToBoolean Conversions

  ----------------- -------------------------------------------------------------------------------------------------------------
  _ARGUMENT TYPE_   _RESULT_
  Undefined         FALSE
  Null              FALSE
  Boolean           The result equals the input argument (no conversion).
  Number            The result is FALSE if the argument is +0, −0, or NAN; otherwise the result is TRUE.
  String            The result is FALSE if the argument is the empty String (its length is zero); otherwise the result is TRUE.
  Object            TRUE
  ----------------- -------------------------------------------------------------------------------------------------------------

The abstract operation ToNumber converts its argument to a value of type
Number according to Table 13:

Table 13 — To Number Conversions

  ----------------- -------------------------------------------------------------------------------------
  _ARGUMENT TYPE_   _RESULT_

  Undefined         NAN

  Null              +0

  Boolean           The result is 1 if the argument is TRUE. The result is +0 if the argument is FALSE.

  Number            The result equals the input argument (no conversion).

  String            See grammar and note below.

  Object            Apply the following steps:
                    
                    Let _primValue_ be ToPrimitive(_input argument_, hint Number).
                    
                    Return ToNumber(_primValue_).
  ----------------- -------------------------------------------------------------------------------------

ToNumber applied to Strings applies the following grammar to the input
String. If the grammar cannot interpret the String as an expansion of
_StringNumericLiteral_, then the result of ToNumber is NAN.

Syntax

StringNumericLiteral :::

StrWhiteSpace~opt~
StrWhiteSpace~opt~ StrNumericLiteral StrWhiteSpace~opt~

StrWhiteSpace :::

StrWhiteSpaceChar StrWhiteSpace~opt~

StrWhiteSpaceChar :::

WhiteSpace
LineTerminator

StrNumericLiteral :::

StrDecimalLiteral
HexIntegerLiteral

StrDecimalLiteral :::

StrUnsignedDecimalLiteral
+ StrUnsignedDecimalLiteral
- StrUnsignedDecimalLiteral

StrUnsignedDecimalLiteral :::

INFINITY
 DecimalDigits . DecimalDigits~opt~ ExponentPart~opt~
. DecimalDigits ExponentPart~opt~
DecimalDigits ExponentPart~opt~

DecimalDigits :::

DecimalDigit
DecimalDigits DecimalDigit

DecimalDigit ::: ONE OF

0 1 2 3 4 5 6 7 8 

ExponentPart :::

ExponentIndicator SignedInteger

ExponentIndicator ::: ONE OF

E E

SignedInteger :::

DecimalDigits
+ DecimalDigits
- DecimalDigits

HexIntegerLiteral :::

0X HexDigit
0X HexDigit
HexIntegerLiteral HexDigit

HexDigit ::: ONE OF

0 1 2 3 4 5 6 7 8 9 A B C D E F A B C D E F

Some differences should be noted between the syntax of a
_StringNumericLiteral_ and a _NumericLiteral_ (see 7.8.3):

-   A _StringNumericLiteral_ may be preceded and/or followed by white
    space and/or line terminators.

-   A _StringNumericLiteral_ that is decimal may have any number of
    leading 0 digits.

-   A _StringNumericLiteral_ that is decimal may be preceded by + or -
    to indicate its sign.

-   A _StringNumericLiteral_ that is empty or contains only white space
    is converted to +0.

The conversion of a String to a Number value is similar overall to the
determination of the Number value for a numeric literal (see 7.8.3), but
some of the details are different, so the process for converting a
String numeric literal to a value of Number type is given here in full.
This value is determined in two steps: first, a mathematical value (MV)
is derived from the String numeric literal; second, this mathematical
value is rounded as described below.

-   The MV of _StringNumericLiteral_ ::: [empty] is 0.

-   The MV of _StringNumericLiteral_ ::: _StrWhiteSpace_ is 0.

-   The MV of _StringNumericLiteral_ ::: _StrWhiteSpace_~opt~
      _StrNumericLiteral_ _StrWhiteSpace_~opt~ is the MV of
      _StrNumericLiteral_, no matter whether white space is present or
      not.

-   The MV of _StrNumericLiteral_ ::: _StrDecimalLiteral_ is the MV of
      _StrDecimalLiteral_.

-   The MV of _StrNumericLiteral_ ::: _HexIntegerLiteral_ is the MV of
      _HexIntegerLiteral_.

-   The MV of _StrDecimalLiteral_ ::: _StrUnsignedDecimalLiteral_ is the
      MV of _StrUnsignedDecimalLiteral_.

-   The MV of _StrDecimalLiteral_ ::: + _StrUnsignedDecimalLiteral_ is
      the MV of _StrUnsignedDecimalLiteral_.

-   The MV of _StrDecimalLiteral_ ::: - _StrUnsignedDecimalLiteral_ is
      the negative of the MV of _StrUnsignedDecimalLiteral_. (Note that
      if the MV of _StrUnsignedDecimalLiteral_ is 0, the negative of
      this MV is also 0. The rounding rule described below handles the
      conversion of this signless mathematical zero to a floating-point
      +0 or −0 as appropriate.)

-   The MV of _StrUnsignedDecimalLiteral_::: INFINITY is 10^10000^ (a
      value so large that it will round to +∞).

-   The MV of _StrUnsignedDecimalLiteral_::: _DecimalDigits_. is the MV
      of _DecimalDigits_.

-   The MV of _StrUnsignedDecimalLiteral_::: _DecimalDigits_ .
      _DecimalDigits_ is the MV of the first _DecimalDigits_ plus (the
      MV of the second _DecimalDigits_ times 10^−_n_^), where _n_ is the
      number of characters in the second _DecimalDigits_.

-   The MV of _StrUnsignedDecimalLiteral_::: _DecimalDigits_.
      _ExponentPart_ is the MV of _DecimalDigits_ times 10_^e^_, where
      _e_ is the MV of _ExponentPart_.

-   The MV of _StrUnsignedDecimalLiteral_::: _DecimalDigits_.
      _DecimalDigits ExponentPart_ is (the MV of the first
      _DecimalDigits_ plus (the MV of the second _DecimalDigits_ times
      10^−_n_^)) times 10_^e^_, where _n_ is the number of characters in
      the second _DecimalDigit_s and _e_ is the MV of _ExponentPart_.

-   The MV of _StrUnsignedDecimalLiteral_:::. _DecimalDigits_ is the MV
      of _DecimalDigits_ times 10^−_n_^, where _n_ is the number of
      characters in _DecimalDigit_s.

-   The MV of _StrUnsignedDecimalLiteral_:::. _DecimalDigits
      ExponentPart_ is the MV of _DecimalDigits_ times 10^_e_−_n_^,
      where _n_ is the number of characters in _DecimalDigit_s and _e_
      is the MV of _ExponentPart_.

-   The MV of _StrUnsignedDecimalLiteral_::: _DecimalDigits_ is the MV
      of _DecimalDigits_.

-   The MV of _StrUnsignedDecimalLiteral_::: _DecimalDigits_
      _ExponentPart_ is the MV of _DecimalDigits_ times 10_^e^_, where
      _e_ is the MV of _ExponentPart_.

-   The MV of _DecimalDigits_ ::: _DecimalDigit_ is the MV of
      _DecimalDigit_.

-   The MV of _DecimalDigits_ ::: _DecimalDigits_ _DecimalDigit_ is (the
      MV of _DecimalDigits_ times 10) plus the MV of _DecimalDigit_.

-   The MV of _ExponentPart_ ::: _ExponentIndicator SignedInteger_ is
      the MV of _SignedInteger_.

-   The MV of _SignedInteger_ ::: _DecimalDigits_ is the MV of
      _DecimalDigits_.

-   The MV of _SignedInteger_ ::: + _DecimalDigits_ is the MV of
      _DecimalDigits_.

-   The MV of _SignedInteger_ ::: - _DecimalDigits_ is the negative of
      the MV of _DecimalDigits_.

-   The MV of _DecimalDigit_ ::: 0 or of _HexDigit_ ::: 0 is 0.

-   The MV of _DecimalDigit_ ::: 1 or of _HexDigit_ ::: 1 is 1.

-   The MV of _DecimalDigit_ ::: 2 or of _HexDigit_ ::: 2 is 2.

-   The MV of _DecimalDigit_ ::: 3 or of _HexDigit_ ::: 3 is 3.

-   The MV of _DecimalDigit_ ::: 4 or of _HexDigit_ ::: 4 is 4.

-   The MV of _DecimalDigit_ ::: 5 or of _HexDigit_ ::: 5 is 5.

-   The MV of _DecimalDigit_ ::: 6 or of _HexDigit_ ::: 6 is 6.

-   The MV of _DecimalDigit_ ::: 7 or of _HexDigit_ ::: 7 is 7.

-   The MV of _DecimalDigit_ ::: 8 or of _HexDigit_ ::: 8 is 8.

-   The MV of _DecimalDigit_ ::: 9 or of _HexDigit_ ::: 9 is 9.

-   The MV of _HexDigit_ ::: A or of _HexDigit_ ::: A is 10.

-   The MV of _HexDigit_ ::: B or of _HexDigit_ ::: B is 11.

-   The MV of _HexDigit_ ::: C or of _HexDigit_ ::: C is 12.

-   The MV of _HexDigit_ ::: D or of _HexDigit_ ::: D is 13.

-   The MV of _HexDigit_ ::: E or of _HexDigit_ ::: E is 14.

-   The MV of _HexDigit_ ::: F or of _HexDigit_ ::: F is 15.

-   The MV of _HexIntegerLiteral_ ::: 0X _HexDigit_ is the MV of
      _HexDigit_.

-   The MV of _HexIntegerLiteral_ ::: 0X _HexDigit_ is the MV of
      _HexDigit_.

-   The MV of _HexIntegerLiteral_ ::: _HexIntegerLiteral_ _HexDigit_ is
      (the MV of _HexIntegerLiteral_ times 16) plus the MV of
      _HexDigit_.

Once the exact MV for a String numeric literal has been determined, it
is then rounded to a value of the Number type. If the MV is 0, then the
rounded value is +0 unless the first non white space character in the
String numeric literal is ‘-’, in which case the rounded value is −0.
Otherwise, the rounded value must be the Number value for the MV (in the
sense defined in 8.5), unless the literal includes a
_StrUnsignedDecimalLiteral_ and the literal has more than 20 significant
digits, in which case the Number value may be either the Number value
for the MV of a literal produced by replacing each significant digit
after the 20th with a 0 digit or the Number value for the MV of a
literal produced by replacing each significant digit after the 20th with
a 0 digit and then incrementing the literal at the 20th digit position.
A digit is _significant_ if it is not part of an _ExponentPart_ and

-   it is not 0; or

-   there is a nonzero digit to its left and there is a nonzero digit,
    not in the _ExponentPart_, to its right.

The abstract operation ToInteger converts its argument to an integral
numeric value. This abstract operation functions as follows:

The abstract operation ToInt32 converts its argument to one of 2^32^
integer values in the range −2^31^ through 2^31^−1, inclusive. This
abstract operation functions as follows:

NOTE Given the above definition of ToInt32:

-   The ToInt32 abstract operation is idempotent: if applied to a result
      that it produced, the second application leaves that value
      unchanged.

-   ToInt32(ToUint32(_x_)) is equal to ToInt32(_x_) for all values of
      _x_. (It is to preserve this latter property that +∞ and −∞ are
      mapped to +0.)

-   ToInt32 maps −0 to +0.

The abstract operation ToUint32 converts its argument to one of 2^32^
integer values in the range 0 through 2^32^−1, inclusive. This
abstraction operation functions as follows:

NOTE Given the above definition of ToUInt32:

-   Step 5 is the only difference between ToUint32 and ToInt32.

-   The ToUint32 abstract operation is idempotent: if applied to a
      result that it produced, the second application leaves that value
      unchanged.

-   ToUint32(ToInt32(_x_)) is equal to ToUint32(_x_) for all values of
      _x_. (It is to preserve this latter property that +∞ and −∞ are
      mapped to +0.)

-   ToUint32 maps −0 to +0.

The abstract operation ToUint16 converts its argument to one of 2^16^
integer values in the range 0 through 2^16^−1, inclusive. This abstract
operation functions as follows:

NOTE Given the above definition of ToUint16:

-   The substitution of 2^16^ for 2^32^ in step 4 is the only difference
      between ToUint32 and ToUint16.

-   ToUint16 maps −0 to +0.

The abstract operation ToString converts its argument to a value of type
String according to Table 14:

Table 14 — ToString Conversions

  ----------------- -----------------------------------------------------------------
  _ARGUMENT TYPE_   _RESULT_

  Undefined         "UNDEFINED"

  Null              "NULL"

  Boolean           If the argument is TRUE, then the result is "TRUE".
                    
                    If the argument is FALSE, then the result is "FALSE".

  Number            See 9.8.1.

  String            Return the input argument (no conversion)

  Object            Apply the following steps:
                    
                    1. Let _primValue_ be ToPrimitive(input argument, hint String).
                    
                    2. Return ToString(_primValue_).
  ----------------- -----------------------------------------------------------------

The abstract operation ToString converts a Number _m_ to String format
as follows:

NOTE 1 The following observations may be useful as guidelines for
implementations, but are not part of the normative requirements of this
Standard:

-   If x is any Number value other than −0, then ToNumber(ToString(x))
      is exactly the same Number value as x.

-   The least significant digit of s is not always uniquely determined
      by the requirements listed in step 5.

NOTE 2 For implementations that provide more accurate conversions than
required by the rules above, it is recommended that the following
alternative version of step 5 be used as a guideline:

  Otherwise, let _n_, _k_, and _s_ be integers such that _k_ ≥ 1,
  10^_k_−1^ ≤ _s_ < 10_^k^_, the Number value for _s_ × 10^_n_−_k_^ is
  _m_, and _k_ is as small as possible. If there are multiple
  possibilities for _s_, choose the value of _s_ for which _s_ ×
  10^_n_−_k_^ is closest in value to _m_. If there are two such possible
  values of _s_, choose the one that is even. Note that _k_ is the
  number of digits in the decimal representation of _s_ and that _s_ is
  not divisible by 10.

NOTE 3 Implementers of ECMAScript may find useful the paper and code
written by David M. Gay for binary-to-decimal conversion of
floating-point numbers:

  Gay, David M. Correctly Rounded Binary-Decimal and Decimal-Binary
  Conversions. Numerical Analysis, Manuscript 90-10. AT&T Bell
  Laboratories (Murray Hill, New Jersey). November 30, 1990. Available
  as
  http://cm.bell-labs.com/cm/cs/doc/90/4-10.ps.gz. Associated code
  available as
  http://cm.bell-labs.com/netlib/fp/dtoa.c.gz and as
  http://cm.bell-labs.com/netlib/fp/g_fmt.c.gz and may also be found at
  the various NETLIB mirror sites.

The abstract operation ToObject converts its argument to a value of type
Object according to Table 15:

Table 15 — ToObject

  ----------------- ------------------------------------------------------------------------------------------------------------------------------------------------------------
  _ARGUMENT TYPE_   _RESULT_
  Undefined         Throw a TYPEERROR exception.
  Null              Throw a TYPEERROR exception.
  Boolean           Create a new Boolean object whose [[PrimitiveValue]] internal property is set to the value of the argument. See 15.6 for a description of Boolean objects.
  Number            Create a new Number object whose [[PrimitiveValue]] internal property is set to the value of the argument. See 15.7 for a description of Number objects.
  String            Create a new String object whose [[PrimitiveValue]] internal property is set to the value of the argument. See 15.5 for a description of String objects.
  Object            The result is the input argument (no conversion).
  ----------------- ------------------------------------------------------------------------------------------------------------------------------------------------------------

The abstract operation CheckObjectCoercible throws an error if its
argument is a value that cannot be converted to an Object using
ToObject. It is defined by Table 16:

Table 16 — CheckObjectCoercible Results

  _ARGUMENT TYPE_   _RESULT_
  ----------------- ------------------------------
  Undefined         Throw a TYPEERROR exception.
  Null              Throw a TYPEERROR exception.
  Boolean           Return
  Number            Return
  String            Return
  Object            Return

The abstract operation IsCallable determines if its argument, which must
be an ECMAScript language value, is a callable function Object according
to Table 17:

Table 17 — IsCallable Results

  ----------------- --------------------------------------------------------------------------------------------------
  _ARGUMENT TYPE_   _RESULT_
  Undefined         Return FALSE.
  Null              Return FALSE.
  Boolean           Return FALSE.
  Number            Return FALSE.
  String            Return FALSE.
  Object            If the argument object has a [[Call]] internal method, then return TRUE, otherwise return FALSE.
  ----------------- --------------------------------------------------------------------------------------------------

The internal comparison abstract operation SameValue(_x_, _y_), where
_x_ and _y_ are ECMAScript language values, produces TRUE or FALSE. Such
a comparison is performed as follows:

There are three types of ECMAScript executable code:

-   _Global code_ is source text that is treated as an ECMAScript
      _Program_. The global code of a particular _Program_ does not
      include any source text that is parsed as part of a
      _FunctionBody_.

-   _Eval code_ is the source text supplied to the built-in EVAL
      function. More precisely, if the parameter to the built-in EVAL
      function is a String, it is treated as an ECMAScript _Program_.
      The eval code for a particular invocation of EVAL is the global
      code portion of that _Program_.

-   _Function code_ is source text that is parsed as part of a
      _FunctionBody_. The _function code_ of a particular _FunctionBody_
      does not include any source text that is parsed as part of a
      nested _FunctionBody_. _Function code_ also denotes the source
      text supplied when using the built-in FUNCTION object as a
      constructor. More precisely, the last parameter provided to the
      FUNCTION constructor is converted to a String and treated as the
      _FunctionBody_. If more than one parameter is provided to the
      FUNCTION constructor, all parameters except the last one are
      converted to Strings and concatenated together, separated by
      commas. The resulting String is interpreted as the
      _FormalParameterList_ for the _FunctionBody_ defined by the last
      parameter. The function code for a particular instantiation of a
      FUNCTION does not include any source text that is parsed as part
      of a nested _FunctionBody_.

An ECMAScript _Program_ syntactic unit may be processed using either
unrestricted or strict mode syntax and semantics. When processed using
strict mode the three types of ECMAScript code are referred to as strict
global code, strict eval code, and strict function code. Code is
interpreted as strict mode code in the following situations:

-   Global code is strict global code if it begins with a Directive
      Prologue that contains a Use Strict Directive (see 14.1).

-   Eval code is strict eval code if it begins with a Directive Prologue
      that contains a Use Strict Directive or if the call to eval is a
      direct call (see 15.1.2.1.1) to the eval function that is
      contained in strict mode code.

-   Function code that is part of a _FunctionDeclaration_,
      _FunctionExpression_, or accessor _PropertyAssignment_ is strict
      function code if its _FunctionDeclaration_, _FunctionExpression_,
      or _PropertyAssignment_ is contained in strict mode code or if the
      function code begins with a Directive Prologue that contains a Use
      Strict Directive.

-   Function code that is supplied as the last argument to the built-in
      Function constructor is strict function code if the last argument
      is a String that when processed as a _FunctionBody_ begins with a
      Directive Prologue that contains a Use Strict Directive.

-   Unless specified otherwise, extended code (10.1.2) is also strict
      mode code.

_Extended code_ is any code contained in an ECMAScript _Program
syntactic unit that contains occurrences of lexical or syntactic
productions defined subsequent to the Fifth Edition of the ECMAScript
specification. Code is interpreted as extended code in the following
situations:

-   Global code is extended global code if it is contained in an
      ECMAScript _Program_ syntactic unit that has been designated as an
      extended _Program_ unit in an implementation defined manner or if
      ???.

-   Eval code is extended eval code if the call to eval is a direct call
      (see 15.1.2.1.1) to the eval function that is contained in
      extended mode code or if it begins with ???.

-   Function code that is part of a _FunctionDeclaration_,
      _FunctionExpression_, or accessor _PropertyAssignment_ is extended
      function code if its _FunctionDeclaration_, _FunctionExpression_,
      or _PropertyAssignment_ is contained in extended mode code or if
      the function code begins with ???.

-   Function code that is supplied as the last argument to the built-in
      Function constructor is strict function code if the last argument
      is a String that when processed as a _FunctionBody_ begins with
      ???.

The term “strict code” is used to designate both actual strict mode code
and extended code while the term “extended code” only designates actual
extended code.

A _Lexical Environment_ is a specification type used to define the
association of _Identifiers_ to specific variables and functions based
upon the lexical nesting structure of ECMAScript code. A Lexical
Environment consists of an Environment Record and a possibly null
reference to an _outer_ Lexical Environment. Usually a Lexical
Environment is associated with some specific syntactic structure of
ECMAScript code such as a _FunctionDeclaration_, a _WithStatement_, or a
_Catch_ clause of a _TryStatement_ and a new Lexical Environment is
created each time such code is evaluated.

An _Environment Record_ records the identifier bindings that are created
within the scope of its associated Lexical Environment.

The outer environment reference is used to model the logical nesting of
Lexical Environment values. The outer reference of a (inner) Lexical
Environment is a reference to the Lexical Environment that logically
surrounds the inner Lexical Environment. An outer Lexical Environment
may, of course, have its own outer Lexical Environment. A Lexical
Environment may serve as the outer environment for multiple inner
Lexical Environments. For example, if a _FunctionDeclaration_ contains
two nested _FunctionDeclarations_ then the Lexical Environments of each
of the nested functions will have as their outer Lexical Environment the
Lexical Environment of the current execution of the surrounding
function.

Lexical Environments and Environment Record values are purely
specification mechanisms and need not correspond to any specific
artefact of an ECMAScript implementation. It is impossible for an
ECMAScript program to directly access or manipulate such values.

There are two kinds of Environment Record values used in this
specification: _declarative environment records_ and _object environment
records_. Declarative environment records are used to define the effect
of ECMAScript language syntactic elements such as
_FunctionDeclarations_, _VariableDeclarations_, and _Catch_ clauses that
directly associate identifier bindings with ECMAScript language values.
Object environment records are used to define the effect of ECMAScript
elements such as _Program_ and _WithStatement_ that associate identifier
bindings with the properties of some object.

For specification purposes Environment Record values can be thought of
as existing in a simple object-oriented hierarchy where Environment
Record is an abstract class with two concrete subclasses, declarative
environment record and object environment record. The abstract class
includes the abstract specification methods defined in Table 18. These
abstract methods have distinct concrete algorithms for each of the
concrete subclasses.

Table 18 — Abstract Methods of Environment Records

  _METHOD_                     _PURPOSE_
  ---------------------------- --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  HasBinding(N)                Determine if an environment record has a binding for an identifier. Return TRUE if it does and FALSE if it does not. The String value _N_ is the text of the identifier.
  CreateMutableBinding(N, D)   Create a new mutable binding in an environment record. The String value _N_ is the text of the bound name. If the optional Boolean argument _D_ is TRUE the binding is may be subsequently deleted.
  SetMutableBinding(N,V, S)    Set the value of an already existing mutable binding in an environment record. The String value _N_ is the text of the bound name. _V_ is the value for the binding and may be a value of any ECMAScript language type. _S_ is a Boolean flag. If _S_ is TRUE and the binding cannot be set throw a TYPEERROR exception. _S_ is used to identify strict mode references.
  GetBindingValue(N,S)         Returns the value of an already existing binding from an environment record. The String value _N_ is the text of the bound name. _S_ is used to identify strict mode references. If _S_ is TRUE and the binding does not exist or is uninitialised throw a REFERENCEERROR exception.
  DeleteBinding(N)             Delete a binding from an environment record. The String value _N_ is the text of the bound name If a binding for _N_ exists, remove the binding and return TRUE. If the binding exists but cannot be removed return FALSE. If the binding does not exist return TRUE.
  ImplicitThisValue()          Returns the value to use as the THIS value on calls to function objects that are obtained as binding values from this environment record.

Each declarative environment record is associated with an ECMAScript
program scope containing variable, constant, and/or function
declarations. A declarative environment record binds the set of
identifiers defined by the declarations contained within its scope.

In addition to the mutable bindings supported by all Environment
Records, declarative environment records also provide for immutable
bindings. An immutable binding is one where the association between an
identifier and a value may not be modified once it has been established.
Creation and initialisation of declarative binding are distinct steps so
it is possible for such bindings to exist in either an initialised or
uninitialised state. Declarative environment records support the methods
listed in Table 19 in addition to the Environment Record abstract
specification methods:

Table 19 — Additional Methods of Declarative Environment Records

  _METHOD_                    _PURPOSE_
  --------------------------- -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  CreateImmutableBinding(N)   Create a new but uninitialised immutable binding in an environment record. The String value _N_ is the text of the bound name.
  InitializeBinding(N,V)      Set the value of an already existing but uninitialised binding in an environment record. The String value _N_ is the text of the bound name. _V_ is the value for the binding and is a value of any ECMAScript language type.

The behaviour of the concrete specification methods for Declarative
Environment Records is defined by the following algorithms.

The concrete environment record method HasBinding for declarative
environment records simply determines if the argument identifier is one
of the identifiers bound by the record:

The concrete Environment Record method CreateMutableBinding for
declarative environment records creates a new mutable binding for the
name _N_ that is initialised to the value UNDEFINED. A binding must not
already exist in this Environment Record for _N_. If Boolean argument
_D_ is provided and has the value TRUE the new binding is marked as
being subject to deletion.

The concrete Environment Record method SetMutableBinding for declarative
environment records attempts to change the bound value of the current
binding of the identifier whose name is the value of the argument _N_ to
the value of argument _V_. A binding for _N_ must already exist. If the
binding is an immutable binding, a TYPEERROR is thrown if S is TRUE.

The concrete Environment Record method GetBindingValue for declarative
environment records simply returns the value of its bound identifier
whose name is the value of the argument _N_. The binding must already
exist. If _S_ is TRUE and the binding is an uninitialised immutable
binding throw a REFERENCEERROR exception.

The concrete Environment Record method DeleteBinding for declarative
environment records can only delete bindings that have been explicitly
designated as being subject to deletion.

Declarative Environment Records always return UNDEFINED as their
ImplicitThisValue.

The concrete Environment Record method CreateImmutableBinding for
declarative environment records creates a new immutable binding for the
name _N_ that is initialised to the value UNDEFINED. A binding must not
already exist in this environment record for _N_.

The concrete Environment Record method InitializeBinding for declarative
environment records is used to set the bound value of the current
binding of the identifier whose name is the value of the argument _N_ to
the value of argument _V_. An uninitialised binding for _N_ must already
exist.

Each object environment record is associated with an object called its
_binding object_. An object environment record binds the set of
identifier names that directly correspond to the property names of its
binding object. Property names that are not an _IdentifierName_ are not
included in the set of bound identifiers. Both own and inherited
properties are included in the set regardless of the setting of their
[[Enumerable]] attribute. Because properties can be dynamically added
and deleted from objects, the set of identifiers bound by an object
environment record may potentially change as a side-effect of any
operation that adds or deletes properties. Any bindings that are created
as a result of such a side-effect are considered to be a mutable binding
even if the Writable attribute of the corresponding property has the
value FALSE. Immutable bindings do not exist for object environment
records.

Object environment records can be configured to provide their binding
object as an implicit this value for use in function calls. This
capability is used to specify the behaviour of With Statement (12.10)
induced bindings. The capability is controlled by a _provideThis_
Boolean value that is associated with each object environment record. By
default, the value of _provideThis_ is FALSE for any object environment
record.

The behaviour of the concrete specification methods for Object
Environment Records is defined by the following algorithms.

The concrete Environment Record method HasBinding for object environment
records determines if its associated binding object has a property whose
name is the value of the argument _N_:

The concrete Environment Record method CreateMutableBinding for object
environment records creates in an environment record’s associated
binding object a property whose name is the String value and initialises
it to the value UNDEFINED. A property named _N_ must not already exist
in the binding object. If Boolean argument _D_ is provided and has the
value TRUE the new property’s [[Configurable]] attribute is set to TRUE,
otherwise it is set to FALSE.

The concrete Environment Record method SetMutableBinding for object
environment records attempts to set the value of the environment
record’s associated binding object’s property whose name is the value of
the argument _N_ to the value of argument _V_. A property named _N_
should already exist but if it does not or is not currently writable,
error handling is determined by the value of the Boolean argument _S_.

The concrete Environment Record method GetBindingValue for object
environment records returns the value of its associated binding object’s
property whose name is the String value of the argument identifier _N_.
The property should already exist but if it does not the result depends
upon the value of the _S_ argument:

The concrete Environment Record method DeleteBinding for object
environment records can only delete bindings that correspond to
properties of the environment object whose [[Configurable]] attribute
have the value TRUE.

Object Environment Records return UNDEFINED as their ImplicitThisValue
unless their _provideThis_ flag is TRUE.

The following abstract operations are used in this specification to
operate upon lexical environments:

The abstract operation GetIdentifierReference is called with a Lexical
Environment _lex_, a String _name_, and a Boolean flag _strict._ The
value of _lex_ may be NULL. When called, the following steps are
performed:

When the abstract operation NewDeclarativeEnvironment is called with
either a Lexical Environment or NULL as argument _E_ the following steps
are performed:

When the abstract operation NewObjectEnvironment is called with an
Object _O_ and a Lexical Environment _E_ (or NULL) as arguments, the
following steps are performed:

The _global environment_ is a unique Lexical Environment which is
created before any ECMAScript code is executed. The global environment’s
Environment Record is an object environment record whose binding object
is the global object (15.1). The global environment’s outer environment
reference is NULL.

As ECMAScript code is executed, additional properties may be added to
the global object and the initial properties may be modified.

When control is transferred to ECMAScript executable code, control is
entering an _execution context_. Active execution contexts logically
form a stack. The top execution context on this logical stack is the
running execution context. A new execution context is created whenever
control is transferred from the executable code associated with the
currently running execution context to executable code that is not
associated with that execution context. The newly created execution
context is pushed onto the stack and becomes the running execution
context.

An execution context contains whatever state is necessary to track the
execution progress of its associated code. In addition, each execution
context has the state components listed in Table 20.

Table 20 —Execution Context State Components

  _COMPONENT_           _PURPOSE_
  --------------------- ----------------------------------------------------------------------------------------------------------------------------------------------------------------------
  LexicalEnvironment    Identifies the Lexical Environment used to resolve identifier references made by code within this execution context.
  VariableEnvironment   Identifies the Lexical Environment whose environment record holds bindings created by _VariableStatements_ and _FunctionDeclarations_ within this execution context.
  ThisBinding           The value associated with the THIS keyword within ECMAScript code associated with this execution context.

The LexicalEnvironment and VariableEnvironment components of an
execution context are always Lexical Environments. When an execution
context is created its LexicalEnvironment and VariableEnvironment
components initially have the same value. The value of the
VariableEnvironment component never changes while the value of the
LexicalEnvironment component may change during execution of code within
an execution context.

In most situations only the running execution context (the top of the
execution context stack) is directly manipulated by algorithms within
this specification. Hence when the terms “LexicalEnvironment”,
“VariableEnvironment” and “ThisBinding” are used without qualification
they are in reference to those components of the running execution
context.

An execution context is purely a specification mechanism and need not
correspond to any particular artefact of an ECMAScript implementation.
It is impossible for an ECMAScript program to access an execution
context.

Identifier resolution is the process of determining the binding of an
_IdentifierName_ using the LexicalEnvironment of the running execution
context. During execution of ECMAScript code, Identifier Resolution is
performed using the following algorithm:

The result of evaluating an identifier is always a value of type
Reference with its referenced name component equal to the _Identifier_
String.

Evaluation of global code or code using the eval function (15.1.2.1)
establishes and enters a new execution context. Every invocation of an
ECMAScript code function (13.2.1) also establishes and enters a new
execution context, even if a function is calling itself recursively.
Every return exits an execution context. A thrown exception may also
exit one or more execution contexts.

When control enters an execution context, the execution context’s
ThisBinding is set, its VariableEnvironment and initial
LexicalEnvironment are defined, and declaration binding instantiation
(10.5) is performed. The exact manner in which these actions occur
depend on the type of code being entered.

The following steps are performed when control enters the execution
context for global code:

The following steps are performed to initialise a global execution
context for ECMAScript code _C_:

The following steps are performed when control enters the execution
context for eval code:

The eval code cannot instantiate variable or function bindings in the
variable environment of the calling context that invoked the eval if
either the code of the calling context or the eval code is strict code.
Instead such bindings are instantiated in a new VariableEnvironment that
is only accessible to the eval code.

The following steps are performed when control enters the execution
context for function code contained in function object _F_, a caller
provided _thisArg_, and a caller provided _argumentsList_:

Every execution context has an associated VariableEnvironment. Variables
and functions declared in ECMAScript code evaluated in an execution
context are added as bindings in that VariableEnvironment’s Environment
Record. For function code, parameters are also added as bindings to that
Environment Record.

Which Environment Record is used to bind a declaration and its kind
depends upon the type of ECMAScript code executed by the execution
context, but the remainder of the behaviour is generic. On entering an
execution context, bindings are created in the VariableEnvironment as
follows using the caller provided _code_ and, if it is function code,
argument List _args_:

When a _Block_ or _CaseBlock_ production is evaluated a new Declarative
Environment Record is created and bindings for each block scoped
variable, constant, or function declarated in the block are instantiated
in the environment record.

Block Declaration Instantiation is performed as follows using arguments
_code_ and _env_. _code_ is the grammar production corresponding to the
body of the block. _env_ is the declarative environment record in which
bindings are to be.

1.  Assert: _parameterNames_ has no duplicate entries.

2.  Let _declarations_ be the LexicalDeclarations of _code_.

3.  For each _FunctionDeclaration_ _f_ in _declarations_, in list order
    do

    a.  Let _fn_ be the _Identifier_ in _FunctionDeclaration_ _f._

    b.  Let _fo_ be the result of instantiating _FunctionDeclaration f_
        as described in Clause 13.

    c.  Call _env’s_ CreateMutableBinding concrete method passing _fn_
        and _configurableBindings_ as the arguments.

    d.  Call _env_’s InitializeBinding concrete method passing _fn_, and
        _fo_ as the arguments.

4.  For each _LetDeclaration_ and _ConstDeclaration_ _d_ in _code_ do

    a.  For each element _dn_ of the BoundNames of _d_ do

        i.  If _d_ is a _LetDeclaration_, then

            1.  Call _env_’s CreateMutableBinding concrete method
                passing _dn_ and FALSE as the arguments.

        ii. Else,

            1.  Call _env_’s CreateImmutableBinding concrete method
                passing _dn_ as the argument.

When control enters an execution context for function code, an arguments
object is created unless (as specified in 10.5) the identifier ARGUMENTS
occurs as an _Identifier_ in the function’s _FormalParameterList_ or
occurs as the _Identifier_ of a _FunctionDeclaration_ contained in the
function code.

The arguments object is created by calling the abstract operation
CreateArgumentsObject with arguments _func_ the function object whose
code is to be evaluated_, names_ a List containing the function’s formal
parameter names_, args_ the actual arguments passed to the [[Call]]
internal method, _env_ the variable environment for the function code,
and _strict_ a Boolean that indicates whether or not the function code
is strict code. When CreateArgumentsObject is called the following steps
are performed:

The abstract operation _MakeArgGetter_ called with String _name_ and
environment record _env_ creates a function object that when executed
returns the value bound for _name_ in _env_. It performs the following
steps:

The abstract operation _MakeArgSetter_ called with String _name_ and
environment record _env_ creates a function object that when executed
sets the value bound for _name_ in _env_. It performs the following
steps:

The [[Get]] internal method of an arguments object for a non-strict mode
function with formal parameters when called with a property name _P_
performs the following steps:

The [[GetOwnProperty]] internal method of an arguments object for a
non-strict mode function with formal parameters when called with a
property name _P_ performs the following steps:

The [[DefineOwnProperty]] internal method of an arguments object for a
non-strict mode function with formal parameters when called with a
property name _P_, Property Descriptor _Desc_, and Boolean flag _Throw_
performs the following steps:

The [[Delete]] internal method of an arguments object for a non-strict
mode function with formal parameters when called with a property name
_P_ and Boolean flag _Throw_ performs the following steps:

NOTE 1 For non-strict mode functions the array index (defined in 15.4)
named data properties of an arguments object whose numeric name values
are less than the number of formal parameters of the corresponding
function object initially share their values with the corresponding
argument bindings in the function’s execution context. This means that
changing the property changes the corresponding value of the argument
binding and vice-versa. This correspondence is broken if such a property
is deleted and then redefined or if the property is changed into an
accessor property. For strict mode functions, the values of the
arguments object’s properties are simply a copy of the arguments passed
to the function and there is no dynamic linkage between the property
values and the formal parameter values.

NOTE 2 The ParameterMap object and its property values are used as a
device for specifying the arguments object correspondence to argument
bindings. The ParameterMap object and the objects that are the values of
its properties are not directly accessible from ECMAScript code. An
ECMAScript implementation does not need to actually create or use such
objects to implement the specified semantics.

NOTE 3 Arguments objects for strict mode functions define
non-configurable accessor properties named "CALLER" and "CALLEE" which
throw a TYPEERROR exception on access. The "CALLEE" property has a more
specific meaning for non-strict mode functions and a "CALLER" property
has historically been provided as an implementation-defined extension by
some ECMAScript implementations. The strict mode definition of these
properties exists to ensure that neither of them is defined in any other
manner by conforming ECMAScript implementations.

Syntax

PrimaryExpression :

THIS
Identifier
Literal
ArrayLiteral
ObjectLiteral
( Expression )

The THIS keyword evaluates to the value of the ThisBinding of the
current execution context.

An _Identifier_ is evaluated by performing Identifier Resolution as
specified in 10.3.1 using the _IdentifierName_ corresponding to
_Identifier_. The result of evaluating an _Identifier_ is always a value
of type Reference.

A _Literal_ is evaluated as described in 7.8.

An array initialiser is an expression describing the initialisation of
an Array object, written in a form of a literal. It is a list of zero or
more expressions, each of which represents an array element, enclosed in
square brackets. The elements need not be literals; they are evaluated
each time the array initialiser is evaluated.

Array elements may be elided at the beginning, middle or end of the
element list. Whenever a comma in the element list is not preceded by an
_AssignmentExpression_ (i.e., a comma at the beginning or after another
comma), the missing array element contributes to the length of the Array
and increases the index of subsequent elements. Elided array elements
are not defined. If an element is elided at the end of an array, that
element does not contribute to the length of the Array.

Syntax

ArrayLiteral :

[ Elision~opt~ ]
[ ElementList ]
[ ElementList , Elision~opt~ ]

ElementList :

Elision~opt~ AssignmentExpression
Elision~opt~ … AssignmentExpression
ElementList , Elision~opt~ AssignmentExpression
ElementList , Elision~opt~ … AssignmentExpression

Elision :

,
Elision ,

Semantics

The production _ArrayLiteral_ : [ _Elision_~opt~ ] is evaluated as
follows:

1.  Let _array_ be the result of creating a new object as if by the
    expression NEW ARRAY() where ARRAY is the standard built-in
    constructor with that name.

2.  Let _pad_ be the result of evaluating _Elision_; if not present, use
    the numeric value zero.

3.  Call the [[Put]] internal method of _array_ with arguments "LENGTH",
    _pad_, and FALSE.

4.  Return _array_.

The production _ArrayLiteral_ : [ _ElementList_ ] is evaluated as
follows:

1.  Return the result of evaluating _ElementList_.

The production _ArrayLiteral_ : [ _ElementList_ , _Elision_~opt~ ] is
evaluated as follows:

1.  Let _array_ be the result of evaluating _ElementList_.

2.  Let _pad_ be the result of evaluating _Elision_; if not present, use
    the numeric value zero.

3.  Let _len_ be the result of calling the [[Get]] internal method of
    _array_ with argument "LENGTH".

4.  Call the [[Put]] internal method of _array_ with arguments "LENGTH",
    ToUint32(_pad_+_len_), and FALSE.

5.  Return _array_.

The production _ElementList_ : _Elision_~opt~ _AssignmentExpression_ is
evaluated as follows:

1.  Let _array_ be the result of creating a new object as if by the
    expression NEW ARRAY() where ARRAY is the standard built-in
    constructor with that name.

2.  Let _firstIndex_ be the result of evaluating _Elision_; if not
    present, use the numeric value zero.

3.  Let _initResult_ be the result of evaluating _AssignmentExpression_.

4.  Let _initValue_ be GetValue(_initResult_).

5.  Call the [[DefineOwnProperty]] internal method of _array_ with
    arguments ToString(_firstIndex)_, the Property Descriptor {
    [[Value]]: _initValue_, [[Writable]]: TRUE, [[Enumerable]]: TRUE,
    [[Configurable]]: TRUE}, and FALSE.

6.  Return _array_.

The static semantics of the production _ElementList_ : _Elision_~opt~ _…
AssignmentExpression_ are:

-   It is a Syntax Error if the source code parsed with this production
    is not extended code.

The production _ElementList_ : _Elision_~opt~ _… AssignmentExpression_
is evaluated as follows:

1.  Let _array_ be the result of creating a new object as if by the
    expression NEW ARRAY() where ARRAY is the standard built-in
    constructor with that name.

2.  Let _index_ be the result of evaluating _Elision_; if not present,
    use the numeric value zero.

3.  Let _spreadRef_ be the result of evaluating _AssignmentExpression_.

4.  Let _spreadValue_ be GetValue(_spreadRef_).

5.  Let _spreadObj_ be ToObject(_spreadValue_).

6.  Let _lenVal_ be the result of calling the [[Get]] internal method of
    _spreadObj_ with argument “LENGTH”.

7.  Let _spreadLen_ be ToUint32(_lenVal_).

8.  Let _n_=0;

9.  Repeat, while _n_ < _spreadLen

    a.  Let _exists_ be the result of calling the [[HasProperty]]
          internal method of _spreadObj_ with ToString(_n_).

    b.  If _exists_ is TRUE then,

        i.  Let _v_ be the result of calling the [[Get]] internal method
              of _spreadObj_ passing ToString(_n_) as the argument.

        ii. Call the [[DefineOwnProperty]] internal method of _array_
              with arguments ToString(ToUint32(_index)_), Property
              Descriptor {[[Value]]: _v_, [[Writable]]: TRUE,
              [[Enumerable]]: TRUE, [[Configurable]]: TRUE}, and FALSE.

    c.  Let _n_ = _n_+1.

    d.  Let _index_ = _index_ +1.

10. Return _array_.

The production _ElementList_ : _ElementList_ , _Elision_~opt~
_AssignmentExpression_ is evaluated as follows:

1.  Let _array_ be the result of evaluating _ElementList_.

2.  Let _pad_ be the result of evaluating _Elision_; if not present, use
    the numeric value zero.

3.  Let _initResult_ be the result of evaluating _AssignmentExpression_.

4.  Let _initValue_ be GetValue(_initResult_).

5.  Let _len_ be the result of calling the [[Get]] internal method of
    _array_ with argument "LENGTH".

6.  Call the [[DefineOwnProperty]] internal method of _array_ with
    arguments ToString(ToUint32((_pad_+_len_)) and the Property
    Descriptor { [[Value]]: _initValue_, [[Writable]]: TRUE,
    [[Enumerable]]: TRUE, [[Configurable]]: TRUE}, and FALSE.

7.  Return _array_.

The static semantics of the production _ElementList_ : _ElementList_ ,
_Elision_~opt~ _… AssignmentExpression_ are:

-   It is a Syntax Error if the source code parsed with this production
    is not extended code.

The production _ElementList_ : _ElementList_ , _Elision_~opt~ _…
AssignmentExpression_ is evaluated as follows:

1.  Let _array_ be the result of evaluating _ElementList_.

2.  Let _pad_ be the result of evaluating _Elision_; if not present, use
    the numeric value zero.

3.  Let _spreadRef_ be the result of evaluating _AssignmentExpression_.

4.  Let _spreadValue_ be GetValue(_spreadRef_).

5.  Let _spreadObj_ be ToObject(_spreadValue_).

6.  Let _index_ be the result of calling the [[Get]] internal method of
    _array_ with argument "LENGTH".

7.  Let _lenVal_ be the result of calling the [[Get]] internal method of
    _spreadObj_ with argument “LENGTH”.

8.  Let _spreadLen_ be ToUint32(_lenVal_).

9.  Let _n_=0;

10. Repeat, while _n_ < _spreadLen

    a.  Let _exists_ be the result of calling the [[HasProperty]]
          internal method of _spreadObj_ with ToString(_n_).

    b.  If _exists_ is TRUE then,

        i.  Let _v_ be the result of calling the [[Get]] internal method
              of _spreadObj_ passing ToString(_n_) as the argument.

        ii. Call the [[DefineOwnProperty]] internal method of _array_
              with arguments ToString(ToUint32((_pad_+_index_)) and the
              Property Descriptor { [[Value]]: _v_, [[Writable]]: TRUE,
              [[Enumerable]]: TRUE, [[Configurable]]: TRUE}, and FALSE.

    c.  Let _n_ = _n_+1.

    d.  Let _index_ = _index_ +1.

11. Return _array_.

The production _Elision_ : , is evaluated as follows:

1.  Return the numeric value 1.

The production _Elision_ : _Elision_ , is evaluated as follows:

1.  Let _preceding_ be the result of evaluating _Elision_.

2.  Return _preceding_+1.

NOTE [[DefineOwnProperty]] is used to ensure that own properties are
defined for the array even if the standard built-in Array prototype
object has been modified in a manner that would preclude the creation of
new own properties using [[Put]].

An object initialiser is an expression describing the initialisation of
an Object, written in a form resembling a literal. It is a list of zero
or more pairs of property names and associated values, enclosed in curly
braces. The values need not be literals; they are evaluated each time
the object initialiser is evaluated.

Syntax

ObjectLiteral :

{ }
{ PropertyNameAndValueList }
{ PropertyNameAndValueList , }

PropertyNameAndValueList :

PropertyAssignment
PropertyNameAndValueList , PropertyAssignment

PropertyAssignment :

IdentifierName
PropertyName : AssignmentExpression
GET PropertyName ( ) { FunctionBody }
SET PropertyName ( PropertySetParameterList ) { FunctionBody }

PropertyName :

IdentifierName
StringLiteral
NumericLiteral

PropertySetParameterList :

Identifier

Semantics

The production _ObjectLiteral_ : { } is evaluated as follows:

1.  Return a new object created as if by the expression NEW OBJECT()
    where OBJECT is the standard built-in constructor with that name.

The productions _ObjectLiteral_ : { _PropertyNameAndValueList_ } and
_ObjectLiteral_ : { _PropertyNameAndValueList_ ,} are evaluated as
follows:

1.  Return the result of evaluating _PropertyNameAndValueList_.

The PropertyDefinitionList(_name_) of the production
 _PropertyAssignment_ : _PropertyName_ : _AssignmentExpression_
is determined as follows:

1.  If PropName of _PropertyAssignment_ is not _name_ return the empty
    List.

2.  Return a List containing _PropertyAssignment_.

The production _PropertyNameAndValueList_ : _PropertyAssignment_ is
evaluated as follows:

1.  Let _obj_ be the result of creating a new object as if by the
    expression NEW OBJECT() where OBJECT is the standard built-in
    constructor with that name.

2.  Let _propId_ be the result of evaluating _PropertyAssignment_.

3.  Call the [[DefineOwnProperty]] internal method of _obj_ with
    arguments _propId_.name, _propId_.descriptor, and FALSE.

4.  Return _obj_.

The PropertyDefinitionList(_name_) of the production
 _PropertyNameAndValueList_ : _PropertyNameAndValueList_ ,
_PropertyAssignment
is determined as follows:

1.  Let _previous_ be PropertyDefinitionList(_name_) of
    _PropertyNameAndValueList_.

2.  If PropName of _PropertyAssignment_ is _name_ then,

    a.  Append _PropertyAssignment_ to the end of _previous_.

3.  Return _previous_.

The static semantics of the production _PropertyNameAndValueList_ :
_PropertyNameAndValueList_ , _PropertyAssignment_ are:

-   It is a Syntax Error if this production is contained in strict code,
    _PropertyAssignment_ is the production _PropertyAssignment_ :
    _PropertyName_ : _AssignmentExpression_, and
    PropertyDefinitionList(PropName of _PropertyAssignment_) of
    _PropertyNameAndValueList_ is not the empty List.

-   It is a Syntax Error if _PropertyAssignment_ is the production
     _PropertyAssignment_ : GET _PropertyName_ ( ) { _FunctionBody_ }
    and PropertyDefinitionList (PropName of _PropertyAssignment_) of
    _PropertyNameAndValueList_ includes a production of the form
    _PropertyAssignment_ : _PropertyName_ : _AssignmentExpression_.

-   It is a Syntax Error if _PropertyAssignment_ is the production
     _PropertyAssignment_ : SET _PropertyName_ (
    _PropertySetParameterList_ ) { _FunctionBody_ }
    and PropertyDefinitionList (PropName of _PropertyAssignment_) of
    _PropertyNameAndValueList_ includes a production of the form
    _PropertyAssignment_ : _PropertyName_ : _AssignmentExpression_.

-   It is a Syntax Error if _PropertyAssignment_ is the production
     _PropertyAssignment_ : GET _PropertyName_ ( ) { _FunctionBody_ }
    and PropertyDefinitionList (PropName of _PropertyAssignment_) of
    _PropertyNameAndValueList_ includes a production of the form
    _PropertyAssignment_ : GET _PropertyName_ ( ) { _FunctionBody_ }.

-   It is a Syntax Error if _PropertyAssignment_ is the production
     _PropertyAssignment_ : SET _PropertyName_ (
    _PropertySetParameterList_ ) { _FunctionBody_ }
    and PropertyDefinitionList (PropName of _PropertyAssignment_) of
    _PropertyNameAndValueList_ includes a production of the form
     _PropertyAssignment_ : SET _PropertyName_ (
    _PropertySetParameterList_ ) { _FunctionBody_ }.

The production
 _PropertyNameAndValueList_ : _PropertyNameAndValueList_ ,
_PropertyAssignment
is evaluated as follows:

If the above steps would throw a SYNTAXERROR then an implementation must
treat the error as an early error (Clause 16).

The PropName of the production _PropertyAssignment_ : _IdentifierName_
is determined as follows:

1.  2.  Return PropName(_IdentifierName_).

The production _PropertyAssignment_ : _IdentifierName_ is evaluated as
follows:

1.  Let _propName_ be PropName(_IdentifierName_).

2.  Let _exprValue_ be the result of performing Identifier Resolution as
    specified in 10.3.1 using _IdentifierName_.

3.  Let _propValue_ be GetValue(_exprValue_).

4.  Let _desc_ be the Property Descriptor{[[Value]]: _propValue_,
    [[Writable]]: TRUE, [[Enumerable]]: TRUE, [[Configurable]]: TRUE}

5.  Return Property Identifier (_propName_, _desc_).

The PropName of the production _PropertyAssignment_ : _PropertyName_ :
_AssignmentExpression_ is determined as follows:

1.  Return PropName(_PropertyName_).

The production _PropertyAssignment_ : _PropertyName_ :
_AssignmentExpression_ is evaluated as follows:

1.  Let _propName_ be PropName(_PropertyName_).

2.  Let _exprValue_ be the result of evaluating _AssignmentExpression_.

3.  Let _propValue_ be GetValue(_exprValue_).

4.  Let _desc_ be the Property Descriptor{[[Value]]: _propValue_,
    [[Writable]]: TRUE, [[Enumerable]]: TRUE, [[Configurable]]: TRUE}

5.  Return Property Identifier (_propName_, _desc_).

The PropName of the production _PropertyAssignment_ : GET _PropertyName_
( ) { _FunctionBody_ } is determined as follows:

1.  2.  Return PropName(_PropertyName_).

The production _PropertyAssignment_ : GET _PropertyName_ ( ) {
_FunctionBody_ } is evaluated as follows:

1.  Let _propName_ be PropName(_PropertyName_).

2.  Let _closure_ be the result of creating a new Function object as
    specified in 13.2 with an empty parameter list and body specified by
    _FunctionBody_. Pass in the LexicalEnvironment of the running
    execution context as the _Scope_. Pass in TRUE as the _Strict_ flag
    if the _PropertyAssignment_ is contained in strict code or if its
    _FunctionBody_ is strict code.

3.  Let _desc_ be the Property Descriptor{[[Get]]: _closure_,
    [[Enumerable]]: TRUE, [[Configurable]]: TRUE}

4.  Return Property Identifier (_propName_, _desc_).

The PropName of the production _PropertyAssignment_ : SET _PropertyName_
( _PropertySetParameterList_ ) { _FunctionBody_ } is determined as
follows:

1.  2.  Return the result of PropName(_PropertyName_).

The production _PropertyAssignment_ : SET _PropertyName_ (
_PropertySetParameterList_ ) { _FunctionBody_ } is evaluated as follows:

1.  Let _propName_ be PropName(_PropertyName_).

2.  Let _closure_ be the result of creating a new Function object as
    specified in 13.2 with parameters specified by
    _PropertySetParameterList_ and body specified by _FunctionBody_.
    Pass in the LexicalEnvironment of the running execution context as
    the _Scope_. Pass in TRUE as the _Strict_ flag if the
    _PropertyAssignment_ is contained in strict code or if its
    _FunctionBody_ is strict code.

3.  Let _desc_ be the Property Descriptor{[[Set]]: _closure_,
    [[Enumerable]]: TRUE, [[Configurable]]: TRUE}

4.  Return Property Identifier (_propName_, _desc_).

The static semantics of the production _PropertyAssignment_ : SET
_PropertyName_ ( _PropertySetParameterList_ ) { _FunctionBody_ } are:

-   It is a Syntax Error if the _Identifier_ "EVAL" or the _Identifier_
    "ARGUMENTS" occurs as the _Identifier_ in a
    _PropertySetParameterList_ of a _PropertyAssignment_ that is either
    contained in strict code or whose _FunctionBody_ is strict code.

The PropName of the production _PropertyName_ : _IdentifierName_ is
evaluated as follows:

1.  Return PropName(_IdentifierName_).

The PropName of the production _PropertyName_ : _StringLiteral_ is
evaluated as follows:

1.  Return the SV of the _StringLiteral_.

The PropName of the production _PropertyName_ : _NumericLiteral_ is
evaluated as follows:

1.  Let _nbr_ be the result of forming the value of the
    _NumericLiteral_.

2.  Return ToString(_nbr_).

The PropName of the token _IdentifierName_ is determined as follows:

1.  Return the String value containing the same sequence of characters
    as _IdentifierName_.

The production _PrimaryExpression_ : ( _Expression_ ) is evaluated as
follows:

1.  Return the result of evaluating _Expression_. This may be of type
    Reference.

NOTE This algorithm does not apply GetValue to the result of evaluating
Expression. The principal motivation for this is so that operators such
as DELETE and TYPEOF may be applied to parenthesised expressions.

Syntax

MemberExpression :

PrimaryExpression
FunctionExpression
MemberExpression [ Expression ]
MemberExpression . IdentifierName
NEW MemberExpression Arguments

NewExpression :

MemberExpression
NEW NewExpression

CallExpression :

MemberExpression Arguments
CallExpression Arguments
CallExpression [ Expression ]
CallExpression . IdentifierName

Arguments :

( )
( ArgumentList )

ArgumentList :

AssignmentExpression
... AssignmentExpression
ArgumentList , AssignmentExpression
ArgumentList , ... AssignmentExpression

LeftHandSideExpression :

NewExpression
CallExpression

Properties are accessed by name, using either the dot notation:

MemberExpression . IdentifierName
CallExpression . IdentifierName

or the bracket notation:

MemberExpression [ Expression ]
CallExpression [ Expression ]

The dot notation is explained by the following syntactic conversion:

MemberExpression . IdentifierName

is identical in its behaviour to

MemberExpression [ <identifier-name-string> ]

and similarly

CallExpression . IdentifierName

is identical in its behaviour to

CallExpression [ <identifier-name-string> ]

where _<identifier-name-string>_ is a string literal containing the same
sequence of characters after processing of Unicode escape sequences as
the _IdentifierName_.

The production _MemberExpression_ : _MemberExpression_ [ _Expression_ ]
is evaluated as follows:

The production _CallExpression_ : _CallExpression_ [ _Expression_ ] is
evaluated in exactly the same manner, except that the contained
_CallExpression_ is evaluated in step 1.

The production _NewExpression_ : NEW _NewExpression_ is evaluated as
follows:

1.  Let _ref_ be the result of evaluating _NewExpression_.

2.  Let _constructor_ be GetValue(_ref_).

3.  If Type(_constructor_) is not Object, throw a TYPEERROR exception.

4.  If _constructor_ does not implement the [[Construct]] internal
    method, throw a TYPEERROR exception.

5.  Return the result of calling the [[Construct]] internal method on
    _constructor_, providing no arguments (that is, an empty list of
    arguments).

The production _MemberExpression_ : NEW _MemberExpression_ _Arguments_
is evaluated as follows:

1.  Let _ref_ be the result of evaluating _MemberExpression_.

2.  Let _constructor_ be GetValue(_ref_).

3.  Let _argList_ be the result of evaluating _Arguments_, producing an
    internal list of argument values (11.2.4).

4.  If Type(_constructor_) is not Object, throw a TYPEERROR exception.

5.  If _constructor_ does not implement the [[Construct]] internal
    method, throw a TYPEERROR exception.

6.  Return the result of calling the [[Construct]] internal method on
    _constructor_, providing the list _argList_ as the argument values.

The production _CallExpression_ : _MemberExpression_ _Arguments_ is
evaluated as follows:

1.  Let _ref_ be the result of evaluating _MemberExpression_.

2.  Let _func_ be GetValue(_ref_).

3.  Let _argList_ be the result of evaluating _Arguments_, producing an
    internal list of argument values (see 11.2.4).

4.  If Type(_func_) is not Object, throw a TYPEERROR exception.

5.  If IsCallable(_func_) is FALSE, throw a TYPEERROR exception.

6.  If Type(_ref_) is Reference, then

    a.  If IsPropertyReference(_ref_) is TRUE, then

        i.  Let _thisValue_ be GetBase(_ref_).

    b.  Else, the base of _ref_ is an Environment Record

        i.  Let _thisValue_ be the result of calling the
            ImplicitThisValue concrete method of GetBase(_ref_).

7.  Else, Type(_ref_) is not Reference.

    a.  Let _thisValue_ be UNDEFINED.

8.  Return the result of calling the [[Call]] internal method on _func_,
    providing _thisValue_ as the THIS value and providing the list
    _argList_ as the argument values.

The production _CallExpression_ : _CallExpression_ _Arguments_ is
evaluated in exactly the same manner, except that the contained
_CallExpression_ is evaluated in step 1.

NOTE The returned result will never be of type Reference if _func_ is a
native ECMAScript object. Whether calling a host object can return a
value of type Reference is implementation-dependent. If a value of type
Reference is returned, it must be a non-strict Property Reference.

The evaluation of an argument list produces a List of values (see 8.8).

The production _Arguments_ : ( ) is evaluated as follows:

1.  Return an empty List.

The production _Arguments_ : ( _ArgumentList_ ) is evaluated as follows:

1.  Return the result of evaluating _ArgumentList_.

The production _ArgumentList_ : _AssignmentExpression_ is evaluated as
follows:

1.  Let _ref_ be the result of evaluating _AssignmentExpression_.

2.  Let _arg_ be GetValue(_ref_).

3.  Return a List whose sole item is _arg_.

The static semantics of the production _ArgumentList_ : _…
AssignmentExpression_ are:

-   It is a Syntax Error if the source code parsed with this production
    is not extended code.

The production _ArgumentList_ : _… AssignmentExpression_ is evaluated as
follows:

1.  Let _list_ be an empty List.

2.  Let _spreadRef_ be the result of evaluating _AssignmentExpression_.

3.  Let _spreadValue_ be GetValue(_spreadRef_).

4.  Let _spreadObj_ be ToObject(_spreadValue_).

5.  Let _lenVal_ be the result of calling the [[Get]] internal method of
    _spreadObj_ with argument “LENGTH”.

6.  Let _spreadLen_ be ToUint32(_lenVal_).

7.  Let _n_ = 0.

8.  Repeat, while _n_ < _spreadLen

    a.  Let _nextArg_ be the result of calling the [[Get]] internal
          method of _spreadObj_ passing ToString(_n_) as the argument.

    b.  Append _nextArg_ as the last element of _list_.

    c.  Let _n_ = _n_+1.

9.  Return _list_.

The production _ArgumentList_ : _ArgumentList_ , _AssignmentExpression_
is evaluated as follows:

1.  Let _precedingArgs_ be the result of evaluating _ArgumentList_.

2.  Let _ref_ be the result of evaluating _AssignmentExpression_.

3.  Let _arg_ be GetValue(_ref_).

4.  Return a List whose length is one greater than the length of
    _precedingArgs_ and whose items are the items of _precedingArgs_, in
    order, followed at the end by _arg_ which is the last item of the
    new list.

The static semantics of the production _ArgumentList_ : _ArgumentList_ ,
_… __AssignmentExpression_ are:

-   It is a Syntax Error if the source code parsed with this production
    is not extended code.

The production _ArgumentList_ : _ArgumentList_ , _…
__AssignmentExpression_ is evaluated as follows:

1.  Let _precedingArgs_ be an empty List.

2.  Let _spreadRef_ be the result of evaluating _AssignmentExpression_.

3.  Let _spreadValue_ be GetValue(_spreadRef_).

4.  Let _spreadObj_ be ToObject(_spreadValue_).

5.  Let _lenVal_ be the result of calling the [[Get]] internal method of
    _spreadObj_ with argument “LENGTH”.

6.  Let _spreadLen_ be ToUint32(_lenVal_).

7.  Let _n_ = 0.

8.  Repeat, while _n_ < _spreadLen

    a.  Let _nextArg_ be the result of calling the [[Get]] internal
          method of _spreadObj_ passing ToString(_n_) as the argument.

    b.  Append _nextArg_ as the last element of _precedingArgs_.

    c.  Let _n_ = _n_+1.

9.  Return _precedingArgs_.

The production _MemberExpression_ : _FunctionExpression_ is evaluated as
follows:

1.  Return the result of evaluating _FunctionExpression_.

Syntax

PostfixExpression :

LeftHandSideExpression
LeftHandSideExpression [no LineTerminator here] ++
LeftHandSideExpression [no LineTerminator here] --

The production _PostfixExpression_ : _LeftHandSideExpression_ [no
_LineTerminator_ here] ++ is evaluated as follows:

1.  Let _lhs_ be the result of evaluating _LeftHandSideExpression_.

2.  Throw a SYNTAXERROR exception if the following conditions are all
    true:

-   Type(_lhs_) is Reference is TRUE

-   IsStrictReference(_lhs_) is TRUE

-   Type(GetBase(_lhs_)) is Environment Record

-   GetReferencedName(_lhs_) is either "EVAL" or "ARGUMENTS"

1.  Let _oldValue_ be ToNumber(GetValue(_lhs_)).

2.  Let _newValue_ be the result of adding the value 1 to _oldValue_,
    using the same rules as for the + operator (see 11.6.3).

3.  Call PutValue(_lhs_, _newValue_).

4.  Return _oldValue_.

The production _PostfixExpression_ : _LeftHandSideExpression_ [no
_LineTerminator_ here] -- is evaluated as follows:

1.  Let _lhs_ be the result of evaluating _LeftHandSideExpression_.

2.  Throw a SYNTAXERROR exception if the following conditions are all
    true:

-   Type(_lhs_) is Reference is TRUE

-   IsStrictReference(_lhs_) is TRUE

-   Type(GetBase(_lhs_)) is Environment Record

-   GetReferencedName(_lhs_) is either "EVAL" or "ARGUMENTS"

1.  Let _oldValue_ be ToNumber(GetValue(_lhs_)).

2.  Let _newValue_ be the result of subtracting the value 1 from
    _oldValue_, using the same rules as for the - operator (11.6.3).

3.  Call PutValue(_lhs_, _newValue_).

4.  Return _oldValue_.

Syntax

UnaryExpression :

PostfixExpression
DELETE UnaryExpression
VOID UnaryExpression
TYPEOF UnaryExpression
++ UnaryExpression
-- UnaryExpression
+ UnaryExpression
- UnaryExpression
~ UnaryExpression
! UnaryExpression

The production _UnaryExpression_ : DELETE _UnaryExpression_ is evaluated
as follows:

1.  Let _ref_ be the result of evaluating _UnaryExpression_.

2.  If Type(_ref_) is not Reference, return TRUE.

3.  If IsUnresolvableReference(_ref_) then,

    a.  If IsStrictReference(_ref_) is TRUE, throw a SYNTAXERROR
        exception.

    b.  Else, return TRUE.

4.  If IsPropertyReference(_ref_) is TRUE, then

    a.  Return the result of calling the [[Delete]] internal method on
        ToObject(GetBase(_ref)_) providing GetReferencedName(_ref_) and
        IsStrictReference(_ref_) as the arguments.

5.  Else, _ref_ is a Reference to an Environment Record binding, so

    a.  If IsStrictReference(_ref_) is TRUE, throw a SYNTAXERROR
        exception.

    b.  Let _bindings_ be GetBase(_ref_).

    c.  Return the result of calling the DeleteBinding concrete method
        of _bindings_, providing GetReferencedName(_ref_) as the
        argument.

NOTE When a DELETE operator occurs within strict mode code, a
SYNTAXERROR exception is thrown if its _UnaryExpression_ is a direct
reference to a variable, function argument, or function name. In
addition, if a DELETE operator occurs within strict mode code and the
property to be deleted has the attribute { [[Configurable]]: FALSE }, a
TYPEERROR exception is thrown.

The production _UnaryExpression_ : VOID _UnaryExpression_ is evaluated
as follows:

1.  Let _expr_ be the result of evaluating _UnaryExpression_.

2.  Call GetValue(_expr_).

3.  Return UNDEFINED.

NOTE GetValue must be called even though its value is not used because
it may have observable side-effects.

The production _UnaryExpression_ : TYPEOF _UnaryExpression_ is evaluated
as follows:

1.  Let _val_ be the result of evaluating _UnaryExpression_.

2.  If Type(_val_) is Reference, then

    a.  If IsUnresolvableReference(_val_) is TRUE, return "UNDEFINED".

    b.  Let _val_ be GetValue(_val_).

3.  Return a String determined by Type(_val_) according to Table 21.

Table 21 — typeof Operator Results

  ----------------------------------------------------- -----------------------------------------------------------------------------------------
  _TYPE OF val_                                         _RESULT_
  Undefined                                             "UNDEFINED"
  Null                                                  "OBJECT"
  Boolean                                               "BOOLEAN"
  Number                                                "NUMBER"
  String                                                "STRING"
  Object (native and does not implement [[Call]])       "OBJECT"
  Object (native or host and does implement [[Call]])   "FUNCTION"
  Object (host and does not implement [[Call]])         Implementation-defined except may not be "UNDEFINED", "BOOLEAN", "NUMBER", or "STRING".
  ----------------------------------------------------- -----------------------------------------------------------------------------------------

The production _UnaryExpression_ : ++ _UnaryExpression_ is evaluated as
follows:

1.  Let _expr_ be the result of evaluating UnaryExpression.

2.  Throw a SYNTAXERROR exception if the following conditions are all
    true:

-   Type(_expr_) is Reference is TRUE

-   IsStrictReference(_expr_) is TRUE

-   Type(GetBase(_expr_)) is Environment Record

-   GetReferencedName(_expr_) is either "EVAL" or "ARGUMENTS"

1.  Let _oldValue_ be ToNumber(GetValue(_expr_)).

2.  Let _newValue_ be the result of adding the value 1 to _oldValue_,
    using the same rules as for the + operator (see 11.6.3).

3.  Call PutValue(_expr_, _newValue_).

4.  Return _newValue_.

The production _UnaryExpression_ : -- _UnaryExpression_ is evaluated as
follows:

1.  Let _expr_ be the result of evaluating UnaryExpression.

2.  Throw a SYNTAXERROR exception if the following conditions are all
    true:

-   Type(_expr_) is Reference is TRUE

-   IsStrictReference(_expr_) is TRUE

-   Type(GetBase(_expr_)) is Environment Record

-   GetReferencedName(_expr_) is either "EVAL" or "ARGUMENTS"

1.  Let _oldValue_ be ToNumber(GetValue(_expr_)).

2.  Let _newValue_ be the result of subtracting the value 1 from
    _oldValue_, using the same rules as for the - operator (see 11.6.3).

3.  Call PutValue(_expr_, _newValue_).

4.  Return _newValue_.

The unary + operator converts its operand to Number type.

The production _UnaryExpression_ : + _UnaryExpression_ is evaluated as
follows:

1.  Let _expr_ be the result of evaluating UnaryExpression.

2.  Return ToNumber(GetValue(_expr_)).

The unary - operator converts its operand to Number type and then
negates it. Note that negating +0 produces −0, and negating −0 produces
+0.

The production _UnaryExpression_ : - _UnaryExpression_ is evaluated as
follows:

1.  Let _expr_ be the result of evaluating UnaryExpression.

2.  Let _oldValue_ be ToNumber(GetValue(_expr_)).

3.  If _oldValue_ is NAN, return NAN.

4.  Return the result of negating _oldValue_; that is, compute a Number
    with the same magnitude but opposite sign.

The production _UnaryExpression_ : ~ _UnaryExpression_ is evaluated as
follows:

1.  Let _expr_ be the result of evaluating _UnaryExpression_.

2.  Let _oldValue_ be ToInt32(GetValue(_expr_)).

3.  Return the result of applying bitwise complement to _oldValue_. The
    result is a signed 32-bit integer.

The production _UnaryExpression_ : ! _UnaryExpression_ is evaluated as
follows:

1.  Let _expr_ be the result of evaluating _UnaryExpression_.

2.  Let _oldValue_ be ToBoolean(GetValue(_expr_)).

3.  If _oldValue_ is TRUE, return FALSE.

4.  Return TRUE.

Syntax

MultiplicativeExpression :

UnaryExpression
MultiplicativeExpression * UnaryExpression
MultiplicativeExpression / UnaryExpression
MultiplicativeExpression % UnaryExpression

Semantics

The production _MultiplicativeExpression_ : _MultiplicativeExpression @
UnaryExpression_, where @ stands for one of the operators in the above
definitions, is evaluated as follows:

1.  Let _left_ be the result of evaluating MultiplicativeExpression.

2.  Let _leftValue_ be GetValue(_left_).

3.  Let _right_ be the result of evaluating UnaryExpression.

4.  Let _rightValue_ be GetValue(_right_).

5.  Let _leftNum_ be ToNumber(_leftValue_).

6.  Let _rightNum_ be ToNumber(_rightValue_).

7.  Return the result of applying the specified operation (*, /, or %)
    to _leftNum_ and _rightNum_. See the Notes below 11.5.1, 11.5.2,
    11.5.3.

The * operator performs multiplication, producing the product of its
operands. Multiplication is commutative. Multiplication is not always
associative in ECMAScript, because of finite precision.

The result of a floating-point multiplication is governed by the rules
of IEEE 754 binary double-precision arithmetic:

-   If either operand is NAN, the result is NAN.

-   The sign of the result is positive if both operands have the same
      sign, negative if the operands have different signs.

-   Multiplication of an infinity by a zero results in NAN.

-   Multiplication of an infinity by an infinity results in an infinity.
      The sign is determined by the rule already stated above.

-   Multiplication of an infinity by a finite nonzero value results in a
      signed infinity. The sign is determined by the rule already stated
      above.

-   In the remaining cases, where neither an infinity or NaN is
      involved, the product is computed and rounded to the nearest
      representable value using IEEE 754 round-to-nearest mode. If the
      magnitude is too large to represent, the result is then an
      infinity of appropriate sign. If the magnitude is too small to
      represent, the result is then a zero of appropriate sign. The
      ECMAScript language requires support of gradual underflow as
      defined by IEEE 754.

The / operator performs division, producing the quotient of its
operands. The left operand is the dividend and the right operand is the
divisor. ECMAScript does not perform integer division. The operands and
result of all division operations are double-precision floating-point
numbers. The result of division is determined by the specification of
IEEE 754 arithmetic:

-   If either operand is NAN, the result is NAN.

-   The sign of the result is positive if both operands have the same
      sign, negative if the operands have different signs.

-   Division of an infinity by an infinity results in NAN.

-   Division of an infinity by a zero results in an infinity. The sign
      is determined by the rule already stated above.

-   Division of an infinity by a nonzero finite value results in a
      signed infinity. The sign is determined by the rule already stated
      above.

-   Division of a finite value by an infinity results in zero. The sign
      is determined by the rule already stated above.

-   Division of a zero by a zero results in NAN; division of zero by any
      other finite value results in zero, with the sign determined by
      the rule already stated above.

-   Division of a nonzero finite value by a zero results in a signed
      infinity. The sign is determined by the rule already stated above.

-   In the remaining cases, where neither an infinity, nor a zero, nor
      NAN is involved, the quotient is computed and rounded to the
      nearest representable value using IEEE 754 round-to-nearest mode.
      If the magnitude is too large to represent, the operation
      overflows; the result is then an infinity of appropriate sign. If
      the magnitude is too small to represent, the operation underflows
      and the result is a zero of the appropriate sign. The ECMAScript
      language requires support of gradual underflow as defined by IEEE
      754.

The % operator yields the remainder of its operands from an implied
division; the left operand is the dividend and the right operand is the
divisor.

NOTE In C and C++, the remainder operator accepts only integral
operands; in ECMAScript, it also accepts floating-point operands.

The result of a floating-point remainder operation as computed by the %
operator is not the same as the “remainder” operation defined by IEEE
754. The IEEE 754 “remainder” operation computes the remainder from a
rounding division, not a truncating division, and so its behaviour is
not analogous to that of the usual integer remainder operator. Instead
the ECMAScript language defines % on floating-point operations to behave
in a manner analogous to that of the Java integer remainder operator;
this may be compared with the C library function fmod.

The result of an ECMAScript floating-point remainder operation is
determined by the rules of IEEE arithmetic:

-   If either operand is NAN, the result is NAN.

    -   The sign of the result equals the sign of the dividend.

    -   If the dividend is an infinity, or the divisor is a zero, or
          both, the result is NAN.

    -   If the dividend is finite and the divisor is an infinity, the
          result equals the dividend.

    -   If the dividend is a zero and the divisor is nonzero and finite,
          the result is the same as the dividend.

    -   In the remaining cases, where neither an infinity, nor a zero,
          nor NAN is involved, the floating-point remainder r from a
          dividend n and a divisor d is defined by the mathematical
          relation r = n − (d × q) where q is an integer that is
          negative only if n/d is negative and positive only if n/d is
          positive, and whose magnitude is as large as possible without
          exceeding the magnitude of the true mathematical quotient of n
          and d. r is computed and rounded to the nearest representable
          value using IEEE 754 round-to-nearest mode.

Syntax

AdditiveExpression :

MultiplicativeExpression
AdditiveExpression + MultiplicativeExpression
AdditiveExpression - MultiplicativeExpression

The addition operator either performs string concatenation or numeric
addition.

The production _AdditiveExpression_ : _AdditiveExpression_ +
_MultiplicativeExpression_ is evaluated as follows:

NOTE 1 No hint is provided in the calls to ToPrimitive in steps 5 and 6.
All native ECMAScript objects except Date objects handle the absence of
a hint as if the hint Number were given; Date objects handle the absence
of a hint as if the hint String were given. Host objects may handle the
absence of a hint in some other manner.

NOTE 2 Step 7 differs from step 3 of the comparison algorithm for the
relational operators (11.8.5), by using the logical-or operation instead
of the logical-and operation.

The production _AdditiveExpression_ : _AdditiveExpression_ -
_MultiplicativeExpression_ is evaluated as follows:

The + operator performs addition when applied to two operands of numeric
type, producing the sum of the operands. The - operator performs
subtraction, producing the difference of two numeric operands.

Addition is a commutative operation, but not always associative.

The result of an addition is determined using the rules of IEEE 754
binary double-precision arithmetic:

-   If either operand is NAN, the result is NAN.

-   The sum of two infinities of opposite sign is NAN.

-   The sum of two infinities of the same sign is the infinity of that
      sign.

-   The sum of an infinity and a finite value is equal to the infinite
      operand.

-   The sum of two negative zeroes is −0. The sum of two positive
      zeroes, or of two zeroes of opposite sign, is +0.

-   The sum of a zero and a nonzero finite value is equal to the nonzero
      operand.

-   The sum of two nonzero finite values of the same magnitude and
      opposite sign is +0.

-   In the remaining cases, where neither an infinity, nor a zero, nor
      NaN is involved, and the operands have the same sign or have
      different magnitudes, the sum is computed and rounded to the
      nearest representable value using IEEE 754 round-to-nearest mode.
      If the magnitude is too large to represent, the operation
      overflows and the result is then an infinity of appropriate sign.
      The ECMAScript language requires support of gradual underflow as
      defined by IEEE 754.

The - operator performs subtraction when applied to two operands of
numeric type, producing the difference of its operands; the left operand
is the minuend and the right operand is the subtrahend. Given numeric
operands _a_ and _b_, it is always the case that _a–b_ produces the same
result as _a +(–b)_.

Syntax

ShiftExpression :

AdditiveExpression
ShiftExpression << AdditiveExpression
ShiftExpression >> AdditiveExpression
ShiftExpression >>> AdditiveExpression

Performs a bitwise left shift operation on the left operand by the
amount specified by the right operand.

The production _ShiftExpression_ : _ShiftExpression_ <<
_AdditiveExpression_ is evaluated as follows:

Performs a sign-filling bitwise right shift operation on the left
operand by the amount specified by the right operand.

The production _ShiftExpression_ : _ShiftExpression_ >>
_AdditiveExpression_ is evaluated as follows:

Performs a zero-filling bitwise right shift operation on the left
operand by the amount specified by the right operand.

The production _ShiftExpression_ : _ShiftExpression_ >>>
_AdditiveExpression_ is evaluated as follows:

Syntax

RelationalExpression :

ShiftExpression
RelationalExpression < ShiftExpression
RelationalExpression > ShiftExpression
RelationalExpression <= ShiftExpression
RelationalExpression >= ShiftExpression
RelationalExpression INSTANCEOF ShiftExpression
RelationalExpression IN ShiftExpression

RelationalExpressionNoIn :

ShiftExpression
RelationalExpressionNoIn < ShiftExpression
RelationalExpressionNoIn > ShiftExpression
RelationalExpressionNoIn <= ShiftExpression
RelationalExpressionNoIn >= ShiftExpression
RelationalExpressionNoIn INSTANCEOF ShiftExpression

NOTE The “NoIn” variants are needed to avoid confusing the in operator
in a relational expression with the in operator in a for statement.

Semantics

The result of evaluating a relational operator is always of type
Boolean, reflecting whether the relationship named by the operator holds
between its two operands.

The _RelationalExpressionNoIn_ productions are evaluated in the same
manner as the _RelationalExpression_ productions except that the
contained _RelationalExpressionNoIn_ is evaluated instead of the
contained _RelationalExpression_.

The production _RelationalExpression_ : _RelationalExpression_ <
_ShiftExpression_ is evaluated as follows:

The production RelationalExpression : _RelationalExpression_ >
_ShiftExpression_ is evaluated as follows:

The production RelationalExpression : _RelationalExpression_ <=
_ShiftExpression_ is evaluated as follows:

The production RelationalExpression : _RelationalExpression_ >=
_ShiftExpression_ is evaluated as follows:

The comparison _x_ < _y_, where _x_ and _y_ are values, produces TRUE,
FALSE, or UNDEFINED (which indicates that at least one operand is NAN).
In addition to _x_ and _y_ the algorithm takes a Boolean flag named
_LeftFirst_ as a parameter. The flag is used to control the order in
which operations with potentially visible side-effects are performed
upon _x_ and _y_. It is necessary because ECMAScript specifies left to
right evaluation of expressions. The default value of _LeftFirst_ is
TRUE and indicates that the _x_ parameter corresponds to an expression
that occurs to the left of the _y_ parameter’s corresponding expression.
If _LeftFirst_ is FALSE, the reverse is the case and operations must be
performed upon _y_ before _x_. Such a comparison is performed as
follows:

NOTE 1 Step 3 differs from step 7 in the algorithm for the addition
operator + (11.6.1) in using and instead of or.

NOTE 2 The comparison of Strings uses a simple lexicographic ordering on
sequences of code unit values. There is no attempt to use the more
complex, semantically oriented definitions of character or string
equality and collating order defined in the Unicode specification.
Therefore String values that are canonically equal according to the
Unicode standard could test as unequal. In effect this algorithm assumes
that both Strings are already in normalised form. Also, note that for
strings containing supplementary characters, lexicographic ordering on
sequences of UTF-16 code unit values differs from that on sequences of
code point values.

The production _RelationalExpression_: _RelationalExpression_ INSTANCEOF
_ShiftExpression_ is evaluated as follows:

The production _RelationalExpression_ : _RelationalExpression_ IN
_ShiftExpression_ is evaluated as follows:

Syntax

EqualityExpression :

RelationalExpression
EqualityExpression == RelationalExpression
EqualityExpression != RelationalExpression
EqualityExpression === RelationalExpression
EqualityExpression !== RelationalExpression

EqualityExpressionNoIn :

RelationalExpressionNoIn
EqualityExpressionNoIn == RelationalExpressionNoIn
EqualityExpressionNoIn != RelationalExpressionNoIn
EqualityExpressionNoIn === RelationalExpressionNoIn
EqualityExpressionNoIn !== RelationalExpressionNoIn

Semantics

The result of evaluating an equality operator is always of type Boolean,
reflecting whether the relationship named by the operator holds between
its two operands.

The _EqualityExpressionNoIn_ productions are evaluated in the same
manner as the _EqualityExpression_ productions except that the contained
_EqualityExpressionNoIn_ and _RelationalExpressionNoIn_ are evaluated
instead of the contained _EqualityExpression_ and
_RelationalExpression_, respectively.

The production EqualityExpression : _EqualityExpression_ ==
_RelationalExpression_ is evaluated as follows:

The production EqualityExpression : _EqualityExpression_ !=
_RelationalExpression_ is evaluated as follows:

The comparison _x_ == _y_, where _x_ and _y_ are values, produces TRUE
or FALSE. Such a comparison is performed as follows:

NOTE 1 Given the above definition of equality:

-   String comparison can be forced by: "" + A == "" + B.

-   Numeric comparison can be forced by: +A == +B.

-   Boolean comparison can be forced by: !A == !B.

NOTE 2 The equality operators maintain the following invariants:

-   A != B is equivalent to !(A == B).

-   A == B is equivalent to B == A, except in the order of evaluation of
      A and B.

NOTE 3 The equality operator is not always transitive. For example,
there might be two distinct String objects, each representing the same
String value; each String object would be considered equal to the String
value by the == operator, but the two String objects would not be equal
to each other. For Example:

-   NEW STRING("A") == "A" and "A" == NEW STRING("A")are both TRUE.

-   NEW STRING("A") == NEW STRING("A") is FALSE.

NOTE 4 Comparison of Strings uses a simple equality test on sequences of
code unit values. There is no attempt to use the more complex,
semantically oriented definitions of character or string equality and
collating order defined in the Unicode specification. Therefore Strings
values that are canonically equal according to the Unicode standard
could test as unequal. In effect this algorithm assumes that both
Strings are already in normalised form.

The production EqualityExpression : _EqualityExpression_ ===
_RelationalExpression_ is evaluated as follows:

The production EqualityExpression : _EqualityExpression_ !==
_RelationalExpression_ is evaluated as follows:

The comparison _x_ === _y_, where _x_ and _y_ are values, produces TRUE
or FALSE. Such a comparison is performed as follows:

NOTE This algorithm differs from the SameValue Algorithm (9.12) in its
treatment of signed zeroes and NaNs.

Syntax

BitwiseANDExpression :

EqualityExpression
BitwiseANDExpression & EqualityExpression

BitwiseANDExpressionNoIn :

EqualityExpressionNoIn
BitwiseANDExpressionNoIn & EqualityExpressionNoIn

BitwiseXORExpression :

BitwiseANDExpression
BitwiseXORExpression ^ BitwiseANDExpression

BitwiseXORExpressionNoIn :

BitwiseANDExpressionNoIn
BitwiseXORExpressionNoIn ^ BitwiseANDExpressionNoIn

BitwiseORExpression :

BitwiseXORExpression
BitwiseORExpression | BitwiseXORExpression

BitwiseORExpressionNoIn :

BitwiseXORExpressionNoIn
BitwiseORExpressionNoIn | BitwiseXORExpressionNoIn

Semantics

The production _A_ : _A @ B_, where @ is one of the bitwise operators in
the productions above, is evaluated as follows:

Syntax

LogicalANDExpression :

BitwiseORExpression
LogicalANDExpression && BitwiseORExpression

LogicalANDExpressionNoIn :

BitwiseORExpressionNoIn
LogicalANDExpressionNoIn && BitwiseORExpressionNoIn

LogicalORExpression :

LogicalANDExpression
LogicalORExpression || LogicalANDExpression

LogicalORExpressionNoIn :

LogicalANDExpressionNoIn
LogicalORExpressionNoIn || LogicalANDExpressionNoIn

Semantics

The production _LogicalANDExpression_ : _LogicalANDExpression_ &&
_BitwiseORExpression_ is evaluated as follows:

The production _LogicalORExpression_ : _LogicalORExpression_ ||
_LogicalANDExpression_ is evaluated as follows:

The _LogicalANDExpressionNoIn_ and _LogicalORExpressionNoIn_ productions
are evaluated in the same manner as the _LogicalANDExpression_ and
_LogicalORExpression_ productions except that the contained
_LogicalANDExpressionNoIn_, _BitwiseORExpressionNoIn_ and
_LogicalORExpressionNoIn_ are evaluated instead of the contained
_LogicalANDExpression_, _BitwiseORExpression_ and _LogicalORExpression_,
respectively.

NOTE The value produced by a && or || operator is not necessarily of
type Boolean. The value produced will always be the value of one of the
two operand expressions.

Syntax

ConditionalExpression :

LogicalORExpression
LogicalORExpression ? AssignmentExpression : AssignmentExpression

ConditionalExpressionNoIn :

LogicalORExpressionNoIn
LogicalORExpressionNoIn ? AssignmentExpression :
AssignmentExpressionNoIn

Semantics

The production _ConditionalExpression_ : _LogicalORExpression_ ?
_AssignmentExpression_ : _AssignmentExpression_ is evaluated as follows:

The _ConditionalExpressionNoIn_ production is evaluated in the same
manner as the _ConditionalExpression_ production except that the
contained _LogicalORExpressionNoIn_, _AssignmentExpression_ and
_AssignmentExpressionNoIn_ are evaluated instead of the contained
_LogicalORExpression_, first _AssignmentExpression_ and second
_AssignmentExpression_, respectively.

NOTE The grammar for a ConditionalExpression in ECMAScript is a little
bit different from that in C and Java, which each allow the second
subexpression to be an Expression but restrict the third expression to
be a ConditionalExpression. The motivation for this difference in
ECMAScript is to allow an assignment expression to be governed by either
arm of a conditional and to eliminate the confusing and fairly useless
case of a comma expression as the centre expression.

Syntax

AssignmentExpression :

ConditionalExpression
LeftHandSideExpression = AssignmentExpression
LeftHandSideExpression AssignmentOperator AssignmentExpression

AssignmentExpressionNoIn :

ConditionalExpressionNoIn
LeftHandSideExpression = AssignmentExpressionNoIn
LeftHandSideExpression AssignmentOperator AssignmentExpressionNoIn

AssignmentOperator : ONE OF

  ---- ---- ---- ---- ---- ----- ----- ------ ---- ---- ----
  *=   /=   %=   +=   -=   <<=   >>=   >>>=   &=   ^=   |=
  ---- ---- ---- ---- ---- ----- ----- ------ ---- ---- ----

Supplemental Syntax

In certain circumstances when processing the production
_AssignmentExpression_ : _LeftHandSideExpression_ =
_AssignmentExpression_ the following grammar is used to refine the
interpretation of _LeftHandSideExpression_.

AssignmentPattern :

ObjectAssignmentPattern
ArrayAssignmentPattern

ObjectAssignmentPattern :

{ }
{ AssignmentPropertyList }
{ AssignmentPropertyList , }

ArrayAssignmentPattern :

[ Elision~opt~ AssignmentRestElement~opt~ ]
[ AssignmentElementList , Elision~opt~ AssignmentRestElement~opt~ ]

AssignmentPropertyList :

AssignmentProperty
AssignmentPropertyList , AssignmentProperty

AssignmentElementList :

Elision~opt~ AssignmentElement
AssignmentElementList , Elision~opt~ AssignmentElement

AssignmentProperty :

Identifier
PropertyName : LeftHandSideExpression

AssignmentElement :

LeftHandSideExpression

AssignmentRestElement :

… LeftHandSideExpression

Semantics

The _AssignmentExpressionNoIn_ productions are evaluated in the same
manner as the _AssignmentExpression_ productions except that the
contained _ConditionalExpressionNoIn_ and _AssignmentExpressionNoIn_ are
evaluated instead of the contained _ConditionalExpression_ and
_AssignmentExpression_, respectively.

The static semantics of _AssignmentExpression_ :
_LeftHandSideExpression_ = _AssignmentExpression_ are:

-   It is a Syntax Error if the _AssignmentExpression_ is contained in
    strict code and _LeftHandSideExpression_ is the _Identifier_ EVAL or
    the _Identifier_ ARGUMENTS.

-   -   It is a Syntax Error if the _AssignmentExpression_ is contained
    in extended code and the _LeftHandSideExpression_ is a _Literal_ or
    a _FunctionExpression_.

-   It is a Syntax Error if the _AssignmentExpression_ is contained in
    extended code and the _LeftHandSideExpression_ is an _Identifier_
    that does not statically resolve to a declarative environment record
    binding or if the resolved binding an immutable binding.

-   It is a Syntax Error if the _LeftHandSideExpression_ is
    _PrimaryExpression_ : ( _Expression_ ) and _Expression_ derived a
    production that would produce a Syntax Error according to these
    rules. This rule is recursively applied.

-   It is a Syntax Error if the _AssignmentExpression_ is contained in
    extended code and the _LeftHandSideExpression_ is an _ObjectLiteral_
    or an _ArrayLiteral_ and the source code corresponding to
    _LeftHandSideExpression_ cannot be parsed using _AssignmentPattern_
    as the goal symbol.

The production _AssignmentExpression_ : _LeftHandSideExpression_ =
_AssignmentExpression_ is evaluated as follows:

NOTE When an assignment occurs within strict mode code, _lref_ in step
1.d must not be an unresolvable reference. If it is, a REFERENCEERROR
exception is thrown upon assignment. The _LeftHandSide_ also may not be
a reference to a data property with the attribute value
{[[Writable]]:FALSE}, to an accessor property with the attribute value
{[[Set]]:UNDEFINED}, nor to a non-existent property of an object whose
[[Extensible]] internal property has the value FALSE. In these cases a
TYPEERROR exception is thrown.

The supplemental production _AssignmentPattern_ :
_ObjectAssignmentPattern_ is evaluated with the parameter _obj_ as
follows:

1.  Evaluate _ObjectAssignmentPattern_ using _obj_ as the _obj
    parameter.

The supplemental production _AssignmentPattern_ :
_ArrayAssignmentPattern_ is evaluated with the parameter _obj_ as
follows:

1.  Evaluate _ArrayAssignmentPattern_ using _obj_ as the _obj
    parameter.

The supplemental production _ObjectAssignmentPattern_ : { } ,the
production _ArrayAssignmentPattern_ : [ ] and the production
_ArrayAssignmentPattern_ : [ _Elision_ ] when evaluated with the
parameter _obj_ do nothing.

The supplemental productions _ObjectAssignmentPattern_ : {
_AssignmentPropertyList_ } and _ObjectAssignmentPattern_ : {
_AssignmentPropertyList_ , } are evaluated with the parameter _obj_ as
follows:

1.  Evaluate _AssignmentPropertyList_ using _obj_ as the _obj
    parameter.

The supplemental production _AssignmentPropertyList_ :
_AssignmentProperty_ is evaluated with the parameter _obj_ as follows:

1.  Evaluate _AssignmentProperty_ using _obj_ as the _obj_ parameter.

The supplemental production _AssignmentPropertyList_ :
_AssignmentPropertyList_ , _AssignmentProperty_ is evaluated with the
parameter _obj_ as follows:

1.  Evaluate _AssignmentPropertyList_ using _obj_ as the _obj
    parameter.

2.  Evaluate _AssignmentProperty_ using _obj_ as the _obj_ parameter.

The supplemental production _AssignmentProperty_ : _Identifier_ is
evaluated with the parameter _obj_ as follows:

1.  Let _v_ be the result of calling the [[Get]] internal method of
    _obj_ passing the _Identifier_ string as the argument.

2.  Let _lref_ be the result of performing Identifier Resolution(10.3.1)
    using the _IdentifierName_ corresponding to _Identifier_.

3.  Call PutValue(_lref_,_v_).

The static semantics of the supplemental production
_AssignmentProperty_ : _PropertyName_ : _LeftHandSideExpression_ and the
supplemental production
_AssignmentElement_ : _LeftHandSideExpression_ are:

-   It is a Syntax Error if _LeftHandSideExpression_ is the _Identifier_
    EVAL or the _Identifier_ ARGUMENTS.

-   It is a Syntax Error if _LeftHandSideExpression_ is the _Identifier_
    THIS or the _Identifier_ SUPER.

-   It is a Syntax Error if the _LeftHandSideExpression_ is a _Literal_,
    a _FunctionExpression_ or a _ClassExpression_.

-   It is a Syntax Error if the _LeftHandSideExpression_ is an
    _Identifier_ that does not statically resolve to a declarative
    environment record binding or if the resolved binding an immutable
    binding.

-   It is a Syntax Error if the _LeftHandSideExpression_ is an
    _ObjectLiteral_ or an _ArrayLiteral_ and the source code
    corresponding to _LeftHandSideExpression_ using cannot be parsed
    using _AssignmentPattern_ as the goal symbol.

-   It is a Syntax Error if the _LeftHandSideExpression_ is
    _PrimaryExpression_ : ( _Expression_ ) and _Expression_ derived a
    production that would produce a Syntax Error according to these
    rules. This rule is recursively applied.

The supplemental production _AssignmentProperty_ : _PropertyName_ :
_LeftHandSideExpression_ is evaluated with the parameter _obj_ as
follows:

1.  Let _name_ be the result of evaluating _PropertyName_.

2.  Let _v_ be the result of calling the [[Get]] internal method of
    _obj_ passing _name_ as the argument.

3.  If _LeftHandSideExpression_ is an _ObjectLiteral_ or an
    _ArrayLiteral_ then

    a.  Let _AssignmentPattern_ be the parse of the source code
        corresponding to _LeftHandSideExpression_ using
        _AssignmentPattern_ as the goal symbol

    b.  Let _vObj_ be ToObject(_v_).

    c.  Evaluate _AssignmentPattern_ using _vObj_ as the _obj_
        parameter.

    d.  Return.

4.  Let _lref_ be the result of evaluating _LeftHandSideExpression_.

5.  Call PutValue(_lref_,_v_).

The supplemental production _ArrayAssignmentPattern_ : [ _Elision_~opt~
_AssignmentRestElement_ ] is evaluated with the parameter _obj_ as
follows:

1.  If _Elision_ is present, then let _skip_ be the result of evaluating
    _Elision_, otherwise let _skip_ be 0.

2.  Evaluate _AssignmentRestElement_ using _obj_ as the _obj_ parameter
    and _skip_ as the _index_ parameter.

The supplemental production
 _ArrayAssignmentPattern_ : [ _AssignmentElementList_ , _Elision_~opt~
_AssignmentRestElement_~opt~ ]
is evaluated with the parameter _obj_ as follows:

1.  Let _lastIndex_ be the result of evaluating _AssignmentElementList
    using _obj_ as the _obj_ parameter and 0 as the _index_ parameter.

2.  If _Elision_ is present, then let _skip_ be the result of evaluating
    _Elision_, otherwise let _skip_ be 0.

3.  If _AssignmentRestElement_ is present, then evaluate
    _AssignmentRestElement_ using _obj_ as the _obj_ parameter and
    _lastIndex_+_skip_ as the _index_ parameter.

The supplemental production _AssignmentElementList_ : _Elision_~opt~
_AssignmentElement_ is evaluated with the parameters _obj_ and _index
as follows:

1.  If _Elision_ is present, then let _skip_ be the result of evaluating
    _Elision_, otherwise let _skip_ be 0.

2.  Evaluate _AssignmentElement_ using _obj_ as the _obj_ parameter and
    _index_+_skip_ as the _index_ parameter.

3.  Return _index_+_skip_+1.

The supplemental production _AssignmentElementList_ :
_AssignmentElementList_ , _Elision_~opt~ _AssignmentElement_ is
evaluated with the parameters _obj_ and _index_ as follows:

1.  Let _listNext_ be the result of evaluating _AssignmentElementList
    using _obj_ as the _obj_ parameter and _index_ as the _index_
    parameter

2.  If _Elision_ is present, then let _skip_ be the result of evaluating
    _Elision_, otherwise let _skip_ be 0.

3.  Evaluate _AssignmentElement_ using _obj_ as the _obj_ parameter and
    _listNext_+_skip_ as the _index_ parameter.

4.  Return _listNext_+_skip+_1.

The supplemental production _AssignmentElement_ :
_LeftHandSideExpression_ is evaluated with the parameters _obj_ and
_index_ as follows:

1.  Let _name_ be ToString(_index_).

2.  Let _v_ be the result of calling the [[Get]] internal method of
    _obj_ passing _name_ as the argument.

3.  If _LeftHandSideExpression_ is an _ObjectLiteral_ or an
    _ArrayLiteral_ then

    a.  Let _AssignmentPattern_ be the parse of the source code
        corresponding to _LeftHandSideExpression_ using
        _AssignmentPattern_ as the goal symbol

    b.  Let _vObj_ be ToObject(_v_).

    c.  Evaluate _AssignmentPattern_ using _vObj_ as the _obj_
        parameter.

    d.  Return.

4.  Let _lref_ be the result of evaluating _LeftHandSideExpression_.

5.  Call PutValue(_lref_,_v_).

The static semantics of the supplemental production
_AssignmentRestElement_ : … _LeftHandSideExpression_ are:

-   It is a Syntax Error if _LeftHandSideExpression_ is the _Identifier_
    EVAL or the _Identifier_ ARGUMENTS.

-   It is a Syntax Error if _LeftHandSideExpression_ is the _Identifier_
    THIS or the _Identifier_ SUPER.

-   It is a Syntax Error if the _LeftHandSideExpression_ is a _Literal_,
    an _ObjectLiteral_, an _ArrayLiteral_, a _FunctionExpression_, or a
    _ClassExpression_.

-   It is a Syntax Error if the _LeftHandSideExpression_ is an
    _Identifier_ that does not statically resolve to a declarative
    environment record binding or if the resolved binding an immutable
    binding.

-   It is a Syntax Error if the _LeftHandSideExpression_ is
    _PrimaryExpression_ : ( _Expression_ ) and _Expression_ derived a
    production that would produce a Syntax Error according to these
    rules. This rule is recursively applied.

The supplemental production _AssignmentRestElement_ : …
_LeftHandSideExpression_ is evaluated with the parameters _obj_ and
_index_ as follows:

1.  Let _lref_ be the result of evaluating _LeftHandSideExpression_.

2.  Let _lenVal_ be the result of calling the [[Get]] internal method of
    _obj_ with argument “LENGTH”.

3.  Let _len_ be ToUint32(_lenVal_).

4.  Let _A_ be a new array object created as if by the expression NEW
    ARRAY() where ARRAY is the standard built-in constructor with that
    name.

5.  Let _n_=0;

6.  Repeat, while _index_ < _len

    a.  Let _P_ be ToString(_index_).

    b.  Let _exists_ be the result of calling the [[HasProperty]]
        internal method of _obj_ with argument _P_.

    c.  If _exists_ is TRUE, then

        i.  Let _v_ be the result of calling the [[Get]] internal method
              of _obj_ passing ToString(_index_) as the argument.

        ii. Call the [[DefineOwnProperty]] internal method of _A_ with
              arguments ToString(_n_), Property Descriptor {[[Value]]:
              _v_, [[Writable]]: TRUE, [[Enumerable]]: TRUE,
              [[Configurable]]: TRUE}, and FALSE.

    d.  Let _n_ = _n_+1.

    e.  Let _index_ = _index_+1.

7.  Call PutValue(_lref_,_A_).

The production _AssignmentExpression_ : _LeftHandSideExpression
AssignmentOperator AssignmentExpression_, where _AssignmentOperator_ is
@= and @ represents one of the operators indicated above, is evaluated
as follows:

-   Type(_lref_) is Reference is TRUE

-   IsStrictReference(_lref_) is TRUE

-   Type(GetBase(_lref_)) is Environment Record

-   GetReferencedName(lref) is either "EVAL" or "ARGUMENTS"

NOTE See NOTE 11.13.1.

Syntax

_Expression_ :

_AssignmentExpression
Expression , AssignmentExpression

ExpressionNoIn :

AssignmentExpressionNoIn
ExpressionNoIn , AssignmentExpressionNoIn

Semantics

The production _Expression_ : _Expression_ , _AssignmentExpression_ is
evaluated as follows:

The _ExpressionNoIn_ production is evaluated in the same manner as the
_Expression_ production except that the contained _ExpressionNoIn_ and
_AssignmentExpressionNoIn_ are evaluated instead of the contained
_Expression_ and _AssignmentExpression_, respectively.

NOTE GetValue must be called even though its value is not used because
it may have observable side-effects.

Syntax

Statement :

BlockStatement
VariableStatement
EmptyStatement
ExpressionStatement
IfStatement
IterationStatement
ContinueStatement
BreakStatement
ReturnStatement
WithStatement
LabelledStatement
SwitchStatement
ThrowStatement
TryStatement
DebuggerStatement

Declaration :

FunctionDeclaration
LetDeclaration
ConstDeclaration

Semantics

A _Statement_ can be part of a _LabelledStatement_, which itself can be
part of a _LabelledStatement_, and so on. The labels introduced this way
are collectively referred to as the “current label set” when describing
the semantics of individual statements. A _LabelledStatement_ has no
semantic meaning other than the introduction of a label to a _label
set_. The label set of an _IterationStatement_ or a _SwitchStatement_
initially contains the single element EMPTY. The label set of any other
statement is initially empty.

The VarDeclaredNames of the productions:
 _Statement_ : _EmptyStatement
_ _Statement_ : _ExpressionStatement
_ _Statement_ : _ContinueStatement
_ _Statement_ : _BreakStatement
_ _Statement_ : _ReturnStatement
_ _Statement_ : _ThrowStatement
 Statement_ : _DebuggerStatement
_is determined as follows:

1.  Return a new empty List.

The VarDeclaredNames of the productions:
 _Statement_ : _BlockStatement
 Statement_ : _IfStatement
 Statement_ : _IterationStatement
 Statement_ : _WithStatement
 Statement_ : _LabelledStatement
 Statement_ : _SwitchStatement
 Statement_ : _TryStatement
_is determined as follows:

1.  Return the VarDeclaredNames of the single non-terminal symbol that
    is the right hand side of the production.

The VarDeclaredNames of the production _Statement_ : _VariableStatement_
is determined as follows:

1.  Return the BoundNames of _VariableStatement_.

The _Statement_ productions are all evaluated as as follows

1.  Return the result of evaluating the single non-terminal symbol that
    is the right hand side of the production.

NOTE The result of evaluating a _Statement_ or _Declaration_ is always a
Completion value.

The BoundNames of the _Declaration_ productions are determined as
follows:

1.  Return the BoundNames of the single non-terminal symbol that is the
    right hand side of the production.

The _Declaration_ productions are all evaluated as as follows

1.  Return the result of evaluating the single non-terminal symbol that
    is the right hand side of the production.

Syntax

BlockStatement :

Block

Block :

{ StatementList~opt~ }

StatementList :

StatementListItem
StatementList StatementListItem

StatementListItem :

Statement
Declaration

Semantics

The VarDeclaredNames of the production _BlockStatement_ : _Block_ is
determined as follows:

1.  Return the VarDeclaredNames of _Block_.

The production _BlockStatement_ : _Block_ is evaluated as follows:

1.  Return the result of evaluating _Block_.

The LexicallyDeclaredNames of the production _Block_ : { } is determined
as follows:

1.  Return a new empty List.

The VarDeclaredNames of the production _Block_ : { } is determined as
follows:

1.  Return a new empty List.

The production _Block_ : { } is evaluated as follows:

1.  Return (NORMAL, EMPTY, EMPTY).

The static semantics of the production _Block_ : { _StatementList_ }
are:

-   It is a Syntax Error if _StatementList_ includes a
    _StatementListItem_ : _Declaration_ production whose _Declaration_
    is a _Declaration_ : _FunctionDeclaration_ production and the source
    code matching this _Block_ production is not contained in extended
    code.

-   It is a Syntax Error if the LexicallyDeclaredNames of
    _StatementList_ contains any duplicate entires.

-   It is a Syntax Error if any element of the LexicallyDeclaredNames of
    _StatementList_ also occurs in the VarDeclaredNames of
    _StatementList_.

The LexicallyDeclaredNames of the production _Block_ : { _StatementList_
}is determined as follows:

1.  Return the LexicallyDeclaredNames of _StatementListItem_.

The VarDeclaredNames of the production _Block_ : { _StatementList_ } is
determined as follows:

1.  Return the VarDeclaredNames of _StatementList_.

The production _Block_ : { _StatementList_ }is evaluated as follows:

NOTE No matter how control leaves the _Block_ the LexicalEnvironment is
always restored to its former state.

The LexicallyDeclaredNames of the production _StatementList_ :
_StatementListItem_ is determined as follows:

1.  Return the LexicallyDeclaredNames of _StatementListItem_.

The LexicalDeclarations of the production _StatementList_ :
_StatementListItem_ is determined as follows:

1.  Return the LexicalDeclarations of _StatementListItem_.

The VarDeclaredNames of the production _StatementList_ :
_StatementListItem_ is determined as follows:

1.  Return the VarDeclaredNames of _StatementListItem_.

The production _StatementList_ : _StatementListItem_ is evaluated as
follows:

The LexicallyDeclaredNames of the production _StatementList_ :
_StatementList StatementListItem_ is determined as follows:

1.  Let _names_ be LexicallyDeclaredNames of _StatementList_.

2.  Append to _names_ the elements of the LexicallyDeclaredNames of
    _StatementListItem._

3.  Return _names_.

The LexicalDeclarations of the production _StatementList_ :
_StatementList StatementListItem_ is determined as follows:

1.  Let _declarations_ be LexicalDeclarations of _StatementList_.

2.  Append to _names_ the elements of the LexicalDeclarations of
    _StatementListItem._

3.  Return _declarations_.

The VarDeclaredNames of the production _StatementList_ : _StatementList
StatementListItem_ is determined as follows:

1.  Let _names_ be VarDeclaredNames of _StatementList_.

2.  Append to _names_ the elements of the VarDeclaredNames of
    _StatementListItem._

3.  Return _names_.

The production _StatementList_ : _StatementList StatementListItem_ is
evaluated as follows:

NOTE Steps 5 and 6 of the above algoritm ensure that the value of a
_StatementList_ is the value of the last value producing _Statement_ in
the _StatementList_. For example, the following calls to the EVAL
function all return the value 1:

  EVAL("1;;;;;")

  EVAL("1;{}")

  EVAL("1;VAR A;")

The LexicallyDeclaredNames and the LexicalDeclarations of the production
_StatementListItem_ : _Statement_ are determined as follows:

1.  Return a new empty List.

The VarDeclaredNames of the production _StatementListItem_ : _Statement_
is determined as follows:

1.  Return the VarDeclaredNames of _Statement_.

The production _StatementListItem_ : _Statement_ is evaluated as
follows:

1.  Return the result of evaluating _Statement_.

The LexicallyDeclaredNames of the production _StatementListItem_ :
_Declaration_ is determined as follows:

1.  Return the BoundNames of _Declaration_.

The LexicalDeclarations of the production _StatementListItem_ :
_Declaration_ is determined as follows:

1.  Return return a new List containing _Declaration_.

The VarDeclaredNames of the production _StatementListItem_ :
_Declaration_ is determined as follows:

1.  Return a new empty List.

The production _StatementListItem_ : _Declaration_ is evaluated as
follows:

1.  Return the result of evaluating _Declaration_.

Syntax

LetDeclaration :

LET LetBindingList ;

LetBindingList :

LetBinding
LetBindingList , LetBinding

LetBindingListNoIn :

LetBindingNoIn
LetBindingListNoIn , LetBindingNoIn

LetBinding :

BindingIdentifier Initialiser~opt
~BindingPattern Initialiser

LetBindingNoIn :

BindingIdentifier InitialiserNoIn~opt
~BindingPattern InitialiserNoIn

BindingIdentifier :

Identifier

Initialiser :

= AssignmentExpression

InitialiserNoIn :

= AssignmentExpressionNoIn

NOTE A LET declaration defines variables that are scoped to the current
execution context’s LexicalEnvironment. Let variables are created when
their containing Lexical Environment is instantiated but may not be
accssed in any way until the variable’s _LetBinding_ is executed. A
variable defined by a _LetBinding_ with an _Initialiser_ is assigned the
value of its _Initialiser_’s _AssignmentExpression_ when the
_LetBinding_ is executed, not when the variable is created. If a
_LetBinding_ does not have an an _Initialiser_ the variable is assigned
the value UNDEFINED when the _LetBinding_ is executed.

Semantics

The static semantics of the production _LetDeclaration_ : LET
_LetBindingList_ ; are:

-   It is a Syntax Error if the code that matches this production is not
    contained in extended code.

The BoundNames of the production _LetDeclaration_ : LET _LetBindingList_
; is determined as follows:

1.  Return BoundNames of _LetBindingList_.

The production _LetDeclaration_ : LET _LetBindingList_ ; is evaluated as
follows:

1.  Evaluate _LetBindingList_.

2.  Return (normal, empty, empty).

The BoundNames of the production _LetBindingList_ : _LetBinding_ is
determined as follows:

1.  Return BoundNames of _LetBinding_.

The production _LetBindingList_ : _LetBinding_ is evaluated as follows:

1.  Evaluate _LetBinding_.

The BoundNames of the production _LetBindingList_ : _LetBindingList_ ,
_LetBinding_ is determined as follows:

1.  Let _names_ be BoundNames of _LetBindingList_.

2.  Append to _names_ the elements of BoundNames of _LetBinding.

3.  Return _names_.

The production _LetBindingList_ : _LetBindingList_ , _LetBinding_ is
evaluated as follows:

1.  Evaluate _LetBindingList_.

2.  Evaluate _LetBinding_.

The BoundNames of the production _LetBinding_ : _BindingIdentifier
Initialiser_~opt~ is determined as follows:

1.  Return the BoundNames of _BindingIdentifier_.

The production _LetBinding_ : _BindingIdentifier_ is evaluated as
follows:

The production _LetBinding_ : _BindingIdentifier Initialiser_ is
evaluated as follows:

1.  Let _rhs_ be the result of evaluating _Initialiser_.

2.  Let _value_ be GetValue(_rhs_).

3.  Let _env_ be the running execution context’s LexicalEnvironment.

4.  Perform Binding Initialization for _BindingIdentifier_ passing
    _value_ and _env_ as the arguments.

The BoundNames of the production _LetBinding_: _BindingPattern
Initialiser_ is determined as follows:

1.  Return the BoundNames of _BindingPattern_.

The production _LetBinding_: _BindingPattern Initialiser_ is evaluated
as follows:

1.  Let _rhs_ be the result of evaluating _Initialiser_.

2.  Let _rval_ be GetValue(_rhs_).

3.  Let _env_ be the running execution context’s LexicalEnvironment.

4.  Evaluate _BindingPattern_ using _rval_ as the _obj_ parameter and
    _env_ as the _environment_ parameter.

The BoundNames of the production _BindingIdentifier_ : _Identifier_ is
determined as follows:

1.  Return a new List containing the _IdentifierName_ corresponding to
    _Identifier_.

The String value of the production _BindingIdentifier_ : _Identifier_ is
determined as follows:

1.  Return a String value consisting of the same sequence of characters
    as the _IdentifierName_ corresponding to _Identifier_.

Binding Initialization of the production _BindingIdentifier_ :
_Identifier_ with arguments _value_ and _enviornment_ is performed as
follows:

1.  If _enviornment_ is not UNDEFINED, then

    a.  Call the InitializeBinding concrete method of _enviornment_
        passing _Identifier_ and _value_ as the arguments.

2.  Else

    a.  Let _lhs_ be the result of evaluating _Identifier_ as described
        in 11.1.2.

    b.  Call PutValue(_lhs_, _value_).

NOTE UNDEFINED is passed for _environment_ to indicate that a PutValue
operation should be used to assign the initialization value. This is the
the case for VAR statements and similar situations where a lexical
binding is hosted and preinitialized prior to evaluation of its
initializer.

The static semantics of the production _BindingIdentifier_ :
_Identifier_ are:

-   It is a Syntax Error if the _BindingIdentifier_ is contained in
    strict code and if the _Identifier_ is EVAL or ARGUMENTS.

The production _BindingIdentifier_ : _Identifier_ is evaluated as
follows:

1.  Return the result of evaluating _Identifier_ as described in 11.1.2.

The production _Initialiser_ : = _AssignmentExpression_ is evaluated as
follows:

The _LetBindingListNoIn_, _LetBindingNoIn_ and _InitialiserNoIn_
productions are evaluated in the same manner as the _LetBindingList_,
_LetBinding_ and _Initialiser_ productions except that the contained
_LetBindingListNoIn_, _LetBindingNoIn_, _InitialiserNoIn_ and
_AssignmentExpressionNoIn_ are evaluated instead of the contained
_LetBindingList_, _LetBinding_, _Initialiser_ and
_AssignmentExpression_, respectively.

Syntax

ConstDeclaration :

CONST ConstBindingList ;

ConstBindingList :

ConstBinding
ConstBinding List , ConstBinding

ConstBinding :

BindingIdentifier Initialiser~
~BindingPattern Initialiser

NOTE A CONST declaration defines read-only variables that are scoped to
the current execution context’s LexicalEnvironment. Constant variables
are created when their containing Lexical Environment is instantiated
but may not be accssed in any way until the variable’s _ConstBinding_ is
executed. A variable defined by a _ConstBinding_ is assigned the value
of its _Initialiser_’s _AssignmentExpression_ when the _ConstBinding_ is
executed, not when the variable is created.

Semantics

The static semantics of the production _ConstDeclaration_ : CONST
_ConstBindingList_ ; are:

-   It is a Syntax Error if the code that matches this production is not
    contained in extended code.

The BoundNames of the production _ConstDeclaration_ : CONST
_ConstBindingList_ ; is determined as follows:

1.  Return BoundNames of _ConstBindingList_.

The production _ConstDeclaration_ : CONST _ConstBindingList_ ; is
evaluated as follows:

1.  Evaluate _ConstBindingList_.

2.  Return (normal, empty, empty).

The BoundNames of the production _ConstBindingList_: _ConstBinding_ is
determined as follows:

1.  Return BoundNames of _ConstBinding_.

The production _ConstBindingList_ : _ConstBinding_ is evaluated as
follows:

1.  Evaluate _ConstBinding_.

The BoundNames of the production _ConstBindingList_ : _ConstBindingList_
, _ConstBinding_ is determined as follows:

1.  Let _names_ be BoundNames of _ConstBindingList_.

2.  Append to _names_ the elements of BoundNames of _ConstBinding.

3.  Return _names_.

The production _ConstBindingList_ : _ConstBindingList_ , _ConstBinding_
is evaluated as follows:

1.  Evaluate _ConstBindingList_.

2.  Evaluate _ConstBinding_.

The BoundNames of the production _ConstBinding_ : _BindingIdentifier
Initialiser_ is determined as follows:

1.  Return the BoundNames of _BindingIdentifier_.

The production _ConstBinding_ : _BindingIdentifier Initialiser_ is
evaluated as follows:

1.  Let _rhs_ be the result of evaluating _Initialiser_.

2.  Let _value_ be GetValue(_rhs_).

3.  Let _env_ be the running execution context’s LexicalEnvironment.

4.  Perform Binding Initialization for _BindingIdentifier_ passing
    _value_ and _env_ as the arguments.

The BoundNames of the production _ConstBinding_: _BindingPattern
Initialiser_ is determined as follows:

1.  Return the BoundNames of _BindingPattern_.

The production _ConstBinding_: _BindingPattern Initialiser_ is evaluated
as follows:

1.  Let _rhs_ be the result of evaluating _Initialiser_.

2.  Let _rval_ be GetValue(_rhs_).

3.  Let _env_ be the running execution context’s LexicalEnvironment.

4.  Evaluate _BindingPattern_ using _rval_ as the _obj_ parameter and
    _env_ as the _environment_ parameter.

Syntax

VariableStatement :

VAR VariableDeclarationList ;

VariableDeclarationList :

VariableDeclaration
VariableDeclarationList , VariableDeclaration

VariableDeclarationListNoIn :

VariableDeclarationNoIn
VariableDeclarationListNoIn , VariableDeclarationNoIn

VariableDeclaration :

BindingIdentifier Initialiser~opt
~BindingPattern Initialiser

VariableDeclarationNoIn :

BindingIdentifier InitialiserNoIn~opt
~BindingPattern InitialiserNoIn

NOTE A VAR statement declares variables that are scoped to the current
execution context’s VariableEnvironment. Var variables are created when
their containing Lexical Environment is instantiated and are initialised
to UNDEFINED when created. Within the scope of any VariableEnvironemnt a
common _Identifier_ may appear in more than one _VariableDeclaration_
but those declarations collective define only one variable. A variable
defined by a _VariableDeclaration_ with an _Initialiser_ is assigned the
value of its _Initialiser_’s _AssignmentExpression_ when the
_VariableDeclaration_ is executed, not when the variable is created.

Semantics

The BoundNames of the production _VariableStatement_ : VAR
_VariableDeclarationList_ ; is determined as follows:

1.  Return BoundNames of _VariableDeclarationList_.

The production _VariableStatement_ : VAR _VariableDeclarationList_ ; is
evaluated as follows:

1.  Evaluate _VariableDeclarationList_.

2.  Return (normal, empty, empty).

The BoundNames of the production _VariableDeclarationList_
:_VariableDeclaration_ is determined as follows:

1.  Return BoundNames of _VariableDeclaration_.

The production _VariableDeclarationList_ :_VariableDeclaration_ is
evaluated as follows:

1.  Evaluate _VariableDeclaration_.

The BoundNames of the production _VariableDeclarationList_ :
_VariableDeclarationList_ , _VariableDeclaration_ is determined as
follows:

1.  Let _names_ be BoundNames of _VariableDeclarationList_.

2.  Append to _names_ the elements of BoundNames of
    _VariableDeclaration._

3.  Return _names_.

The production _VariableDeclarationList_ : _VariableDeclarationList_ ,
_VariableDeclaration_ is evaluated as follows:

1.  Evaluate _VariableDeclarationList_.

2.  Evaluate _VariableDeclaration_.

The BoundNames of the production _VariableDeclaration_ :
_BindingIdentifier Initialiser_~opt~ is determined as follows:

1.  Return the BoundNames of _BindingIdentifier_.

The production _VariableDeclaration_ : _BindingIdentifier_ is evaluated
as follows:

The production _VariableDeclaration_ : _BindingIdentifier Initialiser_
is evaluated as follows:

1.  Let _rhs_ be the result of evaluating _Initialiser_.

2.  Let _value_ be GetValue(_rhs_).

3.  Perform Binding Initialization for _BindingIdentifier_ passing
    _value_ and UNDEFINED as the arguments.

NOTE 1 The String value of a _VariableDeclaration_ is used in the
evaluation of for-in statements (12.6.4).

NOTE 2 If a _VariableDeclaration_ is nested within a with statement and
the _Identifier_ in the _VariableDeclaration_ is the same as a property
name of the binding object of the with statement’s object environment
record, then step 4 will assign value to the property instead of to the
VariableEnvironment binding of the _Identifier_.

The static semantics of the production _VariableDeclaration_ :
_BindingPattern Initialiser_ are:

-   It is a Syntax Error if the source code matching this production is
    not contained in extended code.

The BoundNames of the production _VariableDeclaration_ : _BindingPattern
Initialiser_ is determined as follows:

1.  Return the BoundNames of _BindingPattern_.

The production _VariableDeclaration_ : _BindingPattern Initialiser_ is
evaluated as follows:

1.  Let _rhs_ be the result of evaluating _Initialiser_.

2.  Let _rval_ be ToObject(GetValue(_rhs_)).

3.  Evaluate _BindingPattern_ using _rval_ as the _obj_ parameter and
    UNDEFINED as the _environment_ parameter.

The _VariableDeclarationListNoIn_, _VariableDeclarationNoIn_ and
_InitialiserNoIn_ productions are evaluated in the same manner as the
_VariableDeclarationList_, _VariableDeclaration_ and _Initialiser
productions except that the contained _VariableDeclarationListNoIn_,
_VariableDeclarationNoIn_, _InitialiserNoIn_ and
_AssignmentExpressionNoIn_ are evaluated instead of the contained
_VariableDeclarationList_, _VariableDeclaration_, _Initialiser_ and
_AssignmentExpression_, respectively.

Syntax

BindingPattern :

ObjectBindingPattern
ArrayBindingPattern

ObjectBindingPattern :

{ }
{ BindingPropertyList }
{ BindingPropertyList , }

ArrayBindingPattern :

[ Elision~opt~ BindingRestElement~opt~ ]
[BindingElementList , Elision~opt~ BindingRestElement~opt~ ]

BindingPropertyList :

BindingProperty
BindingPropertyList , BindingProperty

BindingElementList :

Elision~opt~ BindingElement
BindingElementList , Elision~opt~ BindingElement

BindingProperty :

SingleNameBinding ~
~PropertyName : SingleNameBinding
PropertyName : BindingPattern Initialiser~opt~

BindingElement :

SingleNameBinding
BindingPattern Initialiser~opt~

SingleNameBinding :

BindingIdentifier Initialiser~opt~

BindingRestElement :

… BindingIdentifier

Semantics

The BoundNames of the production _BindingPattern_ :
_ObjectBindingPattern_ is determined as follows:

1.  Return BoundNames of _ObjectBindingPattern_.

The production _BindingPattern_ : _ObjectBindingPattern_ is evaluated
with parameters _value_ and _env_ as follows:

1.  Evaluate _ObjectBindingPattern_ using _value_ as the _obj_ parameter
    and _env_ as the _environment_ parameter.

The BoundNames of the production _BindingPattern_ :
_ArrayBindingPattern_ is determined as follows:

1.  Return BoundNames of _ArrayBindingPattern_.

The production _BindingPattern_ : _ArrayBindingPattern_ is evaluated
with parameters _value_ and _env_ as follows:

1.  Evaluate _ArrayBindingPattern_ using _value_ as the _obj_ parameter
    and _env_ as the _environment_ parameter.

The BoundNames of the production _ObjectBindingPattern_: { } is
determined as follows:

1.  Return an empty List.

The production _ObjectBindingPattern_: { } is evaluated with parameters
_value_ and _env_ as follows:

1.  If _value_ is neither of NULL or UNDEFINED, then perform
    ToObject(_value_) and discard the result.

The BoundNames of the productions _ObjectBindingPattern_: {
_BindingPropertyList_ } and _ObjectBindingPattern_ : {
_BindingPropertyList_ , } is determined as follows:

1.  Return the BoundNames of _BindingPropertyList_.

The productions _ObjectBindingPattern_: { _BindingPropertyList_ } and
_ObjectBindingPattern_ : { _BindingPropertyList_ , } are evaluated with
parameters _value_ and _env_ as follows:

1.  If _value_ is neither of NULL or UNDEFINED, then

    a.  Let _obj_ be ToObject(_value_).

2.  Else, let _obj_ be UNDEFINED.

3.  Evaluate _BindingPropertyList_ using _obj_ as the _obj_ parameter
    and _env_ as the _environment_ parameter..

The BoundNames of the production _ArrayBindingPattern_ : [
_Elision_~opt~ ] is determined as follows:

1.  Return an empty List.

The production _ArrayBindingPattern_ : [ _Elision_~opt~ ] is evaluated
with parameters _value_ and _env_ as follows:

1.  If _value_ is neither of NULL or UNDEFINED, then perform
    ToObject(_value_) and discard the result.

The BoundNames of the production _ArrayBindingPattern_ : [
_Elision_~opt~ _BindingRestElement_ ] is determined as follows:

1.  Return the BoundNames of _BindingElementList_.

The production _ArrayBindingPattern_: [ _Elision_~opt~
_BindingRestElement_ ] is evaluated with parameters _value_ and _env_ as
follows:

1.  If _Elision_ is present, then let _skip_ be the result of evaluating
    _Elision_, otherwise let _skip_ be 0.

2.  If _value_ is neither of NULL or UNDEFINED, then

    a.  Let _obj_ be ToObject(_value_).

3.  Else, let _obj_ be UNDEFINED.

4.  Evaluate _BindingRestElement_ using _obj_ as the _obj_ parameter,
    _env_ as the _environment_, and _skip_ as the _index_ parameter.

The BoundNames of the production _ArrayBindingPattern_ :
[_BindingElementList_ , _Elision_~opt~ ] is determined as follows:

1.  Return the BoundNames of _BindingElementList_.

The production _ArrayBindingPattern_: [ _BindingElementList_ ,
_Elision_~opt~] is evaluated with parameters _value_ and _env_ as
follows:

1.  If _value_ is neither of NULL or UNDEFINED, then

    a.  Let _obj_ be ToObject(_value_).

2.  Else, let _obj_ be UNDEFINED.

3.  Let _index_ be the result of evaluating _BindingElementList_ using
    _obj_ as the _obj_ parameter, _env_ as the _environment_, and 0 as
    the _index_ parameter.

4.  If _Elision_ is present, then let _skip_ be the result of evaluating
    _Elision_, otherwise let _skip_ be 0.

The BoundNames of the production _ArrayBindingPattern_ : [
_BindingElementList_ , _Elision_~opt~ _BindingRestElement_ ] is
determined as follows:

1.  Let _names_ be BoundNames of _BindingElementList_.

2.  Append to _names_ the elements of BoundNames of
    _BindingRestElement._

3.  Return _names_.

The production _ArrayBindingPattern_: [ _BindingElementList_ ,
_Elision_~opt~ _BindingRestElement_ ] is evaluated with parameters
_value_ and _env_ as follows:

1.  If _value_ is neither of NULL or UNDEFINED, then

    a.  Let _obj_ be ToObject(_value_).

2.  Else, let _obj_ be UNDEFINED.

3.  Let _index_ be the result of evaluating _BindingElementList_ using
    _obj_ as the _obj_ parameter, _env_ as the _environment_, and 0 as
    the _index_ parameter.

4.  If _Elision_ is present, then let _skip_ be the result of evaluating
    _Elision_, otherwise let _skip_ be 0.

5.  Evaluate _BindingRestElement_ using _obj_ as the _obj_ parameter,
    _env_ as the _environment_, and _index_+_skip_ as the _index_
    parameter.

The BoundNames of the production _BindingPropertyList_ :
_BindingProperty_ is determined as follows:

1.  Return BoundNames of _BindingProperty_.

The production _BindingPropertyList_ : _BindingProperty_ is evaluated
with parameters _obj_ and _env_ as follows:

1.  Evaluate _BindingProperty_ using _obj_ as the _obj_ parameter and
    _env_ as the _environment_ parameter.

The BoundNames of the production _BindingPropertyList_ :
_BindingPropertyList_ , _BindingProperty_ is determined as follows:

1.  Let _names_ be BoundNames of _BindingPropertyList_.

2.  Append to _names_ the elements of BoundNames of _BindingProperty.

3.  Return _names_.

The production _BindingPropertyList_ : _BindingPropertyList_ ,
_BindingProperty_ is evaluated with parameters _obj_ and _env_ as
follows:

1.  Evaluate _BindingPropertyList_ using _obj_ as the _obj_ parameter
    and _env_ as the _environment_ parameter.

2.  Evaluate _BindingProperty_ using _obj_ as the _obj_ parameter and
    _env_ as the _environment_ parameter.

The BoundNames of the production _BindingElementList_ : _Elision_~opt~
_BindingElement_ is determined as follows:

1.  Return BoundNames of _BindingElement_.

The production _BindingElementList_ : _Elision_~opt~ _BindingElement_ is
evaluated with the parameters _obj_, _env_, and _index_ as follows:

1.  If _Elision_ is present, then let _skip_ be the result of evaluating
    _Elision_, otherwise let _skip_ be 0.

2.  Evaluate _BindingElement_ using _obj_ as the _obj_ parameter, _env
    as the _env_ parameter, and _index_+_skip_ as the _index_ parameter.

3.  Return _index_+_skip_+1.

The BoundNames of the production _BindingElementList_ :
_BindingElementList_ , _Elision_~opt~ _BindingElement_ is determined as
follows:

1.  Let _names_ be BoundNames of _BindingElementList_.

2.  Append to _names_ the elements of BoundNames of _BindingElement.

3.  Return _names_.

The production _BindingElementList_ : _BindingElementList_ ,
_Elision_~opt~ _BindingElement_ is evaluated with the parameters _obj_,
_env_, and _index_ as follows:

1.  Let _listNext_ be the result of evaluating _BindingElementList
    using _obj_ as the _obj_ parameter, _env_ as the _env_ parameter,
    and _index_ as the _index_ parameter

2.  If _Elision_ is present, then let _skip_ be the result of evaluating
    _Elision_, otherwise let _skip_ be 0.

3.  Evaluate _BindingElement_ using _obj_ as the _obj_ parameter, _env
    as the _env_ parameter, and _listNext_+_skip_ as the _index_
    parameter.

4.  Return _listNext_+_skip+_1.

The BoundNames of the productions _BindingProperty_ :
_SingleNameBinding_ and _BindingProperty_ : _PropertyName_ :
_SingleNameBinding_ is determined as follows:

1.  Return the BoundNames of _SingleNameBinding_ .

The production _BindingProperty_ : _SingleNameBinding_ is evaluated with
the parameters _obj_ and _env_ as follows:

1.  Let _name_ be the _IdentifierName_ that is the only element of
    BoundNames of _SingleNameBinding_.

2.  Let _P_ be the PropName of _name_.

3.  Evaluate _SingleNameBinding_ using _P_, _obj_, and _env_ as the
    arguments.

The production _BindingProperty_ : _PropertyName_ : _SingleNameBinding_
is evaluated with the parameters _obj_ and _env_ as follows:

1.  Let _P_ be the PropName of _PropertyName

2.  Evaluate _SingleNameBinding_ using _P_, _obj_, and _env_ as the
    arguments.

The BoundNames of the production _BindingProperty_ : _PropertyName_ :
_BindingPattern_ _Initialiser_~opt~ is determined as follows:

1.  Return the BoundNames of _BindingPattern_.

The production _BindingProperty_ : _PropertyName_ : _BindingPattern
Initialiser_~opt~ is evaluated with the parameters _obj_ and _env_ as
follows:

1.  Let _P_ be the PropName of _PropertyName_.

2.  Let _exists_ be the result of calling the [[HasProperty]] internal
    method of _obj_ with argument _P_.

3.  If _exists_ is TRUE, then

    a.  Let _v_ be the result of calling the [[Get]] internal method of
        _obj_ passing _P_ as the argument.

4.  Else

    a.  If _Initialiser_~opt~ is present, then

        i.  Let _v_ be the result of evaluating _Initialiser_.

    b.  Else,

        i.  Let _v_ be UNDEFINED.

5.  Evaluate _BindingPattern_ passing _v_ and _env_ as arguments.

The BoundNames of the production _SingleNameBinding_ :
_BindingIdentifier_ _Initialiser_~opt~ is determined as follows:

1.  Return the BoundNames of _BindingIdentifier_.

The production _SingleNameBinding_ : _BindingIdentifier
Initialiser_~opt~ is evaluated with the parameters _propertyName, obj_,
and _env_ as follows:

1.  Let _exists_ be the result of calling the [[HasProperty]] internal
    method of _obj_ with argument _P_.

2.  If _exists_ is TRUE, then

    a.  Let _v_ be the result of calling the [[Get]] internal method of
        _obj_ passing _P_ as the argument.

3.  Else

    a.  If _Initialiser_~opt~ is present, then

        i.  Let _v_ be the result of evaluating _Initialiser_.

    b.  Else,

        i.  Let _v_ be UNDEFINED.

4.  Perform Binding Initialization for _BindingIdentifer_ using _A_ as
    the _value_ and _env_ as the _enviornment_.

The BoundNames of the production _BindingElement_ : _SingleNameBinding_
is determined as follows:

1.  Return the BoundNames of _SingleNameBinding_ .

The production _BindingElement_: _SingleNameBinding_ is evaluated with
the parameters _obj_, _env_ and _index_ as follows:

1.  Let _P_ be ToString(_index_).

2.  Evaluate _SingleNameBinding_ using _P_, _obj_, and _env_ as the
    arguments.

The BoundNames of the production _BindingElement_ : _BindingPattern
Initialiser_~opt~ is determined as follows:

1.  Return the BoundNames of _BindingPattern_.

The production _BindingElement_: _BindingPattern Initialiser_~opt~ is
evaluated with the parameters _obj_, _env_ and _index_ as follows:

1.  Let _P_ be ToString(_index_).

2.  Let _exists_ be the result of calling the [[HasProperty]] internal
    method of _obj_ with argument _P_.

3.  If _exists_ is TRUE, then

    a.  Let _v_ be the result of calling the [[Get]] internal method of
        _obj_ passing _P_ as the argument.

4.  Else

    a.  If _Initialiser_~opt~ is present, then

        i.  Let _v_ be the result of evaluating _Initialiser_.

    b.  Else,

        i.  Let _v_ be UNDEFINED.

5.  Evaluate _BindingPattern_ passing _v_ and _env_ as arguments.

The BoundNames of the production _BindingRestElement_ : ...
_BindingIdentifier_ is determined as follows:

1.  Return the BoundNames of _BindingIdentifier_.

1.  

The production _BindingRestElement_ : … _BindingIdentifier_ is evaluated
with the parameters _obj_, _env_, and _index_ as follows:

1.  Let _lenVal_ be the result of calling the [[Get]] internal method of
    _obj_ with argument “LENGTH”.

2.  Let _len_ be ToUint32(_lenVal_).

3.  Let _A_ be a new array object created as if by the expression NEW
    ARRAY() where ARRAY is the standard built-in constructor with that
    name.

4.  Let _n_=0;

5.  Repeat, while _index_ < _len

    a.  Let _P_ be ToString(_index_).

    b.  Let _exists_ be the result of calling the [[HasProperty]]
          internal method of _obj_ with argument _P_.

    c.  If _exists_ is TRUE, then

        i.  Let _v_ be the result of calling the [[Get]] internal method
              of _obj_ passing _P_ as the argument.

        ii. Call the [[DefineOwnProperty]] internal method of _A_ with
              arguments ToString(_n_), Property Descriptor {[[Value]]:
              _v_, [[Writable]]: TRUE, [[Enumerable]]: TRUE,
              [[Configurable]]: TRUE}, and FALSE.

    d.  Let _n_ = _n_+1.

    e.  Let _index_ = _index_+1.

6.  Perform Binding Initialization for _BindingIdentifer_ using _A_ as
    the _value_ and _env_ as the _enviornment_.

Syntax

EmptyStatement :

;

Semantics

The production _EmptyStatement_ : ; is evaluated as follows:

Syntax

ExpressionStatement :

[lookahead ∉ {{, FUNCTION}] Expression ;

NOTE An _ExpressionStatement_ cannot start with an opening curly brace
because that might make it ambiguous with a _Block_. Also, an
_ExpressionStatement_ cannot start with the FUNCTION keyword because
that might make it ambiguous with a _FunctionDeclaration_.

Semantics

The production _ExpressionStatement_ : [lookahead ∉ {{, FUNCTION}]
_Expression_; is evaluated as follows:

Syntax

IfStatement :

IF ( Expression ) Statement ELSE Statement
IF ( Expression ) Statement

Each ELSE for which the choice of associated IF is ambiguous shall be
associated with the nearest possible IF that would otherwise have no
corresponding ELSE.

Semantics

The VarDeclaredNames of the production _IfStatement_ : IF ( _Expression_
) _Statement_ ELSE _Statement_ is determined as follows:

1.  Let _names_ be VarDeclaredNames of the first _Statement_.

2.  Append to _names_ the elements of the VarDeclaredNames of the second
    _Statement._

3.  Return _names_.

The production _IfStatement_ : IF ( _Expression_ ) _Statement_ ELSE
_Statement_ is evaluated as follows:

The VarDeclaredNames of the production _IfStatement_ : IF ( _Expression_
) _Statement_ is determined as follows:

1.  Return the VarDeclaredNames of _Statement_.

The production _IfStatement_ : IF ( _Expression_ ) _Statement_ is
evaluated as follows:

Syntax

IterationStatement :

DO Statement WHILE ( Expression );
WHILE ( Expression ) Statement
FOR (ExpressionNoIn~opt~; Expression~opt~ ; Expression~opt~ ) Statement
FOR ( VAR VariableDeclarationListNoIn; Expression~opt~ ; Expression~opt~
) Statement
FOR ( LeftHandSideExpression IN Expression ) Statement
FOR ( VAR VariableDeclarationNoIn IN Expression ) Statement

The VarDeclaredNames of the production DO _Statement_ WHILE (
_Expression_ ); is determined as follows:

1.  Return the VarDeclaredNames of _Statement_.

The production DO _Statement_ WHILE ( _Expression_ ); is evaluated as
follows:

The VarDeclaredNames of the production _IterationStatement_ : WHILE (
_Expression_ ) _Statement_ is determined as follows:

1.  Return the VarDeclaredNames of _Statement_.

The production _IterationStatement_ : WHILE ( _Expression_ ) _Statement_
is evaluated as follows:

The VarDeclaredNames of the production FOR (_ExpressionNoIn_~opt~ ;
_Expression_~opt~ ; _Expression_~opt~) _Statement_ is determined as
follows:

1.  Return the VarDeclaredNames of _Statement_.

The production
 _IterationStatement_ : FOR (_ExpressionNoIn_~opt~ ; _Expression_~opt~ ;
_Expression_~opt~) _Statement
is evaluated as follows:

The VarDeclaredNames of the production
 FOR ( VAR _VariableDeclarationListNoIn_ ; _Expression_~opt~ ;
_Expression_~opt~ ) _Statement
is determined as follows:

1.  Let _names_ be BoundNames of _VariableDeclarationListNoIn_.

2.  Append to _names_ the elements of the VarDeclaredNames of
    _Statement._

3.  Return _names_.

The production
 _IterationStatement_ : FOR ( VAR _VariableDeclarationListNoIn_ ;
_Expression_~opt~ ; _Expression_~opt~ ) _Statement
is evaluated as follows:

The VarDeclaredNames of the production FOR ( _LeftHandSideExpression_ IN
_Expression_ ) _Statement_ is determined as follows:

1.  Return the VarDeclaredNames of _Statement_.

The production _IterationStatement_ : FOR ( _LeftHandSideExpression_ IN
_Expression_ ) _Statement_ is evaluated as follows:

The VarDeclaredNames of the production
 FOR ( VAR _VariableDeclarationNoIn_ IN _Expression_ ) _Statement_
is determined as follows:

1.  Let _names_ be BoundNames of _VariableDeclarationNoIn_.

2.  Append to _names_ the elements of the VarDeclaredNames of
    _Statement._

3.  Return _names_.

The production
 _IterationStatement_ : FOR ( VAR _VariableDeclarationNoIn_ IN
_Expression_ ) _Statement
is evaluated as follows:

The mechanics and order of enumerating the properties (step 6.a in the
first algorithm, step 7.a in the second) is not specified. Properties of
the object being enumerated may be deleted during enumeration. If a
property that has not yet been visited during enumeration is deleted,
then it will not be visited. If new properties are added to the object
being enumerated during enumeration, the newly added properties are not
guaranteed to be visited in the active enumeration. A property name must
not be visited more than once in any enumeration.

Enumerating the properties of an object includes enumerating properties
of its prototype, and the prototype of the prototype, and so on,
recursively; but a property of a prototype is not enumerated if it is
“shadowed” because some previous object in the prototype chain has a
property with the same name. The values of [[Enumerable]] attributes are
not considered when determining if a property of a prototype object is
shadowed by a previous object on the prototype chain.

NOTE See NOTE 11.13.1.

Syntax

ContinueStatement :

CONTINUE ;
CONTINUE [no LineTerminator here] Identifier;

Semantics

A program is considered syntactically incorrect if either of the
following is true:

-   The program contains a CONTINUE statement without the optional
      _Identifier_, which is not nested, directly or indirectly (but not
      crossing function boundaries), within an _IterationStatement_.

-   The program contains a CONTINUE statement with the optional
      _Identifier_, where _Identifier_ does not appear in the label set
      of an enclosing (but not crossing function boundaries)
      _IterationStatement_.

A _ContinueStatement_ without an _Identifier_ is evaluated as follows:

A _ContinueStatement_ with the optional _Identifier_ is evaluated as
follows:

Syntax

BreakStatement :

BREAK ;
BREAK [no LineTerminator here] Identifier ;

Semantics

A program is considered syntactically incorrect if either of the
following is true:

-   The program contains a BREAK statement without the optional
      _Identifier_, which is not nested, directly or indirectly (but not
      crossing function boundaries), within an _IterationStatement_ or a
      _SwitchStatement_.

-   The program contains a BREAK statement with the optional
      _Identifier_, where _Identifier_ does not appear in the label set
      of an enclosing (but not crossing function boundaries)
      _Statement_.

A _BreakStatement_ without an _Identifier_ is evaluated as follows:

A _BreakStatement_ with an _Identifier_ is evaluated as follows:

Syntax

ReturnStatement :

RETURN ;
RETURN [no LineTerminator here] Expression ;

Semantics

An ECMAScript program is considered syntactically incorrect if it
contains a RETURN statement that is not within a _FunctionBody_. A
RETURN statement causes a function to cease execution and return a value
to the caller. If _Expression_ is omitted, the return value is
UNDEFINED. Otherwise, the return value is the value of _Expression_.

A _ReturnStatement_ is evaluated as follows:

Syntax

WithStatement :

WITH ( Expression ) Statement

NOTE The WITH statement adds an object environment record for a computed
object to the lexical environment of the current execution context. It
then executes a statement using this augmented lexical environment.
Finally, it restores the original lexical environment.

Semantics

The static semantics of the production _WithStatement_ : WITH (
_Expression_ ) _Statement_ are:

-   It is a Syntax Error if the code that matches this production is
    contained in static code.

The VarDeclaredNames of the production _WithStatement_ : WITH (
_Expression_ ) _Statement_ is determined as follows:

1.  Return the VarDeclaredNames of _Statement_.

The production _WithStatement_ : WITH ( _Expression_ ) _Statement_ is
evaluated as follows:

NOTE No matter how control leaves the embedded _Statement_, whether
normally or by some form of abrupt completion or exception, the
LexicalEnvironment is always restored to its former state.

Syntax

SwitchStatement :

SWITCH ( Expression ) CaseBlock

CaseBlock :

{ CaseClauses~opt~ }
{ CaseClauses~opt~ DefaultClause CaseClauses~opt~ }

CaseClauses :

CaseClause
CaseClauses CaseClause

CaseClause :

CASE Expression : StatementList~opt~

DefaultClause :

DEFAULT : StatementList~opt~

Semantics

The VarDeclaredNames of the production _SwitchStatement_ : SWITCH (
_Expression_ ) _CaseBlock_ is determined as follows:

1.  Return the VarDeclaredNames of _CaseBlock_.

The production _SwitchStatement_ : SWITCH ( _Expression_ ) _CaseBlock_
is evaluated as follows:

NOTE No matter how control leaves the _SwitchStatement_ the
LexicalEnvironment is always restored to its former state.

The static semantics of the production _CaseBlock_ : { _CaseClauses_ }
are:

-   It is a Syntax Error if the LexicallyDeclaredNames of _CaseClauses_
    contains any duplicate entires.

-   It is a Syntax Error if any element of the LexicallyDeclaredNames of
    _CaseClauses_ also occurs in the VarDeclaredNames of _CaseClauses_.

The LexicallyDeclaredNames ,the LexicalDeclarations, and the
VarDeclaredNames of the production _CaseBlock_ : { } is determined as
follows:

1.  Return a new empty List.

The LexicallyDeclaredNames of the production _CaseBlock_ : {
_CaseClauses_ } is determined as follows:

1.  Return the LexicallyDeclaredNames of _CaseClauses_.

The LexicalDeclarations of the production _CaseBlock_ : { _CaseClauses_
} is determined as follows:

1.  Return the LexicalDeclarations of _CaseClauses_.

The VarDeclaredNames of the production _CaseBlock_ : { _CaseClauses_ }
is determined as follows:

1.  Return the VarDeclaredNames of _CaseClauses_.

The production _CaseBlock_ : { _CaseClauses_~opt~ } is given an input
parameter, _input_, and is evaluated as follows:

The LexicallyDeclaredNames of the production _CaseBlock_ : {
_CaseClauses_~opt~ _DefaultClause CaseClauses_~opt~ } is determined as
follows:

1.  If the first _CaseClauses_ is present, let _names_ be the
    LexicallyDeclaredNames of the first _CaseClauses_.

2.  Else let _names_ be a new empty List.

3.  Append to _names_ the elements of the LexicallyDeclaredNames of the
    _DefaultClause._

4.  If the second _CaseClauses_ is not present, return _names_.

5.  Else return the result of append to _names_ the elements of the the
    LexicallyDeclaredNames of the second _CaseClauses_.

The LexicalDeclarations of the production _CaseBlock_ : {
_CaseClauses_~opt~ _DefaultClause CaseClauses_~opt~ } is determined as
follows:

1.  If the first _CaseClauses_ is present, let _declarations_ be the
    LexicalDeclarations of the first _CaseClauses_.

2.  Else let _declarations_ be a new empty List.

3.  Append to _declarations_ the elements of the LexicallyDeclaredNames
    of the _DefaultClause._

4.  If the second _CaseClauses_ is not present, return _names_.

5.  Else return the result of append to _names_ the elements of the the
    LexicallyDeclaredNames of the second _CaseClauses_.

The VarDeclaredNames of the production _CaseBlock_ : {
_CaseClauses_~opt~ _DefaultClause CaseClauses_~opt~ } is determined as
follows:

1.  If the first _CaseClauses_ is present, let _names_ be the
    VarDeclaredNames of the first _CaseClauses_.

2.  Else let _names_ be a new empty List.

3.  Append to _names_ the elements of the VarDeclaredNames of the
    _DefaultClause._

4.  If the second _CaseClauses_ is not present, return _names_.

5.  Else return the result of append to _names_ the elements of the the
    VarDeclaredNames of the second _CaseClauses_.

The production _CaseBlock_ : { _CaseClauses_~opt~ _DefaultClause
CaseClauses_~opt~ } is given an input parameter, _input_, and is
evaluated as follows:

The LexicallyDeclaredNames of the production _CaseClauses_ :
_CaseClause_ is determined as follows:

1.  Return the LexicallyDeclaredNames of _CaseClause_.

The LexicalDeclarations of the production _CaseClauses_ : _CaseClause_
is determined as follows:

1.  Return the LexicalDeclarations of _CaseClause_.

The VarDeclaredNames of the production _CaseClauses_ : _CaseClause_ is
determined as follows:

1.  Return the VarDeclaredNames of _CaseClause_.

The LexicallyDeclaredNames of the production _CaseClauses_ :
_CaseClauses CaseClause_ is determined as follows:

1.  Let _names_ be LexicallyDeclaredNames of _CaseClauses_.

2.  Append to _names_ the elements of the LexicallyDeclaredNames of
    _CaseClause._

3.  Return _names_.

The LexicalDeclarations of the production _CaseClauses_ : _CaseClauses
CaseClause_ is determined as follows:

1.  Let _declarations_ be LexicalDeclarations of _CaseClauses_.

2.  Append to _names_ the elements of the LexicalDeclarations of
    _CaseClause._

3.  Return _declarations_.

The VarDeclaredNames of the production _CaseClauses_ : _CaseClauses
CaseClause_ is determined as follows:

1.  Let _names_ be VarDeclaredNames of _CaseClauses_.

2.  Append to _names_ the elements of the VarDeclaredNames of
    _CaseClause._

3.  Return _names_.

The static semantics of the production _CaseClause_ : CASE _Expression_
: _StatementList_ are:

-   It is a Syntax Error if _StatementList_ includes a
    _StatementListItem_ : _FunctionDeclaration_ production and the
    source code matching this _CaseClause_ production is not contained
    in extended code.

The LexicallyDeclaredNames of the production _CaseClause_ : CASE
_Expression_ : _StatementList_~opt~ is determined as follows:

1.  If the _StatementList_ is present, return the LexicallyDeclaredNames
    of _StatementList_.

2.  Else return a new empty List.

The LexicalDeclarations of the production _CaseClause_ : CASE
_Expression_ : _StatementList_~opt~ is determined as follows:

1.  If the _StatementList_ is present, return the LexicalDeclarations of
    _StatementList_.

2.  Else return a new empty List.

The VarDeclaredNames of the production _CaseClause_ : CASE _Expression_
: _StatementList_~opt~ is determined as follows:

1.  If the _StatementList_ is present, return the VarDeclaredNames of
    _StatementList_.

2.  Else return a new empty List.

The production _CaseClause_ : CASE _Expression_ : _StatementList_~opt~
is evaluated as follows:

NOTE Evaluating _CaseClause_ does not execute the associated
_StatementList_. It simply evaluates the _Expression_ and returns the
value, which the _CaseBlock_ algorithm uses to determine which
_StatementList_ to start executing.

The LexicallyDeclaredNames of the production _DefaultClause_ : DEFAULT :
_StatementList_~opt~ is determined as follows:

1.  If the _StatementList_ is present, return the LexicallyDeclaredNames
    of _StatementList_.

2.  Else return a new empty List.

The LexicalDeclarations of the production _DefaultClause_ : DEFAULT :
_StatementList_~opt~ is determined as follows:

1.  If the _StatementList_ is present, return the LexicalDeclarations of
    _StatementList_.

2.  Else return a new empty List.

The VarDeclaredNames of the production _DefaultClause_ : DEFAULT :
_StatementList_~opt~ is determined as follows:

1.  If the _StatementList_ is present, return the VarDeclaredNames of
    _StatementList_.

2.  Else return a new empty List.

Syntax

LabelledStatement :

Identifier : Statement

Semantics

NOTE A _Statement_ may be prefixed by a label. Labelled statements are
only used in conjunction with labelled BREAK and CONTINUE statements.
ECMAScript has no GOTO statement.

An ECMAScript program is considered syntactically incorrect if it
contains a _LabelledStatement_ that is enclosed by a _LabelledStatement_
with the same _Identifier_ as label. This does not apply to labels
appearing within the body of a _FunctionDeclaration_ that is nested,
directly or indirectly, within a labelled statement.

The VarDeclaredNames of the production _DefaultCase_ : _Identifier_ :
_Statement_ is determined as follows:

1.  Return the VarDeclaredNames of _Statement_.

The production _Identifier_ : _Statement_ is evaluated by adding
_Identifier_ to the label set of _Statement_ and then evaluating
_Statement_. If the _LabelledStatement_ itself has a non-empty label
set, these labels are also added to the label set of _Statement_ before
evaluating it. If the result of evaluating _Statement_ is (BREAK, _V_,
_L_) where _L_ is equal to _Identifier_, the production results in
(NORMAL, _V_, EMPTY).

Prior to the evaluation of a _LabelledStatement_, the contained
_Statement_ is regarded as possessing an empty label set, unless it is
an _IterationStatement_ or a _SwitchStatement_, in which case it is
regarded as possessing a label set consisting of the single element,
EMPTY.

Syntax

ThrowStatement :

THROW [no LineTerminator here] Expression ;

Semantics

The production _ThrowStatement_ : THROW [no _LineTerminator_ here]
_Expression_ ; is evaluated as follows:

Syntax

TryStatement :

TRY Block Catch~
~TRY Block Finally~
~TRY Block Catch Finally

Catch :

CATCH ( CatchParameter ) Block

Finally :

FINALLY Block

CatchParameter :

BindingIdentifier~
~BindingPattern

The TRY statement encloses a block of code in which an exceptional
condition can occur, such as a runtime error or a THROW statement. The
CATCH clause provides the exception-handling code. When a catch clause
catches an exception, its _Identifier_ is bound to that exception.

Semantics

The VarDeclaredNames of the production _TryStatement_ : TRY _Block_
_Catch_ is determined as follows:

1.  Let _names_ be VarDeclaredNames of _Block_.

2.  Append to _names_ the elements of the VarDeclaredNames of _Catch.

3.  Return _names_.

The production _TryStatement_ : TRY _Block_ _Catch_ is evaluated as
follows:

The VarDeclaredNames of the production _TryStatement_ : TRY _Block_
_Finally_ is determined as follows:

1.  Let _names_ be VarDeclaredNames of _Block_.

2.  Append to _names_ the elements of the VarDeclaredNames of _Finally.

3.  Return _names_.

The production _TryStatement_ : TRY _Block_ _Finally_ is evaluated as
follows:

The VarDeclaredNames of the production _TryStatement_ : TRY _Block_
_Catch_ _Finally_ is determined as follows:

1.  Let _names_ be VarDeclaredNames of _Block_.

2.  Append to _names_ the elements of the VarDeclaredNames of _Catch.

3.  Append to _names_ the elements of the VarDeclaredNames of _Finally.

4.  Return _names_.

The production _TryStatement_ : TRY _Block_ _Catch_ _Finally_ is
evaluated as follows:

The VarDeclaredNames of the production _Catch_ : CATCH (
_CatchParameter_ ) _Block_ is determined as follows:

1.  Return the VarDeclaredNames of _Block_.

The static semantics of the production _Catch_ : CATCH (
_CatchParameter_ ) _Block_ are:

-   It is a Syntax Error if any element of the BoundNames of
    _CatchParameter_ also occurs in the LexicallyDeclaredNames of
    _Block_.

-   It is a Syntax Error if the code that matches this production is
    contained in extended code and any element of the BoundNames of
    _CatchParameter_ also occurs in the VarDeclaredNames of _Block_.

The production _Catch_ : CATCH ( _CatchParameter_ ) _Block_ is evaluated
with parameter _C_ as follows:

NOTE No matter how control leaves the _Block_ the LexicalEnvironment is
always restored to its former state.

The VarDeclaredNames of the production _Finally_ : FINALLY _Block_ is
determined as follows:

1.  Return the VarDeclaredNames of _Block_.

The production _Finally_ : FINALLY _Block_ is evaluated as follows:

The BoundNames of the production _CatchParameter_: _BindingIdentifier_
is determined as follows:

1.  Return the BoundNames of _BindingIdentifier_.

The production _CatchParameter_: _BindingIdentifier_ is evaluated with
parameters _exception_ and _env_ as follows:

1.  Let _name_ be the sole element of the BoundNames of
    _BindingIdentifier_

2.  Call the InitializeBinding concrete method of _env_ passing _name
    and _exception_ as the argument..

The BoundNames of the production _CatchParameter_: _BindingPattern_ is
determined as follows:

1.  Return the BoundNames of _BindingPattern_.

The production _CatchParameter_: _BindingPattern BindingIdentifier_ is
evaluated with parameters _exception_ and _env_ as follows:

1.  Let _rhs_ be the result of evaluating _Initialiser_.

2.  Let _rval_ be ToObject(GetValue(_rhs_)).

3.  Let _env_ be the running execution context’s LexicalEnvironment.

4.  Evaluate _BindingPattern_ using _rval_ as the _obj_ parameter and
    _env_ as the _environment_ parameter.

Syntax

DebuggerStatement :

DEBUGGER ;

Semantics

Evaluating the _DebuggerStatement_ production may allow an
implementation to cause a breakpoint when run under a debugger. If a
debugger is not present or active this statement has no observable
effect.

The production _DebuggerStatement_ : DEBUGGER ; is evaluated as follows:

Syntax

FunctionDeclaration :

FUNCTION BindingIdentifier ( FormalParameterList~opt~ ) { FunctionBody }

FunctionExpression :

FUNCTION BindingIdentifier~opt~ ( FormalParameterList~opt~ ) {
FunctionBody }

FormalParameterList :

... Identifier
FormalsList
FormalsList, ... Identifier

FormalsList :

FormalParameter
FormalsList , FormalParameter

FormalParameter :

BindingIdentifier Initialiser~opt~
BindingPattern Initialiser~opt~

FunctionBody :

SourceElements~opt~

NOTE The identifier of a rest parameter is specified as an _Identifier_
rather than a _BindingIdentifier_ because it may be the the identifier
ARGUMENTS..

Semantics

The production
 _FunctionDeclaration_ : FUNCTION _BindingIdentifier_ (
_FormalParameterList_~opt~ ) { _FunctionBody_ }
is instantiated as follows during Declaration Binding instantiation
(10.5):

The production
 _FunctionExpression_ : FUNCTION ( _FormalParameterList_~opt~ ) {
_FunctionBody_ }
is evaluated as follows:

The BoundNames of the production
 _FunctionExpression_ : FUNCTION _BindingIdentifier_ (
_FormalParameterList_~opt~ ) { _FunctionBody_ }
is determined as follows:

1.  Return the BoundNames of _BindingIdentifier_.

-   

The production
 _FunctionExpression_ : FUNCTION _BindingIdentifier_ (
_FormalParameterList_~opt~ ) { _FunctionBody_ }
is evaluated as follows:

NOTE The _BindingIdentifier_ in a _FunctionExpression_ can be referenced
from inside the _FunctionExpression's_ _FunctionBody_ to allow the
function to call itself recursively. However, unlike in a
_FunctionDeclaration_, the _BindingIdentifier_ in a _FunctionExpression
cannot be referenced from and does not affect the scope enclosing the
_FunctionExpression_.

The production _FunctionBody_ : _SourceElements_~opt~ is evaluated as
follows:

The static semantics of the productions _FormalParameterList_ : …
_Identifier_ and _FormalParameterList_ : _FormalsList_ _,_ …
_Identifier_ are:

-   It is a Syntax Error if the source code parsed with this production
    is not extended code.

-   It is a Syntax Error if _Identifier_ is "EVAL"

The static semantics of the production _FormalParameterList_ :
_FormalsList,_ … _Identifier_ are:

-   It is a Syntax Error if BoundNames of _FormalsList_ contains the
    value of _Identifier_.

The static semantics of the production _FormalsList_ : _FormalsList,_
_FormalParameter_ are:

-   It is a Syntax Error if BoundNames of _FormalsList_ contains an
    element which is also contained in BoundNames of _FormalParameter_.

-   

The static semantics of the production _FormalParameter_ :
_BindingIdentifier Initialiser_ are:

-   It is a Syntax Error if the source code matching this production is
    not extended code.

-   

The static semantics of the production _FormalParameter_ :
_BindingPattern Initialiser_~opt~ are:

-   It is a Syntax Error if the source code parsed with this production
    is not extended code.

-   It is a Syntax Error if BoundNames of _BindingPattern_ contains any
    duplicate elements.

-   It is a Syntax Error if BoundNames of _BindingPattern_ contains
    "EVAL" or "ARGUMENTS".

The ExpectedArgumentCount of the production _FormalParameterList_ : …
_Identifier_ is determined as follows:

1.  Return 0.

The ExpectedArgumentCount of the productions _FormalParameterList_ :
_FormalsList_ and _FormalParameterList_ : _FormalsList ,_ … _Identifier
is determined as follows:

1.  Return the ExpectedArgumentCount of _FormalsList_.

NOTE The ExpectedArgumentCount of a _FormalParameterList_ is the number
of _FormalParameters_ to the left of either the rest parameter or the
first FormalParameter with an _Initialiser_.

The ExpectedArgumentCount of the production _FormalsList_ :
_FormalParameter_ is determined as follows:

1.  If HasInitialiser of _FormalParameter_ is FALSE return 

2.  Return 1.

HasInitialiser of the production _FormalsList_ : _FormalParameter_ is
determined as follows:

1.  Return HasInitialiser of _FormalParameter_.

The ExpectedArgumentCount of the production _FormalsList_ :
_FormalsList,_ _FormalParameter_ is determined as follows:

1.  Let _count_ be the ExpectedArgumentCount of _FormalsList.

2.  If HasInitialiser of _FormalsList_ is TRUE or HasInitialiser of
    _FormalParameter_ is TRUE, then return _count_.

3.  Return _count_+1.

HasInitialiser of the production _FormalsList_ : _FormalsList ,_
_FormalParameter_ is determined as follows:

1.  If HasInitialiser of _FormalsList_ is TRUE, then return TRUE.

2.  Return HasInitialiser of _FormalParameter_.

HasInitialiser of the productions _FormalParameter_ :
_BindingIdentifier_ and _FormalParameter_ : _BindingPattern_ is
determined as follows:

1.  Return FALSE.

HasInitialiser of the production _FormalParameter_ : _BindingIdentifier_
_Initialiser_ and _FormalParameter_ : _BindingPattern Initialiser_ is
determined as follows:

1.  Return TRUE.

The BoundNames of the production _FormalsList_ : _FormalsList ,_
_FormalParameter_ is determined as follows:

1.  Let _names_ be BoundNames of _PropertyName_.

2.  Append to _names_ the elements of BoundNames of _FormalParameter.

3.  Return _names_.

The BoundNames of the production _FormalParameter_ : _BindingIdentifier
Initialiser_~opt~ is determined as follows:

1.  Let _names_ be a List containing the text of the _Identifier_ .

2.  Return _names_.

The BoundNames of the production _FormalParameter_ : _BindingPattern
Initialiser_~opt~ is determined as follows:

1.  Return BoundNames of _BindingPattern_.

Given an optional parameter list specified by _FormalParameterList_, a
body specified by _FunctionBody_, a Lexical Environment specified by
_Scope_, and a Boolean flag _Strict_, a Function object is constructed
as follows:

NOTE A PROTOTYPE property is automatically created for every function,
to allow for the possibility that the function will be used as a
constructor.

When the [[Call]] internal method for a Function object _F_ is called
with a this value and a list of arguments, the following steps are
taken:

When the [[Construct]] internal method for a Function object _F_ is
called with a possibly empty list of arguments, the following steps are
taken:

The [[ThrowTypeError]] object is a unique function object that is
defined once as follows:

Syntax

Program :

SourceElements~opt~

SourceElements :

SourceElement
SourceElements SourceElement

SourceElement :

Statement
FunctionDeclaration

Semantics

The production _Program_ : _SourceElements_~opt~ is evaluated as
follows:

NOTE The processes for initiating the evaluation of a _Program_ and for
dealing with the result of such an evaluation are defined by an
ECMAScript implementation and not by this specification.

The production _SourceElements_ : _SourceElements_ _SourceElement_ is
evaluated as follows:

The production _SourceElement_ : _Statement_ is evaluated as follows:

The production _SourceElement_ : _FunctionDeclaration_ is evaluated as
follows:

A Directive Prologue is the longest sequence of _ExpressionStatement_
productions occurring as the initial _SourceElement_ productions of a
_Program_ or _FunctionBody_ and where each _ExpressionStatement_ in the
sequence consists entirely of a _StringLiteral_ token followed a
semicolon. The semicolon may appear explicitly or may be inserted by
automatic semicolon insertion. A Directive Prologue may be an empty
sequence.

A Use Strict Directive is an _ExpressionStatement_ in a Directive
Prologue whose _StringLiteral_ is either the exact character sequences
"USE STRICT" or 'USE STRICT'. A Use Strict Directive may not contain an
_EscapeSequence_ or _LineContinuation_.

A Directive Prologue may contain more than one Use Strict Directive.
However, an implementation may issue a warning if this occurs.

NOTE The _ExpressionStatement_ productions of a Directive Prologue are
evaluated normally during evaluation of the containing _SourceElements_
production. Implementations may define implementation specific meanings
for _ExpressionStatement_ productions which are not a Use Strict
Directive and which occur in a Directive Prologue. If an appropriate
notification mechanism exists, an implementation should issue a warning
if it encounters in a Directive Prologue an _ExpressionStatement_ that
is not a Use Strict Directive or which does not have a meaning defined
by the implementation.

There are certain built-in objects available whenever an ECMAScript
program begins execution. One, the global object, is part of the lexical
environment of the executing program. Others are accessible as initial
properties of the global object.

Unless specified otherwise, a built-in object has the [[NativeBrand]]
internal property with value NativeFunction if that built-in object has
a [[Call]] internal property. Unless specified otherwise, the
[[Extensible]] internal property of a built-in object initially has the
value TRUE.

Many built-in objects are functions: they can be invoked with arguments.
Some of them furthermore are constructors: they are functions intended
for use with the NEW operator. For each built-in function, this
specification describes the arguments required by that function and
properties of the Function object. For each built-in constructor, this
specification furthermore describes properties of the prototype object
of that constructor and properties of specific object instances returned
by a NEW expression that invokes that constructor.

Unless otherwise specified in the description of a particular function,
if a function or constructor described in this clause is given fewer
arguments than the function is specified to require, the function or
constructor shall behave exactly as if it had been given sufficient
additional arguments, each such argument being the UNDEFINED value.

Unless otherwise specified in the description of a particular function,
if a function or constructor described in this clause is given more
arguments than the function is specified to allow, the extra arguments
are evaluated by the call and then ignored by the function. However, an
implementation may define implementation specific behaviour relating to
such arguments as long as the behaviour is not the throwing of a
TYPEERROR exception that is predicated simply on the presence of an
extra argument.

NOTE Implementations that add additional capabilities to the set of
built-in functions are encouraged to do so by adding new functions
rather than adding new parameters to existing functions.

Every built-in function and every built-in constructor has the Function
prototype object, which is the initial value of the expression
FUNCTION.PROTOTYPE (15.3.4), as the value of its [[Prototype]] internal
property.

Unless otherwise specified every built-in prototype object has the
Object prototype object, which is the initial value of the expression
OBJECT.PROTOTYPE (15.2.4), as the value of its [[Prototype]] internal
property, except the Object prototype object itself.

None of the built-in functions described in this clause that are not
constructors shall implement the [[Construct]] internal method unless
otherwise specified in the description of a particular function. The
behavior specified in this clause for each built-in function is the
specification of the [[Call]] internal method behavior for that
function. None of the built-in functions described in this clause shall
have a PROTOTYPE property unless otherwise specified in the description
of a particular function.

This clause generally describes distinct behaviours for when a
constructor is “called as a function” and for when it is “called as part
of a NEW expression”. The “called as a function” behaviour corresponds
to the invocation of the constructor’s [[Call]] internal method and the
“called as part of a new expression” behaviour corresponds to the
invocation of the constructor’s [[Construct]] internal method.

Every built-in Function object described in this clause—whether as a
constructor, an ordinary function, or both—has a LENGTH property whose
value is an integer. Unless otherwise specified, this value is equal to
the largest number of named arguments shown in the subclause headings
for the function description, including optional parameters.

NOTE For example, the Function object that is the initial value of the
slice property of the String prototype object is described under the
subclause heading “String.prototype.slice (start, end)” which shows the
two named arguments start and end; therefore the value of the length
property of that Function object is 2.

In every case, the LENGTH property of a built-in Function object
described in this clause has the attributes { [[Writable]]: FALSE,
[[Enumerable]]: FALSE, [[Configurable]]: FALSE }. Every other property
described in this clause has the attributes { [[Writable]]: TRUE,
[[Enumerable]]: FALSE, [[Configurable]]: TRUE } unless otherwise
specified.

The unique _global object_ is created before control enters any
execution context.

Unless otherwise specified, the standard built-in properties of the
global object have attributes {[[Writable]]: TRUE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE}.

The global object does not have a [[Construct]] internal property; it is
not possible to use the global object as a constructor with the NEW
operator.

The global object does not have a [[Call]] internal property; it is not
possible to invoke the global object as a function.

The value of the [[Prototype]] internal property of the global object is
implementation-dependent.

In addition to the properties defined in this specification the global
object may have additional host defined properties. This may include a
property whose value is the global object itself; for example, in the
HTML document object model the WINDOW property of the global object is
the global object itself.

The value of NAN is NAN (see 8.5). This property has the attributes {
[[Writable]]: FALSE, [[Enumerable]]: FALSE, [[Configurable]]: FALSE }.

The value of INFINITY is +∞ (see 8.5). This property has the attributes
{ [[Writable]]: FALSE, [[Enumerable]]: FALSE, [[Configurable]]: FALSE }.

The value of UNDEFINED is UNDEFINED (see 8.1). This property has the
attributes { [[Writable]]: FALSE, [[Enumerable]]: FALSE,
[[Configurable]]: FALSE }.

When the EVAL function is called with one argument _x_, the following
steps are taken:

A direct call to the eval function is one that is expressed as a
_CallExpression_ that meets the following two conditions:

The Reference that is the result of evaluating the _MemberExpression_ in
the _CallExpression_ has an environment record as its base value and its
reference name is "EVAL".

The result of calling the abstract operation GetValue with that
Reference as the argument is the standard built-in function defined in
15.1.2.1.

The PARSEINT function produces an integer value dictated by
interpretation of the contents of the _string_ argument according to the
specified _radix_. Leading white space in _string_ is ignored. If
_radix_ is UNDEFINED or 0, it is assumed to be 10 except when the number
begins with the character pairs 0X or 0X, in which case a radix of 16 is
assumed. If _radix_ is 16, the number may also optionally begin with the
character pairs 0X or 0X.

When the PARSEINT function is called, the following steps are taken:

NOTE PARSEINT may interpret only a leading portion of _string_ as an
integer value; it ignores any characters that cannot be interpreted as
part of the notation of an integer, and no indication is given that any
such characters were ignored.

The PARSEFLOAT function produces a Number value dictated by
interpretation of the contents of the _string_ argument as a decimal
literal.

When the PARSEFLOAT function is called, the following steps are taken:

NOTE PARSEFLOAT may interpret only a leading portion of _string_ as a
Number value; it ignores any characters that cannot be interpreted as
part of the notation of an decimal literal, and no indication is given
that any such characters were ignored.

Returns TRUE if the argument coerces to NAN, and otherwise returns
FALSE.

NOTE A reliable way for ECMAScript code to test if a value X is a NAN is
an expression of the form X !== X. The result will be TRUE if and only
if X is a NAN.

Returns FALSE if the argument coerces to NAN, +∞, or −∞, and otherwise
returns TRUE.

Uniform Resource Identifiers, or URIs, are Strings that identify
resources (e.g. web pages or files) and transport protocols by which to
access them (e.g. HTTP or FTP) on the Internet. The ECMAScript language
itself does not provide any support for using URIs except for functions
that encode and decode URIs as described in 15.1.3.1, 15.1.3.2, 15.1.3.3
and 15.1.3.4.

NOTE Many implementations of ECMAScript provide additional functions and
methods that manipulate web pages; these functions are beyond the scope
of this standard.

A URI is composed of a sequence of components separated by component
separators. The general form is:

_Scheme_ : _First_ / _Second_ ; _Third_ ? _Fourth

where the italicised names represent components and “:”, “/”, “;” and
“?” are reserved characters used as separators. The ENCODEURI and
DECODEURI functions are intended to work with complete URIs; they assume
that any reserved characters in the URI are intended to have special
meaning and so are not encoded. The ENCODEURICOMPONENT and
DECODEURICOMPONENT functions are intended to work with the individual
component parts of a URI; they assume that any reserved characters
represent text and so must be encoded so that they are not interpreted
as reserved characters when the component is part of a complete URI.

The following lexical grammar specifies the form of encoded URIs.

Syntax

uri :::

uriCharacters~opt~

uriCharacters :::

uriCharacter uriCharacters~opt~

uriCharacter :::

uriReserved
uriUnescaped
uriEscaped

uriReserved ::: ONE OF

; / ? : @ & = + $ ,

uriUnescaped :::

uriAlpha
DecimalDigit
uriMark

uriEscaped :::

% HexDigit HexDigit

uriAlpha ::: ONE OF

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

uriMark ::: ONE OF

- _ . ! ~ * ' ( )

NOTE The above syntax is based upon RFC 2396 and does not reflect
changes introduced by the more recent RFC 3986.

When a character to be included in a URI is not listed above or is not
intended to have the special meaning sometimes given to the reserved
characters, that character must be encoded. The character is transformed
into its UTF-8 encoding, with surrogate pairs first converted from
UTF-16 to the corresponding code point value. (Note that for code units
in the range [0,127] this results in a single octet with the same
value.) The resulting sequence of octets is then transformed into a
String with each octet represented by an escape sequence of the form
“%xx”.

The encoding and escaping process is described by the abstract operation
Encode taking two String arguments _string_ and _unescapedSet_.

The unescaping and decoding process is described by the abstract
operation Decode taking two String arguments _string_ and _reservedSet_.

NOTE This syntax of Uniform Resource Identifiers is based upon RFC 2396
and does not reflect the more recent RFC 3986 which replaces RFC 2396. A
formal description and implementation of UTF-8 is given in RFC 3629.

In UTF-8, characters are encoded using sequences of 1 to 6 octets. The
only octet of a "sequence" of one has the higher-order bit set to 0, the
remaining 7 bits being used to encode the character value. In a sequence
of n octets, n>1, the initial octet has the n higher-order bits set to
1, followed by a bit set to 0. The remaining bits of that octet contain
bits from the value of the character to be encoded. The following octets
all have the higher-order bit set to 1 and the following bit set to 0,
leaving 6 bits in each to contain bits from the character to be encoded.
The possible UTF-8 encodings of ECMAScript characters are specified in
Table 22.

Table 22 — UTF-8 Encodings

  ------------------- --------------------- --------------- --------------- --------------- ---------------
  _CODE UNIT VALUE_   _REPRESENTATION_      _1^ST^ OCTET_   _2^ND^ OCTET_   _3^RD^ OCTET_   _4^TH^ OCTET_

  0X0000 - 0X007F     00000000 0_zzzzzzz_   0_zzzzzzz_                                      

  0X0080 - 0X07FF     00000_yyy yyzzzzzz_   110_yyyyy_      10_zzzzzz_                      

  0X0800 - 0XD7FF     _xxxxyyyy yyzzzzzz_   1110_xxxx_      10_yyyyyy_      10_zzzzzz_      

  0XD800 - 0XDBFF     110110_vv vvwwwwxx_   11110_uuu_      10_uuwwww_      10_xxyyyy_      10_zzzzzz_
                                                                                            
  _followed by_       _followed by_                                                         
                                                                                            
  0XDC00 – 0XDFFF     110111_yy yyzzzzzz_                                                   

  0XD800 - 0XDBFF     _causes_ URIError                                                     
                                                                                            
  _not followed by_                                                                         
                                                                                            
  0XDC00 – 0XDFFF                                                                           

  0XDC00 – 0XDFFF     _causes_ URIError                                                     

  0XE000 - 0XFFFF     _xxxxyyyy yyzzzzzz_   1110_xxxx_      10_yyyyyy_      10_zzzzzz_      
  ------------------- --------------------- --------------- --------------- --------------- ---------------

Where

_uuuuu_ = _vvvv_ + 

to account for the addition of 0x10000 as in Surrogates, section 3.7, of
the Unicode Standard.

The range of code unit values 0xD800-0xDFFF is used to encode surrogate
pairs; the above transformation combines a UTF-16 surrogate pair into a
UTF-32 representation and encodes the resulting 21-bit value in UTF-8.
Decoding reconstructs the surrogate pair.

RFC 3629 prohibits the decoding of invalid UTF-8 octet sequences. For
example, the invalid sequence C0 80 must not decode into the character
U+0000. Implementations of the Decode algorithm are required to throw a
URIERROR when encountering such invalid sequences.

The DECODEURI function computes a new version of a URI in which each
escape sequence and UTF-8 encoding of the sort that might be introduced
by the ENCODEURI function is replaced with the character that it
represents. Escape sequences that could not have been introduced by
ENCODEURI are not replaced.

When the DECODEURI function is called with one argument _encodedURI_,
the following steps are taken:

NOTE The character “#” is not decoded from escape sequences even though
it is not a reserved URI character.

The DECODEURICOMPONENT function computes a new version of a URI in which
each escape sequence and UTF-8 encoding of the sort that might be
introduced by the ENCODEURICOMPONENT function is replaced with the
character that it represents.

When the DECODEURICOMPONENT function is called with one argument
_encodedURIComponent_, the following steps are taken:

The ENCODEURI function computes a new version of a URI in which each
instance of certain characters is replaced by one, two, three, or four
escape sequences representing the UTF-8 encoding of the character.

When the ENCODEURI function is called with one argument _uri_, the
following steps are taken:

NOTE The character “#” is not encoded to an escape sequence even though
it is not a reserved or unescaped URI character.

The ENCODEURICOMPONENT function computes a new version of a URI in which
each instance of certain characters is replaced by one, two, three, or
four escape sequences representing the UTF-8 encoding of the character.

When the ENCODEURICOMPONENT function is called with one argument
_uriComponent_, the following steps are taken:

See 15.2.1 and 15.2.2.

See 15.3.1 and 15.3.2.

See 15.4.1 and 15.4.2.

See 15.5.1 and 15.5.2.

See 15.6.1 and 15.6.2.

See 15.7.1 and 15.7.2.

See 15.9.2.

See 15.10.3 and 15.10.4.

See 15.11.1 and 15.11.2.

See 15.11.6.1.

See 15.11.6.2.

See 15.11.6.3.

See 15.11.6.4.

See 15.11.6.5.

See 15.11.6.6.

See 15.8.

See 15.12.

When OBJECT is called as a function rather than as a constructor, it
performs a type conversion.

When the OBJECT function is called with no arguments or with one
argument _value_, the following steps are taken:

When OBJECT is called as part of a NEW expression, it is a constructor
that may create an object.

When the OBJECT constructor is called with no arguments or with one
argument _value_, the following steps are taken:

The value of the [[Prototype]] internal property of the Object
constructor is the standard built-in Function prototype object.

Besides the internal properties and the LENGTH property (whose value is
1), the Object constructor has the following properties:

The initial value of OBJECT.PROTOTYPE is the standard built-in Object
prototype object (15.2.4).

This property has the attributes {[[Writable]]: false, [[Enumerable]]:
false, [[Configurable]]: false }.

When the GETPROTOTYPEOF function is called with argument _O_, the
following steps are taken:

When the GETOWNPROPERTYDESCRIPTOR function is called, the following
steps are taken:

When the GETOWNPROPERTYNAMES function is called, the following steps are
taken:

NOTE If _O_ is a String instance, the set of own properties processed in
step 4 includes the implicit properties defined in 15.5.5.2 that
correspond to character positions within the object’s [[PrimitiveValue]]
String.

The CREATE function creates a new object with a specified prototype.
When the CREATE function is called, the following steps are taken:

The DEFINEPROPERTY function is used to add an own property and/or update
the attributes of an existing own property of an object. When the
DEFINEPROPERTY function is called, the following steps are taken:

The DEFINEPROPERTIES function is used to add own properties and/or
update the attributes of existing own properties of an object. When the
DEFINEPROPERTIES function is called, the following steps are taken:

If an implementation defines a specific order of enumeration for the
for-in statement, that same enumeration order must be used to order the
list elements in step 3 of this algorithm.

When the SEAL function is called, the following steps are taken:

When the FREEZE function is called, the following steps are taken:

When the PREVENTEXTENSIONS function is called, the following steps are
taken:

When the ISSEALED function is called with argument _O_, the following
steps are taken:

When the ISFROZEN function is called with argument _O_, the following
steps are taken:

When the ISEXTENSIBLE function is called with argument _O_, the
following steps are taken:

When the KEYS function is called with argument _O_, the following steps
are taken:

If an implementation defines a specific order of enumeration for the
for-in statement, that same enumeration order must be used in step 5 of
this algorithm.

The value of the [[Prototype]] internal property of the Object prototype
object is NULL and the initial value of the [[Extensible]] internal
property is TRUE.

The initial value of OBJECT.PROTOTYPE.CONSTRUCTOR is the standard
built-in OBJECT constructor.

When the TOSTRING method is called, the following steps are taken:

Table 23 — Tags for Classified Native Objects

  [[NATIVEBRAND]] VALUE   _TAG_ VALUE
  ----------------------- -------------
  NativeFunction          "FUNCTION"
  NativeArray             "ARRAY"
  StringWrapper           "STRING"
  BooleanWrapper          "BOOLEAN"
  NumberWrapper           "NUMBER"
  NativeMath              "MATH"
  NativeDate              "DATE"
  NativeRegExp            "REGEXP"
  NativeError             "ERROR"
  NativeJSON              "JSON"
  NativeArguments         "ARGUMENTS"
                          

When the TOLOCALESTRING method is called, the following steps are taken:

NOTE 1 This function is provided to give all Objects a generic
TOLOCALESTRING interface, even though not all may use it. Currently,
ARRAY, NUMBER, and DATE provide their own locale-sensitive
TOLOCALESTRING methods.

NOTE 2 The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that implementations
do not use this parameter position for anything else.

When the VALUEOF method is called, the following steps are taken:

When the HASOWNPROPERTY method is called with argument _V_, the
following steps are taken:

NOTE 1 Unlike [[HasProperty]] (8.12.6), this method does not consider
objects in the prototype chain.

NOTE 2 The ordering of steps 1 and 2 is chosen to ensure that any
exception that would have been thrown by step 1 in previous editions of
this specification will continue to be thrown even if the THIS value is
UNDEFINED or NULL.

When the ISPROTOTYPEOF method is called with argument _V_, the following
steps are taken:

NOTE The ordering of steps 1 and 2 is chosen to preserve the behaviour
specified by previous editions of this specification for the case where
V is not an object and the this value is undefined or null.

When the PROPERTYISENUMERABLE method is called with argument _V_, the
following steps are taken:

NOTE 1 This method does not consider objects in the prototype chain.

NOTE 2 The ordering of steps 1 and 2 is chosen to ensure that any
exception that would have been thrown by step 1 in previous editions of
this specification will continue to be thrown even if the THIS value is
UNDEFINED or NULL.

Object instances have no special properties beyond those inherited from
the Object prototype object.

When FUNCTION is called as a function rather than as a constructor, it
creates and initialises a new Function object. Thus the function call
FUNCTION(…) is equivalent to the object creation expression NEW
FUNCTION(…) with the same arguments.

When the FUNCTION function is called with some arguments _p1_, _p2_, … ,
_pn_, _body_ (where _n_ might be 0, that is, there are no “_p_”
arguments, and where _body_ might also not be provided), the following
steps are taken:

When FUNCTION is called as part of a NEW expression, it is a
constructor: it initialises the newly created object.

The last argument specifies the body (executable code) of a function;
any preceding arguments specify formal parameters.

When the FUNCTION constructor is called with some arguments _p1_, _p2_,
… , _pn_, _body_ (where _n_ might be 0, that is, there are no “_p_”
arguments, and where _body_ might also not be provided), the following
steps are taken:

A PROTOTYPE property is automatically created for every function, to
provide for the possibility that the function will be used as a
constructor.

NOTE It is permissible but not necessary to have one argument for each
formal parameter to be specified. For example, all three of the
following expressions produce the same result:

  new Function("a", "b", "c", "return a+b+c")

  new Function("a, b, c", "return a+b+c")

  new Function("a,b", "c", "return a+b+c")

The Function constructor is itself a Function object and has a
[[NativeBrand]] internal property whose value is NativeFunction. The
value of the [[Prototype]] internal property of the Function constructor
is the standard built-in Function prototype object (15.3.4).

The value of the [[Extensible]] internal property of the Function
constructor is TRUE.

The Function constructor has the following properties:

The initial value of FUNCTION.PROTOTYPE is the standard built-in
Function prototype object (15.3.4).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

This is a data property with a value of 1. This property has the
attributes { [[Writable]]: FALSE, [[Enumerable]]: FALSE,
[[Configurable]]: FALSE }.

The Function prototype object is itself a Function object and has a
[[NativeBrand]] internal property whose value is NativeFunction . When
invoked, it accepts any arguments and returns UNDEFINED.

The value of the [[Prototype]] internal property of the Function
prototype object is the standard built-in Object prototype object
(15.2.4). The initial value of the [[Extensible]] internal property of
the Function prototype object is TRUE.

The Function prototype object does not have a VALUEOF property of its
own; however, it inherits the VALUEOF property from the Object prototype
Object.

The LENGTH property of the Function prototype object is 0.

The initial value of FUNCTION.PROTOTYPE.CONSTRUCTOR is the built-in
FUNCTION constructor.

An implementation-dependent representation of the function is returned.
This representation has the syntax of a _FunctionDeclaration_. Note in
particular that the use and placement of white space, line terminators,
and semicolons within the representation String is
implementation-dependent.

The TOSTRING function is not generic; it throws a TYPEERROR exception if
its THIS value is not a Function object. Therefore, it cannot be
transferred to other kinds of objects for use as a method.

When the APPLY method is called on an object _func_ with arguments
_thisArg_ and _argArray_, the following steps are taken:

The LENGTH property of the APPLY method is 2.

NOTE The thisArg value is passed without modification as the THIS value.
This is a change from Edition 3, where a UNDEFINED or NULL thisArg is
replaced with the global object and ToObject is applied to all other
values and that result is passed as the THIS value.

When the CALL method is called on an object _func_ with argument
_thisArg_ and optional arguments _arg1_, _arg2_ etc, the following steps
are taken:

The LENGTH property of the CALL method is 1.

NOTE The thisArg value is passed without modification as the THIS value.
This is a change from Edition 3, where a UNDEFINED or NULL thisArg is
replaced with the global object and ToObject is applied to all other
values and that result is passed as the THIS value.

The bind method takes one or more arguments, _thisArg_ and (optionally)
_arg1_, _arg2_, etc, and returns a new function object by performing the
following steps:

The LENGTH property of the BIND method is 1.

NOTE Function objects created using FUNCTION.PROTOTYPE.BIND do not have
a PROTOTYPE property or the [[Code]], [[FormalParameters]], and
[[Scope]] internal properties.

When the [[Call]] internal method of a function object, _F_, which was
created using the bind function is called with a THIS value and a list
of arguments _ExtraArgs_, the following steps are taken:

When the [[Construct]] internal method of a function object, _F_ that
was created using the bind function is called with a list of arguments
_ExtraArgs_, the following steps are taken:

When the [[HasInstance]] internal method of a function object _F_, that
was created using the bind function is called with argument _V_, the
following steps are taken:

In addition to the required internal properties, every function instance
has a [[Call]] internal property and in most cases uses a different
version of the [[Get]] internal property. Depending on how they are
created (see 8.6.2, 13.2, 15, and 15.3.4.5), function instances may have
a [[HasInstance]] internal property, a [[Scope]] internal property, a
[[Construct]] internal property, a [[FormalParameters]] internal
property, a [[Code]] internal property, a [[TargetFunction]] internal
property, a [[BoundThis]] internal property, and a [[BoundArgs]]
internal property.

Every function instance has a [[NativeBrand]] internal property whose
value is NativeFunction.

Function instances that correspond to strict mode functions (13.2) and
function instances created using the FUNCTION.PROTOTYPE.BIND METHOD
(15.3.4.5) have properties named “caller” and “arguments” that throw a
TYPEERROR exception. An ECMAScript implementation must not associate any
implementation specific behaviour with accesses of these properties from
strict mode function code.

The value of the LENGTH property is an integer that indicates the
“typical” number of arguments expected by the function. However, the
language permits the function to be invoked with some other number of
arguments. The behaviour of a function when invoked on a number of
arguments other than the number specified by its LENGTH property depends
on the function. This property has the attributes { [[Writable]]: FALSE,
[[Enumerable]]: FALSE, [[Configurable]]: FALSE }.

The value of the PROTOTYPE property is used to initialise the
[[Prototype]] internal property of a newly created object before the
Function object is invoked as a constructor for that newly created
object. This property has the attribute { [[Writable]]: TRUE,
[[Enumerable]]: FALSE, [[Configurable]]: FALSE }.

NOTE Function objects created using FUNCTION.PROTOTYPE.BIND do not have
a PROTOTYPE property.

Assume _F_ is a Function object.

When the [[HasInstance]] internal method of _F_ is called with value
_V_, the following steps are taken:

NOTE Function objects created using FUNCTION.PROTOTYPE.BIND have a
different implementation of [[HasInstance]] defined in 15.3.4.5.3.

Function objects use a variation of the [[Get]] internal method used for
other native ECMAScript objects (8.12.3).

Assume _F_ is a Function object. When the [[Get]] internal method of _F_
is called with property name _P_, the following steps are taken:

NOTE Function objects created using FUNCTION.PROTOTYPE.BIND use the
default [[Get]] internal method.

Array objects give special treatment to a certain class of property
names. A property name _P_ (in the form of a String value) is an _array
index_ if and only if ToString(ToUint32(_P_)) is equal to _P_ and
ToUint32(_P_) is not equal to 2^32^−1. A property whose property name is
an array index is also called an _element_. Every Array object has a
LENGTH property whose value is always a nonnegative integer less than
2^32^. The value of the LENGTH property is numerically greater than the
name of every property whose name is an array index; whenever a property
of an Array object is created or changed, other properties are adjusted
as necessary to maintain this invariant. Specifically, whenever a
property is added whose name is an array index, the LENGTH property is
changed, if necessary, to be one more than the numeric value of that
array index; and whenever the LENGTH property is changed, every property
whose name is an array index whose value is not smaller than the new
length is automatically deleted. This constraint applies only to own
properties of an Array object and is unaffected by LENGTH or array index
properties that may be inherited from its prototypes.

An object, _O_, is said to be _sparse_ if the following algorithm
returns TRUE:

When ARRAY is called as a function rather than as a constructor, it
creates and initialises a new Array object. Thus the function call
ARRAY(…) is equivalent to the object creation expression NEW ARRAY(…)
with the same arguments.

When the ARRAY function is called the following steps are taken:

When ARRAY is called as part of a NEW expression, it is a constructor:
it initialises the newly created object.

This description applies if and only if the Array constructor is given
no arguments or at least two arguments.

The [[Prototype]] internal property of the newly constructed object is
set to the original Array prototype object, the one that is the initial
value of ARRAY.PROTOTYPE (15.4.3.1).

The newly constructed object has the [[NativeBrand]] internal property
with value NativeArray.

The [[Extensible]] internal property of the newly constructed object is
set to TRUE.

The LENGTH property of the newly constructed object is set to the number
of arguments.

The 0 property of the newly constructed object is set to _item0_ (if
supplied); the 1 property of the newly constructed object is set to
_item1_ (if supplied); and, in general, for as many arguments as there
are, the _k_ property of the newly constructed object is set to argument
_k_, where the first argument is considered to be argument number 0.
These properties all have the attributes {[[Writable]]: TRUE,
[[Enumerable]]: TRUE, [[Configurable]]: TRUE}.

The [[Prototype]] internal property of the newly constructed object is
set to the original Array prototype object, the one that is the initial
value of ARRAY.PROTOTYPE (15.4.3.1). The newly constructed object has
the [[NativeBrand]] internal property with value NativeArray. The
[[Extensible]] internal property of the newly constructed object is set
to TRUE.

If the argument _len_ is a Number and ToUint32(_len_) is equal to _len_,
then the LENGTH property of the newly constructed object is set to
ToUint32(_len_). If the argument _len_ is a Number and ToUint32(_len_)
is not equal to _len_, a RANGEERROR exception is thrown.

If the argument _len_ is not a Number, then the LENGTH property of the
newly constructed object is set to 1 and the 0 property of the newly
constructed object is set to _len_ with attributes {[[Writable]]: TRUE,
[[Enumerable]]: TRUE, [[Configurable]]: TRUE}.

The value of the [[Prototype]] internal property of the Array
constructor is the Function prototype object (15.3.4).

Besides the internal properties and the LENGTH property (whose value is
1), the Array constructor has the following properties:

The initial value of ARRAY.PROTOTYPE is the Array prototype object
(15.4.4).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

The isArray function takes one argument _arg_, and returns the Boolean
value TRUE if the argument is an object whose class internal property is
"ARRAY"; otherwise it returns FALSE. The following steps are taken:

The value of the [[Prototype]] internal property of the Array prototype
object is the standard built-in Object prototype object (15.2.4).

The Array prototype object is itself an array; it has an [[NativeBrand]]
internal property with value NativeArray, and it has a LENGTH property
(whose initial value is +0) and the special [[DefineOwnProperty]]
internal method described in 15.4.5.1.

In following descriptions of functions that are properties of the Array
prototype object, the phrase “this object” refers to the object that is
the THIS value for the invocation of the function. It is permitted for
the THIS to be an object which does not have an [[NativeBrand]] internal
property with value NativeArray.

NOTE The Array prototype object does not have a VALUEOF property of its
own; however, it inherits the VALUEOF property from the standard
built-in Object prototype Object.

The initial value of ARRAY.PROTOTYPE.CONSTRUCTOR is the standard
built-in ARRAY constructor.

When the TOSTRING method is called, the following steps are taken:

NOTE The TOSTRING function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the TOSTRING
function can be applied successfully to a host object is
implementation-dependent.

The elements of the array are converted to Strings using their
TOLOCALESTRING methods, and these Strings are then concatenated,
separated by occurrences of a separator String that has been derived in
an implementation-defined locale-specific way. The result of calling
this function is intended to be analogous to the result of TOSTRING,
except that the result of this function is intended to be
locale-specific.

The result is calculated as follows:

NOTE 1 The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that implementations
do not use this parameter position for anything else.

NOTE 2 The TOLOCALESTRING function is intentionally generic; it does not
require that its THIS value be an Array object. Therefore it can be
transferred to other kinds of objects for use as a method. Whether the
TOLOCALESTRING function can be applied successfully to a host object is
implementation-dependent.

When the CONCAT method is called with zero or more arguments _item1_,
_item2_, etc., it returns an array containing the array elements of the
object followed by the array elements of each argument in order.

The following steps are taken:

The LENGTH property of the CONCAT method is 1.

NOTE The CONCAT function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the CONCAT
function can be applied successfully to a host object is
implementation-dependent.

The elements of the array are converted to Strings, and these Strings
are then concatenated, separated by occurrences of the _separator_. If
no separator is provided, a single comma is used as the separator.

The JOIN method takes one argument, _separator_, and performs the
following steps:

The LENGTH property of the JOIN method is 1.

NOTE The JOIN function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore, it can be transferred
to other kinds of objects for use as a method. Whether the JOIN function
can be applied successfully to a host object is
implementation-dependent.

The last element of the array is removed from the array and returned.

NOTE The POP function is intentionally generic; it does not require that
its THIS value be an Array object. Therefore it can be transferred to
other kinds of objects for use as a method. Whether the POP function can
be applied successfully to a host object is implementation-dependent.

The arguments are appended to the end of the array, in the order in
which they appear. The new length of the array is returned as the result
of the call.

When the PUSH method is called with zero or more arguments _item1_,
_item2_, etc., the following steps are taken:

The LENGTH property of the PUSH method is 1.

NOTE The PUSH function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the PUSH function
can be applied successfully to a host object is
implementation-dependent.

The elements of the array are rearranged so as to reverse their order.
The object is returned as the result of the call.

NOTE The REVERSE function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore, it can be transferred
to other kinds of objects for use as a method. Whether the REVERSE
function can be applied successfully to a host object is
implementation-dependent.

The first element of the array is removed from the array and returned.

NOTE The SHIFT function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the SHIFT
function can be applied successfully to a host object is
implementation-dependent.

The SLICE method takes two arguments, _start_ and _end_, and returns an
array containing the elements of the array from element _start_ up to,
but not including, element _end_ (or through the end of the array if
_end_ is UNDEFINED). If _start_ is negative, it is treated as
_length_+_start_ where _length_ is the length of the array. If _end_ is
negative, it is treated as _length_+_end_ where _length_ is the length
of the array. The following steps are taken:

The LENGTH property of the SLICE method is 2.

NOTE The SLICE function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the SLICE
function can be applied successfully to a host object is
implementation-dependent.

The elements of this array are sorted. The sort is not necessarily
stable (that is, elements that compare equal do not necessarily remain
in their original order). If _comparefn_ is not UNDEFINED, it should be
a function that accepts two arguments _x_ and _y_ and returns a negative
value if _x_ < _y_, zero if _x_ = _y_, or a positive value if _x_ > _y_.

Let _obj_ be the result of calling ToObject passing the THIS value as
the argument.

Let _len_ be the result of applying Uint32 to the result of calling the
[[Get]] internal method of _obj_ with argument "LENGTH".

If _comparefn_ is not UNDEFINED and is not a consistent comparison
function for the elements of this array (see below), the behaviour of
SORT is implementation-defined.

Let _proto_ be the value of the [[Prototype]] internal property of
_obj_. If _proto_ is not NULL and there exists an integer _j_ such that
all of the conditions below are satisfied then the behaviour of SORT is
implementation-defined:

-   _obj_ is sparse (15.4)

-   0 ≤ _j_ < _len_

-   The result of calling the [[HasProperty]] internal method of _proto_
    with argument ToString(_j_) is TRUE.

The behaviour of SORT is also implementation defined if _obj_ is sparse
and any of the following conditions are true:

-   The [[Extensible]] internal property of _obj_ is FALSE.

-   Any array index property of _obj_ whose name is a nonnegative
    integer less than _len_ is a data property whose [[Configurable]]
    attribute is FALSE.

The behaviour of SORT is also implementation defined if any array index
property of _obj_ whose name is a nonnegative integer less than _len_ is
an accessor property or is a data property whose [[Writable]] attribute
is FALSE.

Otherwise, the following steps are taken.

The returned object must have the following two properties.

-   There must be some mathematical permutation π of the nonnegative
    integers less than _len_, such that for every nonnegative integer
    _j_ less than _len_, if property old[_j_] existed, then new[π(_j_)]
    is exactly the same value as old[_j_],. But if property old[_j_] did
    not exist, then new[π(_j_)] does not exist.

-   Then for all nonnegative integers _j_ and _k_, each less than _len_,
    if SortCompare(_j_,_k_) < 0 (see SortCompare below), then Π(_j_) <
    Π(_k_).

Here the notation old[_j_] is used to refer to the hypothetical result
of calling the [[Get]] internal method of _obj_ with argument _j_ before
this function is executed, and the notation new[_j_] to refer to the
hypothetical result of calling the [[Get]] internal method of _obj_ with
argument _j_ after this function has been executed.

A function _comparefn_ is a consistent comparison function for a set of
values _S_ if all of the requirements below are met for all values _a_,
_b_, and _c_ (possibly the same value) in the set _S_: The notation
_a_ <~CF~ _b_ means _comparefn_(_a_,_b_) < 0; _a_ =~CF~ _b_ means
_comparefn_(_a_,_b_) = 0 (of either sign); and _a_ >~CF~ _b_ means
_comparefn_(_a_,_b_) > 0.

-   Calling _comparefn_(_a_,_b_) always returns the same value _v_ when
    given a specific pair of values _a_ and _b_ as its two arguments.
    Furthermore, Type(_v_) is Number, and _v_ is not NaN. Note that this
    implies that exactly one of _a_ <~CF~ _b_, _a_ =~CF~ _b_, and
    _a_ >~CF~ _b_ will be true for a given pair of _a_ and _b_.

-   Calling _comparefn_(_a_,_b_) does not modify the THIS object.

-   _a_ =~CF~ _a_ (reflexivity)

-   If _a_ =~CF~ _b_, then _b_ =~CF~ _a_ (symmetry)

-   If _a_ =~CF~ _b_ and _b_ =~CF~ _c_, then _a_ =~CF~ _c_ (transitivity
    of =~CF~)

-   If _a_ <~CF~ _b_ and _b_ <~CF~ _c_, then _a_ <~CF~ _c_ (transitivity
    of <~CF~)

-   If _a_ >~CF~ _b_ and _b_ >~CF~ _c_, then _a_ >~CF~ _c_ (transitivity
    of >~CF~)

NOTE The above conditions are necessary and sufficient to ensure that
_comparefn_ divides the set _S_ into equivalence classes and that these
equivalence classes are totally ordered.

When the SortCompare abstract operation is called with two arguments _j_
and _k_, the following steps are taken:

NOTE 1 Because non-existent property values always compare greater than
UNDEFINED property values, and UNDEFINED always compares greater than
any other value, undefined property values always sort to the end of the
result, followed by non-existent property values.

NOTE 2 The SORT function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore, it can be transferred
to other kinds of objects for use as a method. Whether the SORT function
can be applied successfully to a host object is
implementation-dependent.

When the SPLICE method is called with two or more arguments _start_,
_deleteCount_ and (optionally) _item1_, _item2_, etc., the _deleteCount
elements of the array starting at array index _start_ are replaced by
the arguments _item1_, _item2_, etc. An Array object containing the
deleted elements (if any) is returned. The following steps are taken:

The LENGTH property of the SPLICE method is 2.

NOTE The SPLICE function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the SPLICE
function can be applied successfully to a host object is
implementation-dependent.

The arguments are prepended to the start of the array, such that their
order within the array is the same as the order in which they appear in
the argument list.

When the UNSHIFT method is called with zero or more arguments _item1_,
_item2_, etc., the following steps are taken:

The LENGTH property of the UNSHIFT method is 1.

NOTE The UNSHIFT function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the UNSHIFT
function can be applied successfully to a host object is
implementation-dependent.

INDEXOF compares _searchElement_ to the elements of the array, in
ascending order, using the internal Strict Equality Comparison Algorithm
(11.9.6), and if found at one or more positions, returns the index of
the first such position; otherwise, -1 is returned.

The optional second argument _fromIndex_ defaults to 0 (i.e. the whole
array is searched). If it is greater than or equal to the length of the
array, -1 is returned, i.e. the array will not be searched. If it is
negative, it is used as the offset from the end of the array to compute
_fromIndex_. If the computed index is less than 0, the whole array will
be searched.

When the INDEXOF method is called with one or two arguments, the
following steps are taken:

The LENGTH property of the INDEXOF method is 1.

NOTE The INDEXOF function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the INDEXOF
function can be applied successfully to a host object is
implementation-dependent.

LASTINDEXOF compares _searchElement_ to the elements of the array in
descending order using the internal Strict Equality Comparison Algorithm
(11.9.6), and if found at one or more positions, returns the index of
the last such position; otherwise, -1 is returned.

The optional second argument _fromIndex_ defaults to the array's length
minus one (i.e. the whole array is searched). If it is greater than or
equal to the length of the array, the whole array will be searched. If
it is negative, it is used as the offset from the end of the array to
compute _fromIndex_. If the computed index is less than 0, -1 is
returned.

When the LASTINDEXOF method is called with one or two arguments, the
following steps are taken:

The LENGTH property of the LASTINDEXOF method is 1.

NOTE The LASTINDEXOF function is intentionally generic; it does not
require that its THIS value be an Array object. Therefore it can be
transferred to other kinds of objects for use as a method. Whether the
LASTINDEXOF function can be applied successfully to a host object is
implementation-dependent.

_callbackfn_ should be a function that accepts three arguments and
returns a value that is coercible to the Boolean value TRUE or FALSE.
EVERY calls _callbackfn_ once for each element present in the array, in
ascending order, until it finds one where _callbackfn_ returns FALSE. If
such an element is found, EVERY immediately returns FALSE. Otherwise, if
_callbackfn_ returned TRUE for all elements, EVERY will return TRUE.
_callbackfn_ is called only for elements of the array which actually
exist; it is not called for missing elements of the array.

If a _thisArg_ parameter is provided, it will be used as the THIS value
for each invocation of _callbackfn_. If it is not provided, UNDEFINED is
used instead.

_callbackfn_ is called with three arguments: the value of the element,
the index of the element, and the object being traversed.

EVERY does not directly mutate the object on which it is called but the
object may be mutated by the calls to _callbackfn_.

The range of elements processed by EVERY is set before the first call to
_callbackfn_. Elements which are appended to the array after the call to
EVERY begins will not be visited by _callbackfn_. If existing elements
of the array are changed, their value as passed to _callbackfn_ will be
the value at the time EVERY visits them; elements that are deleted after
the call to EVERY begins and before being visited are not visited. EVERY
acts like the "for all" quantifier in mathematics. In particular, for an
empty array, it returns TRUE.

When the EVERY method is called with one or two arguments, the following
steps are taken:

The LENGTH property of the EVERY method is 1.

NOTE The EVERY function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the EVERY
function can be applied successfully to a host object is
implementation-dependent.

_callbackfn_ should be a function that accepts three arguments and
returns a value that is coercible to the Boolean value TRUE or FALSE.
SOME calls _callbackfn_ once for each element present in the array, in
ascending order, until it finds one where _callbackfn_ returns TRUE. If
such an element is found, SOME immediately returns TRUE. Otherwise, SOME
returns FALSE. _callbackfn_ is called only for elements of the array
which actually exist; it is not called for missing elements of the
array.

If a _thisArg_ parameter is provided, it will be used as the THIS value
for each invocation of _callbackfn_. If it is not provided, UNDEFINED is
used instead.

_callbackfn_ is called with three arguments: the value of the element,
the index of the element, and the object being traversed.

SOME does not directly mutate the object on which it is called but the
object may be mutated by the calls to _callbackfn_.

The range of elements processed by SOME is set before the first call to
_callbackfn_. Elements that are appended to the array after the call to
SOME begins will not be visited by _callbackfn_. If existing elements of
the array are changed, their value as passed to _callbackfn_ will be the
value at the time that SOME visits them; elements that are deleted after
the call to SOME begins and before being visited are not visited. SOME
acts like the "exists" quantifier in mathematics. In particular, for an
empty array, it returns FALSE.

When the SOME method is called with one or two arguments, the following
steps are taken:

The LENGTH property of the SOME method is 1.

NOTE The SOME function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the SOME function
can be applied successfully to a host object is
implementation-dependent.

_callbackfn_ should be a function that accepts three arguments. FOREACH
calls _callbackfn_ once for each element present in the array, in
ascending order. _callbackfn_ is called only for elements of the array
which actually exist; it is not called for missing elements of the
array.

If a _thisArg_ parameter is provided, it will be used as the THIS value
for each invocation of _callbackfn_. If it is not provided, UNDEFINED is
used instead.

_callbackfn_ is called with three arguments: the value of the element,
the index of the element, and the object being traversed.

FOREACH does not directly mutate the object on which it is called but
the object may be mutated by the calls to _callbackfn_.

The range of elements processed by FOREACH is set before the first call
to _callbackfn_. Elements which are appended to the array after the call
to FOREACH begins will not be visited by _callbackfn_. If existing
elements of the array are changed, their value as passed to callback
will be the value at the time FOREACH visits them; elements that are
deleted after the call to FOREACH begins and before being visited are
not visited.

When the FOREACH method is called with one or two arguments, the
following steps are taken:

The LENGTH property of the FOREACH method is 1.

NOTE The FOREACH function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the FOREACH
function can be applied successfully to a host object is
implementation-dependent.

_callbackfn_ should be a function that accepts three arguments. MAP
calls _callbackfn_ once for each element in the array, in ascending
order, and constructs a new Array from the results. _callbackfn_ is
called only for elements of the array which actually exist; it is not
called for missing elements of the array.

If a _thisArg_ parameter is provided, it will be used as the THIS value
for each invocation of _callbackfn_. If it is not provided, UNDEFINED is
used instead.

_callbackfn_ is called with three arguments: the value of the element,
the index of the element, and the object being traversed.

MAP does not directly mutate the object on which it is called but the
object may be mutated by the calls to _callbackfn_.

The range of elements processed by MAP is set before the first call to
_callbackfn_. Elements which are appended to the array after the call to
MAP begins will not be visited by _callbackfn_. If existing elements of
the array are changed, their value as passed to _callbackfn_ will be the
value at the time MAP visits them; elements that are deleted after the
call to MAP begins and before being visited are not visited.

When the MAP method is called with one or two arguments, the following
steps are taken:

The LENGTH property of the MAP method is 1.

NOTE The MAP function is intentionally generic; it does not require that
its THIS value be an Array object. Therefore it can be transferred to
other kinds of objects for use as a method. Whether the MAP function can
be applied successfully to a host object is implementation-dependent.

_callbackfn_ should be a function that accepts three arguments and
returns a value that is coercible to the Boolean value TRUE or FALSE.
FILTER calls _callbackfn_ once for each element in the array, in
ascending order, and constructs a new array of all the values for which
_callbackfn_ returns TRUE. _callbackfn_ is called only for elements of
the array which actually exist; it is not called for missing elements of
the array.

If a _thisArg_ parameter is provided, it will be used as the THIS value
for each invocation of _callbackfn_. If it is not provided, UNDEFINED is
used instead.

_callbackfn_ is called with three arguments: the value of the element,
the index of the element, and the object being traversed.

FILTER does not directly mutate the object on which it is called but the
object may be mutated by the calls to _callbackfn_.

The range of elements processed by FILTER is set before the first call
to _callbackfn_. Elements which are appended to the array after the call
to FILTER begins will not be visited by _callbackfn_. If existing
elements of the array are changed their value as passed to _callbackfn_
will be the value at the time FILTER visits them; elements that are
deleted after the call to FILTER begins and before being visited are not
visited.

When the FILTER method is called with one or two arguments, the
following steps are taken:

The LENGTH property of the FILTER method is 1.

NOTE The FILTER function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the FILTER
function can be applied successfully to a host object is
implementation-dependent.

_callbackfn_ should be a function that takes four arguments. REDUCE
calls the callback, as a function, once for each element present in the
array, in ascending order.

_callbackfn_ is called with four arguments: the _previousValue_ (or
value from the previous call to _callbackfn_), the _currentValue_ (value
of the current element), the _currentIndex_, and the object being
traversed. The first time that callback is called, the _previousValue_
and _currentValue_ can be one of two values. If an _initialValue_ was
provided in the call to REDUCE, then _previousValue_ will be equal to
_initialValue_ and _currentValue_ will be equal to the first value in
the array. If no _initialValue_ was provided, then _previousValue_ will
be equal to the first value in the array and _currentValue_ will be
equal to the second. It is a TYPEERROR if the array contains no elements
and _initialValue_ is not provided.

REDUCE does not directly mutate the object on which it is called but the
object may be mutated by the calls to _callbackfn_.

The range of elements processed by REDUCE is set before the first call
to _callbackfn_. Elements that are appended to the array after the call
to REDUCE begins will not be visited by _callbackfn_. If existing
elements of the array are changed, their value as passed to _callbackfn_
will be the value at the time REDUCE visits them; elements that are
deleted after the call to REDUCE begins and before being visited are not
visited.

When the REDUCE method is called with one or two arguments, the
following steps are taken:

The LENGTH property of the REDUCE method is 1.

NOTE The REDUCE function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the REDUCE
function can be applied successfully to a host object is
implementation-dependent.

_callbackfn_ should be a function that takes four arguments. REDUCERIGHT
calls the callback, as a function, once for each element present in the
array, in descending order.

_callbackfn_ is called with four arguments: the _previousValue_ (or
value from the previous call to _callbackfn_), the _currentValue_ (value
of the current element), the _currentIndex_, and the object being
traversed. The first time the function is called, the _previousValue_
and _currentValue_ can be one of two values. If an _initialValue_ was
provided in the call to REDUCERIGHT, then _previousValue_ will be equal
to _initialValue_ and _currentValue_ will be equal to the last value in
the array. If no _initialValue_ was provided, then _previousValue_ will
be equal to the last value in the array and _currentValue_ will be equal
to the second-to-last value. It is a TYPEERROR if the array contains no
elements and _initialValue_ is not provided.

REDUCERIGHT does not directly mutate the object on which it is called
but the object may be mutated by the calls to _callbackfn_.

The range of elements processed by REDUCERIGHT is set before the first
call to _callbackfn_. Elements that are appended to the array after the
call to REDUCERIGHT begins will not be visited by _callbackfn_. If
existing elements of the array are changed by _callbackfn_, their value
as passed to _callbackfn_ will be the value at the time REDUCERIGHT
visits them; elements that are deleted after the call to REDUCERIGHT
begins and before being visited are not visited.

When the REDUCERIGHT method is called with one or two arguments, the
following steps are taken:

The LENGTH property of the REDUCERIGHT method is 1.

NOTE The REDUCERIGHT function is intentionally generic; it does not
require that its this value be an Array object. Therefore it can be
transferred to other kinds of objects for use as a method. Whether the
REDUCERIGHT function can be applied successfully to a host object is
implementation-dependent.

Array instances inherit properties from the Array prototype object and
have the [[NativeBrand]] internal property with value NativeArray. Array
instances also have the following properties.

Array objects use a variation of the [[DefineOwnProperty]] internal
method used for other native ECMAScript objects (8.12.9).

Assume _A_ is an Array object, _Desc_ is a Property Descriptor, and
_Throw_ is a Boolean flag.

In the following algorithm, the term “Reject” means “If _Throw_ is TRUE,
then throw a TYPEERROR exception, otherwise return FALSE.”

When the [[DefineOwnProperty]] internal method of _A_ is called with
property _P_, Property Descriptor _Desc_, and Boolean flag _Throw_, the
following steps are taken:

The LENGTH property of this Array object is a data property whose value
is always numerically greater than the name of every deletable property
whose name is an array index.

The LENGTH property initially has the attributes { [[Writable]]: TRUE,
[[Enumerable]]: FALSE, [[Configurable]]: FALSE }.

NOTE Attempting to set the length property of an Array object to a value
that is numerically less than or equal to the largest numeric property
name of an existing array indexed non-deletable property of the array
will result in the length being set to a numeric value that is one
greater than that largest numeric property name. See 15.4.5.1.

When STRING is called as a function rather than as a constructor, it
performs a type conversion.

Returns a String value (not a String object) computed by
ToString(_value_). If _value_ is not supplied, the empty String "" is
returned.

When STRING is called as part of a NEW expression, it is a constructor:
it initialises the newly created object.

The [[Prototype]] internal property of the newly constructed object is
set to the standard built-in String prototype object that is the initial
value of STRING.PROTOTYPE (15.5.3.1).

The newly constructed object has the [[NativeBrand]] internal property
with value StringWrapper.

The [[Extensible]] internal property of the newly constructed object is
set to TRUE.

The [[PrimitiveValue]] internal property of the newly constructed object
is set to ToString(_value_), or to the empty String if _value_ is not
supplied.

The value of the [[Prototype]] internal property of the String
constructor is the standard built-in Function prototype object (15.3.4).

Besides the internal properties and the LENGTH property (whose value is
1), the String constructor has the following properties:

The initial value of STRING.PROTOTYPE is the standard built-in String
prototype object (15.5.4).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Returns a String value containing as many characters as the number of
arguments. Each argument specifies one character of the resulting
String, with the first argument specifying the first character, and so
on, from left to right. An argument is converted to a character by
applying the operation ToUint16 (9.7) and regarding the resulting 16-bit
integer as the code unit value of a character. If no arguments are
supplied, the result is the empty String.

The LENGTH property of the FROMCHARCODE function is 1.

The String prototype object is itself a String object whose value is an
empty String. The String prototype object has the [[NativeBrand]]
internal property with value StringWrapper.

The value of the [[Prototype]] internal property of the String prototype
object is the standard built-in Object prototype object (15.2.4).

The initial value of STRING.PROTOTYPE.CONSTRUCTOR is the built-in STRING
constructor.

Returns this String value. (Note that, for a String object, the TOSTRING
method happens to return the same thing as the VALUEOF method.)

The TOSTRING function is not generic; it throws a TYPEERROR exception if
its THIS value is not a String or a String object. Therefore, it cannot
be transferred to other kinds of objects for use as a method.

Returns this String value.

The VALUEOF function is not generic; it throws a TYPEERROR exception if
its THIS value is not a String or String object. Therefore, it cannot be
transferred to other kinds of objects for use as a method.

Returns a String containing the character at position _pos_ in the
String resulting from converting this object to a String. If there is no
character at that position, the result is the empty String. The result
is a String value, not a String object.

If _pos_ is a value of Number type that is an integer, then the result
of X.CHARAT(_pos_) is equal to the result of X.SUBSTRING(_pos_,
_pos_+1).

When the CHARAT method is called with one argument _pos_, the following
steps are taken:

NOTE The CHARAT function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

Returns a Number (a nonnegative integer less than 2^16^) representing
the code unit value of the character at position _pos_ in the String
resulting from converting this object to a String. If there is no
character at that position, the result is NAN.

When the CHARCODEAT method is called with one argument _pos_, the
following steps are taken:

NOTE The CHARCODEAT function is intentionally generic; it does not
require that its THIS value be a String object. Therefore it can be
transferred to other kinds of objects for use as a method.

When the CONCAT method is called with zero or more arguments _string1_,
_string2_, etc., it returns a String consisting of the characters of
this object (converted to a String) followed by the characters of each
of _string1_, _string2_, etc. (where each argument is converted to a
String). The result is a String value, not a String object. The
following steps are taken:

The LENGTH property of the CONCAT method is 1.

NOTE The CONCAT function is intentionally generic; it does not require
that its THIS value be a String object. Therefore it can be transferred
to other kinds of objects for use as a method.

If _searchString_ appears as a substring of the result of converting
this object to a String, at one or more positions that are greater than
or equal to _position_, then the index of the smallest such position is
returned; otherwise, 1 is returned. If _position_ is UNDEFINED, 0 is
assumed, so as to search all of the String.

The INDEXOF method takes two arguments, _searchString_ and _position_,
and performs the following steps:

The LENGTH property of the INDEXOF method is 1.

NOTE The INDEXOF function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

If _searchString_ appears as a substring of the result of converting
this object to a String at one or more positions that are smaller than
or equal to _position_, then the index of the greatest such position is
returned; otherwise, 1 is returned. If _position_ is UNDEFINED, the
length of the String value is assumed, so as to search all of the
String.

The LASTINDEXOF method takes two arguments, _searchString_ and
_position_, and performs the following steps:

The LENGTH property of the LASTINDEXOF method is 1.

NOTE The LASTINDEXOF function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

When the LOCALECOMPARE method is called with one argument _that_, it
returns a Number other than NAN that represents the result of a
locale-sensitive String comparison of the this value (converted to a
String) with _that_ (converted to a String). The two Strings are _S_ and
_That_. The two Strings are compared in an implementation-defined
fashion. The result is intended to order String values in the sort order
specified by the system default locale, and will be negative, zero, or
positive, depending on whether _S_ comes before _That_ in the sort
order, the Strings are equal, or _S_ comes after _That_ in the sort
order, respectively.

Before perform the comparisons the following steps are performed to
prepare the Strings:

The LOCALECOMPARE method, if considered as a function of two arguments
THIS and _that_, is a consistent comparison function (as defined in
15.4.4.11) on the set of all Strings.

The actual return values are implementation-defined to permit
implementers to encode additional information in the value, but the
function is required to define a total ordering on all Strings and to
return 0 when comparing Strings that are considered canonically
equivalent by the Unicode standard.

If no language-sensitive comparison at all is available from the host
environment, this function may perform a bitwise comparison.

NOTE 1 The LOCALECOMPARE method itself is not directly suitable as an
argument to ARRAY.PROTOTYPE.SORT because the latter requires a function
of two arguments.

NOTE 2 This function is intended to rely on whatever language-sensitive
comparison functionality is available to the ECMAScript environment from
the host environment, and to compare according to the rules of the host
environment’s current locale. It is strongly recommended that this
function treat Strings that are canonically equivalent according to the
Unicode standard as identical (in other words, compare the Strings as if
they had both been converted to Normalised Form C or D first). It is
also recommended that this function not honour Unicode compatibility
equivalences or decompositions.

NOTE 3 The second parameter to this function is likely to be used in a
future version of this standard; it is recommended that implementations
do not use this parameter position for anything else.

NOTE 4 The LOCALECOMPARE function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

When the MATCH method is called with argument _regexp_, the following
steps are taken:

NOTE The MATCH function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

First set _string_ according to the following steps:

If _searchValue_ is a regular expression (an object that has a
[[NativeBrand]] internal property whose value is NativeRegExp), do the
following: If _searchValue_.global is FALSE, then search _string_ for
the first match of the regular expression _searchValue_. If
_searchValue_.global is TRUE, then search _string_ for all matches of
the regular expression _searchValue_. Do the search in the same manner
as in STRING.PROTOTYPE.MATCH, including the update of
_searchValue_.LASTINDEX. Let _m_ be the number of left capturing
parentheses in _searchValue_ (using _NcapturingParens_ as specified in
15.10.2.1).

If _searchValue_ is not a regular expression, let _searchString_ be
ToString(_searchValue_) and search _string_ for the first occurrence of
_searchString_. Let _m_ be 0.

If _replaceValue_ is a function, then for each matched substring, call
the function with the following _m_ + 3 arguments. Argument 1 is the
substring that matched. If _searchValue_ is a regular expression, the
next _m_ arguments are all of the captures in the MatchResult (see
15.10.2.1). Argument _m_ + 2 is the offset within _string_ where the
match occurred, and argument _m_ + 3 is _string_. The result is a String
value derived from the original input by replacing each matched
substring with the corresponding return value of the function call,
converted to a String if need be.

Otherwise, let _newstring_ denote the result of converting
_replaceValue_ to a String. The result is a String value derived from
the original input String by replacing each matched substring with a
String derived from _newstring_ by replacing characters in _newstring_
by replacement text as specified in Table 24. These $ replacements are
done left-to-right, and, once such a replacement is performed, the new
replacement text is not subject to further replacements. For example,
"$1,$2".REPLACE(/(\$(\D))/G, "$$1-$1$2") returns "$1-$11,$1-$22". A $ in
_newstring_ that does not match any of the forms below is left as is.

Table 24 — Replacement Text Symbol Substitutions

  ------------ --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  Characters   Replacement text
  $$           $
  $&           The matched substring.
  $‘           The portion of _string_ that precedes the matched substring.
  $’           The portion of _string_ that follows the matched substring.
  $N           The _n_^th^ capture, where _n_ is a single digit in the range 1 to 9 and $_n_ is not followed by a decimal digit. If _n_≤_m_ and the _n_th capture is UNDEFINED, use the empty String instead. If _n_>_m_, the result is implementation-defined.
  $NN          The _nn_^th^ capture, where _nn_ is a two-digit decimal number in the range 01 to 99. If _nn_≤_m_ and the _nn_^th^ capture is UNDEFINED, use the empty String instead. If _nn_>_m_, the result is implementation-defined.
  ------------ --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

NOTE The REPLACE function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

When the search method is called with argument _regexp_, the following
steps are taken:

NOTE The SEARCH function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

The SLICE method takes two arguments, _start_ and _end_, and returns a
substring of the result of converting this object to a String, starting
from character position _start_ and running to, but not including,
character position _end_ (or through the end of the String if _end_ is
UNDEFINED). If _start_ is negative, it is treated as
_sourceLength_+_start_ where _sourceLength_ is the length of the String.
If _end_ is negative, it is treated as _sourceLength_+_end_ where
_sourceLength_ is the length of the String. The result is a String
value, not a String object. The following steps are taken:

The LENGTH property of the SLICE method is 2.

NOTE The SLICE function is intentionally generic; it does not require
that its THIS value be a String object. Therefore it can be transferred
to other kinds of objects for use as a method.

Returns an Array object into which substrings of the result of
converting this object to a String have been stored. The substrings are
determined by searching from left to right for occurrences of
_separator_; these occurrences are not part of any substring in the
returned array, but serve to divide up the String value. The value of
_separator_ may be a String of any length or it may be a RegExp object
(i.e., an object with a [[NativeBrand]] internal property whose value is
NativeRegExp ; see 15.10).

The value of _separator_ may be an empty String, an empty regular
expression, or a regular expression that can match an empty String. In
this case, _separator_ does not match the empty substring at the
beginning or end of the input String, nor does it match the empty
substring at the end of the previous separator match. (For example, if
_separator_ is the empty String, the String is split up into individual
characters; the length of the result array equals the length of the
String, and each substring contains one character.) If _separator_ is a
regular expression, only the first match at a given position of the THIS
String is considered, even if backtracking could yield a
non-empty-substring match at that position. (For example,
"AB".SPLIT(/A*?/) evaluates to the array ["A","B"], while
"AB".SPLIT(/A*/) evaluates to the array["","B"].)

If the THIS object is (or converts to) the empty String, the result
depends on whether _separator_ can match the empty String. If it can,
the result array contains no elements. Otherwise, the result array
contains one element, which is the empty String.

If _separator_ is a regular expression that contains capturing
parentheses, then each time _separator_ is matched the results
(including any UNDEFINED results) of the capturing parentheses are
spliced into the output array. For example,

  "A<B>BOLD</B>AND<CODE>CODED</CODE>".SPLIT(/<(\/)?([^<>]+)>/)

evaluates to the array

  ["A", UNDEFINED, "B", "BOLD", "/", "B", "AND", UNDEFINED,
   "CODE", "CODED", "/", "CODE", ""]

If _separator_ is UNDEFINED, then the result array contains just one
String, which is the THIS value (converted to a String). If _limit_ is
not UNDEFINED, then the output array is truncated so that it contains no
more than _limit_ elements.

When the SPLIT method is called, the following steps are taken:

The abstract operation _SplitMatch_ takes three parameters, a String
_S_, an integer _q_, and a String or RegExp _R_, and performs the
following in order to return a MatchResult (see 15.10.2.1):

The LENGTH property of the SPLIT method is 2.

NOTE 1 The SPLIT method ignores the value of separator.GLOBAL for
separators that are RegExp objects.

NOTE 2 The SPLIT function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

The SUBSTRING method takes two arguments, _start_ and _end_, and returns
a substring of the result of converting this object to a String,
starting from character position _start_ and running to, but not
including, character position _end_ of the String (or through the end of
the String is _end_ is UNDEFINED). The result is a String value, not a
String object.

If either argument is NAN or negative, it is replaced with zero; if
either argument is larger than the length of the String, it is replaced
with the length of the String.

If _start_ is larger than _end_, they are swapped.

The following steps are taken:

The LENGTH property of the SUBSTRING method is 2.

NOTE The SUBSTRING function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

The following steps are taken:

For the purposes of this operation, the 16-bit code units of the Strings
are treated as code points in the Unicode Basic Multilingual Plane.
Surrogate code points are directly transferred from _S_ to _L_ without
any mapping.

The result must be derived according to the case mappings in the Unicode
character database (this explicitly includes not only the
UnicodeData.txt file, but also the SpecialCasings.txt file that
accompanies it in Unicode 2.1.8 and later).

NOTE 1 The case mapping of some characters may produce multiple
characters. In this case the result String may not be the same length as
the source String. Because both TOUPPERCASE and TOLOWERCASE have
context-sensitive behaviour, the functions are not symmetrical. In other
words, S.TOUPPERCASE().TOLOWERCASE() is not necessarily equal to
S.TOLOWERCASE().

NOTE 2 The TOLOWERCASE function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

This function works exactly the same as TOLOWERCASE except that its
result is intended to yield the correct result for the host
environment’s current locale, rather than a locale-independent result.
There will only be a difference in the few cases (such as Turkish) where
the rules for that language conflict with the regular Unicode case
mappings.

NOTE 1 The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that implementations
do not use this parameter position for anything else.

NOTE 2 The TOLOCALELOWERCASE function is intentionally generic; it does
not require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

This function behaves in exactly the same way as
STRING.PROTOTYPE.TOLOWERCASE, except that characters are mapped to their
_uppercase_ equivalents as specified in the Unicode Character Database.

NOTE The TOUPPERCASE function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

This function works exactly the same as TOUPPERCASE except that its
result is intended to yield the correct result for the host
environment’s current locale, rather than a locale-independent result.
There will only be a difference in the few cases (such as Turkish) where
the rules for that language conflict with the regular Unicode case
mappings.

NOTE 1 The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that implementations
do not use this parameter position for anything else.

NOTE 2 The TOLOCALEUPPERCASE function is intentionally generic; it does
not require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

The following steps are taken:

NOTE The TRIM function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

String instances inherit properties from the String prototype object and
have a [[NativeBrand]] internal property with value StringWrapper.
String instances also have a [[PrimitiveValue]] internal property, a
LENGTH property, and a set of enumerable properties with array index
names.

The [[PrimitiveValue]] internal property is the String value represented
by this String object. The array index named properties correspond to
the individual characters of the String value. A special
[[GetOwnProperty]] internal method is used to specify the number,
values, and attributes of the array index named properties.

The number of characters in the String value represented by this String
object.

Once a String object is created, this property is unchanging. It has the
attributes { [[Writable]]: FALSE, [[Enumerable]]: FALSE,
[[Configurable]]: FALSE }.

String objects use a variation of the [[GetOwnProperty]] internal method
used for other native ECMAScript objects (8.12.1). This special internal
method provides access to named properties corresponding to the
individual characters of String objects.

Assume _S_ is a String object and _P_ is a String.

When the [[GetOwnProperty]] internal method of _S_ is called with
property name _P_, the following steps are taken:

When BOOLEAN is called as a function rather than as a constructor, it
performs a type conversion.

Returns a Boolean value (not a Boolean object) computed by
ToBoolean(_value_).

When BOOLEAN is called as part of a NEW expression it is a constructor:
it initialises the newly created object.

The [[Prototype]] internal property of the newly constructed object is
set to the original Boolean prototype object, the one that is the
initial value of BOOLEAN.PROTOTYPE (15.6.3.1).

The newly constructed Boolean object has a [[NativeBrand]] internal
property with value BooleanWrapper.

The [[PrimitiveValue]] internal property of the newly constructed
Boolean object is set to ToBoolean(_value_).

The [[Extensible]] internal property of the newly constructed object is
set to TRUE.

The value of the [[Prototype]] internal property of the Boolean
constructor is the Function prototype object (15.3.4).

Besides the internal properties and the LENGTH property (whose value is
1), the Boolean constructor has the following property:

The initial value of BOOLEAN.PROTOTYPE is the Boolean prototype object
(15.6.4).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

The Boolean prototype object is itself a Boolean object whose value is
FALSE. The Boolean prototype object has a [[NativeBrand]] internal
property whose value is BooleanWrapper.

The value of the [[Prototype]] internal property of the Boolean
prototype object is the standard built-in Object prototype object
(15.2.4).

The initial value of BOOLEAN.PROTOTYPE.CONSTRUCTOR is the built-in
BOOLEAN constructor.

The following steps are taken:

The following steps are taken:

Boolean instances inherit properties from the Boolean prototype object
and have a [[NativeBrand]] internal property whose value is
BooleanWrapper. Boolean instances also have a [[PrimitiveValue]]
internal property.

The [[PrimitiveValue]] internal property is the Boolean value
represented by this Boolean object.

When NUMBER is called as a function rather than as a constructor, it
performs a type conversion.

Returns a Number value (not a Number object) computed by
ToNumber(_value_) if _value_ was supplied, else returns +0.

When NUMBER is called as part of a NEW expression it is a constructor:
it initialises the newly created object.

The [[Prototype]] internal property of the newly constructed object is
set to the original Number prototype object, the one that is the initial
value of NUMBER.PROTOTYPE (15.7.3.1).

The newly constructed object is has a [[NativeBrand]] internal property
whose value is NumberWrapper.

The [[PrimitiveValue]] internal property of the newly constructed object
is set to ToNumber(_value_) if _value_ was supplied, else to +0.

The [[Extensible]] internal property of the newly constructed object is
set to TRUE.

The value of the [[Prototype]] internal property of the Number
constructor is the Function prototype object (15.3.4).

Besides the internal properties and the LENGTH property (whose value is
1), the Number constructor has the following properties:

The initial value of NUMBER.PROTOTYPE is the Number prototype object
(15.7.4).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

The value of NUMBER.MAX_VALUE is the largest positive finite value of
the Number type, which is approximately 1.7976931348623157 × 10^308^.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

The value of NUMBER.MIN_VALUE is the smallest positive value of the
Number type, which is approximately 5 × 10^324^.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

The value of NUMBER.NAN is NAN.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

The value of Number.NEGATIVE_INFINITY is −∞.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

The value of Number.POSITIVE_INFINITY is +∞.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

The Number prototype object is itself a Number object with a
[[NativeBrand]] internal property whose value is NumberWrapper. Its
value is +0.

The value of the [[Prototype]] internal property of the Number prototype
object is the standard built-in Object prototype object (15.2.4).

Unless explicitly stated otherwise, the methods of the Number prototype
object defined below are not generic and the this value passed to them
must be either a Number value or an object that has a [[NativeBrand]]
internal property whose value is NumberWrapper.

In the following descriptions of functions that are properties of the
Number prototype object, the phrase “this Number object” refers to
either the object that is the THIS value for the invocation of the
function or, if Type(THIS value) is Number, an object that is created as
if by the expression NEW NUMBER(THIS value) where NUMBER is the standard
built-in constructor with that name. Also, the phrase “this Number
value” refers to either the Number value represented by this Number
object, that is, the value of the [[PrimitiveValue]] internal property
of this Number object or the THIS value if its type is Number. A
TYPEERROR exception is thrown if the THIS value is neither an object
that has a [[NativeBrand]] internal property whose value is
NumberWrapper or a value whose type is Number.

The initial value of NUMBER.PROTOTYPE.CONSTRUCTOR is the built-in NUMBER
constructor.

The optional _radix_ should be an integer value in the inclusive range 2
to 36. If _radix_ not present or is UNDEFINED the Number 10 is used as
the value of _radix_. If ToInteger(_radix_) is the Number 10 then this
Number value is given as an argument to the ToString abstract operation;
the resulting String value is returned.

If ToInteger(_radix_) is not an integer between 2 and 36 inclusive throw
a RANGEERROR exception. If ToInteger(_radix_) is an integer from 2 to
36, but not 10, the result is a String representation of this Number
value using the specified radix. Letters A-Z are used for digits with
values 10 through 35. The precise algorithm is implementation-dependent
if the radix is not 10, however the algorithm should be a generalisation
of that specified in 9.8.1.

The TOSTRING function is not generic; it throws a TYPEERROR exception if
its THIS value is not a Number or a Number object. Therefore, it cannot
be transferred to other kinds of objects for use as a method.

Produces a String value that represents this Number value formatted
according to the conventions of the host environment’s current locale.
This function is implementation-dependent, and it is permissible, but
not encouraged, for it to return the same thing as TOSTRING.

NOTE The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that implementations
do not use this parameter position for anything else.

Returns this Number value.

The VALUEOF function is not generic; it throws a TYPEERROR exception if
its THIS value is not a Number or a Number object. Therefore, it cannot
be transferred to other kinds of objects for use as a method.

Return a String containing this Number value represented in decimal
fixed-point notation with _fractionDigits_ digits after the decimal
point. If _fractionDigits_ is UNDEFINED, 0 is assumed. Specifically,
perform the following steps:

The LENGTH property of the TOFIXED method is 1.

If the TOFIXED method is called with more than one argument, then the
behaviour is undefined (see clause 15).

An implementation is permitted to extend the behaviour of TOFIXED for
values of _fractionDigits_ less than 0 or greater than 20. In this case
TOFIXED would not necessarily throw RANGEERROR for such values.

NOTE The output of TOFIXED may be more precise than TOSTRING for some
values because toString only prints enough significant digits to
distinguish the number from adjacent number values. For example,

(1000000000000000128).TOSTRING() returns "1000000000000000100",
while (1000000000000000128).TOFIXED(0) returns "1000000000000000128".

Return a String containing this Number value represented in decimal
exponential notation with one digit before the significand's decimal
point and _fractionDigits_ digits after the significand's decimal point.
If _fractionDigits_ is UNDEFINED, include as many significand digits as
necessary to uniquely specify the Number (just like in ToString except
that in this case the Number is always output in exponential notation).
Specifically, perform the following steps:

The LENGTH property of the TOEXPONENTIAL method is 1.

If the TOEXPONENTIAL method is called with more than one argument, then
the behaviour is undefined (see clause 15).

An implementation is permitted to extend the behaviour of TOEXPONENTIAL
for values of _fractionDigits_ less than 0 or greater than 20. In this
case TOEXPONENTIAL would not necessarily throw RANGEERROR for such
values.

NOTE For implementations that provide more accurate conversions than
required by the rules above, it is recommended that the following
alternative version of step 9.b.i be used as a guideline:

Return a String containing this Number value represented either in
decimal exponential notation with one digit before the significand's
decimal point and _precision_–1 digits after the significand's decimal
point or in decimal fixed notation with _precision_ significant digits.
If _precision_ is UNDEFINED, call ToString (9.8.1) instead.
Specifically, perform the following steps:

The LENGTH property of the TOPRECISION method is 1.

If the TOPRECISION method is called with more than one argument, then
the behaviour is undefined (see clause 15).

An implementation is permitted to extend the behaviour of TOPRECISION
for values of _precision_ less than 1 or greater than 21. In this case
TOPRECISION would not necessarily throw RANGEERROR for such values.

Number instances inherit properties from the Number prototype object and
have a [[NativeBrand]] internal property whose value is NumberWrapper.
Number instances also have a [[PrimitiveValue]] internal property.

The [[PrimitiveValue]] internal property is the Number value represented
by this Number object.

The Math object is a single object that has some named properties, some
of which are functions.

The value of the [[Prototype]] internal property of the Math object is
the standard built-in Object prototype object (15.2.4). The Math object
has a [[NativeBrand]] internal property whose value is NativeMath.

The Math object does not have a [[Construct]] internal property; it is
not possible to use the Math object as a constructor with the NEW
operator.

The Math object does not have a [[Call]] internal property; it is not
possible to invoke the Math object as a function.

NOTE In this specification, the phrase “the Number value for _x_” has a
technical meaning defined in 8.5.

The Number value for _e_, the base of the natural logarithms, which is
approximately 2.7182818284590452354.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

The Number value for the natural logarithm of 10, which is approximately
2.302585092994046.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

The Number value for the natural logarithm of 2, which is approximately
0.6931471805599453.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

The Number value for the base-2 logarithm of _e_, the base of the
natural logarithms; this value is approximately 1.4426950408889634.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

NOTE The value of MATH.LOG2E is approximately the reciprocal of the
value of MATH.LN2.

The Number value for the base-10 logarithm of _e_, the base of the
natural logarithms; this value is approximately 0.4342944819032518.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

NOTE The value of MATH.LOG10E is approximately the reciprocal of the
value of MATH.LN10.

The Number value for π, the ratio of the circumference of a circle to
its diameter, which is approximately 3.1415926535897932.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

The Number value for the square root of ½, which is approximately
0.7071067811865476.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

NOTE The value of MATH.SQRT1_2 is approximately the reciprocal of the
value of MATH.SQRT2.

The Number value for the square root of 2, which is approximately
1.4142135623730951.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Each of the following MATH object functions applies the ToNumber
abstract operator to each of its arguments (in left-to-right order if
there is more than one) and then performs a computation on the resulting
Number value(s).

In the function descriptions below, the symbols NaN, −0, +0, −∞ and +∞
refer to the Number values described in 8.5.

NOTE The behaviour of the functions ACOS, ASIN, ATAN, ATAN2, COS, EXP,
LOG, POW, SIN, SQRT, and TAN is not precisely specified here except to
require specific results for certain argument values that represent
boundary cases of interest. For other argument values, these functions
are intended to compute approximations to the results of familiar
mathematical functions, but some latitude is allowed in the choice of
approximation algorithms. The general intent is that an implementer
should be able to use the same mathematical library for ECMAScript on a
given hardware platform that is available to C programmers on that
platform.

Although the choice of algorithms is left to the implementation, it is
recommended (but not specified by this standard) that implementations
use the approximation algorithms for IEEE 754 arithmetic contained in
FDLIBM, the freely distributable mathematical library from Sun
Microsystems (http://www.netlib.org/fdlibm).

Returns the absolute value of _x_; the result has the same magnitude as
_x_ but has positive sign.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is −0, the result is +0.

-   If _x_ is −∞, the result is +∞.

Returns an implementation-dependent approximation to the arc cosine of
_x_. The result is expressed in radians and ranges from +0 to +π.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is greater than 1, the result is NaN.

-   If _x_ is less than −1, the result is NaN.

-   If _x_ is exactly 1, the result is +0.

Returns an implementation-dependent approximation to the arc sine of
_x_. The result is expressed in radians and ranges from −π/2 to +π/2.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is greater than 1, the result is NaN.

-   If _x_ is less than –1, the result is NaN.

-   If _x_ is +0, the result is +0.

-   If _x_ is −0, the result is −0.

Returns an implementation-dependent approximation to the arc tangent of
_x_. The result is expressed in radians and ranges from −π/2 to +π/2.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is +0, the result is +0.

-   If _x_ is −0, the result is −0.

-   If _x_ is +∞, the result is an implementation-dependent
      approximation to +π/2.

-   If _x_ is −∞, the result is an implementation-dependent
      approximation to −π/2.

Returns an implementation-dependent approximation to the arc tangent of
the quotient _y_/_x_ of the arguments _y_ and _x_, where the signs of
_y_ and _x_ are used to determine the quadrant of the result. Note that
it is intentional and traditional for the two-argument arc tangent
function that the argument named _y_ be first and the argument named _x_
be second. The result is expressed in radians and ranges from −π to +π.

-   If either _x_ or _y_ is NaN, the result is NaN.

-   If _y_>0 and _x_ is +0, the result is an implementation-dependent
      approximation to +π/2.

-   If _y_>0 and _x_ is −0, the result is an implementation-dependent
      approximation to +π/2.

-   If _y_ is +0 and _x_>0, the result is +0.

-   If _y_ is +0 and _x_ is +0, the result is +0.

-   If _y_ is +0 and _x_ is −0, the result is an
      implementation-dependent approximation to +π.

-   If _y_ is +0 and _x_<0, the result is an implementation-dependent
      approximation to +π.

-   If _y_ is −0 and _x_>0, the result is −0.

-   If _y_ is −0 and _x_ is +0, the result is −0.

-   If _y_ is −0 and _x_ is −0, the result is an
      implementation-dependent approximation to −π.

-   If _y_ is −0 and _x_<0, the result is an implementation-dependent
      approximation to −π.

-   If _y_<0 and _x_ is +0, the result is an implementation-dependent
      approximation to −π/2.

-   If _y_<0 and _x_ is −0, the result is an implementation-dependent
      approximation to −π/2.

-   If _y_>0 and _y_ is finite and _x_ is +∞, the result is +0.

-   If _y_>0 and _y_ is finite and _x_ is −∞, the result if an
      implementation-dependent approximation to +π.

-   If _y_<0 and _y_ is finite and _x_ is +∞, the result is −0.

-   If _y_<0 and _y_ is finite and _x_ is −∞, the result is an
      implementation-dependent approximation to −π.

-   If _y_ is +∞ and _x_ is finite, the result is an
      implementation-dependent approximation to +π/2.

-   If _y_ is −∞ and _x_ is finite, the result is an
      implementation-dependent approximation to −π/2.

-   If _y_ is +∞ and _x_ is +∞, the result is an
      implementation-dependent approximation to +π/4.

-   If _y_ is +∞ and _x_ is −∞, the result is an
      implementation-dependent approximation to +3π/4.

-   If _y_ is −∞ and _x_ is +∞, the result is an
      implementation-dependent approximation to −π/4.

-   If _y_ is −∞ and _x_ is −∞, the result is an
      implementation-dependent approximation to −3π/4.

Returns the smallest (closest to −∞) Number value that is not less than
_x_ and is equal to a mathematical integer. If _x_ is already an
integer, the result is _x_.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is +0, the result is +0.

-   If _x_ is −0, the result is −0.

-   If _x_ is +∞, the result is +∞.

-   If _x_ is −∞, the result is −∞.

-   If _x_ is less than 0 but greater than -1, the result is −0.

The value of MATH.CEIL(X) is the same as the value of -MATH.FLOOR(-X).

Returns an implementation-dependent approximation to the cosine of _x_.
The argument is expressed in radians.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is +0, the result is 1.

-   If _x_ is −0, the result is 1.

-   If _x_ is +∞, the result is NaN.

-   If _x_ is −∞, the result is NaN.

Returns an implementation-dependent approximation to the exponential
function of _x_ (_e_ raised to the power of _x_, where _e_ is the base
of the natural logarithms).

-   If _x_ is NaN, the result is NaN.

-   If _x_ is +0, the result is 1.

-   If _x_ is −0, the result is 1.

-   If _x_ is +∞, the result is +∞.

-   If _x_ is −∞, the result is +0.

Returns the greatest (closest to +∞) Number value that is not greater
than _x_ and is equal to a mathematical integer. If _x_ is already an
integer, the result is _x_.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is +0, the result is +0.

-   If _x_ is −0, the result is −0.

-   If _x_ is +∞, the result is +∞.

-   If _x_ is −∞, the result is −∞.

-   If _x_ is greater than 0 but less than 1, the result is +0.

NOTE The value of MATH.FLOOR(X) is the same as the value of
-MATH.CEIL(-X).

-   Returns an implementation-dependent approximation to the natural
      logarithm of _x_.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is less than 0, the result is NaN.

-   If _x_ is +0 or −0, the result is −∞.

-   If _x_ is 1, the result is +0.

-   If _x_ is +∞, the result is +∞.

Given zero or more arguments, calls ToNumber on each of the arguments
and returns the largest of the resulting values.

-   If no arguments are given, the result is −∞.

-   If any value is NaN, the result is NaN.

-   The comparison of values to determine the largest value is done as
      in 11.8.5 except that +0 is considered to be larger than −0.

The LENGTH property of the MAX method is 2.

Given zero or more arguments, calls ToNumber on each of the arguments
and returns the smallest of the resulting values.

-   If no arguments are given, the result is +∞.

-   If any value is NaN, the result is NaN.

-   The comparison of values to determine the smallest value is done as
      in 11.8.5 except that +0 is considered to be larger than −0.

The LENGTH property of the MIN method is 2.

Returns an implementation-dependent approximation to the result of
raising _x_ to the power _y_.

-   If _y_ is NaN, the result is NaN.

-   If _y_ is +0, the result is 1, even if _x_ is NaN.

-   If _y_ is −0, the result is 1, even if _x_ is NaN.

-   If _x_ is NaN and _y_ is nonzero, the result is NaN.

-   If abs(_x_)>1 and _y_ is +∞, the result is +∞.

-   If abs(_x_)>1 and _y_ is −∞, the result is +0.

-   If abs(_x_)==1 and _y_ is +∞, the result is NaN.

-   If abs(_x_)==1 and _y_ is −∞, the result is NaN.

-   If abs(_x_)<1 and _y_ is +∞, the result is +0.

-   If abs(_x_)<1 and _y_ is −∞, the result is +∞.

-   If _x_ is +∞ and _y_>0, the result is +∞.

-   If _x_ is +∞ and _y_<0, the result is +0.

-   If _x_ is −∞ and _y_>0 and _y_ is an odd integer, the result is −∞.

-   If _x_ is −∞ and _y_>0 and _y_ is not an odd integer, the result
      is +∞.

-   If _x_ is −∞ and _y_<0 and _y_ is an odd integer, the result is −0.

-   If _x_ is −∞ and _y_<0 and _y_ is not an odd integer, the result
      is +0.

-   If _x_ is +0 and _y_>0, the result is +0.

-   If _x_ is +0 and _y_<0, the result is +∞.

-   If _x_ is −0 and _y_>0 and _y_ is an odd integer, the result is −0.

-   If _x_ is −0 and _y_>0 and _y_ is not an odd integer, the result
      is +0.

-   If _x_ is −0 and _y_<0 and _y_ is an odd integer, the result is −∞.

-   If _x_ is −0 and _y_<0 and _y_ is not an odd integer, the result
      is +∞.

-   If _x_<0 and _x_ is finite and _y_ is finite and _y_ is not an
      integer, the result is NaN.

Returns a Number value with positive sign, greater than or equal to 0
but less than 1, chosen randomly or pseudo randomly with approximately
uniform distribution over that range, using an implementation-dependent
algorithm or strategy. This function takes no arguments.

Returns the Number value that is closest to _x_ and is equal to a
mathematical integer. If two integer Number values are equally close to
_x_, then the result is the Number value that is closer to +∞. If _x_ is
already an integer, the result is _x_.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is +0, the result is +0.

-   If _x_ is −0, the result is −0.

-   If _x_ is +∞, the result is +∞.

-   If _x_ is −∞, the result is −∞.

-   If _x_ is greater than 0 but less than 0.5, the result is +0.

-   If _x_ is less than 0 but greater than or equal to -0.5, the result
      is −0.

NOTE 1 MATH.ROUND(3.5) returns 4, but MATH.ROUND(–3.5) returns –3.

NOTE 2 The value of MATH.ROUND(X) is the same as the value of
MATH.FLOOR(X+0.5), except when X is −0 or is less than 0 but greater
than or equal to -0.5; for these cases MATH.ROUND(X) returns −0, but
MATH.FLOOR(X+0.5) returns +0.

Returns an implementation-dependent approximation to the sine of _x_.
The argument is expressed in radians.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is +0, the result is +0.

-   If _x_ is −0, the result is −0.

-   If _x_ is +∞ or −∞, the result is NaN.

Returns an implementation-dependent approximation to the square root of
_x_.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is less than 0, the result is NaN.

-   If _x_ is +0, the result is +0.

-   If _x_ is −0, the result is −0.

-   If _x_ is +∞, the result is +∞.

Returns an implementation-dependent approximation to the tangent of _x_.
The argument is expressed in radians.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is +0, the result is +0.

-   If _x_ is −0, the result is −0.

-   If _x_ is +∞ or −∞, the result is NaN.

The following functions are abstract operations that operate on time
values (defined in 15.9.1.1). Note that, in every case, if any argument
to one of these functions is NAN, the result will be NAN.

A Date object contains a Number indicating a particular instant in time
to within a millisecond. Such a Number is called a _time value_. A time
value may also be NAN, indicating that the Date object does not
represent a specific instant of time.

Time is measured in ECMAScript in milliseconds since 01 January, 1970
UTC. In time values leap seconds are ignored. It is assumed that there
are exactly 86,400,000 milliseconds per day. ECMAScript Number values
can represent all integers from –9,007,199,254,740,992 to
9,007,199,254,740,992; this range suffices to measure times to
millisecond precision for any instant that is within approximately
285,616 years, either forward or backward, from 01 January, 1970 UTC.

The actual range of times supported by ECMAScript Date objects is
slightly smaller: exactly –100,000,000 days to 100,000,000 days measured
relative to midnight at the beginning of 01 January, 1970 UTC. This
gives a range of 8,640,000,000,000,000 milliseconds to either side of 01
January, 1970 UTC.

The exact moment of midnight at the beginning of 01 January, 1970 UTC is
represented by the value +0.

A given time value _t_ belongs to day number

  Day(_t_) = floor(_t_ / msPerDay)

where the number of milliseconds per day is

  msPerDay = 86400000

The remainder is called the time within the day:

  TimeWithinDay(_t_) = _t_ modulo msPerDay

ECMAScript uses an extrapolated Gregorian system to map a day number to
a year number and to determine the month and date within that year. In
this system, leap years are precisely those which are (divisible by 4)
and ((not divisible by 100) or (divisible by 400)). The number of days
in year number _y_ is therefore defined by

  DaysInYear(_y_) = 365 if (_y_ modulo 4) ≠ 0
  = 366 if (_y_ modulo 4) = 0 and (y modulo 100) ≠ 0
  = 365 if (_y_ modulo 100) = 0 and (y modulo 400) ≠ 0
  = 366 if (_y_ modulo 400) = 0

All non-leap years have 365 days with the usual number of days per month
and leap years have an extra day in February. The day number of the
first day of year _y_ is given by:

  DayFromYear(_y_) = 365 × (_y_−1970) + floor((_y_−1969)/4) −
  floor((_y_−1901)/100) + floor((_y_−1601)/400)

The time value of the start of a year is:

  TimeFromYear(_y_) = msPerDay × DayFromYear(_y_)

A time value determines a year by:

  YearFromTime(_t_) = the largest integer _y_ (closest to positive
  infinity) such that TimeFromYear(_y_) ≤ _t_

The leap-year function is 1 for a time within a leap year and otherwise
is zero:

  InLeapYear(_t_) = 0 if DaysInYear(YearFromTime(_t_)) = 365
  = 1 if DaysInYear(YearFromTime_(t_)) = 366

Months are identified by an integer in the range 0 to 11, inclusive. The
mapping MonthFromTime(_t_) from a time value _t_ to a month number is
defined by:

  MonthFromTime(_t_) = 0 if 0 ≤ DayWithinYear(_t_) < 31
   = 1 if 31 ≤ DayWithinYear (_t_) < 59+InLeapYear(_t_)
   = 2 if 59+InLeapYear(_t_) ≤ DayWithinYear (_t_) < 90+InLeapYear(_t_)
   = 3 if 90+InLeapYear(_t_) ≤ DayWithinYear (_t_) < 120+InLeapYear(_t_)
   = 4 if 120+InLeapYear(_t_) ≤ DayWithinYear (_t_) <
  151+InLeapYear(_t_)
   = 5 if 151+InLeapYear(_t_) ≤ DayWithinYear (_t_) <
  181+InLeapYear(_t_)
   = 6 if 181+InLeapYear(_t_) ≤ DayWithinYear (_t_) <
  212+InLeapYear(_t_)
   = 7 if 212+InLeapYear(_t_) ≤ DayWithinYear (_t_) <
  243+InLeapYear(_t_)
   = 8 if 243+InLeapYear(_t_) ≤ DayWithinYear (_t_) <
  273+InLeapYear(_t_)
   = 9 if 273+InLeapYear(_t_) ≤ DayWithinYear (_t_) <
  304+InLeapYear(_t_)
   = 10 if 304+InLeapYear(_t_) ≤ DayWithinYear (_t_) <
  334+InLeapYear(_t_)
   = 11 if 334+InLeapYear(_t_) ≤ DayWithinYear (_t_) <
  365+InLeapYear(_t_)

where

  DayWithinYear(_t_) = Day(_t_)−DayFromYear(YearFromTime(_t)_)

A month value of 0 specifies January; 1 specifies February; 2 specifies
March; 3 specifies April; 4 specifies May; 5 specifies June; 6 specifies
July; 7 specifies August; 8 specifies September; 9 specifies October; 10
specifies November; and 11 specifies December. Note that
MonthFromTime(0) = 0, corresponding to Thursday, 01 January, 1970.

A date number is identified by an integer in the range 1 through 31,
inclusive. The mapping DateFromTime(_t_) from a time value _t_ to a
month number is defined by:

  DateFromTime(_t_) = DayWithinYear(_t_)+1 if MonthFromTime(_t_)=0
   = DayWithinYear(_t_)−30 if MonthFromTime(_t_)=1
   = DayWithinYear(_t_)−58−InLeapYear(_t_) if MonthFromTime(_t_)=2
   = DayWithinYear(_t_)−89−InLeapYear(_t_) if MonthFromTime(_t_)=3
   = DayWithinYear(_t_)−119−InLeapYear(_t_) if MonthFromTime(_t_)=4
   = DayWithinYear(_t_)−150−InLeapYear(_t_) if MonthFromTime(_t_)=5
   = DayWithinYear(_t_)−180−InLeapYear(_t_) if MonthFromTime(_t_)=6
   = DayWithinYear(_t_)−211−InLeapYear(_t_) if MonthFromTime(_t_)=7
   = DayWithinYear(_t_)−242−InLeapYear(_t_) if MonthFromTime(_t_)=8
   = DayWithinYear(_t_)−272−InLeapYear(_t_) if MonthFromTime(_t_)=9
   = DayWithinYear(_t_)−303−InLeapYear(_t_) if MonthFromTime(_t_)=10
   = DayWithinYear(_t_)−333−InLeapYear(_t_) if MonthFromTime(_t_)=11

The weekday for a particular time value _t_ is defined as

  WeekDay(_t_) = (Day(_t_) + 4) modulo 7

A weekday value of 0 specifies Sunday; 1 specifies Monday; 2 specifies
Tuesday; 3 specifies Wednesday; 4 specifies Thursday; 5 specifies
Friday; and 6 specifies Saturday. Note that WeekDay(0) = 4,
corresponding to Thursday, 01 January, 1970.

An implementation of ECMAScript is expected to determine the local time
zone adjustment. The local time zone adjustment is a value LocalTZA
measured in milliseconds which when added to UTC represents the local
_standard_ time. Daylight saving time is _not_ reflected by LocalTZA.
The value LocalTZA does not vary with time but depends only on the
geographic location.

An implementation of ECMAScript is expected to determine the daylight
saving time algorithm. The algorithm to determine the daylight saving
time adjustment DaylightSavingTA(_t_), measured in milliseconds, must
depend only on four things:

(1) the time since the beginning of the year

  _t_ – TimeFromYear(YearFromTime(_t_))

(2) whether _t_ is in a leap year

  InLeapYear(_t_)

(3) the week day of the beginning of the year

  WeekDay(TimeFromYear(YearFromTime(_t_)))

and (4) the geographic location.

The implementation of ECMAScript should not try to determine whether the
exact time was subject to daylight saving time, but just whether
daylight saving time would have been in effect if the current daylight
saving time algorithm had been used at the time. This avoids
complications such as taking into account the years that the locale
observed daylight saving time year round.

If the host environment provides functionality for determining daylight
saving time, the implementation of ECMAScript is free to map the year in
question to an equivalent year (same leap-year-ness and same starting
week day for the year) for which the host environment provides daylight
saving time information. The only restriction is that all equivalent
years should produce the same result.

Conversion from UTC to local time is defined by

  LocalTime(_t_) = _t_ + LocalTZA + DaylightSavingTA(_t_)

Conversion from local time to UTC is defined by

  UTC(_t_) = _t_ – LocalTZA – DaylightSavingTA(_t_ – LocalTZA)

Note that UTC(LocalTime(_t_)) is not necessarily always equal to _t_.

The following functions are useful in decomposing time values:

  HourFromTime(_t_) = floor(_t_ / msPerHour) modulo HoursPerDay

  MinFromTime(_t_) = floor(_t_ / msPerMinute) modulo MinutesPerHour

  SecFromTime(_t_) = floor(_t_ / msPerSecond) modulo SecondsPerMinute

  msFromTime(_t_) = t modulo msPerSecond

where

  HoursPerDay = 24

  MinutesPerHour = 60

  SecondsPerMinute = 60

  msPerSecond = 1000

  msPerMinute = 60000 = msPerSecond × SecondsPerMinute

  msPerHour = 3600000 = msPerMinute × MinutesPerHour

The operator MakeTime calculates a number of milliseconds from its four
arguments, which must be ECMAScript Number values. This operator
functions as follows:

The operator MakeDay calculates a number of days from its three
arguments, which must be ECMAScript Number values. This operator
functions as follows:

The operator MakeDate calculates a number of milliseconds from its two
arguments, which must be ECMAScript Number values. This operator
functions as follows:

The operator TimeClip calculates a number of milliseconds from its
argument, which must be an ECMAScript Number value. This operator
functions as follows:

NOTE The point of step 3 is that an implementation is permitted a choice
of internal representations of time values, for example as a 64-bit
signed integer or as a 64-bit floating-point value. Depending on the
implementation, this internal representation may or may not distinguish
−0 and +0.

ECMAScript defines a string interchange format for date-times based upon
a simplification of the ISO 8601 Extended Format. The format is as
follows: YYYY-MM-DDTHH:MM:SS.SSS_Z_

Where the fields are as follows:

This format includes date-only forms:

YYYY
YYYY-MM
YYYY-MM-DD

It also includes “date-time” forms that consist of one of the above
date-only forms immediately followed by one of the following time forms
with an optional time zone offset appended:

THH:MM
THH:MM:SS
THH:MM:SS.SSS

All numbers must be base 10. If the MM or DD fields are absent “01” is
used as the value. If the HH, MM, or SS fields are absent “00” is used
as the value and the value of an absent SSS field is “000”. If the time
zone offset is absent, the date-time is in interpreted as a local time.

Illegal values (out-of-bounds as well as syntax errors) in a format
string means that the format string is not a valid instance of this
format.

NOTE 1 As every day both starts and ends with midnight, the two
notations 00:00 and 24:00 are available to distinguish the two midnights
that can be associated with one date. This means that the following two
notations refer to exactly the same point in time: 1995-02-04T24:00 and
1995-02-05T00:

NOTE 2 There exists no international standard that specifies
abbreviations for civil time zones like CET, EST, etc. and sometimes the
same abbreviation is even used for two very different time zones. For
this reason, ISO 8601 and this format specifies numeric representations
of date and time.

ECMAScript requires the ability to specify 6 digit years (extended
years); approximately 285,426 years, either forward or backward, from 01
January, 1970 UTC. To represent years before 0 or after 9999, ISO 8601
permits the expansion of the year representation, but only by prior
agreement between the sender and the receiver. In the simplified
ECMAScript format such an expanded year representation shall have 2
extra year digits and is always prefixed with a + or – sign. The year 0
is considered positive and hence prefixed with a + sign.

NOTE Examples of extended years:

  -283457-03-21T15:00:59.008Z   283458 B.C.
  -000001-01-01T00:00:00Z          2 B.C.
  +000000-01-01T00:00:00Z         1 B.C.
  +000001-01-01T00:00:00Z         1 A.D.
  +001970-01-01T00:00:00Z         1970 A.D.
  +002009-12-15T00:00:00Z         2009 A.D.
  +287396-10-12T08:59:00.992Z 287396 A.D.

When DATE is called as a function rather than as a constructor, it
returns a String representing the current time (UTC).

NOTE The function call DATE(…) is not equivalent to the object creation
expression NEW DATE(…) with the same arguments.

All of the arguments are optional; any arguments supplied are accepted
but are completely ignored. A String is created and returned as if by
the expression (NEW DATE()).TOSTRING() where DATE is the standard
built-in constructor with that name and TOSTRING is the standard
built-in method DATE.PROTOTYPE.TOSTRING.

When DATE is called as part of a NEW expression, it is a constructor: it
initialises the newly created object.

When DATE is called with two to seven arguments, it computes the date
from _year_, _month_, and (optionally) _date_, _hours_, _minutes_,
_seconds_ and _ms_.

The [[Prototype]] internal property of the newly constructed object is
set to the original Date prototype object, the one that is the initial
value of DATE.PROTOTYPE (15.9.4.1).

The newly constructed object has a [[NativeBrand]] internal property
whose value is NativeDate.

The [[Extensible]] internal property of the newly constructed object is
set to TRUE.

The [[PrimitiveValue]] internal property of the newly constructed object
is set as follows:

The [[Prototype]] internal property of the newly constructed object is
set to the original Date prototype object, the one that is the initial
value of DATE.PROTOTYPE (15.9.4.1).

The newly constructed object has a [[NativeBrand]] internal property
whose value is NativeDate.

The [[Extensible]] internal property of the newly constructed object is
set to TRUE.

The [[PrimitiveValue]] internal property of the newly constructed object
is set as follows:

The [[Prototype]] internal property of the newly constructed object is
set to the original Date prototype object, the one that is the initial
value of DATE.PROTOTYPE (15.9.4.1).

The newly constructed object has a [[NativeBrand]] internal property
whose value is NativeDate.

The [[Extensible]] internal property of the newly constructed object is
set to TRUE.

The [[PrimitiveValue]] internal property of the newly constructed object
is set to the time value (UTC) identifying the current time.

The value of the [[Prototype]] internal property of the Date constructor
is the Function prototype object (15.3.4).

Besides the internal properties and the LENGTH property (whose value is
7), the Date constructor has the following properties:

The initial value of DATE.PROTOTYPE is the built-in Date prototype
object (15.9.5).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

The PARSE function applies the ToString operator to its argument and
interprets the resulting String as a date and time; it returns a Number,
the UTC time value corresponding to the date and time. The String may be
interpreted as a local time, a UTC time, or a time in some other time
zone, depending on the contents of the String. The function first
attempts to parse the format of the String according to the rules called
out in Date Time String Format (15.9.1.15). If the String does not
conform to that format the function may fall back to any
implementation-specific heuristics or implementation-specific date
formats. Unrecognisable Strings or dates containing illegal element
values in the format String shall cause DATE.PARSE to return NAN.

If _x_ is any Date object whose milliseconds amount is zero within a
particular implementation of ECMAScript, then all of the following
expressions should produce the same numeric value in that
implementation, if all the properties referenced have their initial
values:

  _X_.VALUEOF()

  DATE.PARSE(_X_.TOSTRING())

  DATE.PARSE(_X_.TOUTCSTRING())

  DATE.PARSE(_X_.TOISOSTRING())

However, the expression

  DATE.PARSE(_x_.TOLOCALESTRING())

is not required to produce the same Number value as the preceding three
expressions and, in general, the value produced by DATE.PARSE is
implementation-dependent when given any String value that does not
conform to the Date Time String Format (15.9.1.15) and that could not be
produced in that implementation by the TOSTRING or TOUTCSTRING method.

When the UTC function is called with fewer than two arguments, the
behaviour is implementation-dependent. When the UTC function is called
with two to seven arguments, it computes the date from _year_, _month_
and (optionally) _date_, _hours_, _minutes_, _seconds_ and _ms_. The
following steps are taken:

The LENGTH property of the UTC function is 7.

NOTE The UTC function differs from the Date constructor in two ways: it
returns a time value as a Number, rather than creating a Date object,
and it interprets the arguments in UTC rather than as local time.

The NOW function return a Number value that is the time value
designating the UTC date and time of the occurrence of the call to NOW.

The Date prototype object is itself a Date object and has a
[[NativeBrand]] internal property whose value is NativeDate. Its
[[PrimitiveValue]] is NAN.

The value of the [[Prototype]] internal property of the Date prototype
object is the standard built-in Object prototype object (15.2.4).

In following descriptions of functions that are properties of the Date
prototype object, the phrase “this Date object” refers to the object
that is the THIS value for the invocation of the function. Unless
explicitly noted otherwise, none of these functions are generic; a
TYPEERROR exception is thrown if the THIS value is not an object with a
[[NativeBrand]] internal property whose value is NativeDate. Also, the
phrase “this time value” refers to the Number value for the time
represented by this Date object, that is, the value of the
[[PrimitiveValue]] internal property of this Date object.

The initial value of DATE.PROTOTYPE.CONSTRUCTOR is the built-in DATE
constructor.

This function returns a String value. The contents of the String are
implementation-dependent, but are intended to represent the Date in the
current time zone in a convenient, human-readable form.

NOTE For any Date value _d_ whose milliseconds amount is zero, the
result of Date.parse(_d_.toString()) is equal to _d_.valueOf(). See
15.9.4.2.

This function returns a String value. The contents of the String are
implementation-dependent, but are intended to represent the “date”
portion of the Date in the current time zone in a convenient,
human-readable form.

This function returns a String value. The contents of the String are
implementation-dependent, but are intended to represent the “time”
portion of the Date in the current time zone in a convenient,
human-readable form.

This function returns a String value. The contents of the String are
implementation-dependent, but are intended to represent the Date in the
current time zone in a convenient, human-readable form that corresponds
to the conventions of the host environment’s current locale.

NOTE The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that implementations
do not use this parameter position for anything else.

This function returns a String value. The contents of the String are
implementation-dependent, but are intended to represent the “date”
portion of the Date in the current time zone in a convenient,
human-readable form that corresponds to the conventions of the host
environment’s current locale.

NOTE The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that implementations
do not use this parameter position for anything else.

This function returns a String value. The contents of the String are
implementation-dependent, but are intended to represent the “time”
portion of the Date in the current time zone in a convenient,
human-readable form that corresponds to the conventions of the host
environment’s current locale.

NOTE The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that implementations
do not use this parameter position for anything else.

The VALUEOF function returns a Number, which is this time value.

Returns the difference between local time and UTC time in minutes.

If _ms_ is not specified, this behaves as if _ms_ were specified with
the value GETMILLISECONDS().

The LENGTH property of the SETSECONDS method is 2.

If _ms_ is not specified, this behaves as if _ms_ were specified with
the value GETUTCMILLISECONDS().

The LENGTH property of the SETUTCSECONDS method is 2.

If _sec_ is not specified, this behaves as if _sec_ were specified with
the value GETSECONDS().

If _ms_ is not specified, this behaves as if _ms_ were specified with
the value GETMILLISECONDS().

The LENGTH property of the SETMINUTES method is 3.

If _sec_ is not specified, this behaves as if _sec_ were specified with
the value GETUTCSECONDS().

If _ms_ is not specified, this function behaves as if _ms_ were
specified with the value return by GETUTCMILLISECONDS().

The LENGTH property of the SETUTCMINUTES method is 3.

If _min_ is not specified, this behaves as if _min_ were specified with
the value GETMINUTES().

If _sec_ is not specified, this behaves as if _sec_ were specified with
the value GETSECONDS().

If _ms_ is not specified, this behaves as if _ms_ were specified with
the value GETMILLISECONDS().

The LENGTH property of the SETHOURS method is 4.

If _min_ is not specified, this behaves as if _min_ were specified with
the value GETUTCMINUTES().

If _sec_ is not specified, this behaves as if _sec_ were specified with
the value GETUTCSECONDS().

If _ms_ is not specified, this behaves as if _ms_ were specified with
the value GETUTCMILLISECONDS().

The LENGTH property of the SETUTCHOURS method is 4.

If _date_ is not specified, this behaves as if _date_ were specified
with the value GETDATE().

The LENGTH property of the SETMONTH method is 2.

If _date_ is not specified, this behaves as if _date_ were specified
with the value GETUTCDATE().

The LENGTH property of the SETUTCMONTH method is 2.

If _month_ is not specified, this behaves as if _month_ were specified
with the value GETMONTH().

If _date_ is not specified, this behaves as if _date_ were specified
with the value GETDATE().

The LENGTH property of the SETFULLYEAR method is 3.

If _month_ is not specified, this behaves as if _month_ were specified
with the value GETUTCMONTH().

If _date_ is not specified, this behaves as if _date_ were specified
with the value GETUTCDATE().

The LENGTH property of the SETUTCFULLYEAR method is 3.

This function returns a String value. The contents of the String are
implementation-dependent, but are intended to represent the Date in a
convenient, human-readable form in UTC.

NOTE The intent is to produce a String representation of a date that is
more readable than the format specified in 15.9.1.15. It is not
essential that the chosen format be unambiguous or easily machine
parsable. If an implementation does not have a preferred human-readable
format it is recommended to use the format defined in 15.9.1.15 but with
a space rather than a “T” used to separate the date and time elements.

This function returns a String value represent the instance in time
represented by this Date object. The format of the String is the Date
Time string format defined in 15.9.1.15. All fields are present in the
String. The time zone is always UTC, denoted by the suffix Z. If the
time value of this object is not a finite Number a RANGEERROR exception
is thrown.

This function provides a String representation of a Date object for use
by JSON.STRINGIFY (15.12.3).

When the TOJSON method is called with argument _key_, the following
steps are taken:

NOTE 1 The argument is ignored.

NOTE 2 The TOJSON function is intentionally generic; it does not require
that its THIS value be a Date object. Therefore, it can be transferred
to other kinds of objects for use as a method. However, it does require
that any such object have a TOISOSTRING method. An object is free to use
the argument _key_ to filter its stringification.

Date instances inherit properties from the Date prototype object and
have a [[NativeBrand]] internal whose value is NativeDate. Date
instances also have a [[PrimitiveValue]] internal property.

The [[PrimitiveValue]] internal property is time value represented by
this Date object.

A RegExp object contains a regular expression and the associated flags.

NOTE The form and functionality of regular expressions is modelled after
the regular expression facility in the Perl 5 programming language.

The REGEXP constructor applies the following grammar to the input
pattern String. An error occurs if the grammar cannot interpret the
String as an expansion of _Pattern_.

Syntax

Pattern ::

Disjunction

Disjunction ::

Alternative
 Alternative | Disjunction

Alternative ::

[empty]
Alternative Term

Term ::

Assertion
Atom
Atom Quantifier

Assertion ::

^
$
\ B
\ B
( ? = Disjunction )
( ? ! Disjunction )

Quantifier ::

QuantifierPrefix
QuantifierPrefix ?

QuantifierPrefix ::

*
+
?
{ DecimalDigits }
{ DecimalDigits , }
{ DecimalDigits , DecimalDigits }

Atom ::

PatternCharacter
.
\ AtomEscape
CharacterClass
( Disjunction )
( ? : Disjunction )

PatternCharacter ::

SourceCharacter BUT NOT ONE OF
 ^ $ \ . * + ? ( ) [ ] { } |

AtomEscape ::

DecimalEscape
CharacterEscape
CharacterClassEscape

CharacterEscape ::

ControlEscape
C ControlLetter
HexEscapeSequence
UnicodeEscapeSequence
IdentityEscape

ControlEscape :: ONE OF

F N R T V

ControlLetter :: ONE OF

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

IdentityEscape ::

SourceCharacter BUT NOT IdentifierPart
<ZWJ>
<ZWNJ>

DecimalEscape ::

DecimalIntegerLiteral [lookahead ∉ DecimalDigit]

CharacterClassEscape :: ONE OF

D D S S W W

CharacterClass ::

[ [lookahead ∉ {^}] ClassRanges ]
[ ^ ClassRanges ]

ClassRanges ::

[empty]
NonemptyClassRanges

NonemptyClassRanges ::

ClassAtom
ClassAtom NonemptyClassRangesNoDash
ClassAtom - ClassAtom ClassRanges

NonemptyClassRangesNoDash ::

ClassAtom
ClassAtomNoDash NonemptyClassRangesNoDash
ClassAtomNoDash - ClassAtom ClassRanges

ClassAtom ::

-
ClassAtomNoDash

ClassAtomNoDash ::

SourceCharacter BUT NOT ONE OF \ OR ] OR -
\ ClassEscape

ClassEscape ::

DecimalEscape
B
CharacterEscape
CharacterClassEscape

A regular expression pattern is converted into an internal procedure
using the process described below. An implementation is encouraged to
use more efficient algorithms than the ones listed below, as long as the
results are the same. The internal procedure is used as the value of a
RegExp object’s [[Match]] internal property.

The descriptions below use the following variables:

-   _Input_ is the String being matched by the regular expression
      pattern. The notation _input_[_n_] means the _n^th^_ character of
      _input_, where _n_ can range between 0 (inclusive) and
      _InputLength_ (exclusive).

-   _InputLength_ is the number of characters in the _Input_ String.

-   _NcapturingParens_ is the total number of left capturing parentheses
      (i.e. the total number of times the _Atom_ :: ( _Disjunction_ )
      production is expanded) in the pattern. A left capturing
      parenthesis is any ( pattern character that is matched by the (
      terminal of the _Atom_ :: ( _Disjunction_ ) production.

-   _IgnoreCase_ is the setting of the RegExp object's IGNORECASE
      property.

-   _Multiline_ is the setting of the RegExp object’s MULTILINE
      property.

Furthermore, the descriptions below use the following internal data
structures:

-   A _CharSet_ is a mathematical set of characters.

-   A _State_ is an ordered pair (_endIndex_, _captures_) where
      _endIndex_ is an integer and _captures_ is an internal array of
      _NcapturingParens_ values. _States_ are used to represent partial
      match states in the regular expression matching algorithms. The
      _endIndex_ is one plus the index of the last input character
      matched so far by the pattern, while _captures_ holds the results
      of capturing parentheses. The _n^th^_ element of _captures_ is
      either a String that represents the value obtained by the _n^th^_
      set of capturing parentheses or UNDEFINED if the _n^th^_ set of
      capturing parentheses hasn’t been reached yet. Due to
      backtracking, many _States_ may be in use at any time during the
      matching process.

-   A _MatchResult_ is either a _State_ or the special token FAILURE
      that indicates that the match failed.

-   A _Continuation_ procedure is an internal closure (i.e. an internal
      procedure with some arguments already bound to values) that takes
      one _State_ argument and returns a _MatchResult_ result. If an
      internal closure references variables bound in the function that
      creates the closure, the closure uses the values that these
      variables had at the time the closure was created. The
      _Continuation_ attempts to match the remaining portion (specified
      by the closure's already-bound arguments) of the pattern against
      the input String, starting at the intermediate state given by its
      _State_ argument. If the match succeeds, the _Continuation_
      returns the final _State_ that it reached; if the match fails, the
      _Continuation_ returns FAILURE.

-   A _Matcher_ procedure is an internal closure that takes two
      arguments -- a _State_ and a _Continuation_ -- and returns a
      _MatchResult_ result. A _Matcher_ attempts to match a middle
      subpattern (specified by the closure's already-bound arguments) of
      the pattern against the input String, starting at the intermediate
      state given by its _State_ argument. The _Continuation_ argument
      should be a closure that matches the rest of the pattern. After
      matching the subpattern of a pattern to obtain a new _State_, the
      _Matcher_ then calls _Continuation_ on that new _State_ to test if
      the rest of the pattern can match as well. If it can, the
      _Matcher_ returns the _State_ returned by _Continuation_; if not,
      the _Matcher_ may try different choices at its choice points,
      repeatedly calling _Continuation_ until it either succeeds or all
      possibilities have been exhausted.

-   An _AssertionTester_ procedure is an internal closure that takes a
      _State_ argument and returns a Boolean result. The assertion
      tester tests a specific condition (specified by the closure's
      already-bound arguments) against the current place in the input
      String and returns TRUE if the condition matched or FALSE if not.

-   An _EscapeValue_ is either a character or an integer. An
      _EscapeValue_ is used to denote the interpretation of a
      _DecimalEscape_ escape sequence: a character _ch_ means that the
      escape sequence is interpreted as the character _ch_, while an
      integer _n_ means that the escape sequence is interpreted as a
      backreference to the _n_^th^ set of capturing parentheses.

The production _Pattern_ :: _Disjunction_ evaluates as follows:

1.  Let _Input_ be the given String _str_. This variable will be used
      throughout the algorithms in 15.10.2.

2.  Let _InputLength_ be the length of _Input_. This variable will be
      used throughout the algorithms in 15.10.2.

3.  Let _c_ be a Continuation that always returns its State argument as
      a successful MatchResult.

4.  Let _cap_ be an internal array of _NcapturingParens_ UNDEFINED
      values, indexed 1 through _NcapturingParens_.

5.  Let _x_ be the State (_index_, _cap_).

6.  Call _m_(_x_, _c_) and return its result.

NOTE A Pattern evaluates ("compiles") to an internal procedure value.
REGEXP.PROTOTYPE.EXEC can then apply this procedure to a String and an
offset within the String to determine whether the pattern would match
starting at exactly that offset within the String, and, if it does
match, what the values of the capturing parentheses would be. The
algorithms in 15.10.2 are designed so that compiling a pattern may throw
a SYNTAXERROR exception; on the other hand, once the pattern is
successfully compiled, applying its result internal procedure to find a
match in a String cannot throw an exception (except for any host-defined
exceptions that can occur anywhere such as out-of-memory).

The production _Disjunction_ :: _Alternative_ evaluates by evaluating
_Alternative_ to obtain a _Matcher_ and returning that _Matcher_.

The production _Disjunction_ :: _Alternative_ | _Disjunction_ evaluates
as follows:

NOTE The | regular expression operator separates two alternatives. The
pattern first tries to match the left _Alternative_ (followed by the
sequel of the regular expression); if it fails, it tries to match the
right _Disjunction_ (followed by the sequel of the regular expression).
If the left _Alternative_, the right _Disjunction_, and the sequel all
have choice points, all choices in the sequel are tried before moving on
to the next choice in the left _Alternative_. If choices in the left
_Alternative_ are exhausted, the right _Disjunction_ is tried instead of
the left _Alternative_. Any capturing parentheses inside a portion of
the pattern skipped by | produce UNDEFINED values instead of Strings.
Thus, for example,

  /a|ab/.exec("abc")

returns the result "A" and not "AB". Moreover,

  /((a)|(ab))((c)|(bc))/.exec("abc")

returns the array

  ["abc", "a", "a", undefined, "bc", undefined, "bc"]

and not

  ["abc", "ab", undefined, "ab", "c", "c", undefined]

The production _Alternative_ :: [empty] evaluates by returning a Matcher
that takes two arguments, a State _x_ and a Continuation _c_, and
returns the result of calling _c_(_x_).

The production _Alternative_ :: _Alternative_ _Term_ evaluates as
follows:

NOTE Consecutive _Terms_ try to simultaneously match consecutive
portions of the input String. If the left _Alternative_, the right
_Term_, and the sequel of the regular expression all have choice points,
all choices in the sequel are tried before moving on to the next choice
in the right _Term_, and all choices in the right _Term_ are tried
before moving on to the next choice in the left _Alternative_.

The production _Term_ :: _Assertion_ evaluates by returning an internal
Matcher closure that takes two arguments, a State _x_ and a Continuation
_c_, and performs the following:

The production _Term_ :: _Atom_ evaluates by evaluating _Atom_ to obtain
a Matcher and returning that Matcher.

The production _Term_ :: _Atom_ _Quantifier_ evaluates as follows:

The abstract operation _RepeatMatcher_ takes eight parameters, a Matcher
_m_, an integer _min_, an integer (or ∞) _max_, a Boolean _greedy_, a
State _x_, a Continuation _c_, an integer _parenIndex_, and an integer
_parenCount_, and performs the following:

NOTE 1 An _Atom_ followed by a _Quantifier_ is repeated the number of
times specified by the _Quantifier_. A _Quantifier_ can be non-greedy,
in which case the _Atom_ pattern is repeated as few times as possible
while still matching the sequel, or it can be greedy, in which case the
_Atom_ pattern is repeated as many times as possible while still
matching the sequel. The _Atom_ pattern is repeated rather than the
input String that it matches, so different repetitions of the _Atom_ can
match different input substrings.

NOTE 2 If the _Atom_ and the sequel of the regular expression all have
choice points, the _Atom_ is first matched as many (or as few, if
non-greedy) times as possible. All choices in the sequel are tried
before moving on to the next choice in the last repetition of _Atom_.
All choices in the last (n^th^) repetition of _Atom_ are tried before
moving on to the next choice in the next-to-last (n–1)^st^ repetition of
_Atom_; at which point it may turn out that more or fewer repetitions of
_Atom_ are now possible; these are exhausted (again, starting with
either as few or as many as possible) before moving on to the next
choice in the (n-1)^st^ repetition of _Atom_ and so on.

Compare

  /a[a-z]{2,4}/.exec("abcdefghi")

which returns "ABCDE" with

  /a[a-z]{2,4}?/.exec("abcdefghi")

which returns "ABC".

Consider also

  /(aa|aabaac|ba|b|c)*/.exec("aabaac")

which, by the choice point ordering above, returns the array

  ["aaba", "ba"]

and not any of:

  ["aabaac", "aabaac"]

  ["aabaac", "c"]

The above ordering of choice points can be used to write a regular
expression that calculates the greatest common divisor of two numbers
(represented in unary notation). The following example calculates the
gcd of 10 and 15:

  "aaaaaaaaaa,aaaaaaaaaaaaaaa".replace(/^(a+)\1*,\1+$/,"$1")

which returns the gcd in unary notation "AAAAA".

NOTE 3 Step 4 of the RepeatMatcher clears _Atom's_ captures each time
_Atom_ is repeated. We can see its behaviour in the regular expression

  /(z)((a+)?(b+)?(c))*/.exec("zaacbbbcac")

which returns the array

  ["zaacbbbcac", "z", "ac", "a", undefined, "c"]

and not

  ["zaacbbbcac", "z", "ac", "a", "bbb", "c"]

because each iteration of the outermost * clears all captured Strings
contained in the quantified _Atom_, which in this case includes capture
Strings numbered 2, 3, 4, and 5.

NOTE 4 Step 1 of the RepeatMatcher's _d_ closure states that, once the
minimum number of repetitions has been satisfied, any more expansions of
_Atom_ that match the empty String are not considered for further
repetitions. This prevents the regular expression engine from falling
into an infinite loop on patterns such as:

  /(a*)*/.exec("b")

or the slightly more complicated:

  /(a*)b\1+/.exec("baaaac")

which returns the array

  ["b", ""]

The production _Assertion_ :: ^ evaluates by returning an internal
AssertionTester closure that takes a State argument _x_ and performs the
following:

The production _Assertion_ :: $ evaluates by returning an internal
AssertionTester closure that takes a State argument _x_ and performs the
following:

The production _Assertion_ :: \ B evaluates by returning an internal
AssertionTester closure that takes a State argument _x_ and performs the
following:

The production _Assertion_ :: \ B evaluates by returning an internal
AssertionTester closure that takes a State argument _x_ and performs the
following:

The production _Assertion_ :: ( ? = _Disjunction_ ) evaluates as
follows:

The production _Assertion_ :: ( ? ! _Disjunction_ ) evaluates as
follows:

The abstract operation _IsWordChar_ takes an integer parameter _e_ and
performs the following:

  --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
  a   b   c   d   e   f   g   h   i   j   k   l   m   n   o   p   q   r   s   t   u   v   w   x   y   z
  A   B   C   D   E   F   G   H   I   J   K   L   M   N   O   P   Q   R   S   T   U   V   W   X   Y   Z
  0   1   2   3   4   5   6   7   8   9   _                                                           
  --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---

The production _Quantifier_ :: _QuantifierPrefix_ evaluates as follows:

The production _Quantifier_ :: _QuantifierPrefix_ ? evaluates as
follows:

The production _QuantifierPrefix_ :: * evaluates by returning the two
results 0 and ∞.

The production _QuantifierPrefix_ :: + evaluates by returning the two
results 1 and ∞.

The production _QuantifierPrefix_ :: ? evaluates by returning the two
results 0 and 1.

The production _QuantifierPrefix_ :: { _DecimalDigits_ } evaluates as
follows:

The production _QuantifierPrefix_ :: { _DecimalDigits_ , } evaluates as
follows:

The production _QuantifierPrefix_ :: { _DecimalDigits_ , _DecimalDigits_
} evaluates as follows:

The production _Atom_ :: _PatternCharacter_ evaluates as follows:

The production _Atom_ :: . evaluates as follows:

The production _Atom_ :: \ _AtomEscape_ evaluates by evaluating
_AtomEscape_ to obtain a Matcher and returning that Matcher.

The production _Atom_ :: _CharacterClass_ evaluates as follows:

The production _Atom_ :: ( _Disjunction_ ) evaluates as follows:

The production _Atom_ :: ( ? : _Disjunction_ ) evaluates by evaluating
_Disjunction_ to obtain a Matcher and returning that Matcher.

The abstract operation _CharacterSetMatcher_ takes two arguments, a
CharSet _A_ and a Boolean flag _invert_, and performs the following:

a.  If there exists a member _a_ of set _A_ such that
      _Canonicalize_(_a_) == _cc_, return FAILURE.

The abstract operation _Canonicalize_ takes a character parameter _ch_
and performs the following steps:

NOTE 1 Parentheses of the form ( _Disjunction_ ) serve both to group the
components of the _Disjunction_ pattern together and to save the result
of the match. The result can be used either in a backreference (\
followed by a nonzero decimal number), referenced in a replace String,
or returned as part of an array from the regular expression matching
internal procedure. To inhibit the capturing behaviour of parentheses,
use the form (?: _Disjunction_ ) instead.

NOTE 2 The form (?= _Disjunction_ ) specifies a zero-width positive
lookahead. In order for it to succeed, the pattern inside _Disjunction_
must match at the current position, but the current position is not
advanced before matching the sequel. If _Disjunction_ can match at the
current position in several ways, only the first one is tried. Unlike
other regular expression operators, there is no backtracking into a (?=
form (this unusual behaviour is inherited from Perl). This only matters
when the _Disjunction_ contains capturing parentheses and the sequel of
the pattern contains backreferences to those captures.

For example,

  /(?=(a+))/.exec("baaabac")

matches the empty String immediately after the first B and therefore
returns the array:

  ["", "aaa"]

To illustrate the lack of backtracking into the lookahead, consider:

  /(?=(a+))a*b\1/.exec("baaabac")

This expression returns

  ["aba", "a"]

and not:

  ["aaaba", "a"]

NOTE 3 The form (?! _Disjunction_ ) specifies a zero-width negative
lookahead. In order for it to succeed, the pattern inside _Disjunction_
must fail to match at the current position. The current position is not
advanced before matching the sequel. _Disjunction_ can contain capturing
parentheses, but backreferences to them only make sense from within
_Disjunction_ itself. Backreferences to these capturing parentheses from
elsewhere in the pattern always return UNDEFINED because the negative
lookahead must fail for the pattern to succeed. For example,

  /(.*?)a(?!(a+)b\2c)\2(.*)/.exec("baaabaac")

looks for an A not immediately followed by some positive number n of
A's, a B, another n A's (specified by the first \2) and a C. The second
\2 is outside the negative lookahead, so it matches against UNDEFINED
and therefore always succeeds. The whole expression returns the array:

  ["baaabaac", "ba", undefined, "abaac"]

In case-insignificant matches all characters are implicitly converted to
upper case immediately before they are compared. However, if converting
a character to upper case would expand that character into more than one
character (such as converting "SS" (\u00DF) into "SS"), then the
character is left as-is instead. The character is also left as-is if it
is not an ASCII character but converting it to upper case would make it
into an ASCII character. This prevents Unicode characters such as \u0131
and \u017F from matching regular expressions such as /[AZ]/I, which are
only intended to match ASCII letters. Furthermore, if these conversions
were allowed, then /[^\W]/I would match each of A, B, …, H, but not I or
S.

The production _AtomEscape_ :: _DecimalEscape_ evaluates as follows:

The production _AtomEscape_ :: _CharacterEscape_ evaluates as follows:

The production _AtomEscape_ :: _CharacterClassEscape_ evaluates as
follows:

NOTE An escape sequence of the form \ followed by a nonzero decimal
number _n_ matches the result of the _n_th set of capturing parentheses
(see 15.10.2.11). It is an error if the regular expression has fewer
than _n_ capturing parentheses. If the regular expression has _n_ or
more capturing parentheses but the _n_th one is UNDEFINED because it has
not captured anything, then the backreference always succeeds.

The production _CharacterEscape_ :: _ControlEscape_ evaluates by
returning the character according to Table 25.

Table 25 — ControlEscape Character Values

  ------------------ ------------- ---------------------- ----------
  _CONTROLESCAPE _   _CODE UNIT_   _NAME_                 _SYMBOL_
  T                  \U0009        horizontal tab         <HT>
  N                  \U000A        line feed (new line)   <LF>
  V                  \U000B        vertical tab           <VT>
  F                  \U000C        form feed              <FF>
  R                  \U000D        carriage return        <CR>
  ------------------ ------------- ---------------------- ----------

The production _CharacterEscape_ :: C _ControlLetter_ evaluates as
follows:

The production _CharacterEscape_ :: _HexEscapeSequence_ evaluates by
evaluating the CV of the _HexEscapeSequence_ (see 7.8.4) and returning
its character result.

The production _CharacterEscape_ :: _UnicodeEscapeSequence_ evaluates by
evaluating the CV of the _UnicodeEscapeSequence_ (see 7.8.4) and
returning its character result.

The production _CharacterEscape_ :: _IdentityEscape_ evaluates by
returning the character represented by _IdentityEscape_.

The production _DecimalEscape_ :: _DecimalIntegerLiteral_ [lookahead ∉
_DecimalDigit_] evaluates as follows:

The definition of “the MV of _DecimalIntegerLiteral_” is in 7.8.3.

NOTE If \ is followed by a decimal number _n_ whose first digit is not
0, then the escape sequence is considered to be a backreference. It is
an error if _n_ is greater than the total number of left capturing
parentheses in the entire regular expression. \0 represents the <NUL>
character and cannot be followed by a decimal digit.

The production _CharacterClassEscape_ :: D evaluates by returning the
ten-element set of characters containing the characters 0 through 9
inclusive.

The production _CharacterClassEscape_ :: D evaluates by returning the
set of all characters not included in the set returned by
_CharacterClassEscape_ :: D.

The production _CharacterClassEscape_ :: S evaluates by returning the
set of characters containing the characters that are on the right-hand
side of the _WhiteSpace_ (7.2) or _LineTerminator_ (7.3) productions.

The production _CharacterClassEscape_ :: S evaluates by returning the
set of all characters not included in the set returned by
_CharacterClassEscape_ :: S.

The production _CharacterClassEscape_ :: W evaluates by returning the
set of characters containing the sixty-three characters:

  --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
  a   b   c   d   e   f   g   h   i   j   k   l   m   n   o   p   q   r   s   t   u   v   w   x   y   z
  A   B   C   D   E   F   G   H   I   J   K   L   M   N   O   P   Q   R   S   T   U   V   W   X   Y   Z
  0   1   2   3   4   5   6   7   8   9   _                                                           
  --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---

The production _CharacterClassEscape_ :: W evaluates by returning the
set of all characters not included in the set returned by
_CharacterClassEscape_ :: W.

The production _CharacterClass_ :: [ [lookahead ∉ {^}] _ClassRanges_ ]
evaluates by evaluating _ClassRanges_ to obtain a CharSet and returning
that CharSet and the Boolean FALSE.

The production _CharacterClass_ :: [ ^ _ClassRanges_ ] evaluates by
evaluating _ClassRanges_ to obtain a CharSet and returning that CharSet
and the Boolean TRUE.

The production _ClassRanges_ :: [empty] evaluates by returning the empty
CharSet.

The production _ClassRanges_ :: _NonemptyClassRanges_ evaluates by
evaluating _NonemptyClassRanges_ to obtain a CharSet and returning that
CharSet.

The production _NonemptyClassRanges_ :: _ClassAtom_ evaluates by
evaluating _ClassAtom_ to obtain a CharSet and returning that CharSet.

The production _NonemptyClassRanges_ :: _ClassAtom_
_NonemptyClassRangesNoDash_ evaluates as follows:

The production _NonemptyClassRanges_ :: _ClassAtom_ - _ClassAtom_
_ClassRanges_ evaluates as follows:

The abstract operation _CharacterRange_ takes two CharSet parameters _A_
and _B_ and performs the following:

The production _NonemptyClassRangesNoDash_ :: _ClassAtom_ evaluates by
evaluating _ClassAtom_ to obtain a CharSet and returning that CharSet.

The production _NonemptyClassRangesNoDash_ :: _ClassAtomNoDash_
_NonemptyClassRangesNoDash_ evaluates as follows:

The production _NonemptyClassRangesNoDash_ :: _ClassAtomNoDash_ -
_ClassAtom_ _ClassRanges_ evaluates as follows:

NOTE 1 _ClassRanges_ can expand into single _ClassAtoms_ and/or ranges
of two _ClassAtoms_ separated by dashes. In the latter case the
_ClassRanges_ includes all characters between the first _ClassAtom_ and
the second _ClassAtom_, inclusive; an error occurs if either _ClassAtom_
does not represent a single character (for example, if one is \W) or if
the first _ClassAtom's_ code unit value is greater than the second
_ClassAtom's_ code unit value.

NOTE 2 Even if the pattern ignores case, the case of the two ends of a
range is significant in determining which characters belong to the
range. Thus, for example, the pattern /[E-F]/I matches only the letters
E, F, E, and F, while the pattern /[E-F]/I matches all upper and
lower-case ASCII letters as well as the symbols [, \, ], ^, _, and `.

NOTE 3 A - character can be treated literally or it can denote a range.
It is treated literally if it is the first or last character of
_ClassRanges_, the beginning or end limit of a range specification, or
immediately follows a range specification.

The production _ClassAtom_ :: - evaluates by returning the CharSet
containing the one character -.

The production _ClassAtom_ :: _ClassAtomNoDash_ evaluates by evaluating
_ClassAtomNoDash_ to obtain a CharSet and returning that CharSet.

The production _ClassAtomNoDash_ :: _SourceCharacter_ BUT NOT ONE OF \
OR ] OR - evaluates by returning a one-element CharSet containing the
character represented by _SourceCharacter_.

The production _ClassAtomNoDash_ :: \ _ClassEscape_ evaluates by
evaluating _ClassEscape_ to obtain a CharSet and returning that CharSet.

The production _ClassEscape_ :: _DecimalEscape_ evaluates as follows:

The production _ClassEscape_ :: B evaluates by returning the CharSet
containing the one character <BS> (Unicode value 0008).

The production _ClassEscape_ :: _CharacterEscape_ evaluates by
evaluating _CharacterEscape_ to obtain a character and returning a
one-element CharSet containing that character.

The production _ClassEscape_ :: _CharacterClassEscape_ evaluates by
evaluating _CharacterClassEscape_ to obtain a CharSet and returning that
CharSet.

NOTE A _ClassAtom_ can use any of the escape sequences that are allowed
in the rest of the regular expression except for \B, \B, and
backreferences. Inside a _CharacterClass_, \B means the backspace
character, while \B and backreferences raise errors. Using a
backreference inside a _ClassAtom_ causes an error.

If _pattern_ is an object _R_ that has a [[NativeBrand]] internal
property whose value is NativeRegExp and _flags_ is UNDEFINED, then
return _R_ unchanged. Otherwise call the standard built-in REGEXP
constructor (15.10.4.1) as if by the expression NEW REGEXP(_pattern_,
_flags_) and return the object constructed by that constructor.

When REGEXP is called as part of a NEW expression, it is a constructor:
it initialises the newly created object.

If _pattern_ is an object _R_ that has a [[NativeBrand]] internal
property whose value is NativeRegExp and _flags_ is UNDEFINED, then let
_P_ be the _pattern_ used to construct _R_ and let _F_ be the flags used
to construct _R_. If _pattern_ is an object _R_ that has a
[[NativeBrand]] internal property whose value is NativeRegExp and
_flags_ is not UNDEFINED, then throw a TYPEERROR exception. Otherwise,
let _P_ be the empty String if _pattern_ is UNDEFINED and
ToString(_pattern_) otherwise, and let _F_ be the empty String if
_flags_ is UNDEFINED and ToString(_flags_) otherwise.

If the characters of _P_ do not have the syntactic form _Pattern_, then
throw a SYNTAXERROR exception. Otherwise let the newly constructed
object have a [[Match]] internal property obtained by evaluating
("compiling") the characters of _P_ as a _Pattern_ as described in
15.10.2.

If _F_ contains any character other than "G", "I", or "M", or if it
contains the same character more than once, then throw a SYNTAXERROR
exception.

If a SYNTAXERROR exception is not thrown, then:

Let _S_ be a String in the form of a _Pattern_ equivalent to _P_, in
which certain characters are escaped as described below. _S_ may or may
not be identical to _P_ or _pattern_; however, the internal procedure
that would result from evaluating _S_ as a _Pattern_ must behave
identically to the internal procedure given by the constructed object's
[[Match]] internal property.

The characters / occurring in the pattern shall be escaped in _S_ as
necessary to ensure that the String value formed by concatenating the
Strings "/", _S_, "/", and _F_ can be parsed (in an appropriate lexical
context) as a _RegularExpressionLiteral_ that behaves identically to the
constructed regular expression. For example, if _P_ is "/", then _S_
could be "\/" or "\U002F", among other possibilities, but not "/",
because /// followed by _F_ would be parsed as a _SingleLineComment_
rather than a _RegularExpressionLiteral_. If _P_ is the empty String,
this specification can be met by letting _S_ be "(?:)".

The following properties of the newly constructed object are data
properties with the attributes that are specified in 15.10.7. The
[[Value]] of each property is set as follows:

The SOURCE property of the newly constructed object is set to _S_.

The GLOBAL property of the newly constructed object is set to a Boolean
value that is TRUE if _F_ contains the character "G" and FALSE
otherwise.

The IGNORECASE property of the newly constructed object is set to a
Boolean value that is TRUE if _F_ contains the character "I" and FALSE
otherwise.

The MULTILINE property of the newly constructed object is set to a
Boolean value that is TRUE if _F_ contains the character "M" and FALSE
otherwise.

The LASTINDEX property of the newly constructed object is set to 0.

The [[Prototype]] internal property of the newly constructed object is
set to the standard built-in RegExp prototype object as specified in
15.10.6.

The newly constructed object has a [[NativeBrand]] internal property
whose value is NativeRegExp

NOTE If pattern is a _StringLiteral_, the usual escape sequence
substitutions are performed before the String is processed by RegExp. If
pattern must contain an escape sequence to be recognised by RegExp, any
backslash \ characters must be escaped within the _StringLiteral_ to
prevent them being removed when the contents of the _StringLiteral_ are
formed.

The value of the [[Prototype]] internal property of the RegExp
constructor is the standard built-in Function prototype object (15.3.4).

Besides the internal properties and the LENGTH property (whose value is
2), the RegExp constructor has the following properties:

The initial value of REGEXP.PROTOTYPE is the RegExp prototype object
(15.10.6).

This property shall have the attributes { [[Writable]]: FALSE,
[[Enumerable]]: FALSE, [[Configurable]]: FALSE }.

The value of the [[Prototype]] internal property of the RegExp prototype
object is the standard built-in Object prototype object (15.2.4). The
RegExp prototype object is itself a regular expression object; it has a
[[NativeBrand]] internal property whose value is NativeRegExp . The
initial values of the RegExp prototype object’s data properties
(15.10.7) are set as if the object was created by the expression NEW
REGEXP() where REGEXP is that standard built-in constructor with that
name.

The RegExp prototype object does not have a VALUEOF property of its own;
however, it inherits the VALUEOF property from the Object prototype
object.

In the following descriptions of functions that are properties of the
RegExp prototype object, the phrase “this RegExp object” refers to the
object that is the THIS value for the invocation of the function; a
TYPEERROR exception is thrown if the THIS value is not an object that
has a [[NativeBrand]] internal property whose value is NativeRegExp.

The initial value of REGEXP.PROTOTYPE.CONSTRUCTOR is the standard
built-in REGEXP constructor.

Performs a regular expression match of _string_ against the regular
expression and returns an Array object containing the results of the
match, or NULL if _string_ did not match.

The String ToString(_string_) is searched for an occurrence of the
regular expression pattern as follows:

The following steps are taken:

Return the String value formed by concatenating the Strings "/", the
String value of the SOURCE property of this RegExp object, and "/"; plus
"G" if the GLOBAL property is TRUE, "I" if the IGNORECASE property is
TRUE, and "M" if the MULTILINE property is TRUE.

NOTE The returned String has the form of a _RegularExpressionLiteral_
that evaluates to another RegExp object with the same behaviour as this
object.

RegExp instances inherit properties from the RegExp prototype object and
have a [[NativeBrand]] internal property whose value is NativeRegExp.
RegExp instances also have a [[Match]] internal property and a LENGTH
property.

The value of the [[Match]] internal property is an implementation
dependent representation of the _Pattern_ of the RegExp object.

RegExp instances also have the following properties.

The value of the SOURCE property is a String in the form of a _Pattern_
representing the current regular expression. This property shall have
the attributes { [[Writable]]: FALSE, [[Enumerable]]: FALSE,
[[Configurable]]: FALSE }.

The value of the GLOBAL property is a Boolean value indicating whether
the flags contained the character “G”. This property shall have the
attributes { [[Writable]]: FALSE, [[Enumerable]]: FALSE,
[[Configurable]]: FALSE }.

The value of the IGNORECASE property is a Boolean value indicating
whether the flags contained the character “I”. This property shall have
the attributes { [[Writable]]: FALSE, [[Enumerable]]: FALSE,
[[Configurable]]: FALSE }.

The value of the MULTILINE property is a Boolean value indicating
whether the flags contained the character “M”. This property shall have
the attributes { [[Writable]]: FALSE, [[Enumerable]]: FALSE,
[[Configurable]]: FALSE }.

The value of the LASTINDEX property specifies the String position at
which to start the next match. It is coerced to an integer when used
(see 15.10.6.2). This property shall have the attributes { [[Writable]]:
TRUE, [[Enumerable]]: FALSE, [[Configurable]]: FALSE }.

NOTE Unlike the other standard built-in properties of RegExp instances,
LASTINDEX is writable.

Instances of Error objects are thrown as exceptions when runtime errors
occur. The Error objects may also serve as base objects for user-defined
exception classes.

When ERROR is called as a function rather than as a constructor, it
creates and initialises a new Error object. Thus the function call
ERROR(…) is equivalent to the object creation expression NEW ERROR(…)
with the same arguments.

The [[Prototype]] internal property of the newly constructed object is
set to the original Error prototype object, the one that is the initial
value of ERROR.PROTOTYPE (15.11.3.1).

The newly constructed object has a [[NativeBrand]] internal property
whose value is NativeError.

The [[Extensible]] internal property of the newly constructed object is
set to TRUE.

If the argument _message_ is not UNDEFINED, the MESSAGE own property of
the newly constructed object is set to ToString(_message_).

When ERROR is called as part of a NEW expression, it is a constructor:
it initialises the newly created object.

The [[Prototype]] internal property of the newly constructed object is
set to the original Error prototype object, the one that is the initial
value of ERROR.PROTOTYPE (15.11.3.1).

The newly constructed object has a [[NativeBrand]] internal property
whose value is NativeError .

The [[Extensible]] internal property of the newly constructed object is
set to TRUE.

If the argument _message_ is not UNDEFINED, the MESSAGE own property of
the newly constructed object is set to ToString(_message_).

The value of the [[Prototype]] internal property of the Error
constructor is the Function prototype object (15.3.4).

Besides the internal properties and the LENGTH property (whose value is
1), the Error constructor has the following property:

The initial value of ERROR.PROTOTYPE is the Error prototype object
(15.11.4).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

The Error prototype object is itself an Error object and has a
[[NativeBrand]] internal property whose value is NativeError .

The value of the [[Prototype]] internal property of the Error prototype
object is the standard built-in Object prototype object (15.2.4).

The initial value of ERROR.PROTOTYPE.CONSTRUCTOR is the built-in ERROR
constructor.

The initial value of ERROR.PROTOTYPE.NAME is "ERROR".

The initial value of ERROR.PROTOTYPE.MESSAGE is the empty String.

The following steps are taken:

Error instances inherit properties from the Error prototype object and
have a [[NativeBrand]] internal property whose value is NativeError .
Error instances have no special properties.

One of the _NativeError_ objects below is thrown when a runtime error is
detected. All of these objects share the same structure, as described in
15.11.7.

This exception is not currently used within this specification. This
object remains for compatibility with previous editions of this
specification.

Indicates a numeric value has exceeded the allowable range. See
15.4.2.2, 15.4.5.1, 15.7.4.2, 15.7.4.5, 15.7.4.6, 15.7.4.7, and
15.9.5.43.

Indicate that an invalid reference value has been detected. See 8.7.1,
8.7.2, 10.2.1, 10.2.1.1.4, 10.2.1.2.4, and 11.13.1.

Indicates that a parsing error has occurred. See 11.1.5, 11.3.1, 11.3.2,
11.4.1, 11.4.4, 11.4.5, 11.13.1, 11.13.2, 12.2.1, 12.10.1, 12.14.1,
13.1, 15.1.2.1, 15.3.2.1, 15.10.2.2, 15.10.2.5, 15.10.2.9, 15.10.2.15,
15.10.2.19, 15.10.4.1, and 15.12.2.

Indicates the actual type of an operand is different than the expected
type. See 8.6.2, 8.7.2, 8.10.5, 8.12.5, 8.12.7, 8.12.8, 8.12.9, 9.9,
9.10, 10.2.1, 10.2.1.1.3, 10.6, 11.2.2, 11.2.3, 11.4.1, 11.8.6, 11.8.7,
11.3.1, 13.2, 13.2.3, 15, 15.2.3.2, 15.2.3.3, 15.2.3.4, 15.2.3.5,
15.2.3.6, 15.2.3.7, 15.2.3.8, 15.2.3.9, 15.2.3.10, 15.2.3.11, 15.2.3.12,
15.2.3.13, 15.2.3.14, 15.2.4.3, 15.3.4.2, 15.3.4.3, 15.3.4.4, 15.3.4.5,
15.3.4.5.2, 15.3.4.5.3, 15.3.5, 15.3.5.3, 15.3.5.4, 15.4.4.3, 15.4.4.11,
15.4.4.16, 15.4.4.17, 15.4.4.18, 15.4.4.19, 15.4.4.20, 15.4.4.21,
15.4.4.22, 15.4.5.1, 15.5.4.2, 15.5.4.3, 15.6.4.2, 15.6.4.3, 15.7.4,
15.7.4.2, 15.7.4.4, 15.9.5, 15.9.5.44, 15.10.4.1, 15.10.6, 15.11.4.4 and
15.12.3.

Indicates that one of the global URI handling functions was used in a
way that is incompatible with its definition. See 15.1.3.

When an ECMAScript implementation detects a runtime error, it throws an
instance of one of the _NativeError_ objects defined in 15.11.6. Each of
these objects has the structure described below, differing only in the
name used as the constructor name instead of _NativeError_, in the NAME
property of the prototype object, and in the implementation-defined
MESSAGE property of the prototype object.

For each error object, references to _NativeError_ in the definition
should be replaced with the appropriate error object name from 15.11.6.

When a _NativeError_ constructor is called as a function rather than as
a constructor, it creates and initialises a new object. A call of the
object as a function is equivalent to calling it as a constructor with
the same arguments.

The [[Prototype]] internal property of the newly constructed object is
set to the prototype object for this error constructor. The newly
constructed object has a [[NativeBrand]] internal property whose value
is NativeError . The [[Extensible]] internal property of the newly
constructed object is set to TRUE.

If the argument _message_ is not UNDEFINED, the MESSAGE own property of
the newly constructed object is set to ToString(_message_).

When a _NativeError_ constructor is called as part of a NEW expression,
it is a constructor: it initialises the newly created object.

The [[Prototype]] internal property of the newly constructed object is
set to the prototype object for this _NativeError_ constructor. The
newly constructed object has a [[NativeBrand]] internal property whose
value is NativeError . The [[Extensible]] internal property of the newly
constructed object is set to TRUE.

If the argument _message_ is not UNDEFINED, the MESSAGE own property of
the newly constructed object is set to ToString(_message_).

The value of the [[Prototype]] internal property of a _NativeError_
constructor is the Function prototype object (15.3.4).

Besides the internal properties and the LENGTH property (whose value is
1), each _NativeError_ constructor has the following property:

The initial value of _NATIVEERROR_.PROTOTYPE is a _NativeError_
prototype object (15.11.7.7). Each _NativeError_ constructor has a
separate prototype object.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Each _NativeError_ prototype object is an Error object and has a
[[NativeBrand]] internal property whose value is NativeError .

The value of the [[Prototype]] internal property of each _NativeError_
prototype object is the standard built-in Error prototype object
(15.11.4).

The initial value of the CONSTRUCTOR property of the prototype for a
given _NativeError_ constructor is the _NativeError_ constructor
function itself (15.11.7).

The initial value of the NAME property of the prototype for a given
_NativeError_ constructor is the name of the constructor (the name used
instead of _NativeError_).

The initial value of the MESSAGE property of the prototype for a given
_NativeError_ constructor is the empty String.

NOTE The prototypes for the NativeError constructors do not themselves
provide a TOSTRING function, but instances of errors will inherit it
from the Error prototype object.

_NativeError_ instances inherit properties from their _NativeError
prototype object and have a [[NativeBrand]] internal property whose
value is NativeError . _NativeError_ instances have no special
properties.

The JSON object is a single object that contains two functions, PARSE
and STRINGIFY, that are used to parse and construct JSON texts. The JSON
Data Interchange Format is described in RFC 4627
<http://www.ietf.org/rfc/rfc4627.txt>. The JSON interchange format used
in this specification is exactly that described by RFC 4627 with two
exceptions:

-   The top level _JSONText_ production of the ECMAScript JSON grammar
    may consist of any _JSONValue_ rather than being restricted to being
    a _JSONObject_ or a _JSONArray_ as specified by RFC 4627.

-   Conforming implementations of JSON.PARSE and JSON.STRINGIFY must
    support the exact interchange format described in this specification
    without any deletions or extensions to the format. This differs from
    RFC 4627 which permits a JSON parser to accept non-JSON forms and
    extensions.

The value of the [[Prototype]] internal property of the JSON object is
the standard built-in Object prototype object (15.2.4). The JSON object
has a [[NativeBrand]] internal property whose value is NativeJSON . The
value of the [[Extensible]] internal property of the JSON object is set
to TRUE.

The JSON object does not have a [[Construct]] internal property; it is
not possible to use the JSON object as a constructor with the NEW
operator.

The JSON object does not have a [[Call]] internal property; it is not
possible to invoke the JSON object as a function.

JSON.stringify produces a String that conforms to the following JSON
grammar. JSON.parse accepts a String that conforms to the JSON grammar.

JSON is similar to ECMAScript source text in that it consists of a
sequence of characters conforming to the rules of _SourceCharacter_. The
JSON Lexical Grammar defines the tokens that make up a JSON text similar
to the manner that the ECMAScript lexical grammar defines the tokens of
an ECMAScript source text. The JSON Lexical grammar only recognises the
white space character specified by the production _JSONWhiteSpace_. The
JSON lexical grammar shares some productions with the ECMAScript lexical
grammar. All nonterminal symbols of the grammar that do not begin with
the characters “JSON” are defined by productions of the ECMAScript
lexical grammar.

Syntax

_JSONWhiteSpace_ ::

<TAB>
<CR>
<LF>
<SP>

JSONString ::

" JSONStringCharacters~opt~ "

JSONStringCharacters ::

JSONStringCharacter JSONStringCharacters~opt~

_JSONStringCharacter_ ::

SourceCharacter BUT NOT ONE OF " OR \ OR U+0000 THROUGH U+001F

\ JSONEscapeSequence

JSONEscapeSequence ::

JSONEscapeCharacter

UnicodeEscapeSequence

JSONEscapeCharacter :: ONE OF

" / \ B F N R T

JSONNumber ::

-~opt~ DecimalIntegerLiteral JSONFraction~opt~ ExponentPart~opt~

JSONFraction ::

. DecimalDigits

JSONNullLiteral ::

NullLiteral

JSONBooleanLiteral ::

BooleanLiteral

The JSON Syntactic Grammar defines a valid JSON text in terms of tokens
defined by the JSON lexical grammar. The goal symbol of the grammar is
_JSONText_.

Syntax

JSONText :

JSONValue

JSONValue :

JSONNullLiteral
JSONBooleanLiteral
JSONObject
JSONArray
JSONString
JSONNumber

JSONObject :

{ }
{ JSONMemberList }

JSONMember :

JSONString : JSONValue

JSONMemberList :

JSONMember
JSONMemberList , JSONMember

JSONArray :

[ ]
[ JSONElementList ]

JSONElementList :

JSONValue
JSONElementList , JSONValue

The PARSE function parses a JSON text (a JSON-formatted String) and
produces an ECMAScript value. The JSON format is a restricted form of
ECMAScript literal. JSON objects are realized as ECMAScript objects.
JSON arrays are realized as ECMAScript arrays. JSON strings, numbers,
booleans, and null are realized as ECMAScript Strings, Numbers,
Booleans, and NULL. JSON uses a more limited set of white space
characters than _WhiteSpace_ and allows Unicode code points U+2028 and
U+2029 to directly appear in _JSONString_ literals without using an
escape sequence. The process of parsing is similar to 11.1.4 and 11.1.5
as constrained by the JSON grammar.

The optional _reviver_ parameter is a function that takes two
parameters, (_key_ and _value_). It can filter and transform the
results. It is called with each of the _key_/_value_ pairs produced by
the parse, and its return value is used instead of the original value.
If it returns what it received, the structure is not modified. If it
returns UNDEFINED then the property is deleted from the result.

The abstract operation Walk is a recursive abstract operation that takes
two parameters: a _holder_ object and the String _name_ of a property in
that object. Walk uses the value of _reviver_ that was originally passed
to the above parse function.

It is not permitted for a conforming implementation of JSON.PARSE to
extend the JSON grammars. If an implementation wishes to support a
modified or extended JSON interchange format it must do so by defining a
different parse function.

NOTE In the case where there are duplicate name Strings within an
object, lexically preceding values for the same key shall be
overwritten.

The STRINGIFY function returns a String in JSON format representing an
ECMAScript value. It can take three parameters. The _value_ parameter is
an ECMAScript value, which is usually an object or array, although it
can also be a String, Boolean, Number or NULL. The optional _replacer_
parameter is either a function that alters the way objects and arrays
are stringified, or an array of Strings and Numbers that acts as a white
list for selecting the object properties that will be stringified. The
optional _space_ parameter is a String or Number that allows the result
to have white space injected into it to improve human readability.

These are the steps in stringifying an object:

The abstract operation _Str_(_key_, _holder_) has access to
_ReplacerFunction_ from the invocation of the STRINGIFY method. Its
algorithm is as follows:

The abstract operation _Quote_(_value_) wraps a String value in double
quotes and escapes characters within it.

  backspace "B"

  formfeed "F"

  newline "N"

  carriage return "R"

  tab "T"

The abstract operation _JO_(_value_) serializes an object. It has access
to the _stack_, _indent_, _gap_, and _PropertyList_ of the invocation of
the stringify method.

The abstract operation _JA_(_value_) serializes an array. It has access
to the _stack_, _indent_, and _gap_ of the invocation of the stringify
method. The representation of arrays includes only the elements between
zero and ARRAY.LENGTH – 1 inclusive. Named properties are excluded from
the stringification. An array is stringified as an open left bracket,
elements separated by comma, and a closing right bracket.

NOTE 1 JSON structures are allowed to be nested to any depth, but they
must be acyclic. If _value_ is or contains a cyclic structure, then the
stringify function must throw a TYPEERROR exception. This is an example
of a value that cannot be stringified:

  a = [];

  a[0] = a;

  my_text = JSON.stringify(a); // This must throw an TypeError.

NOTE 2 Symbolic primitive values are rendered as follows:

-   The NULL value is rendered in JSON text as the String null.

-   The UNDEFINED value is not rendered.

-   The TRUE value is rendered in JSON text as the String true.

-   The FALSE value is rendered in JSON text as the String false.

NOTE 3 String values are wrapped in double quotes. The characters " and
\ are escaped with \ prefixes. Control characters are replaced with
escape sequences \UHHHH, or with the shorter forms, \B (backspace), \F
(formfeed), \N (newline), \R (carriage return), \T (tab).

NOTE 4 Finite numbers are stringified as if by calling
ToString(_number_). NAN and Infinity regardless of sign are represented
as the String NULL.

NOTE 5 Values that do not have a JSON representation (such as UNDEFINED
and functions) do not produce a String. Instead they produce the
undefined value. In arrays these values are represented as the String
NULL. In objects an unrepresentable value causes the property to be
excluded from stringification.

NOTE 6 An object is rendered as an opening left brace followed by zero
or more properties, separated with commas, closed with a right brace. A
property is a quoted String representing the key or property name, a
colon, and then the stringified property value. An array is rendered as
an opening left bracket followed by zero or more values, separated with
commas, closed with a right bracket.

An implementation must report most errors at the time the relevant
ECMAScript language construct is evaluated. An _early error_ is an error
that can be detected and reported prior to the evaluation of any
construct in the _Program_ containing the error. An implementation must
report early errors in a _Program_ prior to the first evaluation of that
_Program_. Early errors in EVAL code are reported at the time EVAL is
called but prior to evaluation of any construct within the EVAL code.
All errors that are not early errors are runtime errors.

An implementation must treat any instance of the following kinds of
errors as an early error:

-   Any syntax error.

-   Attempts to define an _ObjectLiteral_ that has multiple GET property
    assignments with the same name or multiple SET property assignments
    with the same name.

-   Attempts to define an _ObjectLiteral_ that has both a data property
    assignment and a GET or SET property assignment with the same name.

-   Errors in regular expression literals that are not
    implementation-defined syntax extensions.

-   Attempts in strict mode code to define an _ObjectLiteral_ that has
    multiple data property assignments with the same name.

-   The occurrence of a _WithStatement_ in strict mode code.

-   The occurrence of an _Identifier_ value appearing more than once
    within a _FormalParameterList_ of an individual strict mode
    _FunctionDeclaration_ or _FunctionExpression_.

-   Improper uses of RETURN, BREAK, and CONTINUE.

-   Attempts to call PutValue on any value for which an early
    determination can be made that the value is not a Reference (for
    example, executing the assignment statement 3=4).

An implementation shall not treat other kinds of errors as early errors
even if the compiler can prove that a construct cannot execute without
error under any circumstances. An implementation may issue an early
warning in such a case, but it should not report the error until the
relevant construct is actually executed.

An implementation shall report all errors as specified, except for the
following:

-   An implementation may extend program syntax and regular expression
      pattern or flag syntax. To permit this, all operations (such as
      calling EVAL, using a regular expression literal, or using the
      FUNCTION or REGEXP constructor) that are allowed to throw
      SYNTAXERROR are permitted to exhibit implementation-defined
      behaviour instead of throwing SYNTAXERROR when they encounter an
      implementation-defined extension to the program syntax or regular
      expression pattern or flag syntax.

-   An implementation may provide additional types, values, objects,
      properties, and functions beyond those described in this
      specification. This may cause constructs (such as looking up a
      variable in the global scope) to have implementation-defined
      behaviour instead of throwing an error (such as REFERENCEERROR).

-   An implementation may define behaviour other than throwing
      RANGEERROR for TOFIXED, TOEXPONENTIAL, and TOPRECISION when the
      _fractionDigits_ or _precision_ argument is outside the specified
      range.

(informative)
Grammar Summary


Lexical Grammar

SourceCharacter :: See clause 6

any Unicode code unit

InputElementDiv :: See clause 7

WhiteSpace
LineTerminator
Comment
Token
DivPunctuator

InputElementRegExp :: See clause 7

WhiteSpace
LineTerminator
Comment
Token
RegularExpressionLiteral

WhiteSpace :: See 7.2

<TAB>
<VT>
<FF>
<SP>
<NBSP>
<BOM>
<USP>

LineTerminator :: See 7.3

<LF>
<CR>
<LS>
<PS>

LineTerminatorSequence :: See 7.3

<LF>
<CR> [lookahead ∉ <LF> ]
<LS>
<PS>
<CR> <LF>

Comment :: See 7.4

MultiLineComment
SingleLineComment

MultiLineComment :: See 7.4

/* MultiLineCommentChars~opt~ */

MultiLineCommentChars :: See 7.4

MultiLineNotAsteriskChar MultiLineCommentChars~opt~
* PostAsteriskCommentChars~opt~

PostAsteriskCommentChars :: See 7.4

MultiLineNotForwardSlashOrAsteriskChar MultiLineCommentChars~opt~
* PostAsteriskCommentChars~opt~

MultiLineNotAsteriskChar :: See 7.4

SourceCharacter BUT NOT *

MultiLineNotForwardSlashOrAsteriskChar :: See 7.4

SourceCharacter BUT NOT ONE OF / OR *

SingleLineComment :: See 7.4

// SingleLineCommentChars~opt~

SingleLineCommentChars :: See 7.4

SingleLineCommentChar SingleLineCommentChars~opt~

SingleLineCommentChar :: See 7.4

SourceCharacter BUT NOT LineTerminator

Token :: See 7.5

IdentifierName
Punctuator
NumericLiteral
StringLiteral

Identifier :: See 7.6

IdentifierName BUT NOT ReservedWord

IdentifierName :: See 7.6

IdentifierStart
IdentifierName IdentifierPart

IdentifierStart :: See 7.6

UnicodeLetter
$
_
\ UnicodeEscapeSequence

IdentifierPart :: See 7.6

IdentifierStart
UnicodeCombiningMark
UnicodeDigit
UnicodeConnectorPunctuation
<ZWNJ>
<ZWJ>

UnicodeLetter :: See 7.6

any character in the Unicode categories “Uppercase letter (Lu)”,
“Lowercase letter (Ll)”, “Titlecase letter (Lt)”, “Modifier letter
(Lm)”, “Other letter (Lo)”, or “Letter number (Nl)”.

UnicodeCombiningMark :: See 7.6

any character in the Unicode categories “Non-spacing mark (Mn)” or
“Combining spacing mark (Mc)”

UnicodeDigit :: See 7.6

any character in the Unicode category “Decimal number (Nd)”

UnicodeConnectorPunctuation :: See 7.6

any character in the Unicode category “Connector punctuation (Pc)”

ReservedWord :: See 7.6.1

Keyword
FutureReservedWord
NullLiteral
BooleanLiteral

Keyword :: ONE OF See 7.6.1.1

  ---------- ---------- ------------ --------
  break      do         instanceof   typeof
  case       else       new          var
  catch      finally    return       void
  continue   for        switch       while
  debugger   function   this         with
  default    if         throw        
  delete     in         try          
  ---------- ---------- ------------ --------

FutureReservedWord :: ONE OF See 7.6.1.2

  ------- -------- --------- -------
  class   enum     extends   super
  const   export   import    
  ------- -------- --------- -------

  The following tokens are also considered to be _FutureReservedWords_
  when parsing strict mode code (see 10.1.1).

  ------------ --------- ----------- --------
  implements   let       private     public
  interface    package   protected   static
  yield                              
  ------------ --------- ----------- --------

Punctuator :: ONE OF See 7.7

  ----- ------ ----- ----- ----- -----
  {     }      (     )     [     ]
  .     ;      ,     <     >     <=
  >=    ==     !=    ===   !==   
  +     -      *     %     ++    --
  <<    >>     >>>   &     |     ^
  !     ~      &&    ||    ?     :
  =     +=     -=    *=    %=    <<=
  >>=   >>>=   &=    |=    ^=    
  ----- ------ ----- ----- ----- -----

DivPunctuator :: ONE OF See 7.7

  --- ---- -- -- -- --
  /   /=            
  --- ---- -- -- -- --

Literal :: See 7.8

NullLiteral
BooleanLiteral
NumericLiteral
StringLiteral
RegularExpressionLiteral

NullLiteral :: See 7.8.1

NULL

BooleanLiteral :: See 7.8.2

TRUE
FALSE

_NumericLiteral_ :: See 7.8.

DecimalLiteral
HexIntegerLiteral

DecimalLiteral :: See 7.8.3

DecimalIntegerLiteral . DecimalDigits~opt~ ExponentPart~opt~
. DecimalDigits ExponentPart~opt~
DecimalIntegerLiteral ExponentPart~opt~

DecimalIntegerLiteral :: See 7.8.3

0
NonZeroDigit DecimalDigits~opt~

DecimalDigits :: See 7.8.3

DecimalDigit
DecimalDigits DecimalDigit

DecimalDigit :: ONE OF See 7.8.3

0 1 2 3 4 5 6 7 8 

NonZeroDigit :: ONE OF See 7.8.3

1 2 3 4 5 6 7 8 

ExponentPart :: See 7.8.3

ExponentIndicator SignedInteger

ExponentIndicator :: ONE OF See 7.8.3

E E

SignedInteger :: See 7.8.3

DecimalDigits
+ DecimalDigits
- DecimalDigits

HexIntegerLiteral :: See 7.8.3

0X HexDigit
0X HexDigit
HexIntegerLiteral HexDigit

HexDigit :: ONE OF See 7.8.3

0 1 2 3 4 5 6 7 8 9 A B C D E F A B C D E F

StringLiteral :: See 7.8.4

" DoubleStringCharacters~opt~ "
' SingleStringCharacters~opt~ '

DoubleStringCharacters :: See 7.8.4

DoubleStringCharacter DoubleStringCharacters~opt~

SingleStringCharacters :: See 7.8.4

SingleStringCharacter SingleStringCharacters~opt~

DoubleStringCharacter :: See 7.8.4

SourceCharacter BUT NOT ONE OF " OR \ OR LineTerminator
\ EscapeSequence
LineContinuation

SingleStringCharacter :: See 7.8.4

SourceCharacter BUT NOT ONE OF ' OR \ OR LineTerminator
\ EscapeSequence
LineContinuation

LineContinuation :: See 7.8.4

\ LineTerminatorSequence

EscapeSequence :: See 7.8.4

CharacterEscapeSequence
0 [lookahead ∉ DecimalDigit]
HexEscapeSequence
UnicodeEscapeSequence

CharacterEscapeSequence :: See 7.8.4

SingleEscapeCharacter
NonEscapeCharacter

SingleEscapeCharacter :: ONE OF See 7.8.4

' " \ B F N R T V

NonEscapeCharacter :: See 7.8.4

SourceCharacter BUT NOT ONE OF EscapeCharacter OR LineTerminator

EscapeCharacter :: See 7.8.4

SingleEscapeCharacter
DecimalDigit
X
U

HexEscapeSequence :: See 7.8.4

X HexDigit HexDigit

UnicodeEscapeSequence :: See 7.8.4

U HexDigit HexDigit HexDigit HexDigit

RegularExpressionLiteral :: See 7.8.5

/ RegularExpressionBody / RegularExpressionFlags

RegularExpressionBody :: See 7.8.5

RegularExpressionFirstChar RegularExpressionChars

RegularExpressionChars :: See 7.8.5

[empty]
RegularExpressionChars RegularExpressionChar

RegularExpressionFirstChar :: See 7.8.5

RegularExpressionNonTerminator BUT NOT ONE OF * OR \ OR / OR [
RegularExpressionBackslashSequence
RegularExpressionClass

RegularExpressionChar :: See 7.8.5

RegularExpressionNonTerminator BUT NOT \ OR / OR [
RegularExpressionBackslashSequence
RegularExpressionClass

RegularExpressionBackslashSequence :: See 7.8.5

\ RegularExpressionNonTerminator

RegularExpressionNonTerminator :: See 7.8.5

SourceCharacter BUT NOT LineTerminator

RegularExpressionClass :: See 7.8.5

[ RegularExpressionClassChars ]

RegularExpressionClassChars :: See 7.8.5

[empty]
RegularExpressionClassChars RegularExpressionClassChar

RegularExpressionClassChar :: See 7.8.5

RegularExpressionNonTerminator BUT NOT ] OR \
RegularExpressionBackslashSequence

RegularExpressionFlags :: See 7.8.5

[empty]
RegularExpressionFlags IdentifierPart


Number Conversions

StringNumericLiteral ::: See 9.3.1

StrWhiteSpace~opt~
StrWhiteSpace~opt~ StrNumericLiteral StrWhiteSpace~opt~

StrWhiteSpace ::: See 9.3.1

StrWhiteSpaceChar StrWhiteSpace~opt~

StrWhiteSpaceChar ::: See 9.3.1

WhiteSpace
LineTerminator

StrNumericLiteral ::: See 9.3.1

StrDecimalLiteral
HexIntegerLiteral

StrDecimalLiteral ::: See 9.3.1

StrUnsignedDecimalLiteral
+ StrUnsignedDecimalLiteral
- StrUnsignedDecimalLiteral

StrUnsignedDecimalLiteral ::: See 9.3.1

INFINITY
DecimalDigits . DecimalDigits~opt~ ExponentPart~opt~
. DecimalDigits ExponentPart~opt~
DecimalDigits ExponentPart~opt~

DecimalDigits ::: See 9.3.1

DecimalDigit
DecimalDigits DecimalDigit

DecimalDigit ::: ONE OF See 9.3.1

0 1 2 3 4 5 6 7 8 

ExponentPart ::: See 9.3.1

ExponentIndicator SignedInteger

ExponentIndicator ::: ONE OF See 9.3.1

E E

SignedInteger ::: See 9.3.1

DecimalDigits
+ DecimalDigits
- DecimalDigits

HexIntegerLiteral ::: See 9.3.1

0X HexDigit
0X HexDigit
HexIntegerLiteral HexDigit

HexDigit ::: ONE OF See 9.3.1

0 1 2 3 4 5 6 7 8 9 A B C D E F A B C D E F


Expressions

PrimaryExpression : See 11.1

THIS
Identifier
Literal
ArrayLiteral
ObjectLiteral
( Expression )

ArrayLiteral : See 11.1.4

[ Elision~opt~ ]
[ ElementList ]
[ ElementList , Elision~opt~ ]

ElementList : See 11.1.4

Elision~opt~ AssignmentExpression
ElementList , Elision~opt~ AssignmentExpression

Elision : See 11.1.4

,
Elision ,

ObjectLiteral : See 11.1.5

{ }
{ PropertyNameAndValueList }
{ PropertyNameAndValueList , }

PropertyNameAndValueList : See 11.1.5

PropertyAssignment
PropertyNameAndValueList , PropertyAssignment

PropertyAssignment : See 11.1.5

PropertyName : AssignmentExpression
GET PropertyName ( ) { FunctionBody }
SET PropertyName ( PropertySetParameterList ) { FunctionBody }

PropertyName : See 11.1.5

IdentifierName
StringLiteral
NumericLiteral

PropertySetParameterList : See 11.1.5

Identifier

MemberExpression : See 11.2

PrimaryExpression
FunctionExpression
MemberExpression [ Expression ]
MemberExpression . IdentifierName
NEW MemberExpression _Arguments_

NewExpression : See 11.2

MemberExpression
NEW NewExpression

CallExpression : See 11.2

MemberExpression Arguments
CallExpression Arguments
CallExpression [ Expression ]
CallExpression . IdentifierName

Arguments : See 11.2

( )
( ArgumentList )

ArgumentList : See 11.2

AssignmentExpression
ArgumentList , AssignmentExpression

LeftHandSideExpression : See 11.2

NewExpression
CallExpression

PostfixExpression : See 11.3

LeftHandSideExpression
LeftHandSideExpression [no LineTerminator here] ++
LeftHandSideExpression [no LineTerminator here] --

UnaryExpression : See 11.4

PostfixExpression
DELETE UnaryExpression
VOID UnaryExpression
TYPEOF UnaryExpression
++ UnaryExpression
-- UnaryExpression
+ UnaryExpression
- UnaryExpression
~ UnaryExpression
! UnaryExpression

MultiplicativeExpression : See 11.5

UnaryExpression
MultiplicativeExpression * UnaryExpression
MultiplicativeExpression / UnaryExpression
MultiplicativeExpression % UnaryExpression

AdditiveExpression : See 11.6

MultiplicativeExpression
AdditiveExpression + MultiplicativeExpression
AdditiveExpression - MultiplicativeExpression

ShiftExpression : See 11.7

AdditiveExpression
ShiftExpression << AdditiveExpression
ShiftExpression >> AdditiveExpression
ShiftExpression >>> AdditiveExpression

RelationalExpression : See 11.8

ShiftExpression
RelationalExpression < ShiftExpression
RelationalExpression > ShiftExpression
RelationalExpression <= ShiftExpression
RelationalExpression >= ShiftExpression
RelationalExpression INSTANCEOF ShiftExpression
RelationalExpression IN ShiftExpression

RelationalExpressionNoIn : See 11.8

ShiftExpression
RelationalExpressionNoIn < ShiftExpression
RelationalExpressionNoIn > ShiftExpression
RelationalExpressionNoIn <= ShiftExpression
RelationalExpressionNoIn >= ShiftExpression
RelationalExpressionNoIn INSTANCEOF ShiftExpression

EqualityExpression : See 11.9

RelationalExpression
EqualityExpression == RelationalExpression
EqualityExpression != RelationalExpression
EqualityExpression === RelationalExpression
EqualityExpression !== RelationalExpression

EqualityExpressionNoIn : See 11.9

RelationalExpressionNoIn
EqualityExpressionNoIn == RelationalExpressionNoIn
EqualityExpressionNoIn != RelationalExpressionNoIn
EqualityExpressionNoIn === RelationalExpressionNoIn
EqualityExpressionNoIn !== RelationalExpressionNoIn

BitwiseANDExpression : See 11.10

EqualityExpression
BitwiseANDExpression & EqualityExpression

BitwiseANDExpressionNoIn : See 11.10

EqualityExpressionNoIn
BitwiseANDExpressionNoIn & EqualityExpressionNoIn

BitwiseXORExpression : See 11.10

BitwiseANDExpression
BitwiseXORExpression ^ BitwiseANDExpression

BitwiseXORExpressionNoIn : See 11.10

BitwiseANDExpressionNoIn
BitwiseXORExpressionNoIn ^ BitwiseANDExpressionNoIn

BitwiseORExpression : See 11.10

BitwiseXORExpression
BitwiseORExpression | BitwiseXORExpression

BitwiseORExpressionNoIn : See 11.10

BitwiseXORExpressionNoIn
BitwiseORExpressionNoIn | BitwiseXORExpressionNoIn

LogicalANDExpression : See 11.11

BitwiseORExpression
LogicalANDExpression && BitwiseORExpression

LogicalANDExpressionNoIn : See 11.11

BitwiseORExpressionNoIn
LogicalANDExpressionNoIn && BitwiseORExpressionNoIn

LogicalORExpression : See 11.11

LogicalANDExpression
LogicalORExpression || LogicalANDExpression

LogicalORExpressionNoIn : See 11.11

LogicalANDExpressionNoIn
LogicalORExpressionNoIn || LogicalANDExpressionNoIn

ConditionalExpression : See 11.12

LogicalORExpression
LogicalORExpression ? AssignmentExpression : AssignmentExpression

ConditionalExpressionNoIn : See 11.12

LogicalORExpressionNoIn
LogicalORExpressionNoIn ? AssignmentExpression :
AssignmentExpressionNoIn

AssignmentExpression : See 11.13

ConditionalExpression
LeftHandSideExpression = AssignmentExpression
LeftHandSideExpression AssignmentOperator AssignmentExpression

AssignmentExpressionNoIn : See 11.13

ConditionalExpressionNoIn
LeftHandSideExpression = AssignmentExpressionNoIn
LeftHandSideExpression AssignmentOperator AssignmentExpressionNoIn

AssignmentOperator : ONE OF See 11.13

  ---- ---- ---- ---- ---- ----- ----- ------ ---- ---- ----
  *=   /=   %=   +=   -=   <<=   >>=   >>>=   &=   ^=   |=
  ---- ---- ---- ---- ---- ----- ----- ------ ---- ---- ----

Expression : See 11.14

AssignmentExpression
Expression , AssignmentExpression

ExpressionNoIn : See 11.14

AssignmentExpressionNoIn
ExpressionNoIn , AssignmentExpressionNoIn


Statements

Statement : See clause 12

Block
VariableStatement
EmptyStatement
ExpressionStatement
IfStatement
IterationStatement
ContinueStatement
BreakStatement
ReturnStatement
WithStatement
LabelledStatement
SwitchStatement
ThrowStatement
TryStatement
DebuggerStatement

Block : See 12.1

{ StatementList~opt~ }

StatementList : See 12.1

Statement
StatementList Statement

VariableStatement : See 12.2

VAR VariableDeclarationList ;

VariableDeclarationList : See 12.2

VariableDeclaration
VariableDeclarationList , VariableDeclaration

VariableDeclarationListNoIn : See 12.2

VariableDeclarationNoIn
VariableDeclarationListNoIn , VariableDeclarationNoIn

VariableDeclaration : See 12.2

Identifier Initialiser~opt~

VariableDeclarationNoIn : See 12.2

Identifier InitialiserNoIn~opt~

Initialiser : See 12.2

= AssignmentExpression

InitialiserNoIn : See 12.2

= AssignmentExpressionNoIn

EmptyStatement : See 12.3

;

ExpressionStatement : See 12.4

[lookahead ∉ {{, FUNCTION}] Expression ;

IfStatement : See 12.5

IF ( Expression ) Statement ELSE Statement
IF ( Expression ) Statement

IterationStatement : See 12.6

DO Statement WHILE ( Expression );
WHILE ( Expression ) Statement
FOR (ExpressionNoIn~opt~; Expression~opt~ ; Expression~opt~ ) Statement
FOR ( VAR VariableDeclarationListNoIn; Expression~opt~ ; Expression~opt~
) Statement
FOR ( LeftHandSideExpression IN Expression ) Statement
FOR ( VAR VariableDeclarationNoIn IN Expression ) Statement

ContinueStatement : See 12.7

CONTINUE ;
CONTINUE [no LineTerminator here] Identifier ;

BreakStatement : See 12.8

BREAK ;
BREAK [no LineTerminator here] Identifier ;

ReturnStatement : See 12.9

RETURN ;
RETURN [no LineTerminator here] Expression ;

WithStatement : See 12.10

WITH ( Expression ) Statement

SwitchStatement : See 12.11

SWITCH ( Expression ) CaseBlock

CaseBlock : See 12.11

{ CaseClauses~opt~ }
{ CaseClauses~opt~ DefaultClause CaseClauses~opt~ }

CaseClauses : See 12.11

CaseClause
CaseClauses CaseClause

CaseClause : See 12.11

CASE Expression : StatementList~opt~

DefaultClause : See 12.11

DEFAULT : StatementList~opt~

LabelledStatement : See 12.12

Identifier : Statement

ThrowStatement : See 12.13

THROW [no LineTerminator here] Expression ;

TryStatement : See 12.14

TRY Block Catch~
~TRY Block Finally~
~TRY Block Catch Finally

Catch : See 12.14

CATCH ( Identifier ) Block

Finally : See 12.14

FINALLY Block

DebuggerStatement : See 12.15

DEBUGGER ;


Functions and Programs

FunctionDeclaration : See clause 13

FUNCTION Identifier ( FormalParameterList~opt~ ) { FunctionBody }

FunctionExpression : See clause 13

FUNCTION Identifier~opt~ ( FormalParameterList~opt~ ) { FunctionBody }

FormalParameterList : See clause 13

Identifier
FormalParameterList , Identifier

FunctionBody : See clause 13

SourceElements~opt~

Program : See clause 14

SourceElements~opt~

SourceElements : See clause 14

SourceElement
SourceElements SourceElement

SourceElement : See clause 14

Statement
FunctionDeclaration


Universal Resource Identifier Character Classes

uri ::: See 15.1.3

uriCharacters~opt~

uriCharacters ::: See 15.1.3

uriCharacter uriCharacters~opt~

uriCharacter ::: See 15.1.3

uriReserved
uriUnescaped
uriEscaped

uriReserved ::: ONE OF See 15.1.3

; / ? : @ & = + $ ,

uriUnescaped ::: See 15.1.3

uriAlpha
DecimalDigit
uriMark

uriEscaped ::: See 15.1.3

% HexDigit HexDigit

uriAlpha ::: ONE OF See 15.1.3

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

uriMark ::: ONE OF See 15.1.3

- _ . ! ~ * ' ( )


Regular Expressions

Pattern :: See 15.10.1

Disjunction

Disjunction :: See 15.10.1

Alternative
 Alternative | Disjunction

Alternative :: See 15.10.1

[empty]
Alternative Term

Term :: See 15.10.1

Assertion
Atom
Atom Quantifier

Assertion :: See 15.10.1

^
$
\ B
\ B
( ? = Disjunction )
( ? ! Disjunction )

Quantifier :: See 15.10.1

QuantifierPrefix
QuantifierPrefix ?

QuantifierPrefix :: See 15.10.1

*
+
?
{ DecimalDigits }
{ DecimalDigits , }
{ DecimalDigits , DecimalDigits }

Atom :: See 15.10.1

PatternCharacter
.
\ AtomEscape
CharacterClass
( Disjunction )
( ? : Disjunction )

_PatternCharacter_ :: See 15.10.

_SourceCharacter_ BUT NOT ONE OF-
 ^ $ \ . * + ? ( ) [ ] { } |

AtomEscape :: See 15.10.1

DecimalEscape
CharacterEscape
CharacterClassEscape

CharacterEscape :: See 15.10.1

ControlEscape
C ControlLetter
HexEscapeSequence
UnicodeEscapeSequence
IdentityEscape

ControlEscape :: ONE OF See 15.10.1

F N R T V

ControlLetter :: ONE OF See 15.10.1

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

IdentityEscape :: See 15.10.1

SourceCharacter BUT NOT IdentifierPart
<ZWJ>
<ZWNJ>

DecimalEscape :: See 15.10.1

DecimalIntegerLiteral [lookahead ∉ DecimalDigit]

CharacterClassEscape :: ONE OF See 15.10.1

D D S S W W

CharacterClass :: See 15.10.1

[ [lookahead ∉ {^}] ClassRanges ]
[ ^ ClassRanges ]

ClassRanges :: See 15.10.1

[empty]
NonemptyClassRanges

NonemptyClassRanges :: See 15.10.1

ClassAtom
ClassAtom NonemptyClassRangesNoDash
ClassAtom – ClassAtom ClassRanges

NonemptyClassRangesNoDash :: See 15.10.1

ClassAtom
ClassAtomNoDash NonemptyClassRangesNoDash
ClassAtomNoDash – ClassAtom ClassRanges

ClassAtom :: See 15.10.1

-
ClassAtomNoDash

ClassAtomNoDash :: See 15.10.1

SourceCharacter BUT NOT ONE OF \ OR ] OR -
\ ClassEscape

ClassEscape :: See 15.10.1

DecimalEscape
B
CharacterEscape
CharacterClassEscape


JSON

JSON Lexical Grammar

_JSONWhiteSpace_ :: See 15.12.1.

_<TAB>
<CR>
<LF>
<SP>_

JSONString :: See 15.12.1.1

" JSONStringCharacters~opt~ "

JSONStringCharacters :: See 15.12.1.1

JSONStringCharacter JSONStringCharacters~opt~

JSONStringCharacter :: See 15.12.1.1

SourceCharacter BUT NOT ONE OF " OR \ OR U+0000 THROUGH U+001F

\ JSONEscapeSequence

JSONEscapeSequence :: See 15.12.1.1

JSONEscapeCharacter

UnicodeEscapeSequence

JSONEscapeCharacter :: ONE OF See 15.12.1.1

" / \ B F N R T

JSONNumber :: See 15.12.1.1

-~opt~ DecimalIntegerLiteral JSONFraction~opt~ ExponentPart~opt~

JSONFraction :: See 15.12.1.1

. DecimalDigits

JSONNullLiteral :: See 15.12.1.1

NullLiteral

JSONBooleanLiteral :: See 15.12.1.1

BooleanLiteral

JSON Syntactic Grammar

JSONText : See 15.12.1.2

JSONValue

JSONValue : See 15.12.1.2

JSONNullLiteral
JSONBooleanLiteral
JSONObject
JSONArray
JSONString
JSONNumber

JSONObject : See 15.12.1.2

{ }
{ JSONMemberList }

JSONMember : See 15.12.1.2

JSONString : JSONValue

JSONMemberList : See 15.12.1.2

JSONMember
JSONMemberList , JSONMember

JSONArray : See 15.12.1.2

[ ]
[ JSONElementList ]

JSONElementList : See 15.12.1.2

JSONValue
JSONElementList , JSONValue

(normative)
Additional ECMAScript Features for Web Browsers

The ECMAScript language syntax and semantics defined in this annex are
required when the ECMAScript host is a web browser. The content of this
annex is normative but optional if the ECMAScript host is not a web
browser.


Additional Syntax

Numeric Literals

The syntax and semantics of 7.8.3 is extended as follows except that
this extension is not allowed for strict mode code:

Syntax

NumericLiteral ::

DecimalLiteral
HexIntegerLiteral
OctalIntegerLiteral

OctalIntegerLiteral ::

0 OctalDigit
OctalIntegerLiteral OctalDigit

OctalDigit :: ONE OF

0 1 2 3 4 5 6 

Semantics

-   The MV of _NumericLiteral_ :: _OctalIntegerLiteral_ is the MV of
      _OctalIntegerLiteral_.

-   The MV of _OctalDigit_ :: 0 is 0.

-   The MV of _OctalDigit_ :: 1 is 1.

-   The MV of _OctalDigit_ :: 2 is 2.

-   The MV of _OctalDigit_ :: 3 is 3.

-   The MV of _OctalDigit_ :: 4 is 4.

-   The MV of _OctalDigit_ :: 5 is 5.

-   The MV of _OctalDigit_ :: 6 is 6.

-   The MV of _OctalDigit_ :: 7 is 7.

-   The MV of _OctalIntegerLiteral_ :: 0 _OctalDigit_ is the MV of
      _OctalDigit_.

-   The MV of _OctalIntegerLiteral_ :: _OctalIntegerLiteral_
      _OctalDigit_ is (the MV of _OctalIntegerLiteral_ times 8) plus the
      MV of _OctalDigit_.

String Literals

The syntax and semantics of 7.8.4 is extended as follows except that
this extension is not allowed for strict mode code:

Syntax

EscapeSequence ::

CharacterEscapeSequence
OctalEscapeSequence
HexEscapeSequence
UnicodeEscapeSequence

OctalEscapeSequence ::

OctalDigit [lookahead ∉ DecimalDigit]
ZeroToThree OctalDigit [lookahead ∉ DecimalDigit]
FourToSeven OctalDigit
ZeroToThree OctalDigit OctalDigit

ZeroToThree :: ONE OF

0 1 2 

FourToSeven :: ONE OF

4 5 6 

Semantics

-   The CV of _EscapeSequence_ :: _OctalEscapeSequence_ is the CV of the
    _OctalEscapeSequence_.

-   The CV of _OctalEscapeSequence_ :: _OctalDigit_ [lookahead ∉
    _DecimalDigit_] is the character whose code unit value is the MV of
    the _OctalDigit_.

-   The CV of _OctalEscapeSequence_ :: _ZeroToThree_ _OctalDigit_
    [lookahead ∉ _DecimalDigit_] is the character whose code unit value
    is (8 times the MV of the _ZeroToThree_) plus the MV of the
    _OctalDigit_.

-   The CV of _OctalEscapeSequence_ :: _FourToSeven_ _OctalDigit_ is the
    character whose code unit value is (8 times the MV of the
    _FourToSeven_) plus the MV of the _OctalDigit_.

-   The CV of _OctalEscapeSequence_ :: _ZeroToThree_ _OctalDigit_
    _OctalDigit_ is the character whose code unit value is (64 (that is,
    8^2^) times the MV of the _ZeroToThree_) plus (8 times the MV of the
    first _OctalDigit_) plus the MV of the second _OctalDigit_.

-   The MV of _ZeroToThree_ :: 0 is 0.

-   The MV of _ZeroToThree_ :: 1 is 1.

-   The MV of _ZeroToThree_ :: 2 is 2.

-   The MV of _ZeroToThree_ :: 3 is 3.

-   The MV of _FourToSeven_ :: 4 is 4.

-   The MV of _FourToSeven_ :: 5 is 5.

-   The MV of _FourToSeven_ :: 6 is 6.

-   The MV of _FourToSeven_ :: 7 is 7.


Additional Properties

When the ECMAScript host is a web browser the following these additional
properties of the standard native objects are defined.

escape (string)

The ESCAPE function is a property of the global object. It computes a
new version of a String value in which certain characters have been
replaced by a hexadecimal escape sequence.

For those characters being replaced whose code unit value is 0XFF or
less, a two-digit escape sequence of the form %_xx_ is used. For those
characters being replaced whose code unit value is greater than 0XFF, a
four-digit escape sequence of the form %U_xxxx_ is used.

When the ESCAPE function is called with one argument _string_, the
following steps are taken:

NOTE The encoding is partly based on the encoding described in RFC 1738,
but the entire encoding specified in this standard is described above
without regard to the contents of RFC 1738. This encoding does not
reflect changes to RFC 1738 made by RFC 3986.

unescape (string)

The UNESCAPE function is a property of the global object. It computes a
new version of a String value in which each escape sequence of the sort
that might be introduced by the ESCAPE function is replaced with the
character that it represents.

When the UNESCAPE function is called with one argument _string_, the
following steps are taken:

String.prototype.substr (start, length)

The SUBSTR method takes two arguments, _start_ and _length_, and returns
a substring of the result of converting the this object to a String,
starting from character position _start_ and running for _length_
characters (or through the end of the String if _length_ is UNDEFINED).
If _start_ is negative, it is treated as (_sourceLength_+_start_) where
_sourceLength_ is the length of the String. The result is a String
value, not a String object. The following steps are taken:

The LENGTH property of the SUBSTR method is 2.

NOTE The SUBSTR function is intentionally generic; it does not require
that its THIS value be a String object. Therefore it can be transferred
to other kinds of objects for use as a method.

Date.prototype.getYear ( )

NOTE The GETFULLYEAR method is preferred for nearly all purposes,
because it avoids the “year 2000 problem.”

When the GETYEAR method is called with no arguments, the following steps
are taken:

Date.prototype.setYear (year)

NOTE The SETFULLYEAR method is preferred for nearly all purposes,
because it avoids the “year 2000 problem.”

When the SETYEAR method is called with one argument _year_, the
following steps are taken:

Date.prototype.toGMTString ( )

NOTE The property TOUTCSTRING is preferred. The TOGMTSTRING property is
provided principally for compatibility with old code. It is recommended
that the TOUTCSTRING property be used in new ECMAScript code.

The Function object that is the initial value of
DATE.PROTOTYPE.TOGMTSTRING is the same Function object that is the
initial value of DATE.PROTOTYPE.TOUTCSTRING.

(informative)
The Strict Mode of ECMAScript

THE STRICT MODE RESTRICTION AND EXCEPTIONS

-   The identifiers "IMPLEMENTS", "INTERFACE", "LET", "PACKAGE",
      "PRIVATE", "PROTECTED", "PUBLIC", "STATIC", and "YIELD" are
      classified as _FutureReservedWord_ tokens within strict mode code.
      (7.6.12).

-   A conforming implementation, when processing strict mode code, may
      not extend the syntax of _NumericLiteral_ (7.8.3) to include
      _OctalIntegerLiteral_ as described in B.1.1.

-   A conforming implementation, when processing strict mode code (see
      10.1.1), may not extend the syntax of _EscapeSequence_ to include
      _OctalEscapeSequence_ as described in B.1.2.

-   Assignment to an undeclared identifier or otherwise unresolvable
      reference does not create a property in the global object. When a
      simple assignment occurs within strict mode code, its
      _LeftHandSide_ must not evaluate to an unresolvable Reference. If
      it does a REFERENCEERROR exception is thrown (8.7.2). The
      _LeftHandSide_ also may not be a reference to a data property with
      the attribute value {[[Writable]]:FALSE}, to an accessor property
      with the attribute value {[[Set]]:UNDEFINED}, nor to a
      non-existent property of an object whose [[Extensible]] internal
      property has the value FALSE. In these cases a TYPEERROR exception
      is thrown (11.13.1).

-   The identifier EVAL or ARGUMENTS may not appear as the
      _LeftHandSideExpression_ of an Assignment operator (11.13) or of a
      _PostfixExpression_ (11.3) or as the _UnaryExpression_ operated
      upon by a Prefix Increment (11.4.4) or a Prefix Decrement (11.4.5)
      operator.

-   Arguments objects for strict mode functions define non-configurable
      accessor properties named "CALLER" and "CALLEE" which throw a
      TYPEERROR exception on access (10.6).

-   Arguments objects for strict mode functions do not dynamically share
      their array indexed property values with the corresponding formal
      parameter bindings of their functions. (10.6).

-   For strict mode functions, if an arguments object is created the
      binding of the local identifier ARGUMENTS to the arguments object
      is immutable and hence may not be the target of an assignment
      expression. (10.5).

-   It is a SYNTAXERROR if strict mode code contains an _ObjectLiteral_
      with more than one definition of any data property (11.1.5).

-   It is a SYNTAXERROR if the _Identifier_ "EVAL" or the _Identifier_
      "ARGUMENTS" occurs as the _Identifier_ in a
      _PropertySetParameterList_ of a _PropertyAssignment_ that is
      contained in strict code or if its _FunctionBody_ is strict code
      (11.1.5).

-   Strict mode eval code cannot instantiate variables or functions in
      the variable environment of the caller to eval. Instead, a new
      variable environment is created and that environment is used for
      declaration binding instantiation for the eval code (10.4.2).

-   If THIS is evaluated within strict mode code, then the THIS value is
      not coerced to an object. A THIS value of NULL or UNDEFINED is not
      converted to the global object and primitive values are not
      converted to wrapper objects. The THIS value passed via a function
      call (including calls made using FUNCTION.PROTOTYPE.APPLY and
      FUNCTION.PROTOTYPE.CALL) do not coerce the passed this value to an
      object (10.4.3, 11.1.1, 15.3.4.3, 15.3.4.4).

-   When a DELETE operator occurs within strict mode code, a SYNTAXERROR
      is thrown if its _UnaryExpression_ is a direct reference to a
      variable, function argument, or function name(11.4.1).

-   When a DELETE operator occurs within strict mode code, a TYPEERROR
      is thrown if the property to be deleted has the attribute {
      [[Configurable]]:FALSE } (11.4.1).

-   It is a SYNTAXERROR if a _VariableDeclaration_ or
      _VariableDeclarationNoIn_ occurs within strict code and its
      _Identifier_ is EVAL or ARGUMENTS (12.2.1).

-   Strict mode code may not include a _WithStatement_. The occurrence
      of a _WithStatement_ in such a context is an SYNTAXERROR (12.10).

-   It is a SYNTAXERROR if a _TryStatement_ with a _Catch_ occurs within
      strict code and the _Identifier_ of the _Catch_ production is EVAL
      or ARGUMENTS (12.14.1)

-   It is a SYNTAXERROR if the identifier EVAL or ARGUMENTS appears
      within a _FormalParameterList_ of a strict mode
      _FunctionDeclaration_ or _FunctionExpression_ (13.1)

-   A strict mode function may not have two or more formal parameters
      that have the same name. An attempt to create such a function
      using a _FunctionDeclaration_, _FunctionExpression_, or FUNCTION
      constructor is a SYNTAXERROR (13.1, 15.3.2).

-   An implementation may not extend, beyond that defined in this
      specification, the meanings within strict mode functions of
      properties named CALLER or ARGUMENTS of function instances.
      ECMAScript code may not create or modify properties with these
      names on function objects that correspond to strict mode functions
      (10.6, 13.2, 15.3.4.5.3).

-   It is a SYNTAXERROR to use within strict mode code the identifiers
      EVAL or ARGUMENTS as the _Identifier_ of a _FunctionDeclaration_
      or _FunctionExpression_ or as a formal parameter name (13.1).
      Attempting to dynamically define such a strict mode function using
      the FUNCTION constructor (15.3.2) will throw a SYNTAXERROR
      exception.

(informative)
Corrections and Clarifications in the 5^th^ Edition
with Possible 3^rd^ Edition Compatibility Impact

Throughout: In the Edition 3 specification the meaning of phrases such
as “as if by the expression NEW ARRAY()” are subject to
misinterpretation. In the Edition 5 specification text for all internal
references and invocations of standard built-in objects and methods has
been clarified by making it explicit that the intent is that the actual
built-in object is to be used rather than the current dynamic value of
the correspondingly named property.

11.8.2, 11.8.3, 11.8.5: ECMAScript generally uses a left to right
evaluation order, however the Edition 3 specification language for the >
and <= operators resulted in a partial right to left order. The
specification has been corrected for these operators such that it now
specifies a full left to right evaluation order. However, this change of
order is potentially observable if side-effects occur during the
evaluation process.

11.1.4: Edition 5 clarifies the fact that a trailing comma at the end of
an _ArrayInitialiser_ does not add to the length of the array. This is
not a semantic change from Edition 3 but some implementations may have
previously misinterpreted this.

11.2.3: Edition 5 reverses the order of steps 2 and 3 of the algorithm.
The original order as specified in Editions 1 through 3 was incorrectly
specified such that side-effects of evaluating _Arguments_ could affect
the result of evaluating _MemberExpression_.

12.4: In Edition 3, an object is created, as if by NEW OBJECT()to serve
as the scope for resolving the name of the exception parameter passed to
a CATCH clause of a TRY statement. If the actual exception object is a
function and it is called from within the CATCH clause, the scope object
will be passed as the THIS value of the call. The body of the function
can then define new properties on its THIS value and those property
names become visible identifiers bindings within the scope of the CATCH
clause after the function returns. In Edition 5, when an exception
parameter is called as a function, UNDEFINED is passed as the THIS
value.

13: In Edition 3, the algorithm for the production _FunctionExpression
with an _Identifier_ adds an object created as if by NEW OBJECT() to the
scope chain to serve as a scope for looking up the name of the function.
The identifier resolution rules (10.1.4 in Edition 3) when applied to
such an object will, if necessary, follow the object’s prototype chain
when attempting to resolve an identifier. This means all the properties
of Object.prototype are visible as identifiers within that scope. In
practice most implementations of Edition 3 have not implemented this
semantics. Edition 5 changes the specified semantics by using a
Declarative Environment Record to bind the name of the function.

14: In Edition 3, the algorithm for the production _SourceElements_ :
_SourceElements SourceElement_ did not correctly propagate statement
result values in the same manner as _Block_. This could result in the
EVAL function producing an incorrect result when evaluating a _Program_
text. In practice most implementations of Edition 3 have implemented the
correct propagation rather than what was specified in Edition 5.

15.10.6: RegExp.prototype is now a RegExp object rather than an instance
of Object. The value of its [[Class]] internal property which is
observable using Object.prototype.toString is now “RegExp” rather than
“Object”.

(informative)
Additions and Changes in the 5^th^ Edition that
Introduce Incompatibilities with the 3^rd^ Edition

7.1: Unicode format control characters are no longer stripped from
ECMAScript source text before processing. In Edition 5, if such a
character appears in a _StringLiteral_ or _RegularExpressionLiteral_ the
character will be incorporated into the literal where in Edition 3 the
character would not be incorporated into the literal.

7.2: Unicode character <BOM> is now treated as whitespace and its
presence in the middle of what appears to be an identifier could result
in a syntax error which would not have occurred in Edition 3

7.3: Line terminator characters that are preceded by an escape sequence
are now allowed within a string literal token. In Edition 3 a syntax
error would have been produced.

7.8.5: Regular expression literals now return a unique object each time
the literal is evaluated. This change is detectable by any programs that
test the object identity of such literal values or that are sensitive to
the shared side effects.

7.8.5: Edition 5 requires early reporting of any possible RegExp
constructor errors that would be produced when converting a
_RegularExpressionLiteral_ to a RegExp object. Prior to Edition 
implementations were permitted to defer the reporting of such errors
until the actual execution time creation of the object.

7.8.5: In Edition 5 unescaped “/” characters may appear as a
_CharacterClass_ in a regular expression literal. In Edition 3 such a
character would have been interpreted as the final character of the
literal.

10.4.2: In Edition 5, indirect calls to the EVAL function use the global
environment as both the variable environment and lexical environment for
the eval code. In Edition 3, the variable and lexical environments of
the caller of an indirect EVAL was used as the environments for the eval
code.

15.4.4: In Edition 5 all methods of ARRAY.PROTOTYPE are intentionally
generic. In Edition 3 TOSTRING and TOLOCALESTRING were not generic and
would throw a TYPEERROR exception if applied to objects that were not
instances of Array.

10.6: In Edition 5 the array indexed properties of argument objects that
correspond to actual formal parameters are enumerable. In Edition 3,
such properties were not enumerable.

10.6: In Edition 5 the value of the [[Class]] internal property of an
arguments object is "ARGUMENTS". In Edition 3, it was "OBJECT". This is
observable if TOSTRING is called as a method of an arguments object.

12.6.4: for-in statements no longer throw a TYPEERROR if the IN
expression evaluates to NULL or UNDEFINED. Instead, the statement
behaves as if the value of the expression was an object with no
enumerable properties.

15: In Edition 5, the following new properties are defined on built-in
objects that exist in Edition 3: OBJECT.GETPROTOTYPEOF,
OBJECT.GETOWNPROPERTYDESCRIPTOR, OBJECT.GETOWNPROPERTYNAMES,
OBJECT.CREATE, OBJECT.DEFINEPROPERTY, OBJECT.DEFINEPROPERTIES,
OBJECT.SEAL, OBJECT.FREEZE, OBJECT.PREVENTEXTENSIONS, OBJECT.ISSEALED,
OBJECT.ISFROZEN, OBJECT.ISEXTENSIBLE, OBJECT.KEYS,
FUNCTION.PROTOTYPE.BIND, ARRAY.PROTOTYPE.INDEXOF,
ARRAY.PROTOTYPE.LASTINDEXOF, ARRAY.PROTOTYPE.EVERY,
ARRAY.PROTOTYPE.SOME, ARRAY.PROTOTYPE.FOREACH, ARRAY.PROTOTYPE.MAP,
ARRAY.PROTOTYPE.FILTER, ARRAY.PROTOTYPE.REDUCE,
ARRAY.PROTOTYPE.REDUCERIGHT, STRING.PROTOTYPE.TRIM, DATE.NOW,
DATE.PROTOTYPE.TOISOSTRING, DATE.PROTOTYPE.TOJSON.

15: Implementations are now required to ignore extra arguments to
standard built-in methods unless otherwise explicitly specified. In
Edition 3 the handling of extra arguments was unspecified and
implementations were explicitly allowed to throw a TYPEERROR exception.

15.1.1: The value properties NAN, INFINITY, and UNDEFINED of the Global
Object have been changed to be read-only properties.

15.1.2.1. Implementations are no longer permitted to restrict the use of
eval in ways that are not a direct call. In addition, any invocation of
eval that is not a direct call uses the global environment as its
variable environment rather than the caller’s variable environment.

15.1.2.2: The specification of the function PARSEINT no longer allows
implementations to treat Strings beginning with a 0 character as octal
values.

15.3.4.3: In Edition 3, a TYPEERROR is thrown if the second argument
passed to FUNCTION.PROTOTYPE.APPLY is neither an array object nor an
arguments object. In Edition 5, the second argument may be any kind of
generic array-like object that has a valid LENGTH property.

15.3.4.3, 15.3.4.4: In Edition 3 passing UNDEFINED or NULL as the first
argument to either FUNCTION.PROTOTYPE.APPLY or FUNCTION.PROTOTYPE.CALL
causes the global object to be passed to the indirectly invoked target
function as the THIS value. If the first argument is a primitive value
the result of calling ToObject on the primitive value is passed as the
THIS value. In Edition 5, these transformations are not performed and
the actual first argument value is passed as the THIS value. This
difference will normally be unobservable to existing ECMAScript Edition
3 code because a corresponding transformation takes place upon
activation of the target function. However, depending upon the
implementation, this difference may be observable by host object
functions called using APPLY or CALL. In addition, invoking a standard
built-in function in this manner with NULL or UNDEFINED passed as the
this value will in many cases cause behaviour in Edition 5
implementations that differ from Edition 3 behaviour. In particular, in
Edition 5 built-in functions that are specified to actually use the
passed THIS value as an object typically throw a TYPEERROR exception if
passed NULL or UNDEFINED as the THIS value.

15.3.5.2: In Edition 5, the PROTOTYPE property of Function instances is
not enumerable. In Edition 3, this property was enumerable.

15.5.5.2: In Edition 5, the individual characters of a String object’s
[[PrimitiveValue] may be accessed as array indexed properties of the
String object. These properties are non-writable and non-configurable
and shadow any inherited properties with the same names. In Edition 3,
these properties did not exist and ECMAScript code could dynamically add
and remove writable properties with such names and could access
inherited properties with such names.

15.9.4.2: DATE.PARSE is now required to first attempt to parse its
argument as an ISO format string. Programs that use this format but
depended upon implementation specific behaviour (including failure) may
behave differently.

15.10.2.12: In Edition 5, \S now additionally matches <BOM>.

15.10.4.1: In Edition 3, the exact form of the String value of the
SOURCE property of an object created by the REGEXP constructor is
implementation defined. In Edition 5, the String must conform to certain
specified requirements and hence may be different from that produced by
an Edition 3 implementation.

15.10.6.4: In Edition 3, the result of REGEXP.PROTOTYPE.TOSTRING need
not be derived from the value of the RegExp object’s SOURCE property. In
Edition 5 the result must be derived from the SOURCE property in a
specified manner and hence may be different from the result produced by
an Edition 3 implementation.

15.11.2.1, 15.11.4.3: In Edition 5, if an initial value for the MESSAGE
property of an Error object is not specified via the ERROR constructor
the initial value of the property is the empty String. In Edition 3,
such an initial value is implementation defined.

15.11.4.4: In Edition 3, the result of ERROR.PROTOTYPE.TOSTRING is
implementation defined. In Edition 5, the result is fully specified and
hence may differ from some Edition 3 implementations.

15.12: In Edition 5, the name JSON is defined in the global environment.
In Edition 3, testing for the presence of that name will show it to be
undefined unless it is defined by the program or implementation.

(informative)
Technically Significant Corrections and Clarifications in the 5.1
Edition

7.8.4: CV definitions added for _DoubleStringCharacter_ ::
_LineContinuation_ and _SingleStringCharacter_ :: _LineContinuation_.

10.2.1.1.3: The argument S is not ignored. It controls whether an
exception is thrown when attempting to set an immutable binding.

10.2.1.2.2: In algorithm step 5, TRUE is passed as the last argument to
[[DefineOwnProperty]].

10.5: Former algorithm step 5.e is now 5.f and a new step 5.e was added
to restore compatibility with 3^rd^ Edition when redefining global
functions.

11.5.3: In the final bullet item, use of IEEE 754 round-to-nearest mode
is specified.

12.6.3: Missing ToBoolean restored in step 3.a.ii of both algorithms.

12.6.4: Additional final sentences in each of the last two paragraphs
clarify certain property enumeration requirements.

12.7, 12.8, 12.9: BNF modified to clarify that a CONTINUE or BREAK
statement without an _Identifier_ or a RETURN statement without an
_Expression_ may have a _LineTerminator_ before the semi-colon.

12.14: Step 3 of algorithm 1 and step 2.a of algorithm 3 are corrected
such that the value field of _B_ is passed as a parameter rather than
_B_ itself.

15.1.2.2: In step 2 of algorithm, clarify that _S_ may be the empty
string.

15.1.2.3: In step 2 of algorithm clarify that _trimmedString_ may be the
empty string.

15.1.3: Added notes clarifying that ECMAScript’s URI syntax is based
upon RFC 2396 and not the newer RFC 3986. In the algorithm for Decode, a
step was removed that immediately preceded the current step 4.d.vii.10.a
because it tested for a condition that cannot occur.

15.2.3.7: Corrected use of variable _P_ in steps 5 and 6 of algorithm.

15.2.4.2: Edition 5 handling of UNDEFINED and NULL as THIS value caused
existing code to fail. Specification modified to maintain compatibility
with such code. New steps 1 and 2 added to the algorithm.

15.3.4.3: Steps 5 and 7 of Edition 5 algorithm have been deleted because
they imposed requirements upon the _argArray_ argument that are
inconsistent with other uses of generic array-like objects.

15.4.4.12: In step 9.a, incorrect reference to _relativeStart_ was
replaced with a reference to _actualStart_.

15.4.4.15: Clarified that the default value for _fromIndex_ is the
length minus 1 of the array.

15.4.4.18: In step 9 of the algorithm, UNDEFINED is now the specified
return value.

15.4.4.22: In step 9.c.ii the first argument to the [[Call]] internal
method has been changed to UNDEFINED for consistency with the definition
of Array.prototype.reduce.

15.4.5.1: In Algorithm steps 3.l.ii and 3.l.iii the variable name was
inverted resulting in an incorrectly inverted test.

15.5.4.9: Normative requirement concerning canonically equivalent
strings deleted from paragraph following algorithm because it is listed
as a recommendation in NOTE 2.

15.5.4.14: In split algorithm step 11.a and 13.a, the positional order
of the arguments to _SplitMatch_ was corrected to match the actual
parameter signature of _SplitMatch_. In step 13.a.iii.7.d, _lengthA_
replaces _A_.length.

15.5.5.2: In first paragraph, removed the implication that the
individual character property access had “array index” semantics.
Modified algorithm steps 3 and 5 such that they do not enforce “array
index” requirement.

15.9.1.15: Specified legal value ranges for fields that lacked them.
Eliminated “time-only” formats. Specified default values for all
optional fields.

15.10.2.2: The step numbers of the algorithm for the internal closure
produced by step 2 were incorrectly numbered in a manner that implied
that they were steps of the outer algorithm.

15.10.2.6: In the abstract operation _IsWordChar_ the first character in
the list in step 3 is “A” rather than “A”.

15.10.2.8: In the algorithm for the closure returned by the abstract
operation _CharacterSetMatcher_, the variable defined by step 3 and
passed as an argument in step 4 was renamed to _ch_ in order to avoid a
name conflict with a formal parameter of the closure.

15.10.6.2: Step 9.e was deleted because It performed an extra increment
of _i_.

15.11.1.1: Removed requirement that the message own property is set to
the empty String when the _message_ argument is UNDEFINED.

15.11.1.2: Removed requirement that the message own property is set to
the empty String when the _message_ argument is UNDEFINED.

15.11.4.4: Steps 6-10 modified/added to correctly deal with missing or
empty message property value.

15.11.1.2: Removed requirement that the message own property is set to
the empty String when the _message_ argument is UNDEFINED.

15.12.3: In step 10.b.iii of the _JA_ internal operation, the last
element of the concatenation is “]”.

B.2.1: Added to NOTE that the encoding is based upon RFC 1738 rather
than the newer RFC 3986.

Annex C: An item was added corresponding to 7.6.12 regarding
_FutureReservedWords_ in strict mode.

Bibliography

IEEE Std 754-2008: IEEE Standard for Floating-Point Arithmetic.
Institute of Electrical and Electronic Engineers, New York (2008)

The Unicode Consortium. The Unicode Standard, Version 3.0, defined by:
The Unicode Standard, Version 3.0 (Reading, MA, Addison-Wesley, 2000.
ISBN 0-201-61633-5)

Unicode Inc. (2010), Unicode Technical Report #15: Unicode Normalization
Forms

ISO 8601:2004(E) _Data elements and interchange formats – Information
interchange -- Representation of dates and times_

RFC 1738 "Uniform Resource Locators (URL)", available at
<_http://tools.ietf.org/html/rfc1738_>

RFC 2396 "Uniform Resource Identifiers (URI): Generic Syntax", available
at <_http://tools.ietf.org/html/rfc2396_>

RFC 3629 "UTF-8, a transformation format of ISO 10646", available at
<_http://tools.ietf.org/html/rfc3629_>

RFC 4627 "The application/json Media Type for JavaScript Object Notation
(JSON)" , available at <_http://tools.ietf.org/html/rfc4627_>

[1] Note: Please note that for ECMAScript Edition 4 the Ecma standard
number “ECMA-262 Edition 4” was reserved but not used in the Ecma
publication process. Therefore “ECMA-262 Edition 4” as an Ecma
International publication does not exist.
