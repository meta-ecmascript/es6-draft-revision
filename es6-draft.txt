Contents Page

Introduction vii

_1_ _Scope_ 

_2_ _Conformance_ 

_3_ _Normative references_ 

_4_ _Overview_ 

_4.1_ _Web Scripting_ 

_4.2_ _Language Overview_ 

_4.2.1_ _Objects_ 

_4.2.2_ _The Strict Variant of ECMAScript_ 

_4.3_ _Terms and definitions_ 

_5_ _Notational Conventions_ 

_5.1_ _Syntactic and Lexical Grammars_ 

_5.1.1_ _Context-Free Grammars_ 

_5.1.2_ _The Lexical and RegExp Grammars_ 

_5.1.3_ _The Numeric String Grammar_ 

_5.1.4_ _The Syntactic Grammar_ 

_5.1.5_ _The JSON Grammar_ 

_5.1.6_ _Grammar Notation_ 

_5.2_ _Algorithm Conventions_ 

_5.3 Static Semantic Rules_ 

_6_ _Source Text_ 

_7_ _Lexical Conventions_ 

_7.1_ _Unicode Format-Control Characters_ 

_7.2_ _White Space_ 

_7.3_ _Line Terminators_ 

_7.4_ _Comments_ 

_7.5_ _Tokens_ 

_7.6_ _Identifier Names and Identifiers_ 

_7.6.1_ _Reserved Words_ 

_7.7_ _Punctuators_ 

_7.8_ _Literals_ 

_7.8.1_ _Null Literals_ 

_7.8.2_ _Boolean Literals_ 

_7.8.3_ _Numeric Literals_ 

_7.8.4_ _Regular Expression Literals_ 

_7.8.5_ _Template Literal Lexical Components_ 

_7.8.6_ _String Literals_ 

_7.9_ _Automatic Semicolon Insertion_ 

_7.9.1_ _Rules of Automatic Semicolon Insertion_ 

_7.9.2_ _Examples of Automatic Semicolon Insertion_ 

_8_ _Types_ 

_8.1_ _ECMAScript Language Types_ 

_8.1.1_ _The Undefined Type_ 

_8.1.2_ _The Null Type_ 

_8.1.3_ _The Boolean Type_ 

_8.1.4_ _The String Type_ 

_8.1.5_ _The Number Type_ 

_8.1.6 The Symbol Type_ 

_8.1.7_ _The Object Type_ 

_8.2_ _ECMAScript Specification Types_ 

_8.2.1 Data Blocks_ 

_8.2.2_ _The List and Record Specification Type_ 

_8.2.3_ _The Completion Record Specification Type_ 

_8.2.4_ _The Reference Specification Type_ 

_8.2.5_ _The Property Descriptor Specification Type_ 

_8.2.6_ _The Lexical Environment and Environment Record Specification
Types_ 52

_8.3_ _Ordinary Object Internal Methods and Internal Data Properties_ 

_8.3.1_ _[[GetInheritance]] ( )_ 

_8.3.2_ _[[SetInheritance]] (V)_ 

_8.3.3_ _[[HasIntegrity]] ( Level )_ 

_8.3.4_ _[[SetIntegrity]] ( Level )_ 

_8.3.5_ _[[HasOwnProperty]] (P)_ 

_8.3.6_ _[[GetOwnProperty]] (P)_ 

_8.3.7_ _[[DefineOwnProperty]] (P, Desc)_ 

_8.3.8 [[HasProperty]](P)_ 

_8.3.9_ _[[Get]] (P, Receiver)_ 

_8.3.10_ _[[Set]] ( P, V, Receiver)_ 

_8.3.11_ _[[Delete]] (P)_ 

_8.3.12_ _[[Enumerate]] ()_ 

_8.3.13_ _[[OwnPropertyKeys]] ( )_ 

_8.3.14_ _ObjectCreate(proto, internalDataList) Abstract Operation_ 

_8.3.15_ _Ordinary Function Objects_ 

_8.4_ _Built-in Exotic Object Internal Methods and Data Fields_ 

_8.4.1 Bound Function Exotic Objects_ 

_8.4.2 Array Exotic Objects_ 

_8.4.3 String Exotic Objects_ 

_8.4.4 Exotic Arguments Objects_ 

_8.4.5 Integer Indexed Delegation Exotic Objects_ 

_8.4.6 Built-in Function Objects_ 

_8.5_ _Proxy Object Internal Methods and Internal Data Properties_ 

_8.5.1_ _[[GetInheritance]] ( )_ 

_8.5.3_ _[[HasIntegrity]] ( Level )_ 

_8.5.4_ _[[SetIntegrity]] ( Level )_ 

_8.5.5_ _[[HasOwnProperty]] (P)_ 

_8.5.6_ _[[GetOwnProperty]] (P)_ 

_8.5.7_ _[[DefineOwnProperty]] (P, Desc)_ 

_8.5.8_ _[[HasProperty]] (P)_ 

_8.5.9_ _[[Get]] (P, Receiver)_ 

_8.5.10_ _[[Set]] ( P, V, Receiver)_ 

_8.5.11_ _[[Delete]] (P)_ 

_8.5.12_ _[[Enumerate]] ()_ 

_8.5.13_ _[[OwnPropertyKeys]] ( )_ 

_8.5.14_ _[[Call]] (thisArgument, argumentsList)_ 

_8.5.15_ _[[Construct]] Internal Method_ 

_9 Abstract Operations_ 

_9.1_ _Type Conversion and Testing_ 

_9.1.1_ _ToPrimitive_ 

_9.1.2_ _ToBoolean_ 

_9.1.3_ _ToNumber_ 

_9.1.4_ _ToInteger_ 

_9.1.5_ _ToInt32: (Signed 32 Bit Integer)_ 

_9.1.6_ _ToUint32: (Unsigned 32 Bit Integer)_ 

_9.1.7_ _ToUint16: (Unsigned 16 Bit Integer)_ 

_9.1.8_ _ToString_ 

_9.1.9_ _ToObject_ 

_9.1.10_ _ToPropertyKey_ 

_9.2_ _Testing and Comparison Operations_ 

_9.2.1_ _CheckObjectCoercible_ 

_9.2.2_ _IsCallable_ 

_9.2.3_ _SameValue(x, y)_ 

_9.2.4_ _SameValueZero(x, y)_ 

_9.2.5_ _IsConstructor_ 

_9.2.6_ _IsPropertyKey_ 

_9.2.7_ _IsExtensible (O)_ 

_9.3_ _Operations on Objects_ 

_9.3.1_ _Get (O, P)_ 

_9.3.2_ _Put (O, P, V, Throw)_ 

_9.3.3_ _CreateOwnDataProperty (O, P, V)_ 

_9.3.4_ _DefinePropertyOrThrow (O, P, desc)_ 

_9.3.5_ _DeletePropertyOrThrow (O, P)_ 

_9.3.6_ _HasProperty (O, P)_ 

_9.3.7_ _GetMethod (O, P)_ 

_9.3.8_ _Invoke(O,P, [args])_ 

_9.3.9_ _SetIntegrityLevel (O, level)_ 

_9.3.10_ _TestIntegrityLevel (O, level)_ 

_9.3.11_ _CreateArrayFromList (elements)_ 

_9.3.12_ _OrdinaryHasInstance (C, O)_ 

_9.3.13_ _GetPrototypeFromConstructor ( constructor,
intrinsicDefaultProto )_ 90

_9.3.14_ _OrdinaryCreateFromConstructor ( constructor,
intrinsicDefaultProto, internalDataList )_ 90

_10_ _Executable Code and Execution Contexts_ 

_10.1_ _Types of Executable Code_ 

_10.1.1_ _Strict Mode Code_ 

_10.1.2_ _Non-ECMAScript Functions_ 

_10.2_ _Lexical Environments_ 

_10.2.1_ _Environment Records_ 

_10.2.2_ _Lexical Environment Operations_ 

_10.3_ _Code Realms_ 

_10.4_ _Execution Contexts_ 

_10.4.1_ _Identifier Resolution_ 

_10.4.2_ _GetThisEnvironment_ 

_10.4.3_ _This Resolution_ 

_10.4.4_ _GetGlobalObject_ 

_10.5_ _Declaration Binding Instantiation_ 

_10.5.1_ _Global Declaration Instantiation_ 

_10.5.2_ _Module Declaration Instantiation_ 

_10.5.3_ _Function Declaration Instantiation_ 

_10.5.4_ _Block Declaration Instantiation_ 

_10.5.5 Eval Declaration Instantiation_ 

_10.6_ _Arguments Object_ 

_11_ _Expressions_ 

_11.1_ _Primary Expressions_ 

_11.1.1_ _The this Keyword_ 

_11.1.2_ _Identifier Reference_ 

_11.1.3_ _Literals_ 

_11.1.4_ _Array Initialiser_ 

_11.1.5_ _Object Initialiser_ 

_11.1.6_ _Function Defining Expressions_ 

_11.1.7_ _Generator Comprehensions_ 

_11.1.8_ _Regular Expression Literals_ 

_11.1.9_ _Template Literals_ 

_11.1.10_ _The Grouping Operator_ 

_11.2_ _Left-Hand-Side Expressions_ 

_11.2.1_ _Property Accessors_ 

_11.2.2_ _The new Operator_ 

_11.2.3_ _Function Calls_ 

_11.2.4_ _The super Keyword_ 

_11.2.5_ _Argument Lists_ 

_11.2.6_ _Tagged Templates_ 

_11.3_ _Postfix Expressions_ 

_11.3.1_ _Postfix Increment Operator_ 

_11.3.2_ _Postfix Decrement Operator_ 

_11.4_ _Unary Operators_ 

_11.4.1_ _The delete Operator_ 

_11.4.2_ _The void Operator_ 

_11.4.3_ _The typeof Operator_ 

_11.4.4_ _Prefix Increment Operator_ 

_11.4.5_ _Prefix Decrement Operator_ 

_11.4.6_ _Unary + Operator_ 

_11.4.7_ _Unary - Operator_ 

_11.4.8_ _Bitwise NOT Operator ( ~ )_ 

_11.4.9_ _Logical NOT Operator ( ! )_ 

_11.5_ _Multiplicative Operators_ 

_11.5.1_ _Applying the * Operator_ 

_11.5.2_ _Applying the / Operator_ 

_11.5.3_ _Applying the % Operator_ 

_11.6_ _Additive Operators_ 

_11.6.1_ _The Addition operator ( + )_ 

_11.6.2_ _The Subtraction Operator ( - )_ 

_11.6.3_ _Applying the Additive Operators to Numbers_ 

_11.7_ _Bitwise Shift Operators_ 

_11.7.1_ _The Left Shift Operator ( << )_ 

_11.7.2_ _The Signed Right Shift Operator ( >> )_ 

_11.7.3_ _The Unsigned Right Shift Operator ( >>> )_ 

_11.8_ _Relational Operators_ 

_11.8.1 Runtime Semantics_ 

_11.9_ _Equality Operators_ 

_11.9.1 Runtime Semantics_ 

_11.10_ _Binary Bitwise Operators_ 

_11.11_ _Binary Logical Operators_ 

_11.12_ _Conditional Operator ( ? : )_ 

_11.13_ _Assignment Operators_ 

_Static Semantics_ 

_Runtime Semantics_ 

_11.13.1 Destructuring Assignment_ 

_11.14_ _Comma Operator ( , )_ 

_12_ _Statements and Declarations_ 

_Static Semantics_ 

_Runtime Semantics_ 

_12.1_ _Block_ 

_12.2_ _Declarations and the Variable Statement_ 

_12.2.1_ _Let and Const Declarations_ 

_12.2.2_ _Variable Statement_ 

_12.2.4_ _Destructuring Binding Patterns_ 

_12.3_ _Empty Statement_ 

_12.4_ _Expression Statement_ 

_12.5_ _The if Statement_ 

_12.6_ _Iteration Statements_ 

_12.6.1_ _The do-while Statement_ 

_12.6.2_ _The while Statement_ 

_12.6.3_ _The for Statement_ 

_12.6.4_ _The for-in and for-of Statements_ 

_12.7_ _The continue Statement_ 

_12.8_ _The break Statement_ 

_12.9_ _The return Statement_ 

_12.10_ _The with Statement_ 

_12.11_ _The switch Statement_ 

_12.12_ _Labelled Statements_ 

_12.13_ _The throw Statement_ 

_12.14_ _The try Statement_ 

_12.15_ _The debugger statement_ 

_13_ _Functions and Generators_ 

_13.1_ _Function Definitions_ 

_13.2_ _Arrow Function Definitions_ 

_13.3_ _Method Definitions_ 

_13.4_ _Generator Function Definitions_ 

_13.5_ _Class Definitions_ 

_13.6 Tail Position Calls_ 

_14_ _Scripts and Modules_ 

_14.1 Script_ 

_14.1.1_ _Directive Prologues and the Use Strict Directive_ 

_14.2 Modules_ 

_15_ _Standard Built-in ECMAScript Objects_ 

_15.1_ _The Global Object_ 

_15.1.1_ _Value Properties of the Global Object_ 

_15.1.2_ _Function Properties of the Global Object_ 

_15.1.3_ _URI Handling Function Properties_ 

_15.1.4_ _Constructor Properties of the Global Object_ 

_15.1.5_ _Other Properties of the Global Object_ 

_15.2_ _Object Objects_ 

_15.2.1_ _The Object Constructor Called as a Function_ 

_15.2.2_ _The Object Constructor_ 

_15.2.3_ _Properties of the Object Constructor_ 

_15.2.4_ _Properties of the Object Prototype Object_ 

_15.2.5_ _Properties of Object Instances_ 

_15.3_ _Function Objects_ 

_15.3.1_ _The Function Constructor_ 

_15.3.2_ _Properties of the Function Constructor_ 

_15.3.3_ _Properties of the Function Prototype Object_ 

_15.3.4_ _Function Instances_ 

_15.4_ _Array Objects_ 

_15.4.1_ _The Array Constructor_ 

_15.4.2_ _Properties of the Array Constructor_ 

_15.4.3_ _Properties of the Array Prototype Object_ 

_15.4.4_ _Properties of Array Instances_ 

_15.4.5_ _Array Iterator Object Structure_ 

_15.5_ _String Objects_ 

_15.5.1_ _The String Constructor Called as a Function_ 

_15.5.2_ _The String Constructor_ 

_15.5.3_ _Properties of the String Constructor_ 

_15.5.4_ _Properties of the String Prototype Object_ 

_15.5.5_ _Properties of String Instances_ 

_15.6_ _Boolean Objects_ 

_15.6.1_ _The Boolean Constructor Called as a Function_ 

_15.6.2_ _The Boolean Constructor_ 

_15.6.3_ _Properties of the Boolean Constructor_ 

_15.6.4_ _Properties of the Boolean Prototype Object_ 

_15.6.5_ _Properties of Boolean Instances_ 

_15.7_ _Number Objects_ 

_15.7.1_ _The Number Constructor Called as a Function_ 

_15.7.2_ _The Number Constructor_ 

_15.7.3_ _Properties of the Number Constructor_ 

_15.7.4_ _Properties of the Number Prototype Object_ 

_15.7.5_ _Properties of Number Instances_ 

_15.8_ _The Math Object_ 

_15.8.1_ _Value Properties of the Math Object_ 

_15.8.2_ _Function Properties of the Math Object_ 

_15.9_ _Date Objects_ 

_15.9.1_ _Overview of Date Objects and Definitions of Abstract
Operations_ 298

_15.9.2_ _The Date Constructor Called as a Function_ 

_15.9.3_ _The Date Constructor_ 

_15.9.4_ _Properties of the Date Constructor_ 

_15.9.5_ _Properties of the Date Prototype Object_ 

_15.9.6_ _Properties of Date Instances_ 

_15.10_ _RegExp (Regular Expression) Objects_ 

_15.10.1_ _Patterns_ 

_15.10.2_ _Pattern Semantics_ 

_15.10.3_ _The RegExp Constructor Called as a Function_ 

_15.10.4_ _The RegExp Constructor_ 

_15.10.5_ _Properties of the RegExp Constructor_ 

_15.10.6_ _Properties of the RegExp Prototype Object_ 

_15.10.7_ _Properties of RegExp Instances_ 

_15.11_ _Error Objects_ 

_15.11.1_ _The Error Constructor Called as a Function_ 

_15.11.2_ _The Error Constructor_ 

_15.11.3_ _Properties of the Error Constructor_ 

_15.11.4_ _Properties of the Error Prototype Object_ 

_15.11.5_ _Properties of Error Instances_ 

_15.11.6_ _Native Error Types Used in This Standard_ 

_15.11.7_ __NativeError Object Structure__ 

_15.12_ _The JSON Object_ 

_15.12.1_ _The JSON Grammar_ 

_15.12.2_ _JSON.parse ( text [ , reviver ] )_ 

_15.12.3_ _JSON.stringify ( value [ , replacer [ , space ] ] )_ 

_15.13_ _Binary Data Objects_ 

_15.13.1 The BinaryData Module_ 

_15.13.2 The BinaryData.Type Object_ 

_15.13.3 The BinaryData.ArrayType Object_ 

_15.13.4 The BinaryData.StructType Object_ 

_15.13.5 ArrayBuffer Objects_ 

_15.13.6 _TypedArray_ Object Structures_ 

_15.13.7 DataView Objects_ 

_15.14 Map Objects_ 

_15.14.1_ _The Map Constructor Called as a Function_ 

_15.14.2_ _The Map Constructor_ 

_15.14.3_ _Properties of the Map Constructor_ 

_15.14.4_ _Properties of the Map Prototype Object_ 

_15.14.5_ _Properties of Map Instances_ 

_15.14.6_ _Map Iterator Object Structure_ 

_15.15 WeakMap Objects_ 

_15.15.1_ _The WeakMap Constructor Called as a Function_ 

_15.15.2_ _The WeakMap Constructor_ 

_15.15.3_ _Properties of the WeakMap Constructor_ 

_15.15.4_ _Properties of the WeakMap Prototype Object_ 

_15.15.5_ _Properties of WeakMap Instances_ 

_15.16 Set Objects_ 

_15.16.1_ _The Set Constructor Called as a Function_ 

_15.16.2_ _The Set Constructor_ 

_15.16.3_ _Properties of the Set Constructor_ 

_15.16.4_ _Properties of the Set Prototype Object_ 

_15.16.5_ _Properties of Set Instances_ 

_15.16.6_ _Set Iterator Object Structure_ 

_15.17 The Reflect Module_ 

_15.17.1_ _Exported Function Properties Reflecting the Essentional
Internal Methods_ 383

_15.18 Proxy Objects_ 

_15.19 The "std:iteration" Module_ 

_15.19.1 Common Iteration Interfaces_ 

_15.19.2_ _"std:iteration" Exports_ 

_15.19.3_ _GeneratorFunction Objects_ 

_15.19. 4 Generator Objects_ 

_16_ _Errors_ 

_Annex A (informative) Grammar Summary_ 

_A.1_ _Lexical Grammar_ 

_A.2_ _Number Conversions_ 

_A.3_ _Expressions_ 

_A.4_ _Statements_ 

_A.5_ _Functions and Scripts_ 

_A.6_ _Universal Resource Identifier Character Classes_ 

_A.7_ _Regular Expressions_ 

_A.8_ _JSON_ 

_A.8.1_ _JSON Lexical Grammar_ 

_A.8.2_ _JSON Syntactic Grammar_ 

_Annex B (normative) Additional ECMAScript Features for Web Browsers
4

_B.1_ _Additional Syntax_ 

_B.1.1_ _Numeric Literals_ 

_B.1.2_ _String Literals_ 

_B.1.3_ _HTML-like Comments_ 

_B.2_ _Additional Properties_ 

_B.2.1_ _Additional Properties of the Global Object_ 

_B.2.2_ _Additional Properties of the Object.prototype Object_ 

_B.2.3_ _Additional Properties of the String.prototype Object_ 

_B.2.4_ _Additional Properties of the Date.prototype Object_ 

_B.2.5_ _Additional Properties of the RegExp.prototype Object_ 

_B.3_ _Other Additional Features_ 

_B.3.1_ ___proto___ Property Names in Object Initialisers_ 

_B.3.2_ _Web Legacy Compatibility for Block-Level Function Declarations
4

_Annex C (informative) The Strict Mode of ECMAScript_ 

_Annex D (informative) Corrections and Clarifications with Possible
Compatibility Impact_ 428

_Annex E (informative) Additions and Changes that Introduce
Incompatibilities with Prior Editions_ 432

_In the 6^th^ Edition_ 

_In the 5^th^ Edition_ 

_Annex F (informative) Static Semantic Rule Cross Reference_ 

_Scrap Heap_ 

_8.4.4 Symbol Exotic Objects_ 

_8.3.10_ _[[Enumerate]] (includePrototype, onlyEnumerable )_ 

_9.1.11 ToPositiveInteger_ 

_10.5.3_ _Function Declaration Instantiation_ 

_F.1.1_ _The __proto__ pseudo property._ 

Introduction

This Ecma Standard is based on several originating technologies, the
most well known being JavaScript (Netscape) and JScript (Microsoft). The
language was invented by Brendan Eich at Netscape and first appeared in
that company’s Navigator 2.0 browser. It has appeared in all subsequent
browsers from Netscape and in all browsers from Microsoft starting with
Internet Explorer 3.0.

The development of this Standard started in November 1996. The first
edition of this Ecma Standard was adopted by the Ecma General Assembly
of June 1997.

That Ecma Standard was submitted to ISO/IEC JTC 1 for adoption under the
fast-track procedure, and approved as international standard ISO/IEC
16262, in April 1998. The Ecma General Assembly of June 1998 approved
the second edition of ECMA-262 to keep it fully aligned with ISO/IEC
16262. Changes between the first and the second edition are editorial in
nature.

The third edition of the Standard introduced powerful regular
expressions, better string handling, new control statements, try/catch
exception handling, tighter definition of errors, formatting for numeric
output and minor changes in anticipation of forthcoming
internationalisation facilities and future language growth. The third
edition of the ECMAScript standard was adopted by the Ecma General
Assembly of December 1999 and published as ISO/IEC 16262:2002 in June
2002.

Since publication of the third edition, ECMAScript has achieved massive
adoption in conjunction with the World Wide Web where it has become the
programming language that is supported by essentially all web browsers.
Significant work was done to develop a fourth edition of ECMAScript.
Although that work was not completed and not published[1] as the fourth
edition of ECMAScript, it informs continuing evolution of the language.
The fifth edition of ECMAScript (published as ECMA-262 5^th^ edition)
codifies de facto interpretations of the language specification that
have become common among browser implementations and adds support for
new features that have emerged since the publication of the third
edition. Such features include accessor properties, reflective creation
and inspection of objects, program control of property attributes,
additional array manipulation functions, support for the JSON object
encoding format, and a strict mode that provides enhanced error checking
and program security.

The edition 5.1 of the ECMAScript Standard has been fully aligned with
the third edition of the international standard ISO/IEC 16262:2011.

This present sixth edition of the Standard………

ECMAScript is a vibrant language and the evolution of the language is
not complete. Significant technical enhancement will continue with
future editions of this specification.

This Ecma Standard has been adopted by the General Assembly of <month>
<year>.

_"DISCLAIMER

_This draft document may be copied and furnished to others, and
derivative works that comment on or otherwise explain it or assist in
its implementation may be prepared, copied, published, and distributed,
in whole or in part, without restriction of any kind, provided that the
above copyright notice and this section are included on all such copies
and derivative works. However, this document itself may not be modified
in any way, including by removing the copyright notice or references to
Ecma International, except as needed for the purpose of developing any
document or deliverable produced by Ecma International._

_This disclaimer is valid only prior to final version of this document.
After approval all rights on the standard are reserved by Ecma
International._

_The limited permissions are granted through the standardization phase
and will not be revoked by Ecma International or its successors or
assigns during this time._

_This document and the information contained herein is provided on an
"AS IS" basis and ECMA INTERNATIONAL DISCLAIMS ALL WARRANTIES, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
THE INFORMATION HEREIN WILL NOT INFRINGE ANY OWNERSHIP RIGHTS OR ANY
IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE."_

ECMAScript Language Specification



SCOPE


This Standard defines the ECMAScript scripting language.



CONFORMANCE


A conforming implementation of ECMAScript must provide and support all
the types, values, objects, properties, functions, and program syntax
and semantics described in this specification.

A conforming implementation of this Standard shall interpret characters
in conformance with the Unicode Standard, Version 5.1.0 or later and
ISO/IEC 10646. If the adopted ISO/IEC 10646-1 subset is not otherwise
specified, it is presumed to be the Unicode set, collection 10646.

A conforming implementation of ECMAScript is permitted to provide
additional types, values, objects, properties, and functions beyond
those described in this specification. In particular, a conforming
implementation of ECMAScript is permitted to provide properties not
described in this specification, and values for those properties, for
objects that are described in this specification.

A conforming implementation of ECMAScript is permitted to support
program and regular expression syntax not described in this
specification. In particular, a conforming implementation of ECMAScript
is permitted to support program syntax that makes use of the “future
reserved words” listed in 7.6.1.2 of this specification.



NORMATIVE REFERENCES


The following referenced documents are indispensable for the application
of this document. For dated references, only the edition cited applies.
For undated references, the latest edition of the referenced document
(including any amendments) applies.

ISO/IEC 9899:1996_, Programming Languages – C, including amendment 1 and
technical corrigenda 1 and 2_

ISO/IEC 10646:2003: _Information Technology – Universal Multiple-Octet
Coded Character Set (UCS) plus Amendment 1:2005, Amendment 2:2006,
Amendment 3:2008, and Amendment 4:2008_, plus additional amendments and
corrigenda, or successor

_The Unicode Standard, Version 5.0_, as amended by Unicode 5.1.0, or
successor

_Unicode Standard Annex #15, Unicode Normalization Forms, version
Unicode 5.1.0_, or successor

_Unicode Standard Annex #31, Unicode Identifiers and Pattern Syntax,
version Unicode 5.1.0_, or successor.

This section contains a non-normative overview of the ECMAScript
language.

ECMAScript is an object-oriented programming language for performing
computations and manipulating computational objects within a host
environment. ECMAScript as defined here is not intended to be
computationally self-sufficient; indeed, there are no provisions in this
specification for input of external data or output of computed results.
Instead, it is expected that the computational environment of an
ECMAScript program will provide not only the objects and other
facilities described in this specification but also certain
environment-specific objects, whose description and behaviour are beyond
the scope of this specification except to indicate that they may provide
certain properties that can be accessed and certain functions that can
be called from an ECMAScript program.

A _SCRIPTING LANGUAGE_ is a programming language that is used to
manipulate, customise, and automate the facilities of an existing
system. In such systems, useful functionality is already available
through a user interface, and the scripting language is a mechanism for
exposing that functionality to program control. In this way, the
existing system is said to provide a host environment of objects and
facilities, which completes the capabilities of the scripting language.
A scripting language is intended for use by both professional and
non-professional programmers. ECMAScript was originally designed to be
used as a scripting language, but has become widely used as a general
purpose programming language.

ECMAScript was originally designed to be a _WEB SCRIPTING LANGUAGE_,
providing a mechanism to enliven Web pages in browsers and to perform
server computation as part of a Web-based client-server architecture.
ECMAScript is now used both as a general propose programming language
and to provide core scripting capabilities for a variety of host
environments. Therefore the core language is specified in this document
apart from any particular host environment.

Some of the facilities of ECMAScript are similar to those used in other
programming languages; in particular Java, Self, and Scheme as
described in:

Gosling, James, Bill Joy and Guy Steele. The Java^^ Language
Specification. Addison Wesley Publishing Co., 1996.

Ungar, David, and Smith, Randall B. Self: The Power of Simplicity.
OOPSLA '87 Conference Proceedings, pp. 227–241, Orlando, FL, October
1987.

IEEE Standard for the Scheme Programming Language. IEEE Std 1178-1990.


4.1 Web Scripting

A web browser provides an ECMAScript host environment for client-side
computation including, for instance, objects that represent windows,
menus, pop-ups, dialog boxes, text areas, anchors, frames, history,
cookies, and input/output. Further, the host environment provides a
means to attach scripting code to events such as change of focus, page
and image loading, unloading, error and abort, selection, form
submission, and mouse actions. Scripting code appears within the HTML
and the displayed page is a combination of user interface elements and
fixed and computed text and images. The scripting code is reactive to
user interaction and there is no need for a main program.

A web server provides a different host environment for server-side
computation including objects representing requests, clients, and files;
and mechanisms to lock and share data. By using browser-side and
server-side scripting together, it is possible to distribute computation
between the client and server while providing a customised user
interface for a Web-based application.

Each Web browser and server that supports ECMAScript supplies its own
host environment, completing the ECMAScript execution environment.


4.2 Language Overview

The following is an informal overview of ECMAScript—not all parts of the
language are described. This overview is not part of the standard
proper.

ECMAScript is object-based: basic language and host facilities are
provided by objects, and an ECMAScript program is a cluster of
communicating objects. An ECMAScript _OBJECT_ is a collection of
_PROPERTIES_ each with zero or more _ATTRIBUTES_ that determine how each
property can be used—for example, when the Writable attribute for a
property is set to FALSE, any attempt by executed ECMAScript code to
change the value of the property fails. Properties are containers that
hold other objects, _PRIMITIVE VALUES_, or _FUNCTIONS_. A primitive
value is a member of one of the following built-in types: UNDEFINED,
NULL, SYMBOL, BOOLEAN, NUMBER, and STRING; an object is a member of the
remaining built-in type OBJECT; and a function is a callable object. A
function that is associated with an object via a property is a _METHOD_.

ECMAScript defines a collection of _BUILT-IN OBJECTS_ that round out the
definition of ECMAScript entities. These built-in objects include the
global object, the OBJECT object, the FUNCTION object, the ARRAY object,
the STRING object, the BOOLEAN object, the NUMBER object, the MATH
object, the DATE object, the REGEXP object, the JSON object, and the
Error objects ERROR, EVALERROR, RANGEERROR, REFERENCEERROR, SYNTAXERROR,
TYPEERROR and URIERROR.

ECMAScript also defines a set of built-in _OPERATORS_. ECMAScript
operators include various unary operations, multiplicative operators,
additive operators, bitwise shift operators, relational operators,
equality operators, binary bitwise operators, binary logical operators,
assignment operators, and the comma operator.

ECMAScript syntax intentionally resembles Java syntax. ECMAScript syntax
is relaxed to enable it to serve as an easy-to-use scripting language.
For example, a variable is not required to have its type declared nor
are types associated with properties, and defined functions are not
required to have their declarations appear textually before calls to
them.

4.2.1 Objects

ECMAScript does not use classes such as those in C++, Smalltalk, or
Java. Instead objects may be created in various ways including via a
literal notation or via _CONSTRUCTORS_ which create objects and then
execute code that initialises all or part of them by assigning initial
values to their properties. Each constructor is a function that has a
property named “PROTOTYPE” that is used to implement _PROTOTYPE-BASED
INHERITANCE_ and _SHARED PROPERTIES_. Objects are created by using
constructors in NEW expressions; for example, NEW DATE(2009,11) creates
a new Date object. Invoking a constructor without using NEW has
consequences that depend on the constructor. For example, DATE()
produces a string representation of the current date and time rather
than an object.

Every object created by a constructor has an implicit reference (called
the object’s _prototype_) to the value of its constructor’s “PROTOTYPE”
property. Furthermore, a prototype may have a non-null implicit
reference to its prototype, and so on; this is called the _prototype
chain_. When a reference is made to a property in an object, that
reference is to the property of that name in the first object in the
prototype chain that contains a property of that name. In other words,
first the object mentioned directly is examined for such a property; if
that object contains the named property, that is the property to which
the reference refers; if that object does not contain the named
property, the prototype for that object is examined next; and so on.

  --
  --

Figure 1 — Object/Prototype Relationships

In a class-based object-oriented language, in general, state is carried
by instances, methods are carried by classes, and inheritance is only of
structure and behaviour. In ECMAScript, the state and methods are
carried by objects, while structure, behaviour, and state are all
inherited.

All objects that do not directly contain a particular property that
their prototype contains share that property and its value. Figure 1
illustrates this:

CF is a constructor (and also an object). Five objects have been created
by using NEW expressions: CF~1~, CF~2~, CF~3~, CF~4~, and CF~5~. Each of
these objects contains properties named q1 and q2. The dashed lines
represent the implicit prototype relationship; so, for example, CF~3~’s
prototype is CF~P~. The constructor, CF, has two properties itself,
named P1 and P2, which are not visible to CF~P~, CF~1~, CF~2~, CF~3~,
CF~4~, or CF~5~. The property named CFP1 in CF~P~ is shared by CF~1~,
CF~2~, CF~3~, CF~4~, and CF~5~ (but not by CF), as are any properties
found in CF~P~’s implicit prototype chain that are not named q1, q2, or
CFP1. Notice that there is no implicit prototype link between CF and
CF~P~.

Unlike class-based object languages, properties can be added to objects
dynamically by assigning values to them. That is, constructors are not
required to name or assign values to all or any of the constructed
object’s properties. In the above diagram, one could add a new shared
property for CF~1~, CF~2~, CF~3~, CF~4~, and CF~5\ ~by assigning a new
value to the property in CF~P~.

4.2.2 The Strict Variant of ECMAScript

The ECMAScript Language recognises the possibility that some users of
the language may wish to restrict their usage of some features available
in the language. They might do so in the interests of security, to avoid
what they consider to be error-prone features, to get enhanced error
checking, or for other reasons of their choosing. In support of this
possibility, ECMAScript defines a strict variant of the language. The
strict variant of the language excludes some specific syntactic and
semantic features of the regular ECMAScript language and modifies the
detailed semantics of some features. The strict variant also specifies
additional error conditions that must be reported by throwing error
exceptions in situations that are not specified as errors by the
non-strict form of the language.

The strict variant of ECMAScript is commonly referred to as the _strict
mode_ of the language. Strict mode selection and use of the strict mode
syntax and semantics of ECMAScript is explicitly made at the level of
individual ECMAScript code units. Because strict mode is selected at the
level of a syntactic code unit, strict mode only imposes restrictions
that have local effect within such a code unit. Strict mode does not
restrict or modify any aspect of the ECMAScript semantics that must
operate consistently across multiple code units. A complete ECMAScript
program may be composed for both strict mode and non-strict mode
ECMAScript code units. In this case, strict mode only applies when
actually executing code that is defined within a strict mode code unit.

In order to conform to this specification, an ECMAScript implementation
must implement both the full unrestricted ECMAScript language and the
strict mode variant of the ECMAScript language as defined by this
specification. In addition, an implementation must support the
combination of unrestricted and strict mode code units into a single
composite program.


4.3 Terms and definitions

For the purposes of this document, the following terms and definitions
apply.

4.3.

type

set of data values as defined in Clause 8 of this specification

4.3.

primitive value

member of one of the types Undefined, Null, Symbol, Boolean, Number, or
String as defined in Clause 8

NOTE A primitive value is a datum that is represented directly at the
lowest level of the language implementation.

4.3.

object

member of the type Object

NOTE An object is a collection of properties and has a single prototype
object. The prototype may be the null value.

4.3.

constructor

function object that creates and initialises objects

NOTE The value of a constructor’s “prototype” property is a prototype
object that is used to implement inheritance and shared properties.

4.3.

prototype

object that provides shared properties for other objects

NOTE When a constructor creates an object, that object implicitly
references the constructor’s “PROTOTYPE” property for the purpose of
resolving property references. The constructor’s “PROTOTYPE” property
can be referenced by the program expression _constructor_.PROTOTYPE, and
properties added to an object’s prototype are shared, through
inheritance, by all objects sharing the prototype. Alternatively, a new
object may be created with an explicitly specified prototype by using
the OBJECT.CREATE built-in function.

4.3.

ordinary object

object that has the default behaviour for the internal methods that must
be supported by all ECMAScript objects.

4.3.

exotic object

object that has some alternative behaviour for one or more of the
internal methods that must be supported by all ECMAScript objects.

NOTE Any object that is not an ordinary object is an exotic object.

4.3.

standard object

object whose semantics are defined by this specification.

4.3.

built-in object

object supplied by an ECMAScript implementation, independent of the host
environment, that is present at the start of the execution of an
ECMAScript program

NOTE Standard built-in objects are defined in this specification, and an
ECMAScript implementation may specify and define others. A _built-in
constructor_ is a built-in object that is also a constructor.

4.3.

undefined value

primitive value used when a variable has not been assigned a value

4.3.

Undefined type

type whose sole value is the UNDEFINED value

4.3.

null value

primitive value that represents the intentional absence of any object
value

4.3.

Null type

type whose sole value is the null value

4.3.

Boolean value

member of the Boolean type

NOTE There are only two Boolean values, TRUE and FALSE.

4.3.

Boolean type

type consisting of the primitive values TRUE and FALSE

4.3.

Boolean object

member of the Object type that is an instance of the standard built-in
BOOLEAN constructor

NOTE A Boolean object is created by using the BOOLEAN constructor in a
NEW expression, supplying a Boolean value as an argument. The resulting
object has an internal data property whose value is the Boolean value. A
Boolean object can be coerced to a Boolean value.

4.3.

String value

primitive value that is a finite ordered sequence of zero or more 16-bit
unsigned integer

NOTE A String value is a member of the String type. Each integer value
in the sequence usually represents a single 16-bit unit of UTF-16 text.
However, ECMAScript does not place any restrictions or requirements on
the values except that they must be 16-bit unsigned integers.

4.3.

String type

set of all possible String values

4.3.

String object

member of the Object type that is an instance of the standard built-in
STRING constructor

NOTE A String object is created by using the STRING constructor in a NEW
expression, supplying a String value as an argument. The resulting
object has an internal data property whose value is the String value. A
String object can be coerced to a String value by calling the STRING
constructor as a function (15.5.1).

4.3.

Number value

primitive value corresponding to a double-precision 64-bit binary format
IEEE 754 value

NOTE A Number value is a member of the Number type and is a direct
representation of a number.

4.3.

Number type

set of all possible Number values including the special “Not-a-Number”
(NaN) value, positive infinity, and negative infinity

4.3.

Number object

member of the Object type that is an instance of the standard built-in
NUMBER constructor

NOTE A Number object is created by using the NUMBER constructor in a NEW
expression, supplying a Number value as an argument. The resulting
object has an internal data property whose value is the Number value. A
Number object can be coerced to a Number value by calling the NUMBER
constructor as a function (15.7.1).

4.3.

Infinity

number value that is the positive infinite Number value

4.3.

NaN

number value that is a IEEE 754 “Not-a-Number” value

4.3.

function

member of the Object type that may be invoked as a subroutine

NOTE In addition to its properties, a function contains executable code
and state that determine how it behaves when invoked. A function’s code
may or may not be written in ECMAScript.

4.3.

built-in function

built-in object that is a function

NOTE Examples of built-in functions include PARSEINT and MATH.EXP. An
implementation may provide implementation-dependent built-in functions
that are not described in this specification.

4.3.

property

association between a name and a value that is a part of an object

NOTE Depending upon the form of the property the value may be
represented either directly as a data value (a primitive value, an
object, or a function object) or indirectly by a pair of accessor
functions.

4.3.

method

function that is the value of a property

NOTE When a function is called as a method of an object, the object is
passed to the function as its THIS value.

4.3.

built-in method

method that is a built-in function

NOTE Standard built-in methods are defined in this specification, and an
ECMAScript implementation may specify and provide other additional
built-in methods.

4.3.

attribute

internal value that defines some characteristic of a property

4.3.

own property

property that is directly contained by its object

4.3.

inherited property

property of an object that is not an own property but is a property
(either own or inherited) of the object’s prototype


5.1 Syntactic and Lexical Grammars

5.1.1 Context-Free Grammars

A _context-free grammar_ consists of a number of _productions_. Each
production has an abstract symbol called a _nonterminal_ as its
_left-hand side_, and a sequence of zero or more nonterminal and
_terminal_ symbols as its _right-hand side_. For each grammar, the
terminal symbols are drawn from a specified alphabet.

A _chain_ _production_ is a production that has exactly one nonterminal
symbol on its right-hand side along with zero or more terminal symbols.

Starting from a sentence consisting of a single distinguished
nonterminal, called the _goal symbol_, a given context-free grammar
specifies a _language_, namely, the (perhaps infinite) set of possible
sequences of terminal symbols that can result from repeatedly replacing
any nonterminal in the sequence with a right-hand side of a production
for which the nonterminal is the left-hand side.

5.1.2 The Lexical and RegExp Grammars

A _lexical grammar_ for ECMAScript is given in clause 7. This grammar
has as its terminal symbols characters (Unicode code units) that conform
to the rules for _SourceCharacter_ defined in Clause 6. It defines a set
of productions, starting from the goal symbol _InputElementDiv_ or
_InputElementRegExp_, that describe how sequences of such characters are
translated into a sequence of input elements.

Input elements other than white space and comments form the terminal
symbols for the syntactic grammar for ECMAScript and are called
ECMAScript _tokens_. These tokens are the reserved words, identifiers,
literals, and punctuators of the ECMAScript language. Moreover, line
terminators, although not considered to be tokens, also become part of
the stream of input elements and guide the process of automatic
semicolon insertion (7.9). Simple white space and single-line comments
are discarded and do not appear in the stream of input elements for the
syntactic grammar. A _MultiLineComment_ (that is, a comment of the form
“/*…*/” regardless of whether it spans more than one line) is likewise
simply discarded if it contains no line terminator; but if a
_MultiLineComment_ contains one or more line terminators, then it is
replaced by a single line terminator, which becomes part of the stream
of input elements for the syntactic grammar.

A _RegExp grammar_ for ECMAScript is given in 15.10. This grammar also
has as its terminal symbols the characters as defined by
_SourceCharacter_. It defines a set of productions, starting from the
goal symbol _Pattern_, that describe how sequences of characters are
translated into regular expression patterns.

Productions of the lexical and RegExp grammars are distinguished by
having two colons “::” as separating punctuation. The lexical and RegExp
grammars share some productions.

5.1.3 The Numeric String Grammar

Another grammar is used for translating Strings into numeric values.
This grammar is similar to the part of the lexical grammar having to do
with numeric literals and has as its terminal symbols _SourceCharacter_.
This grammar appears in 9.3.1.

Productions of the numeric string grammar are distinguished by having
three colons “:::” as punctuation.

5.1.4 The Syntactic Grammar

The _syntactic grammar_ for ECMAScript is given in clauses 11, 12, 13
and 14. This grammar has ECMAScript tokens defined by the lexical
grammar as its terminal symbols (5.1.2). It defines a set of
productions, starting from the goal symbol _Script_, that describe how
sequences of tokens can form syntactically correct independent
components of an ECMAScript programs.

When a stream of characters is to be parsed as an ECMAScript script, it
is first converted to a stream of input elements by repeated application
of the lexical grammar; this stream of input elements is then parsed by
a single application of the syntactic grammar. The script is
syntactically in error if the tokens in the stream of input elements
cannot be parsed as a single instance of the goal nonterminal _Script_,
with no tokens left over.

Productions of the syntactic grammar are distinguished by having just
one colon “:” as punctuation.

The syntactic grammar as presented in clauses 11, 12, 13 and 14 is
actually not a complete account of which token sequences are accepted as
correct ECMAScript scripts. Certain additional token sequences are also
accepted, namely, those that would be described by the grammar if only
semicolons were added to the sequence in certain places (such as before
line terminator characters). Furthermore, certain token sequences that
are described by the grammar are not considered acceptable if a
terminator character appears in certain “awkward” places.

In certain cases in order to avoid ambiguities the syntactic grammar
uses generalize productions that permit token sequences that are not
valid ECMAScript scripts. For example, this technique is used in with
object literals and object destructuring patterns. In such cases a more
restrictive _supplemental_ _grammar_ is provided that further restricts
the acceptable token sequences. In certain contexts, when explicitly
specific, the input elements corresponding to such a production are
parsed again using a goal symbol of a supplemental grammar. The script
is syntactically in error if the tokens in the stream of input elements
cannot be parsed as a single instance of the supplemental goal symbol,
with no tokens left over.

5.1.5 The JSON Grammar

The JSON grammar is used to translate a String describing a set of
ECMAScript objects into actual objects. The JSON grammar is given in
15.12.1.

The JSON grammar consists of the JSON lexical grammar and the JSON
syntactic grammar. The JSON lexical grammar is used to translate
character sequences into tokens and is similar to parts of the
ECMAScript lexical grammar. The JSON syntactic grammar describes how
sequences of tokens from the JSON lexical grammar can form syntactically
correct JSON object descriptions.

Productions of the JSON lexical grammar are distinguished by having two
colons “::” as separating punctuation. The JSON lexical grammar uses
some productions from the ECMAScript lexical grammar. The JSON syntactic
grammar is similar to parts of the ECMAScript syntactic grammar.
Productions of the JSON syntactic grammar are distinguished by using one
colon “:” as separating punctuation.

5.1.6 Grammar Notation

Terminal symbols of the lexical, RegExp, and numeric string grammars,
and some of the terminal symbols of the other grammars, are shown in
FIXED WIDTH font, both in the productions of the grammars and throughout
this specification whenever the text directly refers to such a terminal
symbol. These are to appear in a script either exactly as written or
using equalvant Unicode escape sequences (see clause 6). All terminal
symbol characters specified in this way are to be understood as the
appropriate Unicode character from the ASCII range, as opposed to any
similar-looking characters from other Unicode ranges.

Nonterminal symbols are shown in _italic_ type. The definition of a
nonterminal (also called a “production”) is introduced by the name of
the nonterminal being defined followed by one or more colons. (The
number of colons indicates to which grammar the production belongs.) One
or more alternative right-hand sides for the nonterminal then follow on
succeeding lines. For example, the syntactic definition:

WhileStatement :

WHILE ( Expression ) Statement

states that the nonterminal _WhileStatement_ represents the token WHILE,
followed by a left parenthesis token, followed by an _Expression_,
followed by a right parenthesis token, followed by a _Statement_. The
occurrences of _Expression_ and _Statement_ are themselves nonterminals.
As another example, the syntactic definition:

ArgumentList :

AssignmentExpression
ArgumentList , AssignmentExpression

states that an _ArgumentList_ may represent either a single
_AssignmentExpression_ or an _ArgumentList_, followed by a comma,
followed by an _AssignmentExpression_. This definition of _ArgumentList_
is recursive, that is, it is defined in terms of itself. The result is
that an _ArgumentList_ may contain any positive number of arguments,
separated by commas, where each argument expression is an
_AssignmentExpression_. Such recursive definitions of nonterminals are
common.

The subscripted suffix “~opt~”, which may appear after a terminal or
nonterminal, indicates an optional symbol. The alternative containing
the optional symbol actually specifies two right-hand sides, one that
omits the optional element and one that includes it. This means that:

VariableDeclaration :

Identifier Initialiser~opt~

is a convenient abbreviation for:

VariableDeclaration :

Identifier
Identifier Initialiser

and that:

IterationStatement :

FOR ( ExpressionNoIn~opt~ ; Expression~opt~ ; Expression~opt~ )
Statement

is a convenient abbreviation for:

IterationStatement :

FOR ( ; Expression~opt~ ; Expression~opt~ ) Statement
FOR ( ExpressionNoIn ; Expression~opt~ ; Expression~opt~ ) Statement

which in turn is an abbreviation for:

IterationStatement :

FOR ( ; ; Expression~opt~ ) Statement
FOR ( ; Expression ; Expression~opt~ ) Statement
FOR ( ExpressionNoIn ; ; Expression~opt~ ) Statement
FOR ( ExpressionNoIn ; Expression ; Expression~opt~ ) Statement

which in turn is an abbreviation for:

IterationStatement :

FOR ( ; ; ) Statement
FOR ( ; ; Expression ) Statement
FOR ( ; Expression ; ) Statement
FOR ( ; Expression ; Expression ) Statement
FOR ( ExpressionNoIn ; ; ) Statement
FOR ( ExpressionNoIn ; ; Expression ) Statement
FOR ( ExpressionNoIn ; Expression ; ) Statement
FOR ( ExpressionNoIn ; Expression ; Expression ) Statement

so the nonterminal _IterationStatement_ actually has eight alternative
right-hand sides.

When the words “ONE OF” follow the colon(s) in a grammar definition,
they signify that each of the terminal symbols on the following line or
lines is an alternative definition. For example, the lexical grammar for
ECMAScript contains the production:

NonZeroDigit :: ONE OF

1 2 3 4 5 6 7 8 

which is merely a convenient abbreviation for:

NonZeroDigit ::

1
2
3
4
5
6
7
8
9

If the phrase “[empty]” appears as the right-hand side of a production,
it indicates that the production's right-hand side contains no terminals
or nonterminals.

If the phrase “[lookahead ∉ _set_]” appears in the right-hand side of a
production, it indicates that the production may not be used if the
immediately following input token is a member of the given _set_. The
_set_ can be written as a list of terminals enclosed in curly braces.
For convenience, the set can also be written as a nonterminal, in which
case it represents the set of all terminals to which that nonterminal
could expand. For example, given the definitions

DecimalDigit :: ONE OF

0 1 2 3 4 5 6 7 8 

DecimalDigits ::

DecimalDigit
DecimalDigits DecimalDigit

the definition

LookaheadExample ::

N [lookahead ∉ {1, 3, 5, 7, 9}] DecimalDigits
DecimalDigit [lookahead ∉ DecimalDigit ]

matches either the letter N followed by one or more decimal digits the
first of which is even, or a decimal digit not followed by another
decimal digit.

If the phrase “[no _LineTerminator_ here]” appears in the right-hand
side of a production of the syntactic grammar, it indicates that the
production is _a restricted production_: it may not be used if a
_LineTerminator_ occurs in the input stream at the indicated position.
For example, the production:

ThrowStatement :

THROW [no LineTerminator here] Expression ;

indicates that the production may not be used if a _LineTerminator_
occurs in the script between the THROW token and the _Expression_.

Unless the presence of a _LineTerminator_ is forbidden by a restricted
production, any number of occurrences of _LineTerminator_ may appear
between any two consecutive tokens in the stream of input elements
without affecting the syntactic acceptability of the script.

The lexical grammar has multiple goal symbols and the appropriate goal
symbol to use depends upon the syntactic grammar context. If a phrase of
the form “[Lexical goal _LexicalGoalSymbol_]” appears on the
right-hand-side of a syntactic production then the next token must be
lexically recognised using the indicated goal symbol. In the absence of
such a phrase the default lexical goal symbol is used.

When an alternative in a production of the lexical grammar or the
numeric string grammar appears to be a multi-character token, it
represents the sequence of characters that would make up such a token.

The right-hand side of a production may specify that certain expansions
are not permitted by using the phrase “BUT NOT” and then indicating the
expansions to be excluded. For example, the production:

Identifier ::

IdentifierName BUT NOT ReservedWord

means that the nonterminal _Identifier_ may be replaced by any sequence
of characters that could replace _IdentifierName_ provided that the same
sequence of characters could not replace _ReservedWord_.

Finally, a few nonterminal symbols are described by a descriptive phrase
in sans-serif type in cases where it would be impractical to list all
the alternatives:

SourceCharacter ::

any Unicode character


5.2 Algorithm Conventions

The specification often uses a numbered list to specify steps in an
algorithm. These algorithms are used to precisely specify the required
semantics of ECMAScript language constructs. The algorithms are not
intended to imply the use of any specific implementation technique. In
practice, there may be more efficient algorithms available to implement
a given feature.

Algorithms may be explicitly parameterised, in which case the names and
usage of the parameters must be provided as part of the algorithm’s
definition. In order to facilitate their use in multiple parts of this
specification, some algorithms, called _abstract_ _operations_, are
named and written in parameterised functional form so that they may be
referenced by name from within other algorithms.

Algorithms may be associated with productions of one of the ECMAScript
grammars. A production that has multiple alternative definitions will
typically have a distinct algorithm for each alternative. When an
algorithm is associated with a grammar production, it may reference the
terminal and non-terminal symbols of the production alternative as if
they were parameters of the algorithm. When used in this manner,
non-terminal symbols refer to the actual alternative definition that is
matched when parsing the script souce code.

Unless explicitly specified otherwise, all chain productions have an
implicit associated definition for every algorithm that is might be
applied to that production’s left-hand side nonterminal. The implicit
simply reapplies the same algorithm name with the same parameters, if
any, to the chain production’s sole right-hand side nonterminal and then
result. For example, assume there is a production

Block :

{ StatementList }

but there is no evalution algorithm that is explicitly specified for
that production. If in some algorithm there is a statement of the form:
“Return the result of evaluating _Block_” it is implicit that the
algorithm has an evalution algorithm of the form:

  RUNTIME SEMANTICS: EVALUATION

  Block : { StatementList }

1.  Return the result of evaluating _StatementList

For clarity of expression, algorithm steps may be subdivided into
sequential substeps. Substeps are indented and may themselves be further
divided into indented substeps. Outline numbering conventions are used
to identify substeps with the first level of substeps labelled with
lower case alphabetic characters and the second level of substeps
labelled with lower case roman numerals. If more than three levels are
required these rules repeat with the fourth level using numeric labels.
For example:

1.  Top-level step

    a.  Substep.

    b.  Substep

        i.  Subsubstep.

        ii. Subsubstep.

            1.  Subsubsubstep

                a.  Subsubsubsubstep

A step or substep may be written as an “if” predicate that conditions
its substeps. In this case, the substeps are only applied if the
predicate is true. If a step or substep begins with the word “else”, it
is a predicate that is the negation of the preceding “if” predicate step
at the same level.

A step may specify the iterative application of its substeps.

A step may assert an invariant condition of its algorithm. Such
assertions are used to make explicit algorithmic invariants that would
otherwise be implicit. Such assertions add no additional semantic
requirements and hence need not be checked by an implementation. They
are used simply to clarify algorithms.

Mathematical operations such as addition, subtraction, negation,
multiplication, division, and the mathematical functions defined later
in this clause should always be understood as computing exact
mathematical results on mathematical real numbers, which do not include
infinities and do not include a negative zero that is distinguished from
positive zero. Algorithms in this standard that model floating-point
arithmetic include explicit steps, where necessary, to handle infinities
and signed zero and to perform rounding. If a mathematical operation or
function is applied to a floating-point number, it should be understood
as being applied to the exact mathematical value represented by that
floating-point number; such a floating-point number must be finite, and
if it is +0 or −0 then the corresponding mathematical value is simply 0.

The mathematical function abs(_x_) yields the absolute value of _x_,
which is −_x_ if _x_ is negative (less than zero) and otherwise is _x_
itself.

The mathematical function sign(_x_) yields 1 if _x_ is positive and −1
if _x_ is negative. The sign function is not used in this standard for
cases when _x_ is zero.

The mathematical function min(_x_~1~, _x_~2~, ..., _x_~n~) yields the
mathematically smallest of _x_~1~ through _x_~n~.

The notation “_x_ modulo _y_” (_y_ must be finite and nonzero) computes
a value _k_ of the same sign as _y_ (or zero) such that abs(_k_) <
abs(_y_) and _x_−_k_ = _q_ × _y_ for some integer _q_.

The mathematical function floor(_x_) yields the largest integer (closest
to positive infinity) that is not larger than _x_.

NOTE floor(_x_) = _x_−(_x_ modulo 1).


5.3 Static Semantic Rules

Context-free grammars are not sufficiently powerful to express all the
rules that define whether a stream of input elements make up a valid
ECMAScript script that may be evaluated. In some situations additional
rules are needed that may be expressed using either ECMAScript algorithm
conventions or prose requirements. Such rules are always associated with
a production of a grammar and are called the _static semantics_ of the
production.

Static Semantic Rules have names and typically are defined using an
algorithm. Named Static Semantic Rules are associated with grammar
productions and a production that has multiple alternative definitions
will typically have for each alternative a distinct algorithm for each
applicable named static semantic rule.

Unless otherwise specified every grammar production alternative in this
specification implicitly has a definition for a static semantic rule
named Contains which takes an argument named _symbol_ whose value is a
terminal or non-terminal of the grammar that includes the associated
production. The default definition of Contains is:

1.  For each terminal and non-terminal grammar symbol, _sym_, in the
    definition of this production do

    a.  If _sym_ is the same grammar symbol as _symbol_, return TRUE.

    b.  If _sym_ is a non-terminal, then

        i.  Let _contained_ be the result of Contains for _sym_ with
            argument _symbol_.

        ii. If _contained_ is TRUE, return TRUE.

2.  Return FALSE.

The above definition is explicitly over-ridden for specific productions.

A special kind of static semantic rule is an Early Error Rule. Early
error rules define early error conditions (see clause 16) that are
associate with specific grammar productions. Evaluation of most early
error rules are not explicitly invoked within the algorithms of this
specification. A comforming implementation must, prior to the first
evaluation of a _Script_, validate all of the early error rules of the
productions used to parse that _Script_. If any of the early error rules
are violated the _Script_ is invalid and cannot be evaluated.

Syntax

SourceCharacter ::

  any Unicode character

The ECMAScript code is expressed using Unicode, version 5.1 or later.
ECMAScript source text is a sequence of Unicode characters. The phrase
“Unicode character” refers to the abstract linguistic or typographical
unit represented by a single Unicode scalar value. The actual encodings
used to store and interchange ECMAScript source text is not relevant to
this specification. Any well-defined encoding such as UTF-32 or UTF-16
may be used. Source text might even be externally represented using a
non-Unicode character encoding. Regardless of the external source text
encoding, a conforming ECMAScript implementation processes the source
text as if it was an equivalent sequence of _SourceCharacter_ values.
Each _SourceCharacter_ being an abstract Unicode character with a
corresponding Unicode scalar value. Conforming ECMAScript
implementations are not required to perform any normalisation of text,
or behave as though they were performing normalisation of text.

The phrase “code point” refers to such a Unicode scalar value. “Unicode
character” only refers to entities represented by single Unicode scalar
values: the components of a combining character sequence are still
individual “Unicode characters,” even though a user might think of the
whole sequence as a single character.

In string literals, regular expression literals,template literals and
identifiers, any Unicode characters may also be expressed as a Unicode
escape sequence that explicitly express a code point’s numeric value.
Within a comment, such an escape sequence is effectively ignored as part
of the comment. Within other contexts, such an escape sequence
contextually contributes one Unicode character.

NOTE

ECMAScript differs from the Java programming language in the behaviour
of Unicode escape sequences. In a Java program, if the Unicode escape
sequence \U000A, for example, occurs within a single-line comment, it is
interpreted as a line terminator (Unicode character 000A is line feed)
and therefore the next Unicode character is not part of the comment.
Similarly, if the Unicode escape sequence \U000A occurs within a string
literal in a Java program, it is likewise interpreted as a line
terminator, which is not allowed within a string literal—one must write
\N instead of \U000A to cause a line feed to be part of the string value
of a string literal. In an ECMAScript program, a Unicode escape sequence
occurring within a comment is never interpreted and therefore cannot
contribute to termination of the comment. Similarly, a Unicode escape
sequence occurring within a string literal in an ECMAScript program
always contributes a Unicode character to the literal and is never
interpreted as a line terminator or as a quote mark that might terminate
the string literal.

ECMAScript String values (8.4) are computational sequences of 16-bit
integer values called “code units”. ECMAScript language constructs that
generate string values from _SourceCharacter_ sequences use UTF-16
encoding to generate the code unit values.

STATIC SEMANTICS: UTF-16 ENCODING

The UTF-16 Encoding of a numeric code point value, _cp_, is determined
as follows:

1.  Assert: 0 ≤ _cp_ ≤ 0x10FFFF

2.  If _cp_ ≤ 65535, then return _cp_.

3.  Let _cu1_ be floor((_cp_ – 65536) / 1024) + 55296. NOTE 55296 is
    0xD800.

4.  Let _cu2_ be ((_cp_ – 65536) modulo 1024) + 56320. NOTE 56320 is
    0xDC00.

5.  Return the code unit sequence consisting of _cu1_ followed by _cu2_.

The source text of an ECMAScript script is first converted into a
sequence of input elements, which are tokens, line terminators,
comments, or white space. The source text is scanned from left to right,
repeatedly taking the longest possible sequence of characters as the
next input element.

There are several situations where the identification of lexical input
elements is sensitive to the syntactic grammar context that is consuming
the input elements. This requires multiple goal symbols for the lexical
grammar. The _InputElementDiv_ goal symbol is the default goal symbol
and is used in those syntactic grammar contexts where a leading division
(/) or division-assignment (/=) operator is permitted. The
_InputElementRegExp_ goal symbol is used in all syntactic grammar
contexts where a _RegularExpressionLiteral_ is permitted. The
_InputElementTemplateTail_ goal is used in syntactic grammar contexts
where a _TemplateLiteral_ logically continues after a substitution
element.

NOTE There are no syntactic grammar contexts where both a leading
division or division-assignment, and a leading
_RegularExpressionLiteral_ are permitted. This is not affected by
semicolon insertion (see 7.9); in examples such as the following:

  A = B
  /HI/G.EXEC(C).MAP(D);

where the first non-whitespace, non-comment character after a
_LineTerminator_ is slash (/) and the syntactic context allows division
or division-assignment, no semicolon is inserted at the
_LineTerminator_. That is, the above example is interpreted in the same
way as:

  A = B / HI / G.EXEC(C).MAP(D);

Syntax

InputElementDiv ::

WhiteSpace
LineTerminator
Comment
Token
DivPunctuator
RightBracePunctuator

InputElementRegExp ::

WhiteSpace
LineTerminator
Comment
Token
RightBracePunctuator
RegularExpressionLiteral

InputElementTemplateTail ::

WhiteSpace
LineTerminator
Comment
Token
DivPunctuator
TemplateSubstitutionTail


7.1 Unicode Format-Control Characters

The Unicode format-control characters (i.e., the characters in category
“Cf” in the Unicode Character Database such as left-to-right mark or
right-to-left mark) are control codes used to control the formatting of
a range of text in the absence of higher-level protocols for this (such
as mark-up languages).

It is useful to allow format-control characters in source text to
facilitate editing and display. All format control characters may be
used within comments, and within string literals, template literals, and
regular expression literals.

<ZWNJ> and <ZWJ> are format-control characters that are used to make
necessary distinctions when forming words or phrases in certain
languages. In ECMAScript source text, <ZWNJ> and <ZWJ> may also be used
in an identifier after the first character.

<BOM> is a format-control character used primarily at the start of a
text to mark it as Unicode and to allow detection of the text's encoding
and byte order. <BOM> characters intended for this purpose can sometimes
also appear after the start of a text, for example as a result of
concatenating files. <BOM> characters are treated as white space
characters (see 7.2).

The special treatment of certain format-control characters outside of
comments, string literals, and regular expression literals is summarised
in Table 1.

Table 1 — Format-Control Character Usage

  ---------------- ----------------------- --------------- ------------------
  _CODE_ _POINT_   _NAME_                  _FORMAL NAME_   _USAGE_
  U+200C           Zero width non-joiner   <ZWNJ>          _IdentifierPart_
  U+200D           Zero width joiner       <ZWJ>           _IdentifierPart_
  U+FEFF           Byte Order Mark         <BOM>           _Whitespace_
  ---------------- ----------------------- --------------- ------------------


7.2 White Space

White space characters are used to improve source text readability and
to separate tokens (indivisible lexical units) from each other, but are
otherwise insignificant. White space characters may occur between any
two tokens and at the start or end of input. White space characters may
occur within a _StringLiteral_, a _RegularExpressionLiteral_, a
_Template_, or a _TemplateSubstitutionTail_ where they are considered
significant characters forming part of a literal value. They may also
occur within a _Comment_, but cannot appear within any other kind of
token.

The ECMAScript white space characters are listed in Table 2.

Table 2 — Whitespace Characters

  --------------------- ------------------------------------- ---------------
  _CODE_ _POINT_        _NAME_                                _FORMAL NAME_
  U+0009                Tab                                   <TAB>
  U+000B                Vertical Tab                          <VT>
  U+000C                Form Feed                             <FF>
  U+0020                Space                                 <SP>
  U+00A0                No-break space                        <NBSP>
  U+FEFF                Byte Order Mark                       <BOM>
  Other category “Zs”   Any other Unicode “space separator”   <USP>
  --------------------- ------------------------------------- ---------------

ECMAScript implementations must recognise all of the white space
characters defined in Unicode 5.1. Later editions of the Unicode
Standard may define other white space characters. ECMAScript
implementations may recognise white space characters from later editions
of the Unicode Standard.

Syntax

WhiteSpace ::

<TAB>
<VT>
<FF>
<SP>
<NBSP>
<BOM>
<USP>


7.3 Line Terminators

Like white space characters, line terminator characters are used to
improve source text readability and to separate tokens (indivisible
lexical units) from each other. However, unlike white space characters,
line terminators have some influence over the behaviour of the syntactic
grammar. In general, line terminators may occur between any two tokens,
but there are a few places where they are forbidden by the syntactic
grammar. Line terminators also affect the process of automatic semicolon
insertion (7.9). A line terminator cannot occur within any token except
a _StringLiteral_, _Template_, or _TemplateSubstitutionTail_. Line
terminators may only occur within a _StringLiteral_ token as part of a
_LineContinuation_.

A line terminator can occur within a _MultiLineComment_ (7.4) but cannot
occur within a _SingleLineComment_.

Line terminators are included in the set of white space characters that
are matched by the \S class in regular expressions.

The ECMAScript line terminator characters are listed in Table 3.

Table 3 — Line Terminator Characters

  ---------------- --------------------- ---------------
  _CODE_ _POINT_   _NAME_                _FORMAL NAME_
  U+000A           Line Feed             <LF>
  U+000D           Carriage Return       <CR>
  U+2028           Line separator        <LS>
  U+2029           Paragraph separator   <PS>
  ---------------- --------------------- ---------------

Only the Unicode characters in Table 3 are treated as line terminators.
Other new line or line breaking Unicode characters are treated as white
space but not as line terminators. The sequence <CR><LF> is commonly
used as a line terminator. It should be considered a single
_SourceCharacter_ for the purpose of reporting line numbers.

Syntax

LineTerminator ::

<LF>
<CR>
<LS>
<PS>

LineTerminatorSequence ::

<LF>
<CR> [lookahead ∉ <LF> ]
<LS>
<PS>
<CR> <LF>


7.4 Comments

Comments can be either single or multi-line. Multi-line comments cannot
nest.

Because a single-line comment can contain any Unicode character except a
_LineTerminator_ character, and because of the general rule that a token
is always as long as possible, a single-line comment always consists of
all characters from the // marker to the end of the line. However, the
_LineTerminator_ at the end of the line is not considered to be part of
the single-line comment; it is recognised separately by the lexical
grammar and becomes part of the stream of input elements for the
syntactic grammar. This point is very important, because it implies that
the presence or absence of single-line comments does not affect the
process of automatic semicolon insertion (see 7.9).

Comments behave like white space and are discarded except that, if a
_MultiLineComment_ contains a line terminator character, then the entire
comment is considered to be a _LineTerminator_ for purposes of parsing
by the syntactic grammar.

Syntax

Comment ::

MultiLineComment
SingleLineComment

MultiLineComment ::

/* MultiLineCommentChars~opt~ */

MultiLineCommentChars ::

MultiLineNotAsteriskChar MultiLineCommentChars~opt~
* PostAsteriskCommentChars~opt~

PostAsteriskCommentChars ::

MultiLineNotForwardSlashOrAsteriskChar MultiLineCommentChars~opt~
* PostAsteriskCommentChars~opt~

MultiLineNotAsteriskChar ::

SourceCharacter BUT NOT *

MultiLineNotForwardSlashOrAsteriskChar ::

SourceCharacter BUT NOT ONE OF / OR *

SingleLineComment ::

// SingleLineCommentChars~opt~

SingleLineCommentChars ::

SingleLineCommentChar SingleLineCommentChars~opt~

SingleLineCommentChar ::

SourceCharacter BUT NOT LineTerminator


7.5 Tokens

Syntax

Token ::

IdentifierName
Punctuator
NumericLiteral
StringLiteral
Template

NOTE The _DivPunctuator_, _RegularExpressionLiteral_,
_RightBracePunctuator,_ and _TemplateSubstitutionTail_ productions
define tokens, but are not included in the _Token_ production.


7.6 Identifier Names and Identifiers

_IdentifierName_, _Identifier_, and _ReservedWord_ are tokens that are
interpreted according to the Default Identifier Syntax given in Unicode
Standard Annex #31, Identifier and Pattern Syntax, with some small
modifications. _ReservedWord_ is is an enumerated subset of
_IdentifierName_ and _Identifier_ is an _IdentifierName_ that is not a
_ReservedWord_ (see 7.6.1). The Unicode identifier grammar is based on
character properties specified by the Unicode Standard. The Unicode
characters in the specified categories in version 5.1.0 of the Unicode
standard must be treated as in those categories by all conforming
ECMAScript implementations. ECMAScript implementations may recognise
identifier characters defined in later editions of the Unicode Standard.

NOTE 1 This standard specifies specific character additions: The dollar
sign (U+0024) and the underscore (U+005F) are permitted anywhere in an
_IdentifierName_, and the characters zero width non-joiner (U+200C) and
zero width joiner (U+200D) are permitted anywhere after the first
character of an _IdentifierName_.

Unicode escape sequences are permitted in an _IdentifierName_, where
they contribute a single Unicode character to the _IdentifierName_. The
code point of the contributed character is expressed by the _HexDigits_
of the _UnicodeEscapeSequence_ (see 7.8.6). The \ preceding the
_UnicodeEscapeSequence_ and the U and { } characters, if they appear, do
not contribute characters to the _IdentifierName_. A
_UnicodeEscapeSequence_ cannot be used to put a character into an
_IdentifierName_ that would otherwise be illegal. In other words, if a \
_UnicodeEscapeSequence_ sequence were replaced by the Unicode character
it constributes, the result must still be a valid _IdentifierName_ that
has the exact same sequence of characters as the original
_IdentifierName_. All interpretations of _IdentifierName_ within this
specification are based upon their actual characters regardless of
whether or not an escape sequence was used to contribute any particular
characters.

Two _IdentifierName_ that are canonically equivalent according to the
Unicode standard are _not_ equal unless they are represented by the
exact same sequence of code units (in other words, conforming ECMAScript
implementations are only required to do bitwise comparison on
IdentifierName values).

NOTE 2 If maximal portability is a concern, programmers should only
employ the identifier characters that were defined in Unicode 3.0.

Syntax

Identifier ::

IdentifierName BUT NOT ReservedWord

IdentifierName ::

IdentifierStart
IdentifierName IdentifierPart

IdentifierStart ::

UnicodeIDStart
$
_
\ UnicodeEscapeSequence

IdentifierPart ::

UnicodeIDContinue
$
_
\ UnicodeEscapeSequence
<ZWNJ>
<ZWJ>

UnicodeIDStart ::

any Unicode character with the Unicode property “ID_Start”.

UnicodeIDContinue ::

any Unicode character with the Unicode property “ID_Continue”

The definitions of the nonterminal _UnicodeEscapeSequence_ is given in
7.8.

STATIC SEMANTICS: STRINGVALUE

_Identifier_ :: _IdentifierName_ BUT NOT _ReservedWord

1.  Return the StringValue of _IdentifierName_.

IdentifierName ::

IdentifierStart
IdentifierName IdentifierPart

1.  Return the String value consisting of the sequence of code units
    corresponding to _IdentifierName_. In determining the sequence any
    occurrences of \ _UnicodeEscapeSequence_ are first replaced with the
    code point represented by the _UnicodeEscapeSequence_ and then the
    code points of the entire _IdentifierName_ are converted to code
    units by UTF-16 Encoding (clause 6) each code point.

7.6.1 Reserved Words

A reserved word is an _IdentifierName_ that cannot be used as an
_Identifier_.

Syntax

ReservedWord ::

Keyword
FutureReservedWord
NullLiteral
BooleanLiteral

The _ReservedWord_ definitions are specified as literal sequences of
Unicode characters. However, any Unicode character in a _ReservedWord_
can also be expressed by a \ _UnicodeEscapeSequence_ that expresses that
same Unicode character’s code point. Use of such escape sequences does
not change the meaning of the _ReservedWord_.

7.6.1.1 Keywords

The following tokens are ECMAScript keywords and may not be used as
_Identifiers_ in ECMAScript programs.

Syntax

Keyword :: ONE OF

  ---------- ---------- ------------ --------
  break      delete     import       this
  case       do         in           throw
  catch      else       instanceof   try
  class      export     let          typeof
  continue   finally    new          var
  const      for        return       void
  debugger   function   super        while
  default    if         switch       with
  ---------- ---------- ------------ --------

7.6.1.2 Future Reserved Words

The following words are used as keywords in proposed extensions and are
therefore reserved to allow for the possibility of future adoption of
those extensions.

Syntax

FutureReservedWord :: ONE OF

  -- ------ --------- --
     enum   extends   
                      
  -- ------ --------- --

The following tokens are also considered to be _FutureReservedWords_
when they occur within strict mode code (see 10.1.1). The occurrence of
any of these tokens within strict mode code in any context where the
occurrence of a _FutureReservedWord_ would produce an error must also
produce an equivalent error:

  ------------ --------- ----------- -------- -------
  implements             private     public   yield
  interface    package   protected   static   
  ------------ --------- ----------- -------- -------


7.7 Punctuators

Syntax

Punctuator :: ONE OF

  ----- ------ ----- ----- ----- -----
  {     (      )     [     ]     .
  ...   ;      ,     <     >     <=
  >=    ==     !=    ===   !==   
  +     -      *     %     ++    --
  <<    >>     >>>   &     |     ^
  !     ~      &&    ||    ?     :
  =     +=     -=    *=    %=    <<=
  >>=   >>>=   &=    |=    ^=    =>
  ----- ------ ----- ----- ----- -----

DivPunctuator :: ONE OF

  --- ---- -- -- -- --
  /   /=            
  --- ---- -- -- -- --

RightBracePunctuator ::

  --- -- -- -- -- --
  }               
  --- -- -- -- -- --


7.8 Literals

7.8.1 Null Literals

Syntax

NullLiteral ::

NULL

7.8.2 Boolean Literals

Syntax

BooleanLiteral ::

TRUE
FALSE

7.8.3 Numeric Literals

Syntax

NumericLiteral ::

DecimalLiteral
BinaryIntegerLiteral
OctalIntegerLiteral
HexIntegerLiteral

DecimalLiteral ::

DecimalIntegerLiteral . DecimalDigits~opt~ ExponentPart~opt~
. DecimalDigits ExponentPart~opt~
DecimalIntegerLiteral ExponentPart~opt~

DecimalIntegerLiteral ::

0
NonZeroDigit DecimalDigits~opt~

DecimalDigits ::

DecimalDigit
DecimalDigits DecimalDigit

DecimalDigit :: ONE OF

0 1 2 3 4 5 6 7 8 

NonZeroDigit :: ONE OF

1 2 3 4 5 6 7 8 

ExponentPart ::

ExponentIndicator SignedInteger

ExponentIndicator :: ONE OF

E E

SignedInteger ::

DecimalDigits
+ DecimalDigits
- DecimalDigits

BinaryIntegerLiteral ::

0B BinaryDigit
0B BinaryDigit
BinaryIntegerLiteral BinaryDigit

BinaryDigit :: ONE OF

0 

OctalIntegerLiteral ::

0O OctalDigit
0O OctalDigit
OctalIntegerLiteral OctalDigit

OctalDigit :: ONE OF

0 1 2 3 4 5 6 

HexIntegerLiteral ::

0X HexDigits
0X HexDigits

HexDigits ::

HexDigit
HexDigits HexDigit

HexDigit :: one of

0 1 2 3 4 5 6 7 8 9 A B C D E F A B C D E F

The _SourceCharacter_ immediately following a _NumericLiteral_ must not
be an _IdentifierStart_ or _DecimalDigit_.

NOTE For example:

  3in

is an error and not the two input elements 3 and IN.

A conforming implementation, when processing strict mode code (see
10.1.1), must not extend the syntax of _NumericLiteral_ to include
_OctalIntegerLiteral_ as described in B.1.1.

Static Semantics: MV’s

A numeric literal stands for a value of the Number type. This value is
determined in two steps: first, a mathematical value (MV) is derived
from the literal; second, this mathematical value is rounded as
described below.

-   The MV of _NumericLiteral_ :: _DecimalLiteral_ is the MV of
    _DecimalLiteral_.

-   The MV of _NumericLiteral_ :: _BinaryIntegerLiteral_ is the MV of
    _BinaryIntegerLiteral_.

-   The MV of _NumericLiteral_ :: _OctalIntegerLiteral_ is the MV of
    _OctalIntegerLiteral_.

-   The MV of _NumericLiteral_ :: _HexIntegerLiteral_ is the MV of
    _HexIntegerLiteral_.

-   The MV of _DecimalLiteral_ :: _DecimalIntegerLiteral_ . is the MV of
    _DecimalIntegerLiteral_.

-   The MV of _DecimalLiteral_ :: _DecimalIntegerLiteral_ .
    _DecimalDigits_ is the MV of _DecimalIntegerLiteral_ plus (the MV of
    _DecimalDigits_ times 10^–_n_^), where _n_ is the number of
    characters in _DecimalDigit_s.

-   The MV of _DecimalLiteral_ :: _DecimalIntegerLiteral_ .
    _ExponentPart_ is the MV of _DecimalIntegerLiteral_ times 10_^e^_,
    where _e_ is the MV of _ExponentPart_.

-   The MV of _DecimalLiteral_ :: _DecimalIntegerLiteral_ .
    _DecimalDigits ExponentPart_ is (the MV of _DecimalIntegerLiteral_
    plus (the MV of _DecimalDigits_ times 10^–_n_^)) times 10_^e^_,
    where _n_ is the number of characters in _DecimalDigit_s and _e_ is
    the MV of _ExponentPart_.

-   The MV of _DecimalLiteral_ ::. _DecimalDigits_ is the MV of
    _DecimalDigits_ times 10^–_n_^, where _n_ is the number of
    characters in _DecimalDigit_s.

-   The MV of _DecimalLiteral_ ::. _DecimalDigits ExponentPart_ is the
    MV of _DecimalDigits_ times 10^_e_–_n_^, where _n_ is the number of
    characters in _DecimalDigit_s and _e_ is the MV of _ExponentPart_.

-   The MV of _DecimalLiteral_ :: _DecimalIntegerLiteral_ is the MV of
    _DecimalIntegerLiteral_.

-   The MV of _DecimalLiteral_ :: _DecimalIntegerLiteral ExponentPart_
    is the MV of _DecimalIntegerLiteral_ times 10_^e^_, where _e_ is the
    MV of _ExponentPart_.

-   The MV of _DecimalIntegerLiteral_ :: 0 is 0.

-   The MV of _DecimalIntegerLiteral_ :: _NonZeroDigit_ is the MV of
    _NonZeroDigit._

-   The MV of _DecimalIntegerLiteral_ :: _NonZeroDigit_ _DecimalDigits_
    is (the MV of _NonZeroDigit_ times 10_^n^_) plus the MV of
    _DecimalDigits_, where _n_ is the number of characters in
    _DecimalDigits_.

-   The MV of _DecimalDigits_ :: _DecimalDigit_ is the MV of
    _DecimalDigit_.

-   The MV of _DecimalDigits_ :: _DecimalDigits_ _DecimalDigit_ is (the
    MV of _DecimalDigits_ times 10) plus the MV of _DecimalDigit_.

-   The MV of _ExponentPart_ :: _ExponentIndicator SignedInteger_ is the
    MV of _SignedInteger_.

-   The MV of _SignedInteger_ :: _DecimalDigits_ is the MV of
    _DecimalDigits_.

-   The MV of _SignedInteger_ :: + _DecimalDigits_ is the MV of
    _DecimalDigits_.

-   The MV of _SignedInteger_ :: - _DecimalDigits_ is the negative of
    the MV of _DecimalDigits_.

-   The MV of _DecimalDigit_ :: 0 or of _HexDigit_ :: 0 or of
    _OctalDigit_ :: 0 or of _BinaryDigit_ :: 0 is 0.

-   The MV of _DecimalDigit_ :: 1 or of _NonZeroDigit_ :: 1 or of
    _HexDigit_ :: 1 or of _OctalDigit_ :: 1 or
    of _BinaryDigit_ :: 1 is 1.

-   The MV of _DecimalDigit_ :: 2 or of _NonZeroDigit_ :: 2 or of
    _HexDigit_ :: 2 or of _OctalDigit_ :: 2 is 2.

-   The MV of _DecimalDigit_ :: 3 or of _NonZeroDigit_ :: 3 or of
    _HexDigit_ :: 3 or of _OctalDigit_ :: 3 is 3.

-   The MV of _DecimalDigit_ :: 4 or of _NonZeroDigit_ :: 4 or of
    _HexDigit_ :: 4 or of _OctalDigit_ :: 4 is 4.

-   The MV of _DecimalDigit_ :: 5 or of _NonZeroDigit_ :: 5 or of
    _HexDigit_ :: 5 or of _OctalDigit_ :: 5 is 5.

-   The MV of _DecimalDigit_ :: 6 or of _NonZeroDigit_ :: 6 or of
    _HexDigit_ :: 6 or of _OctalDigit_ :: 6 is 6.

-   The MV of _DecimalDigit_ :: 7 or of _NonZeroDigit_ :: 7 or of
    _HexDigit_ :: 7 or of _OctalDigit_ :: 7 is 7.

-   The MV of _DecimalDigit_ :: 8 or of _NonZeroDigit_ :: 8 or of
    _HexDigit_ :: 8 is 8.

-   The MV of _DecimalDigit_ :: 9 or of _NonZeroDigit_ :: 9 or of
    _HexDigit_ :: 9 is 9.

-   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   The
    MV of _HexDigit_ :: A or of _HexDigit_ :: A is 10.

-   The MV of _HexDigit_ :: B or of _HexDigit_ :: B is 11.

-   The MV of _HexDigit_ :: C or of _HexDigit_ :: C is 12.

-   The MV of _HexDigit_ :: D or of _HexDigit_ :: D is 13.

-   The MV of _HexDigit_ :: E or of _HexDigit_ :: E is 14.

-   The MV of _HexDigit_ :: F or of _HexDigit_ :: F is 15.

-   The MV of _BinaryIntegerLiteral_ :: 0B _BinaryDigit_ is the MV of
    _BinaryDigit_.

-   The MV of _BinaryIntegerLiteral_ :: 0B _BinaryDigit_ is the MV of
    _BinaryDigit_.

-   The MV of _BinaryIntegerLiteral_ :: _BinaryIntegerLiteral_
    _BinaryDigit_ is (the MV of _BinaryIntegerLiteral_ times 2) plus the
    MV of _BinaryDigit_.

-   The MV of _OctalIntegerLiteral_ :: 0O _OctalDigit_ is the MV of
    _OctalDigit_.

-   The MV of _OctalIntegerLiteral_ :: 0O _OctalDigit_ is the MV of
    _OctalDigit_.

-   The MV of _OctalIntegerLiteral_ :: _OctalIntegerLiteral_
    _OctalDigit_ is (the MV of _OctalIntegerLiteral_ times 8) plus the
    MV of _OctalDigit_.

-   The MV of _HexIntegerLiteral_ :: 0X _HexDigits_ is the MV of
    _HexDigits_.

-   The MV of _HexIntegerLiteral_ :: 0X _HexDigits_ is the MV of
    _HexDigits_.

-   The MV of _HexDigits_ :: _HexDigit_ is the MV of _HexDigit_.

-   The MV of _HexDigits_ :: _HexDigits_ _HexDigit_ is (the MV of
    _HexDigits_ times 16) plus the MV of _HexDigit_.

Once the exact MV for a numeric literal has been determined, it is then
rounded to a value of the Number type. If the MV is 0, then the rounded
value is +0; otherwise, the rounded value must be the Number value for
the MV (as specified in 8.5), unless the literal is a _DecimalLiteral_
and the literal has more than 20 significant digits, in which case the
Number value may be either the Number value for the MV of a literal
produced by replacing each significant digit after the 20th with a 0
digit or the Number value for the MV of a literal produced by replacing
each significant digit after the 20th with a 0 digit and then
incrementing the literal at the 20th significant digit position. A digit
is _significant_ if it is not part of an _ExponentPart_ and

-   it is not 0; or

-   there is a nonzero digit to its left and there is a nonzero digit,
    not in the _ExponentPart_, to its right.

-   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   

  -- -- -- --
           
           
           
           
           
           
           
           
           
           
  -- -- -- --

-   -   -   -   -   -   

7.8.4 Regular Expression Literals

NOTE A regular expression literal is an input element that is converted
to a RegExp object (see 15.10) each time the literal is evaluated. Two
regular expression literals in a program evaluate to regular expression
objects that never compare as === to each other even if the two
literals' contents are identical. A RegExp object may also be created at
runtime by NEW REGEXP (see 15.10.4) or calling the REGEXP constructor as
a function (15.10.3).

The productions below describe the syntax for a regular expression
literal and are used by the input element scanner to find the end of the
regular expression literal. The source code comprising the
_RegularExpressionBody_ and the _RegularExpressionFlags_ are
subsequently parsed using the more stringent ECMAScript Regular
Expression grammar (15.10.1).

An implementation may extend the ECMAScript Regular Expression grammar
defined in 15.10.1, but it must not extend the _RegularExpressionBody_
and _RegularExpressionFlags_ productions defined below or the
productions used by these productions.

Syntax

RegularExpressionLiteral ::

/ RegularExpressionBody / RegularExpressionFlags

RegularExpressionBody ::

RegularExpressionFirstChar RegularExpressionChars

RegularExpressionChars ::

[empty]
RegularExpressionChars RegularExpressionChar

RegularExpressionFirstChar ::

RegularExpressionNonTerminator BUT NOT ONE OF * OR \ OR / OR [
RegularExpressionBackslashSequence
RegularExpressionClass

RegularExpressionChar ::

RegularExpressionNonTerminator BUT NOT ONE OF \ OR / OR [
RegularExpressionBackslashSequence
RegularExpressionClass

RegularExpressionBackslashSequence ::

\ RegularExpressionNonTerminator

RegularExpressionNonTerminator ::

SourceCharacter BUT NOT LineTerminator

RegularExpressionClass ::

[ RegularExpressionClassChars ]

RegularExpressionClassChars ::

[empty]
RegularExpressionClassChars RegularExpressionClassChar

RegularExpressionClassChar ::

RegularExpressionNonTerminator BUT NOT ONE OF ] OR \
RegularExpressionBackslashSequence

RegularExpressionFlags ::

[empty]
RegularExpressionFlags IdentifierPart

NOTE Regular expression literals may not be empty; instead of
representing an empty regular expression literal, the characters //
start a single-line comment. To specify an empty regular expression,
use: /(?:)/.

STATIC SEMANTICS: EARLY ERRORS

_RegularExpressionFlags_:: _RegularExpressionFlags IdentifierPart 

-   It is a Syntax Error if _IdentifierPart_ contains a Unicode escape
    sequence.

STATIC SEMANTICS: BODYTEXT

_RegularExpressionLiteral_ :: / _RegularExpressionBody_ /
_RegularExpressionFlags

1.  Return the source code that was recognised as
    _RegularExpressionBody_.

STATIC SEMANTICS: FLAGTEXT

_RegularExpressionLiteral_ :: / _RegularExpressionBody_ /
_RegularExpressionFlags

1.  Return the source code that was recognised as
    _RegularExpressionFlags_.

7.8.5 Template Literal Lexical Components

Syntax

Template ::

NoSubstitutionTemplate
TemplateHead

NoSubstitutionTemplate ::

` TemplateCharacters~opt~ `

TemplateHead ::

` TemplateCharacters~opt~ ${

TemplateSubstitutionTail ::

TemplateMiddle
TemplateTail

TemplateMiddle ::

} TemplateCharacters~opt~ ${

TemplateTail ::

} TemplateCharacters~opt~ `

TemplateCharacters ::

TemplateCharacter TemplateCharacters~opt~

TemplateCharacter ::

SourceCharacter BUT NOT ONE OF ` OR \ OR $
$ [lookahead ∉ { ]
\ EscapeSequence
LineContinuation

STATIC SEMANTICS: TV’S AND TRV’S

A template literal component is interpreted as a sequence of Unicode
characters. The Template Value (TV) of a literal component is described
in terms of code unit values (CV, 7.8.4) contributed by the various
parts of the template literal component. As part of this process, some
Unicode characters within the template component are interpreted as
having a mathematical value (MV, 7.8.3). In determining a TV, escape
sequences are replaced by the code unit of the Unicode characters
represented by the escape sequence. The Template Raw Value (TRV) is
similar to a Template Value with the difference that in TRVs escape
sequences are interpreted literally.

-   The TV and TRV of _NoSubstitutionTemplate_ :: `` is the empty code
    unit sequence.

-   The TV and TRV of _TemplateHead_ :: `${ is the empty code unit
    sequence.

-   The TV and TRV of _TemplateMiddle_ :: }${ is the empty code unit
    sequence.

-   The TV and TRV of _TemplateTail_ :: }` is the empty code unit
    sequence.

-   The TV of _NoSubstitutionTemplate_ :: ` _TemplateCharacters_ ` is
    the TV of _TemplateCharacters_.

-   The TV of _TemplateHead_ :: ` _TemplateCharacters_ ${ is the TV of
    _TemplateCharacters_.

-   The TV of _TemplateMiddle_ :: } _TemplateCharacters_ ${ is the TV of
    _TemplateCharacters_.

-   The TV of _TemplateTail_ :: } _TemplateCharacters_ ` is the TV of
    _TemplateCharacters_.

-   The TV of _TemplateCharacters_ :: _TemplateCharacter_ is the TV of
    _TemplateCharacter_.

-   The TV of _TemplateCharacters_ :: _TemplateCharacter_
    _TemplateCharacters_ is a sequence consisting of the code units in
    the TV of _TemplateCharacter_ followed by all the code units in the
    TV of _TemplateCharacters_ in order.

-   The TV of _TemplateCharacter_ :: _SourceCharacter_ BUT NOT ONE OF `
    OR \ OR $ is the UTF-16 Encoding (clause 6) of the code point value
    of _SourceCharacter_.

-   The TV of _TemplateCharacter_ :: $ [lookahead ∉ { ] is the code unit
    value 0x0024.

-   The TV of _TemplateCharacter_ :: \ _EscapeSequence_ is the CV of
    _EscapeSequence_.

-   The TV of _TemplateCharacter_ :: _LineContinuation_ is the TV of
    _LineContinuation_.

-   The TV of _LineContinuation_ :: \ _LineTerminatorSequence_ is the
    empty code unit sequence.

-   The TRV of _NoSubstitutionTemplate_ :: ` _TemplateCharacters_ ` is
    the TRV of _TemplateCharacters_.

-   The TRV of _TemplateHead_ :: ` _TemplateCharacters_ ${ is the TRV of
    _TemplateCharacters_.

-   The TRV of _TemplateMiddle_ :: } _TemplateCharacters_ ${ is the TRV
    of _TemplateCharacters_.

-   The TRV of _TemplateTail_ :: } _TemplateCharacters_ ` is the TRV of
    _TemplateCharacters_.

-   The TRV of _TemplateCharacters_ :: _TemplateCharacter_ is the TRV of
    _TemplateCharacter_.

-   The TRV of _TemplateCharacters_ :: _TemplateCharacter_
    _TemplateCharacters_ is a sequence consisting of the code units in
    the TRV of _TemplateCharacter_ followed by all the code units in the
    TRV of _TemplateCharacters,_ in order.

-   The TRV of _TemplateCharacter_ :: _SourceCharacter_ BUT NOT ONE OF `
    OR \ OR $ is the UTF-16 Encoding (clause 6) of the code point value
    of _SourceCharacter_.

-   The TRV of _TemplateCharacter_ :: $ [lookahead ∉ { ] is the code
    unit value 0x0024.

-   The TRV of _TemplateCharacter_ :: \ _EscapeSequence_ is the sequence
    consisting of the code unit value 0x005C followed by the code units
    of TRV of _EscapeSequence_.

-   The TRV of _TemplateCharacter_ :: _LineContinuation_ is the TRV of
    _LineContinuation_.

-   The TRV of _EscapeSequence_ :: _CharacterEscapeSequence_ is the TRV
    of the _CharacterEscapeSequence_.

-   The TRV of _EscapeSequence_ :: 0 [lookahead ∉ _DecimalDigit_] is the
    code unit value 0x0030.

-   The TRV of _EscapeSequence_ :: _HexEscapeSequence_ is the TRV of the
    _HexEscapeSequence_.

-   The TRV of _EscapeSequence_ :: _UnicodeEscapeSequence_ is the TRV of
    the _UnicodeEscapeSequence_.

-   The TRV of _CharacterEscapeSequence_ :: _SingleEscapeCharacter_ is
    the TRV of the _SingleEscapeCharacter_.

-   The TRV of _CharacterEscapeSequence_ :: _NonEscapeCharacter_ is the
    CV of the _NonEscapeCharacter_.

-   The TRV of _SingleEscapeCharacter_ :: ONE OF ' " \ B F N R T V is
    the CV of the _SourceCharacter_ that is that single character.

-   The TRV of _HexEscapeSequence_ :: X _HexDigit HexDigit_ is the
    sequence consisting of code unit value 0x0078 followed by TRV of the
    first _HexDigit_ followed by the TRV of the second _HexDigit_.

-   The TRV of _UnicodeEscapeSequence_ :: U _HexDigit_ _HexDigit_
    _HexDigit_ _HexDigit_ is the sequence consisting of code unit value
    0x0075 followed by TRV of the first _HexDigit_ followed by the TRV
    of the second _HexDigit_ followed by TRV of the third _HexDigit_
    followed by the TRV of the fourth _HexDigit_.

-   The TRV of _UnicodeEscapeSequence_ :: U{ _HexDigits_ } is the
    sequence consisting of code unit value 0x0075 followed by code unit
    value 0x007B followed by TRV of _HexDigits_ followed by code unit
    value 0x007D.

-   The TRV of _HexDigits_ :: _HexDigit_ is the TRV of _HexDigit_.

-   The TRV of _HexDigits_ :: _HexDigits_ _HexDigit_ is the sequence
    consisting of TRV of _HexDigits_ followed by TRV of _HexDigit_.

-   The TRV of a _HexDigit_ is the CV of the _SourceCharacter_ that is
    that _HexDigit_.

-   The TRV of _LineContinuation_ :: \ _LineTerminatorSequence_ is the
    sequence consisting of the code unit value 0x005C followed by the
    code units of TRV of _LineTerminatorSequence_.

-   The TRV of _LineTerminatorSequence_ :: <LF> is the code unit value
    0x000A.

-   The TRV of _LineTerminatorSequence_ :: <CR> [lookahead ∉ <LF> ] is
    the code unit value 0x000D.

-   The TRV of _LineTerminatorSequence_ :: <LS> is the code unit value
    0x2028.

-   The TRV of _LineTerminatorSequence_ :: <PS> is the code unit value
    0x2029.

-   The TRV of _LineTerminatorSequence_ :: <CR><LF> is the sequence
    consisting of the code unit value 0x000D followed by the code unit
    value 0x000A.

NOTE TV excludes the code units of _LineContinuation_ while TRV includes
them.

7.8.6 String Literals

NOTE A string literal is zero or more Unicode code points enclosed in
single or double quotes. Unicode code points may also be represented by
an escape sequence. All characters may appear literally in a string
literal except for the closing quote character, backslash, carriage
return, line separator, paragraph separator, and line feed. Any
character may appear in the form of an escape sequence. String literals
evaluate to ECAMScript String values. When generating these string
values Unicode code points are UTF-16 encoded as defined in clause 6.
Code points belonging to Basic Multilingual Plane are encoded as a
single code unit element of the string. All other code points are
encoded as two code unit elements of the string.

Syntax

StringLiteral ::

" DoubleStringCharacters~opt~ "
' SingleStringCharacters~opt~ '

DoubleStringCharacters ::

DoubleStringCharacter DoubleStringCharacters~opt~

SingleStringCharacters ::

SingleStringCharacter SingleStringCharacters~opt~

DoubleStringCharacter ::

SourceCharacter BUT NOT ONE OF " OR \ OR LineTerminator
\ EscapeSequence
LineContinuation

SingleStringCharacter ::

SourceCharacter BUT NOT ONE OF ' OR \ OR LineTerminator
\ EscapeSequence
LineContinuation

LineContinuation ::

\ LineTerminatorSequence

EscapeSequence ::

CharacterEscapeSequence
0 [lookahead ∉ DecimalDigit]
HexEscapeSequence
UnicodeEscapeSequence

A conforming implementation, when processing strict mode code (see
10.1.1), must not extend the syntax of _EscapeSequence_ to include
_OctalEscapeSequence_ as described in B.1.2.

CharacterEscapeSequence ::

SingleEscapeCharacter
NonEscapeCharacter

SingleEscapeCharacter :: ONE OF

' " \ B F N R T V

NonEscapeCharacter ::

SourceCharacter BUT NOT ONE OF EscapeCharacter OR LineTerminator

EscapeCharacter ::

SingleEscapeCharacter
DecimalDigit
X
U

HexEscapeSequence ::

X HexDigit HexDigit

UnicodeEscapeSequence ::

U HexDigit HexDigit HexDigit HexDigit
U{ HexDigits }

The definition of the nonterminal _HexDigit_ is given in 7.8.3.
_SourceCharacter_ is defined in clause 6.

NOTE A line terminator character cannot appear in a string literal,
except as part of a _LineContinuation_ to produce the empty character
sequence. The correct way to cause a line terminator character to be
part of the String value of a string literal is to use an escape
sequence such as \N or \U000A.

STATIC SEMANTICS

STATIC SEMANTICS: EARLY ERRORS

_UnicodeEscapeSequence_ :: U{ _HexDigits_ }

-   It is a Syntax Error if the MV of _HexDigits_ > 1114111.

STATIC SEMANTICS: SV’S AND CV’S

A string literal stands for a value of the String type. The String value
(SV) of the literal is described in terms of code unit values (CV)
contributed by the various parts of the string literal. As part of this
process, some Unicode characters within the string literal are
interpreted as having a mathematical value (MV), as described below or
in 7.8.3.

-   The SV of _StringLiteral_ :: "" is the empty code unit sequence.

-   The SV of _StringLiteral_ :: '' is the empty code unit sequence.

-   The SV of _StringLiteral_ :: " _DoubleStringCharacters_ " is the SV
    of _DoubleStringCharacters_.

-   The SV of _StringLiteral_ :: ' _SingleStringCharacters_ ' is the SV
    of _SingleStringCharacters_.

-   The SV of _DoubleStringCharacters_ :: _DoubleStringCharacter_ is a
    sequence of one or two code units that is the CV of
    _DoubleStringCharacter_.

-   The SV of _DoubleStringCharacters_ :: _DoubleStringCharacter_
    _DoubleStringCharacters_ is a sequence of one or two code units that
    is the CV of _DoubleStringCharacter_ followed by all the code units
    in the SV of _DoubleStringCharacters_ in order.

-   The SV of _SingleStringCharacters_ :: _SingleStringCharacter_ is a
    sequence of one or two code units that is the CV of
    _SingleStringCharacter_.

-   The SV of _SingleStringCharacters_ :: _SingleStringCharacter_
    _SingleStringCharacters_ is a sequence of one or two code units that
    is the CV of _SingleStringCharacter_ followed by all the code units
    in the SV of _SingleStringCharacters_ in order.

-   The SV of _LineContinuation_ :: \ _LineTerminatorSequence_ is the
    empty code unit sequence.

-   The CV of _DoubleStringCharacter_ :: _SourceCharacter_ BUT NOT ONE
    OF " OR \ OR _LineTerminator_ is the UTF-16 Encoding (clause 6) of
    the code point value of _SourceCharacter_.

-   The CV of _DoubleStringCharacter_ :: \ _EscapeSequence_ is the CV of
    the _EscapeSequence_.

-   The CV of _DoubleStringCharacter_ :: _LineContinuation_ is the empty
    character sequence.

-   The CV of _SingleStringCharacter_ :: _SourceCharacter_ BUT NOT ONE
    OF ' OR \ OR _LineTerminator_ is the UTF-16 Encoding (clause 6) of
    the code point value of _SourceCharacter_ .

-   The CV of _SingleStringCharacter_ :: \ _EscapeSequence_ is the CV of
    the _EscapeSequence_.

-   The CV of _SingleStringCharacter_ :: _LineContinuation_ is the empty
    character sequence.

-   The CV of _EscapeSequence_ :: _CharacterEscapeSequence_ is the CV of
    the _CharacterEscapeSequence_.

-   The CV of _EscapeSequence_ :: 0 [lookahead ∉ _DecimalDigit_] is the
    code unit value 0.

-   The CV of _EscapeSequence_ :: _HexEscapeSequence_ is the CV of the
    _HexEscapeSequence_.

-   The CV of _EscapeSequence_ :: _UnicodeEscapeSequence_ is the CV of
    the _UnicodeEscapeSequence_.

-   The CV of _CharacterEscapeSequence_ :: _SingleEscapeCharacter_ is
    the character whose code unit value is determined by the
    _SingleEscapeCharacter_ according to :

Table 4 — String Single Character Escape Sequences

  ------------------- ------------------- ---------------------- ----------
  _ESCAPE SEQUENCE_   _CODE UNIT VALUE_   _NAME_                 _SYMBOL_
  \B                  0X0008              backspace              <BS>
  \T                  0X0009              horizontal tab         <HT>
  \N                  0X000A              line feed (new line)   <LF>
  \V                  0X000B              vertical tab           <VT>
  \F                  0X000C              form feed              <FF>
  \R                  0X000D              carriage return        <CR>
  \"                  0X0022              double quote           "
  \'                  0X0027              single quote           '
  \\                  0X005C              backslash              \
  ------------------- ------------------- ---------------------- ----------

-   The CV of _CharacterEscapeSequence_ :: _NonEscapeCharacter_ is the
    CV of the _NonEscapeCharacter_.

-   The CV of _NonEscapeCharacter_ :: _SourceCharacter_ BUT NOT ONE OF
    _EscapeCharacter_ OR _LineTerminator_ is the UTF-16 Encoding (clause
    6) of the code point value of _SourceCharacter_ .

-   The CV of _HexEscapeSequence_ :: X _HexDigit_ _HexDigit_ is the code
    unit value that is (16 times the MV of the first _HexDigit_) plus
    the MV of the second _HexDigit_.

-   The CV of _UnicodeEscapeSequence_ :: U _HexDigit_ _HexDigit_
    _HexDigit_ _HexDigit_ is the code unit value that is (4096 times the
    MV of the first _HexDigit_) plus (256 times the MV of the second
    _HexDigit_) plus (16 times the MV of the third _HexDigit_) plus the
    MV of the fourth _HexDigit_.

-   The CV of _UnicodeEscapeSequence_ :: U{ _HexDigits_ } the is the
    UTF-16 Encoding (clause 6) of the MV of _HexDigits_.


7.9 Automatic Semicolon Insertion

Certain ECMAScript statements (empty statement, variable statement,
expression statement, DO-WHILE statement, CONTINUE statement, BREAK
statement, RETURN statement, and THROW statement) must be terminated
with semicolons. Such semicolons may always appear explicitly in the
source text. For convenience, however, such semicolons may be omitted
from the source text in certain situations. These situations are
described by saying that semicolons are automatically inserted into the
source code token stream in those situations.

7.9.1 Rules of Automatic Semicolon Insertion

There are three basic rules of semicolon insertion:

1.  When, as the script is parsed from left to right, a token (called
    the _offending token_) is encountered that is not allowed by any
    production of the grammar, then a semicolon is automatically
    inserted before the offending token if one or more of the following
    conditions is true:

-   The offending token is separated from the previous token by at least
    one _LineTerminator_.

-   The offending token is }.

    1.  When, as the script is parsed from left to right, the end of the
        input stream of tokens is encountered and the parser is unable
        to parse the input token stream as a single complete ECMAScript
        _script_, then a semicolon is automatically inserted at the end
        of the input stream.

    2.  When, as the script is parsed from left to right, a token is
        encountered that is allowed by some production of the grammar,
        but the production is a _restricted production_ and the token
        would be the first token for a terminal or nonterminal
        immediately following the annotation “[no _LineTerminator_
        here]” within the restricted production (and therefore such a
        token is called a restricted token), and the restricted token is
        separated from the previous token by at least one
        _LineTerminator_, then a semicolon is automatically inserted
        before the restricted token.

However, there is an additional overriding condition on the preceding
rules: a semicolon is never inserted automatically if the semicolon
would then be parsed as an empty statement or if that semicolon would
become one of the two semicolons in the header of a FOR statement (see
12.6.3).

NOTE The following are the only restricted productions in the grammar:

PostfixExpression :

LeftHandSideExpression [no LineTerminator here] ++
LeftHandSideExpression [no LineTerminator here] --

ContinueStatement :

CONTINUE [no LineTerminator here] Identifier ;

BreakStatement :

BREAK [no LineTerminator here] Identifier ;

ReturnStatement :

RETURN [no LineTerminator here] Expression ;

ThrowStatement :

THROW [no LineTerminator here] Expression ;

The practical effect of these restricted productions is as follows:

  When a ++ or -- token is encountered where the parser would treat it
  as a postfix operator, and at least one _LineTerminator_ occurred
  between the preceding token and the ++ or -- token, then a semicolon
  is automatically inserted before the ++ or -- token.

  When a CONTINUE, BREAK, RETURN, or THROW token is encountered and a
  _LineTerminator_ is encountered before the next token, a semicolon is
  automatically inserted after the CONTINUE, BREAK, RETURN, or THROW
  token.

The resulting practical advice to ECMAScript programmers is:

  A postfix ++ or -- operator should appear on the same line as its
  operand.

  An _Expression_ in a RETURN or THROW statement should start on the
  same line as the RETURN or THROW token.

  An _Identifier_ in a BREAK or CONTINUE statement should be on the same
  line as the BREAK or CONTINUE token.

7.9.2 Examples of Automatic Semicolon Insertion

The source

  { 1 2 } 3

is not a valid sentence in the ECMAScript grammar, even with the
automatic semicolon insertion rules. In contrast, the source

  { 1
  2 } 3

is also not a valid ECMAScript sentence, but is transformed by automatic
semicolon insertion into the following:

  { 1
  ;2 ;} 3;

which is a valid ECMAScript sentence.

The source

  for (a; b
  )

is not a valid ECMAScript sentence and is not altered by automatic
semicolon insertion because the semicolon is needed for the header of a
FOR statement. Automatic semicolon insertion never inserts one of the
two semicolons in the header of a FOR statement.

The source

  return
  a + b

is transformed by automatic semicolon insertion into the following:

  return;
  a + b;

NOTE The expression A + B is not treated as a value to be returned by
the RETURN statement, because a _LineTerminator_ separates it from the
token RETURN.

The source

  a = b
  ++c

is transformed by automatic semicolon insertion into the following:

  a = b;
  ++c;

NOTE The token ++ is not treated as a postfix operator applying to the
variable B, because a _LineTerminator_ occurs between B and ++.

The source

  if (a > b)
  else c = d

is not a valid ECMAScript sentence and is not altered by automatic
semicolon insertion before the ELSE token, even though no production of
the grammar applies at that point, because an automatically inserted
semicolon would then be parsed as an empty statement.

The source

  a = b + c
  (d + e).print()

is _not_ transformed by automatic semicolon insertion, because the
parenthesised expression that begins the second line can be interpreted
as an argument list for a function call:

a = b + c(d + e).print()

In the circumstance that an assignment statement must begin with a left
parenthesis, it is a good idea for the programmer to provide an explicit
semicolon at the end of the preceding statement rather than to rely on
automatic semicolon insertion.

Algorithms within this specification manipulate values each of which has
an associated type. The possible value types are exactly those defined
in this clause. Types are further subclassified into ECMAScript language
types and specification types.

Within this specification, the notation “Type(_x_)” is used as shorthand
for “the type of _x_” where “type” refers to the ECMAScript language and
specification types defined in this clause.


8.1 ECMAScript Language Types

An ECMAScript language type corresponds to values that are directly
manipulated by an ECMAScript programmer using the ECMAScript language.
The ECMAScript language types are Undefined, Null, Boolean, String,
Number, Symbol, and Object. An ECMAScript language value is a value that
is characterized by an ECMAScript language type.

8.1.1 The Undefined Type

The Undefined type has exactly one value, called UNDEFINED. Any variable
that has not been assigned a value has the value UNDEFINED.

8.1.2 The Null Type

The Null type has exactly one value, called NULL.

8.1.3 The Boolean Type

The Boolean type represents a logical entity having two values, called
TRUE and FALSE.

8.1.4 The String Type

The String type is the set of all finite ordered sequences of zero or
more 16-bit unsigned integer values (“elements”). The String type is
generally used to represent textual data in a running ECMAScript
program, in which case each element in the String is treated as a UTF-16
code unit value. Each element is regarded as occupying a position within
the sequence. These positions are indexed with nonnegative integers. The
first element (if any) is at index 0, the next element (if any) at index
1, and so on. The length of a String is the number of elements (i.e.,
16-bit values) within it. The empty String has length zero and therefore
contains no elements.

Where ECMAScript operations interpret String values, each element is
interpreted as a single UTF-16 code unit. However, ECMAScript does not
place any restrictions or requirements on the sequence of code units in
a String value, so they may be ill-formed when interpreted as UTF-16
code unit sequences. Operations that do not interpret String contents
treat them as sequences of undifferentiated 16-bit unsigned integers. No
operations ensure that Strings are in a normalized form. Only operations
that are explicitly specified to be language or locale sensitive produce
language-sensitive results

-   

NOTE The rationale behind this design was to keep the implementation of
Strings as simple and high-performing as possible. If ECMAScript source
code is in Normalised Form C, string literals are guaranteed to also be
normalised, as long as they do not contain any Unicode escape sequences.

Some operations interpret String contents as UTF-16 encoded Unicode code
points. In that case the interpretation is:

-   A code unit in the range 0 to 0xD7FF or in the range 0xE000 to
    0xFFFF is interpreted as a code point with the same value.

-   A sequence of two code units, where the first code unit _c1_ is in
    the range 0xD800 to 0xDBFF and the second code unit _c2_ is in the
    range 0xDC00 to 0xDFFF, is a surrogate pair and is interpreted as a
    code point with the value (_c1_ - 0xD800) × 0x400 + (_c2_ –
    0xDC00) + 0x10000.

-   A code unit that is in the range 0xD800 to 0xDFFF, but is not part
    of a surrogate pair, is interpreted as a code point with the same
    value.

8.1.5 The Number Type

The Number type has exactly 18437736874454810627 (that is,
2^64^−2^53^+3) values, representing the double-precision 64-bit format
IEEE 754 values as specified in the IEEE Standard for Binary
Floating-Point Arithmetic, except that the 9007199254740990 (that is,
2^53^−2) distinct “Not-a-Number” values of the IEEE Standard are
represented in ECMAScript as a single special NAN value. (Note that the
NAN value is produced by the program expression NAN.) In some
implementations, external code might be able to detect a difference
between various Not-a-Number values, but such behaviour is
implementation-dependent; to ECMAScript code, all NaN values are
indistinguishable from each other.

There are two other special values, called POSITIVE INFINITY and
NEGATIVE INFINITY. For brevity, these values are also referred to for
expository purposes by the symbols +∞ and −∞, respectively. (Note that
these two infinite Number values are produced by the program expressions
+INFINITY (or simply INFINITY) and -INFINITY.)

The other 18437736874454810624 (that is, 2^64^−2^53^) values are called
the finite numbers. Half of these are positive numbers and half are
negative numbers; for every finite positive Number value there is a
corresponding negative value having the same magnitude.

Note that there is both a POSITIVE ZERO and a NEGATIVE ZERO. For
brevity, these values are also referred to for expository purposes by
the symbols +0 and −0, respectively. (Note that these two different zero
Number values are produced by the program expressions +0 (or simply 0)
and -0.)

The 18437736874454810622 (that is, 2^64^−2^53^−2) finite nonzero values
are of two kinds:

18428729675200069632 (that is, 2^64^−2^54^) of them are normalised,
having the form

  _s_ × _m_ × 2_^e^_

where _s_ is +1 or −1, _m_ is a positive integer less than 2^53^ but not
less than 2^52^, and _e_ is an integer ranging from −1074 to 971,
inclusive.

The remaining 9007199254740990 (that is, 2^53^−2) values are
denormalised, having the form

  _s_ × _m_ × 2_^e^_

where _s_ is +1 or −1, _m_ is a positive integer less than 2^52^, and
_e_ is −1074.

Note that all the positive and negative integers whose magnitude is no
greater than 2^53^ are representable in the Number type (indeed, the
integer 0 has two representations, +0 and -0).

A finite number has an _odd significand_ if it is nonzero and the
integer _m_ used to express it (in one of the two forms shown above) is
odd. Otherwise, it has an _even significand_.

In this specification, the phrase “the Number value for _x_” where _x_
represents an exact nonzero real mathematical quantity (which might even
be an irrational number such as π) means a Number value chosen in the
following manner. Consider the set of all finite values of the Number
type, with −0 removed and with two additional values added to it that
are not representable in the Number type, namely 2^1024^ (which is +1 ×
2^53^ × 2^971^) and −2^1024^ (which is −1 × 2^53^ × 2^971^). Choose the
member of this set that is closest in value to _x_. If two values of the
set are equally close, then the one with an even significand is chosen;
for this purpose, the two extra values 2^1024^ and −2^1024^ are
considered to have even significands. Finally, if 2^1024^ was chosen,
replace it with +∞; if −2^1024^ was chosen, replace it with −∞; if +0
was chosen, replace it with −0 if and only if _x_ is less than zero; any
other chosen value is used unchanged. The result is the Number value for
_x_. (This procedure corresponds exactly to the behaviour of the IEEE
754 “round to nearest” mode.)

Some ECMAScript operators deal only with integers in the range −2^31^
through 2^31^−1, inclusive, or in the range 0 through 2^32^−1,
inclusive. These operators accept any value of the Number type but first
convert each such value to one of 2^32^ integer values. See the
descriptions of the ToInt32 and ToUint32 operators in 9.5 and 9.6,
respectively.

8.1.6 The Symbol Type

The Symbol type is the set of all non-String values that may be used as
the key of an Object property (8.1.7).

Each possible Symbol values is unique and immutable.

Symbol values have a single observable attribute called [[Private]]
whose immutable value is either TRUE or FALSE. A _private symbol_ is a
Symbol value whose [[Private]] attribute has the value TRUE.

8.1.7 The Object Type

An Object is logically a collection of properties. Each property is
either a data property, or an accessor property:

-   A _data property_ associates a key value with an ECMAScript language
    value and a set of Boolean attributes.

-   A _accessor property_ associates a key value with one or two
    accessor functions, and a set of Boolean attributes. The accessor
    functions are used to store or retrieve an ECMAScript language value
    that is associated with the property.

Properties are identified using key values. A key value is either an
ECMAScript String value or a Symbol value.

-   Property keys are used to access properties and their values.

There are two kinds of access for properties: _get_ and _set_,
corresponding to value retrieval and assignment, respectively. The
properties accessible via get and set access includes both _own
properties_ that are a direct part of an object and _inherited_
_properties_ which are provided by another associated object via a
property inheritance relationship. Inherited properties may be either
own or inherited properties of the associated object.

All objects are logically collections of properties, but there are
multiple forms of objects that differ in their semantics for accessing
and manipulating their properties. O_rdinary_ _objects_ are the most
common form of objects and have the default object semantics. An _exotic
object_ is any form of object whose property semantics differ in any way
from the default semantics.

8.1.7.1 Property Attributes

Attributes are used in this specification to define and explain the
state of Object properties. A data property associates a key value with
the attributes listed in Table 5.

Table 5 — Attributes of a Data Property

  _ATTRIBUTE NAME_   _VALUE DOMAIN_                 _DESCRIPTION_
  ------------------ ------------------------------ ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  [[Value]]          Any ECMAScript language type   The value retrieved by a get access of the property.
  [[Writable]]       Boolean                        If FALSE, attempts by ECMAScript code to change the property’s [[Value]] attribute using [[Set]] will not succeed.
  [[Enumerable]]     Boolean                        If TRUE, the property will be enumerated by a for-in enumeration (see 12.6.4). Otherwise, the property is said to be non-enumerable.
  [[Configurable]]   Boolean                        If FALSE, attempts to delete the property, change the property to be an accessor property, or change its attributes (other than [[Value]], or changing [[Writable]] to FALSE) will fail.

An accessor property associates a key value with the attributes listed
in Table 6.

Table 6 — Attributes of an Accessor Property

  _ATTRIBUTE NAME_   _VALUE DOMAIN_          _DESCRIPTION_
  ------------------ ----------------------- --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  [[Get]]            Object _or_ Undefined   If the value is an Object it must be a function Object. The function’s [[Call]] internal method (8.6.2) is called with an empty arguments list to retrieve the property value each time a get access of the property is performed.
  [[Set]]            Object _or_ Undefined   If the value is an Object it must be a function Object. The function’s [[Call]] internal method (8.6.2) is called with an arguments list containing the assigned value as its sole argument each time a set access of the property is performed. The effect of a property's [[Set]] internal method may, but is not required to, have an effect on the value returned by subsequent calls to the property's [[Get]] internal method.
  [[Enumerable]]     Boolean                 If TRUE, the property is to be enumerated by a for-in enumeration (see 12.6.4). Otherwise, the property is said to be non-enumerable.
  [[Configurable]]   Boolean                 If FALSE, attempts to delete the property, change the property to be a data property, or change its attributes will fail.

If the initial values of a property’s attributes are not explicitly
specified by this specification, the default value defined in Table 7 is
used.

Table 7 — Default Attribute Values

  ATTRIBUTE NAME     DEFAULT VALUE
  ------------------ ---------------
  [[Value]]          UNDEFINED
  [[Get]]            UNDEFINED
  [[Set]]            UNDEFINED
  [[Writable]]       FALSE
  [[Enumerable]]     FALSE
  [[Configurable]]   FALSE

8.1.7.2 Object Internal Methods and Internal Data Properties

The actual semantics of ECMAScript objects are specified via algorithms
called _internal methods_. Each object in an ECMAScript engine is
associated with a set of internal methods that defines its runtime
behaviour. These internal methods are not part of the ECMAScript
language. They are defined by this specification purely for expository
purposes. However, each object within an implementation of ECMAScript
must behave as specified by the internal methods associated with it. The
exact manner in which this is accomplished is determined by the
implementation.

Internal methods are identified within this specification using names
enclosed in double square brackets [[ ]]. Internal method names are
polymorphic. This means that different ECMAScript object values may
perform different algorithms when a common internal method name is
invoked upon them. If, at runtime, the implementation of an algorithm
attempts to use an internal method of an object that the object does not
support, a TYPEERROR exception is thrown.

Internal data properties correspond to internal state that is associated
with objects and used by various ECMAScript specification algorithms.
Depending upon the specific internal data property such state may
consist of values of any ECMAScript language type or of specific ECMA
specification type values. Unless explicitly specified otherwise,
internal data properties are allocated as part of the process of
creating an ECMAScript object and may not be dynamically added to
ECMAScript objects. Unless specified otherwise, the initial value of an
internal data property is the value UNDEFINED.

Table 8 summarises the _essential internal_ _methods_ used by this
specification that are applicable to all ECMAScript objects. Every
object must have algorithms for all of the essential internal methods.
However, all objects do not necessarily use the same algorithms for
those methods.

The “Signature” column of Table 8 and other similar tables describes the
invocation pattern for each internal method. The invocation pattern
always includes a parenthesised list of descriptive parameter names. If
a parameter name is the same as an ECMAScript type name then the name
describes the required type of the parameter value. If an internal
method explicitly returns a value, its parameter list is followed by the
symbol “→” and the type name of the returned value. The type names used
in signatures refer to the types defined in Clause 8 augmented by the
following additional names. “_any_” means the value may be any
ECMAScript language type. An internal method implicitly returns a
Completion Record as described in 8.8. In addition to its parameters, an
internal method always has access to the object upon which it is invoked
as a method.

Table 8 — Essential Internal Methods

  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  _INTERNAL METHOD_       _SIGNATURE_                                       _DESCRIPTION_
  ----------------------- ------------------------------------------------- -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  [[GetInheritance]]      ()_→_Object or Null                               Determine the object that provides inherited properties for this object. A NULL value indicates that there are no inherited properties. an object.

  [[SetInheritance]]      (_Object_ or Null)_→_Boolean                      Associate with an object another object that provides inherited properties. Passing NULL indicates that there are no inherited properties. Returns TRUE indicating that the operation was completed successfully or FALSE indicating that the operation was not successful.

  [[HasIntegrity]]        (String)_→_Boolean                                Determine whether the property structure of an object is fixed to at least the specified level. The argument is one of the values "NONEXTENSIBLE", "SEALED", or "FROZEN".

  [[SetIntegrity]]        (String)_→_Boolean                                Restrict the mutability of an object’s properties to that which is allowed for the specified integrity level. The argument is one of the values "NONEXTENSIBLE", "SEALED", or "FROZEN". Returns TRUE indicating that the operation was completed successfully or FALSE indicating that the operation was not successful. The integrity level of an object may be raised but may not be lowered.

  [[HasOwnProperty]]      (_propertyKey_) _→_ Boolean                       Returns a Boolean value indicating whether the object already has an own property whose key is _propertyKey_.

  [[GetOwnProperty]]      (_propertyKey_) →                                 Returns a Property Descriptor for the own property of this object whose key is _propertyKey_, or UNDEFINED if no such property exists.
                                                                            
                          Undefined or Property Descriptor                  

  [[HasProperty]]         (_propertyKey_) _→_ Boolean                       Returns a Boolean value indicating whether the object already has either an own or inherited property whose key is _propertyKey_.

  [[Get]]                 (_propertyKey_, _Receiver_) _→ any_               Retrive the value of an object’s property using the _propertyKey_ parameter. If any ECMAScript code must be executed to retrieve the property value, _Receiver_ is used as the THIS value when evaluating the code.

  [[Set]]                 (_propertyKey_,_value_, _Receiver_) _→ Boolean_   Try to set the value of an object’s property indentified by _propertyKey_ to _value_. If any ECMAScript code must be executed to set the property value, _Receiver_ is used as the THIS value when evaluating the code. Returns TRUE indicating that the property value was set or FALSE indicating that it could not be set.

  [[Delete]]              (_propertyKey_) _→_ Boolean                       Removes the own property indentified by the _propertyKey_ parameter from the object. Return FALSE if the property was not deleted and is still present. Return TRUE if the property was deleted or was not present.

  [[DefineOwnProperty]]   (_propertyKey, PropertyDescriptor_) _→_ Boolean   Creates or alters the named own property to have the state described by a Property Descriptor. Returns TRUE indicating that the property was successfully created/updated or FALSE indicating that the property could not be created or updated.

  [[Enumerate]]           ()_→_Object                                       Returns an iterator object over the string values of the keys of the enumerable properties of the object.

                                                                            

  [[OwnPropertyKeys]]     ()_→_Object                                       Returns an Iterator object that produces all of the own property keys for the object except those that are private Symbols.

                                                                            

                                                                            

                                                                            

                                                                            
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Table 9 summarises additional essential internal methods that are
supported by objects that may be called as functions.

Table 9 — Additional Essential Internal Methods of Function Objects

  _INTERNAL METHOD_   _SIGNATURE_                          _DESCRIPTION_
  ------------------- ------------------------------------ ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  [[Call]]            (_any_, a List of _any_) _→_ _any_   Executes code associated with the object. Invoked via a function call expression. The arguments to the internal method are a THIS value and a list containing the arguments passed to the function by a call expression. Objects that implement this internal method are _callable_.
  [[Construct]]       (a List of _any_) _→_ Object         Creates an object. Invoked via the NEW operator. The arguments to the internal method are the arguments passed to the NEW operator. Objects that implement this internal method are called _constructors_. A Function object is not necessarily a constructor and such non-construtor Function object do not have a [[Construct]] internal method.

8.1.7.3 Invariants of the Essential Internal Methods

Current this section is just a bunch of material merged together from
the ES5 spec. and from the wiki Proxy pages. It need to be completely
reworked.

The intent is that it lists all invariants of the Essential Internal
Methods. This includes both invariants that are enforced for Proxy
objects and other invariants that may not be enfored.

Definitions:

-   The _target_ of an internal method is the object the internal method
    is called upon.

-   A _sealed property_ is a non-configurable own property of a target.

-   A _frozen property_ is a non-configurable non-writable own property
    of a target.

-   A new property is a property that does not exist on a non-extensible
    target.

-   Two property descriptors _desc1_ and _desc2_ for a property key
    value are incompatible if:

    1.  _Descl_ is produced by calling [[GetOwnPropertyDescriptor]] of
        _target_ with _key_, and

    2.  Calling [[DefineOwnProperty]] of _target_ with arguments _key_
        and _desc2_ would throw a _TypeError_ exception.

Exotic objects may define additional constraints upon their [[Set]]
internal method behaviour. If possible, exotic objects should not allow
[[Set]] operations in situations where this definition of [[CanPut]]
returns FALSE.

[[GetInheritance]]

Every [[Prototype]] chain must have finite length (that is, starting
from any object, recursively accessing the [[Prototype]] internal data
property must eventually lead to a NULL value).

getOwnPropertyDescriptor

Non-configurability invariant: cannot return incompatible descriptors
for sealed properties 

Non-extensibility invariant: must return UNDEFINED for new properties

Invariant checks:

if trap returns UNDEFINED, check if the property is configurable

 if property exists on target, check if the returned descriptor is
compatible

if returned descriptor is non-configurable, check if the property exists
on the target and is also non-configurable

defineProperty

Non-configurability invariant: cannot succeed (return true) for
incompatible changes to sealed properties 

Non-extensibility invariant: must reject (return FALSE) for new
properties

Invariant checks:

on success, if property exists on target, check if existing descriptor
is compatible with argument descriptor

on success, if argument descriptor is non-configurable, check if the
property exists on the target and is also non-configurable

getOwnPropertyNames

_Non-configurability invariant: must report all sealed properties

Non-extensibility invariant: must not list new property names 

Invariant checks:

check whether all sealed target properties are present in the trap
result

If the target is non-extensible, check that no new properties are listed
in the trap result

deleteProperty

Non-configurability invariant: cannot succeed (return true) for sealed
properties

Invariant checks:

on success, check if the target property is configurable

getPrototypeOf

Invariant check: check whether the target’s prototype and the trap
result are identical (according to the egal operator)

freeze | seal | preventExtensions

Invariant checks:

on success, check if isFrozen(target), isSealed(target) or
!isExtensible(target)

isFrozen | isSealed | isExtensible

Invariant check: check whether the boolean trap result is equal to
isFrozen(target), isSealed(target) or isExtensible(target)

hasOwn

Non-configurability invariant: cannot return FALSE for sealed properties

Non-extensibility invariant: must return FALSE for new properties 

Invariant checks:

if FALSE is returned, check if the target property is configurable

if FALSE is returned, the property does not exist on target, and the
target is non-extensible, throw a TypeError

has

Non-configurability invariant: cannot return FALSE for sealed properties

Invariant checks:

if FALSE is returned, check if the target property is configurable

get

Non-configurability invariant: cannot return inconsistent values for
frozen data properties, and must return UNDEFINED for sealed accessors
with an UNDEFINED getter 

Invariant checks:

if property exists on target as a data property, check whether the
target property’s value and the trap result are identical (according to
the egal operator)

if property exists on target as an accessor, and the accessor’s get
attribute is UNDEFINED, check whether the trap result is also UNDEFINED.

set

Non-configurability invariant: cannot succeed (return true) for frozen
data properties or sealed accessors with an UNDEFINED setter 

Invariant checks:

on success, if property exists on target as a data property, check
whether the target property’s value and the update value are identical
(according to the egal operator)

on success, if property exists on target as an accessor, check whether
the accessor’s set attribute is not UNDEFINED

keys

Non-configurability invariant: must report all enumerable sealed
properties

Non-extensibility invariant: must not list new property names

Invariant checks:

Check whether all enumerable sealed target properties are listed in the
trap result

If the target is non-extensible, check that no new properties are listed
in the trap result

enumerate

Non-configurability invariant: must report all enumerable sealed
properties

Invariant checks:

Check whether all enumerable sealed target properties are listed in the
trap result

  -- -- --
        
        
        
        
        
        
        
        
        
        
        
        
        
        
  -- -- --

~~NOTE This specification defines no ECMAScript language operators or
built-in functions that permit a program to modify an object’s~~
~~[[Prototype]] internal properties or to change the value of
[[Extensible]] from FALSE to TRUE. Implementation specific extensions
that modify~~ ~~[[Prototype]] or [[Extensible]] must not violate the
invariants defined in the preceding paragraph.~~

Unless otherwise specified, the standard ECMAScript objects are ordinary
objects and behave as described in 8.3. Some standard objects are exotic
objects and have behaviour defined in 8.4.

Exotic objects may implement internal methods in any manner unless
specified otherwise; for example, one possibility is that [[Get]] and
[[Set]] for a particular exotic object indeed fetch and store property
values but [[HasOwnProperty]] always generates FALSE. However, if any
specified manipulation of an exotic object's internal properties is not
supported by an implementation, that manipulation must throw a TYPEERROR
exception when attempted.

The [[GetOwnProperty]] internal method of all objects must conform to
the following invariants for each property of the object:

-   If a property is described as a data property and it may return
    different values over time, then either or both of the [[Writable]]
    and [[Configurable]] attributes must be TRUE even if no mechanism to
    change the value is exposed via the other internal methods.

-   If a property is described as a data property and its [[Writable]]
    and [[Configurable]] are both FALSE, then the SameValue (according
    to 9.12) must be returned for the [[Value]] attribute of the
    property on all calls to [[GetOwnProperty]].

-   If the attributes other than [[Writable]] may change over time or if
    the property might disappear, then the [[Configurable]] attribute
    must be TRUE.

-   If the [[Writable]] attribute may change from FALSE to TRUE, then
    the [[Configurable]] attribute must be TRUE.

-   If the result of calling an object’s [[IsExtensible]] internal
    method has been observed by ECMAScript code to be FALSE, then if a
    call to [[GetOwnProperty]] describes a property as non-existent all
    subsequent calls must also describe that property as non-existent.

The [[DefineOwnProperty]] internal method of all objects must not permit
the addition of a new property to an object if the [[Extensible]]
internal method of that object has been observed by ECMAScript code to
be FALSE.

If the result of calling the [[IsExtensible]] internal method of an
object has been observed by ECMAScript code to be FALSE then it must not
subsequently become TRUE.

8.1.7.4 Well-Known Symbols and Intrinsics

Well-known symbols are built-in Symbol values (8.4.4) that are
explicitly referenced by algorithms of this specification. They are
typically used as the keys of properties whose values serve as extension
points of a specification algorithm. Unless otherwise specified,
well-known symbols values are shared by all Code Realms (10.3) and the
value of their [[Private]] attribute is FALSE.

Within this specification a well-known symbol is referred to by using a
notation of the form @@name, where “name” is one of the values listed in
Table 10.

Table 10--Well-known Symbols

  ------------------------ ------------------------------------------------------------------------------------------------------------------------------------------------------------------
  _SPECIFICATION_ _NAME_   _VALUE AND PURPOSE_
  @@create                 A method used to allocate an object. Called from the [[Construct]] internal method.
  @@hasInstance            A method that determines if a constructor object recognizes an object as one of the constructor’s instances. Called by the semantics of the INSTANCEOF operator.
  @@isRegExp               A Boolean value that if true indicates that an object may be used as a regular expression.
  @@iterator               A method that returns the default iterator for an object. Called by the semantics of the for-of statement.
  @@ToPrimitive            A method that converts an object to a corresponding primitive value. Called by the ToPrimitive abstract operation.
  @@toStringTag            A string value that is used in the creation of the default string description of an object. Called by the built-in method Object.prototype.toString.
  ------------------------ ------------------------------------------------------------------------------------------------------------------------------------------------------------------

Well-known intrinsics are built-in objects that are explicitly
referenced by the algorithms of this specification and which usually
have Realm specific identities. Unless otherwise specified each
intrinsic object actually corresponds to a set of similar objects, one
per Realm.

Within this specification a reference such as %name% means the intrinsic
object, associated with the current Realm, corresponding to the name.
Determination of the current Realm and its intrinsics is described in
10.4. The well-known intrincs are listed in Table 11.

Table 11 — Well-known Intrinsic Objects

  --------------------------- ------------------------------------------------------------------------------------------------------
  _INTRINSIC NAME_            _ECMASCRIPT LANGUAGE ASSOCIATION_

  %Object%                    The initial value of the global object property named "OBJECT".

  %ObjectPrototype%           The initial value of the "PROTOTYPE" data property of the intrinsic %Object%.

  %ObjProto_toString%         The initial value of the "TOSTRING" data property of the intrinsic %ObjectPrototype%.

  %Function%                  The initial value of the global object property named "FUNCTION".

  %FunctionPrototype%         The initial value of the "PROTOTYPE" data property of the intrinsic %Function%.

  %Array%                     The initial value of the global object property named "ARRAY".

  %ArrayPrototype%            The initial value of the "PROTOTYPE" data property of the intrinsic %Array%.

  %ArrayIteratorPrototype%    The prototype object used for
                              Iterator objects created by the CreateArrayIterator abstract operation.

  %Map%                       The initial value of the global object property named "MAP".

  %MapPrototype%              The initial value of the "PROTOTYPE" data property of the intrinsic %Map%.

  %MapIteratorPrototype%      The prototype object used for
                              Iterator objects created by the CreateMapIterator abstract operation

  %WeakMap%                   The initial value of the global object property named "WEAKMAP".

  %WeakMapPrototype%          The initial value of the "PROTOTYPE" data property of the intrinsic %WeakMap%.

  %Set%                       The initial value of the global object property named "SET".

  %SetPrototype%              The initial value of the "PROTOTYPE" data property of the intrinsic %Set%.

  %SetIteratorPrototype%      The prototype object used for
                              Iterator objects created by the CreateSetIterator abstract operation

                              

  %GeneratorFunction%         The initial value of the name "GeneratorFunction" exported from the built-in module "std:iteration".

  %Generator%                 The initial value of the name "Generator" exported from the built-in module "std:iteration"

                              

                              

  %ErrorPrototype%            

  %EvalErrorPrototype%        

  %RangeErrorPrototype%       

  %ReferenceErrorPrototype%   

  %SyntaxErrorPrototype%      

  %TypeErrorPrototype%        

  %URIErrorPrototype%         

  %ArrayBuffer%               

  %DateViewPrototype%         

  ???                         
  --------------------------- ------------------------------------------------------------------------------------------------------

  -- -- --
        
        
        
        
        
        
        
        
        
        
        
        
        
        
  -- -- --

  -- -- --
        
        
        
        
        
        
        
        
        
        
        
        
        
  -- -- --


8.2 ECMAScript Specification Types

A specification type corresponds to meta-values that are used within
algorithms to describe the semantics of ECMAScript language constructs
and ECMAScript language types. The specification types are Reference,
List, Completion, Property Descriptor, Lexical Environment, Environment
Record, and Data Block. Specification type values are specification
artefacts that do not necessarily correspond to any specific entity
within an ECMAScript implementation. Specification type values may be
used to describe intermediate results of ECMAScript expression
evaluation but such values cannot be stored as properties of objects or
values of ECMAScript language variables.

8.2.1 Data Blocks

_THIS SECTION IS A PLACEHOLDER FOR DESCRIBING THE DATA BLOCK INTERNAL
TYPE. THE FOLLOWING MATERIAL IS VERBATIUM FROM THE THE BINARY DATA ES
WIKI PROPOSAL. THE MATERIAL HAS NOT YET BEEN REVIEWED OR INTEGRATED WITH
THE REST OF THIS SPEC._

This spec introduces a new, spec-internal block datatype, intuitively
representing a contiguously allocated block of binary data. Blocks are
not ECMAScript language values and appear only in the program store (aka
heap).

A block is one of:

-   a number-block

-   an array-block[t, n]

-   a struct-block[t1, ..., tn]

A number-block is one of:

-   an unsigned-integer; i.e., one of uint8, uint16, uint32, or uint64

-   a signed-integer; i.e., one of int8, int16, int32, or int64

-   a floating-point; i.e., one of float32 or float64

A uintk is an integer in the range [0, 2k). An intk is an integer in the
range [-2k-1, 2k-1). A floatk is a floating-point number representable
as a k-bit IEE754 value.

An array-block[t, n] is an ordered sequence of n blocks of homogeneous
block type t. Each element of the array is stored at in independently
addressable location in the program store, and multiple Data objects may
contain references to the element.

A struct-block[t1, ..., tn] is an ordered sequence of n blocks of
heterogeneous types t1 to tn, respectively. Each field of the struct is
stored at in independently addressable location in the program store,
and multiple Data objects may contain references to the field.

The spec also introduces a datatype of Data objects, which are
ECMAScript objects that encapsulate references to block data in the
program store. Every Data object has the following properties:

[[Class]] = “Data”

[[Value]] : reference[block] – a reference to a block in the program
store

[[DataType]] : reference[Type] – a reference to a Type object describing
this object’s data block

8.2.2 The List and Record Specification Type

The List type is used to explain the evaluation of argument lists (see
11.2.4) in NEW expressions, in function calls, and in other algorithms
where a simple list of values is needed. Values of the List type are
simply ordered sequences of values. These sequences may be of any
length.

The Record type is used to describe data aggregations within the
algorithms of this specification. A Record type value consists of one or
more named fields. The value of each field is either an ECMAScript value
or an abstract value represented by a name associated with the Record
type. Field names are always enclosed in double brackets, for example
[[value]]

For notational convenience within this specification, an object
literal-like syntax can be used to express a Record value. For example,
{[[field1]]: 42, [[field2]]: FALSE, [[field3]]: EMPTY} defines a Record
value that has three fields each of which is initialized to a specific
value. Field name order is not significant. Any fields that are not
explicitly listed are considered to be absent.

In specification text and algorithms, dot notation may be used to refer
to a specific field of a Record value. For example, if R is the record
shown in the previous paragraph then R.[[field2]] is shorthand for “the
field of R named [[field2]]”.

Schema for commonly used Record field combinations may be named, and
that name may be used as a prefix to a literal Record value to identify
the specific kind of aggregations that is being described. For example:
Property Descriptor {[[Value]]: 42, [[Writable]]: FALSE,
[[Configurable]]: TRUE}.

8.2.3 The Completion Record Specification Type

The Completion type is a Record used to explain the runtime propagation
of values and control flow such as the behaviour of statements (BREAK,
CONTINUE, RETURN and THROW) that perform nonlocal transfers of control.

Values of the Completion type are Record values whole fields are defined
as by Table 12.

Table 12 — Completion Record Fields

  -------------- -------------------------------------------------- --------------------------------------------------
  _FIELD NAME_   _VALUE_                                            _MEANING_
  [[type]]       One of NORMAL, BREAK, CONTINUE, RETURN, or THROW   The type of completion that occurred.
  [[value]]      any ECMAScript language value or EMPTY             The value that was produced.
  [[target]]     any ECMAScript identifier or EMPTY                 The target label for directed control transfers.
  -------------- -------------------------------------------------- --------------------------------------------------

The term “abrupt completion” refers to any completion with a [[type]]
value other than NORMAL.

8.2.3.1 NormalCompletion

The abstract operation NormalCompletion with a single _argument_, such
as:

1.  Return NormalCompletion(_argument_).

Is a short hand that is defined as follows:

1.  Return Completion {[[type]]: normal, [[value]]: _argument_,
    [[target]]:empty}.

8.2.3.2 Implicit Completion Values

The algorithms of this specification often implicitly return Completion
Records whose [[type]] is NORMAL. Unless it is otherwise obvious from
the context, an algorithm statement that returns a value that is not a
Completion Record, such as:

Generally means the same thing as:

1.  Return NormalCompletion("INFINITY").

A “return” statement without a value in an algorithm step means the same
thing as:

1.  Return NormalCompletion(UNDEFINED).

Similarly, any reference to a Completion Record value that is in a
context that does not explicitly require a complete Completion Record
value is equivalent to an explicit reference to the [[value]] field of
the Completion Record value unless the Completion Record is an abrupt
completion.

1.  

1.  

8.2.3.3 Throw an Exception

Algorithms steps that say to throw an exception, such as

1.  Throw a TYPEERROR exception.

Mean the same things as:

1.  Return Completion {[[type]]: throw, [[value]]: a newly created
    TYPEERROR object, [[target]]:empty}.

8.2.3.4 ReturnIfAbrupt

Algorithms steps that say

1.  ReturnIfAbrupt(_argument_).

mean the same things as:

1.  If _argument_ is an abrupt completion, then return _argument_.

2.  Else if _argument_ is a Completion Record, then let _argument_ be
    _argument_.[[value]].


8.2.4 The Reference Specification Type

NOTE The Reference type is used to explain the behaviour of such
operators as DELETE, TYPEOF, the assignment operators, the SUPER keyword
and other language features. For example, the left-hand operand of an
assignment is expected to produce a reference.

A REFERENCE is a resolved name or property binding. A Reference consists
of three components, the _base_ value, the _referenced name_ and the
Boolean valued _strict reference_ flag. The _base_ value is either
UNDEFINED, an Object, a Boolean, a String, a Number, or an environment
record (10.2.1). A _base_ value of UNDEFINED indicates that the
Reference could not be resolved to a binding. The _referenced name_ is a
String or Symbol.

A Super Reference is a Reference that is used to represents a name
binding that was expressed using the super keyword. A Super Reference
has an additional _thisValue_ component and its _base_ value will never
be an environment record.

The following abstract operations are used in this specification to
access the components of references:

-   GetBase(V). Returns the _base_ value component of the reference V.

-   GetReferencedName(V). Returns the _referenced name_ component of the
    reference V.

-   -   IsStrictReference(V). Returns the _strict reference_ flag
    component of the reference V.

-   HasPrimitiveBase(V). Returns TRUE if the _base_ value is a Boolean,
    String, or Number.

-   IsPropertyReference(V). Returns TRUE if either the _base_ value is
    an object or HasPrimitiveBase(V) is TRUE; otherwise returns FALSE.

-   IsUnresolvableReference(V). Returns TRUE if the _base_ value is
    UNDEFINED and FALSE otherwise.

-   IsSuperReference(V). Returns TRUE if this reference has a
    _thisValue_ component.

The following abstract operations are used in this specification to
operate on references:

8.2.4.1 GetValue (V)

NOTE The object that may be created in step 5.a.ii is not accessible
outside of the above abstract operation and the ordinary object [[Get]]
internal method. An implementation might choose to avoid the actual
creation of the object.

8.2.4.2 PutValue (V, W)

1.  ReturnIfAbrupt(_V_).

2.  ReturnIfAbrupt(_W_).

3.  4.  5.  If Type(_V_) is not Reference, throw a REFERENCEERROR
    exception.

6.  Let _base_ be the result of calling GetBase(_V_).

7.  If IsUnresolvableReference(_V_), then

    a.  If IsStrictReference(_V_) is TRUE, then

        i.  Throw REFERENCEERROR exception.

    b.  Let _globalObj_ be the result of the abstract operation
        GetGlobalObject.

    c.  Return the result of calling
        Put(_globalObj_,GetReferencedName(_V_), _W_, FALSE).

8.  Else if IsPropertyReference(_V_), then

    a.  If HasPrimitiveBase(_V_) is TRUE, then

        i.  Assert: In this case, _base_ will never be a Symbol, NULL or
            UNDEFINED.

        ii. Set _base_ to ToObject(_base_).

    b.  c.  Let _succeeded_ be the

    d.  result of calling the [[Set]] internal method of _base_ passing
        GetReferencedName(_V_), _W_, and GetThisValue(_V_) as arguments.

    e.  ReturnIfAbrupt(_succeeded_).

    f.  If _succeeded_ is FALSE and IsStrictReference(_V_) is TRUE, then
        throw a TYPEERROR exception.

    g.  Return.

9.  Else _base_ must be a reference whose base is an environment record.
    So,

    a.  Return the result of calling the SetMutableBinding (10.2.1)
        concrete method of _base_, passing GetReferencedName(_V_), _W_,
        and IsStrictReference(_V_) as arguments.

10. Return.

NOTE The object that may be created in step 6.a.ii is not accessible
outside of the above algorithm and the ordinary object [[Set]] internal
method. An implementation might choose to avoid the actual creation of
that object.

8.2.4.3 GetThisValue (V)

1.  ReturnIfAbrupt(_V_).

2.  If Type(_V_) is not Reference, return _V_.

3.  If IsUnresolvableReference(_V_), throw a REFERENCEERROR exception.

4.  If IsSuperReference(_V_), then

    a.  Return the value of the _thisValue_ component of the reference
        _V_.

5.  Return GetBase(_V_).


8.2.5 The Property Descriptor Specification Type

The Property Descriptor type is used to explain the manipulation and
reification of Object property attributes. Values of the Property
Descriptor type are Records composed of named fields where each field’s
name is an attribute name and its value is a corresponding attribute
value as specified in 8.1.6.1. In addition, any field may be present or
absent.

Property Descriptor values may be further classified as data property
descriptors and accessor property descriptors based upon the existence
or use of certain fields. A data property descriptor is one that
includes any fields named either [[Value]] or [[Writable]]. An accessor
property descriptor is one that includes any fields named either [[Get]]
or [[Set]]. Any property descriptor may have fields named [[Enumerable]]
and [[Configurable]]. A Property Descriptor value may not be both a data
property descriptor and an accessor property descriptor; however, it may
be neither. A generic property descriptor is a Property Descriptor value
that is neither a data property descriptor nor an accessor property
descriptor. A fully populated property descriptor is one that is either
an accessor property descriptor or a data property descriptor and that
has all of the fields that correspond to the property attributes defined
in either 8.1.6.1 Table 5 or Table 6.

A Property Descriptor may be derived from an ECMAScript object that has
properties that directly correspond to the fields of a Property
Descriptor. Such a derived Property Descriptor has an additional field
named [[Origin]] whose value is the object from which the Property
Descriptor was derived.

The following abstract operations are used in this specification to
operate upon Property Descriptor values:

8.2.5.1 IsAccessorDescriptor ( Desc )

When the abstract operation IsAccessorDescriptor is called with property
descriptor _Desc_, the following steps are taken:

1.  If _Desc_ is UNDEFINED, then return FALSE.

2.  If both _Desc_.[[Get]] and _Desc_.[[Set]] are absent, then return
    FALSE.

3.  Return TRUE.

8.2.5.2 IsDataDescriptor ( Desc )

When the abstract operation IsDataDescriptor is called with property
descriptor _Desc_, the following steps are taken:

8.2.5.3 IsGenericDescriptor ( Desc )

When the abstract operation IsGenericDescriptor is called with property
descriptor _Desc_, the following steps are taken:

8.2.5.4 FromPropertyDescriptor ( Desc )

When the abstract operation FromPropertyDescriptor is called with
property descriptor _Desc_, the following steps are taken:

The following algorithm assumes that _Desc_ is a fully populated
Property Descriptor, such as that returned from [[GetOwnProperty]] (see
8.12.1).

8.2.5.5 ToPropertyDescriptor ( Obj )

When the abstract operation ToPropertyDescriptor is called with object
_Obj_, the following steps are taken:

8.2.5.6 CompletePropertyDescriptor ( Desc, LikeDesc )

When the abstract operation CompletePropertyDescriptor is called with
Property Descriptor _Desc_, the following steps are taken:

1.  Assert: _LikeDesc_ is either a Property Descriptor or UNDEFINED.

2.  ReturnIfAbrupt(_Desc_).

3.  Assert: _Desc_ is a Property Descriptor

4.  If _LikeDesc_ is UNDEFINED, then set _LikeDesc_ to Record{[[Value]]:
    UNDEFINED, [[Writable]]: FALSE, [[Get]]: UNDEFINED, [[Set]]:
    UNDEFINED, [[Enumerable]]: FALSE, [[Configurable]]: FALSE}.

5.  If either IsGenericDescriptor(_Desc_) or IsDataDescriptor(_Desc_) is
    TRUE, then

    a.  If _Desc_ does not have a [[Value]] field, then set
        _Desc_.[[Value]] to _LikeDesc_.[[Value]].

    b.  If _Desc_ does not have a [[Writable]] field, then set
        _Desc_.[[Writable]] to _LikeDesc_.[[Writable]].

6.  Else,

    a.  If _Desc_ does not have a [[Get]] field, then set _Desc_.[[Get]]
        to _LikeDesc_.[[Get]].

    b.  If _Desc_ does not have a [[Set]] field, then set _Desc_.[[Set]]
        to _LikeDesc_.[[Set]].

7.  If _Desc_ does not have a [[Enumerable]] field, then set
    _Desc_.[[Enumerable]] to _LikeDesc_.[[Enumerable]].

8.  If _Desc_ does not have a [[Configurable]] field, then set
    _Desc_.[[Configurable]] to _LikeDesc_.[[Configurable]].

9.  Return _Desc_.

8.2.6 The Lexical Environment and Environment Record Specification Types

The Lexical Environment and Environment Record types are used to explain
the behaviour of name resolution in nested functions and blocks. These
types and the operations upon them are defined in Clause 10.


8.3 Ordinary Object Internal Methods and Internal Data Properties

Sections 8.3-8.5 will eventually be subsectons of a new toplevel section
that follow the current section 10

All ordinary objects have an internal data property called
[[Prototype]]. The value of this property is either NULL or an object
and is used for implementing inheritance. Data properties of the
[[Prototype]] object are inherited (are visible as properties of the
child object) for the purposes of get access, but not for set access.
Accessor properties are inherited for both get access and set access.

Every ordinary ECMAScript object has a Boolean-valued [[Extensible]]
internal data property that controls whether or not properties may be
added to the object. If the value of the [[Extensible]] internal data
property is FALSE then additional properties may not be added to the
object. In addition, if [[Extensible]] is FALSE the value of
[[Prototype]] internal data properties of the object may not be
modified. Once the value of an object’s [[Extensible]] internal data
property has been set to FALSE it may not be subsequently changed to
TRUE.

In the following algorithm descriptions, assume _O_ is an ordinary
ECMAScript object, _P_ is a property key value, _V_ is any ECMAScript
language value, Desc is a Property Description record, and _B_ is a
Boolean flag.

8.3.1 [[GetInheritance]] ( )

When the [[GetInheritance]] internal method of _O_ is called the
following steps are taken:

1.  Return the value of the [[Prototype]] internal data property of _O_.

8.3.2 [[SetInheritance]] (V)

When the [[SetInheritance]] internal method of _O_ is called with
argument _V_ the following steps are taken:

1.  Assert: Either Type(_V_) is Object or Type(_V_) is Null.

2.  Let _extensible_ be the value of the [[Extensible]] internal data
    property of _O_.

3.  Let _current_ be the value of the [[Prototype]] internal data
    property of _O_.

4.  If SameValue(_V_, _current_), then return TRUE.

5.  If _extensible_ is FALSE, then return FALSE.

6.  If _V_ is not NULL, then

    a.  Let _p_ be _V_.

    b.  Repeat, while _p_ is not NULL

        i.  If SameValue(_p_, _O_) is TRUE, then return FALSE.

        ii. Let _nextp_ be the result of calling the [[GetInheritance]]
            internal method of _p_ with no arguments.

        iii. ReturnIfAbrupt(_nextp_).

        iv. Let _p_ be _nextp_.

7.  Set the value of the [[Prototype]] internal data property of _O_ to
    _V_.

8.  Return TRUE.

8.3.3 [[HasIntegrity]] ( Level )

When the [[HasIntegrity]] internal method of _O_ is called the following
steps are taken:

1.  Assert: _Level_ is one of "NONEXTENSIBLE", "SEALED", or "FROZEN".

2.  If _Level_ is "NONEXTENSIBLE", then

    a.  Return Boolean negation of the value of the [[Extensible]]
        internal data property of _O_

3.  Return the result of TestIntegrityLevel(_O_, _Level_).

4.  

8.3.4 [[SetIntegrity]] ( Level )

When the [[SetIntegrity]] internal method of _O_ is called the following
steps are taken:

1.  Assert: _Level_ is one of "NONEXTENSIBLE", "SEALED", or "FROZEN".

2.  3.  Set the value of the [[Extensible]] internal data property of
    _O_ to FALSE.

4.  If _Level_ is not "NONEXTENSIBLE", then

    a.  Return the result of SetIntegrityLevel(_O_, _Level_).

5.  Return TRUE.

8.3.5 [[HasOwnProperty]] (P)

When the [[HasOwnProperty]] internal method of _O_ is called with
property key _P_, the following steps are taken:

1.  Assert: IsPropertyKey(_P_) is TRUE.

2.  If _O_ does not have an own property with key _P_, return FALSE

3.  Return TRUE.

8.3.6 [[GetOwnProperty]] (P)

When the [[GetOwnProperty]] internal method of _O_ is called with
property key _P_, the following steps are taken:

8.3.6.1 OrdinaryGetOwnProperty (O, P)

When the abstract operation OrdinaryGetOwnProperty is called with Object
_O_ and with property key _P_, the following steps are taken:

1.  Assert: IsPropertyKey(_P_) is TRUE.

2.  3.  If _O_ does not have an own property with key _P_, return
    UNDEFINED.

4.  Let _D_ be a newly created Property Descriptor with no fields.

5.  Let _X_ be _O_’s own property whose key is _P_.

6.  If _X_ is a data property, then

    a.  Set _D_.[[Value]] to the value of _X_’s [[Value]] attribute.

    b.  Set _D_.[[Writable]] to the value of _X_’s [[Writable]]
        attribute

7.  Else _X_ is an accessor property, so

    a.  Set _D_.[[Get]] to the value of _X_’s [[Get]] attribute.

    b.  Set _D_.[[Set]] to the value of _X_’s [[Set]] attribute.

8.  Set _D_.[[Enumerable]] to the value of _X_’s [[Enumerable]]
    attribute.

9.  Set _D_.[[Configurable]] to the value of _X_’s [[Configurable]]
    attribute.

10. Return _D_.

8.3.7 [[DefineOwnProperty]] (P, Desc)

When the [[DefineOwnProperty]] internal method of _O_ is called with
property key _P_ and property descriptor _Desc_, the following steps are
taken:

1.  Return the result of OrdinaryDefineOwnProperty with arguments _O_,
    _P_, and _Desc_.

8.3.7.1 OrdinaryDefineOwnProperty (O, P, Desc)

When the abstract operation OrdinaryDefineOwnProperty is called with
Object _O_, property key _P_, and property descriptors _Desc_ the
following steps are taken:

1.  Let _current_ be the result of calling OrdinaryGetOwnProperty with
    arguments _O_ and _P_.

2.  Let _extensible_ be the value of the [[Extensible]] internal data
    property of _O_.

3.  Return the result of ValidateAndApplyPropertyDescriptor with
    arguments _O_, _P_, _extensible_, _Desc_, and _current_.

8.3.7.2 IsCompatiblePropertyDescriptor (Extensible, Desc, Current)

When the abstract operation IsCompatiblePropertyDescriptor is called
with Boolean value _Extensible_, and property descriptors _Desc_, and
_Current_ the following steps are taken:

1.  Return the result of ValidateAndApplyPropertyDescriptor with
    arguments UNDEFINED, UNDEFINED, _Extensible_, _Desc_, and _Current_.

8.3.7.3 ValidateAndApplyPropertyDescriptor (O, P, extensible, Desc, current)

When the abstract operation ValidateAndApplyPropertyDescriptor is called
with Object _O_, property key _P_, Boolean value _extensible_, and
property descriptors _Desc_, and _current_ the following steps are
taken:

This algorithm contains steps that test various fields of the Property
Descriptor _Desc_ for specific values. The fields that are tested in
this manner need not actually exist in _Desc_. If a field is absent then
its value is considered to be FALSE.

NOTE If UNDEFINED is passed as the _O_ argument only validation is
performed and no object updates are preformed.

1.  Assert: If _O_ is not UNDEFINED then _P_ is a valid property key.

2.  If _current_ is UNDEFINED, then

    a.  If _extensible_ is FALSE, then return FALSE.

    b.  Assert: _extensible_ is TRUE.

    c.  If IsGenericDescriptor(_Desc_) or IsDataDescriptor(_Desc_) is
        TRUE, then

        i.  If _O_ is not UNDEFINED, then create an own data property
            named _P_ of object _O_ whose [[Value]], [[Writable]],
            [[Enumerable]] and [[Configurable]] attribute values are
            described by _Desc_. If the value of an attribute field of
            _Desc_ is absent, the attribute of the newly created
            property is set to its default value.

    d.  Else _Desc_ must be an accessor Property Descriptor,

        i.  If _O_ is not UNDEFINED, then create an own accessor
            property named _P_ of object _O_ whose [[Get]], [[Set]],
            [[Enumerable]] and [[Configurable]] attribute values are
            described by _Desc_. If the value of an attribute field of
            _Desc_ is absent, the attribute of the newly created
            property is set to its default value.

    e.  Return TRUE.

3.  Return TRUE, if every field in _Desc_ is absent.

4.  Return TRUE, if every field in _Desc_ also occurs in _current_ and
    the value of every field in _Desc_ is the same value as the
    corresponding field in _current_ when compared using the SameValue
    algorithm (9.12).

5.  If the [[Configurable]] field of _current_ is FALSE then

    a.  Return FALSE, if the [[Configurable]] field of _Desc_ is TRUE.

    b.  Return FALSE, if the [[Enumerable]] field of _Desc_ is present
        and the [[Enumerable]] fields of _current_ and _Desc_ are the
        Boolean negation of each other.

6.  If IsGenericDescriptor(_Desc_) is TRUE, then no further validation
    is required.

7.  Else if IsDataDescriptor(_current_) and IsDataDescriptor(_Desc_)
    have different results, then

    a.  Return FALSE, if the [[Configurable]] field of _current_ is
        FALSE.

    b.  If IsDataDescriptor(_current_) is TRUE, then

        i.  If _O_ is not UNDEFINED, then convert the property named _P_
            of object _O_ from a data property to an accessor property.
            Preserve the existing values of the converted property’s
            [[Configurable]] and [[Enumerable]] attributes and set the
            rest of the property’s attributes to their default values.

    c.  Else,

        i.  If _O_ is not UNDEFINED, then convert the property named _P_
            of object _O_ from an accessor property to a data property.
            Preserve the existing values of the converted property’s
            [[Configurable]] and [[Enumerable]] attributes and set the
            rest of the property’s attributes to their default values.

8.  Else if IsDataDescriptor(_current_) and IsDataDescriptor(_Desc_) are
    both TRUE, then

    a.  If the [[Configurable]] field of _current_ is FALSE, then

        i.  Return FALSE, if the [[Writable]] field of _current_ is
            FALSE and the [[Writable]] field of _Desc_ is TRUE.

        ii. If the [[Writable]] field of _current_ is FALSE, then

            1.  Return FALSE, if the [[Value]] field of _Desc_ is
                present and SameValue(_Desc_.[[Value]],
                _current_.[[Value]]) is FALSE.

    b.  else the [[Configurable]] field of _current_ is TRUE, so any
        change is acceptable.

9.  Else IsAccessorDescriptor(_current_) and
    IsAccessorDescriptor(_Desc_) are both TRUE,

    a.  If the [[Configurable]] field of _current_ is FALSE, then

        i.  Return FALSE, if the [[Set]] field of _Desc_ is present and
            SameValue(_Desc_.[[Set]], _current_.[[Set]]) is FALSE.

        ii. Return FALSE, if the [[Get]] field of _Desc_ is present and
            SameValue(_Desc_.[[Get]], _current_.[[Get]]) is FALSE.

10. If _O_ is not UNDEFINED, then

    a.  For each attribute field of _Desc_ that is present, set the
        correspondingly named attribute of the property named _P_ of
        object _O_ to the value of the field.

11. Return TRUE.

NOTE Step 8.b allows any field of Desc to be different from the
corresponding field of current if current’s [[Configurable]] field is
TRUE. This even permits changing the [[Value]] of a property whose
[[Writable]] attribute is FALSE. This is allowed because a TRUE
[[Configurable]] attribute would permit an equivalent sequence of calls
where [[Writable]] is first set to TRUE, a new [[Value]] is set, and
then [[Writable]] is set to FALSE.

8.3.8 [[HasProperty]](P)

When the [[HasProperty]] internal method of _O_ is called with property
key _P_, the following steps are taken:

1.  Assert: IsPropertyKey(_P_) is TRUE.

2.  Let _hasOwn_ be the result of calling the [[HasOwnProperty]]
    internal method of _O_ with argument _P_.

3.  ReturnIfAbrupt(_hasOwn_).

4.  If _hasOwn_ is FALSE, then

    a.  Let _parent_ be the result of calling the [[GetInheritance]]
        internal method of _O_.

    b.  ReturnIfAbrupt(_parent_).

    c.  If _parent_ is not NULL, then

        i.  Return the result of calling the [[HasProperty]] internal
            method of _parent_ with argument _P_.

5.  Return _hasOwn_.

8.3.9 [[Get]] (P, Receiver)

When the [[Get]] internal method of _O_ is called with property key _P_
and ECMAScript language value _Receiver_ the following steps are taken:

1.  Assert: IsPropertyKey(_P_) is TRUE.

2.  Let _desc_ be the result of calling the [[GetOwnProperty]] internal
    method of _O_ with argument _P_.

3.  ReturnIfAbrupt(_desc_).

4.  If _desc_ is UNDEFINED, then

    a.  Let _parent_ be the result of calling the [[GetInheritance]]
        internal method of _O_.

    b.  ReturnIfAbrupt(_parent_).

    c.  If _parent_ is NULL, then return UNDEFINED.

    d.  Return the result of calling the [[Get]] internal method of
        _parent_ with arguments _P_ and _Receiver_.

5.  If IsDataDescriptor(_desc_) is TRUE, return _desc_.[[Value]].

6.  Otherwise, IsAccessorDescriptor(_desc_) must be TRUE so, let
    _getter_ be _desc_.[[Get]].

7.  If _getter_ is UNDEFINED, return UNDEFINED.

8.  Return the result of calling the [[Call]] internal method of
    _getter_ with _Receiver_ as the _thisArgument_ and an empty List as
    _argumentsList_.

8.3.10 [[Set]] ( P, V, Receiver)

When the [[Set]] internal method of _O_ is called with property key _P_,
value _V_, and ECMAScript language value _Receiver_, the following steps
are taken:

1.  Assert: IsPropertyKey(_P_) is TRUE.

2.  a.  b.  

3.  Let _ownDesc_ be the result of calling the [[GetOwnProperty]]
    internal method of _O_ with argument _P_.

4.  ReturnIfAbrupt(_ownDesc_).

5.  If _ownDesc_ is UNDEFINED, then

    a.  Let _parent_ be the result of calling the [[GetInheritance]]
        internal method of _O_.

    b.  ReturnIfAbrupt(_parent_).

    c.  If _parent_ is not NULL, then

        i.  Return the result of calling the [[Set]] internal method of
            _parent_ with arguments _P_, _V_, and _Receiver_.

    d.  Else,

        i.  If Type(_Receiver_) is not Object, return FALSE.

    e.  i.  Return the result of performing
            CreateOwnDataProperty(_Receiver_, _P_, _V_).

6.  If IsDataDescriptor(_ownDesc_) is TRUE, then

    a.  If _ownDesc_.[[Writable]] is FALSE, return FALSE.

    b.  If Type(_Receiver_) is not Object, return FALSE.

    c.  Let _existingDescriptor_ be the result of calling the
        [[GetOwnProperty]] internal method of _Receiver_ with argument
        _P_.

    d.  ReturnIfAbrupt(_existingDescriptor_).

    e.  If _existingDescriptor_ is not UNDEFINED, then

        i.  Let _valueDesc_ be the Property Descriptor {[[Value]]: _V_}.

        ii. Return the result of calling the [[DefineOwnProperty]]
            internal method of _Receiver_ with arguments _P_ and
            _valueDesc_.

    f.  Else _Receiver_ does not currently have a property _P_,

        i.  ii. Return the result of performing
            CreateOwnDataProperty(_Receiver_, _P_, _V_).

7.  8.  If IsAccessorDescriptor(_ownDesc_) is TRUE, then

    a.  Let _setter_ be _ownDesc_.[[Set]].

    b.  If _setter_ is UNDEFINED, return FALSE.

9.  a.  Let _setterResult_ be the result of calling the [[Call]]
        internal method of _setter_ providing _Receiver_ as
        _thisArgument_ and a new List containing _V_ as _argumentsList_.

    b.  ReturnIfAbrupt(_setterResult_).

    c.  Return TRUE.

1.  2.  a.  b.  

3.  4.  a.  b.  c.  

5.  6.  a.  b.  c.  

7.  a.  b.  

8.3.11 [[Delete]] (P)

When the [[Delete]] internal method of _O_ is called with property key
_P_ the following steps are taken:

1.  

1.  2.  3.  

1.  

1.  2.  3.  a.  b.  c.  i.  

    d.  i.  

    e.  

4.  5.  6.  a.  b.  

7.  8.  a.  b.  i.  

    c.  i.  

9.  a.  i.  ii. 1.  

    b.  

10. a.  i.  ii. 

11. a.  

12. 

1.  

1.  2.  3.  a.  

4.  a.  

5.  a.  b.  c.  

6.  7.  

8.3.12 [[Enumerate]] ()

When the [[Enumerate]] internal method of _O_ is called the following
steps are taken:

1.  Return an Iterator object (reference xxxx) whose next method
    iterates over all the String valued keys of enumerable property keys
    of _O_. The mechanics and order of enumerating the properties is not
    specified but must conform to the rules specified below.

Enumerated properties do not include properties whose property key is a
Symbol. Properties of the object being enumerated may be deleted during
enumeration. If a property that has not yet been visited during
enumeration is deleted, then it will not be visited. If new properties
are added to the object being enumerated during enumeration, the newly
added properties are not guaranteed to be visited in the active
enumeration. A property name must not be visited more than once in any
enumeration.

Enumerating the properties of an object includes enumerating properties
of its prototype, and the prototype of the prototype, and so on,
recursively; but a property of a prototype is not enumerated if it is
“shadowed” because some previous object in the prototype chain has a
property with the same name. The values of [[Enumerable]] attributes are
not considered when determining if a property of a prototype object is
shadowed by a previous object on the prototype chain.

The following is an informative algorithm that conforms to these rules

1.  Let _obj_ be _O_.

2.  Let _proto_ be the result of calling the [[GetInheritance]] internal
    method of _O_ with no arguments.

3.  ReturnIfAbrupt(_proto_).

4.  If _proto_ is the value NULL, then

    a.  Let _propList_ be a new empty List.

5.  Else

    a.  Let _propList_ be the result of calling the [[Enumerate]]
        internal method of _proto_.

6.  ReturnIfAbrupt(_propList_).

7.  For each _name_ that is the property key of an own property of _O

    a.  If Type(_name_) is String, then

        i.  Let _desc_ be the result of calling OrdinaryGetOwnProperty
            with arguments _O_ and _name_.

        ii. If _name_ is an element of _propList_, then remove _name_ as
            an element of _propList_.

        iii. If _desc_.[[Enumerable]] is TRUE, then add _name_ as an
            element of _propList_.

8.  Order the elements of _propList_ in an implementation defined order.

9.  Return _propList_.

1.  2.  

8.3.13 [[OwnPropertyKeys]] ( )

When the [[OwnPropertyKeys]] internal method of _O_ is called the
following steps are taken:

1.  Let _keys_ be a new empty List.

2.  3.  For each own property key _P_ of _O

    a.  If _P_ is not a private Symbol, then

        i.  Add _P_ as the last element of _keys_.

4.  Return MakeListIterator(_keys_).

1.  

1.  

1.  

1.  

8.3.14 ObjectCreate(proto, internalDataList) Abstract Operation

The abstract operation ObjectCreate with argument _proto_ (an object or
null) is used to specify the runtime creation of new ordinary objects.
The optional argument _internalDataList_ is a List of the names of
internal data property names that should be defined as part of the
object. If the list is not provided, an empty List is used. It performs
the following steps:

8.3.15 Ordinary Function Objects

Ordinary function objects encapsulate parameterised ECMAScript code
closed over a lexical environment and support the dynamic evaluation of
that code. An ordinary function object is an ordinary object and has the
same internal data properties and (except as noted below) the same
internal methods as other ordinary objects.

Ordinary function objects have the additional internal data properties
listed in Table 13.

Ordinary function objects provide alternative definitions for the
[[Get]] and [[GetOwnProperty]] internal methods. These alternatives
prevent the value of strict mode function from being revealed as the
value of a function object property named "CALLER". These alternative
definitions exist sole to preclude a non-standard legacy feature of some
ECMAScript implementations from revealing information about strict mode
callers. If an implementation does not provide such a feature, it need
not implement these alternative internal methods for ordinary function
objects.

Table 13 -- Internal Data Properties of Ordinary Function Objects

  _INTERNAL DATA PROPERTY_   _TYPE_                      _DESCRIPTION_
  -------------------------- --------------------------- --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  [[Scope]]                  Lexical Environment         The Lexical Environment that the function was closed over. Is used as the outer environment when evaluating the code of the function.
  [[FormalParameters]]       Parse Node                  The root parse node of the source code that defines the function’s formal parameter list.
  [[FunctionKind]]           String                      Either "NORMAL" or "GENERATOR".
  [[Code]]                   Parse Node                  The root parse node of the source code that defines the function’s body.
  [[Realm]]                  Realm Record                The Code Realm in which the function was created and which provides any intrinsic objects that are accessed when evaluating the function.
  [[ThisMode]]               (lexical, strict, global)   Defines how THIS references are interpreted within the formal parameters and code body of the function. LEXICAL means that THIS refers to the THIS value of a lexically enclosing function. STRICT means that the THIS value is used exactly as provided by an invocation of the function. GLOBAL means that a this value of UNDEFINED is interpreted as a reference to the global object.
  [[Strict]]                 Boolean                     TRUE if this is a strict mode function, FALSE this is not a strict mode function.
  [[Home]]                   Object                      If the function uses SUPER, this is the object whose [[GetInheritance]] provides the object where super property lookups begin. Not present for functions that don’t reference SUPER.
  [[MethodName]]             String or Symbol            If the function uses SUPER, this is the property keys that is used for unqualified references to SUPER. Not present for functions that don’t reference SUPER.

Ordinary function objects all have the [[Call]], [[Get]] and
[[GetOwnProperty]] internal methods defined here. Ordinary functions
that are also constructors in addition have the [[Construct]] internal
method.

8.3.15.1 [[Call]] ( thisArgument, argumentsList) 

The [[Call]] internal method for an ordinary Function object _F_ is
called with parameters _thisArgument_ and _argumentsList_, a List of
ECMAScript language values. The following steps are taken:

1.  Let _callerContext_ be the running execution context.

2.  If, _callerContext_ is not already suspended, then Suspend
    _callerContext_.

3.  Let _calleeContext_ be a new ECMAScript Code execution context.

4.  Let _calleeRealm_ be the value of _F’s_ [[Realm]] internal data
    property.

5.  Set _calleeContext’s_ Realm to _calleeRealm_.

6.  Let _thisMode_ be the value of _F_’s [[ThisMode]] internal data
    property.

7.  If _thisMode_ is lexical, then

    a.  Let _localEnv_ be the result of calling
        NewDeclarativeEnvironment passing the value of the [[Scope]]
        internal data property of _F_ as the argument.

8.  Else,

    a.  If _thisMode_ is strict, set _thisValue_ to _thisArgument_.

    b.  Else

        i.  if _thisArgument_ is NULL or UNDEFINED, then

            1.  Set _thisValue_ to _calleeRealm_.[[globalThis]].

        ii. Else if Type(_thisArgument_) is not Object, set the
            _thisValue_ to ToObject(_thisArgument_).

        iii. Else set the _thisValue_ to _thisArgument_.

    c.  Let _localEnv_ be the result of calling NewFunctionEnvironment
        passing _F_ and _thisValue_ as the arguments.

9.  Set the LexicalEnvironment of _calleeContext_ to _localEnv_.

10. Set the VariableEnvironment of _calleeContext_ to _localEnv_.

11. Push _calleeContext_ onto the execution context stack;
    _calleeContext_ is now the running execution context.

12. Let _status_ be the result of performing Function Declaration
    Instantiation using the function _F_, _argumentsList_ , and
    _localEnv_ as described in 10.5.3.

13. If _status_ is an abrupt completion, then

    a.  Remove _calleeContext_ from the execution context stack and
        restore _callerContext_ as the running execution context.

    b.  Return _status_.

14. Let _result_ be the result of EvaluateBody of the production that is
    the value of _F_'s [[Code]] internal data property passing _F_ as
    the argument.

15. Remove _calleeContext_ from the execution context stack and restore
    _callerContext_ as the running execution context.

16. 17. Return _result_.

NOTE 1 Most ordinary functions use a Function Environment Record as
their LexicalEnvironment. Ordinary functions that are arrow functions
use a Declarative Environment Record as their LexicalEnvironment.

NOTE 2 When _calleeContext_ is removed from the execution context stack
it must not be destroyed because it may have been suspended and retained
by a generator object for later resumption_._

8.3.15.2 [[Construct]] ( argumentsList)

The [[Construct]] internal method for an ordinary Function object _F_ is
called with a single parameter _argumentsList_ which is a possibly empty
List of ECMAScript language values. The following steps are taken:

1.  Return the result of OrdinaryConstruct(_F_, _argumentsList_).

8.3.15.2.1 OrdinaryConstruct (F, argumentsList)

When the abstract operation OrdinaryConstruct is called with Object _F_
and List _argumentsList_ the following steps are taken:

8.3.15.3 [[Get]] (P, Receiver)

When the [[Get]] internal method of ordinary function object _F_ is
called with property key _P_ and ECMAScript language value _Receiver_
the following steps are taken:

If an implementation does not provide such a built-in CALLER method for
FUNCTION.PROTOTYPE then it must not use this definition. Instead the
ordinary object [[Get]] internal method is used.

8.3.15.4 [[GetOwnProperty]] (P)

When the [[GetOwnProperty]] internal method of ordinary function object
_F_ is called with property key _P_, the following steps are taken:

1.  Let _v_ be the result of calling the default ordinary object
    [[GetOwnProperty]] internal method (8.3.6) on _F_ passing _P_ as the
    argument.

2.  ReturnIfAbrupt(_v_).

3.  If IsDataDescriptor(_v_) is TRUE, then

    a.  If _P_ is "CALLER" and _v_.[[Value]] is a strict mode Function
        object, then

        i.  Set _v_.[[Value]] to NULL.

4.  Return _v_.

If an implementation does not provide such a built-in CALLER method for
FUNCTION.PROTOTYPE then it must not use this definition. Instead the
ordinary object [[GetOwnProperty]] internal method is used.

8.3.15.5 FunctionAllocate Abstract Operation

The abstract operation FunctionAllocate requires the one arguments,
_functionPrototype_ and accepts one optional argument, _functionKind_.
FunctionAllocate performs the following steps:

8.3.15.6 FunctionInitialize Abstract Operation

The abstract operation FunctionInitialize requires the arguments: a
function object _F_, _kind_ which is one of (Normal, Method, Arrow), an
parameter list production specified by _ParameterList_, a body
production specified by _Body_, a Lexical Environment specified by
_Scope_, a Boolean flag _Strict_, and optionally, an object _homeObject
and a property key _methodName_. FunctionInitialize performs the
following steps:

1.  Set the [[Prototype]] internal data property of _F_ to
    _functionPrototype_.

2.  Set the [[Scope]] internal data property of _F_ to the value of
    _Scope_.

3.  Set the [[FormalParameters]] internal property of _F_ to
    _ParameterList_ .

4.  Set the [[Code]] internal data property of _F_ to _Body_.

5.  If the _homeObject_ argument was provided, set the [[HomeObject]]
    internal data property of _F_ to _homeObject_.

6.  If the _methodName_ argument was provided, set the [[MethodName]]
    internal data property of _F_ to _methodName_.

7.  Set the [[Strict]] internal data property of _F_ to _Strict_.

8.  If _kind_ is Arrow, then set the [[ThisMode]] internal data property
    of _F_ to lexical.

9.  Else if _Strict_ is TRUE, then set the [[ThisMode]] internal data
    property of _F_ to strict.

10. Else set the [[ThisMode]] internal data property of _F_ to global.

11. Let _len_ be the ExpectedArgumentCount of _ParameterList_.

12. Call the [[DefineOwnProperty]] internal method of _F_ with arguments
    "LENGTH" and Property Descriptor {[[Value]]: _len_, [[Writable]]:
    FALSE, [[Enumerable]]: FALSE, [[Configurable]]: FALSE}

13. If _Strict_ is TRUE, then

    a.  Perform the AddRestrictedFunctionProperties abstract operation
        with argument _F_.

14. Return _F_.

8.3.15.7 FunctionCreate Abstract Operation

The abstract operation FunctionCreate requires the arguments: _kind_
which is one of (Normal, Method, Arrow), an parameter list production
specified by _ParameterList_, a body production specified by _Body_, a
Lexical Environment specified by _Scope_, a Boolean flag _Strict_, and
optionally, an object _functionPrototype_, an object _homeObject_ and a
string _methodName_. FunctionCreate performs the following steps:

1.  If the _functionPrototype_ argument was not passed,then

    a.  Let _functionPrototype_ be the intrinsic object
        %FunctionPrototype%.

2.  Let _F_ be the result of performing FunctionAllocate with argument
    _functionPrototype_.

3.  Return the result of performing FunctionInitialize with passing _F_,
    _kind_, _ParameterList_, _Body_, _Scope_, and _Strict_. Also pass
    _homeObject_ and _methodName_ if they are present.

8.3.15.7 GeneratorFunctionCreate Abstract Operation

The abstract operation GeneratorFunctionCreate requires the arguments:
_kind_ which is one of (Normal, Method, Arrow), an parameter list
production specified by _ParameterList_, a body production specified by
_Body_, a Lexical Environment specified by _Scope_, a Boolean flag
_Strict_, and optionally, an object _functionPrototype_, an object
_homeObject_ and a string _methodName_. GeneratorFunctionCreate performs
the following steps:

1.  If the _functionPrototype_ argument was not passed,then

    a.  Let _functionPrototype_ be the intrinsic object %Generator%.

2.  Let _F_ be the result of performing FunctionAllocate with arguments
    _functionPrototype_ and "GENERATOR".

3.  Return the result of performing FunctionInitialize with passing _F_,
    _kind_, _ParameterList_, _Body_, _Scope_, and _Strict_. Also pass
    _homeObject_ and _methodName_ if they are present.

8.3.15.8 AddRestrictedFunctionProperties Abstract Operation

The abstract operation is called with a function object _F_ as its
argument. It performs the following steps:

1.  Let _thrower_ be the %ThrowTypeError% intrinsic function Object.

2.  Call the [[DefineOwnProperty]] internal method of _F_ with arguments
    "CALLER" and PropertyDescriptor {[[Get]]: _thrower_, [[Set]]:
    _thrower_, [[Enumerable]]: FALSE, [[Configurable]]: FALSE}.

3.  Call the [[DefineOwnProperty]] internal method of _F_ with arguments
    "ARGUMENTS" and PropertyDescriptor {[[Get]]: _thrower_, [[Set]]:
    _thrower_, [[Enumerable]]: FALSE, [[Configurable]]: FALSE}.

The %ThrowTypeError% object is a unique function object that is defined
once for each Realm as follows:

1.  Let the _scope_ be the Global Environment.

2.  Let _formalParameters_ be the syntactic production:
    _FormalParameters_ : [empty].

3.  Let _body_ be the syntactic production: _FunctionBody_ :
    _ThrowTypeError_.

4.  Let _F_ be the result of the abstract operation FunctionCreate with
    arguments Normal, _formalParameters_, _body, scope_, and TRUE.

5.  Call the [[SetIntegrity]] internal method of _F_ with argument
    "NONEXTENSIBLE".

6.  Let %ThrowTypeError% be _F_.

8.3.15.9 MakeConstructor Abstract Operation

The abstract operation MakeConstructor requires a Function argument _F_
and optionally, a Boolean _writablePrototype_ and an object _prototype_.
If _prototype_ is provided it is assume to already contain, if needed, a
"CONSTRUCTOR" property whose value is _F_. This operation converts _F_
into a constructor by performs the following steps:

1.  Let _installNeeded_ be FALSE.

2.  If the _prototype_ argument was not provided,then

3.  If the _writablePrototype_ argument was not provided,then

    a.  Let _writablePrototype_ be TRUE.

4.  Set _F_’s essential internal method [[Construct]] to the definition
    specified in 8.3.15.2.

5.  If _installNeeded_, then

    a.  Call the [[DefineOwnProperty]] internal method of _prototype_
        with arguments "CONSTRUCTOR" and Property Descriptor {[[Value]]:
        _F_, [[Writable]]: _writablePrototype_, [[Enumerable]]: FALSE,
        [[Configurable]]: _writablePrototype_ }

7.  Call the [[DefineOwnProperty]] internal method of _F_ with arguments
    "PROTOTYPE" and Property Descriptor {[[Value]]: _prototype_ ,
    [[Writable]]: _writablePrototype_ , [[Enumerable]]: FALSE,
    [[Configurable]]: FALSE}.

8.  Return.


8.4 Built-in Exotic Object Internal Methods and Data Fields

This specification defines several kinds of built-in exotic objects.
These objects generally behave similar to ordinary objects except for a
few specific situations. The following exotic objects use the ordinary
object internal methods except where it is explicitly specified
otherwise below:

8.4.1 Bound Function Exotic Objects

A _bound function_ is an exotic object that wrappers another function
object. A bound function is callable (it has [[Call]] and [[Construct]]
internal methods). Calling a bound function generally results in a call
of its wrappered function.

Bound function objects do not have the internal data properties of
ordinary function objects defined in Table 13. Instead they have the
internal data properties defined in Table 14.

Table 14 -- Internal Data Properties of Exotic Bound Function Objects

  _INTERNAL DATA PROPERTY_   _TYPE_            _DESCRIPTION_
  -------------------------- ----------------- -------------------------------------------------------------------------------------------------------------
  [[BoundTargetFunction]]    Callable Object   The wrappered function object.
  [[BoundThis]]              Any               The value that is always passed as the THIS value when calling the wrappered function.
  [[BoundArguments]]         List of Any       A list of values that whose elements are used as the first arguments to any call to the wrappered function.

Unlike ordinary function objects, bound function objects do not use
alternative definitions of the [[Get]] and [[GetOwnPropety]] internal
methods. Bound function objects provide all of the essential internal
methods as specified in 8.3. However, they use the following definitions
for the essential internal methods of function objects.

8.4.1.1 [[Call]]

When the [[Call]] internal method of an exotic bound function object,
_F_, which was created using the bind function is called with parameters
_thisArgument_ and _argumentsList_, a List of ECMAScript language
values, the following steps are taken:

8.4.1.2 [[Construct]]

When the [[Construct]] internal method of an exotic bound function
object, _F_ that was created using the bind function is called with a
list of arguments _ExtraArgs_, the following steps are taken:

8.4.1.3 BoundFunctionCreate Abstract Operation

The abstract operation BoundFunctionCreate with arguments
_targetFunction_, _boundThis_ and _boundArgs_ is used to specify the
creation of new Bound Function exotic objects. It performs the following
steps:

1.  Let _proto_ be the the intrinsic %FunctionPrototype%.

2.  Let _obj_ be a newly created ECMAScript object.

3.  Set _obj_’s essential internal methods to the default ordinary
    object definitions specified in 8.3.

4.  Set the [[Call]] internal method of _obj_ as described in 8.4.1.1.

5.  Set the [[Construct]] internal method of _obj_ as described in
    8.4.1.2.

6.  Set the [[Prototype]] internal data property of _obj_ to _proto_.

7.  Set the [[Extensible]] internal data property of _obj_ to TRUE.

8.  Set the [[BoundTargetFunction]] internal data property of _obj_ to
    _targetFunction_.

9.  Set the [[BoundThis]] internal data property of _obj_ to the value
    of _boundThis_.

10. Set the [[BoundArguments]] internal data property of _obj_ to
    _boundArgs_.

11. 12. Return _obj_.

8.4.2 Array Exotic Objects

An _Array object_ is an exotic object that gives special treatment to a
certain class of property names. A property name _P_ (in the form of a
String value) is an _array index_ if and only if ToString(ToUint32(_P_))
is equal to _P_ and ToUint32(_P_) is not equal to 2^32^−1. A property
whose property name is an array index is also called an _element_. Every
Array object has a LENGTH property whose value is always a nonnegative
integer less than 2^32^. The value of the LENGTH property is numerically
greater than the name of every property whose name is an array index;
whenever a property of an Array object is created or changed, other
properties are adjusted as necessary to maintain this invariant.
Specifically, whenever a property is added whose name is an array index,
the LENGTH property is changed, if necessary, to be one more than the
numeric value of that array index; and whenever the LENGTH property is
changed, every property whose name is an array index whose value is not
smaller than the new length is automatically deleted. This constraint
applies only to own properties of an Array object and is unaffected by
LENGTH or array index properties that may be inherited from its
prototypes.

Exotic Array objects have the same internal data properties as ordinary
objects. They also have an [[ArrayInitialisationState]] internal data
property.

Exotic Array objects always have a non-configurable property named
"LENGTH".

Exotic Array objects provide alternative definitions for the [[Set]] and
[[DefineOwnProperty]] internal methods. Except for these two internal
methods, exotic Array objects provide all of the other essential
internal methods as specified in 8.3.

1.  2.  3.  4.  a.  b.  c.  i.  

    d.  i.  ii. 

5.  a.  b.  i.  ii. 1.  

        iii. 1.  

    c.  i.  ii. 

6.  a.  b.  c.  d.  e.  

8.4.2.1 [[DefineOwnProperty]] ( P, Desc)

When the [[DefineOwnProperty]] internal method of an exotic Array object
_A_ is called with property _P_, and Property Descriptor _Desc_ the
following steps are taken:

8.4.2.2 ArrayCreate Abstract Operation

The abstract operation ArrayCreate with argument _length_ (a positive
integer or UNDEFINED) and optional argument _proto_ is used to specify
the creation of new exotic Array objects. It performs the following
steps:

1.  If the _proto_ argument was not passed, then let _proto_ be the
    intrinsic object %ArrayPrototype%.

2.  Let _A_ be a newly created Array exotic object.

3.  Set _A_’s essential internal methods to the default ordinary object
    definitions specified in 8.3.

4.  5.  Set the [[DefineOwnProperty]] internal method of _A_ as
    specified in 8.4.2.1.

6.  Set the [[Prototype]] internal data property of _A_ to _proto_.

7.  8.  Set the [[Extensible]] internal data property of _A_ to TRUE.

9.  If _length_ is not UNDEFINED, then

    a.  Set the [[ArrayInitialisationState]] internal data property of
        _A_ to TRUE.

10. Else

    a.  Set the [[ArrayInitialisationState]] internal data property of
        _A_ to FALSE.

    b.  Let _length_ be 0.

11. Call OrdinaryDefineOwnProperty with arguments _A_, "LENGTH" and
    Property Descriptor {[[Value]]: _length_, [[Writable]]: TRUE,
    [[Enumerable]]: FALSE, [[Configurable]]: FALSE}.

12. Return _A_.

8.4.2.3 ArraySetLength Abstract Operation

When the abstract operation ArraySetLength is called with an exotic
Array object _A_, and Property Descriptor _Desc_ the following steps are
taken:

1.  2.  3.  If the [[Value]] field of _Desc_ is absent, then

    a.  Return the result of calling OrdinaryDefineOwnProperty passing
        _A_, "LENGTH", and _Desc_ as arguments.

4.  Let _newLenDesc_ be a copy of _Desc_.

5.  Let _newLen_ be ToUint32(_Desc_.[[Value]]).

6.  If _newLen_ is not equal to ToNumber( _Desc_.[[Value]]), throw a
    RANGEERROR exception.

7.  Set _newLenDesc_.[[Value]] to _newLen_.

8.  Let _oldLenDesc_ be the result of calling the [[GetOwnProperty]]
    internal method of _A_ passing "LENGTH" as the argument. The result
    will never be UNDEFINED or an accessor descriptor because Array
    objects are created with a length data property that cannot be
    deleted or reconfigured.

9.  Let _oldLen_ be _oldLenDesc_.[[Value]].

10. If _newLen_ ≥_oldLen_, then

    a.  Return the result of calling OrdinaryDefineOwnProperty passing
        _A_, "LENGTH", and _newLenDesc_ as arguments.

11. If _oldLenDesc_.[[Writable]] is FALSE, then return FALSE.

12. If _newLenDesc_.[[Writable]] is absent or has the value TRUE, let
    _newWritable_ be TRUE.

13. Else,

    a.  Need to defer setting the [[Writable]] attribute to FALSE in
        case any elements cannot be deleted.

    b.  Let _newWritable_ be FALSE.

    c.  Set _newLenDesc_.[[Writable]] to TRUE.

14. Let _succeeded_ be the result of calling OrdinaryDefineOwnProperty
    passing _A_, "LENGTH", and _newLenDesc_ as arguments.

15. ReturnIfAbrupt(_succeeded_).

16. If _succeeded_ is FALSE, return FALSE.

17. While _newLen_ < _oldLen_ repeat,

    a.  Set _oldLen_ to _oldLen_ – 1.

    b.  Let _deleteSucceeded_ be the result of calling the [[Delete]]
        internal method of _A_ passing ToString(_oldLen_).

    c.  ReturnIfAbrupt(_succeeded_).

    d.  If _deleteSucceeded_ is FALSE, then

        i.  Set _newLenDesc_.[[Value]] to _oldLen+1_.

        ii. If _newWritable_ is FALSE, set _newLenDesc_.[[Writable]] to
            FALSE.

        iii. Let _succeeded_ be the result of calling
            OrdinaryDefineOwnProperty passing _A_, "LENGTH", and
            _newLenDesc_ as arguments.

        iv. ReturnIfAbrupt(_succeeded_).

        v.  Return FALSE.

18. If _newWritable_ is FALSE, then

    a.  Call OrdinaryDefineOwnProperty passing _A_, "LENGTH", and
        Property Descriptor{[[Writable]]: FALSE} as arguments. This call
        will always return TRUE.

19. Return TRUE.

8.4.3 String Exotic Objects

A _String_ _object_ is an exotic object that encapsulates a String value
and exposes virtual array index data properties corresponding to the
individual code unit elements of the string value. Exotic String objects
always have a data property named "LENGTH" whose value is the number of
code unit elements in the encapsulated String value. Both the code unit
data properties and the "LENGTH" property are non-writable and
non-configurable.

Exotic String objects have the same internal data properties as ordinary
objects. They also have a [[StringData]] internal data property.

Exotic String objects provide alternative definitions for the following
internal methods. All of the other exotic String object essential
internal methods that are not defined below are as specified in 8.3.

8.4.3.1 [[HasOwnProperty]] (P)

When the [[HasOwnProperty]] internal method of exotic String object _O_
is called with property key _P_, the following steps are taken:

1.  Assert: IsPropertyKey(_P_) is TRUE.

2.  Let _has_ be the result of calling the ordinary object
    [[HasOwnProperty]] internal method (8.3.5) on _O_ with argument _P_.

3.  ReturnIfAbrupt(_has_).

4.  If _has_ is TRUE, then return TRUE.

5.  Let _index_ be ToInteger(_P_).

6.  ReturnIfAbrupt(_index_).

7.  Let _absIntIndex_ be ToString(abs(_index_)).

8.  ReturnIfAbrupt(_absIntIndex_).

9.  If SameValue(_absIntIndex_, _P_) is FALSE return FALSE.

10. Let _str_ be the String value of the [[StringData]] internal
    property of _O_, if the value of [[StringData]] is undefined the
    empty string is used as its value.

11. Let _len_ be the number of elements in _str_.

12. If _len_ ≤ _index_, return FALSE.

13. Return TRUE.

8.4.3.2 [[GetOwnProperty]] ( P )

When the [[GetOwnProperty]] internal method of an an exotic String
object _S_ is called with property key _P_ the following steps are
taken:

1.  2.  3.  4.  a.  b.  

5.  

8.4.3.3 [[DefineOwnProperty]] ( P, Desc)

When the [[DefineOwnProperty]] internal method of an exotic String
object _O_ is called with property _P_, and Property Descriptor _Desc_
the following steps are taken:

1.  Let _current_ be the result of calling the [[GetOwnProperty]]
    internal method of _O_ with argument _P_.

2.  Let _extensible_ be the value of the [[Extensible]] internal data
    property of _O_.

3.  Return the result of ValidateAndApplyPropertyDescriptor with
    arguments _O_, _P_, _extensible_, _Desc_, and _current_.

NOTE This algorithm differs from the ordinary object
OrdinaryDefineOwnProperty abstract operation algorithm only in
invocation of [[GetOwnProperty]] in step 1.

8.4.3.4 [[Enumerate]] ()

When the [[Enumerate]] internal method of an exotic String object _O_ is
called the following steps are taken:

8.4.3.5 [[OwnPropertyKeys]] ( )

When the [[OwnPropertyKeys]] internal method of an exotic String object
_O_ is called the following steps are taken:

8.4.3.6 StringCreate Abstract Operation

The abstract operation StringCreate with argument _prototype_ is used to
specify the creation of new exotic String objects. It performs the
following steps:

1.  Let _A_ be a newly created String exotic object.

2.  Set _A_’s essential internal methods to the default ordinary object
    definitions specified in 8.3.

3.  Set the [[HasOwnProperty]] internal method of _A_ as specified in
    8.4.3.1.

4.  Set the [[GetOwnProperty]] internal method of _A_ as specified in
    8.4.3.2.

5.  Set the [[DefineOwnProperty]] internal method of _A_ as specified in
    8.4.3.3.

6.  Set the [[Enumerate]] internal method of _A_ as specified in
    8.4.3.4.

7.  Set the [[OwnPropertyKeys]] internal method of _A_ as specified in
    8.4.3.5.

8.  Set the [[Prototype]] internal data property of _A_ to _prototype_.

9.  Set the [[Extensible]] internal data property of _A_ to TRUE.

10. Return _A_.

1.  

1.  2.  

1.  2.  

1.  2.  

1.  

1.  

1.  

1.  

1.  2.  a.  b.  c.  

3.  

1.  

1.  2.  

1.  

1.  

1.  

1.  

1.  

1.  

1.  

1.  

8.4.4 Exotic Arguments Objects

An _arguments_ _object_ is an exotic object whose array index properties
map to the formal parameters bindings of an invocation of a non-strict
function.

Exotic arguments objects have the same internal data properties as
ordinary objects. They also have a [[ParameterMap]] internal data.

Exotic arguments objects provide alternative definitions for the
following internal methods. All of the other exotic arguments object
essential internal methods that are not defined below are as specified
in 8.3.

8.4.5 Integer Indexed Delegation Exotic Objects

An _Integer Indexed object_ is an exotic object that that delegates
[[Get]] and [[Set]] handling of integer property keys to methods of the
object.

Integer Indexed exotic objects initially have the same internal data
properties as ordinary objects.

Integer Indexed Exotic objects provide alternative definitions for the
following internal methods. All of the other Integer Indexed exotic
object essential internal methods that are not defined below are as
specified in 8.3.

8.4.5.1 [[Get]] (P, Receiver)

When the [[Get]] internal method of an Integer Indexed exotic object _O_
is called with property key _P_ and ECMAScript language value _Receiver_
the following steps are taken:

1.  If SameValue(_O_, _Receiver_) is TRUE, then

    a.  Let _intIndex_ be ToInteger(_P_).

    b.  If SameVaue(ToString(_intIndex_, _P_) is TRUE, then

        i.  Let _args_ be a new List containing _intIndex_.

        ii. Return the result of Invoke(_O_, @@elementGet, _args_).

2.  Return the result of calling the default ordinary object [[Get]]
    internal method (8.3.7) on _O_ passing _P_ and _Receiver_ as
    arguments.

8.4.5.2 [[Set]] ( P, V, Receiver)

When the [[Set]] internal method of an an Integer Indexed exotic object
_O_ is called with property key _P_, value _V_, and ECMAScript language
value _Receiver_, the following steps are taken:

1.  If SameValue(_O_, _Receiver_) is TRUE, then

    a.  Let _intIndex_ be ToInteger(_P_).

    a.  If SameVaue(ToString(_intIndex_, _P_) is TRUE, then

        i.  Let _args_ be a new List containing _intIndex_ and _V_.

        ii. Return the result of ToBoolean(Invoke(_O_, @@elementSet,
            _args_)).

2.  Return the result of calling the default ordinary object [[Set]]
    internal method (8.3.7) on _O_ passing _P_, _V_, and _Receiver_ as
    arguments.

8.4.5.3 IntegertIndexedObjectCreate Abstract Operation

The abstract operation IntegerIndexedObjectCreate with argument
_prototype_ is used to specify the creation of new Integer Indexed
exotic objects. It performs the following steps:

1.  Let _A_ be a newly created ECMAScript object.

2.  Set _A_’s essential internal methods to the default ordinary object
    definitions specified in 8.3.

3.  Set the [[Get]] internal method of _A_ as specified in 8.4.6.1.

4.  Set the [[Set]] internal method of _A_ as specified in 8.4.6.2.

5.  Set the [[Prototype]] internal data property of _A_ to _prototype_.

6.  Set the [[Extensible]] internal data property of _A_ to TRUE.

7.  Return _A_.

8.4.6 Built-in Function Objects

The function objects specified in Clause 15 may be implemented as either
ordinary function objects whose behaviour is provided using ECMAScript
code or as implementation provided exotic function objects whose
behaviour is provided in some other manner. In either case, the effect
of calling such functions must be that specified for each one in Clause
15.

If an implementation provided exotic object is used, the object must
have the ordinary object behaviour specified in 8.3 except for [[Get]]
and [[GetOwnProperty]] which must be as specified in 8.3.15. All such
exotic function objects also have [[Prototype]] and [[Extensible]]
internal data.

[[Calll]] and [[Construct]]


8.5 Proxy Object Internal Methods and Internal Data Properties

A proxy object is an exotic object whose essential internal methods are
partially implemented using ECMAScript code. Every proxy objects has an
internal data property called [[ProxyHandler]]. The value of
[[ProxyHandler]] is always an object, called the proxy’s _handler
object_. Methods of a handler object may be used to augment the
implementation for one or more of the proxy object’s internal methods.
Every proxy object also has an internal data property called
[[ProxyTarget]] whose value is either an object or the NULL value. This
object is called the proxy’s _target object_.

When a handler method is called to provide the implementation of a proxy
object internal method, the handler method is passed the proxy’s target
object as a parameter. A proxy’s handler object does not necessarily
have a method corresponding to every essential internal method. Invoking
an internal method on the proxy results in the invocation of the
corresponding internal method on the proxy’s target object if the
handler object does not have a method corresponding to the internal
trap.

The [[ProxyHandler]] and [[ProxyTarget]] internal data properties of a
proxy object are always initialized when the object is created and
typically may not be modified. Some proxy objects are created in a
manner that permits them to be subsequently _revoked_. When a proxy is
revoked, its [[ProxyHander]] internal data property is set to a special
revoked proxy handler object and its [[ProxyTarget]] internal data
property is set to NULL.

Because proxy permit arbitrary ECMAScript code to be used to in the
implementation of internal methods, it is possible to define a proxy
object whose handler methods violates the invariants defined in 8.1.6.2.
Some of the internal method invariants defined in 8.1.6.2 are essential
integrity invariants. These invariants are explicitly enforced by the
proxy internal methods specified in this section. An ECMAScript
implementation must be robust in the presence of all possible invariant
violations.

In the following algorithm descriptions, assume _O_ is an ECMAScript
proxy object, _P_ is a property key value, _V_ is any ECMAScript
language value, Desc is a Property Description record, and _B_ is a
Boolean flag.

8.5.1 [[GetInheritance]] ( )

When the [[GetInheritance]] internal method of an exotic Proxy object
_O_ is called the following steps are taken:

1.  Let _handler_ be the value of the [[ProxyHandler]] internal data
    property of _O_.

2.  Let _target_ be the value of the [[ProxyTarget]] internal data
    property of _O_.

3.  Let _trap_ be the result of GetMethod(_handler_, "GETPROTOTYPEOF").

4.  ReturnIfAbrupt(_trap_).

5.  If _trap_ is UNDEFINED, then

    a.  Return the result of calling the [[GetInheritance]] internal
        method of _target_.

6.  Let _handlerProto_ be the result of calling the [[Call]] internal
    method of _trap_ with _handler_ as the THIS value and a new List
    containing _target_.

7.  ReturnIfAbrupt(_handlerProto_).

8.  Let _targetProto_ be the result of calling the [[GetInheritance]]
    internal method of _target_.

9.  ReturnIfAbrupt(_targetProto_).

10. If SameValue(_handlerProto_, _targetProto_) is FALSE, then throw a
    TYPEERROR exception.

11. Return _handlerProto_.

NOTE [[GetInheritance]] for proxy objects enforces the following
invariant:

-   [[GetInheritance]] applied to the proxy object must return the same
      value as [[GetInheritance] applied to the proxy object’s target
      object.

8.5.2 [[SETINHERITANCE]] (V)

When the [[SetInheritance]] internal method of an exotic Proxy object
_O_ is called with argument _V_ the following steps are taken:

1.  Assert: Either Type(_V_) is Object or Type(_V_) is Null.

2.  Let _handler_ be the value of the [[ProxyHandler]] internal data
    property of _O_.

3.  Let _target_ be the value of the [[ProxyTarget]] internal data
    property of _O_.

4.  Let _trap_ be the result of GetMethod(_handler_, "SETPROTOTYPEOF").

5.  ReturnIfAbrupt(_trap_).

6.  If _trap_ is UNDEFINED, then

    a.  Return the result of calling the [[SetInheritance]] internal
        method of _target_ with argument _V_.

7.  Let _trapResult_ be the result of calling the [[Call]] internal
    method of _trap_ with _handler_ as the THIS value and a new List
    containing _target_ and _V_.

8.  ReturnIfAbrupt(_trapResult_).

9.  Let _trapResult_ be ToBoolean(_trapResult_).

10. Let _extensibleTarget_ be the result of IsExtensible(_target_).

11. ReturnIfAbrupt(_extensibleTarget_).

12. Set _extensibleTarget_ to ToBoolean(_extensibleTarget_).

13. If _extensibleTarget_ is TRUE, then return _trapResult_.

14. 15. 16. a.  

17. 18. 19. Let _targetProto_ be the result of calling the
    [[GetInheritance]] internal method of _target_.

20. ReturnIfAbrupt(_targetProto_).

21. If _trapResult_ is TRUE and SameValue(_V_, _targetProto_) is FALSE,
    then throw a TYPEERROR exception.

22. Return _trapResult_.

NOTE [[SetInheritance]] for proxy objects enforces the following
invariant:

-   If the target object is not extensible, the argument value must be
      the same as the result of [[GetInheritance]] applied to target
      object.

8.5.3 [[HasIntegrity]] ( Level )

When the [[HasIntegrity]] internal method of an exotic Proxy object _O_
is called the following steps are taken:

1.  Assert: _Level_ is one of "NONEXTENSIBLE", "SEALED", or "FROZEN".

2.  Let _handler_ be the value of the [[ProxyHandler]] internal data
    property of _O_.

3.  Let _target_ be the value of the [[ProxyTarget]] internal data
    property of _O_.

4.  If _Level_ is "NONEXTENSIBLE", then let _trapName_ be
    "ISEXTENSIBLE".

5.  Else if _Level_ is "SEALED", then let _trapName_ be "ISSEALED".

6.  Else _Level_ is "FROZEN", so let _trapName_ be "ISFROZEN".

7.  Let _trap_ be the result of GetMethod(_handler_, _trapName_).

8.  ReturnIfAbrupt(_trap_).

9.  If _trap_ is UNDEFINED, then

    a.  Return the result of calling the [[HasIntegrity]] internal
        method of _target_ with argument _Level_.

10. Let _trapResult_ be the result of calling the [[Call]] internal
    method of _trap_ with _handler_ as the THIS value and a new List
    containing _target_.

11. ReturnIfAbrupt(_trapResult_).

12. Let _booleanTrapResult_ be ToBoolean(_trapResult_).

13. Let _targetResult_ be the result of calling the [[HasIntegrity]]
    internal method of _target_ with argument _Level_.

14. ReturnIfAbrupt(_targetResult_).

15. If SameValue(_booleanTrapResult_, _targetResult_) is FALSE, then
    throw a TYPEERROR exception.

16. Return _booleanTrapResult_.

NOTE [[HasIntegrity]] for proxy objects enforces the following
invariant:

-   [[HasIntegrity]] applied to the proxy object must return the same
      value as [[HasIntegrity]] applied to the proxy object’s target
      object with the same argument.

8.5.4 [[SetIntegrity]] ( Level )

When the [[Setntegrity]] internal method of an exotic Proxy object _O_
is the following steps are taken:

1.  Assert: _Level_ is one of "NONEXTENSIBLE", "SEALED", or "FROZEN".

2.  Let _handler_ be the value of the [[ProxyHandler]] internal data
    property of _O_.

3.  Let _target_ be the value of the [[ProxyTarget]] internal data
    property of _O_.

4.  If _Level_ is "NONEXTENSIBLE", then let _trapName_ be
    "PREVENTEXTENSIONS".

5.  Else if _Level_ is "SEALED", then let _trapName_ be "SEAL".

6.  Else _Level_ is "FROZEN", so let _trapName_ be "FREEZE".

7.  Let _trap_ be the result of GetMethod(_handler_, _trapName_).

8.  ReturnIfAbrupt(_trap_).

9.  If _trap_ is UNDEFINED, then

    a.  Return the result of calling the [[SetIntegrity]] internal
        method of _target_ with argument _Level_.

10. Let _trapResult_ be the result of calling the [[Call]] internal
    method of _trap_ with _handler_ as the THIS value and a new List
    containing _target_.

11. ReturnIfAbrupt(_trapResult_).

12. Let _booleanTrapResult_ be ToBoolean(_trapResult_).

13. 14. 15. a.  

16. 17. 18. 19. Let _targetResult_ be the result of calling the
    [[HasIntegrity]] internal method of _target_ with argument _Level_.

20. ReturnIfAbrupt(_targetResult_).

21. If SameValue(_booleanTrapResult_, _targetResult_) is FALSE , then
    throw a TYPEERROR exception.

22. Return _booleanTrapResult_.

NOTE [[SetIntegrity]] for proxy objects enforces the following
invariant:

-   [[SetIntegrity]] applied to the proxy object must return the same
    value as [[HasIntegrity]] applied to the proxy object’s target
    object with the same argument

8.5.5 [[HasOwnProperty]] (P)

When the [[HasOwnProperty]] internal method of an exotic Proxy object
_O_ is called with property key _P_, the following steps are taken:

1.  Assert: IsPropertyKey(_P_) is TRUE.

2.  Let _handler_ be the value of the [[ProxyHandler]] internal data
    property of _O_.

3.  Let _target_ be the value of the [[ProxyTarget]] internal data
    property of _O_.

4.  Let _trap_ be the result of GetMethod(_handler_, "HASOWN").

5.  ReturnIfAbrupt(_trap_).

6.  If _trap_ is UNDEFINED, then

    a.  Return the result of calling the [[HasOwnProperty]] internal
        method of _target_ with argument _P_.

7.  Let _trapResult_ be the result of calling the [[Call]] internal
    method of _trap_ with _handler_ as the THIS value and a new List
    containing _target_ and _P_.

8.  ReturnIfAbrupt(_trapResult_).

9.  Let _success_ be ToBoolean(_trapResult_).

10. If _success_ is FALSE, then

    a.  Let _targetDesc_ be the result of calling the [[GetOwnProperty]]
        internal method of _target_ with argument _P_.

    b.  ReturnIfAbrupt(_targetDesc_).

    c.  If _targetDesc_ is not UNDEFINED, then

        i.  If _targetDesc_.[[Configurable]] is FALSE, then throw a
            TYPEERROR exception.

        ii. Let _extensibleTarget_ be the result of calling the
            [[IsExtensible]] internal method of _target_.

        iii. ReturnIfAbrupt(_extensibleTarget_).

        iv. If ToBoolean(_extensibleTarget_) is FALSE, then throw a
            TYPEERROR exception.

11. Else _success_ is TRUE,

    a.  b.  Let _extensibleTarget_ be the result of
        IsExtensible(_target_).

    c.  ReturnIfAbrupt(_extensibleTarget_).

    d.  If ToBoolean(_extensibleTarget_) is TRUE, then return _success_.

    e.  Let _targetDesc_ be the result of calling the [[GetOwnProperty]]
        internal method of _target_ with argument _P_.

    f.  ReturnIfAbrupt(_targetDesc_).

    g.  If _targetDesc_ is UNDEFINED, then throw a TYPEERROR exception.

12. Return _success_.

NOTE [[HasOwnProperty]] for proxy objects enforces the following
invariants:

-   A property cannot be reported as non-existent, if it exists as a
      non-configurable own property of the target object.

-   A property cannot be reported as non-existent, if it exists as a own
      property of the target object and the target object is not
      extensible.

-   A property cannot be reported as existent, if it does not exists as
      a own property of the target object and the target object is not
      extensible.

8.5.6 [[GetOwnProperty]] (P)

When the [[GetOwnProperty]] internal method of an exotic Proxy object
_O_ is called with property key _P_, the following steps are taken:

1.  Assert: IsPropertyKey(_P_) is TRUE.

2.  Let _handler_ be the value of the [[ProxyHandler]] internal data
    property of _O_.

3.  Let _target_ be the value of the [[ProxyTarget]] internal data
    property of _O_.

4.  Let _trap_ be the result of GetMethod(_handler_,
    "GETOWNPROPERTYDESCRIPTOR").

5.  ReturnIfAbrupt(_trap_).

6.  If _trap_ is UNDEFINED, then

    a.  Return the result of calling the [[GetOwnProperty]] internal
        method of _target_ with argument _P_.

7.  Let _trapResultObj_ be the result of calling the [[Call]] internal
    method of _trap_ with _handler_ as the THIS value and a new List
    containing _target_ and _P_.

8.  ReturnIfAbrupt(_trapResultObj_).

9.  If Type(_trapResultObj_) is neither Object or Undefined, then throw
    a TYPEERROR exception.

10. Let _targetDesc_ be the result of calling the [[GetOwnProperty]]
    internal method of _target_ with argument _P_.

11. ReturnIfAbrupt(_targetDesc_).

12. If _trapResultObj_ is UNDEFINED, then

    a.  If _targetDesc_ is UNDEFINED, then return UNDEFINED.

    b.  If _targetDesc_.[[Configurable]] is FALSE, then throw a
        TYPEERROR exception.

    c.  Let _extensibleTarget_ be the result of IsExtensible(_target_).

    d.  ReturnIfAbrupt(_extensibleTarget_).

    e.  If ToBoolean(_extensibleTarget_) is FALSE, then throw a
        TYPEERROR exception.

    f.  Return UNDEFINED.

13. Let _extensibleTarget_ be the result of IsExtensible(_target_).

14. ReturnIfAbrupt(_extensibleTarget_).

15. Set _extensibleTarget_ to ToBoolean(_extensibleTarget_),

16. Let _resultDesc_ be ToPropertyDescriptor(_trapResultObj_).

17. ReturnIfAbrupt(_resultDesc_).

18. Call CompletePropertyDescriptor(_resultDesc, targetDesc_).

19. Let _valid_ be the result of IsCompatiblePropertyDescriptor
    (_extensibleTarget_, _resultDesc_, _targetDesc_).

20. If _valid_ is FALSE, then throw a TYPEERROR exception.

21. If _resultDesc_.[[Configurable]] is FALSE, then

    a.  If _targetDesc_ is UNDEFINED or _targetDesc_.[[Configurable]] is
        TRUE_,_ then

        i.  Throw a TYPEERROR exception.

22. Return _resultDesc_.

NOTE [[GetOwnProperty]] for proxy objects enforces the following
invariants:

-   The result of [[GetOwnProperty]] must be either an Object or
      UNDEFINED.

-   A property cannot be reported as non-existent, if it exists as a
      non-configurable own property of the target object.

-   A property cannot be reported as non-existent, if it exists as a own
      property of the target object and the target object is not
      extensible.

-   A property cannot be reported as existent, if it does not exists as
      a own property of the target object and the target object is not
      extensible.

-   A property cannot be reported as non-configurable, if it does not
      exists as a own property of the target object or if it exists as a
      configurable own property of the target object.

-   The result of [[GetOwnProperty]] can be applied to the target object
      using [[DefineOwnPropery]] and will not throw an exception.

8.5.7 [[DefineOwnProperty]] (P, Desc)

When the [[DefineOwnProperty]] internal method of an exotic Proxy object
_O_ is called with property key _P_ and property descriptor _Desc_, the
following steps are taken:

1.  Assert: IsPropertyKey(_P_) is TRUE.

2.  Let _handler_ be the value of the [[ProxyHandler]] internal data
    property of _O_.

3.  Let _target_ be the value of the [[ProxyTarget]] internal data
    property of _O_.

4.  Let _trap_ be the result of GetMethod(_handler_, "DEFINEPROPERTY").

5.  ReturnIfAbrupt(_trap_).

6.  If _trap_ is UNDEFINED, then

    a.  Return the result of calling the [[DefineOwnProperty]] internal
        method of _target_ with arguments _P_ and _Desc_.

7.  Let _descObj_ be FromPropertyDescriptor(_Desc_).

8.  NOTE If _Desc_ was originally generated from an object using
    ToPropertyDescriptor, then _descObj_ will be that original object.

9.  Let _trapResult_ be the result of calling the [[Call]] internal
    method of _trap_ with _handler_ as the THIS value and a new List
    containing _target_, _P_, and _descObj_.

10. ReturnIfAbrupt(_trapResult_).

11. If ToBoolean(_trapResult_) is FALSE, then return FALSE.

12. Let _targetDesc_ be the result of calling the [[GetOwnProperty]]
    internal method of _target_ with argument _P_.

13. ReturnIfAbrupt(_targetDesc_).

14. Let _extensibleTarget_ be the result of IsExtensible(_target_).

15. ReturnIfAbrupt(_extensibleTarget_).

16. Set _extensibleTarget_ to ToBoolean(_extensibleTarget_),

17. If _targetDesc_ is UNDEFINED, then

    a.  If _extensibleTarget_ is FALSE, then throw a TYPEERROR
        exception.

    b.  If _Desc_.[[Configurable]] is FALSE, then throw a TYPEERROR
        exception.

18. Else _targetDesc_ is not UNDEFINED_,

    a.  If IsCompatiblePropertyDescriptor(_extensibleTarget_, _Desc_ ,
        _targetDesc_) is FALSE, then throw a TYPEERROR exception.

    b.  If _Desc_.[[Configurable]] is FALSE and
        _targetDesc_.[[Configurable]] is TRUE, then throw a TYPEERROR
        exception.

19. Return TRUE.

NOTE [[DefineOwnProperty]] for proxy objects enforces the following
invariants:

-   A property cannot be added, if the target object is not extensible.

-   A property cannot be added as or modified to be non-configurable, if
      it does not exists as a non-configurable own property of the
      target object.

-   A property may not be non-configurable, if is corresponding
      configurable property of the target object exists.

-   If a property has a corresponding target object property then apply
      the property descriptor of the property to the target object using
      [[DefineOwnPropery]] will not throw an exception.

8.5.8 [[HasProperty]] (P)

When the [[HasProperty]] internal method of an exotic Proxy object _O_
is called with property key _P_, the following steps are taken:

1.  Assert: IsPropertyKey(_P_) is TRUE.

2.  Let _handler_ be the value of the [[ProxyHandler]] internal data
    property of _O_.

3.  Let _target_ be the value of the [[ProxyTarget]] internal data
    property of _O_.

4.  Let _trap_ be the result of GetMethod(_handler_, "HAS").

5.  ReturnIfAbrupt(_trap_).

6.  If _trap_ is UNDEFINED, then

    a.  Return the result of calling the [[HasProperty]] internal method
        of _target_ with argument _P_.

7.  Let _trapResult_ be the result of calling the [[Call]] internal
    method of _trap_ with _handler_ as the THIS value and a new List
    containing _target_ and _P_.

8.  ReturnIfAbrupt(_trapResult_).

9.  Let _success_ be ToBoolean(_trapResult_).

10. If _success_ is FALSE, then

    a.  Let _targetDesc_ be the result of calling the [[GetOwnProperty]]
        internal method of _target_ with argument _P_.

    b.  ReturnIfAbrupt(_targetDesc_).

    c.  If _targetDesc_ is not UNDEFINED, then

        i.  If _targetDesc_.[[Configurable]] is FALSE, then throw a
            TYPEERROR exception.

        ii. Let _extensibleTarget_ be the result of
            IsExtensible(_target_).

        iii. ReturnIfAbrupt(_extensibleTarget_).

        iv. If ToBoolean(_extensibleTarget_) is FALSE, then throw a
            TYPEERROR exception.

11. Return _success_.

NOTE [[HasProperty]] for proxy objects enforces the following
invariants:

-   A property cannot be reported as non-existent, if it exists as a
      non-configurable own property of the target object.

-   A property cannot be reported as non-existent, if it exists as a own
      property of the target object and the target object is not
      extensible.

8.5.9 [[Get]] (P, Receiver)

When the [[Get]] internal method of an exotic Proxy object _O_ is called
with property key _P_ and ECMAScript language value _Receiver_ the
following steps are taken:

1.  Assert: IsPropertyKey(_P_) is TRUE.

2.  Let _handler_ be the value of the [[ProxyHandler]] internal data
    property of _O_.

3.  Let _target_ be the value of the [[ProxyTarget]] internal data
    property of _O_.

4.  Let _trap_ be the result of GetMethod(_handler_, "GET").

5.  ReturnIfAbrupt(_trap_).

6.  If _trap_ is UNDEFINED, then

    a.  Return the result of calling the [[Get]] internal method of
        _target_ with arguments _P_ and _Receiver_.

7.  Let _trapResult_ be the result of calling the [[Call]] internal
    method of _trap_ with _handler_ as the THIS value and a new List
    containing _target_, _P_, and _Receiver_.

8.  ReturnIfAbrupt(_trapResult_).

9.  Let _targetDesc_ be the result of calling the [[GetOwnProperty]]
    internal method of _target_ with argument _P_.

10. ReturnIfAbrupt(_targetDesc_).

11. If _targetDesc_ is not UNDEFINED, then

    a.  If IsDataDescriptor(_targetDesc_) and
        _targetDesc_.[[Configurable]] is FALSE and
        _targetDesc_.[[Writable]] is FALSE, then

        i.  If SameValue(_trapResult_, _targetDesc_.[[Value]]) is FALSE,
            then throw a TYPEERROR exception.

    b.  If IsAccessorDescriptor(_targetDesc_) and
        _targetDesc_.[[Configurable]] is FALSE and _targetDesc_.[[Get]]
        is UNDEFINED, then

        i.  If _trapResult_ is not UNDEFINED, then throw a TYPEERROR
            exception.

12. Return _trapResult_.

NOTE [[Get]] for proxy objects enforces the following invariants:

-   The value reported for a property must be the same as the value of
      the corresponding target object property if the target object
      property is a non-writable, non-configurable data property.

-   The value reported for a property must be UNDEFINED if the
      corresponding corresponding target object property is
      non-configurable accessor property that has UNDEFINED as its
      [[Get]] attribute.

8.5.10 [[Set]] ( P, V, Receiver)

When the [[Set]] internal method of an exotic Proxy object _O_ is called
with property key _P_, value _V_, and ECMAScript language value
_Receiver_, the following steps are taken:

1.  Assert: IsPropertyKey(_P_) is TRUE.

2.  Let _handler_ be the value of the [[ProxyHandler]] internal data
    property of _O_.

3.  Let _target_ be the value of the [[ProxyTarget]] internal data
    property of _O_.

4.  Let _trap_ be the result of GetMethod(_handler_, "SET").

5.  ReturnIfAbrupt(_trap_).

6.  If _trap_ is UNDEFINED, then

    a.  Return the result of calling the [[Set]] internal method of
        _target_ with arguments _P_, _V_, and _Receiver_.

7.  Let _trapResult_ be the result of calling the [[Call]] internal
    method of _trap_ with _handler_ as the THIS value and a new List
    containing _target_, _P_, _V_, and _Receiver_.

8.  ReturnIfAbrupt(_trapResult_).

9.  If ToBoolean(_trapResult_) is FALSE, then return FALSE.

10. Let _targetDesc_ be the result of calling the [[GetOwnProperty]]
    internal method of _target_ with argument _P_.

11. ReturnIfAbrupt(_targetDesc_).

12. If _targetDesc_ is not UNDEFINED, then

    a.  If IsDataDescriptor(_targetDesc_) and
        _targetDesc_.[[Configurable]] is FALSE and
        _targetDesc_.[[Writable]] is FALSE, then

        i.  If SameValue(_V_, _targetDesc_.[[Value]]) is FALSE, then
            throw a TYPEERROR exception.

    b.  If IsAccessorDescriptor(_targetDesc_) and
        _targetDesc_.[[Configurable]] is FALSE, then

        i.  If _targetDesc_.[[Set]] is UNDEFINED, then throw a TYPEERROR
            exception.

13. Return TRUE.

NOTE [[Set]] for proxy objects enforces the following invariants:

-   Cannnot change the value of a property to be different from the
      value of the corresponding target object property if the
      corresponding target object property is a non-writable,
      non-configurable data property.

-   Cannot set the value of a property if the corresponding
      corresponding target object property is a non-configurable
      accessor property that has UNDEFINED as its [[Set]] attribute.

8.5.11 [[Delete]] (P)

When the [[Delete]] internal method of an exotic Proxy object _O_ is
called with property name _P_ the following steps are taken:

1.  Assert: IsPropertyKey(_P_) is TRUE.

2.  Let _handler_ be the value of the [[ProxyHandler]] internal data
    property of _O_.

3.  Let _target_ be the value of the [[ProxyTarget]] internal data
    property of _O_.

4.  Let _trap_ be the result of GetMethod(_handler_, "DELETEPROPERTY").

5.  ReturnIfAbrupt(_trap_).

6.  If _trap_ is UNDEFINED, then

    a.  Return the result of calling the [[Delete]] internal method of
        _target_ with argument _P_.

7.  Let _trapResult_ be the result of calling the [[Call]] internal
    method of _trap_ with _handler_ as the THIS value and a new List
    containing _target_ and _P_.

8.  ReturnIfAbrupt(_trapResult_).

9.  If ToBoolean(_trapResult_) is FALSE, then return FALSE.

10. Let _targetDesc_ be the result of calling the [[GetOwnProperty]]
    internal method of _target_ with argument _P_.

11. ReturnIfAbrupt(_targetDesc_).

12. If _targetDesc_ is UNDEFINED, then return TRUE.

13. If _targetDesc_.[[Configurable]] is FALSE, then throw a TYPEERROR
    exception.

14. Return TRUE.

NOTE [[Delete]] for proxy objects enforces the following invariant:

-   A property cannot be deleted, if it exists as a non-configurable own
      property of the target object.

1.  2.  3.  4.  5.  6.  a.  

7.  8.  9.  10. 11. 12. 13. 14. 15. 16. 17. a.  b.  

18. a.  b.  

19. 

-   -   -   -   

8.5.12 [[Enumerate]] ()

When the [[Enumerate]] internal method of an exotic Proxy object _O_ is
called the following steps are taken:

1.  Let _handler_ be the value of the [[ProxyHandler]] internal data
    property of _O_.

2.  Let _target_ be the value of the [[ProxyTarget]] internal data
    property of _O_.

3.  Let _trap_ be the result of GetMethod(_handler_, "ENUMERATE").

4.  ReturnIfAbrupt(_trap_).

5.  If _trap_ is UNDEFINED, then

    a.  Return the result of calling the [[Enumerate]] internal method
        of _target_.

6.  Let _trapResult_ be the result of calling the [[Call]] internal
    method of _trap_ with _handler_ as the THIS value and a new List
    containing _target_.

7.  ReturnIfAbrupt(_trapResult_).

8.  If Type(_trapResult_) is not Object, then throw a TYPEERROR
    exception.

TODO: we may need to add a lot of additional invariant checking here
according to the wiki spec. But maybe it really isn’t necessary. Tomvc
response: I think it may be possible to waive the extra invariant checks
for [[Enumerate]]. It's not a crucial primitive. My reasoning is that
[[Enumerate]] deals with both own and inherited properties, and we don't
really enforce any invariants on inherited properties. So I guess it's
ok if the invariants for [[Enumerate]] are weakened.

Do note that this is a bit inconsistent with the way we treat internal
methods like [[HasProperty]], [[GetP]] and [[SetP]]: these also deal
with own and inherited properties, but still enforce invariants on own
properties.

1.  Return _trapResult_.

NOTE [[Enumerate]] for proxy objects enforces the following invariants:

-   The result of [[Enumerate]] must be an Object.

1.  2.  3.  4.  5.  a.  

6.  7.  8.  9.  10. 

-   

8.5.13 [[OwnPropertyKeys]] ( )

When the [[OwnPropertyKeys]] internal method of an exotic Proxy object
_O_ is called the following steps are taken:

1.  Let _handler_ be the value of the [[ProxyHandler]] internal data
    property of _O_.

2.  Let _target_ be the value of the [[ProxyTarget]] internal data
    property of _O_.

3.  Let _trap_ be the result of GetMethod(_handler_, "OWNKEYS").

4.  ReturnIfAbrupt(_trap_).

5.  If _trap_ is UNDEFINED, then

    a.  Return the result of calling the [[OwnPropertyKeys]] internal
        method of _target_.

6.  Let _trapResult_ be the result of calling the [[Call]] internal
    method of _trap_ with _handler_ as the THIS value and a new List
    containing _target_.

7.  ReturnIfAbrupt(_trapResult_).

8.  If Type(_trapResult_) is not Object, then throw a TYPEERROR
    exception.

9.  TODO: we may need to add a lot of additional invariant checking here
    according to the wiki spec. But maybe it really isn’t necessary

10. Return _trapResult_.

NOTE [[OwnPropertyKeys]] for proxy objects enforces the following
invariants:

-   The result of [[OwnPropertyKeys]] must be an Object.

1.  

1.  

1.  

1.  

8.5.14 [[Call]] (thisArgument, argumentsList) 

The [[Call]] internal method of an exotic Proxy object _O_ is called
with parameters _thisArgument_ and _argumentsList_, a List of ECMAScript
language values. The following steps are taken:

1.  Let _handler_ be the value of the [[ProxyHandler]] internal data
    property of _O_.

2.  Let _target_ be the value of the [[ProxyTarget]] internal data
    property of _O_.

3.  Let _trap_ be the result of GetMethod(_handler_, "APPLY").

4.  ReturnIfAbrupt(_trap_).

5.  If _trap_ is UNDEFINED, then

    a.  Return the result of calling the [[Call]] internal method of
        _target_ with arguments _thisArgument_ and _argumentsList_.

6.  Let _argArray_ be the result of
    CreateArrayFromList(_argumentsList_).

7.  Return the result of calling the [[Call]] internal method of _trap
    with _handler_ as the THIS value and a new List containing _target_,
    _thisArgument_, and _argArray_.

NOTE An Proxy exotic object only has a [[Call]] internal method if the
initial value of its [[ProxyTarget]] internal data property is an object
that has a [[Call]] internal method.

8.5.15 [[Construct]] Internal Method

The [[Construct]] internal method of an exotic Proxy object _O_ is
called with a single parameter _argumentsList_ which is a possibly empty
List of ECMAScript language values. The following steps are taken:

1.  Let _handler_ be the value of the [[ProxyHandler]] internal data
    property of _O_.

2.  Let _target_ be the value of the [[ProxyTarget]] internal data
    property of _O_.

3.  Let _trap_ be the result of GetMethod(_handler_, "CONSTRUCT").

4.  ReturnIfAbrupt(_trap_).

5.  If _trap_ is UNDEFINED, then

    a.  Return the result of calling the [[Construct]] internal method
        of _target_ with argument _argumentsList_.

6.  Let _argArray_ be the result of
    CreateArrayFromList(_argumentsList_).

7.  Let _newObj_ be the result of calling _trap_ with _handler_ as the
    THIS value and a new List containing _target_ and _argArray_.

8.  ReturnIfAbrupt(_newObj_).

9.  If Type(_newObj_) is not Object, then throw a TYPEERROR exception.

10. Return _newObj_.

NOTE 1 An Proxy exotic object only has a [[Construct]] internal method
if the initial value of its [[ProxyTarget]] internal data property is an
object that has a [[Construct]] internal method.

NOTE 2 [[Construct]]] for proxy objects enforces the following
invariants:

-   The result of [[Construct]] must be an Object.

These operations are not a part of the ECMAScript language; they are
defined here to solely to aid the specification of the semantics of the
ECMAScript language. Other, more specialized abstract operations are
defined throughout this specification.


9.1 Type Conversion and Testing

The ECMAScript language implicitly performs automatic type conversion as
needed. To clarify the semantics of certain constructs it is useful to
define a set of conversion abstract operations. The conversion abstract
operations are polymorphic; they can accept a value of any ECMAScript
language type or of a Completion Record value. But no other
specification types are used with these operations.

9.1.1 ToPrimitive

The abstract operation ToPrimitive takes an input _argument_ and an
optional argument _PreferredType_. The abstract operation ToPrimitive
converts its _input_ argument to a non-Object type. If an object is
capable of converting to more than one primitive type, it may use the
optional hint _PreferredType_ to favour that type. Conversion occurs
according to Table 15:

Table 15 — ToPrimitive Conversions

  ------------------- --------------------------------------------------------------------------------------------------------------------------------------------------------------
  _INPUT TYPE_        _RESULT_
  Completion Record   If _argument_ is an abrupt completion, return _argument_. Otherwise return ToPrimitive(_argument_.[[value]]) also passing the optional hint _PreferredType_.
  Undefined           Return _argument_ (no conversion).
  Null                Return _argument_ (no conversion).
  Boolean             Return _argument_ (no conversion).
  Number              Return _argument_ (no conversion).
  String              Return _argument_ (no conversion).
  Symbol              Return _argument_ (no conversion).
  Object              Perform the steps following this table.
  ------------------- --------------------------------------------------------------------------------------------------------------------------------------------------------------

When the _InputType_ is Object, the following steps are taken:

1.  If _PreferredType_ was not passed, let _hint_ be "DEFAULT".

2.  Else if _PreferredType_ is hint String, let _hint_ be "STRING".

3.  Else _PreferredType_ is hint Number, let _hint_ be "NUMBER".

4.  Let _exoticToPrim_ be the result of Get(_argument_, @@ToPrimitive).

5.  ReturnIfAbrupt(_exoticToPrim_).

6.  If _exoticToPrim_ is not UNDEFINED, then

    a.  If IsCallable(_exoticToPrim)_ is FALSE, then throw a TYPEERROR
        exception.

    b.  Let _result_ be the result of calling the [[Call]] internal
        method of _exoticToPrim_, with _argument_ as _thisArgument_ and
        a List containing _hint_ as _argumentsList_.

    c.  ReturnIfAbrupt(_result_).

    d.  If _result_ is an ECMAScript language value and Type(_result_)
        is not Object, then return _result_.

    e.  Else, throw a TYPEERROR exception.

7.  If _hint_ is "DEFAULT" then, let _hint_ be "NUMBER".

8.  Return the result of OrdinaryToPrimitive(_argument,hint_).

When the OrdinaryToPrimitive is called with arguments _O_ and _hint_,
the following steps are taken:

1.  Assert: Type(_O_) is Object

2.  Assert: Type(_hint_) is String and its value is either "STRING" or
    "NUMBER".

3.  If _hint_ is "STRING", then

    a.  Let _tryFirst_ be "TOSTRING".

    b.  Let _trySecond_ be "VALUEOF".

4.  Else,

    a.  Let _tryFirst_ be "VALUEOF".

    b.  Let _trySecond_ be "TOSTRING".

5.  Let _first_ be the result of Get(_O_, _tryFirst_).

6.  ReturnIfAbrupt(_first_).

7.  If IsCallable(_first)_ is TRUE then,

    a.  Let _result_ be the result of calling the [[Call]] internal
        method of _first_, with _O_ as _thisArgument_ and an empty List
        as _argumentsList_.

    b.  ReturnIfAbrupt(_result_).

    c.  If _result_ is an ECMAScript language value and Type(_result_)
        is not Object, then return _result_.

    d.  

8.  Let _second_ be the result of Get(_O_, _trySecond_ ).

9.  ReturnIfAbrupt(_second_).

10. If IsCallable(_second)_ is TRUE then,

    a.  Let _result_ be the result of calling the [[Call]] internal
        method of _second_, with _O_ as _thisArgument_ and an empty
        argument list.

    b.  ReturnIfAbrupt(_result_).

    c.  If _result_ is an ECMAScript language value and Type(_result_)
        is not Object, then return _result_.

11. Throw a TYPEERROR exception.

NOTE When ToPrimitive is called with no hint, then it generally behaves
as if the hint were Number. However, objects may over-ride this
behaviour by defining a @@ToPrimitive method. Of the objects defined in
this specification only Date objects (see 15.9.6) over-ride the default
ToPrimitive behaviour. Date objects treat no hint as if the hint were
String.

9.1.2 ToBoolean

The abstract operation ToBoolean converts its _argument_ to a value of
type Boolean according to Table 16:

Table 16 — ToBoolean Conversions

  ------------------- --------------------------------------------------------------------------------------------------------------
  _ARGUMENT TYPE_     _RESULT_
  Completion Record   If _argument_ is an abrupt completion, return the argument. Otherwise return ToBoolean(_argument_.[[value]])
  Undefined           Return FALSE
  Null                Return FALSE
  Boolean             Return the input argument (no conversion).
  Number              Return FALSE if the argument is +0, −0, or NAN; otherwise return TRUE.
  String              Return FALSE if the argument is the empty String (its length is zero); otherwise return TRUE.
  Symbol              Return TRUE
  Object              Return TRUE
  ------------------- --------------------------------------------------------------------------------------------------------------

9.1.3 ToNumber

The abstract operation ToNumber converts its _argument_ to a value of
type Number according to Table 17:

Table 17 — ToNumber Conversions

  ------------------- -----------------------------------------------------------------------------------------------------------
  _ARGUMENT TYPE_     _RESULT_

  Completion Record   If _argument_ is an abrupt completion, return _argument_. Otherwise return ToNumber(_argument_.[[value]])

  Undefined           Return NAN

  Null                Return +0

  Boolean             Return 1 if _argument_ is TRUE. Return +0 if _argument_ is FALSE.

  Number              Return _argument_ (no conversion).

  String              See grammar and note below.

  Symbol              Return NAN

  Object              Apply the following steps:
                      
                      Let _primValue_ be ToPrimitive(_argument_, hint Number).
                      
                      Return ToNumber(_primValue_).
  ------------------- -----------------------------------------------------------------------------------------------------------

9.1.3.1 ToNumber Applied to the String Type

ToNumber applied to Strings applies the following grammar to the input
String. If the grammar cannot interpret the String as an expansion of
_StringNumericLiteral_, then the result of ToNumber is NAN.

Syntax

StringNumericLiteral :::

StrWhiteSpace~opt~
StrWhiteSpace~opt~ StrNumericLiteral StrWhiteSpace~opt~

StrWhiteSpace :::

StrWhiteSpaceChar StrWhiteSpace~opt~

StrWhiteSpaceChar :::

WhiteSpace
LineTerminator

StrNumericLiteral :::

StrDecimalLiteral
HexIntegerLiteral

StrDecimalLiteral :::

StrUnsignedDecimalLiteral
+ StrUnsignedDecimalLiteral
- StrUnsignedDecimalLiteral

StrUnsignedDecimalLiteral :::

INFINITY
 DecimalDigits . DecimalDigits~opt~ ExponentPart~opt~
. DecimalDigits ExponentPart~opt~
DecimalDigits ExponentPart~opt~

DecimalDigits :::

DecimalDigit
DecimalDigits DecimalDigit

DecimalDigit ::: ONE OF

0 1 2 3 4 5 6 7 8 

ExponentPart :::

ExponentIndicator SignedInteger

ExponentIndicator ::: ONE OF

E E

SignedInteger :::

DecimalDigits
+ DecimalDigits
- DecimalDigits

HexIntegerLiteral :::

0X HexDigit
0X HexDigit
HexIntegerLiteral HexDigit

HexDigit ::: ONE OF

0 1 2 3 4 5 6 7 8 9 A B C D E F A B C D E F

NOTE Some differences should be noted between the syntax of a
_StringNumericLiteral_ and a _NumericLiteral_ (see 7.8.3):

-   A _StringNumericLiteral_ may be preceded and/or followed by white
    space and/or line terminators.

-   A _StringNumericLiteral_ that is decimal may have any number of
    leading 0 digits.

-   A _StringNumericLiteral_ that is decimal may be preceded by + or -
    to indicate its sign.

-   A _StringNumericLiteral_ that is empty or contains only white space
    is converted to +0.

-   INFINITY AND –INFINITY are recognised as a _StringNumericLiteral_
    but not as a _NumericLiteral_.

RUNTIME SEMANTICS

The conversion of a String to a Number value is similar overall to the
determination of the Number value for a numeric literal (see 7.8.3), but
some of the details are different, so the process for converting a
String numeric literal to a value of Number type is given here in full.
This value is determined in two steps: first, a mathematical value (MV)
is derived from the String numeric literal; second, this mathematical
value is rounded as described below.

-   The MV of _StringNumericLiteral_ ::: [empty] is 0.

-   The MV of _StringNumericLiteral_ ::: _StrWhiteSpace_ is 0.

-   The MV of _StringNumericLiteral_ ::: _StrWhiteSpace_~opt~
      _StrNumericLiteral_ _StrWhiteSpace_~opt~ is the MV of
      _StrNumericLiteral_, no matter whether white space is present or
      not.

-   The MV of _StrNumericLiteral_ ::: _StrDecimalLiteral_ is the MV of
      _StrDecimalLiteral_.

-   The MV of _StrNumericLiteral_ ::: _HexIntegerLiteral_ is the MV of
      _HexIntegerLiteral_.

-   The MV of _StrDecimalLiteral_ ::: _StrUnsignedDecimalLiteral_ is the
      MV of _StrUnsignedDecimalLiteral_.

-   The MV of _StrDecimalLiteral_ ::: + _StrUnsignedDecimalLiteral_ is
      the MV of _StrUnsignedDecimalLiteral_.

-   The MV of _StrDecimalLiteral_ ::: - _StrUnsignedDecimalLiteral_ is
      the negative of the MV of _StrUnsignedDecimalLiteral_. (Note that
      if the MV of _StrUnsignedDecimalLiteral_ is 0, the negative of
      this MV is also 0. The rounding rule described below handles the
      conversion of this signless mathematical zero to a floating-point
      +0 or −0 as appropriate.)

-   The MV of _StrUnsignedDecimalLiteral_::: INFINITY is 10^10000^ (a
      value so large that it will round to +∞).

-   The MV of _StrUnsignedDecimalLiteral_::: _DecimalDigits_. is the MV
      of _DecimalDigits_.

-   The MV of _StrUnsignedDecimalLiteral_::: _DecimalDigits_ .
      _DecimalDigits_ is the MV of the first _DecimalDigits_ plus (the
      MV of the second _DecimalDigits_ times 10^−_n_^), where _n_ is the
      number of characters in the second _DecimalDigits_.

-   The MV of _StrUnsignedDecimalLiteral_::: _DecimalDigits_.
      _ExponentPart_ is the MV of _DecimalDigits_ times 10_^e^_, where
      _e_ is the MV of _ExponentPart_.

-   The MV of _StrUnsignedDecimalLiteral_::: _DecimalDigits_.
      _DecimalDigits ExponentPart_ is (the MV of the first
      _DecimalDigits_ plus (the MV of the second _DecimalDigits_ times
      10^−_n_^)) times 10_^e^_, where _n_ is the number of characters in
      the second _DecimalDigit_s and _e_ is the MV of _ExponentPart_.

-   The MV of _StrUnsignedDecimalLiteral_:::. _DecimalDigits_ is the MV
      of _DecimalDigits_ times 10^−_n_^, where _n_ is the number of
      characters in _DecimalDigit_s.

-   The MV of _StrUnsignedDecimalLiteral_:::. _DecimalDigits
      ExponentPart_ is the MV of _DecimalDigits_ times 10^_e_−_n_^,
      where _n_ is the number of characters in _DecimalDigit_s and _e_
      is the MV of _ExponentPart_.

-   The MV of _StrUnsignedDecimalLiteral_::: _DecimalDigits_ is the MV
      of _DecimalDigits_.

-   The MV of _StrUnsignedDecimalLiteral_::: _DecimalDigits_
      _ExponentPart_ is the MV of _DecimalDigits_ times 10_^e^_, where
      _e_ is the MV of _ExponentPart_.

-   The MV of _DecimalDigits_ ::: _DecimalDigit_ is the MV of
      _DecimalDigit_.

-   The MV of _DecimalDigits_ ::: _DecimalDigits_ _DecimalDigit_ is (the
      MV of _DecimalDigits_ times 10) plus the MV of _DecimalDigit_.

-   The MV of _ExponentPart_ ::: _ExponentIndicator SignedInteger_ is
      the MV of _SignedInteger_.

-   The MV of _SignedInteger_ ::: _DecimalDigits_ is the MV of
      _DecimalDigits_.

-   The MV of _SignedInteger_ ::: + _DecimalDigits_ is the MV of
      _DecimalDigits_.

-   The MV of _SignedInteger_ ::: - _DecimalDigits_ is the negative of
      the MV of _DecimalDigits_.

-   The MV of _DecimalDigit_ ::: 0 or of _HexDigit_ ::: 0 is 0.

-   The MV of _DecimalDigit_ ::: 1 or of _HexDigit_ ::: 1 is 1.

-   The MV of _DecimalDigit_ ::: 2 or of _HexDigit_ ::: 2 is 2.

-   The MV of _DecimalDigit_ ::: 3 or of _HexDigit_ ::: 3 is 3.

-   The MV of _DecimalDigit_ ::: 4 or of _HexDigit_ ::: 4 is 4.

-   The MV of _DecimalDigit_ ::: 5 or of _HexDigit_ ::: 5 is 5.

-   The MV of _DecimalDigit_ ::: 6 or of _HexDigit_ ::: 6 is 6.

-   The MV of _DecimalDigit_ ::: 7 or of _HexDigit_ ::: 7 is 7.

-   The MV of _DecimalDigit_ ::: 8 or of _HexDigit_ ::: 8 is 8.

-   The MV of _DecimalDigit_ ::: 9 or of _HexDigit_ ::: 9 is 9.

-   The MV of _HexDigit_ ::: A or of _HexDigit_ ::: A is 10.

-   The MV of _HexDigit_ ::: B or of _HexDigit_ ::: B is 11.

-   The MV of _HexDigit_ ::: C or of _HexDigit_ ::: C is 12.

-   The MV of _HexDigit_ ::: D or of _HexDigit_ ::: D is 13.

-   The MV of _HexDigit_ ::: E or of _HexDigit_ ::: E is 14.

-   The MV of _HexDigit_ ::: F or of _HexDigit_ ::: F is 15.

-   The MV of _HexIntegerLiteral_ ::: 0X _HexDigit_ is the MV of
      _HexDigit_.

-   The MV of _HexIntegerLiteral_ ::: 0X _HexDigit_ is the MV of
      _HexDigit_.

-   The MV of _HexIntegerLiteral_ ::: _HexIntegerLiteral_ _HexDigit_ is
      (the MV of _HexIntegerLiteral_ times 16) plus the MV of
      _HexDigit_.

Once the exact MV for a String numeric literal has been determined, it
is then rounded to a value of the Number type. If the MV is 0, then the
rounded value is +0 unless the first non white space character in the
String numeric literal is ‘-’, in which case the rounded value is −0.
Otherwise, the rounded value must be the Number value for the MV (in the
sense defined in 8.5), unless the literal includes a
_StrUnsignedDecimalLiteral_ and the literal has more than 20 significant
digits, in which case the Number value may be either the Number value
for the MV of a literal produced by replacing each significant digit
after the 20th with a 0 digit or the Number value for the MV of a
literal produced by replacing each significant digit after the 20th with
a 0 digit and then incrementing the literal at the 20th digit position.
A digit is _significant_ if it is not part of an _ExponentPart_ and

-   it is not 0; or

-   there is a nonzero digit to its left and there is a nonzero digit,
    not in the _ExponentPart_, to its right.

9.1.4 ToInteger

The abstract operation ToInteger converts its argument to an integral
numeric value. This abstract operation functions as follows:

9.1.5 ToInt32: (Signed 32 Bit Integer)

The abstract operation ToInt32 converts its argument to one of 2^32^
integer values in the range −2^31^ through 2^31^−1, inclusive. This
abstract operation functions as follows:

1.  Let _number_ be the result of calling ToNumber on the input
    argument.

2.  ReturnIfAbrupt(_number_).

3.  If _number_ is NAN, +0, −0, +∞, or −∞, return +0.

4.  Let _int_ be sign(_number_) × floor(abs(_number_)).

5.  Let _int32bit_ be _int_ modulo 2^32^.

6.  If _int32bit_ ≥ 2^31^, return _int32bit_ − 2^32^, otherwise return
    _int32bit_.

NOTE Given the above definition of ToInt32:

-   The ToInt32 abstract operation is idempotent: if applied to a result
      that it produced, the second application leaves that value
      unchanged.

-   ToInt32(ToUint32(_x_)) is equal to ToInt32(_x_) for all values of
      _x_. (It is to preserve this latter property that +∞ and −∞ are
      mapped to +0.)

-   ToInt32 maps −0 to +0.

9.1.6 ToUint32: (Unsigned 32 Bit Integer)

The abstract operation ToUint32 converts its argument to one of 2^32^
integer values in the range 0 through 2^32^−1, inclusive. This abstract
operation functions as follows:

NOTE Given the above definition of ToUInt32:

-   Step 6 is the only difference between ToUint32 and ToInt32.

-   The ToUint32 abstract operation is idempotent: if applied to a
      result that it produced, the second application leaves that value
      unchanged.

-   ToUint32(ToInt32(_x_)) is equal to ToUint32(_x_) for all values of
      _x_. (It is to preserve this latter property that +∞ and −∞ are
      mapped to +0.)

-   ToUint32 maps −0 to +0.

9.1.7 ToUint16: (Unsigned 16 Bit Integer)

The abstract operation ToUint16 converts its argument to one of 2^16^
integer values in the range 0 through 2^16^−1, inclusive. This abstract
operation functions as follows:

NOTE Given the above definition of ToUint16:

-   The substitution of 2^16^ for 2^32^ in step 4 is the only difference
      between ToUint32 and ToUint16.

-   ToUint16 maps −0 to +0.

9.1.8 ToString

The abstract operation ToString converts its _argument_ to a value of
type String according to Table 18:

Table 18 — ToString Conversions

  ------------------- -----------------------------------------------------------------------------------------------------------
  _ARGUMENT TYPE_     _RESULT_

  Completion Record   If _argument_ is an abrupt completion, return _argument_. Otherwise return ToString(_argument_.[[value]])

  Undefined           "UNDEFINED"

  Null                "NULL"

  Boolean             If _argument_ is TRUE, then return "TRUE".
                      
                      If _argument_ is FALSE, then return "FALSE".

  Number              See 9.8.1.

  String              Return _argument_ (no conversion)

  Symbol              "[OBJECT SYMBOL]"

  Object              Apply the following steps:
                      
                      1. Let _primValue_ be ToPrimitive(_argument_, hint String).
                      
                      2. Return ToString(_primValue_).
  ------------------- -----------------------------------------------------------------------------------------------------------

9.1.8.1 ToString Applied to the Number Type

The abstract operation ToString converts a Number _m_ to String format
as follows:

1.  If _m_ is NAN, return the String "NAN".

2.  If _m_ is +0 or −0, return the String "0".

3.  If _m_ is less than zero, return the String concatenation of the
    String "-" and ToString(−_m_).

4.  If _m_ is +∞, return the String "INFINITY".

5.  Otherwise, let _n_, _k_, and _s_ be integers such that _k_ ≥ 1,
    10^_k_−1^ ≤ _s_ < 10_^k^_, the Number value for _s_ × 10_^n−k^_ is
    _m_, and _k_ is as small as possible. Note that _k_ is the number of
    digits in the decimal representation of _s_, that _s_ is not
    divisible by 10, and that the least significant digit of _s_ is not
    necessarily uniquely determined by these criteria.

6.  If _k_ ≤ _n_ ≤ 21, return the String consisting of the _k_ digits of
    the decimal representation of _s_ (in order, with no leading
    zeroes), followed by _n−k_ occurrences of the character ‘0’.

7.  If 0 < _n_ ≤ 21, return the String consisting of the most
    significant _n_ digits of the decimal representation of _s_,
    followed by a decimal point ‘.’, followed by the remaining _k−n_
    digits of the decimal representation of _s_.

8.  If −6 < _n_ ≤ 0, return the String consisting of the character ‘0’,
    followed by a decimal point ‘.’, followed by −_n_ occurrences of the
    character ‘0’, followed by the _k_ digits of the decimal
    representation of _s_.

9.  Otherwise, if _k_ = 1, return the String consisting of the single
    digit of _s_, followed by lowercase character ‘E’, followed by a
    plus sign ‘+’ or minus sign ‘−’ according to whether _n_−1 is
    positive or negative, followed by the decimal representation of the
    integer abs(_n_−1) (with no leading zeroes).

10. Return the String consisting of the most significant digit of the
    decimal representation of _s_, followed by a decimal point ‘.’,
    followed by the remaining _k_−1 digits of the decimal representation
    of _s_, followed by the lowercase character ‘E’, followed by a plus
    sign ‘+’ or minus sign ‘−’ according to whether _n_−1 is positive or
    negative, followed by the decimal representation of the integer
    abs(_n_−1) (with no leading zeroes).

NOTE 1 The following observations may be useful as guidelines for
implementations, but are not part of the normative requirements of this
Standard:

-   If x is any Number value other than −0, then ToNumber(ToString(x))
      is exactly the same Number value as x.

-   The least significant digit of s is not always uniquely determined
      by the requirements listed in step 5.

NOTE 2 For implementations that provide more accurate conversions than
required by the rules above, it is recommended that the following
alternative version of step 5 be used as a guideline:

  Otherwise, let _n_, _k_, and _s_ be integers such that _k_ ≥ 1,
  10^_k_−1^ ≤ _s_ < 10_^k^_, the Number value for _s_ × 10^_n_−_k_^ is
  _m_, and _k_ is as small as possible. If there are multiple
  possibilities for _s_, choose the value of _s_ for which _s_ ×
  10^_n_−_k_^ is closest in value to _m_. If there are two such possible
  values of _s_, choose the one that is even. Note that _k_ is the
  number of digits in the decimal representation of _s_ and that _s_ is
  not divisible by 10.

NOTE 3 Implementers of ECMAScript may find useful the paper and code
written by David M. Gay for binary-to-decimal conversion of
floating-point numbers:

  Gay, David M. Correctly Rounded Binary-Decimal and Decimal-Binary
  Conversions. Numerical Analysis, Manuscript 90-10. AT&T Bell
  Laboratories (Murray Hill, New Jersey). November 30, 1990. Available
  as
  http://cm.bell-labs.com/cm/cs/doc/90/4-10.ps.gz. Associated code
  available as
  http://netlib.sandia.gov/fp/dtoa.c and as
  http://netlib.sandia.gov/fp/g_fmt.c and may also be found at the
  various NETLIB mirror sites.

9.1.9 ToObject

The abstract operation ToObject converts its _argument_ to a value of
type Object according to Table 19:

Table 19 — ToObject Conversions

  ------------------- ------------------------------------------------------------------------------------------------------------------------------------------------------------
  _ARGUMENT TYPE_     _RESULT_
  Completion Record   If _argument_ is an abrupt completion, return _argument_. Otherwise return ToObject(_argument_.[[value]])
  Undefined           Throw a TYPEERROR exception.
  Null                Throw a TYPEERROR exception.
  Boolean             Return a new Boolean object whose [[BooleanData]] internal data property is set to the value of _argument_. See 15.6 for a description of Boolean objects.
  Number              Return a new Number object whose [[NumberData]] internal data property is set to the value of _argument_. See 15.7 for a description of Number objects.
  String              Return a new String object whose [[StringData]] internal data property is set to the value of _argument_. See 15.5 for a description of String objects.
  Symbol              Throw a TYPEERROR exception.
  Object              Return _argument_ (no conversion).
  ------------------- ------------------------------------------------------------------------------------------------------------------------------------------------------------

9.1.10 ToPropertyKey 

The abstract operation ToPropertyKey converts its _argument_ to a value
that can be used as a property key by performing the following steps:

1.  ReturnIfAbrupt(_argument_).

2.  If Type(_argument_) is Symbol, then

    a.  b.  Return _argument_.

3.  Return ToString(_argument_).

1.  2.  3.  4.  5.  6.  


9.2 Testing and Comparison Operations

9.2.1 CheckObjectCoercible

The abstract operation CheckObjectCoercible throws an error if its
argument is a value that cannot be converted to an Object using
ToObject. It is defined by Table 20:

Table 20 — CheckObjectCoercible Results

  _ARGUMENT TYPE_     _RESULT_
  ------------------- -----------------------------------------------------------------------------------------------------------------------
  Completion Record   If _argument_ is an abrupt completion, return _argument_. Otherwise return CheckObjectCoercible(_argument_.[[value]])
  Undefined           Throw a TYPEERROR exception.
  Null                Throw a TYPEERROR exception.
  Boolean             Return _argument_
  Number              Return _argument_
  String              Return _argument_
  Symbol              Throw a TYPEERROR exception.
  Object              Return _argument_

9.2.2 IsCallable

The abstract operation IsCallable determines if its _argument_, which
must be an ECMAScript language value or a Completion Record, is a
callable function Object according to Table 21:

Table 21 — IsCallable Results

  ------------------- -------------------------------------------------------------------------------------------------------------
  _ARGUMENT TYPE_     _RESULT_
  Completion Record   If _argument_ is an abrupt completion, return _argument_. Otherwise return IsCallable(_argument_.[[value]])
  Undefined           Return FALSE.
  Null                Return FALSE.
  Boolean             Return FALSE.
  Number              Return FALSE.
  String              Return FALSE.
  Symbol              Return FALSE.
  Object              If _argument_ has a [[Call]] internal method, then return TRUE, otherwise return FALSE.
  ------------------- -------------------------------------------------------------------------------------------------------------

9.2.3 SameValue(x, y)

The internal comparison abstract operation SameValue(_x_, _y_), where
_x_ and _y_ are ECMAScript language values, produces TRUE or FALSE. Such
a comparison is performed as follows:

9.2.4 SameValueZero(x, y)

The internal comparison abstract operation SameValueZero(_x_, _y_),
where _x_ and _y_ are ECMAScript language values, produces TRUE or
FALSE. Such a comparison is performed as follows:

1.  ReturnIfAbrupt(_x_).

2.  ReturnIfAbrupt(_y_).

3.  If Type(_x_) is different from Type(_y_), return FALSE.

4.  If Type(_x_) is Undefined, return TRUE.

5.  If Type(_x_) is Null, return TRUE.

6.  If Type(_x_) is Number, then

    a.  If _x_ is NaN and _y_ is NaN, return TRUE.

    b.  If _x_ is +0 and _y_ is -0, return TRUE.

    c.  If _x_ is -0 and _y_ is +0, return TRUE.

    d.  If _x_ is the same Number value as _y_, return TRUE.

    e.  Return FALSE.

7.  If Type(_x_) is String, then

    a.  If _x_ and _y_ are exactly the same sequence of code units (same
        length and same code units in corresponding positions) return
        TRUE; otherwise, return FALSE.

8.  If Type(_x_) is Boolean, then

    a.  If _x_ and _y_ are both TRUE or both FALSE, then return TRUE;
        otherwise, return FALSE.

9.  If Type(_x_) is Symbol, then

    a.  If _x_ and _y_ are both the same Symbol value, then return TRUE;
        otherwise, return FALSE.

10. Return TRUE if _x_ and _y_ are the same Object value. Otherwise,
    return FALSE.

NOTE SameValueZero differs from SameValue only in its treatment of +0
and -0.

9.2.5 IsConstructor

The abstract operation IsConstructor determines if its _argument_, which
must be an ECMAScript language value or a Completion Record, is a
function object with a [[Construct]] internal method.

1.  ReturnIfAbrupt(_argument_).

2.  If Type(_argument_) is not Object, return FALSE.

3.  If _argument_ has a [[Construct]] internal method, return TRUE.

4.  Return FALSE.

9.2.6 IsPropertyKey

The abstract operation IsPropertyKey determine if its _argument_, which
must be an ECMAScript language value or a Completion Record, is a value
that may be used as a property key.

1.  ReturnIfAbrupt(_argument_).

2.  If Type(_argument_) is String, return TRUE.

3.  If Type(_argument_) is Symbol, return TRUE.

4.  Return FALSE.

9.2.7 IsExtensible (O)

The abstract operation IsExtensible is used to determine whether
additional properties can be added to an object. A Boolean value is
returned. The the argument _O_ where is the object that is tested. This
abstract operation performs the following steps:

1.  Assert: Type(_O_) is Object.

2.  Let _notExtensible_ be the result of calling the [[HasIntegrity]]
    internal method of _O_ with argument "NONEXTENSIBLE".

3.  ReturnIfAbrupt(_notExtensible_).

4.  If _notExtensible_ is TRUE, then return FALSE; else return TRUE.


 9.3 Operations on Objects

9.3.1 Get (O, P)

The abstract operation Get is used to retrieve the value of an specific
property of an object. The operation is called with arguments _O_ and
_P_ where _O_ is the object and _P_ is the property key. This abstract
operation performs the following steps:

1.  Assert: Type(_O_) is Object.

2.  Assert: IsPropertyKey(_P_) is TRUE.

3.  Return the result of calling the [[Get]] internal method of _O
    passing _P_ and _O_ as the arguments.

9.3.2 Put (O, P, V, Throw)

The abstract operation Put is used to set the value of a specific
property of an object. The operation is called with arguments _O_, _P_,
_V_, and _Throw_ where _O_ is the object, _P_ is the property key, _V
is the new value for the property and _Throw_ is a Boolean flag. This
abstract operation performs the following steps:

1.  Assert: Type(_O_) is Object.

2.  Assert: IsPropertyKey(_P_) is TRUE.

3.  Assert: Type(_Throw_) is Boolean.

4.  Let _success_ be the result of calling the [[Set]] internal method
    of _O_ passing _P_, _V_, and _O_ as the arguments.

5.  ReturnIfAbrupt(_success_).

6.  If _success_ is FALSE and _Throw_ is TRUE, then throw a TYPEERROR
    exception.

7.  Return _success_.

9.3.3 CreateOwnDataProperty (O, P, V)

The abstract operation CreateOwnDataProperty is used to create a new own
property of an object. The operation is called with arguments _O_, _P_,
and _V_ where _O_ is the object, _P_ is the property key, and _V_ is the
new value for the property. This abstract operation performs the
following steps:

1.  Assert: Type(_O_) is Object.

2.  Assert: IsPropertyKey(_P_) is TRUE.

3.  Assert: _O_ does not have an own property whose key is _P_.

4.  5.  6.  7.  Let _newDesc_ be the Property Descriptor {[[Value]]:
    _V_, [[Writable]]: TRUE, [[Enumerable]]: TRUE, [[Configurable]]:
    TRUE}.

8.  Return the result of calling the [[DefineOwnProperty]] internal
    method of _O_ passing _P_ and _newDesc_ as arguments.

NOTE This abstract operation creates a property whose attributes as set
to the same defaults used for properties created by the ECMAScript
language assignment operator.

9.3.4 DefinePropertyOrThrow (O, P, desc)

The abstract operation DefinePropertyOrThrow is used to call the
[[DefineOwnProperlty]] internal method of an object in a manner that
will throw a TYPEERROR exception if the requested property update cannot
be performed. The operation is called with arguments _O_, _P_, and
_desc_ where _O_ is the object, _P_ is the property key, and _desc_ is
the Property Descriptor for the property. This abstract operation
perform, the following steps:

1.  Assert: Type(_O_) is Object.

2.  Assert: IsPropertyKey(_P_) is TRUE.

3.  Let _success_ be the result of calling the [[DefineOwnProperty]]
    internal method of _O_ passing _P_ and _desc_ as arguments.

4.  ReturnIfAbrupt(_success_).

5.  If _success_ is FALSE, then throw a TYPEERROR exception.

6.  Return _success_.

9.3.5 DeletePropertyOrThrow (O, P)

The abstract operation Put is used to remove a specific own property of
an object. It throws an exception is the property is not configurable.
The operation is called with arguments _O_ and _P_ where _O_ is the
object and _P_ is the property key. This abstract operation performs the
following steps:

1.  Assert: Type(_O_) is Object.

2.  Assert: IsPropertyKey(_P_) is TRUE.

3.  Let _success_ be the result of calling the [[Delete]] internal
    method of _O_ passing _P_ as the argument.

4.  ReturnIfAbrupt(_success_).

5.  If _success_ is FALSE, then throw a TYPEERROR exception.

6.  Return _success_.

9.3.6 HasProperty (O, P)

The abstract operation HasProperty is used to determine whether an
object has a property with the specified property key. The property may
be either an own or inherited. A Boolean value is return. The operation
is called with arguments _O_ and _P_ where _O_ is the object and _P_ is
the property key. This abstract operation performs the following steps:

1.  Assert: Type(_O_) is Object.

2.  Assert: IsPropertyKey(_P_) is TRUE.

3.  4.  a.  b.  c.  d.  e.  f.  

5.  Return the result of calling the [[HasProperty]] internal method of
    _O_ with argument _P_.

9.3.7 GetMethod (O, P)

The abstract operation GetMethod is used to get the value of an specific
property of an object when the value of the property is expected to be a
function. The operation is called with arguments _O_ and _P_ where _O_
is the object, _P_ is the property key. This abstract operation performs
the following steps:

1.  Assert: Type(_O_) is Object.

2.  Assert: IsPropertyKey(_P_) is TRUE.

3.  Let _func_ be the result of calling the [[Get]] internal method of
    _O_ passing _P_ and _O_ as the arguments.

4.  ReturnIfAbrupt(_func_).

5.  If _func_ is UNDEFINED, then return UNDEFINED.

6.  If IsCallable(_func_) is FALSE, then throw a TYPEERROR exception.

7.  Return _func_.

9.3.8 Invoke(O,P, [args])

The abstract operation Invoke is used to call a method property of an
object. The operation is called with arguments _P_, _O_, and optionally
_args_ where _P_ is the property key, _O_ serves as both the lookup
point for the property and the THIS value of the call, and _args_ is the
list of arguments values passed to the method. If args is not present,
an empty List is used as its value. This abstract operation performs the
following steps:

1.  Assert: _P_ is a valid property key.

2.  If _args_ was not passed, then let _args_ be a new empty List.

3.  Let _obj_ be ToObject(_O_).

4.  ReturnIfAbrupt(_obj_).

5.  Let _func_ be the result of GetMethod(_obj_, _P_).

6.  ReturnIfAbrupt(_func_).

7.  If _func_ is UNDEFINED, throw a TYPEERROR exception.

8.  Return the result of calling the [[Call]] internal method of _func
    passing _O_ as _thisArgument_ and _args_ as _argumentsList_.

9.3.9 SetIntegrityLevel (O, level)

The abstract operation SetIntegrityLevel is used to fix the set of own
properties of an object. This abstract operation performs the following
steps:

1.  Assert: Type(_O_) is Object.

2.  3.  Assert: _level_ is either "SEALED" or "FROZEN".

4.  Let _keys_ be the result of calling the [[OwnPropertyKeys]] internal
    method of _O_.

5.  ReturnIfAbrupt(_keys_).

6.  Let _pendingException_ be UNDEFINED.

7.  If _level_ is "SEALED", then

    a.  Repeat for each element _k_ of _keys_,

        i.  Let _status_ be the result of DefinePropertyOrThrow(_O_,
            _k_, PropertyDescriptor{ [[Configurable]]: FALSE}).

        ii. If _status_ is an Abrupt Completion, then

            1.  If _pendingException_ is UNDEFINED, then set
                _pendingException_ to _status_.

8.  Else _level_ is "FROZEN",

    a.  Repeat for each element _k_ of _keys_,

        i.  Let _status_ be the result of calling the [[GetOwnProperty]]
            internal method of _O_ with _k_.

        ii. If _status_ is an Abrupt Completion, then

            1.  If _pendingException_ is UNDEFINED, then set
                _pendingException_ to _status_.

        iii. Else,

            1.  Let _currentDesc_ be _status_.[[value]].

            2.  If _currentDesc_ is not UNDEFINED, then

                a.  If IsAccessorDescriptor(_currentDesc_) is TRUE, then

                    i.  Let _desc_ be
                        PropertyDescriptor{[[Configurable]]: FALSE}.

                b.  Else,

                    i.  Let _desc_ be PropertyDescriptor {
                        [[Configurable]]: FALSE, [[Writable]]: FALSE }.

                c.  Let _status_ be the result of
                    DefinePropertyOrThrow(_O_, _k_, _desc_).

                d.  If _status_ is an Abrupt Completion, then

                    i.  If _pendingException_ is UNDEFINED, then set
                        _pendingException_ to _status_.

9.  If _pendingException_ is not UNDEFINED, then return
    _pendingException_.

10. Return the result of calling the [[PreventExtensions]] internal
    method of _O_.

9.3.10 TestIntegrityLevel (O, level)

The abstract operation TestIntegrityLevel is used to determine if the
set of own properties of an object are fixed. This abstract operation
performs the following steps:

1.  Assert: Type(_O_) is Object.

2.  Assert: _level_ is either "SEALED" or "FROZEN".

3.  4.  Let _status_ be the result of IsExtensible(_O_).

5.  ReturnIfAbrupt(_status_).

6.  If _status_ is TRUE, then return FALSE

7.  NOTE If the object is extensible, none of its properties are
    examined.

8.  Let _keys_ be the result of calling the [[OwnPropertyKeys]] internal
    method of _O_.

9.  ReturnIfAbrupt(_keys_).

10. Let _pendingException_ be UNDEFINED.

11. 12. Let _configurable_ be FALSE.

13. Let _writable_ be FALSE.

14. Repeat for each element _k_ of _keys_,

    a.  Let _status_ be the result of calling the [[GetOwnProperty]]
        internal method of _O_ with _k_.

    b.  If _status_ is an Abrupt Completion, then

        i.  If _pendingException_ is UNDEFINED, then set
            _pendingException_ to _status_.

        ii. Let _configurable_ be TRUE.

    c.  Else,

        i.  Let _currentDesc_ be _status_.[[value]].

        ii. If _currentDesc_ is not UNDEFINED, then

            1.  Set _configurable_ to _configurable_ logically ored with
                _currentDesc_.[[Configurable]].

            2.  If IsDataDescriptor(_currentDesc_) is TRUE, then

                a.  Set _writable_ to _writable_ logically ored with
                    _currentDesc_.[[Writable]].

15. If _pendingException_ is not UNDEFINED, then return
    _pendingException_.

16. If _level_ is "FROZEN" and _writable_ is TRUE, then return FALSE.

17. If _configurable_ is TRUE, then return FALSE.

18. Return TRUE.

9.3.11 CreateArrayFromList (elements)

The abstract operation CreateArrayFromList is used to create an Array
object whose elements are provided by an internal List. This abstract
operation performs the following steps:

1.  Assert: _elements_ is a List whose elements are all ECMAScript
    language values.

2.  Let _array_ be the result of the abstract operation ArrayCreate with
    argument 0.

3.  Let _n_ be 0.

4.  For each element _e_ of _elements

    a.  Call CreateOwnDataProperty(_array_, ToString(_n_), _e_).

    b.  Assert: the call in step 4.a will never result in an abrupt
        completion.

    c.  Increment _n_ by 1.

5.  Return _array_.

9.3.12 OrdinaryHasInstance (C, O)

The abstract operation OrdinaryHasInstance implements the default
algorithm for determining if an object _O_ inherits from the instance
object inheritance path provided by constructor _C_. This abstract
operation performs the following steps:

9.3.13 GetPrototypeFromConstructor ( constructor, intrinsicDefaultProto )

The abstract operation GetPrototypeFromConstructor determines the
[[Prototype]] value that should be used to create an object
corresponding to a specific constructor. The value is retrieved from the
constructor’s PROTOTYPE property, if it exists. Otherwise the supplied
default is used for [[Prototype]]. This abstract operation performs the
following steps:

1.  Assert: _intrinsicProto_ is a string value that is this
    specification’s name of an intrinsic object. The corresponding
    object must be an intrinsic that is intended to be used as the
    [[Prototype]] value of an object.

2.  If IsConstructor (_constructor_) is FALSE, then throw a TYPEERROR
    exception.

3.  Let _proto_ be the result of Get(_constructor_, "PROTOTYPE").

4.  ReturnIfAbrupt(_proto_).

5.  If Type(_proto_) is not Object, then

    a.  If _constructor_ has a [[Realm]] internal data property, let
        _realm_ be _constructor’s_ [[Realm]].

    b.  Else,

        i.  Let _ctx_ be the running execution context.

        ii. Let _realm_ be _ctx’s_ Realm.

    c.  Let _proto_ be _realm’s_ intrinsic object named
        _intrinsicDefaultProto_.

6.  Return _proto_.

NOTE If _constructor_ does not supply a [[Prototype]] value, the default
value that is used is obtained from the Code Realm of the _constructor_
function rather than from the running execution context. This accounts
for the possibility that a built-in @@create method from a different
Code Realm might be installed on _constructor_.

9.3.14 OrdinaryCreateFromConstructor ( constructor, intrinsicDefaultProto, internalDataList )

The abstract operation OrdinaryCreateFromConstructor creates an ordinary
object whose [[Prototype]] value is retrieved from a constructor’s
PROTOTYPE property, if it exists. Otherwise the supplied default is used
for [[Prototype]]. The optional _internalDataList_ is a List of the
names of internal data property names that should be defined as part of
the object. If the list is not provided, an empty List is used. This
abstract operation performs the following steps:

1.  Assert: _intrinsicDefaultProto_ is a string value that is this
    specification’s name of an intrinsic object. The corresponding
    object must be an intrinsic that is intended to be used as the
    [[Prototype]] value of an object.

2.  3.  4.  5.  a.  b.  i.  ii. 

    c.  

6.  Let _proto_ be the result of
    GetPrototypeFromConstructor(_constructor_, _intrinsicDefaultProto_).

7.  ReturnIfAbrupt(_proto_).

8.  Return the result of the abstract operation ObjectCreate(_proto_,
    _internalDataList_).


10.1 Types of Executable Code

There are four types of ECMAScript executable code:

-   _Global code_ is source text that is treated as an ECMAScript
      _Script_. The global code of a particular _Script_ does not
      include any source text that is parsed as part of a
      _FunctionBody_, _GeneratorBody_, _ConciseBody_, _ClassBody_, or
      _ModuleBody_.

-   _Eval code_ is the source text supplied to the built-in EVAL
      function. More precisely, if the parameter to the built-in EVAL
      function is a String, it is treated as an ECMAScript _Script_. The
      eval code for a particular invocation of EVAL is the global code
      portion of that _Script_.

-   _Function code_ is source text that is parsed to supply the value of
    the [[Code]] internal data property (see 8.3.15) of function and
    generator objects. The _function code_ of a particular function or
    generator does not include any source text that is parsed as the
    function code of a nested _FunctionBody_, _GeneratorBody_,
    _ConciseBody_, or _ClassBody_.

-   -   _Module code_ is source text that is parse code that is provided
      as a _ModuleBody_. It is the code that is directly evaluated when
      a module is initialized. The module code of a particular module
      does not include any source text that is parsed as part of a
      nested _FunctionBody_, _GeneratorBody_, _ConciseBody_,
      _ClassBody_, or _ModuleBody_.

NOTE Function code is generally provided as the bodies of Function
Definitions (13.1), Arrow Function Definitions (13.2), Method
Definitions (13.3) and Generator Definitions (13.4). Function code is
also derived from the last argument to the Function constructor (15.3).

10.1.1 Strict Mode Code

An ECMAScript _Script_ syntactic unit may be processed using either
unrestricted or strict mode syntax and semantics. When processed using
strict mode the four types of ECMAScript code are referred to as module
code, strict global code, strict eval code, and strict function code.
Code is interpreted as strict mode code in the following situations:

-   Global code is strict global code if it begins with a Directive
      Prologue that contains a Use Strict Directive (see 14.1).

-   Module code is always strict code.

-   All code contained in a _ClassBody_ is strict code.

-   Eval code is strict eval code if it begins with a Directive Prologue
      that contains a Use Strict Directive or if the call to eval is a
      direct call (see 15.1.2.1.1) to the eval function that is
      contained in strict mode code.

-   Function code that is part of a _FunctionDeclaration_,
      _FunctionExpression_, or accessor _PropertyDefinition_ is strict
      function code if its _FunctionDeclaration_, _FunctionExpression_,
      or _PropertyDefinition_ is contained in strict mode code or if the
      function code begins with a Directive Prologue that contains a Use
      Strict Directive.

-   Function code that is supplied as the last argument to the built-in
      Function constructor is strict function code if the last argument
      is a String that when processed as a _FunctionBody_ begins with a
      Directive Prologue that contains a Use Strict Directive.

-   

-   -   -   -   -   

10.1.2 Non-ECMAScript Functions

An ECMAScript implementation may support the evaluation of function
objects whose evaluative behaviour is expressed in some implementation
defined form of executable code other than via ECMAScript code. Whether
a function object is an ECMAScript code function or a non-ECMAScript
function is not semantically observable from the perspective of an
ECMAScript code function that calls or is called by such a
non-ECMAScript function.


10.2 Lexical Environments

A _Lexical Environment_ is a specification type used to define the
association of _Identifiers_ to specific variables and functions based
upon the lexical nesting structure of ECMAScript code. A Lexical
Environment consists of an Environment Record and a possibly null
reference to an _outer_ Lexical Environment. Usually a Lexical
Environment is associated with some specific syntactic structure of
ECMAScript code such as a _FunctionDeclaration_, a _BlockStatement_, or
a _Catch_ clause of a _TryStatement_ and a new Lexical Environment is
created each time such code is evaluated.

An _Environment Record_ records the identifier bindings that are created
within the scope of its associated Lexical Environment.

The outer environment reference is used to model the logical nesting of
Lexical Environment values. The outer reference of a (inner) Lexical
Environment is a reference to the Lexical Environment that logically
surrounds the inner Lexical Environment. An outer Lexical Environment
may, of course, have its own outer Lexical Environment. A Lexical
Environment may serve as the outer environment for multiple inner
Lexical Environments. For example, if a _FunctionDeclaration_ contains
two nested _FunctionDeclarations_ then the Lexical Environments of each
of the nested functions will have as their outer Lexical Environment the
Lexical Environment of the current evaluation of the surrounding
function.

A _global environment_ is a Lexical Environment which does not have an
outer environment. The global environment’s outer environment reference
is NULL. A global environment’s environment record may be prepopulated
with identifier bindings and includes an associated _global object_
whose properties provide some of the global environment’s identifier
bindings. This global object is the value of a global environment’s THIS
binding. As ECMAScript code is executed, additional properties may be
added to the global object and the initial properties may be modified.

A method environment is a Lexical Environment that corresponds to the
invocation of an ECMAScript function object that establishes a new THIS
binding. A method environment also captures the state necessary to
support SUPER method invocations.

Lexical Environments and Environment Record values are purely
specification mechanisms and need not correspond to any specific
artefact of an ECMAScript implementation. It is impossible for an
ECMAScript program to directly access or manipulate such values.

10.2.1 Environment Records

There are two primary kinds of Environment Record values used in this
specification: _declarative environment records_ and _object environment
records_. Declarative environment records are used to define the effect
of ECMAScript language syntactic elements such as
_FunctionDeclarations_, _VariableDeclarations_, and _Catch_ clauses that
directly associate identifier bindings with ECMAScript language values.
Object environment records are used to define the effect of ECMAScript
elements such as _WithStatement_ that associate identifier bindings with
the properties of some object. Global Environment Records and Function
Environment Records are specializations that are used for specifically
for _Script_ global declarations and for top-level declarations within
functions.

For specification purposes Environment Record values can be thought of
as existing in a simple object-oriented hierarchy where Environment
Record is an abstract class with three concrete subclasses, declarative
environment record, object environment record, and global environment
record. Function environment records are a subclass of declarative
environment record. The abstract class includes the abstract
specification methods defined in Table 22. These abstract methods have
distinct concrete algorithms for each of the concrete subclasses.

Table 22 — Abstract Methods of Environment Records

  _METHOD_                     _PURPOSE_
  ---------------------------- --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  HasBinding(N)                Determine if an environment record has a binding for an identifier. Return TRUE if it does and FALSE if it does not. The String value _N_ is the text of the identifier.
  CreateMutableBinding(N, D)   Create a new but uninitialised mutable binding in an environment record. The String value _N_ is the text of the bound name. If the optional Boolean argument _D_ is TRUE the binding is may be subsequently deleted.
  CreateImmutableBinding(N)    Create a new but uninitialised immutable binding in an environment record. The String value N is the text of the bound name.
  InitialiseBinding(N,V)       Set the value of an already existing but uninitialised binding in an environment record. The String value N is the text of the bound name. V is the value for the binding and is a value of any ECMAScript language type.
  SetMutableBinding(N,V, S)    Set the value of an already existing mutable binding in an environment record. The String value _N_ is the text of the bound name. _V_ is the value for the binding and may be a value of any ECMAScript language type. _S_ is a Boolean flag. If _S_ is TRUE and the binding cannot be set throw a TYPEERROR exception. _S_ is used to identify strict mode references.
  GetBindingValue(N,S)         Returns the value of an already existing binding from an environment record. The String value _N_ is the text of the bound name. _S_ is used to identify strict mode references. If _S_ is TRUE and the binding does not exist or is uninitialised throw a REFERENCEERROR exception.
  DeleteBinding(N)             Delete a binding from an environment record. The String value _N_ is the text of the bound name If a binding for _N_ exists, remove the binding and return TRUE. If the binding exists but cannot be removed return FALSE. If the binding does not exist return TRUE.
                               
  HasThisBinding()             Determine if an environment record establishes a THIS binding. Return TRUE if it does and FALSE if it does not.
  HasSuperBinding()            Determine if an environment record establishes a SUPER method binding. Return TRUE if it does and FALSE if it does not.
  WithBaseObject ()            If this environment record is associated with a WITH statement, return the with object. Otherwise, return UNDEFINED.

10.2.1.1 Declarative Environment Records

Each declarative environment record is associated with an ECMAScript
program scope containing variable, constant, let, class, module, import,
and/or function declarations. A declarative environment record binds the
set of identifiers defined by the declarations contained within its
scope.

The behaviour of the concrete specification methods for Declarative
Environment Records is defined by the following algorithms.

10.2.1.1.1 HasBinding(N)

The concrete environment record method HasBinding for declarative
environment records simply determines if the argument identifier is one
of the identifiers bound by the record:

10.2.1.1.2 CreateMutableBinding (N, D)

The concrete Environment Record method CreateMutableBinding for
declarative environment records creates a new mutable binding for the
name _N_ that is uninitialised. A binding must not already exist in this
Environment Record for _N_. If Boolean argument _D_ is provided and has
the value TRUE the new binding is marked as being subject to deletion.

1.  Let _envRec_ be the declarative environment record for which the
    method was invoked.

2.  Assert: _envRec_ does not already have a binding for _N_.

3.  Create a mutable binding in _envRec_ for _N_ and record that it is
    uninitialised. If _D_ is TRUE record that the newly created binding
    may be deleted by a subsequent DeleteBinding call.

4.  Return NormalCompletion(empty)

10.2.1.1.3 CreateImmutableBinding (N)

The concrete Environment Record method CreateImmutableBinding for
declarative environment records creates a new immutable binding for the
name _N_ that is uninitialised. A binding must not already exist in this
environment record for _N_.

10.2.1.1.4 InitialiseBinding (N,V)

The concrete Environment Record method InitialiseBinding for declarative
environment records is used to set the bound value of the current
binding of the identifier whose name is the value of the argument _N_ to
the value of argument _V_. An uninitialised binding for _N_ must already
exist.

1.  Let _envRec_ be the declarative environment record for which the
    method was invoked.

2.  Assert: _envRec_ must have an uninitialised binding for _N_.

3.  Set the bound value for _N_ in _envRec_ to _V_.

4.  Record that the binding for _N_ in _envRec_ has been initialised.

10.2.1.1.5 SetMutableBinding (N,V,S)

The concrete Environment Record method SetMutableBinding for declarative
environment records attempts to change the bound value of the current
binding of the identifier whose name is the value of the argument _N_ to
the value of argument _V_. A binding for _N_ must already exist. If the
binding is an immutable binding, a TYPEERROR is thrown if S is TRUE.

10.2.1.1.6 GetBindingValue(N,S)

The concrete Environment Record method GetBindingValue for declarative
environment records simply returns the value of its bound identifier
whose name is the value of the argument _N_. The binding must already
exist. If _S_ is TRUE and the binding is an uninitialised immutable
binding throw a REFERENCEERROR exception.

10.2.1.1.7 DeleteBinding (N)

The concrete Environment Record method DeleteBinding for declarative
environment records can only delete bindings that have been explicitly
designated as being subject to deletion.

1.  Let _envRec_ be the declarative environment record for which the
    method was invoked.

2.  If _envRec_ does not have a binding for the name that is the value
    of _N_, return TRUE.

3.  If the binding for _N_ in _envRec_ cannot be deleted, return FALSE.

4.  Remove the binding for _N_ from _envRec_.

5.  Return TRUE.

10.2.1.1.8 HasThisBinding () 

Regular Declarative Environment Records do not provide a THIS binding.

1.  Return FALSE.

10.2.1.1.9 HasSuperBinding ()

Regular Declarative Environment Records do not provide a SUPER binding.

1.  Return FALSE.

10.2.1.1.10 WithBaseObject()

Declarative Environment Records always return UNDEFINED as their
WithBaseObject.

10.2.1.2 Object Environment Records

Each object environment record is associated with an object called its
_binding object_. An object environment record binds the set of
identifier names that directly correspond to the property names of its
binding object. Property names that are not an _IdentifierName_ are not
included in the set of bound identifiers. Both own and inherited
properties are included in the set regardless of the setting of their
[[Enumerable]] attribute. Because properties can be dynamically added
and deleted from objects, the set of identifiers bound by an object
environment record may potentially change as a side-effect of any
operation that adds or deletes properties. Any bindings that are created
as a result of such a side-effect are considered to be a mutable binding
even if the Writable attribute of the corresponding property has the
value FALSE. Immutable bindings do not exist for object environment
records.

Object environment records created for WITH statements (12.10) can
provide their binding object as an implicit this value for use in
function calls. The capability is controlled by a _withEnvironment_
Boolean value that is associated with each object environment record. By
default, the value of _withEnvironment_ is FALSE for any object
environment record.

The behaviour of the concrete specification methods for Object
Environment Records is defined by the following algorithms.

10.2.1.2.1 HasBinding(N)

The concrete Environment Record method HasBinding for object environment
records determines if its associated binding object has a property whose
name is the value of the argument _N_:

10.2.1.2.2 CreateMutableBinding (N, D)

The concrete Environment Record method CreateMutableBinding for object
environment records creates in an environment record’s associated
binding object a property whose name is the String value and initialises
it to the value UNDEFINED. A property named _N_ must not already exist
in the binding object. If Boolean argument _D_ is provided and has the
value TRUE the new property’s [[Configurable]] attribute is set to TRUE,
otherwise it is set to FALSE.

10.2.1.2.3 CreateImmutableBinding (N)

The concrete Environment Record method CreateImmutableBinding is never
used within this specification in association with Object environment
records.

10.2.1.2.4 InitialiseBinding (N,V)

The concrete Environment Record method InitialiseBinding for object
environment records is used to set the bound value of the current
binding of the identifier whose name is the value of the argument _N_ to
the value of argument _V_. An uninitialised binding for _N_ must already
exist.

1.  Let _envRec_ be the object environment record for which the method
    was invoked.

2.  Assert: _envRec_ must have an uninitialised binding for N.

3.  Record that the binding for _N_ in _envRec_ has been initialised.

4.  Call the SetMutableBinding concrete method of _envRec_ with _N_,
    _V_, and FALSE as arguments.

10.2.1.2.5 SetMutableBinding (N,V,S)

The concrete Environment Record method SetMutableBinding for object
environment records attempts to set the value of the environment
record’s associated binding object’s property whose name is the value of
the argument _N_ to the value of argument _V_. A property named _N_
normally already exists but if it does not or is not currently writable,
error handling is determined by the value of the Boolean argument _S_.

1.  Let _envRec_ be the object environment record for which the method
    was invoked.

2.  Let _bindings_ be the binding object for _envRec_.

3.  Return the result of Put(_bindings_, _N_, _V_, and _S_).

10.2.1.2.6 GetBindingValue(N,S)

The concrete Environment Record method GetBindingValue for object
environment records returns the value of its associated binding object’s
property whose name is the String value of the argument identifier _N_.
The property should already exist but if it does not the result depends
upon the value of the _S_ argument:

10.2.1.2.7 DeleteBinding (N)

The concrete Environment Record method DeleteBinding for object
environment records can only delete bindings that correspond to
properties of the environment object whose [[Configurable]] attribute
have the value TRUE.

10.2.1.2.8 HasThisBinding ()

Regular Object Environment Records do not provide a THIS binding.

1.  Return FALSE.

10.2.1.2.9 HasSuperBinding ()

Regular Object Environment Records do not provide a SUPER binding.

1.  Return FALSE.

10.2.1.2.10 WithBaseObject()

Object Environment Records return UNDEFINED as their WithBaseObject
unless their _withEnvironment_ flag is TRUE.

10.2.1.3 Function Environment Records

A function environment record is a declarative environment record that
is used to represent the outer most scope of a function that provides a
THIS binding. In addition to its identifier bindings, a function
environment record contains the THIS value used within its scope. If
such a function references SUPER, its function environment record also
contains the state that is used to perform SUPER method invocations from
within the function.

Function environment records store their THIS binding as the value of
their _thisValue_. If the associated function references SUPER, the
environment record stores in _HomeObject_ the object that the function
is bound to as a method and in _MethodName_ the property key used for
unqualified super invocations from within the function. The default
value for _HomeObject_ and _MethodName_ is UNDEFINED.

Methods environment records support all of Declarative Environment
Record methods listed in Table 22 and share the same specifications for
all of those methods except for HasThisBinding and HasSuperBinding. In
addition, declarative environment records support the methods listed in
Table 23:

Table 23 — Additional Methods of Function Environment Records

  _METHOD_           _PURPOSE_
  ------------------ --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  GetThisBinding()   Return the value of this environment record’s THIS binding.
  GetSuperBase()     Return the object that is the base for SUPER property accesses bound in this environment record. The object is derived from this environment record’s HomeObject binding. If the value is Empty, return UNDEFINED.
  GetMethodName()    Return the value of this environment record’s MethodName binding.

The behaviour of the additional concrete specification methods for
Function Environment Records is defined by the following algorithms:

10.2.1.3.1 HasThisBinding ()

Function Environment Records always provide a THIS binding.

1.  Return TRUE.

10.2.1.3.2 HasSuperBinding ()

1.  If this environment record’s _HomeObject_ has the value Empty, then
    return FALSE. Otherwise, return TRUE.

10.2.1.3.3 GetThisBinding ()

1.  Return the value of this environment record’s _thisValue_.

10.2.1.3.4 GetSuperBase ()

1.  Let _home_ be the value of this environment record’s _HomeObject_.

2.  If _home_ has the value Empty, then return UNDEFINED.

3.  Assert Type(_home_) is Object.

4.  Return the result of calling _home’s_ [[GetInheritance]] internal
    method.

10.2.1.3.5 GetMethodName ()

1.  Return the value of this environment record’s _MethodName_.

10.2.1.4 Global Environment Records

A global environment record is used to represent the outer most scope
that is shared by all of the ECMAScript _Script_ elements that are
processed in a common Realm (10.3). A global environment provides the
bindings for built-in globals (15.1), properties of the global object,
and for all declarations that are not function code and that occur
within _Script_ productions.

A global environment record is logically a single record but it is
specified as a composite encapsulating an object environment record and
a declarative environment record. The object environment record has as
its base object the global object of the associated Realm. This global
object is also the value of the global environment record’s _thisValue_.
The object environment record component of a global environment record
contains the bindings for all built-in globals (15.1) and all bindings
introduced by a _FunctionDeclaration_ or _VariableStatement_ contained
in global code. The bindings for all other ECMAScript declarations in
global code are contained in the declarative environment record
component of the global environment record.

Properties may be created directly on a global object. Hence, the object
environment record component of a global environment record may contain
both bindings created explicitly by _FunctionDeclaration_ or
_VariableStatement_ declarations and binding created implicitly as
properties of the global object. In order to identify which bindings
were explicitly created using declarations, a global environment record
maintains a list of the names bound using its CreateGlobalVarBindings
and CreateGlobalFunctionBindings concrete methods.

Global environment records have the additional state components listed
in Table 24 and the additional methods listed in Table 25.

Table 24 -- Components of Global Environment Records

  _COMPONENT_              _PURPOSE_
  ------------------------ ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ObjectEnvironment        A Object Environment Record whose base object is the global object. Contains global built-in bindings as well as bindings for _FunctionDeclaration_ or _VariableStatement_ declarations in global code for the associated Realm.
  DeclarativeEnvironment   A Declarative Environment Record that contains bindings for all declarations in global for the associated Realm code except for _FunctionDeclaration_ and _VariableStatement_ declarations.
  VarNames                 A List containing the string names bound by _FunctionDeclaration_ or _VariableStatement_ declarations in global code for the associated Realm.

Table 25 — Additional Methods of Global Environment Records

  _METHOD_                               _PURPOSE_
  -------------------------------------- ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  GetThisBinding()                       Return the value of this environment record’s THIS binding.
  HasVarDeclaration (N)                  Determines if the argument identifier has a binding in this environment record that was created using a _VariableStatement_ or a _FunctionDeclaration_.
  HasLexicalDeclaration (N)              Determines if the argument identifier has a binding in this environment record that was created using a lexical declaration such as a _LexicalDeclaration_ or a _ClassDeclaration_.
  CanDeclareGlobalVar (N)                Determines if a corresponding CreateGlobalVarBinding call would succeed if called for the same argument _N_.
  CanDeclareGlobalFunction (N)           Determines if a corresponding CreateGlobalFunctionBinding call would succeed if called for the same argument _N_.
  CreateGlobalVarBinding(N, D)           Used to create global VAR bindings in the ObjectEnvironmentComponent of the environment record. The binding will be a mutable binding. The corresponding global object property will have attribute values approate for a VAR. The String value _N_ is the text of the bound name. _V_ is the initial value of the binding If the optional Boolean argument _D_ is TRUE the binding is may be subsequently deleted. This is logically equivalent to CreateMutableBinding but it allows var declarations to receive special treatment.
  CreateGlobalFunctionBinding(N, V, D)   Used to create and initialize global FUNCTION bindings in the ObjectEnvironmentComponent of the environment record. The binding will be a mutable binding. The corresponding global object property will have attribute values approate for a FUNCTION.The String value _N_ is the text of the bound name. If the optional Boolean argument _D_ is TRUE the binding is may be subsequently deleted. This is logically equivalent to CreateMutableBinding followed by a SetMutableBinding but it allows function declarations to receive special treatment.
                                         

The behaviour of the concrete specification methods for Global
Environment Records is defined by the following algorithms.

10.2.1.4.1 HasBinding(N)

The concrete environment record method HasBinding for global environment
records simply determines if the argument identifier is one of the
identifiers bound by the record:

1.  Let _envRec_ be the global environment record for which the method
    was invoked.

2.  Let _DclRec_ be _envRec’s_ DeclarativeEnvironment.

3.  If the result of calling _DclRec’s_ HasBinding concrete method with
    argument _N_ is TRUE, return TRUE.

4.  Let _ObjRec_ be _envRec’s_ ObjectEnvironment.

5.  Return the result of calling _ObjRec’s_ HasBinding concrete method
    with argument _N_.

10.2.1.4.2 CreateMutableBinding (N, D)

The concrete environment record method CreateMutableBinding for global
environment records creates a new mutable binding for the name _N_ that
is uninitialised. The binding is created in the associated
DeclarativeEnvironment. A binding for _N_ must not already exist in the
DeclarativeEnvironment. If Boolean argument _D_ is provided and has the
value TRUE the new binding is marked as being subject to deletion.

1.  Let _envRec_ be the global environment record for which the method
    was invoked.

2.  Let _DclRec_ be _envRec’s_ DeclarativeEnvironment.

3.  Assert: _DclRec_ does not already have a binding for _N_.

4.  Create a mutable binding in _DclRec_ for _N_ and record that it is
    uninitialised. If _D_ is TRUE record that the newly created binding
    may be deleted by a subsequent DeleteBinding call.

5.  Return NormalCompletion(empty)

10.2.1.4.3 CreateImmutableBinding (N)

The concrete Environment Record method CreateImmutableBinding for
declarative environment records creates a new immutable binding for the
name _N_ that is uninitialised. A binding must not already exist in this
environment record for _N_.

1.  Let _envRec_ be the global environment record for which the method
    was invoked.

2.  Assert: _envRec_ does not already have a binding for _N_.

3.  Create an immutable binding in _envRec_ for _N_ and record that it
    is uninitialised.

10.2.1.4.4 InitialiseBinding (N,V)

The concrete Environment Record method InitialiseBinding for global
environment records is used to set the bound value of the current
binding of the identifier whose name is the value of the argument _N_ to
the value of argument _V_. An uninitialised binding for _N_ must already
exist.

1.  Let _envRec_ be the global environment record for which the method
    was invoked.

2.  Let _DclRec_ be _envRec’s_ DeclarativeEnvironment.

3.  If the result of calling _DclRec’s_ HasBinding concrete method with
    argument _N_ is TRUE, then

    a.  Return the result of calling _DclRec’s_ InitialiseBinding
        concrete method with arguments _N_ and _V_.

4.  Let _ObjRec_ be _envRec’s_ ObjectEnvironment.

5.  If the result of calling _ObjRec’s_ HasBinding concrete method with
    argument _N_ is TRUE, then

    a.  Set the bound value for _N_ in _envRec_ to _V_.

    b.  Record that the binding for _N_ in _envRec_ has been
        initialised.

10.2.1.4.5 SetMutableBinding (N,V,S)

The concrete Environment Record method SetMutableBinding for global
environment records attempts to change the bound value of the current
binding of the identifier whose name is the value of the argument _N_ to
the value of argument _V_. If the binding is an immutable binding, a
TYPEERROR is thrown if S is TRUE. A property named _N_ normally already
exists but if it does not or is not currently writable, error handling
is determined by the value of the Boolean argument _S_.

1.  Let _envRec_ be the declarative environment record for which the
    method was invoked.

2.  Let _DclRec_ be _envRec’s_ DeclarativeEnvironment.

3.  If the result of calling _DclRec’s_ HasBinding concrete method with
    argument _N_ is TRUE, then

    a.  Return the result of calling the SetMutableBinding concrete
        method of _DclRec_ with arguments _N_, _V_, and _S_.

4.  Let _ObjRec_ be _envRec’s_ ObjectEnvironment.

5.  Return the result of calling the SetMutableBinding concrete method
    of _ObjRec_ with arguments _N_, _V_, and _S_.

10.2.1.4.6 GetBindingValue(N,S)

The concrete Environment Record method GetBindingValue for global
environment records simply returns the value of its bound identifier
whose name is the value of the argument _N_. If _S_ is TRUE and the
binding is an uninitialised binding throw a REFERENCEERROR exception. A
property named _N_ normally already exists but if it does not or is not
currently writable, error handling is determined by the value of the
Boolean argument _S_.

1.  Let _envRec_ be the declarative environment record for which the
    method was invoked.

2.  Let _DclRec_ be _envRec’s_ DeclarativeEnvironment.

3.  If the result of calling _DclRec’s_ HasBinding concrete method with
    argument _N_ is TRUE, then

    a.  Return the result of calling the GetBindingValue concrete method
        of _DclRec_ with arguments _N_, and _S_.

4.  Let _ObjRec_ be _envRec’s_ ObjectEnvironment.

5.  Return the result of calling the GetBindingValue concrete method of
    _ObjRec_ with arguments _N_, and _S_.

10.2.1.4.7 DeleteBinding (N)

The concrete Environment Record method DeleteBinding for global
environment records can only delete bindings that have been explicitly
designated as being subject to deletion.

1.  Let _envRec_ be the declarative environment record for which the
    method was invoked.

2.  Let _DclRec_ be _envRec’s_ DeclarativeEnvironment.

3.  If the result of calling _DclRec’s_ HasBinding concrete method with
    argument _N_ is TRUE, then

    a.  Return the result of calling the DeleteBinding concrete method
        of _DclRec_ with argument _N_.

4.  Let _ObjRec_ be _envRec’s_ ObjectEnvironment.

5.  If the result of calling _ObjRec’s_ HasBinding concrete method with
    argument _N_ is TRUE, then

    a.  Let _status_ be the result of calling the DeleteBinding concrete
        method of _ObjRec_ with argument _N_.

    b.  ReturnIfAbrupt(_status_).

    c.  If _status_ is TRUE, then

        i.  Let _varNames_ be _envRec’s_ VarNames List.

        ii. If _N_ is an element of _varNames_, then remove that element
            from the _varNames_.

    d.  Return _status_.

6.  Return TRUE.

10.2.1.4.8 HasThisBinding ()

Global Environment Records always provide a THIS binding whose value is
the associated global object.

1.  Return TRUE.

10.2.1.4.9 HasSuperBinding ()

1.  Return FALSE.

10.2.1.4.10 WithBaseObject()

Global Environment Records always return UNDEFINED as their
WithBaseObject.

1.  Return UNDEFINED.

10.2.1.4.11 GetThisBinding ()

1.  Let _envRec_ be the global environment record for which the method
    was invoked.

2.  Let _ObjRec_ be _envRec’s_ ObjectEnvironment.

3.  Let _bindings_ be the binding object for _ObjRec_.

4.  Return _bindings_.

10.2.1.4.12 HasVarDeclaration (N)

The concrete environment record method HasVarDeclaration for global
environment records determines if the argument identifier has a binding
in this record that was created using a _VariableStatement_ or a
_FunctionDeclaration_:

1.  Let _envRec_ be the global environment record for which the method
    was invoked.

2.  Let _varDeclaredNames_ be _envRec’s_ VarNames List.

3.  If _varDeclaredNames_ contains the value of _N_, return TRUE.

4.  Return FALSE.

10.2.1.4.13 HasLexicalDeclaration (N)

The concrete environment record method HasLexicalDeclaration for global
environment records determines if the argument identifier has a binding
in this record that was created using a lexical declaration such as a
_LexicalDeclaration_ or a _ClassDeclaration_:

1.  Let _envRec_ be the global environment record for which the method
    was invoked.

2.  Let _DclRec_ be _envRec’s_ DeclarativeEnvironment.

3.  Return the result of calling _DclRec’s_ HasBinding concrete method
    with argument _N_.

10.2.1.4.14 CanDeclareGlobalVar (N)

The concrete environment record method CanDeclareGlobalVar for global
environment records determines if a corresponding CreateGlobalVarBinding
call would succeed if called for the same argument _N_. Redundent var
declarations and var declarations for pre-existing global object
properties are allowed.

1.  Let _envRec_ be the global environment record for which the method
    was invoked.

2.  Let _ObjRec_ be _envRec’s_ ObjectEnvironment.

3.  If the result of calling _ObjRec’s_ HasBinding concrete method with
    argument _N_ is TRUE, return TRUE.

4.  Let _bindings_ be the binding object for _ObjRec_.

5.  Let _extensible_ be the result of IsExtensible(_bindings_).

6.  7.  Return _extensible_.

10.2.1.4.15 CanDeclareGlobalFunction (N)

The concrete environment record method CanDeclareGlobalVar for global
environment records determines if a corresponding
CreateGlobalFunctionBinding call would succeed if called for the same
argument _N_.

1.  Let _envRec_ be the global environment record for which the method
    was invoked.

2.  Let _ObjRec_ be _envRec’s_ ObjectEnvironment.

3.  Let _globalObject_ be the binding object for _ObjRec_.

4.  Let _extensible_ be the result of IsExtensible(_globalObject_).

5.  ReturnIfAbrupt(_extensible_).

6.  If the result of calling _ObjRec’s_ HasBinding concrete method with
    argument _N_ is FALSE, then return _extensible_.

7.  Let _existingProp_ be the result of calling the [[GetOwnProperty]]
    internal method of _globalObject_ with argument _N_.

8.  If _existingProp_ is UNDEFINED, then return _extensible_.

9.  If _existingProp_.[[Configurable]] is TRUE, then return TRUE.

10. If IsDataDescriptor(_existingProp_) is TRUE and _existingProp_ has
    attribute values {[[Writable]]: TRUE, [[Enumerable]]: TRUE}, then
    return TRUE.

11. Return FALSE.

10.2.1.4.16 CreateGlobalVarBinding (N, D)

The concrete Environment Record method CreateVarBinding for global
environment records creates a mutable binding in the associated object
environment record and records the bound name in the associated VarNames
List. If a binding already exists, it is reused.

1.  Let _envRec_ be the declarative environment record for which the
    method was invoked.

2.  Let _ObjRec_ be _envRec’s_ ObjectEnvironment.

3.  Assert: The result of calling _envRec’s_ CanDeclareGlobalVar
    concrete method with argument _N_ is TRUE.

4.  If the result of calling _ObjRec’s_ HasBinding concrete method with
    argument _N_ is FALSE, then

    a.  Call the CreateMutableBinding concrete method of _ObjRec_ with
        arguments _N_ and _D_.

5.  Let _varDeclaredNames_ be _envRec’s_ VarNames List.

6.  If _varDeclaredNames_ does not contain the value of _N_, then

    a.  Append _N_ to _varDeclaredNames_.

7.  Return.

10.2.1.4.17 CreateGlobalFunctionBinding (N, V, D)

The concrete Environment Record method CreateFunctionBinding for global
environment records creates a mutable binding in the associated object
environment record and records the bound name in the associated VarNames
List. If a binding already exists, it is replaced.

1.  Let _envRec_ be the declarative environment record for which the
    method was invoked.

2.  Let _ObjRec_ be _envRec’s_ ObjectEnvironment.

3.  Assert: The result of calling _envRec’s_ CanDeclareGlobalFunction
    concrete method with argument _N_ is TRUE.

4.  Let _globalObject_ be the binding object for _ObjRec_.

5.  Let _existingProp_ be the result of calling the [[GetOwnProperty]]
    internal method of _globalObject_ with argument _N_.

6.  If _existingProp_ is UNDEFINED or _existingProp_.[[Configurable]] is
    TRUE, then

    a.  Call the [[DefineOwnProperty]] internal method of _globalObject_
        passing _N_ and Property Descriptor {[[Value]]:_V_,
        [[Writable]]: TRUE, [[Enumerable]]: TRUE , [[Configurable]]:
        _D_} as arguments.

7.  Else,

    a.  Call the [[DefineOwnProperty]] internal method of _globalObject_
        passing _N_ and Property Descriptor {[[Value]]:_V_ } as
        arguments.

8.  NOTE The assertion in step 3 means that the above
    [[DefineOwnProperty]] calls will never return FALSE or an abrupt
    completion.

9.  Let _varDeclaredNames_ be _envRec’s_ VarNames List.

10. If _varDeclaredNames_ does not contain the value of _N_, then

    a.  Append _N_ to _varDeclaredNames_.

11. Return.

NOTE Global function declarations are always represented as a own
property of the global object. If possible, an existing own property is
reconfigured to have a standard set of attribute values.

10.2.2 Lexical Environment Operations

The following abstract operations are used in this specification to
operate upon lexical environments:

10.2.2.1 GetIdentifierReference (lex, name, strict)

The abstract operation GetIdentifierReference is called with a Lexical
Environment _lex_, a String _name_, and a Boolean flag _strict._ The
value of _lex_ may be NULL. When called, the following steps are
performed:

1.  If _lex_ is the value NULL, then

    a.  Return a value of type Reference whose base value is UNDEFINED,
        whose referenced name is _name_, and whose strict reference flag
        is _strict_.

2.  Let _envRec_ be _lex_’s environment record.

3.  Let _exists_ be the result of calling the HasBinding(_N_) concrete
    method of _envRec_ passing _name_ as the argument _N_.

4.  If _exists_ is TRUE, then

    a.  Return a value of type Reference whose base value is _envRec_,
        whose referenced name is _name_, and whose strict reference flag
        is _strict._

5.  Else

    a.  Let _outer_ be the value of _lex’s_ outer environment reference.

    b.  Return the result of calling GetIdentifierReference passing
        _outer_, _name_, and _strict_ as arguments.

10.2.2.2 NewDeclarativeEnvironment (E)

When the abstract operation NewDeclarativeEnvironment is called with
either a Lexical Environment or NULL as argument _E_ the following steps
are performed:

10.2.2.3 NewObjectEnvironment (O, E)

When the abstract operation NewObjectEnvironment is called with an
Object _O_ and a Lexical Environment _E_ (or NULL) as arguments, the
following steps are performed:

10.2.2.4 NewFunctionEnvironment (F, T)

When the abstract operation NewFunctionEnvironment is called with an
ECMAScript function Object _F_ and a ECMAScript value _T_ as arguments,
the following steps are performed:

1.  Assert: The value of _F’s_ [[ThisMode]] internal data property is
    not lexical.

2.  Let _env_ be a new Lexical Environment.

3.  Let _envRec_ be a new Function environment record containing
    containing no bindings.

4.  Set _envRec’s_ _thisValue_ to _T_.

5.  If _F_ has a [[HomeObject]] internal data property, then

    a.  Set _envRec’s_ _HomeObject_ to the value of _F’s_ [[HomeObject]]
        internal data property.

    b.  Set _envRec’s_ _MethodName_ to the value of _F’s_ [[MethodName]]
        internal data property.

6.  Else,

    a.  b.  Set _envRec’s_ _HomeObject_ to Empty.

7.  Set _env’s_ environment record to be _envRec_.

8.  Set the outer lexical environment reference of _env_ to the value of
    _F’s_ [[Scope]] internal data property.

9.  Return _env_.


10.3 Code Realms

Before it is evaluated, all ECMAScript code must be associated with a
_Realm_. Conceptually, a realm consists of a set of intrinsic objects,
an ECMAScript global environment, all of the ECMAScript code that is
loaded within the scope of that global environment, a Loader object that
can associate new ECMAScript code with the realm, and other associated
state and resources.

A Realm is specified as a Record with the fields specified in Table 26:

Table 26 — Realm Record Fields

  ---------------- ---------------------------------------------------------------------------- ------------------------------------------------------------------------
  _FIELD NAME_     _VALUE_                                                                      _MEANING_
  [[intrinsics]]   A record whose field names are intrinsic keys and whose values are objects   These are the intrinsic values used by code associated with this Realm
  [[globalThis]]   An ECMAScript object                                                         The global object for this Realm
  [[globalEnv]]    A ECMAScript environment                                                     The global environment for this Realm
  [[loader]]       any ECMAScript identifier or EMPTY                                           The Loader object that can associate ECMAScript code with this Realm
  ---------------- ---------------------------------------------------------------------------- ------------------------------------------------------------------------

The intrinsic objects associated with a code Realm include the
well-known intrinsics listed in Table 11 and additional intrinsics
specified by Table 27.

Table 27 — Additional Intrinsic Objects with Realm Specific Bindings

  ------------------ -----------------------------------
  _INTRINSIC NAME_   _ECMASCRIPT LANGUAGE ASSOCIATION_
  ???                ???
  ???                ???
                     
                     
                     
                     
                     
                     
                     
                     
                     
                     
                     
                     
                     
                     
                     
                     
  ------------------ -----------------------------------


10.4 Execution Contexts

An _execution context_ is a specification device that is used to track
the runtime evaluation of code by an ECMAScript implementation. At any
point in time, there is at most one execution context that is actually
executing code. This is known as the _running_ execution context. A
stack is used to track execution contexts. The running execution context
is always the top element of this stack. A new execution context is
created whenever control is transferred from the executable code
associated with the currently running execution context to executable
code that is not associated with that execution context. The newly
created execution context is pushed onto the stack and becomes the
running execution context.

An execution context contains whatever implementation specific state is
necessary to track the execution progress of its associated code. Each
execution context has the state components listed in Table 28.

Table 28 —State Components for All Execution Contexts

  _COMPONENT_             _PURPOSE_
  ----------------------- -----------------------------------------------------------------------------------------------------------------
  code evaluation state   Any state needed to perform, suspend, and resume evaluation of the code associated with this execution context.
                          
  Realm                   The Realm from which associated code accesses ECMAScript resources.
                          
                          
                          

Evaluation of code by the running execution context may be suspended at
various points defined within this specification. Once the running
execution context has been suspended a different execution context may
become the running execution context and commence evaluating its code.
At some latter time a suspended execution context may again become the
running execution context and continue evaluating its code at the point
where it had previously been suspended. Transition of the running
execution context status among execution contexts usually occurs in
stack-like last-in/first-out manner. However, some ECMAScript features
require non-LIFO transitions of the running execution context.

The value is the Realm component of the running execution context is
also called the _current Realm_.

Execution contexts for ECMAScript code have the additional state
components listed in Table 29.

Table 29 —Additional State Components for ECMAScript Code Execution
Contexts

  _COMPONENT_           _PURPOSE_
  --------------------- -------------------------------------------------------------------------------------------------------------------------------------------
  LexicalEnvironment    Identifies the Lexical Environment used to resolve identifier references made by code within this execution context.
  VariableEnvironment   Identifies the Lexical Environment whose environment record holds bindings created by _VariableStatements_ within this execution context.

The LexicalEnvironment and VariableEnvironment components of an
execution context are always Lexical Environments. When an execution
context is created its LexicalEnvironment and VariableEnvironment
components initially have the same value. The value of the
VariableEnvironment component never changes while the value of the
LexicalEnvironment component may change during execution of code within
an execution context.

Execution contexts representing the evaluation of generator objects have
the additional state components listed in Table 30.

Table 30 -- Additional State Components for Generator Execution Contexts

  _COMPONENT_   _PURPOSE_
  ------------- ----------------------------------------------------------------
  Generator     The GeneratorObject that this execution context is evaluating.

In most situations only the running execution context (the top of the
execution context stack) is directly manipulated by algorithms within
this specification. Hence when the terms “LexicalEnvironment”, and
“VariableEnvironment” are used without qualification they are in
reference to those components of the running execution context.

An execution context is purely a specification mechanism and need not
correspond to any particular artefact of an ECMAScript implementation.
It is impossible for an ECMAScript program to directly access or observe
an execution context.

10.4.1 Identifier Resolution

Identifier resolution is the process of determining the binding of an
_IdentifierName_ using the LexicalEnvironment of the running execution
context. During execution of ECMAScript code, Identifier Resolution is
performed using the following algorithm:

The result of evaluating an identifier is always a value of type
Reference with its referenced name component equal to the
_IdentifierName_ String.

10.4.2 GetThisEnvironment

The abstract operation GetThisEnviroment finds the lexical environment
that currently supplies the binding of the keyword THIS.
GetThisEnviroment performs the following steps:

1.  Let _lex_ be the running execution context’s LexicalEnvironment.

2.  Repeat

    a.  Let _envRec_ be _lex_’s environment record.

    b.  Let _exists_ be the result of calling the HasThisBinding
        concrete method of _envRec_.

    c.  If _exists_ is TRUE, then return _envRec_.

    d.  Let _outer_ be the value of _lex’s_ outer environment reference.

    e.  Let _lex_ be _outer_.

NOTE The loop in step 2 will always terminate because the llst of
environments always ends with the global environment which has a THIS
binding.

10.4.3 This Resolution

The abstract operation ThisResolution is the process of determining the
binding of the keyword THIS using the LexicalEnvironment of the running
execution context. ThisResolution performs the following steps:

1.  Let _env_ be the result of performing the GetThisEnvironment
    abstract operation.

2.  Return the result of calling the GetThisBinding concrete method of
    _env_.

10.4.4 GetGlobalObject

The abstract operation GetGlobalObject returns the global object used by
the currently running execution context. GetGlobalObject performs the
following steps:

1.  Let _ctx_ be the running execution context.

2.  Let _currentRealm_ be _ctx’s_ Realm.

3.  Return _currentRealm_.[[globalThis]].


10.5 Declaration Binding Instantiation

10.5.1 Global Declaration Instantiation

NOTE When an execution context is established for evaluating scripts,
declarations are instantiated in the current global environment. Each
global binding declarated in the code is instantiated.

Global Declaration Instantiation is performed as follows using arguments
_script_, _env_, and _deletableBindings_. _script_ is the _ScriptBody
that for which the execution context is being established. _env_ is the
global environment record in which bindings are to be created.
_deletableBindings_ is TRUE if the bindings that are created should be
deletable.

NOTE Early errors specified in 14.1 prevent name conflicts between
function/var declarations and let/const/class/module declarations as
well as redeclaration of let/const/class/module bindings for declaration
contained within a single _Script_. However, such conflicts and
redeclarations that span more than one _Script_ are detected as runtime
errors during Global Declaration Instantiation. If any such errors are
detected, no bindings are instantiated for the script.

Unlike explicit var or function declarations, properties that are
directly created on the global object result in global bindings that may
be shadowed by let, const, class, and module declarations.

10.5.2 Module Declaration Instantiation

10.5.3 Function Declaration Instantiation

This version reflects the concensus as of the Sept. 2012 TC39 meeting.
However, it now appears that the binding semantics of formal parameters
is like to change again.

NOTE When an execution context is established for evaluating function
code a new Declarative Environment Record is created and bindings for
each formal parameter, and each function level variable, constant, or
function declarated in the function are instantiated in the environment
record. Formal parameters and functions are initialized as part of this
process. All other bindings are initialized during execution of the
function code.

Function Declaration Instantiation is performed as follows using
arguments _func,_ _argumentsList_, and _env_. _func_ is the function
object that for which the execution context is being established. _env_
is the declarative environment record in which bindings are to be
created.

1.  Let _code_ be the value of the [[Code]] internal data property of
    _func_.

2.  Let _strict_ be the value of the [[Strict]] internal data property
    of _func_.

3.  Let _formals_ be the value of the [[FormalParameters]] internal data
    property of _func_.

4.  Let _parameterNames_ be the BoundNames of _formals_.

5.  Let _varDeclarations_ be the VarScopedDeclarations of _code_.

6.  Let _functionsToInitialize_ be an empty List.

7.  Let _argumentsObjectNotNeeded_ be FALSE.

8.  For each _d_ in _varDeclarations_, in reverse list order do

    a.  If _d_ is a _FunctionDeclaration_ then

        i.  NOTE If there are multiple _FunctionDeclarations_ for the
            same name, the last declaration is used.

        ii. Let _fn_ be the sole element of the BoundNames of _d._

        iii. If _fn_ is "ARGUMENTS", then let _argumentsObjectNotNeeded_
            be TRUE.

        iv. Let _alreadyDeclared_ be the result of calling _env’s_
            HasBinding concrete method passing _fn_ as the argument.

        v.  If _alreadyDeclared_ is FALSE, then

            1.  Let _status_ be the result of calling _env’s_
                CreateMutableBinding concrete method passing _fn_ as the
                argument.

            2.  Assert: _status_ is never an Abrupt Completion.

            3.  Append _d_ to _functionsToInitialize_.

9.  For each String _paramName_ in _parameterNames_, do

    a.  Let _alreadyDeclared_ be the result of calling _env’s_
        HasBinding concrete method passing _paramName_ as the argument.

    b.  NOTE Duplicate parameter names can only occur in non-strict
        functions. Parameter names that are the same as function
        declaration names do not get initialized to UNDEFINED.

    c.  If _alreadyDeclared_ is FALSE, then

        i.  If _paramName_ is "ARGUMENTS", then let
            _argumentsObjectNotNeeded_ be TRUE.

        ii. Let _status_ be the result of calling _env’s_
            CreateMutableBinding concrete method passing _paramName_ as
            the argument.

        iii. Assert: _status_ is never an Abrupt Completion

        iv. v.  Call _env_’s InitialiseBinding concrete method passing
            _paramName_, and UNDEFINED as the arguments.

10. NOTE If there is a function declaration or formal parameter with the
    name "ARGUMENTS" then an argument object is not created.

11. If _argumentsObjectNotNeeded_ is FALSE, then

    a.  If _strict_ is TRUE, then

        i.  Call _env_’s CreateImmutableBinding concrete method passing
            the String "ARGUMENTS" as the argument.

    b.  Else,

        i.  Call _env_’s CreateMutableBinding concrete method passing
            the String "ARGUMENTS" as the argument.

12. Let _varNames_ be the VarDeclaredNames of _code_.

13. For each String _varName_ in _varNames_, in list order do

    a.  Let _alreadyDeclared_ be the result of calling _env’s_
        HasBinding concrete method passing _varName_ as the argument.

    b.  NOTE A VarDeclaredNames is only instantiated and initialied here
        if it is not also the name of a formal parameter or a
        _FunctionDeclarations_.

    c.  If _alreadyDeclared_ is FALSE, then

        i.  Call _env’s_ CreateMutableBinding concrete method passing
            _varName_ as the argument.

14. Let _lexDeclarations_ be the LexicalDeclarations of _code_.

15. For each element _d_ in _lexDeclarations_ do

    a.  NOTE A lexically declared name cannot be the same as a function
        declaration, formal parameter, or a var name. Lexically
        declarated names are only instantiated here but not initialized.

    b.  For each element _dn_ of the BoundNames of _d_ do

        i.  If IsConstantDeclaration of _d_ is TRUE, then

            1.  Call _env_’s CreateImmutableBinding concrete method
                passing _dn_ as the argument.

        ii. Else,

            1.  Call _env_’s CreateMutableBinding concrete method
                passing _dn_ and FALSE as the arguments.

    c.  If _d_ is a _GeneratorDeclaration_ production, then

        i.  Append _d_ to _functionsToInitialize_.

16. For each production _f_ in _functionsToInitialize_, do

    a.  Let _fn_ be the sole element of the BoundNames of _f._

    b.  Let _fo_ be the result of performing InstantiateFunctionObject
        for _f_ with argument _env_.

    c.  Call _env_’s SetMutableBinding concrete method passing _fn_,
        _fo_, and FALSE as the arguments.

17. NOTE Function declaration are initialised prior to parameter
    initialisation so that default value expressions may reference them.
    "ARGUMENTS" is not initialized until after parameter initialization.

18. Let _ao_ be the result of InstantiateArgumentsObject with argument
    _argumentsList._

19. 20. a.  b.  

21. a.  b.  c.  d.  

22. 23. 24. a.  i.  ii. 1.  a.  

            2.  a.  

25. 26. NOTE If _argumentsObjectNotNeeded_ is TRUE then the value of
    _ao_ is not directly observable to ECMAScript code and need not
    actually exist. In that case, its use in the above steps is strictly
    as a device for specifying formal parameter initialisation
    semantics.

27. Let _formalStatus_ be the result of performing Binding
    Initialisation for _formals_ with _ao_ and UNDEFINED as arguments.

28. ReturnIfAbrupt(_formalStatus_).

29. 30. If _argumentsObjectNotNeeded_ is FALSE, then

    a.  If _strict_ is TRUE, then

        i.  Perform the abstract operation CompleteStrictArgumentsObject
            with argument _ao._

        ii. 

    b.  Else,

        i.  Perform the abstract operation CompleteMappedArgumentsObject
            with arguments _ao, func_, _formals_, and _env_.

        ii. 

    c.  Call _env_’s InitialiseBinding concrete method passing
        "ARGUMENTS" and _ao_ as arguments.

31. 32. a.  b.  c.  i.  ii. 

33. 34. a.  b.  c.  i.  ii. iii. 

35. Return NormalCompletion(empty).

10.5.4 Block Declaration Instantiation

NOTE When a _Block_ or _CaseBlock_ production is evaluated a new
Declarative Environment Record is created and bindings for each block
scoped variable, constant, or function declarated in the block are
instantiated in the environment record.

Block Declaration Instantiation is performed as follows using arguments
_code_ and _env_. _code_ is the grammar production corresponding to the
body of the block. _env_ is the declarative environment record in which
bindings are to be created.

1.  2.  Let _declarations_ be the LexicalDeclarations of _code_.

3.  Let _functionsToInitialize_ be an emptyList.

4.  For each element _d_ in _declarations_ do

    a.  For each element _dn_ of the BoundNames of _d_ do

        i.  If IsConstantDeclaration of _d_ is TRUE, then

            1.  Call _env_’s CreateImmutableBinding concrete method
                passing _dn_ as the argument.

        ii. Else,

            1.  Call _env_’s CreateMutableBinding concrete method
                passing _dn_ and FALSE as the arguments.

    b.  If _d_ is a _GeneratorDeclaration_ production or a
        _FunctionDeclaration_ production, then

        i.  Append _d_ to _functionsToInitialize_.

5.  For each production _f_ in _declarations_, in list order do

    a.  Let _fn_ be the sole element of the BoundNames of _f._

    b.  Let _fo_ be the result of performing InstantiateFunctionObject
        for _f_ with argument _env_.

    c.  d.  Call _env_’s InitialiseBinding concrete method passing _fn_,
        and _fo_ as the arguments.

    e.  

10.5.5 Eval Declaration Instantiation


10.6 Arguments Object

When function code is evaluated, an arguments object is created unless
(as specified in 10.5) the identifier ARGUMENTS occurs as an
_Identifier_ in the function’s _FormalParameters_ or occurs as the
_BindingIdentifier_ of a _FunctionDeclaration_ contained in the
outermost _StatementList_ of the function code.

The abstract operation InstantiateArgumentsObject called with an
argument _args_ performs the following steps:

The abstract operation _CompleteStrictArgumentsObject_ is called with
argument _obj_ which must have been previously created by the abstract
operation InstantiateArgumentsObject. The following steps are performed:

1.  2.  3.  4.  a.  b.  c.  

5.  6.  Perform the AddRestrictedFunctionProperties abstract operation
    with argument _obj_.

7.  8.  9.  Return.

The abstract operation _Complete_MappedArgumentsObject is called with
object _obj_, object _func_, grammar production _formals_, and
environment record _env_. _obj_ must have been previously created by the
abstract operation InstantiateArgumentsObject.The following steps are
performed:

1.  Let _len_ be the result of Get(_obj_, "LENGTH").

2.  3.  4.  5.  Let _mappedNames_ be an empty List.

6.  Let _numberOfNonRestFormals_ be NumberOfParameters of _formals_.

7.  Let _map_ be the result of the abstract operation ObjectCreate with
    the intrinsic object %ObjectPrototype% as its argument.

8.  Let _indx_ = _len_ - 1.

9.  Repeat while _indx_ ≥ 0,

    a.  b.  c.  If _indx_ is less than the _numberOfNonRestFormals_,
        then

        i.  Let _param_ be getParameter of _formals_ with argument
            _indx_.

        ii. If _param_ is a _BindingIdentifier_, then

            1.  Let _name_ be the sole element of BoundNames of _param_.

            2.  If _name_ is not an element of _mappedNames_, then

                a.  Add _name_ as an element of the list _mappedNames_.

                b.  Let _g_ be the result of calling the MakeArgGetter
                    abstract operation with arguments _name_ and _env_.

                c.  Let _p_ be the result of calling the MakeArgSetter
                    abstract operation with arguments _name_ and _env_.

                d.  Call the [[DefineOwnProperty]] internal method of
                    _map_ passing ToString(_indx_) and the Property
                    Descriptor {[[Set]]: _p_, [[Get]]: _g,_
                    [[Configurable]]: TRUE} as arguments.

    d.  Let _indx_ = _indx_ - 1

10. If _mappedNames_ is not empty, then

    a.  Set the [[ParameterMap]] internal data property of _obj_ to
        _map_.

    b.  Set the [[Get]], [[GetOwnProperty]], [[DefineOwnProperty]], and
        [[Delete]] internal methods of _obj_ to the definitions provided
        below.

11. Call the [[DefineOwnProperty]] internal method on _obj_ passing
    "CALLEE" and the Property Descriptor {[[Value]]: _func_,
    [[Writable]]: TRUE, [[Enumerable]]: FALSE, [[Configurable]]: TRUE}
    as arguments.

12. Return _obj

The abstract operation MakeArgGetter called with String _name_ and
environment record _env_ creates a function object that when executed
returns the value bound for _name_ in _env_. It performs the following
steps:

1.  Let _bodyText_ be the result of concatenating the Strings "RETURN ",
    _name_, and ";".

2.  Let _body_ be the result of parsing _bodyText_ using _FunctionBody
    as the goal symbol.

3.  Let _parameters_ be a _FormalParameters_ : [empty] production.

4.  Return the result of calling the abstract operation FunctionCreate
    using Normal as the _kind_, _parameters_ as _FormalParameterList_,
    _body_ for _FunctionBody_, _env_ as _Scope_, and TRUE for _Strict_.

The abstract operation MakeArgSetter called with String _name_ and
environment record _env_ creates a function object that when executed
sets the value bound for _name_ in _env_. It performs the following
steps:

The [[Get]] internal method of an arguments object for a non-strict mode
function with formal parameters when called with a property name _P_
performs the following steps:

The [[GetOwnProperty]] internal method of an arguments object for a
non-strict mode function with formal parameters when called with a
property name _P_ performs the following steps:

The [[DefineOwnProperty]] internal method of an arguments object for a
non-strict mode function with formal parameters when called with a
property name _P_ and Property Descriptor _Desc_ performs the following
steps:

1.  Let _map_ be the value of the [[ParameterMap]] internal data
    property of the arguments object.

2.  Let _isMapped_ be the result of calling the [[GetOwnProperty]]
    internal method of _map_ passing _P_ as the argument.

3.  Let _allowed_ be the result of calling the default
    [[DefineOwnProperty]] internal method (8.3.9) on the arguments
    object passing _P_ and _Desc_ as the arguments.

4.  ReturnIfAbrupt(_allowed_).

5.  If _allowed_ is FALSE, then

6.  return FALSE.

7.  If the value of _isMapped_ is not UNDEFINED, then

    a.  If IsAccessorDescriptor(_Desc_) is TRUE, then

        i.  Call the [[Delete]] internal method of _map_ passing _P_ as
            the argument.

    b.  Else

        i.  If _Desc_.[[Value]] is present, then

            1.  Assert: the follow Put call will always succeed because
                formal parameters mapped by argument objects are always
                writable.

            2.  Call Put(_map_, _P_, _Desc_.[[Value]], FALSE).

        ii. If _Desc_.[[Writable]] is present and its value is FALSE,
            then

            1.  Call the [[Delete]] internal method of _map_ passing _P_
                as the argument.

8.  Return TRUE.

The [[Delete]] internal method of an arguments object for a non-strict
mode function with formal parameters when called with a property key _P_
performs the following steps:

1.  Let _map_ be the value of the [[ParameterMap]] internal data
    property of the arguments object.

2.  Let _isMapped_ be the result of calling the [[GetOwnProperty]]
    internal method of _map_ passing _P_ as the argument.

3.  Let _result_ be the result of calling the default [[Delete]]
    internal method for ordinary objects (8.3.10) on the arguments
    object passing _P_ as the argument.

4.  If _result_ is TRUE and the value of _isMapped_ is not UNDEFINED,
    then

    a.  Call the [[Delete]] internal method of _map_ passing _P_ as the
        argument.

5.  Return _result_.

NOTE 1 For non-strict mode functions the array index (defined in 15.4)
data properties of an arguments object whose numeric name values are
less than the number of formal parameters of the corresponding function
object initially share their values with the corresponding argument
bindings in the function’s execution context. This means that changing
the property changes the corresponding value of the argument binding and
vice-versa. This correspondence is broken if such a property is deleted
and then redefined or if the property is changed into an accessor
property. For strict mode functions, the values of the arguments
object’s properties are simply a copy of the arguments passed to the
function and there is no dynamic linkage between the property values and
the formal parameter values.

NOTE 2 The ParameterMap object and its property values are used as a
device for specifying the arguments object correspondence to argument
bindings. The ParameterMap object and the objects that are the values of
its properties are not directly accessible from ECMAScript code. An
ECMAScript implementation does not need to actually create or use such
objects to implement the specified semantics.

NOTE 3 Arguments objects for strict mode functions define
non-configurable accessor properties named "CALLER" and "CALLEE" which
throw a TYPEERROR exception on access. The "CALLEE" property has a more
specific meaning for non-strict mode functions and a "CALLER" property
has historically been provided as an implementation-defined extension by
some ECMAScript implementations. The strict mode definition of these
properties exists to ensure that neither of them is defined in any other
manner by conforming ECMAScript implementations.


11.1 Primary Expressions

Syntax

PrimaryExpression :

THIS
Identifier
Literal
ArrayInitialiser
ObjectLiteral
FunctionExpression
ClassExpression
GeneratorExpression
GeneratorComprehension
RegularExpressionLiteral
TemplateLiteral
CoverParenthesisedExpressionAndArrowParameterList

CoverParenthesisedExpressionAndArrowParameterList :

( Expression )
( )
( ... Identifier )
( Expression , ... Identifier)

Supplemental Syntax

When processing the production _PrimaryExpression_ :
_CoverParenthesisedExpressionAndArrowParameterList_ the following
grammar is used to refine the interpretation of
_CoverParenthesisedExpressionAndArrowParameterList_.

ParenthesisedExpression :

( Expression )

STATIC SEMANTICS

-   -   

STATIC SEMANTICS: COVEREDPARENTHESISEDEXPRESSION

CoverParenthesisedExpressionAndArrowParameterList : ( Expression )

1.  Return the result of parsing the lexical token stream matched by
    _CoverParenthesisedExpressionAndArrowParameterList_ using
    _ParenthesisedExpression_ as the goal symbol.

STATIC SEMANTICS: ISVALIDSIMPLEASSIGNMENTTARGET

PrimaryExpression :

THIS
Literal
ArrayInitialiser
ObjectLiteral
FunctionExpression
ClassExpression
GeneratorExpression
GeneratorComprehension
RegularExpressionLiteral
TemplateLiteral

1.  Return FALSE.

_PrimaryExpression_ : _Identifier

1.  If this _PrimaryExpression_ is contained in strict code and
    StringValue of _Identifier_ is "EVAL" or "ARGUMENTS", then return
    FALSE.

2.  Return TRUE.

_PrimaryExpression_ :
_CoverParenthesisedExpressionAndArrowParameterList

1.  Let _expr_ be CoveredParenthesisedExpression of
    _CoverParenthesisedExpressionAndArrowParameterList_.

2.  Return IsValidSimpleAssignmentTarget of _expr_.

11.1.1 The this Keyword

RUNTIME SEMANTICS: EVALUATION

PrimaryExpression : THIS

1.  2.  Return the result of calling the ThisResolution abstract
    operation.

11.1.2 Identifier Reference

RUNTIME SEMANTICS: EVALUATION

PrimaryExpression : Identifier

1.  Let _ref_ be the result of performing Identifier Resolution as
    specified in 10.4.1 using the _IdentifierName_ corresponding to
    _Identifier_.

2.  Return _ref_.

NOTE: The result of evaluating an _Identifier_ is always a value of type
Reference.

11.1.3 Literals 

Syntax

Literal :

NullLiteral
ValueLiteral

ValueLiteral :

BooleanLiteral
NumericLiteral
StringLiteral

RUNTIME SEMANTICS

RUNTIME SEMANTICS: EVALUATION

Literal : NullLiteral

1.  Return NULL.

ValueLiteral : BooleanLiteral

1.  Return FALSE if _BooleanLiteral_ is the token _BooleanLiteral_ ::
    FALSE

2.  Return TRUE if _BooleanLiteral_ is the token _BooleanLiteral_ ::
    TRUE

ValueLiteral : NumericLiteral

1.  Return the number whose value is MV of _NumericLiteral_ as defined
    in 7.8.3.

ValueLiteral : StringLiteral

1.  Return the string whose elements are the SV of _StringLiteral_ as
    defined in 7.8.4.

11.1.4 Array Initialiser

Syntax

ArrayInitialiser :

ArrayLiteral
ArrayComprehension

11.1.4.1 Array Literal

NOTE An _ArrayLiteral_ is an expression describing the initialisation of
an Array object, using a list, of zero or more expressions each of which
represents an array element, enclosed in square brackets. The elements
need not be literals; they are evaluated each time the array initialiser
is evaluated.

Array elements may be elided at the beginning, middle or end of the
element list. Whenever a comma in the element list is not preceded by an
_AssignmentExpression_ (i.e., a comma at the beginning or after another
comma), the missing array element contributes to the length of the Array
and increases the index of subsequent elements. Elided array elements
are not defined. If an element is elided at the end of an array, that
element does not contribute to the length of the Array.

Syntax

ArrayLiteral :

[ Elision~opt~ ]
[ ElementList ]
[ ElementList , Elision~opt~ ]

ElementList :

Elision~opt~ AssignmentExpression
Elision~opt~ SpreadElement
ElementList , Elision~opt~ AssignmentExpression
ElementList , Elision~opt~ SpreadElement

Elision :

,
Elision ,

SpreadElement :

... AssignmentExpression

STATIC SEMANTICS

-   -   

STATIC SEMANTICS: ELISION WIDTH

1.  

_Elision_ : ,

1.  Return the numeric value 1.

_Elision_ : _Elision_ ,

1.  Let _preceding_ be the Elision Width of _Elision_.

2.  Return _preceding_+1.

RUNTIME SEMANTICS

RUNTIME SEMANTICS: ARRAY ACCUMULATION

  With parameters _array_ and _nextIndex_.

_ElementList_ : _Elision_~opt~ _AssignmentExpression

1.  Let _padding_ be the Elision Width of _Elision_; if _Elision_ is not
    present, use the numeric value zero.

2.  Let _initResult_ be the result of evaluating _AssignmentExpression_.

3.  Let _initValue_ be GetValue(_initResult_).

4.  ReturnIfAbrupt(_initValue_).

5.  Call the [[DefineOwnProperty]] internal method of _array_ with
    arguments ToString(ToUint32(_nextIndex+padding_)) and the Property
    Descriptor { [[Value]]: _initValue_, [[Writable]]: TRUE,
    [[Enumerable]]: TRUE, [[Configurable]]: TRUE}.

6.  Assert: the above call to [[DefineOwnProperty]] will never return
    FALSE or an abrupt completion value.

7.  Return _nextIndex+padding+_1.

_ElementList_ : _Elision_~opt~ _SpreadElement

1.  Let _padding_ be the Elision Width of _Elision_; if _Elision_ is not
    present, use the numeric value zero.

2.  Return the result of performing Array Accumulation for
    _SpreadElement_ with arguments _array_ and _nextIndex_+_padding_.

_ElementList_ : _ElementList_ , _Elision_~opt~ _AssignmentExpression

1.  Let _postIndex_ be the result of performing Array Accumulation for
    _ElementList_ with arguments _array_ and _nextIndex_.

2.  ReturnIfAbrupt(_postIndex_).

3.  Let _padding_ be the Elision Width of _Elision_; if _Elision_ is not
    present, use the numeric value zero.

4.  Let _initResult_ be the result of evaluating _AssignmentExpression_.

5.  Let _initValue_ be GetValue(_initResult_).

6.  ReturnIfAbrupt(_initValue_).

7.  Call the [[DefineOwnProperty]] internal method of _array_ with
    arguments ToString(ToUint32(_postIndex_+_padding_)) and the Property
    Descriptor { [[Value]]: _initValue_, [[Writable]]: TRUE,
    [[Enumerable]]: TRUE, [[Configurable]]: TRUE}.

8.  Assert: the above call to [[DefineOwnProperty]] will never return
    FALSE or an abrupt completion value.

9.  Return _postIndex_+_padding+_1.

_ElementList_ : _ElementList_ , _Elision_~opt~ _SpreadElement

1.  Let _postIndex_ be the result of performing Array Accumulation for
    _ElementList_ with arguments _array_ and _nextIndex_.

2.  ReturnIfAbrupt(_postIndex_).

3.  Let _padding_ be the Elision Width of _Elision_; if _Elision_ is not
    present, use the numeric value zero.

4.  Return the result of performing Array Accumulation for
    _SpreadElement_ with arguments _array_ and _postIndex_+_padding_.

_SpreadElement_ : ... _AssignmentExpression

1.  Let _spreadRef_ be the result of evaluating _AssignmentExpression_.

2.  Let _spreadValue_ be GetValue(_spreadRef_).

3.  Let _spreadObj_ be ToObject(_spreadValue_).

4.  ReturnIfAbrupt(_spreadObj_).

5.  Let _lenVal_ be the result of calling Get(_spreadObj_, "LENGTH").

6.  Let _spreadLen_ be ToUint32(_lenVal_).

7.  ReturnIfAbrupt(_spreadLen_).

8.  Let _n_=0;

9.  Repeat, while _n_ < _spreadLen

    a.  Let _exists_ be the result of HasProperty(_spreadObj_,
          ToString(_n_)).

    b.  ReturnIfAbrupt(_exists_).

    c.  If _exists_ is TRUE then,

        i.  Let _v_ be the result of calling the [[Get]] internal method
              of _spreadObj_ passing ToString(_n_) as the argument.

        ii. ReturnIfAbrupt(_v_).

        iii. Call the [[DefineOwnProperty]] internal method of _array_
              with arguments ToString(ToUint32(_nextIndex)_) and
              Property Descriptor {[[Value]]: _v_, [[Writable]]: TRUE,
              [[Enumerable]]: TRUE, [[Configurable]]: TRUE}.

        iv. Assert: the above call to [[DefineOwnProperty]] will never
              return FALSE or an abrupt completion value.

    d.  Let _n_ = _n_+1.

    e.  Let _nextIndex_ = _nextIndex_ +1.

10. Return _nextIndex_.

NOTE [[DefineOwnProperty]] is used to ensure that own properties are
defined for the array even if the standard built-in Array prototype
object has been modified in a manner that would preclude the creation of
new own properties using [[Set]].

RUNTIME SEMANTICS: EVALUATION

_ArrayLiteral_ : [ _Elision_~opt~ ]

1.  Let _array_ be the result of the abstract operation ArrayCreate with
    argument 0.

2.  Let _pad_ be the Elision Width of _Elision_; if _Elision_ is not
    present, use the numeric value zero.

3.  Call Put(_array_, "LENGTH", _pad_, FALSE).

4.  Return _array_.

_ArrayLiteral_ : [ _ElementList_ ]

1.  Let _array_ be the result of the abstract operation ArrayCreate with
    argument 0.

2.  Let _len_ be the result of performing Array Accumulation for
    _ElementList_ with arguments _array_ and 0.

3.  ReturnIfAbrupt(_len_).

4.  Call Put(_array_, "LENGTH", _len_, FALSE).

5.  Return _array_.

_ArrayLiteral_ : [ _ElementList_ , _Elision_~opt~ ]

1.  Let _array_ be the result of the abstract operation ArrayCreate with
    argument 0.

2.  3.  Let _len_ be the result of performing Array Accumulation for
    _ElementList_ with arguments _array_ and 0.

4.  ReturnIfAbrupt(_len_).

5.  Let _padding_ be the Elision Width of _Elision_; if _Elision_ is not
    present, use the numeric value zero.

6.  7.  Call Put(_array_, "LENGTH", ToUint32(_padding_+_len_), FALSE).

8.  Return _array_.

11.1.4.2 Array Comprehension

Syntax

ArrayComprehension :

[Comprehension ]

Comprehension :

ComprehensionFor ComprehensionQualifierTail

ComprehensionQualifierTail :

AssignmentExpression
ComprehensionQualifier ComprehensionQualifierTail

ComprehensionQualifier :

ComprehensionFor
ComprehensionIf

ComprehensionFor :

FOR ( ForBinding OF AssignmentExpression )

ComprehensionIf :

IF ( AssignmentExpression )

ForBinding :

BindingIdentifier
BindingPattern

STATIC SEMANTICS

STATIC SEMANTICS: EARLY ERRORS

_ComprehensionFor_ : FOR (_ForBinding_ OF _AssignmentExpression_ )

-   It is a Syntax Error if the BoundNames of _ForBinding_ contains any
    duplicate entries.

1.  

1.  

RUNTIME SEMANTICS

RUNTIME SEMANTICS: BINDING INITIALISATION

  With arguments _value_ and _environment_.

NOTE UNDEFINED is passed for _environment_ to indicate that a PutValue
operation should be used to assign the initialisation value. This is the
case for VAR statements formal parameter lists of non-strict functions.
In those cases a lexical binding is hosted and preinitialised prior to
evaluation of its initializer.

_ForBinding_ : _BindingPattern

1.  Let _obj_ be ToObject(_value_).

2.  ReturnIfAbrupt(_obj_).

3.  Return the result of performing Binding Initialisation for
    _BindingPattern_ passing _obj_ and _environment_ as the arguments.

RUNTIME SEMANTICS: COMPREHENSIONEVALUATION

  With argument _accumulator_.

NOTE UNDEFINED is passed for _accumulator_ to indicate that a
comprehension component is being evaluated as part of a generator
comprehension. Otherwise, the value of _accumulator_ is the array object
into the elements of an array comprehension are to be accumulated.

_Comprehension_ : _ComprehensionFor ComprehensionQualifierTail

1.  Return the result of performing QualifierEvaluation for
    _ComprehensionFor_ with arguments _ComprehensionQualifierTail_ and
    _accumulator_.

_ComprehensionQualifierTail_: _ComprehensionQualifier
ComprehensionQualifierTail_

1.  Return the result of performing QualifierEvaluation for
    _ComprehensionQualifier_ with arguments _ComprehensionQualifierTail_
    and _accumulator_.

_ComprehensionQualifierTail_: _AssignmentExpression

1.  Let _valueRef_ be the result of evaluating _AssignmentExpression_.

2.  Let _value_ be GetValue(_valueRef_).

3.  ReturnIfAbrupt(_value_).

4.  If _accumulator_ is not UNDEFINED, then

    a.  Assert: this is part of an array comprehension.

    b.  Assert: _accumulator_ is an exotic array object so access to its
        LENGTH property should never fail.

    c.  Let _len_ be the result of Get(_accumulator_, "LENGTH").

    d.  If _len_≥2^32^-1, then throw a RANGEERROR exception.

    e.  Let _putStatus_ be the result of Put(_O_, ToString(_len_),
        _value_, TRUE).

    f.  ReturnIfAbrupt(_putStatus_).

    g.  Increase _len_ by 1.

    h.  Let _putStatus_ be the result of Put(_O_, "LENGTH", _len_,
        TRUE).

    i.  ReturnIfAbrupt(_putStatus_).

    j.  Return NormalCompletion(UNDEFINED).

5.  Assert: _accumulator_ is UNDEFINED, so this is part of a generator
    comprehension.

6.  Let _yieldStatus_ be the result of
    GeneratorYield(CreateItrResultObject(_value_, FALSE)).

7.  ReturnIfAbrupt(_yieldStatus_).

8.  Return NormalCompletion(UNDEFINED).

RUNTIME SEMANTICS: QUALIFIEREVALUATION

  With arguments _tail_ and _accumulator_.

NOTE UNDEFINED is passed for _accumulator_ to indicate that a
comprehension component is being evaluated as part of a generator
comprehension. Otherwise, the value of _accumulator_ is the array object
into the elements of an array comprehension are to be accumulated.

_ComprehensionFor_ : FOR (_ForBinding_ OF _AssignmentExpression_ )

1.  Let _exprRef_ be the result of evaluating _AssignmentExpression_.

2.  Let _experValue_ be GetValue(_exprRef_).

3.  Let _obj_ be ToObject(_experValue_).

4.  ReturnIfAbrupt(_obj_).

5.  Let _iterator_ be the result of performing Invoke with arguments
    _obj_, @@iterator, and an empty List.

6.  Let _keys_ be ToObject(_iterator_).

7.  ReturnIfAbrupt(_keys_).

8.  Let _oldEnv_ be the running execution context’s LexicalEnvironment.

9.  Let _noArgs_ be an empty List.

10. Repeat

    a.  Let _nextResult_ be the result of Invoke(_keys_, "NEXT").

    b.  ReturnIfAbrupt(_nextResult_).

    c.  If Type(_nextResult_) is not Object, then throw a TYPEERROR
        exception.

    d.  Let _done_ be IteratorComplete(_nextResult_).

    e.  ReturnIfAbrupt(_done_).

    f.  If _done_ is TRUE, then return TRUE.

    g.  Let _nextValue_ be IteratorValue(_nextResult_);

    h.  ReturnIfAbrupt(_nextValue_).

    i.  Let _forEnv_ be the result of calling NewDeclarativeEnvironment
        passing _oldEnv_ as the argument.

    j.  For each element _name_ of the BoundNames of _ForBinding_ do

        i.  Call _forEnv_’s CreateMutableBinding concrete method with
            argument _name_.

    k.  Let _status_ be the result of performing Binding Initialisation
        for _ForBinding_ passing _value_ and _environment_ as the
        arguments.

    l.  ReturnIfAbrupt(_status_).

    m.  Set the running execution context’s LexicalEnvironment to
        _forEnv_.

    n.  Let _continue_ the result of performing ComprehensionEvaluation
        for _tail_ with argument _accumulator_.

    o.  Set the running execution context’s LexicalEnvironment to
        _oldEnv_.

    p.  ReturnIfAbrupt(_continue_).

_ComprehensionFor_ : IF ( _AssignmentExpression_ )

1.  Let _valueRef_ be the result of evaluating _AssignmentExpression_.

2.  Let _value_ be GetValue(_valueRef_).

3.  Let _boolValue_ be ToBoolean(_value_).

4.  ReturnIfAbrupt(_boolValue_).

5.  If _exprValue_ is TRUE, then

    a.  Return the result of performing ComprehensionEvaluation for
        _tail_ with argument _accumulator_.

6.  Else,

    a.  Return NormalCompletion(UNDEFINED).

1.  

1.  

RUNTIME SEMANTICS: EVALUATION

_ArrayComprehension_ : [ _Comprehension_ ]

1.  Let _array_ be the result of the abstract operation ArrayCreate with
    argument 0.

2.  Let _status_ be the result of performing ComprehensionEvaluation for
    _Compression_ with argument _array_.

3.  ReturnIfAbrupt(_status_).

4.  Return _array_.

11.1.5 Object Initialiser

NOTE 1 An object initialiser is an expression describing the
initialisation of an Object, written in a form resembling a literal. It
is a list of zero or more pairs of property names and associated values,
enclosed in curly braces. The values need not be literals; they are
evaluated each time the object initialiser is evaluated.

Syntax

ObjectLiteral :

{ }
{ PropertyDefinitionList }
{ PropertyDefinitionList , }

PropertyDefinitionList :

PropertyDefinition
PropertyDefinitionList , PropertyDefinition

PropertyDefinition :

IdentifierName
CoverInitialisedName
PropertyName : AssignmentExpression
MethodDefinition

PropertyName :

IdentifierName
StringLiteral
NumericLiteral

CoverInitialisedName :

IdentifierName Initialiser

Initialiser :

= AssignmentExpression

NOTE 2 _MethodDefinition_ is defined in 13.3.

NOTE 3 In certain contexts, _ObjectLiteral_ is used as a cover grammar
for a more restricted secondary grammar. The _CoverInitialisedName_
production is necessary to fully cover these secondary grammars.
However, use of this production results in an early Syntax Error in
normal contexts where an actual _ObjectLiteral_ is expected.

Static Semantics

STATIC SEMANTICS: EARLY ERRORS

In addition to describing an actual object initialiser the
_ObjectLiteral_ productions are also used as a cover grammar for
_ObjectAssignmentPattern_ (11.13.1). When _ObjectLiteral_ appears in a
context where _ObjectAssignmentPattern_ is required, the following Early
Error rules are NOT applied.

_ObjectLiteral_ : { _PropertyDefinitionList_ }

and

_ObjectLiteral_ : { _PropertyDefinitionList_ , }

-   It is a Syntax Error if PropertyNameList of _PropertyDefinitionList_
    contains any duplicate entries, unless one of the following
    conditions are true for each duplicate entry:

    1.  The source code corresponding to _PropertyDefinitionList_ is not
        strict code and all occurrences in the list of the duplicated
        entry were obtained from productions of the form
        _PropertyDefinition_ : _PropertyName_ : _AssignmentExpression_.

    2.  The duplicated entry occurs exactly twice in the list and one
        occurrence was obtained from a GET accessor _MethodDefinition_
        and the other occurrence was obtained from a SET accessor
        _MethodDefinition_.

_PropertyDefinition_ : _MethodDefinition

-   It is a Syntax Error if ReferencesSuper of _MethodDefinition_ is
    TRUE.

_PropertyDefinition_ : _IdentifierName

-   It is a Syntax Error if _IdentifierName_ is a _ReservedWord_.

_PropertyDefinition_ : _CoverInitialisedName

-   Always throw a Syntax Error if this production is present

NOTE This production exists so that _ObjectLiteral_ can serve as a cover
grammar for _ObjectAssignmentPattern_ (11.13.1). It cannot occur in an
actual object initialiser.

-   -   -   -   -   -   -   -   -   -   -   -   -   -   

-   -   

-   -   -   -   -   -   

1.  

1.  

STATIC SEMANTICS: CONTAINS

  ith parameter _symbol_.

_PropertyDefinition_ : _MethodDefinition

1.  If _symbol_ is MethodDefinition, return TRUE.

2.  Return FALSE.

NOTE Static semantic rules that depend upon substructure generally do
not look into function definitions.

_PropertyName_ : _IdentifierName

1.  If _symbol_ is a _ReservedWord_, return FALSE.

2.  If _symbol_ is an _Identifier_ and StringValue of _symbol_ is the
    same value as the StringValue of _IdentifierName_, return TRUE;

3.  Return FALSE.

STATIC SEMANTICS: ISVALIDSIMPLEASSIGNMENTTARGET

_PrimaryExpression_ : _Literal

1.  Return FALSE.

1.  

1.  

1.  

1.  

1.  2.  

1.  2.  a.  

3.  

STATIC SEMANTICS: PROPNAME

_PropertyDefinition_ : _IdentifierName

1.  Return StringValue of _IdentifierName_.

_PropertyDefinition_ : _PropertyName_ : _AssignmentExpression

1.  Return PropName of _PropertyName_.

1.  

1.  

1.  

1.  

1.  

1.  

_PropertyName_ : _StringLiteral

1.  Return a String value whose characters are the SV of the
    _StringLiteral_.

_PropertyName_ : _NumericLiteral

1.  Let _nbr_ be the result of forming the value of the
    _NumericLiteral_.

2.  Return ToString(_nbr_).

STATIC SEMANTICS: PROPERTYNAMELIST

_PropertyDefinitionList_ : _PropertyDefinition

1.  Return a new List containing PropName of _PropertyDefinition_.

_PropertyDefinitionList_ : _PropertyDefinitionList_ ,
_PropertyDefinition

1.  Let _list_ be PropertyNameList of _PropertyDefinitionList_.

2.  Append PropName of _PropertyDefinition_ to the end of _list_.

3.  Return _list_.

Runtime Semantics

RUNTIME SEMANTICS: EVALUATION

_ObjectLiteral_ : { }

1.  Return a new object created as if by the expression NEW OBJECT()
    where OBJECT is the standard built-in constructor with that name.

ObjectLiteral :

  { _PropertyDefinitionList_ }_
  _{ _PropertyDefinitionList_ , }

1.  Let _obj_ be the result of the abstract operation ObjectCreate with
    the intrinsic object %ObjectPrototype% as its argument.

2.  Let _status_ be the result of performing Property Definition
    Evaluation of _PropertyDefinitionList_ with argument _obj_.

3.  ReturnIfAbrupt(_status_).

4.  Return _obj_.

RUNTIME SEMANTICS: PROPERTY DEFINITION EVALUATION

  With parameter _object_ and optional parameter _functionPrototype_.

1.  2.  3.  4.  

_PropertyDefinitionList_ : _PropertyDefinitionList_ ,
_PropertyDefinition

_PropertyDefinition_ : _IdentifierName

1.  Let _propName_ be StringValue of _IdentifierName_.

2.  Let _exprValue_ be the result of performing Identifier Resolution as
    specified in 10.3.1 using _IdentifierName_.

3.  Let _propValue_ be GetValue(_exprValue_).

4.  ReturnIfAbrupt(_propValue_).

5.  Let _desc_ be the Property Descriptor{[[Value]]: _propValue_,
    [[Writable]]: TRUE, [[Enumerable]]: TRUE, [[Configurable]]: TRUE}

6.  Return the result of DefinePropertyOrThrow(_object_, _propName_,
    _desc_).

7.  

_PropertyDefinition_ : _PropertyName_ : _AssignmentExpression

1.  Let _propName_ be PropName of _PropertyName_.

2.  Let _exprValue_ be the result of evaluating _AssignmentExpression_.

3.  Let _propValue_ be GetValue(_exprValue_).

4.  ReturnIfAbrupt(_propValue_).

5.  Let _desc_ be the Property Descriptor{[[Value]]: _propValue_,
    [[Writable]]: TRUE, [[Enumerable]]: TRUE, [[Configurable]]: TRUE}

6.  Return the result of DefinePropertyOrThrow(_object_, _propName_,
    _desc_).

11.1.6 Function Defining Expressions

See 13.1 for _PrimaryExpression_ : _FunctionExpression_.

See 13.4 for _PrimaryExpression_ : _GeneratorExpression_.

See 13.5 for _PrimaryExpression_ : _ClassExpression_.

11.1.7 Generator Comprehensions

Syntax

GeneratorComprehension :

( Comprehension )

Static Semantics

STATIC SEMANTICS: EARLY ERRORS

_GeneratorComprehension_ : ( _Comprehension_ )

-   It is a Syntax Error if _Comprehension_ Contains _YieldExpression_
    is TRUE.

Runtime Semantics

RUNTIME SEMANTICS: EVALUATION

_GeneratorComprehension_ : ( _Comprehension_ )

1.  If _GeneratorComprehension_ is contained in strict mode code, then
    let _strict_ be TRUE; otherwise let _strict_ be FALSE.

2.  Let _scope_ be the LexicalEnvironment of the running execution
    context.

3.  Let _parameters_ be the production: _FormalParameters_ : [empty].

4.  Using _Comprehension_ from the production that is being evaluated,
    let _body_ be the supplemental syntactic grammar production:
    _GeneratorBody_ : _Comprehension_.

5.  Let _closure_ be the result of performing the
    GeneratorFunctionCreate abstract operation with arguments Arrow,
    _parameters_, _body, scope_, and _strict_.

6.  Let _prototype_ be the result of the abstract operation ObjectCreate
    with the intrinsic object %GeneratorPrototype% as its argument.

7.  Perform the abstract operation MakeConstructor with arguments
    _closure_, TRUE, and _prototype_.

8.  Let _iterator_ be the result of calling the [[Call]] internal method
    of _closure_ with UNDEFINED as _thisArgument_ and a empty List as
    _argumentsList_.

9.  Return _iterator_.

NOTE The GeneratorFunction object created in step 5 is not observable
from ECMAScript code so an implementation may choose to avoid its
allocation and initialization. In that case use other semantically
equivalent means must be used to allocate and initialize the _iterator_
object in step 8. In either case, the _prototype_ object created in step
6 must be created because it is potentially observable as the value of
the _iterator_ object’s [[Prototype]] internal data property.

11.1.8 Regular Expression Literals

Syntax

See 7.8.4.

STATIC SEMANTICS

STATIC SEMANTICS: EARLY ERRORS

_PrimaryExpression_ : RegularExpressionLiteral

-   It is a Syntax Error if BodyText of _RegularExpressionLiteral_
    cannot be recognised using the goal symbol _Pattern_ of the
    ECMAScript RegExp grammar specified in 15.10.

-   It is a Syntax Error if FlagText of _RegularExpressionLiteral_
    contains any character other than "G", "I", "M", "U", or "Y", or if
    it contains the same character more than once.

RUNTIME SEMANTICS

RUNTIME SEMANTICS: EVALUATION

_PrimaryExpression_ : RegularExpressionLiteral

1.  A regular expression literal evaluates to a value of the Object type
    that is an instance of the standard built-in constructor RegExp.
    This value is determined in two steps: first, the characters
    comprising the regular expression's _RegularExpressionBody_ and
    _RegularExpressionFlags_ production expansions are collected
    uninterpreted into two Strings Pattern and Flags, respectively. Then
    each time the literal is evaluated, a new object is created as if by
    the expression NEW REGEXP(Pattern, Flags) where RegExp is the
    standard built-in constructor with that name. The newly constructed
    object becomes the value of the _RegularExpressionLiteral_.

11.1.9 Template Literals 

Syntax

TemplateLiteral :

NoSubstitutionTemplate
TemplateHead _Expression_ [Lexical goal InputElementTemplateTail]
TemplateSpans

TemplateSpans :

TemplateTail
TemplateMiddleList [Lexical goal InputElementTemplateTail] TemplateTail

TemplateMiddleList :

TemplateMiddle _Expression_
TemplateMiddleList [Lexical goal InputElementTemplateTail]
TemplateMiddle _Expression_

STATIC SEMANTICS

STATIC SEMANTICS: TEMPLATESTRINGS

  With parameter _raw_.

_TemplateLiteral_ : _NoSubstitutionTemplate

1.  If _raw_ is FALSE, then

    a.  Let _string_ be the TV of _NoSubstitutionTemplate_.

2.  Else,

    a.  Let _string_ be the TRV of _NoSubstitutionTemplate_.

3.  Return a List containing the single element, _string_.

_TemplateLiteral_ : _TemplateHead Expression_ [Lexical goal
_InputElementTemplateTail_] _TemplateSpans

1.  If _raw_ is FALSE, then

    a.  Let _head_ be the TV of _TemplateHead_.

    b.  

2.  Else,

    a.  Let _head_ be the TRV of _TemplateHead_.

3.  Let _tail_ be TemplateStrings of _TemplateSpans_ with argument
    _raw_.

4.  Return a List containing _head_ followed by the element, in order of
    _tail_.

_TemplateSpans_ : _TemplateTail

1.  If _raw_ is FALSE, then

    a.  Let _tail_ be the TV of _TemplateTail_.

2.  Else,

    a.  Let _tail_ be the TRV of _TemplateTail_.

3.  Return a List containing the single element, _tail_.

_TemplateSpans_ : _TemplateMiddleList_ [Lexical goal
_InputElementTemplateTail_] _TemplateTail

1.  Let _middle_ be TemplateStrings of _TemplateMiddleList_ with
    argument _raw_.

2.  If _raw_ is FALSE, then

3.  a.  Let _tail_ be the TV of _TemplateTail_.

4.  Else,

    a.  b.  Let _tail_ be the TRV of _TemplateTail_.

5.  6.  Return a List containing the elements, in order, of _middle
    followed by _tail_.

_TemplateMiddleList_ : _TemplateMiddle Expression

1.  If _raw_ is FALSE, then

    a.  Let _string_ be the TV of _TemplateMiddle_.

2.  Else,

    a.  Let _string_ be the TRV of _TemplateMiddle_.

3.  Return a List containing the single element, _string_.

_TemplateMiddleList_ : _TemplateMiddleList_ [Lexical goal
_InputElementTemplateTail_] _TemplateMiddle Expression

1.  Let _front_ be TemplateStrings of _TemplateMiddleList_ with argument
    _raw_.

2.  If _raw_ is FALSE, then

    a.  Let _last_ be the TV of _TemplateMiddle_.

3.  Else,

    a.  Let _last_ be the TRV of _TemplateMiddle_.

4.  Append _last_ as the last element of the List _front_.

5.  Return _front_.

RUNTIME SEMANTICS

RUNTIME SEMANTICS: ARGUMENTLISTEVALUATION

_TemplateLiteral_ : _NoSubstitutionTemplate

1.  Let _siteObj_ be the result of the abstract operation
    GetTemplateCallSite passing this _TemplateLiteral_ production as the
    argument.

2.  Return a List containing the one element which is _siteObj_.

1.  2.  3.  4.  

_TemplateLiteral_ : _TemplateHead Expression_ [Lexical goal
_InputElementTemplateTail_] _TemplateSpans

1.  Let _siteObj_ be the result of the abstract operation
    GetTemplateCallSite passing this _TemplateLiteral_ production as the
    argument.

2.  Let _firstSub_ be the result of evaluating _Expression_.

3.  ReturnIfAbrupt(_firstSub_).

4.  Let _restSub_ be SubstitutionEvaluation of _TemplateSpans_.

5.  ReturnIfAbrupt(_restSub_).

6.  Assert, _restSub_ is a List.

7.  Return a List whose first element is _siteObj_, whose second
    elements is _firstSub_, and whose subsequent elements are the
    elements of _restSub_, in order. _restSub_ may contain no elements.

RUNTIME SEMANTICS: GETTEMPLATECALLSITE ABSTRACT OPERATION

The abstract operation GetTemplateCallSite is called with a grammar
production, _templateLiteral_, as an argument. It performs the following
steps:

1.  If a call site object for the source code corresponding to
    _templateLiteral_ has already been created by a previous call to
    this abstract operation, then return that call site object.

2.  Let _cookedStrings_ be TemplateStrings of _templateLiteral_ with
    argument FALSE.

3.  Let _rawStrings_ be TemplateStrings of _templateLiteral_ with
    argument TRUE.

4.  Let _count_ be the number of elements in the List _cookedStrings_.

5.  Let _siteObj_ be the result of the abstract operation ArrayCreate
    with argument _count_.

6.  Let _rawObj_ be the result of the abstract operation ArrayCreate
    with argument _count_.

7.  Let _index_ be 0.

8.  Repeat while _index_ < _count

    a.  Let _prop_ be ToString(_index_).

    b.  Let _cookedValue_ be the string value at 0-based position
        _index_ of the List _cookedStrings_.

    c.  Call the [[DefineOwnProperty]] internal method of _siteObj_ with
        arguments _prop_ and Property Descriptor {[[Value]]:
        _cookedValue_, [[Writable]]: FALSE, [[Configurable]]: FALSE}_._

    d.  Let _rawValue_ be the string value at 0-based position _index_
        of the List _rawStrings_.

    e.  Call the [[DefineOwnProperty]] internal method of _rawObj_ with
        arguments _prop_ and Property Descriptor {[[Value]]: _rawValue_,
        [[Writable]]: FALSE, [[Configurable]]: FALSE}_._

    f.  Let _index_ be _index_+1.

9.  Call the [[Freeze]] internal method of _rawObj_.

10. Call the [[DefineOwnProperty]] internal method of _siteObj_ with
    arguments "RAW" and Property Descriptor {[[Value]]: _rawObj_,
    [[Writable]]: FALSE, [[Enumerable]]: FALSE, [[Configurable]]:
    FALSE}_._

11. Call the [[Freeze]] internal method of _siteObj_.

12. Remember an association between the source code corresponding to
    _templateLiteral_ and _siteObj_ such that _siteObj_ can be retrieve
    in subsequent calls to this abstract operation.

13. Return _siteObj_.

NOTE 1 The creation of a call site object cannot result in an abrupt
completion.

NOTE 2 Each _TemplateLiteral_ in the program code is associated with a
unique Template call site object that is used in the evaluation of
tagged Templates (11.2.6). The same call site object is used each time a
specific tagged Template is evaluated. Whether call site objects are
created lazily upon first evaluation of the _TemplateLiteral_ or eagerly
prior to first evaluation is an implementation choice that is not
observable to ECMAScript code.

RUNTIME SEMANTICS: SUBSTITUTIONEVALUATION

_TemplateSpans_ : _TemplateTail

1.  Return an empty List.

_TemplateSpans_ : _TemplateMiddleList_ [Lexical goal
_InputElementTemplateTail_] _TemplateTail

1.  Return the result of SubstitutionEvaluation of _TemplateMiddleList_.

_TemplateMiddleList_ : _TemplateMiddle Expression

1.  Let _sub_ be the result of evaluating _Expression_.

2.  ReturnIfAbrupt(_sub_).

3.  Return a List containing only _sub_.

_TemplateMiddleList_ : _TemplateMiddleList_ [Lexical goal
_InputElementTemplateTail_] _TemplateMiddle Expression

1.  Let _preceeding_ be the result of SubstitutionEvaluation of
    _TemplateMiddleList_ .

2.  ReturnIfAbrupt(_preceeding_).

3.  Let _next_ be the result of evaluating _Expression_.

4.  ReturnIfAbrupt(_next_).

5.  Append _next_ as the last element of the List _preceeding_.

6.  Return _preceeding_.

RUNTIME SEMANTICS: EVALUATION

_TemplateLiteral_ : _NoSubstitutionTemplate

1.  Return the string value whose elements are the TV of
    _NoSubstitutionTemplate_ as defined in 7.8.5.

_TemplateLiteral_ : _TemplateHead_ _Expression_ [Lexical goal
_InputElementTemplateTail_] _TemplateSpans

1.  Let _head_ be the TV of _TemplateHead_ as defined in 7.8.5.

2.  Let _sub_ be the result of evaluating _Expression_.

3.  Let _middle_ be ToString(_sub_).

4.  ReturnIfAbrupt(_middle_).

5.  Let _tail_ be the result of evaluating _TemplateSpans_ .

6.  ReturnIfAbrupt(_tail_).

7.  8.  Return the string value whose elements are the code units of
    _head_ followed by the code units of _tail_.

_TemplateSpans_ : _TemplateTail

1.  Let _tail_ be the TV of _TemplateTail_ as defined in 7.8.5.

2.  Return the string whose elements are the code units of _tail_.

_TemplateSpans_ : _TemplateMiddleList_ [Lexical goal
_InputElementTemplateTail_] _TemplateTail

1.  2.  3.  4.  5.  

1.  Let _head_ be the result of evaluating _TemplateMiddleList_.

2.  ReturnIfAbrupt(_head_).

3.  Let _tail_ be the TV of _TemplateTail_ as defined in 7.8.5.

4.  Return the string whose elements are the elements of _head_ followed
    by the elements of _tail_.

_TemplateMiddleList_ : _TemplateMiddle Expression

1.  Let _head_ be the TV of _TemplateMiddle_ as defined in 7.8.5.

2.  Let _sub_ be the result of evaluating _Expression_.

3.  Let _middle_ be ToString(_sub_).

4.  ReturnIfAbrupt(_middle_).

5.  Return the sequence of characters consisting of the code units of
    _head_ followed by the elements of _middle_.

_TemplateMiddleList_ : _TemplateMiddleList_ [Lexical goal
_InputElementTemplateTail_] _TemplateMiddle Expression

1.  Let _rest_ be the result of evaluating _TemplateMiddleList_ .

2.  ReturnIfAbrupt(_rest_).

3.  Let _middle_ be the TV of _TemplateMiddle_ as defined in 7.8.5.

4.  Let _sub_ be the result of evaluating _Expression_.

5.  Let _last_ be ToString(_sub_).

6.  ReturnIfAbrupt(_last_).

7.  Return the sequence of characters consisting of the elements of
    _rest_ followed by the code units of _middle_ followed by the
    elements of _last_.

11.1.10 The Grouping Operator

STATIC SEMANTICS: EARLY ERRORS

_PrimaryExpression_ : _CoverParenthesisedExpressionAndArrowParameterList
_

-   It is a Syntax Error if the lexical token sequence matched by
    _CoverParenthesisedExpressionAndArrowParameterList_ cannot be parsed
    with no tokens left over using _ParenthesisedExpression_ as the goal
    symbol.

-   All Early Errors rules for _ParenthesisedExpression_ and its derived
    productions also apply to the CoveredParenthesisedExpression of
    _CoverParenthesisedExpressionAndArrowParameterList_.

STATIC SEMANTICS: ISVALIDSIMPLEASSIGNMENTTARGET

_PrimaryExpression_ :
_CoverParenthesisedExpressionAndArrowParameterList

1.  Let _expr_ be CoveredParenthesisedExpression of
    _CoverParenthesisedExpressionAndArrowParameterList_.

2.  Return IsValidSimpleAssignmentTarget of _expr_.

_ParenthesisedExpression_ : ( _Expression_ )

1.  Return IsValidSimpleAssignmentTarget of _Expression_.

RUNTIME SEMANTICS: EVALUATION

_PrimaryExpression_ :
_CoverParenthesisedExpressionAndArrowParameterList

1.  Let _expr_ be CoveredParenthesisedExpression of
    _CoverParenthesisedExpressionAndArrowParameterList_.

2.  Return the result of evaluating _expr_.

_ParenthesisedExpression_ : ( _Expression_ )

1.  Return the result of evaluating _Expression_. This may be of type
    Reference.

NOTE This algorithm does not apply GetValue to the result of evaluating
_Expression_. The principal motivation for this is so that operators
such as DELETE and TYPEOF may be applied to parenthesised expressions.


11.2 Left-Hand-Side Expressions

Syntax

MemberExpression :

[Lexical goal InputElementRegExp] PrimaryExpression
MemberExpression [ Expression ]
MemberExpression . IdentifierName
MemberExpression TemplateLiteral
SUPER [ Expression ]
SUPER . IdentifierName
NEW SUPER Arguments~opt~
NEW MemberExpression Arguments

NewExpression :

MemberExpression
NEW NewExpression

CallExpression :

MemberExpression Arguments
SUPER Arguments
CallExpression Arguments
CallExpression [ Expression ]
CallExpression . IdentifierName
CallExpression TemplateLiteral

Arguments :

( )
( ArgumentList )

ArgumentList :

AssignmentExpression
... AssignmentExpression
ArgumentList , AssignmentExpression
ArgumentList , ... AssignmentExpression

LeftHandSideExpression :

NewExpression
CallExpression

STATIC SEMANTICS

STATIC SEMANTICS: CONTAINS

  With parameter _symbol_.

_MemberExpression_ : _MemberExpression_ . _IdentifierName

1.  If _MemberExpression_ Contains _symbol_ is TRUE, return TRUE.

2.  If _symbol_ is a _ReservedWord_, return FALSE.

3.  If _symbol_ is an _Identifier_ and StringValue of _symbol_ is the
    same value as the StringValue of _IdentifierName_, return TRUE;

4.  Return FALSE.

_MemberExpression_ : SUPER . _IdentifierName

1.  If _symbol_ is the _ReservedWord_ SUPER, return TRUE.

2.  If _symbol_ is a _ReservedWord_, return FALSE.

3.  If _symbol_ is an _Identifier_ and StringValue of _symbol_ is the
    same value as the StringValue of _IdentifierName_, return TRUE;

4.  Return FALSE.

_CallExpression_ : _CallExpression_ . _IdentifierName

1.  If _CallExpression_ Contains _symbol_ is TRUE, return TRUE.

2.  If _symbol_ is a _ReservedWord_, return FALSE.

3.  If _symbol_ is an _Identifier_ and StringValue of _symbol_ is the
    same value as the StringValue of _IdentifierName_, return TRUE;

4.  Return FALSE.

_MemberExpression_ : NEW SUPER

1.  If _symbol_ is the _ReservedWord_ SUPER, return TRUE.

2.  If _symbol_ is the _ReservedWord_ NEW, return TRUE.

3.  Return FALSE.

_MemberExpression_ : NEW SUPER _Arguments

1.  If _symbol_ is the _ReservedWord_ SUPER, return TRUE.

2.  If _symbol_ is the _ReservedWord_ NEW, return TRUE.

3.  Return the result of _Arguments_ Contains _symbol_.

1.  a.  

2.  3.  

1.  

STATIC SEMANTICS: ISVALIDSIMPLEASSIGNMENTTARGET

CallExpression :

CallExpression [ Expression ]
CallExpression . IdentifierName

MemberExpression :

MemberExpression [ Expression ]
MemberExpression . IdentifierName
SUPER [ Expression ]
SUPER . IdentifierName

1.  Return TRUE.

CallExpression :

MemberExpression Arguments
SUPER Arguments
CallExpression Arguments
CallExpression TemplateLiteral

NewExpression : NEW NewExpression

MemberExpression :

NEW SUPER Arguments~opt~
NEW MemberExpression Arguments

1.  Return FALSE.

11.2.1 Property Accessors

Properties are accessed by name, using either the dot notation:

MemberExpression . IdentifierName
CallExpression . IdentifierName

or the bracket notation:

MemberExpression [ Expression ]
CallExpression [ Expression ]

The dot notation is explained by the following syntactic conversion:

MemberExpression . IdentifierName

is identical in its behaviour to

MemberExpression [ <identifier-name-string> ]

and similarly

CallExpression . IdentifierName

is identical in its behaviour to

CallExpression [ <identifier-name-string> ]

where _<identifier-name-string>_ is a string literal containing the same
sequence of characters after processing of Unicode escape sequences as
the _IdentifierName_.

RUNTIME SEMANTICS: EVALUATION

_MemberExpression_ : _MemberExpression_ [ _Expression_ ]

1.  Let _baseReference_ be the result of evaluating _MemberExpression_.

2.  Let _baseValue_ be GetValue(_baseReference_).

3.  ReturnIfAbrupt(_baseValue_).

4.  Let _propertyNameReference_ be the result of evaluating
    _Expression_.

5.  Let _propertyNameValue_ be GetValue(_propertyNameReference_).

6.  ReturnIfAbrupt(_propertyNameValue_).

7.  Let _bv_ be CheckObjectCoercible(_baseValue_).

8.  ReturnIfAbrupt(_bv_).

9.  Let _propertyNameString_ be ToString(_propertyNameValue_).

10. If the code matched by the syntactic production that is being
    evaluated is strict mode code, let _strict_ be TRUE, else let
    _strict_ be FALSE.

11. Return a value of type Reference whose base value is _bv_ and whose
    referenced name is _propertyNameString_, and whose strict reference
    flag is _strict_.

_CallExpression_ : _CallExpression_ [ _Expression_ ]

Is evaluated in exactly the same manner as _MemberExpression_ :
_MemberExpression_ [ _Expression_ ] except that the contained
_CallExpression_ is evaluated in step 1.

11.2.2 The new Operator

RUNTIME SEMANTICS: EVALUATION

_NewExpression_ : NEW _NewExpression

1.  Let _ref_ be the result of evaluating _NewExpression_.

2.  Let _constructor_ be GetValue(_ref_).

3.  ReturnIfAbrupt(_constructor_).

4.  If Type(_constructor_) is not Object, throw a TYPEERROR exception.

5.  If _constructor_ does not implement the [[Construct]] internal
    method, throw a TYPEERROR exception.

6.  Return the result of calling the [[Construct]] internal method on
    _constructor_ with an empty List as the argument.

_MemberExpression_ : NEW _MemberExpression_ _Arguments

1.  Let _ref_ be the result of evaluating _MemberExpression_.

2.  Let _constructor_ be GetValue(_ref_).

3.  ReturnIfAbrupt(_constructor_).

4.  Let _argList_ be the result of evaluating _Arguments_, producing an
    internal List of argument values (11.2.4).

5.  ReturnIfAbrupt(_argList_).

6.  If Type(_constructor_) is not Object, throw a TYPEERROR exception.

7.  If _constructor_ does not implement the [[Construct]] internal
    method, throw a TYPEERROR exception.

8.  Return the result of calling the [[Construct]] internal method on
    _constructor_, passing _argList_ as the argument.

11.2.3 Function Calls

RUNTIME SEMANTICS: EVALUATION

_CallExpression_ : _MemberExpression_ _Arguments

1.  Let _ref_ be the result of evaluating _MemberExpression_.

2.  If this _CallExpression_ is in a tail position (13.6) then let
    _tailCall_ be TRUE, otherwise let _tailCall_ be FALSE.

3.  Return the result of the abstract operation EvaluateCall with
    arguments _ref_, _Arguments_, and _tailCall_.

_CallExpression_ : _CallExpression_ _Arguments

1.  Let _ref_ be the result of evaluating _CallExpression_.

2.  If this _CallExpression_ is in a tail position (13.6) then let
    _tailCall_ be TRUE, otherwise let _tailCall_ be FALSE.

3.  Return the result of the abstract operation EvaluateCall with
    arguments _ref_, _Arguments_, and _tailCall_.

A tail position call must either release any transient internal
resources associated with the currently executing function execution
context before invoking the target function or reuse those resources in
support of the target function.

NOTE 1 For example, a tail position call should only grow an
implementation’s activication record stack by the amount that the size
of the target function’s activation record exceeds the size of the
calling function’s activation record. If the target function’s
activation record is smaller, then the total size of the stack should
decrease.

RUNTIME SEMANTICS: EVALUATECALL ABSTRACT OPERATION

The abstract operation EvaluateCall takes as arguments a value _ref_,
and a syntactic grammar production _arguments_, and a Boolean argument
_tailPosition_. It performs the following steps:

1.  2.  Let _func_ be GetValue(_ref_).

3.  ReturnIfAbrupt(_func_).

4.  Let _argList_ be the result of performing ArgumentListEvaluation of
    _arguments_.

5.  ReturnIfAbrupt(_argList_).

6.  If Type(_func_) is not Object, throw a TYPEERROR exception.

7.  If IsCallable(_func_) is FALSE, throw a TYPEERROR exception.

8.  If Type(_ref_) is Reference, then

    a.  If IsPropertyReference(_ref_) is TRUE, then

        i.  Let _thisValue_ be GetThisValue(_ref_).

    b.  Else, the base of _ref_ is an Environment Record

        i.  Let _thisValue_ be the result of calling the WithBaseObject
            concrete method of GetBase(_ref_).

9.  Else Type(_ref_) is not Reference,

    a.  Let _thisValue_ be UNDEFINED.

10. If _tailPosition_ is TRUE, then

    a.  Let _leafContext_ be the running execution context.

    b.  c.  Suspend _leafContext_.

    d.  Pop _leafContext_ from the execution context stack. The
        execution context now on the top of the stack becomes the
        running execution context, however it remains in its suspended
        state.

    e.  Assert: _leafContext_ has no further use. It will never be
        activated as the running execution context.

11. Let _result_ be the result of calling the [[Call]] internal method
    on _func_, passing _thisValue_ as the _thisArgument_ and _argList_
    as the _argumentsList_.

12. Assert: If _tailPosition_ is TRUE, the above call will not return
    here, but instead evaluation will continue with the resumption of
    _leafCallerContext_ as the running execution context.

13. Assert: Type(_result_) is an ECMAScript language type

14. Return _result_.

11.2.4 The super Keyword

STATIC SEMANTICS

STATIC SEMANTICS: EARLY ERRORS

MemberExpression :

SUPER [ Expression ]
SUPER . IdentifierName
NEW SUPER Arguments~opt~

-   -   

-   

_CallExpression_ : SUPER _Arguments

-   It is a Syntax Error if the source code parsed with this production
    is global code that is not eval code.

-   It is a Syntax Error if the source code parsed with this production
    is eval code and the source code is not being processed by a direct
    call to eval that is contained in function code.

-   

RUNTIME SEMANTICS: EVALUATION

_MemberExpression_ : SUPER [ _Expression_ ]

1.  2.  3.  4.  5.  6.  7.  Let _propertyNameReference_ be the result of
    evaluating _Expression_.

8.  Let _propertyNameValue_ be GetValue(_propertyNameReference_).

9.  10. Let _propertyKey_ be ToPropertyKey(_propertyNameValue_).

11. If the code matched by the syntactic production that is being
    evaluated is strict mode code, let _strict_ be TRUE, else let
    _strict_ be FALSE.

12. Return the result of MakeSuperReference(_propertyKey_, _strict_).

_MemberExpression_ : SUPER . _IdentifierName

1.  2.  3.  4.  5.  6.  Let _propertyKey_ be StringValue of
    _IdentifierName_.

7.  If the code matched by the syntactic production that is being
    evaluated is strict mode code, let _strict_ be TRUE, else let
    _strict_ be FALSE.

8.  Return the result of MakeSuperReference(_propertyKey_, _strict_).

_MemberExpression_ : NEW SUPER _Arguments_~opt~

1.  If the code matched by the syntactic production that is being
    evaluated is strict mode code, let _strict_ be TRUE, else let
    _strict_ be FALSE.

2.  Let _ref_ be the result of MakeSuperReference(UNDEFINED, _strict_).

3.  Let _constructor_ be GetValue(_ref_).

4.  ReturnIfAbrupt(_constructor_).

5.  If _Arguments_ is present, then

    a.  Let _argList_ be the result of evaluating _Arguments_, producing
        an internal List of argument values (11.2.4).

    b.  ReturnIfAbrupt(_argList_).

6.  Else,

    a.  Let _argList_ be a new empty List.

7.  If Type(_constructor_) is not Object, throw a TYPEERROR exception.

8.  If _constructor_ does not implement the [[Construct]] internal
    method, throw a TYPEERROR exception.

9.  Return the result of calling the [[Construct]] internal method on
    _constructor_, passing _argList_ as the argument.

_CallExpression_ : SUPER _Arguments

1.  2.  3.  4.  5.  6.  7.  If the code matched by the syntactic
    production that is being evaluated is strict mode code, let _strict_
    be TRUE, else let _strict_ be FALSE.

8.  Let _ref_ be the result of MakeSuperReference(UNDEFINED, _strict_).

9.  ReturnIfAbrupt(_ref_).

10. If this _CallExpression_ is in a tail position (13.7) then let
    _tailCall_ be TRUE, otherwise let _tailCall_ be FALSE.

11. Return the result of the abstract operation EvaluateCall with
    arguments _ref_, _Arguments_, and _tailCall_.

RUNTIME SEMANTICS: ABSTRACT OPERATION MAKESUPERREFERENCE(PROPERTYKEY,
STRICT)

1.  Let _env_ be the result of performing the GetThisEnvironment
    abstract operation.

2.  If the result of calling the HasSuperBinding concrete method of
    _env_ is FALSE, then throw a REFERENCEERROR exception.

3.  Let _actualThis_ be the result of calling the GetThisBinding
    concrete method of _env_.

4.  Let _baseValue_ be the result of calling the GetSuperBase concrete
    method of _env_.

5.  Let _bv_ be CheckObjectCoercible(_baseValue_).

6.  ReturnIfAbrupt(_bv_).

7.  If _propertyKey_ is UNDEFINED, then

    a.  Let _propertyKey_ be the result of calling the GetMethodName
        concrete method of _env_.

8.  Return a value of type Reference that is a Super Reference whose
    base value is _bv_, whose referenced name is _propertyKey_, whose
    thisValue is _actualThis_, and whose strict reference flag is
    _strict_.

11.2.5 Argument Lists

The evaluation of an argument list produces a List of values (see 8.7).

Runtime Semantics

RUNTIME SEMANTICS: ARGUMENTLISTEVALUATION

_Arguments_ : ( )

1.  Return an empty List.

1.  

_ArgumentList_ : _AssignmentExpression

1.  Let _ref_ be the result of evaluating _AssignmentExpression_.

2.  Let _arg_ be GetValue(_ref_).

3.  ReturnIfAbrupt(_arg_).

4.  Return a List whose sole item is _arg_.

_ArgumentList_ : _..._ _AssignmentExpression

1.  Let _list_ be an empty List.

2.  Let _spreadRef_ be the result of evaluating _AssignmentExpression_.

3.  Let _spreadValue_ be GetValue(_spreadRef_).

4.  Let _spreadObj_ be ToObject(_spreadValue_).

5.  ReturnIfAbrupt(_spreadObj_).

6.  Let _lenVal_ be the result of calling Get(_spreadObj_, "LENGTH").

7.  Let _spreadLen_ be ToUint32(_lenVal_).

8.  ReturnIfAbrupt(_spreadLen_).

9.  Let _n_ = 0.

10. Repeat, while _n_ < _spreadLen

    a.  Let _nextArg_ be the result of calling Get(_spreadObj_,
          ToString(_n_)).

    b.  ReturnIfAbrupt(_nextArg_).

    c.  Append _nextArg_ as the last element of _list_.

    d.  Let _n_ = _n_+1.

11. Return _list_.

_ArgumentList_ : _ArgumentList_ , _AssignmentExpression

1.  Let _precedingArgs_ be the result of evaluating _ArgumentList_.

2.  ReturnIfAbrupt(_precedingArgs_).

3.  Let _ref_ be the result of evaluating _AssignmentExpression_.

4.  Let _arg_ be GetValue(_ref_).

5.  ReturnIfAbrupt(_arg_).

6.  Return a List whose length is one greater than the length of
    _precedingArgs_ and whose items are the items of _precedingArgs_, in
    order, followed at the end by _arg_ which is the last item of the
    new list.

_ArgumentList_ : _ArgumentList_ , _..._ _AssignmentExpression

1.  Let _precedingArgs_ be an empty List.

2.  Let _spreadRef_ be the result of evaluating _AssignmentExpression_.

3.  Let _spreadValue_ be GetValue(_spreadRef_).

4.  Let _spreadObj_ be ToObject(_spreadValue_).

5.  ReturnIfAbrupt(_spreadObj_).

6.  Let _lenVal_ be the result of calling Get(_spreadObj_, "LENGTH").

7.  Let _spreadLen_ be ToUint32(_lenVal_).

8.  ReturnIfAbrupt(_spreadLen_).

9.  Let _n_ = 0.

10. Repeat, while _n_ < _spreadLen

    a.  Let _nextArg_ be the result of calling Get(_spreadObj_,
          ToString(_n_)).

    b.  ReturnIfAbrupt(_nextArg_).

    c.  Append _nextArg_ as the last element of _precedingArgs_.

    d.  Let _n_ = _n_+1.

11. Return _precedingArgs_.

11.2.6 Tagged Templates

Runtime Semantics

RUNTIME SEMANTICS: EVALUATION

_MemberExpression_ : _MemberExpression TemplateLiteral

1.  Let _tagRef_ be the result of evaluating _MemberExpression_.

2.  If this _MemberExpression_ is in a tail position (13.7) then let
    _tailCall_ be TRUE, otherwise let _tailCall_ be FALSE.

3.  Return the result of the abstract operation EvaluateCall with
    arguments _tagRef_, _TemplateLiteral_, and _tailCall_.

_CallExpression_ : _CallExpression TemplateLiteral

1.  Let _tagRef_ be the result of evaluating _CallExpression_.

2.  If this _CallExpression_ is in a tail position (13.7) then let
    _tailCall_ be TRUE, otherwise let _tailCall_ be FALSE.

3.  Return the result of the abstract operation EvaluateCall with
    arguments _tagRef_, _TemplateLiteral_, and _tailCall_.


11.3 Postfix Expressions

Syntax

PostfixExpression :

LeftHandSideExpression
LeftHandSideExpression [no LineTerminator here] ++
LeftHandSideExpression [no LineTerminator here] --

STATIC SEMANTICS

STATIC SEMANTICS: EARLY ERRORS

-   -   

PostfixExpression :

LeftHandSideExpression [no LineTerminator here] ++
LeftHandSideExpression [no LineTerminator here] --

-   It is an early Reference Error if IsValidSimpleAssignmentTarget of
    _LeftHandSideExpression_ is FALSE.

-   -   -   

STATIC SEMANTICS: ISVALIDSIMPLEASSIGNMENTTARGET

PostfixExpression :

LeftHandSideExpression [no LineTerminator here] ++
LeftHandSideExpression [no LineTerminator here] --

1.  Return FALSE.

11.3.1 Postfix Increment Operator

RUNTIME SEMANTICS: EVALUATION

_PostfixExpression_ : _LeftHandSideExpression_ [no _LineTerminator
here] ++

1.  Let _lhs_ be the result of evaluating _LeftHandSideExpression_.

2.  

-   -   -   -   

1.  Let _oldValue_ be ToNumber(GetValue(_lhs_)).

2.  ReturnIfAbrupt(_oldValue_).

3.  Let _newValue_ be the result of adding the value 1 to _oldValue_,
    using the same rules as for the + operator (see 11.6.3).

4.  Let _status_ be PutValue(_lhs_, _newValue_).

5.  ReturnIfAbrupt(_status_).

6.  Return _oldValue_.

11.3.2 Postfix Decrement Operator

RUNTIME SEMANTICS: EVALUATION

_PostfixExpression_ : _LeftHandSideExpression_ [no _LineTerminator
here] --

1.  Let _lhs_ be the result of evaluating _LeftHandSideExpression_.

2.  

-   -   -   -   

1.  Let _oldValue_ be ToNumber(GetValue(_lhs_)).

2.  Let _newValue_ be the result of subtracting the value 1 from
    _oldValue_, using the same rules as for the - operator (11.6.3).

3.  Let _status_ be PutValue(_lhs_, _newValue_).

4.  ReturnIfAbrupt(_status_).

5.  Return _oldValue_.


11.4 Unary Operators

Syntax

UnaryExpression :

PostfixExpression
DELETE UnaryExpression
VOID UnaryExpression
TYPEOF UnaryExpression
++ UnaryExpression
-- UnaryExpression
+ UnaryExpression
- UnaryExpression
~ UnaryExpression
! UnaryExpression

STATIC SEMANTICS

STATIC SEMANTICS: EARLY ERRORS

-   -   -   -   -   

UnaryExpression :

++ UnaryExpression
-- UnaryExpression

-   It is an early Reference Error if IsValidSimpleAssignmentTarget of
    _UnaryExpression_ is FALSE.

STATIC SEMANTICS: ISVALIDSIMPLEASSIGNMENTTARGET

UnaryExpression :

DELETE UnaryExpression
VOID UnaryExpression
TYPEOF UnaryExpression
++ UnaryExpression
-- UnaryExpression
+ UnaryExpression
- UnaryExpression
~ UnaryExpression
! UnaryExpression

1.  Return FALSE.

11.4.1 The delete Operator

STATIC SEMANTICS: EARLY ERRORS

_UnaryExpression_ : DELETE _UnaryExpression

-   It is a Syntax Error if the _UnaryExpression_ is contained in strict
    code and the derived _UnaryExpression_ is _PrimaryExpression_ :
    _Identifier_.

-   It is a Syntax Error if the derived _UnaryExpression_ is
     _PrimaryExpression_ :
    _CoverParenthesisedExpressionAndArrowParameterList
    _and derives a production that is used in place of _UnaryExpression_
    would produce a Syntax Error according to these rules. This rule is
    recursively applied.

RUNTIME SEMANTICS: EVALUATION

_UnaryExpression_ : DELETE _UnaryExpression

1.  Let _ref_ be the result of evaluating _UnaryExpression_.

2.  ReturnIfAbrupt(_ref_).

3.  If Type(_ref_) is not Reference, return TRUE.

4.  If IsUnresolvableReference(_ref_) is TRUE, then,

    a.  If IsStrictReference(_ref_) is TRUE, then throw a SYNTAXERROR
        exception.

    b.  Return TRUE.

5.  If IsPropertyReference(_ref_) is TRUE, then

    a.  If IsSuperReference(_ref_), then throw a REFERENCEERROR
        exception.

    b.  Let _deleteStatus_ be the result of calling the [[Delete]]
        internal method on ToObject(GetBase(_ref)_), providing
        GetReferencedName(_ref_) as the argument.

    c.  ReturnIfAbrupt(_deleteStatus_).

    d.  If _deleteStatus_ is FALSE and IsStrictReference(_ref_) is TRUE,
        then throw a TYPEERROR exception.

    e.  Return _deleteStatus_.

6.  Else _ref_ is a Reference to an Environment Record binding,

    a.  b.  Let _bindings_ be GetBase(_ref_).

    c.  Return the result of calling the DeleteBinding concrete method
        of _bindings_, providing GetReferencedName(_ref_) as the
        argument.

NOTE When a DELETE operator occurs within strict mode code, a
SYNTAXERROR exception is thrown if its _UnaryExpression_ is a direct
reference to a variable, function argument, or function name. In
addition, if a DELETE operator occurs within strict mode code and the
property to be deleted has the attribute { [[Configurable]]: FALSE }, a
TYPEERROR exception is thrown.

11.4.2 The void Operator

RUNTIME SEMANTICS: EVALUATION

_UnaryExpression_ : VOID _UnaryExpression

1.  Let _expr_ be the result of evaluating _UnaryExpression_.

2.  Let _status_ be GetValue(_expr_).

3.  ReturnIfAbrupt(_status_).

4.  5.  Return UNDEFINED.

NOTE GetValue must be called even though its value is not used because
it may have observable side-effects.

11.4.3 The typeof Operator

RUNTIME SEMANTICS: EVALUATION

_UnaryExpression_ : TYPEOF _UnaryExpression

1.  Let _val_ be the result of evaluating _UnaryExpression_.

2.  If Type(_val_) is Reference, then

    a.  If IsUnresolvableReference(_val_) is TRUE, return "UNDEFINED".

    b.  Let _val_ be GetValue(_val_).

3.  ReturnIfAbrupt(_val_).

4.  Return a String determined by Type(_val_) according to TABLE 30 .

TABLE 30 — TYPEOF OPERATOR RESULTS

  -------------------------------------------------------------- ---------------------------------------------------------------------------------------------
  _TYPE OF val_                                                  _RESULT_
  Undefined                                                      "UNDEFINED"
  Null                                                           "OBJECT"
  Boolean                                                        "BOOLEAN"
  Number                                                         "NUMBER"
  String                                                         "STRING"
  Symbol                                                         "SYMBOL"
  Object (ordinary and does not implement [[Call]])              "OBJECT"
  Object (standard exotic and does not implement [[Call]])       "OBJECT"
  Object (implements [[Call]])                                   "FUNCTION"
  Object (non-standard exotic and does not implement [[Call]])   Implementation-defined. May not be "UNDEFINED", "BOOLEAN", "NUMBER", "SYMBOL", or "STRING".
  -------------------------------------------------------------- ---------------------------------------------------------------------------------------------

NOTE Implementations are discouraged from defining new TYPEOF result
values for non-standard exotic objects. If possible "OBJECT"should be
used for such objects.

11.4.4 Prefix Increment Operator

RUNTIME SEMANTICS: EVALUATION

_UnaryExpression_ : ++ _UnaryExpression

1.  Let _expr_ be the result of evaluating _UnaryExpression_.

2.  

-   -   -   -   

1.  Let _oldValue_ be ToNumber(GetValue(_expr_)).

2.  ReturnIfAbrupt(_oldValue_).

3.  Let _newValue_ be the result of adding the value 1 to _oldValue_,
    using the same rules as for the + operator (see 11.6.3).

4.  Let _status_ be PutValue(_expr_, _newValue_).

5.  ReturnIfAbrupt(_status_).

6.  Return _newValue_.

11.4.5 Prefix Decrement Operator

RUNTIME SEMANTICS: EVALUATION

_UnaryExpression_ : -- _UnaryExpression

1.  Let _expr_ be the result of evaluating _UnaryExpression_.

2.  

-   -   -   -   

1.  Let _oldValue_ be ToNumber(GetValue(_expr_)).

2.  ReturnIfAbrupt(_oldValue_).

3.  Let _newValue_ be the result of subtracting the value 1 from
    _oldValue_, using the same rules as for the - operator (see 11.6.3).

4.  Let _status_ be PutValue(_expr_, _newValue_).

5.  ReturnIfAbrupt(_status_).

6.  Return _newValue_.

11.4.6 Unary + Operator

NOTE The unary + operator converts its operand to Number type.

RUNTIME SEMANTICS: EVALUATION

_UnaryExpression_ : + _UnaryExpression

1.  Let _expr_ be the result of evaluating _UnaryExpression_.

2.  Return ToNumber(GetValue(_expr_)).

11.4.7 Unary - Operator

NOTE The unary - operator converts its operand to Number type and then
negates it. Negating +0 produces −0, and negating −0 produces +0.

RUNTIME SEMANTICS: EVALUATION

_UnaryExpression_ : - _UnaryExpression

1.  Let _expr_ be the result of evaluating _UnaryExpression_.

2.  Let _oldValue_ be ToNumber(GetValue(_expr_)).

3.  ReturnIfAbrupt(_oldValue_).

4.  If _oldValue_ is NAN, return NAN.

5.  Return the result of negating _oldValue_; that is, compute a Number
    with the same magnitude but opposite sign.

11.4.8 Bitwise NOT Operator ( ~ )

RUNTIME SEMANTICS: EVALUATION

_UnaryExpression_ : ~ _UnaryExpression

1.  Let _expr_ be the result of evaluating _UnaryExpression_.

2.  Let _oldValue_ be ToInt32(GetValue(_expr_)).

3.  ReturnIfAbrupt(_oldValue_).

4.  Return the result of applying bitwise complement to _oldValue_. The
    result is a signed 32-bit integer.

11.4.9 Logical NOT Operator ( ! )

RUNTIME SEMANTICS: EVALUATION

_UnaryExpression_ : ! _UnaryExpression

1.  Let _expr_ be the result of evaluating _UnaryExpression_.

2.  Let _oldValue_ be ToBoolean(GetValue(_expr_)).

3.  ReturnIfAbrupt(_oldValue_).

4.  If _oldValue_ is TRUE, return FALSE.

5.  Return TRUE.


11.5 Multiplicative Operators

Syntax

MultiplicativeExpression :

UnaryExpression
MultiplicativeExpression * UnaryExpression
MultiplicativeExpression / UnaryExpression
MultiplicativeExpression % UnaryExpression

STATIC SEMANTICS: ISVALIDSIMPLEASSIGNMENTTARGET

MultiplicativeExpression :

MultiplicativeExpression * UnaryExpression
MultiplicativeExpression / UnaryExpression
MultiplicativeExpression % UnaryExpression

1.  Return FALSE.

RUNTIME SEMANTICS: EVALUATION

The production _MultiplicativeExpression_ : _MultiplicativeExpression @
UnaryExpression_, where @ stands for one of the operators in the above
definitions, is evaluated as follows:

1.  Let _left_ be the result of evaluating _MultiplicativeExpression_.

2.  Let _leftValue_ be GetValue(_left_).

3.  ReturnIfAbrupt(_leftValue_).

4.  Let _right_ be the result of evaluating _UnaryExpression_.

5.  Let _rightValue_ be GetValue(_right_).

6.  Let _lnum_ be ToNumber(_leftValue_).

7.  ReturnIfAbrupt(_lnum_).

8.  Let _rnum_ be ToNumber(_rightValue_).

9.  ReturnIfAbrupt(_rnum_).

10. Return the result of applying the specified operation (*, /, or %)
    to _lnum_ and _rnum_. See the Notes below 11.5.1, 11.5.2, 11.5.3.

11.5.1 Applying the * Operator

The * operator performs multiplication, producing the product of its
operands. Multiplication is commutative. Multiplication is not always
associative in ECMAScript, because of finite precision.

The result of a floating-point multiplication is governed by the rules
of IEEE 754 binary double-precision arithmetic:

-   If either operand is NAN, the result is NAN.

-   The sign of the result is positive if both operands have the same
      sign, negative if the operands have different signs.

-   Multiplication of an infinity by a zero results in NAN.

-   Multiplication of an infinity by an infinity results in an infinity.
      The sign is determined by the rule already stated above.

-   Multiplication of an infinity by a finite nonzero value results in a
      signed infinity. The sign is determined by the rule already stated
      above.

-   In the remaining cases, where neither an infinity or NaN is
      involved, the product is computed and rounded to the nearest
      representable value using IEEE 754 round-to-nearest mode. If the
      magnitude is too large to represent, the result is then an
      infinity of appropriate sign. If the magnitude is too small to
      represent, the result is then a zero of appropriate sign. The
      ECMAScript language requires support of gradual underflow as
      defined by IEEE 754.

11.5.2 Applying the / Operator

The / operator performs division, producing the quotient of its
operands. The left operand is the dividend and the right operand is the
divisor. ECMAScript does not perform integer division. The operands and
result of all division operations are double-precision floating-point
numbers. The result of division is determined by the specification of
IEEE 754 arithmetic:

-   If either operand is NAN, the result is NAN.

-   The sign of the result is positive if both operands have the same
      sign, negative if the operands have different signs.

-   Division of an infinity by an infinity results in NAN.

-   Division of an infinity by a zero results in an infinity. The sign
      is determined by the rule already stated above.

-   Division of an infinity by a nonzero finite value results in a
      signed infinity. The sign is determined by the rule already stated
      above.

-   Division of a finite value by an infinity results in zero. The sign
      is determined by the rule already stated above.

-   Division of a zero by a zero results in NAN; division of zero by any
      other finite value results in zero, with the sign determined by
      the rule already stated above.

-   Division of a nonzero finite value by a zero results in a signed
      infinity. The sign is determined by the rule already stated above.

-   In the remaining cases, where neither an infinity, nor a zero, nor
      NAN is involved, the quotient is computed and rounded to the
      nearest representable value using IEEE 754 round-to-nearest mode.
      If the magnitude is too large to represent, the operation
      overflows; the result is then an infinity of appropriate sign. If
      the magnitude is too small to represent, the operation underflows
      and the result is a zero of the appropriate sign. The ECMAScript
      language requires support of gradual underflow as defined by IEEE
      754.

11.5.3 Applying the % Operator

The % operator yields the remainder of its operands from an implied
division; the left operand is the dividend and the right operand is the
divisor.

NOTE In C and C++, the remainder operator accepts only integral
operands; in ECMAScript, it also accepts floating-point operands.

The result of a floating-point remainder operation as computed by the %
operator is not the same as the “remainder” operation defined by IEEE
754. The IEEE 754 “remainder” operation computes the remainder from a
rounding division, not a truncating division, and so its behaviour is
not analogous to that of the usual integer remainder operator. Instead
the ECMAScript language defines % on floating-point operations to behave
in a manner analogous to that of the Java integer remainder operator;
this may be compared with the C library function fmod.

The result of an ECMAScript floating-point remainder operation is
determined by the rules of IEEE arithmetic:

-   If either operand is NAN, the result is NAN.

    -   The sign of the result equals the sign of the dividend.

    -   If the dividend is an infinity, or the divisor is a zero, or
          both, the result is NAN.

    -   If the dividend is finite and the divisor is an infinity, the
          result equals the dividend.

    -   If the dividend is a zero and the divisor is nonzero and finite,
          the result is the same as the dividend.

    -   In the remaining cases, where neither an infinity, nor a zero,
          nor NAN is involved, the floating-point remainder r from a
          dividend n and a divisor d is defined by the mathematical
          relation r = n − (d × q) where q is an integer that is
          negative only if n/d is negative and positive only if n/d is
          positive, and whose magnitude is as large as possible without
          exceeding the magnitude of the true mathematical quotient of n
          and d. r is computed and rounded to the nearest representable
          value using IEEE 754 round-to-nearest mode.


11.6 Additive Operators

Syntax

AdditiveExpression :

MultiplicativeExpression
AdditiveExpression + MultiplicativeExpression
AdditiveExpression - MultiplicativeExpression

STATIC SEMANTICS: ISVALIDSIMPLEASSIGNMENTTARGET

AdditiveExpression :

AdditiveExpression + MultiplicativeExpression
AdditiveExpression - MultiplicativeExpression

1.  Return FALSE.

11.6.1 The Addition operator ( + )

NOTE The addition operator either performs string concatenation or
numeric addition.

RUNTIME SEMANTICS: EVALUATION

_AdditiveExpression_ : _AdditiveExpression_ + _MultiplicativeExpression

NOTE 1 No hint is provided in the calls to ToPrimitive in steps 5 and 6.
All standard ECMAScript objects except Date objects handle the absence
of a hint as if the hint Number were given; Date objects handle the
absence of a hint as if the hint String were given. Exotic objects may
handle the absence of a hint in some other manner.

NOTE 2 Step 7 differs from step 3 of the comparison algorithm for the
relational operators (11.8.1), by using the logical-or operation instead
of the logical-and operation.

11.6.2 The Subtraction Operator ( - )

RUNTIME SEMANTICS: EVALUATION

_AdditiveExpression_ : _AdditiveExpression_ - _MultiplicativeExpression

11.6.3 Applying the Additive Operators to Numbers

The + operator performs addition when applied to two operands of numeric
type, producing the sum of the operands. The - operator performs
subtraction, producing the difference of two numeric operands.

Addition is a commutative operation, but not always associative.

The result of an addition is determined using the rules of IEEE 754
binary double-precision arithmetic:

-   If either operand is NAN, the result is NAN.

-   The sum of two infinities of opposite sign is NAN.

-   The sum of two infinities of the same sign is the infinity of that
      sign.

-   The sum of an infinity and a finite value is equal to the infinite
      operand.

-   The sum of two negative zeroes is −0. The sum of two positive
      zeroes, or of two zeroes of opposite sign, is +0.

-   The sum of a zero and a nonzero finite value is equal to the nonzero
      operand.

-   The sum of two nonzero finite values of the same magnitude and
      opposite sign is +0.

-   In the remaining cases, where neither an infinity, nor a zero, nor
      NaN is involved, and the operands have the same sign or have
      different magnitudes, the sum is computed and rounded to the
      nearest representable value using IEEE 754 round-to-nearest mode.
      If the magnitude is too large to represent, the operation
      overflows and the result is then an infinity of appropriate sign.
      The ECMAScript language requires support of gradual underflow as
      defined by IEEE 754.

The - operator performs subtraction when applied to two operands of
numeric type, producing the difference of its operands; the left operand
is the minuend and the right operand is the subtrahend. Given numeric
operands _a_ and _b_, it is always the case that _a–b_ produces the same
result as _a +(–b)_.


11.7 Bitwise Shift Operators

Syntax

ShiftExpression :

AdditiveExpression
ShiftExpression << AdditiveExpression
ShiftExpression >> AdditiveExpression
ShiftExpression >>> AdditiveExpression

STATIC SEMANTICS: ISVALIDSIMPLEASSIGNMENTTARGET

ShiftExpression :

ShiftExpression << AdditiveExpression
ShiftExpression >> AdditiveExpression
ShiftExpression >>> AdditiveExpression

1.  Return FALSE.

11.7.1 The Left Shift Operator ( << )

NOTE Performs a bitwise left shift operation on the left operand by the
amount specified by the right operand.

RUNTIME SEMANTICS: EVALUATION

_ShiftExpression_ : _ShiftExpression_ << _AdditiveExpression

11.7.2 The Signed Right Shift Operator ( >> )

NOTE Performs a sign-filling bitwise right shift operation on the left
operand by the amount specified by the right operand.

RUNTIME SEMANTICS: EVALUATION

_ShiftExpression_ : _ShiftExpression_ >> _AdditiveExpression

11.7.3 The Unsigned Right Shift Operator ( >>> )

NOTE Performs a zero-filling bitwise right shift operation on the left
operand by the amount specified by the right operand.

RUNTIME SEMANTICS: EVALUATION

_ShiftExpression_ : _ShiftExpression_ >>> _AdditiveExpression


11.8 Relational Operators

NOTE The result of evaluating a relational operator is always of type
Boolean, reflecting whether the relationship named by the operator holds
between its two operands.

Syntax

RelationalExpression :

ShiftExpression
RelationalExpression < ShiftExpression
RelationalExpression > ShiftExpression
RelationalExpression <= ShiftExpression
RelationalExpression >= ShiftExpression
RelationalExpression INSTANCEOF ShiftExpression
RelationalExpression IN ShiftExpression

RelationalExpressionNoIn :

ShiftExpression
RelationalExpressionNoIn < ShiftExpression
RelationalExpressionNoIn > ShiftExpression
RelationalExpressionNoIn <= ShiftExpression
RelationalExpressionNoIn >= ShiftExpression
RelationalExpressionNoIn INSTANCEOF ShiftExpression

The semantics of the _RelationalExpressionNoIn_ productions are the same
as the _RelationalExpression_ productions except that the contained
_RelationalExpressionNoIn_ is used in place of the contained
_RelationalExpression_.

NOTE The “NoIn” variants are needed to avoid confusing the in operator
in a relational expression with the in operator in a for statement.

STATIC SEMANTICS: ISVALIDSIMPLEASSIGNMENTTARGET

RelationalExpression :

RelationalExpression < ShiftExpression
RelationalExpression > ShiftExpression
RelationalExpression <= ShiftExpression
RelationalExpression >= ShiftExpression
RelationalExpression INSTANCEOF ShiftExpression
RelationalExpression IN ShiftExpression

1.  Return FALSE.

11.8.1 Runtime Semantics

RUNTIME SEMANTICS: THE ABSTRACT RELATIONAL COMPARISON ALGORITHM

The comparison _x_ < _y_, where _x_ and _y_ are values, produces TRUE,
FALSE, or UNDEFINED (which indicates that at least one operand is NAN).
In addition to _x_ and _y_ the algorithm takes a Boolean flag named
_LeftFirst_ as a parameter. The flag is used to control the order in
which operations with potentially visible side-effects are performed
upon _x_ and _y_. It is necessary because ECMAScript specifies left to
right evaluation of expressions. The default value of _LeftFirst_ is
TRUE and indicates that the _x_ parameter corresponds to an expression
that occurs to the left of the _y_ parameter’s corresponding expression.
If _LeftFirst_ is FALSE, the reverse is the case and operations must be
performed upon _y_ before _x_. Such a comparison is performed as
follows:

NOTE 1 Step 3 differs from step 7 in the algorithm for the addition
operator + (11.6.1) in using and instead of or.

NOTE 2 The comparison of Strings uses a simple lexicographic ordering on
sequences of code unit values. There is no attempt to use the more
complex, semantically oriented definitions of character or string
equality and collating order defined in the Unicode specification.
Therefore String values that are canonically equal according to the
Unicode standard could test as unequal. In effect this algorithm assumes
that both Strings are already in normalised form. Also, note that for
strings containing supplementary characters, lexicographic ordering on
sequences of UTF-16 code unit values differs from that on sequences of
code point values.

RUNTIME SEMANTICS: EVALUATION

_RelationalExpression_ : _RelationalExpression_ < _ShiftExpression

_RelationalExpression_ : _RelationalExpression_ > _ShiftExpression

_RelationalExpression_ : _RelationalExpression_ <= _ShiftExpression

_RelationalExpression_ : _RelationalExpression_ >= _ShiftExpression

_RelationalExpression_: _RelationalExpression_ INSTANCEOF
_ShiftExpression

The abstract operation instanceofOperator(_O_, _C_) implements the
generic algorithm for determining if an object _O_ inherits from the
inheritance path defined by constructor _C_. This abstract operation
performs the following steps:

1.  If Type(_C_) is not Object, throw a TYPEERROR exception.

2.  Let _instOfHandler_ be the result of GetMethod(_C_,@@hasInstance).

3.  ReturnIfAbrupt(_instOfHandler_).

4.  If _instOfHandler_ is not UNDEFINED, then

    a.  Let _result_ be the result of calling the [[Call]] internal
        method of _instOfHandler_ passing _C_ as _thisArgument_ and a
        new List containing _O_ as _argumentsList_.

    b.  Return ToBoolean(_result_).

5.  If IsCallable(_C_) is FALSE, then throw a TYPEERROR exception.

6.  Return the result of OrdinaryHasInstance(_C_, _O_).

NOTE Steps 5 and 6 provide compatibility with previous editions of
ECMAScript that did not use a @@hasInstance method to define the
INSTANCEOF operator semantics. If a function object does not define or
inherit @@hasInstance it uses the default INSTANCEOF semantics.

_RelationalExpression_ : _RelationalExpression_ IN _ShiftExpression


11.9 Equality Operators

NOTE The result of evaluating an equality operator is always of type
Boolean, reflecting whether the relationship named by the operator holds
between its two operands.

Syntax

EqualityExpression :

RelationalExpression
EqualityExpression == RelationalExpression
EqualityExpression != RelationalExpression
EqualityExpression === RelationalExpression
EqualityExpression !== RelationalExpression

EqualityExpressionNoIn :

RelationalExpressionNoIn
EqualityExpressionNoIn == RelationalExpressionNoIn
EqualityExpressionNoIn != RelationalExpressionNoIn
EqualityExpressionNoIn === RelationalExpressionNoIn
EqualityExpressionNoIn !== RelationalExpressionNoIn

The semantics of the _EqualityExpressionNoIn_ productions are the same
as the _EqualityExpression_ productions except that the contained
_EqualityExpressionNoIn_ and _RelationalExpressionNoIn_ are used in
place of the contained _EqualityExpression_ and _RelationalExpression_,
respectively.

STATIC SEMANTICS: ISVALIDSIMPLEASSIGNMENTTARGET

EqualityExpression :

EqualityExpression == RelationalExpression
EqualityExpression != RelationalExpression
EqualityExpression === RelationalExpression
EqualityExpression !== RelationalExpression

1.  Return FALSE.

11.9.1 Runtime Semantics

RUNTIME SEMANTICS: THE ABSTRACT EQUALITY COMPARISON ALGORITHM

The comparison _x_ == _y_, where _x_ and _y_ are values, produces TRUE
or FALSE. Such a comparison is performed as follows:

NOTE 1 Given the above definition of equality:

-   String comparison can be forced by: "" + A == "" + B.

-   Numeric comparison can be forced by: +A == +B.

-   Boolean comparison can be forced by: !A == !B.

NOTE 2 The equality operators maintain the following invariants:

-   A != B is equivalent to !(A == B).

-   A == B is equivalent to B == A, except in the order of evaluation of
      A and B.

NOTE 3 The equality operator is not always transitive. For example,
there might be two distinct String objects, each representing the same
String value; each String object would be considered equal to the String
value by the == operator, but the two String objects would not be equal
to each other. For Example:

-   NEW STRING("A") == "A" and "A" == NEW STRING("A")are both TRUE.

-   NEW STRING("A") == NEW STRING("A") is FALSE.

NOTE 4 Comparison of Strings uses a simple equality test on sequences of
code unit values. There is no attempt to use the more complex,
semantically oriented definitions of character or string equality and
collating order defined in the Unicode specification. Therefore Strings
values that are canonically equal according to the Unicode standard
could test as unequal. In effect this algorithm assumes that both
Strings are already in normalised form.

RUNTIME SEMANTICS: THE STRICT EQUALITY COMPARISON ALGORITHM

The comparison _x_ === _y_, where _x_ and _y_ are values, produces TRUE
or FALSE. Such a comparison is performed as follows:

NOTE This algorithm differs from the SameValue Algorithm (9.12) in its
treatment of signed zeroes and NaNs.

RUNTIME SEMANTICS: EVALUATION

_EqualityExpression_ : _EqualityExpression_ == _RelationalExpression

_EqualityExpression_ : _EqualityExpression_ != _RelationalExpression

_EqualityExpression_ : _EqualityExpression_ === _RelationalExpression

_EqualityExpression_ : _EqualityExpression_ !== _RelationalExpression

1.  2.  3.  4.  5.  6.  7.  

1.  2.  3.  4.  5.  6.  7.  8.  


11.10 Binary Bitwise Operators

Syntax

BitwiseANDExpression :

EqualityExpression
BitwiseANDExpression & EqualityExpression

BitwiseANDExpressionNoIn :

EqualityExpressionNoIn
BitwiseANDExpressionNoIn & EqualityExpressionNoIn

BitwiseXORExpression :

BitwiseANDExpression
BitwiseXORExpression ^ BitwiseANDExpression

BitwiseXORExpressionNoIn :

BitwiseANDExpressionNoIn
BitwiseXORExpressionNoIn ^ BitwiseANDExpressionNoIn

BitwiseORExpression :

BitwiseXORExpression
BitwiseORExpression | BitwiseXORExpression

BitwiseORExpressionNoIn :

BitwiseXORExpressionNoIn
BitwiseORExpressionNoIn | BitwiseXORExpressionNoIn

STATIC SEMANTICS: ISVALIDSIMPLEASSIGNMENTTARGET

BitwiseANDExpression : BitwiseANDExpression & EqualityExpression

BitwiseXORExpression : BitwiseXORExpression ^ BitwiseANDExpression

BitwiseORExpression : BitwiseORExpression | BitwiseXORExpression

1.  Return FALSE.

RUNTIME SEMANTICS: EVALUATION

The production _A_ : _A @ B_, where @ is one of the bitwise operators in
the productions above, is evaluated as follows:


11.11 Binary Logical Operators

Syntax

LogicalANDExpression :

BitwiseORExpression
LogicalANDExpression && BitwiseORExpression

LogicalANDExpressionNoIn :

BitwiseORExpressionNoIn
LogicalANDExpressionNoIn && BitwiseORExpressionNoIn

LogicalORExpression :

LogicalANDExpression
LogicalORExpression || LogicalANDExpression

LogicalORExpressionNoIn :

LogicalANDExpressionNoIn
LogicalORExpressionNoIn || LogicalANDExpressionNoIn

The semantics of the _LogicalANDExpressionNoIn_ and
_LogicalORExpressionNoIn_ productions are the same manner as the
_LogicalANDExpression_ and _LogicalORExpression_ productions except that
the contained _LogicalANDExpressionNoIn_, _BitwiseORExpressionNoIn_ and
_LogicalORExpressionNoIn_ are used in place of the contained
_LogicalANDExpression_, _BitwiseORExpression_ and _LogicalORExpression_,
respectively.

NOTE The value produced by a && or || operator is not necessarily of
type Boolean. The value produced will always be the value of one of the
two operand expressions.

STATIC SEMANTICS: ISVALIDSIMPLEASSIGNMENTTARGET

LogicalANDExpression : LogicalANDExpression && BitwiseORExpression

LogicalORExpression : LogicalORExpression || LogicalANDExpression

1.  Return FALSE.

RUNTIME SEMANTICS: EVALUATION

_LogicalANDExpression_ : _LogicalANDExpression_ && _BitwiseORExpression

_LogicalORExpression_ : _LogicalORExpression_ || _LogicalANDExpression


11.12 Conditional Operator ( ? : )

Syntax

ConditionalExpression :

LogicalORExpression
LogicalORExpression ? AssignmentExpression : AssignmentExpression

ConditionalExpressionNoIn :

LogicalORExpressionNoIn
LogicalORExpressionNoIn ? AssignmentExpression :
AssignmentExpressionNoIn

The semantics of the _ConditionalExpressionNoIn_ production is the same
as the _ConditionalExpression_ production except that the contained
_LogicalORExpressionNoIn_, _AssignmentExpression_ and
_AssignmentExpressionNoIn_ are used in place of the contained
_LogicalORExpression_, first _AssignmentExpression_ and second
_AssignmentExpression_, respectively.

NOTE The grammar for a ConditionalExpression in ECMAScript is a little
bit different from that in C and Java, which each allow the second
subexpression to be an Expression but restrict the third expression to
be a ConditionalExpression. The motivation for this difference in
ECMAScript is to allow an assignment expression to be governed by either
arm of a conditional and to eliminate the confusing and fairly useless
case of a comma expression as the centre expression.

STATIC SEMANTICS: ISVALIDSIMPLEASSIGNMENTTARGET

ConditionalExpression : LogicalORExpression ? AssignmentExpression :
AssignmentExpression

1.  Return FALSE.

RUNTIME SEMANTICS: EVALUATION

_ConditionalExpression_ : _LogicalORExpression_ ? _AssignmentExpression
: _AssignmentExpression_


11.13 Assignment Operators

Syntax

AssignmentExpression :

ConditionalExpression
YieldExpression
ArrowFunction
LeftHandSideExpression = AssignmentExpression
LeftHandSideExpression AssignmentOperator AssignmentExpression

AssignmentExpressionNoIn :

ConditionalExpressionNoIn
YieldExpression
ArrowFunction
LeftHandSideExpression = AssignmentExpressionNoIn
LeftHandSideExpression AssignmentOperator AssignmentExpressionNoIn

AssignmentOperator : ONE OF

  ---- ---- ---- ---- ---- ----- ----- ------ ---- ---- ----
  *=   /=   %=   +=   -=   <<=   >>=   >>>=   &=   ^=   |=
  ---- ---- ---- ---- ---- ----- ----- ------ ---- ---- ----

The semantics of the _AssignmentExpressionNoIn_ productions are the same
manner as the _AssignmentExpression_ productions except that the
contained _ConditionalExpressionNoIn_ and _AssignmentExpressionNoIn_ are
used in place of the contained _ConditionalExpression_ and
_AssignmentExpression_, respectively.

Static Semantics

STATIC SEMANTICS: EARLY ERRORS

-   -   

-   -   -   -   -   -   

AssignmentExpression : LeftHandSideExpression = AssignmentExpression

-   It is a Syntax Error if _LeftHandSideExpression_ is either an
    _ObjectLiteral_ or an _ArrayLiteral_ and if the lexical token
    sequence matched by _LeftHandSideExpression_ cannot be parsed with
    no tokens left over using _AssignmentPattern_ as the goal symbol.

-   If _LeftHandSideExpression_ is either an _ObjectLiteral_ or an
    _ArrayLiteral_ and if the lexical token sequence matched by
    _LeftHandSideExpression_ can be parsed with no tokens left over
    using _AssignmentPattern_ as the goal symbol then the following
    rules are not applied. Instead, the Early Error rules for
    _AssignmentPattern_ are used.

-   It is a Syntax Error if _LeftHandSideExpression_ is an _Identifier_
    that can be statically determined to always resolve to a declarative
    environment record binding and the resolved binding is an immutable
    binding.

-   It is an early Reference Error if _LeftHandSideExpression_ is
    neither an _ObjectLiteral_ nor an _ArrayLiteral_ and
    IsValidSimpleAssignmentTarget of _LeftHandSideExpression_ is FALSE.

-   

AssignmentExpression : LeftHandSideExpression AssignmentOperator
AssignmentExpression

-   It is a Syntax Error if the _LeftHandSideExpression_ is an
    _Identifier_ that can be statically determined to always resolve to
    a declarative environment record binding and the resolved binding is
    an immutable binding.

-   It is an early Reference Error if IsValidSimpleAssignmentTarget of
    _LeftHandSideExpression_ is FALSE.

STATIC SEMANTICS: ISVALIDSIMPLEASSIGNMENTTARGET

AssignmentExpression :

YieldExpression
ArrowFunction
LeftHandSideExpression = AssignmentExpression
LeftHandSideExpression AssignmentOperator AssignmentExpression

1.  Return FALSE.

Runtime Semantics

RUNTIME SEMANTICS: EVALUATION

_AssignmentExpression_ : _LeftHandSideExpression_ =
_AssignmentExpression

_AssignmentExpression_ : _LeftHandSideExpression AssignmentOperator
AssignmentExpression_

-   -   -   -   

NOTE When an assignment occurs within strict mode code, it is an runtime
error if _lref_ in step 1.e of the first algorithm or step 9 of the
second algorithm it is an unresolvable reference. If it is, a
REFERENCEERROR exception is thrown. The _LeftHandSide_ also may not be a
reference to a data property with the attribute value
{[[Writable]]:FALSE}, to an accessor property with the attribute value
{[[Set]]:UNDEFINED}, nor to a non-existent property of an object for
which the IsExtensible predicate returns the value FALSE. In these cases
a TYPEERROR exception is thrown.

11.13.1 Destructuring Assignment

Supplemental Syntax

In certain circumstances when processing the production
_AssignmentExpression_ : _LeftHandSideExpression_ =
_AssignmentExpression_ the following grammar is used to refine the
interpretation of _LeftHandSideExpression_.

AssignmentPattern :

ObjectAssignmentPattern
ArrayAssignmentPattern

ObjectAssignmentPattern :

{ }
{ AssignmentPropertyList }
{ AssignmentPropertyList , }

ArrayAssignmentPattern :

[ Elision~opt~ AssignmentRestElement~opt~ ]
[ AssignmentElementList ]
[ AssignmentElementList , Elision~opt~ AssignmentRestElement~opt~ ]

AssignmentPropertyList :

AssignmentProperty
AssignmentPropertyList , AssignmentProperty

AssignmentElementList :

Elision~opt~ AssignmentElement
AssignmentElementList , Elision~opt~ AssignmentElement

AssignmentProperty :

Identifier Initialiser~opt~
PropertyName : AssignmentElement

AssignmentElement :

DestructuringAssignmentTarget Initialiser~opt~

AssignmentRestElement :

... DestructuringAssignmentTarget

DestructuringAssignmentTarget :

LeftHandSideExpression

Static Semantics

STATIC SEMANTICS: EARLY ERRORS

_AssignmentProperty_ : _Identifier_ _Initialiser_~opt~

-   It is a Syntax Error if _Identifier_ is the _Identifier_ EVAL or the
    _Identifier_ ARGUMENTS.

-   -   It is a Syntax Error if _Identifier_ does not statically resolve
    to a declarative environment record binding or if the resolved
    binding is an immutable binding.

_AssignmentRestElement_ : ... _DestructuringAssignmentTarget

-   It is a Syntax Error if IsValidSimpleAssignmentTarget of
    _DestructuringAssignmentTarget_ is FALSE.

DestructuringAssignmentTarget : LeftHandSideExpression

-   It is a Syntax Error _LeftHandSideExpression_ is either an
    _ObjectLiteral_ or an _ArrayLiteral_ and if the lexical token
    sequence matched by _LeftHandSideExpression_ cannot be parsed with
    no tokens left over using _AssignmentPattern_ as the goal symbol.

-   It is a Syntax Error if _LeftHandSideExpression_ is neither an
    _ObjectLiteral_ nor an _ArrayLiteral_ and
    IsValidSimpleAssignmentTarget of _LeftHandSideExpression_ is FALSE.

-   It is a Syntax Error if the _LeftHandSideExpression_ is an
    _Identifier_ that can be statically determined to always resolve to
    a declarative environment record binding and the resolved binding is
    an immutable binding.

-   It is a Syntax Error if _LeftHandSideExpression_ is the _Identifier_
    EVAL or the _Identifier_ ARGUMENTS.

-   -   -   -   It is a Syntax Error if IsInvalidAssignmentPattern of
    _LeftHandSideExpression_ is TRUE.

-   It is a Syntax Error if the _LeftHandSideExpression_ is
    _CoverParenthesisedExpressionAndArrowParameterList_ : ( _Expression_
    )
    and _Expression_ derived a production that would produce a Syntax
    Error according to these rules. This rule is recursively applied.

Runtime Semantics

RUNTIME SEMANTICS: DESTRUCTURING ASSIGNMENT EVALUATION

  with parameter _obj_

1.  2.  

1.  2.  

_ObjectAssignmentPattern_ : { }

and

ArrayAssignmentPattern :

[]
[Elision]

1.  Return NormalCompletion(empty).

1.  2.  

1.  2.  

_AssignmentPropertyList_ : _AssignmentPropertyList_ ,
_AssignmentProperty

  Let _status_ be

1.  the result of performing Destructuring Assignment Evaluation for
    _AssignmentPropertyList_ using _obj_ as the argument.

2.  ReturnIfAbrupt(_status_).

3.  Return the result of performing Destructuring Assignment Evaluation
    for _AssignmentProperty_ using _obj_ as the argument.

_AssignmentProperty_ : _Identifier_ _Initialiser_~opt~

1.  Let _P_ be StringValue of _Identifier_.

2.  3.  4.  5.  Let _v_ be the result of calling Get(_obj_, _P_).

6.  ReturnIfAbrupt(_v_).

7.  8.  If _Initialiser_~opt~ is present and _v_ is UNDEFINED, then

    a.  Let _defaultValue_ be the result of evaluating _Initialiser_.

    b.  Let _v_ be ToObject(GetValue(_defaultValue_)).

        i.  

9.  ReturnIfAbrupt(_v_).

10. Let _lref_ be the result of performing Identifier Resolution(10.3.1)
    with the _IdentifierName_ corresponding to _Identifier_.

11. Return PutValue(_lref_,_v_).

12. 

-   -   -   -   -   -   

_AssignmentProperty_ : _PropertyName_ : _AssignmentElement

1.  Let _name_ be PropName of _PropertyName_.

2.  Return the result of performing Keyed Destructuring Assignment
    Evaluation of _AssignmentElement_ with _obj_ and _name_ as the
    arguments.

3.  4.  5.  a.  b.  c.  d.  e.  

6.  7.  8.  

_ArrayAssignmentPattern_ : [ _Elision_~opt~ _AssignmentRestElement_ ]

1.  Let _skip_ be the Elision Width of _Elision_; if _Elision_ is not
    present, use the numeric value zero.

2.  Return the result of performing Indexed Destructuring Assignment
    Evaluation of _AssignmentRestElement_ with _obj_ and _skip_ as the
    arguments.

3.  

_ArrayAssignmentPattern_ : [ _AssignmentElementList_ ]

1.  Return the result of performing Indexed Destructuring Assignment
    Evaluation of _AssignmentElementList_ using _obj_ and 0 as the
    arguments.

2.  

_ArrayAssignmentPattern_ : [ _AssignmentElementList_ , _Elision_~opt~
_AssignmentRestElement_~opt~ ]

1.  2.  Let _lastIndex_ be the result of performing Indexed
    Destructuring Assignment Evaluation of _AssignmentElementList_ using
    _obj_ and 0 as the arguments.

3.  ReturnIfAbrupt(_lastIndex_).

4.  Let _skip_ be the Elision Width of _Elision_; if _Elision_ is not
    present, use the numeric value zero.

5.  If _AssignmentRestElement_ is present, then return the result of
    performing Indexed Destructuring Assignment Evaluation of
    _AssignmentRestElement_ with _obj_ and _lastIndex_+_skip_ as the
    arguments.

6.  7.  Return _lastIndex_.

RUNTIME SEMANTICS: INDEXED DESTRUCTURING ASSIGNMENT EVALUATION

  with parameters _obj_ and _index_

_AssignmentElementList_ : _Elision_~opt~ _AssignmentElement 

1.  Let _skip_ be the Elision Width of _Elision_; if _Elision_ is not
    present, use the numeric value zero.

2.  Let _name_ be ToString(_index_+_skip_).

3.  Let _status_ be the result of performing Keyed Destructuring
    Assignment Evaluation of _AssignmentElement_ with _obj_ and _name_
    as the arguments.

4.  ReturnIfAbrupt(_status_).

5.  Return _index_+_skip_+1.

6.  

_AssignmentElementList_ : _AssignmentElementList_ , _Elision_~opt~
_AssignmentElement 

1.  Let _listNext_ be the result of performing Indexed Destructuring
    Assignment Evaluation of _AssignmentElementList_ using _obj_ as the
    _obj_ parameter and _index_ as the _index_ parameter

2.  Let _skip_ be the Elision Width of _Elision_; if _Elision_ is not
    present, use the numeric value zero.

3.  ReturnIfAbrupt(_listNext_).

4.  Let _name_ be ToString(_listNext_+_skip_).

5.  Let _status_ be the result of performing Keyed Destructuring
    Assignment Evaluation of _AssignmentElement_ with _obj_ and _name_
    as the arguments.

6.  ReturnIfAbrupt(_status_).

7.  Return _listNext_+_skip+_1.

8.  

1.  2.  3.  4.  5.  6.  a.  b.  i.  

7.  8.  9.  10. a.  b.  c.  d.  e.  

11. 12. 13. 

_AssignmentRestElement_ : ... _DestructuringAssignmentTarget

1.  Let _lref_ be the result of evaluating
    _DestructuringAssignmentTarget_.

2.  ReturnIfAbrupt(_lref_).

3.  Let _lenVal_ be the result of Get(_obj_, "LENGTH").

4.  Let _len_ be ToUint32(_lenVal_).

5.  ReturnIfAbrupt(_len_).

6.  Let _A_ be the result of the abstract operation ArrayCreate with
    argument 0.

7.  Let _n_=0;

8.  Repeat, while _index_ < _len

    a.  Let _P_ be ToString(_index_).

    b.  Let _exists_ be the result of HasProperty(_obj_, _P_).

    c.  ReturnIfAbrupt(_exists_).

    d.  If _exists_ is TRUE, then

        i.  Let _v_ be the result of Get(_obj_, ToString(_index_)).

        ii. ReturnIfAbrupt(_len_).

        iii. Call the [[DefineOwnProperty]] internal method of _A_ with
              arguments ToString(_n_) and Property Descriptor
              {[[Value]]: _v_, [[Writable]]: TRUE, [[Enumerable]]: TRUE,
              [[Configurable]]: TRUE}.

    e.  Let _n_ = _n_+1.

    f.  Let _index_ = _index_+1.

9.  Return PutValue(_lref_,_A_).

10. 

RUNTIME SEMANTICS: KEYED DESTRUCTURING ASSIGNMENT EVALUATION

  with parameters _obj_ and _propertyName_

_AssignmentElement_ : _DestructuringAssignmentTarget_ _Initialiser_~opt~

1.  Let _v_ be the result of Get(_obj_, _propertyName_).

2.  ReturnIfAbrupt(_v_).

3.  If _Initialiser_~opt~ is present and _v_ is UNDEFINED, then

    a.  Let _defaultValue_ be the result of evaluating _Initialiser_.

    b.  Let _v_ be GetValue(_defaultValue_)

4.  If _DestructuringAssignmentTarget_ is an _ObjectLiteral_ or an
    _ArrayLiteral_ then

    a.  Let _AssignmentPattern_ be the parse of the source code
        corresponding to _DestructuringAssignmentTarget_ using
        _AssignmentPattern_ as the goal symbol

    b.  Let _vObj_ be ToObject(_v_).

    c.  ReturnIfAbrupt(_vObj_).

    d.  Return the result of performing Destructuring Assignment
        Evaluation of _AssignmentPattern_ with _vObj_ as the argument.

5.  ReturnIfAbrupt(_v_).

6.  Let _lref_ be the result of evaluating
    _DestructuringAssignmentTarget_.

7.  Return PutValue(_lref_,_v_).


11.14 Comma Operator ( , )

Syntax

_Expression_ :

_AssignmentExpression
Expression , AssignmentExpression

ExpressionNoIn :

AssignmentExpressionNoIn
ExpressionNoIn , AssignmentExpressionNoIn

The semantics of the _ExpressionNoIn_ production is the same manner as
the _Expression_ production except that the contained _ExpressionNoIn_
and _AssignmentExpressionNoIn_ are used in place of the contained
_Expression_ and _AssignmentExpression_, respectively.

STATIC SEMANTICS: ISVALIDSIMPLEASSIGNMENTTARGET

_Expression_ : Expression , AssignmentExpression

1.  Return FALSE.

RUNTIME SEMANTICS: EVALUATION

_Expression_ : _Expression_ , _AssignmentExpression

NOTE GetValue must be called even though its value is not used because
it may have observable side-effects.

Syntax

Statement :

BlockStatement
VariableStatement
EmptyStatement
ExpressionStatement
IfStatement
BreakableStatement
ContinueStatement
BreakStatement
ReturnStatement
WithStatement
LabelledStatement
ThrowStatement
TryStatement
DebuggerStatement

Declaration :

FunctionDeclaration
GeneratorDeclaration
ClassDeclaration
LexicalDeclaration

BreakableStatement :

IterationStatement
SwitchStatement


Static Semantics

1.  

STATIC SEMANTICS: VARDECLAREDNAMES

Statement :

EmptyStatement
ExpressionStatement
ContinueStatement
BreakStatement
ReturnStatement
ThrowStatement
DebuggerStatement

1.  Return a new empty List.


Runtime Semantics

RUNTIME SEMANTICS: LABELLED EVALUATION

  With argument _labelSet_.

_BreakableStatement_ : _IterationStatement

1.  Let _stmtResult_ be the result of performing Labelled Evaluation of
    _IterationStatement_ with argument _labelSet_.

2.  If _stmtResult_.[[type]] is break and _stmtResult_.[[target]] is
    empty, then

    a.  If _stmtResult_.[[value]] is empty, then let _stmtResult_ be
        NormalCompletion(UNDEFINED).

    b.  Else, let _stmtResult_ be
        NormalCompletion(_stmtResult_.[[value]])

3.  Return _stmtResult_.

_BreakableStatement_ : _SwitchStatement

1.  Let _stmtResult_ be the result of evaluating _SwitchStatement_.

2.  If _stmtResult_.[[type]] is break and _stmtResult_.[[target]] is
    empty, then

    a.  If _stmtResult_.[[value]] is empty, then let _stmtResult_ be
        NormalCompletion(UNDEFINED).

    b.  Else, let _stmtResult_ be
        NormalCompletion(_stmtResult_.[[value]])

3.  Return _stmtResult_.

NOTE A _BreakableStatement_ is one that can be exited via an unlabelled
_BreakStatement_.

RUNTIME SEMANTICS: EVALUATION

1.  

1.  

BreakableStatement :

IterationStatement
SwitchStatement

1.  Let _newLabelSet_ be a new empty List.

2.  Return the result of performing Labelled Evaluation of this
    _BreakableStatement_ with argument _newLabelSet_.


12.1 Block

Syntax

BlockStatement :

Block

Block :

{ StatementList~opt~ }

StatementList :

StatementListItem
StatementList StatementListItem

StatementListItem :

Statement
Declaration

Static Semantics

STATIC SEMANTICS: EARLY ERRORS

_Block_ : { _StatementList_ }

-   -   It is a Syntax Error if the LexicallyDeclaredNames of
    _StatementList_ contains any duplicate entries.

-   It is a Syntax Error if any element of the LexicallyDeclaredNames of
    _StatementList_ also occurs in the VarDeclaredNames of
    _StatementList_.

STATIC SEMANTICS: LEXICALDECLARATIONS

1.  

_StatementList_ : _StatementList StatementListItem

1.  Let _declarations_ be LexicalDeclarations of _StatementList_.

2.  Append to _declarations_ the elements of the LexicalDeclarations of
    _StatementListItem._

3.  Return _declarations_.

_StatementListItem_ : _Statement

1.  Return a new empty List.

_StatementListItem_ : _Declaration

1.  Return a new List containing _Declaration_.

1.  

1.  

STATIC SEMANTICS: LEXICALLYDECLAREDNAMES

_Block_ : { }

1.  Return a new empty List.

1.  

1.  

_StatementList_ : _StatementList StatementListItem

1.  Let _names_ be LexicallyDeclaredNames of _StatementList_.

2.  Append to _names_ the elements of the LexicallyDeclaredNames of
    _StatementListItem._

3.  Return _names_.

_StatementListItem_ : _Statement

1.  Return a new empty List.

_StatementListItem_ : _Declaration

1.  Return the BoundNames of _Declaration_.

STATIC SEMANTICS: TOPLEVELLEXICALLYDECLAREDNAMES

_StatementList_ : _StatementList StatementListItem

1.  Let _names_ be TopLevelLexicallyDeclaredNames of _StatementList_.

2.  Append to _names_ the elements of the TopLevelLexicallyDeclaredNames
    of _StatementListItem._

3.  Return _names_.

_StatementListItem_ : _Statement

1.  Return a new empty List.

_StatementListItem_ : _Declaration

1.  If _Declaration_ is _Declaration_ : _FunctionDeclaration_, then
    return a new empty List.

2.  Return the BoundNames of _Declaration_.

NOTE At the top level of a function, or script, function declarations
are treated like var declarations rather than like lexical declarations.

STATIC SEMANTICS: TOPLEVELLEXICALLYSCOPEDDECLARATIONS

_StatementList_ : _StatementList StatementListItem

1.  Let _declarations_ be TopLevelLexicallyScopedDeclarations of
    _StatementList_.

2.  Append to _declarations_ the elements of the
    TopLevelLexicallyScopedDeclarations of _StatementListItem._

3.  Return _declarations_.

_StatementListItem_ : _Statement

1.  Return a new empty List.

_StatementListItem_ : _Declaration

1.  If _Declaration_ is _Declaration_ : _FunctionDeclaration_, then
    return a new empty List.

2.  Return a new List containing _Declaration_.

STATIC SEMANTICS: TOPLEVELVARDECLAREDNAMES

_StatementList_ : _StatementList StatementListItem

1.  Let _names_ be TopLevelVarDeclaredNames of _StatementList_.

2.  Append to _names_ the elements of the TopLevelVarDeclaredNames of
    _StatementListItem._

3.  Return _names_.

_StatementListItem_ : _Declaration

1.  If _Declaration_ is _Declaration_ : _FunctionDeclaration_, then
    return the LexicallyDeclaredNames of _Declaration_.

2.  Return a new empty List.

_StatementListItem_ : _Statement

1.  Return VarDeclaredNames of _Statement_.

NOTE At the top level of a function or script, inner function
declarations are treated like var declarations.

STATIC SEMANTICS: TOPLEVELVARSCOPEDDECLARATIONS

_StatementList_ : _StatementList StatementListItem

1.  Let _declarations_ be TopLevelVarScopedDeclarations of
    _StatementList_.

2.  Append to _declarations_ the elements of the
    TopLevelVarScopedDeclarations of _StatementListItem._

3.  Return _declarations_.

_StatementListItem_ : _Statement

1.  If _Statement_ is _Statement_ : _VariableStatement_, then return a
    new List containing _VariableStatement_.

2.  Return a new empty List.

_StatementListItem_ : _Declaration

1.  If _Declaration_ is _Declaration_ : _FunctionDeclaration_, then
    return a new List containing _Declaration_.

2.  Return a new empty List.

STATIC SEMANTICS: VARDECLAREDNAMES

1.  

_Block_ : { }

1.  Return a new empty List.

1.  

1.  

_StatementList_ : _StatementList StatementListItem

1.  Let _names_ be VarDeclaredNames of _StatementList_.

2.  Append to _names_ the elements of the VarDeclaredNames of
    _StatementListItem._

3.  Return _names_.

1.  

_StatementListItem_ : _Declaration

1.  Return a new empty List.

Runtime Semantics

RUNTIME SEMANTICS: EVALUATION

1.  

_Block_ : { }

1.  Return NormalCompletion(UNDEFINED).

-   -   -   

1.  

1.  

_Block_ : { _StatementList_ }

1.  Let _oldEnv_ be the running execution context’s LexicalEnvironment.

2.  Let _blockEnv_ be the result of calling NewDeclarativeEnvironment
    passing _oldEnv_ as the argument.

3.  Perform Block Declaration Instantiation using _StatementList_ and
    _blockEnv_.

4.  Set the running execution context’s LexicalEnvironment to
    _blockEnv_.

5.  Let _blockValue_ be the result of evaluating _StatementList_.

6.  Set the running execution context’s LexicalEnvironment to _oldEnv_.

7.  If _blockValue_.[[type]] is normal and _blockValue_.[[value]] is
    empty, then

    a.  Return NormalCompletion(UNDEFINED).

8.  Return _blockValue_.

NOTE No matter how control leaves the _Block_ the LexicalEnvironment is
always restored to its former state.

1.  

1.  

1.  

1.  2.  3.  

1.  2.  3.  

1.  2.  3.  

_StatementList_ : _StatementList StatementListItem

NOTE Steps 4 and 5 of the above algorithm ensure that the value of a
_StatementList_ is the value of the last value producing _Statement_ in
the _StatementList_. For example, the following calls to the EVAL
function all return the value 1:

  EVAL("1;;;;;")

  EVAL("1;{}")

  EVAL("1;VAR A;")


12.2 Declarations and the Variable Statement

12.2.1 Let and Const Declarations

NOTE A LET and CONST declarations define variables that are scoped to
the running execution context’s LexicalEnvironment. The variables are
created when their containing Lexical Environment is instantiated but
may not be accessed in any way until the variable’s _LexicalBinding_ is
evaluated. A variable defined by a _LexicalBinding_ with an
_Initialiser_ is assigned the value of its _Initialiser_’s
_AssignmentExpression_ when the _LexicalBinding_ is evaluated, not when
the variable is created. If a _LexicalBinding_ in a LET declaration does
not have an an _Initialiser_ the variable is assigned the value
UNDEFINED when the _LexicalBinding_ is evaluated.

Syntax

LexicalDeclaration :

LetOrConst BindingList ;

LexicalDeclarationNoIn :

LetOrConst BindingListNoIn

LetOrConst :

LET
CONST

BindingList :

LexicalBinding
BindingList , LexicalBinding

BindingListNoIn :

LexicalBindingNoIn
BindingListNoIn , LexicalBindingNoIn

LexicalBinding :

BindingIdentifier Initialiser~opt
~BindingPattern Initialiser

LexicalBindingNoIn :

BindingIdentifier InitialiserNoIn~opt
~BindingPattern InitialiserNoIn

BindingIdentifier :

Identifier

InitialiserNoIn :

= AssignmentExpressionNoIn

The semantics of the _LexicalDeclarationNoIn_, _BindingListNoIn_,
_LexicalBindingNoIn_ and _InitialiserNoIn_ productions are the same as
the _LexicalDeclaration_, _BindingList_, _LexicalBinding_ and
_Initialiser_ productions except that the contained _BindingListNoIn_,
_LexicalBindingNoIn_, _InitialiserNoIn_ and _AssignmentExpressionNoIn
are used in place of the contained _BindingList_, _LexicalBinding_,
_Initialiser_ and _AssignmentExpression_, respectively.

 Static Semantics

STATIC SEMANTICS: EARLY ERRORS

_LexicalBinding_ : _BindingIdentifier

-   It is a Syntax Error if IsConstantDeclaration of the
    _LexicalDeclaration_ containing this production is TRUE.

-   

_BindingIdentifier_ : _Identifier

-   It is a Syntax Error if the _BindingIdentifier_ is contained in
    strict code and if the _Identifier_ is EVAL or ARGUMENTS.

STATIC SEMANTICS: BOUNDNAMES

_LexicalDeclaration_ : _LetOrConst BindingList_ ;

1.  Return the BoundNames of _BindingList_.

1.  

_BindingList_ : _BindingList_ , _LexicalBinding

1.  Let _names_ be the BoundNames of _BindingList_.

2.  Append to _names_ the elements of the BoundNames of
    _LexicalBinding._

3.  Return _names_.

_LexicalBinding_ : _BindingIdentifier Initialiser_~opt~

1.  Return the BoundNames of _BindingIdentifier_.

_LexicalBinding_ : _BindingPattern Initialiser

1.  Return the BoundNames of _BindingPattern_.

_BindingIdentifier_ : _Identifier

1.  Return a new List containing the StringValue of _Identifier_.

STATIC SEMANTICS: ISCONSTANTDECLARATION

_LexicalDeclaration_ : _LetOrConst BindingList_ ;

1.  Return IsConstantDeclaration of _LetOrConst_.

_LetOrConst_ : LET

1.  Return FALSE.

_LetOrConst_ : CONST

1.  Return TRUE.

Runtime Semantics

RUNTIME SEMANTICS: BINDING INITIALISATION

  With arguments _value_ and _environment_.

NOTE UNDEFINED is passed for _environment_ to indicate that a PutValue
operation should be used to assign the initialisation value. This is the
case for VAR statements formal parameter lists of non-strict functions.
In those cases a lexical binding is hosted and preinitialised prior to
evaluation of its initialiser.

_BindingIdentifier_ : _Identifier

1.  

1.  If _environment_ is not UNDEFINED, then

    a.  Let _name_ be StringValue of _Identifier_.

    b.  Let _env_ be the environment record component of _environment_.

    c.  Call the InitialiseBinding concrete method of _env_ passing
        _name_ and _value_ as the arguments.

    d.  Return NormalCompletion(UNDEFINED).

2.  Else

    a.  Let _lhs_ be the result of evaluating _Identifier_ as described
        in 11.1.2.

    b.  Return PutValue(_lhs_, _value_).

RUNTIME SEMANTICS: EVALUATION

_LexicalDeclaration_ : _LetOrConst BindingList_ ;

1.  Let _next_ be the result of evaluating _BindingList_.

2.  ReturnIfAbrupt(_next_).

3.  Return NormalCompletion(empty).

1.  

_BindingList_ : _BindingList_ , _LexicalBinding

1.  Let _next_ be the result of evaluating _BindingList_.

2.  ReturnIfAbrupt(_next_).

3.  Return the result of evaluating _LexicalBinding_.

_LexicalBinding_ : _BindingIdentifier 

1.  Let _env_ be the running execution context’s LexicalEnvironment.

2.  Return the result of performing Binding Initialisation for
    _BindingIdentifier_ passing UNDEFINED and _env_ as the arguments.

NOTE A static semantics rule ensures that this form of _LexicalBinding_
never occurs in a CONST declaration.

_LexicalBinding_ : _BindingIdentifier Initialiser

1.  Let _rhs_ be the result of evaluating _Initialiser_.

2.  Let _value_ be GetValue(_rhs_).

3.  ReturnIfAbrupt(_value_).

4.  Let _env_ be the running execution context’s LexicalEnvironment.

5.  Return the result of performing Binding Initialisation for
    _BindingIdentifier_ passing _value_ and _env_ as the arguments.

_LexicalBinding_ : _BindingPattern Initialiser

1.  Let _rhs_ be the result of evaluating _Initialiser_.

2.  Let _value_ be ToObject(GetValue(_rhs_)).

3.  ReturnIfAbrupt(_value_).

4.  Let _env_ be the running execution context’s LexicalEnvironment.

5.  Return the result of performing Binding Initialisation for
    _BindingPattern_ using _value_ and _env_ as the _arguments_.

12.2.2 Variable Statement

NOTE A VAR statement declares variables that are scoped to the running
execution context’s VariableEnvironment. Var variables are created when
their containing Lexical Environment is instantiated and are initialised
to UNDEFINED when created. Within the scope of any VariableEnvironemnt a
common _Identifier_ may appear in more than one _VariableDeclaration_
but those declarations collective define only one variable. A variable
defined by a _VariableDeclaration_ with an _Initialiser_ is assigned the
value of its _Initialiser_’s _AssignmentExpression_ when the
_VariableDeclaration_ is executed, not when the variable is created.

Syntax

VariableStatement :

VAR VariableDeclarationList ;

VariableDeclarationList :

VariableDeclaration
VariableDeclarationList , VariableDeclaration

VariableDeclarationListNoIn :

VariableDeclarationNoIn
VariableDeclarationListNoIn , VariableDeclarationNoIn

VariableDeclaration :

BindingIdentifier Initialiser~opt
~BindingPattern Initialiser

VariableDeclarationNoIn :

BindingIdentifier InitialiserNoIn~opt
~BindingPattern InitialiserNoIn

The semantics of the _VariableDeclarationListNoIn_,
_VariableDeclarationNoIn_ and _InitialiserNoIn_ productions are the same
as the _VariableDeclarationList_, _VariableDeclaration_ and
_Initialiser_ productions except that the contained
_VariableDeclarationListNoIn_, _VariableDeclarationNoIn_,
_InitialiserNoIn_ and _AssignmentExpressionNoIn_ are used in of the
contained _VariableDeclarationList_, _VariableDeclaration_,
_Initialiser_ and _AssignmentExpression_, respectively.

Static Semantics

-   

STATIC SEMANTICS: BOUNDNAMES

1.  

1.  

_VariableDeclarationList_ : _VariableDeclarationList_ ,
_VariableDeclaration

1.  Let _names_ be BoundNames of _VariableDeclarationList_.

2.  Append to _names_ the elements of BoundNames of
    _VariableDeclaration._

3.  Return _names_.

_VariableDeclaration_ : _BindingIdentifier Initialiser_~opt~

1.  Return the BoundNames of _BindingIdentifier_.

_VariableDeclaration_ : _BindingPattern Initialiser

1.  Return the BoundNames of _BindingPattern_.

Runtime Semantics

RUNTIME SEMANTICS: BINDING INITIALISATION

  With arguments _value_ and _environment_.

NOTE UNDEFINED is passed for _environment_ to indicate that a PutValue
operation should be used to assign the initialisation value. This is the
case for VAR statements formal parameter lists of non-strict functions.
In those cases a lexical binding is hosted and preinitialised prior to
evaluation of its initializer.

_VariableDeclaration_ : _BindingIdentifier

1.  Return the result of performing Binding Initialisation for
    _BindingIdentifier_ passing _value_ and UNDEFINED as the arguments.

_VariableDeclaration_ : _BindingIdentifier Initialiser

1.  Return the result of performing Binding Initialisation for
    _BindingIdentifier_ passing _value_ and UNDEFINED as the arguments.

_VariableDeclaration_ : _BindingPattern Initialiser

1.  Return the result of performing Binding Initialisation for
    _BindingPattern_ passing _value_ and UNDEFINED as the arguments.

RUNTIME SEMANTICS: EVALUATION

_VariableStatement_ : VAR _VariableDeclarationList_ ;

1.  Let _next_ be the result of evaluating _VariableDeclarationList_.

2.  ReturnIfAbrupt(_next_).

3.  Return NormalCompletion( empty).

1.  

1.  

1.  2.  3.  

_VariableDeclarationList_ : _VariableDeclarationList_ ,
_VariableDeclaration

1.  Let _next_ be the result of evaluating _VariableDeclarationList_.

2.  ReturnIfAbrupt(_next_).

3.  Return the result of evaluating _VariableDeclaration_.

1.  

_VariableDeclaration_ : _BindingIdentifier

1.  Return NormalCompletion(empty).

_VariableDeclaration_ : _BindingIdentifier Initialiser

1.  Let _rhs_ be the result of evaluating _Initialiser_.

2.  Let _value_ be GetValue(_rhs_).

3.  ReturnIfAbrupt(_value_).

4.  Return the result of performing Binding Initialisation for
    _BindingIdentifier_ passing _value_ and UNDEFINED as the arguments.

NOTE If a _VariableDeclaration_ is nested within a with statement and
the _Identifier_ in the _VariableDeclaration_ is the same as a property
name of the binding object of the with statement’s object environment
record, then step 3 will assign value to the property instead of to the
VariableEnvironment binding of the _Identifier_.

-   

1.  

_VariableDeclaration_ : _BindingPattern Initialiser

1.  Let _rhs_ be the result of evaluating _Initialiser_.

2.  Let _rval_ be ToObject(GetValue(_rhs_)).

3.  ReturnIfAbrupt(_rval_).

4.  Return the result of performing Binding Initialisation for
    _BindingPattern_ passing _rval_ and UNDEFINED as arguments.

12.2.4 Destructuring Binding Patterns

Syntax

BindingPattern :

ObjectBindingPattern
ArrayBindingPattern

ObjectBindingPattern :

{ }
{ BindingPropertyList }
{ BindingPropertyList , }

ArrayBindingPattern :

[ Elision~opt~ BindingRestElement~opt~ ]
[ BindingElementList ]
[ BindingElementList , Elision~opt~ BindingRestElement~opt~ ]

BindingPropertyList :

BindingProperty
BindingPropertyList , BindingProperty

BindingElementList :

Elision~opt~ BindingElement
BindingElementList , Elision~opt~ BindingElement

BindingProperty :

SingleNameBinding ~
~ PropertyName : BindingElement

BindingElement :

SingleNameBinding
BindingPattern Initialiser~opt~

SingleNameBinding :

BindingIdentifier Initialiser~opt~

BindingRestElement :

... BindingIdentifier

Static Semantics

STATIC SEMANTICS: EARLY ERRORS

_BindingPattern_ : _ObjectBindingPattern

-   It is a Syntax Error if the BoundNames of _ObjectBindingPattern_
    contains the string “EVAL” or the string “ARGUMENTS”.

_BindingPattern_ : _ArrayBindingPattern

-   It is a Syntax Error if the BoundNames of _ArrayBindingPattern_
    contains the string “EVAL” or the string “ARGUMENTS”.

STATIC SEMANTICS: BOUNDNAMES

1.  2.  

1.  

1.  2.  3.  4.  5.  

1.  

1.  

1.  

_ObjectBindingPattern_ : { }

1.  Return an empty List.

1.  

_ArrayBindingPattern_ : [ _Elision_~opt~ ]

1.  Return an empty List.

_ArrayBindingPattern_ : [ _Elision_~opt~ _BindingRestElement_ ]

1.  Return the BoundNames of _BindingRestElement_.

1.  

_ArrayBindingPattern_ : [ _BindingElementList_ , _Elision_~opt~ ]

1.  Return the BoundNames of _BindingElementList_.

_ArrayBindingPattern_ : [ _BindingElementList_ , _Elision_~opt~
_BindingRestElement_ ]

1.  Let _names_ be BoundNames of _BindingElementList_.

2.  Append to _names_ the elements of BoundNames of
    _BindingRestElement._

3.  Return _names_.

1.  

_BindingPropertyList_ : _BindingPropertyList_ , _BindingProperty

1.  Let _names_ be BoundNames of _BindingPropertyList_.

2.  Append to _names_ the elements of BoundNames of _BindingProperty.

3.  Return _names_.

_BindingElementList_ : _Elision_~opt~ _BindingElement

1.  Return BoundNames of _BindingElement_.

_BindingElementList_ : _BindingElementList_ , _Elision_~opt~
_BindingElement

1.  Let _names_ be BoundNames of _BindingElementList_.

2.  Append to _names_ the elements of BoundNames of _BindingElement.

3.  Return _names_.

1.  

_BindingProperty_ : _PropertyName_ : _BindingElement 

1.  Return the BoundNames of _BindingElement_.

_SingleNameBinding_ : _BindingIdentifier Initialiser_~opt~

1.  Return the BoundNames of _BindingIdentifier_.

1.  

_BindingElement_ : _BindingPattern Initialiser_~opt~

1.  Return the BoundNames of _BindingPattern_.

1.  

STATIC SEMANTICS: HASINITIALISER

1.  

_BindingElement_ : _BindingPattern 

1.  Return FALSE.

_BindingElement_ : _BindingPattern Initialiser

1.  Return TRUE.

_SingleNameBinding_ : _BindingIdentifier 

1.  Return FALSE.

_SingleNameBinding_ : _BindingIdentifier Initialiser

1.  Return TRUE.

Runtime Semantics

RUNTIME SEMANTICS: BINDING INITIALISATION

  With parameters _value_ and _environment_.

NOTE When UNDEFINED is passed for _environment_ it indicates that a
PutValue operation should be used to assign the initialisation value.
This is the case for formal parameter lists of non-strict functions. In
that case the formal parameter bindings are preinitialised in order to
deal with the possibility of multiple parameters with the same name.

_BindingPattern_ : _ObjectBindingPattern

1.  Assert: Type(_value_) is Object

    a.  

2.  3.  Return the result of performing Binding Initialisation for
    _ObjectBindingPattern_ using _value_ and _environment_ as arguments.

1.  

_BindingPattern_ : _ArrayBindingPattern

1.  Assert: Type(_value_) is Object

    a.  b.  c.  

2.  a.  b.  

3.  Return the result of performing Indexed Binding Initialisation for
    _ArrayBindingPattern_ using _value_, 0, and _environment_ as
    arguments.

1.  

_ObjectBindingPattern_ : { }

1.  Return NormalCompletion(empty).

1.  

1.  a.  

2.  3.  

1.  

1.  

1.  

1.  2.  a.  

3.  4.  

1.  

1.  a.  

2.  3.  4.  

1.  2.  3.  

1.  a.  

2.  3.  4.  5.  

1.  

1.  

1.  2.  3.  

_BindingPropertyList_ : _BindingPropertyList_ , _BindingProperty

1.  Let _status_ be the result of performing Binding Initialisation for
    _BindingPropertyList_ using _value_ and _environment_ as arguments.

2.  ReturnIfAbrupt(_status_).

3.  Return the result of performing Binding Initialisation for
    _BindingProperty_ using _value_ and _environment_ as arguments.

_BindingProperty_ : _SingleNameBinding

1.  Let _name_ be the string that is the only element of BoundNames of
    _SingleNameBinding_.

2.  Return the result of performing Keyed Binding Initialisation for
    _SingleNameBinding_ using _value_, _environment_, and _name_ as the
    arguments.

_BindingProperty_ : _PropertyName_ : _BindingElement 

1.  Let _P_ be the PropName of _PropertyName

2.  Return the result of performing Keyed Binding Initialisation for
    _BindingElement_ using _value_, _environment_, and _P_ as arguments.

RUNTIME SEMANTICS: INDEXED BINDING INITIALISATION

  With parameters _array_, _nextIndex,_ and _environment_.

NOTE When UNDEFINED is passed for _environment_ it indicates that a
PutValue operation should be used to assign the initialisation value.
This is the case for formal parameter lists of non-strict functions. In
that case the formal parameter bindings are preinitialised in order to
deal with the possibility of multiple parameters with the same name.

_ArrayBindingPattern_ : [ _Elision_~opt~ ]

1.  Return NormalCompletion(empty).

_ArrayBindingPattern_: [ _Elision_~opt~ _BindingRestElement_ ]

1.  Let _nextIndex_ be the Elision Width of _Elision_; if _Elision_ is
    not present, use the numeric value zero.

2.  Return the result of performing Indexed Binding Initialisation for
    _BindingRestElement_ using _array, nextIndex_, and _environment_ as
    arguments.

_ArrayBindingPattern_: [ _BindingElementList_ ]

1.  Return the result of performing Indexed Binding Initialisation for
    _BindingElementList_ using _array_, _nextIndex_, and _environment_
    as arguments.

_ArrayBindingPattern_: [ _BindingElementList_ , _Elision_~opt~]

1.  Return the result of performing Indexed Binding Initialisation for
    _BindingElementList_ using _array_, _nextIndex_, and _environment_
    as arguments.

_ArrayBindingPattern_: [ _BindingElementList_ , _Elision_~opt~
_BindingRestElement_ ]

1.  Let _next_ be the result of performing Indexed Binding
    Initialisation for _BindingElementList_ using _array , nextIndex_,
    and _environment_ as arguments.

2.  ReturnIfAbrupt(_next_).

3.  Let _skip_ be the Elision Width of _Elision_; if _Elision_ is not
    present, use the numeric value zero.

4.  Return the result of performing Indexed Binding Initialisation for
    _BindingRestElement_ using _array,_ _next_+_skip_ , and
    _environment_ as arguments.

1.  

_BindingElementList_ : _Elision_~opt~ _BindingElement

1.  Let _skip_ be the Elision Width of _Elision_; if _Elision_ is not
    present, use the numeric value zero.

2.  Let _status_ be the result of performing Indexed Binding
    Initialisation for _BindingElement_ using _array_,
    _nextIndex_+_skip_ , and _environment_ as arguments.

3.  ReturnIfAbrupt(_status_).

4.  Return _nextIndex_ +_skip_+1.

1.  2.  3.  

_BindingElementList_ : _BindingElementList_ , _Elision_~opt~
_BindingElement 

1.  Let _listNext_ be the result of performing Indexed Binding
    Initialisation for _BindingElementList_ using _array, nextIndex_,
    and _environment_ as arguments.

2.  ReturnIfAbrupt(_listNext_).

3.  Let _skip_ be the Elision Width of _Elision_; if _Elision_ is not
    present, use the numeric value zero.

4.  Let _status_ be the result of performing Indexed Binding
    Initialisation for _BindingElement_ using _array_, _listNext_+_skip_
    , and _environment_ as arguments.

5.  ReturnIfAbrupt(_status_).

6.  Return _listNext_ +_skip+_1.

7.  

1.  

1.  2.  3.  

1.  2.  

1.  

1.  2.  3.  a.  

4.  a.  i.  

    b.  i.  

5.  

1.  

1.  2.  a.  

3.  a.  i.  

    b.  i.  

4.  

1.  

_BindingElement_ : _SingleNameBinding

1.  a.  

2.  3.  Return the result of performing Keyed Binding Initialisation for
    _SingleNameBinding_ using _array_, _environment_, and
    ToString(_nextIndex_) as the arguments.

1.  

_BindingElement_ : _BindingPattern Initialiser_~opt~

1.  Let _P_ be ToString(_nextIndex_).

2.  3.  4.  5.  6.  7.  8.  9.  Let _v_ be the result of Get(_array_,
    _P_).

10. ReturnIfAbrupt(_v_).

11. 12. If _Initialiser_~opt~ is present and _v_ is UNDEFINED, then

    a.  Let _defaultValue_ be the result of evaluating _Initialiser_.

    b.  Let _v_ be ToObject(GetValue(_defaultValue_)).

    c.  

    a.  i.  

13. ReturnIfAbrupt(_v_).

14. Return the result of performing Binding Initialisation for
    _BindingPattern_ passing _v_ and _environment_ as arguments.

_BindingRestElement_ : ... _BindingIdentifier

1.  Let _A_ be the result of the abstract operation ArrayCreate with
    argument 0.

2.  Let _lenVal_ be the result of Get(_array_, "LENGTH").

3.  Let _arrayLength_ be ToUint32(_lenVal_).

4.  ReturnIfAbrupt(_arrayLength_).

5.  Let _n_=0.

6.  Let _index_ = _nextIndex_.

7.  Repeat, while _index_ < _arrayLength

    a.  Let _P_ be ToString(_index_).

    b.  Let _exists_ be the result of HasProperty(_array_, _P_).

    c.  ReturnIfAbrupt(_exists_).

    d.  If _exists_ is TRUE, then

        i.  Let _v_ be the result of Get(_array_, _P_).

        ii. ReturnIfAbrupt(_v_).

        iii. Call the [[DefineOwnProperty]] internal method of _A_ with
              arguments ToString(_n_) and Property Descriptor
              {[[Value]]: _v_, [[Writable]]: TRUE, [[Enumerable]]: TRUE,
              [[Configurable]]: TRUE}.

    e.  Let _n_ = _n_+1.

    f.  Let _index_ = _index_+1.

8.  Return the result of performing Binding Initialisation for
    _BindingIdentifier_ using _A_ and _environment_ as arguments.

RUNTIME SEMANTICS: KEYED BINDING INITIALISATION

  With parameters _obj_, _environment,_ and _propertyName_.

NOTE When UNDEFINED is passed for _environment_ it indicates that a
PutValue operation should be used to assign the initialisation value.
This is the case for formal parameter lists of non-strict functions. In
that case the formal parameter bindings are preinitialised in order to
deal with the possibility of multiple parameters with the same name.

1.  

_BindingElement_ : _BindingPattern_ _Initialiser_~opt~

1.  2.  3.  

1.  Let _v_ be the result of Get(_obj_, _propertyName_).

2.  ReturnIfAbrupt(_v_).

3.  4.  If _Initialiser_~opt~ is present and _v_ is UNDEFINED, then

    a.  Let _defaultValue_ be the result of evaluating _Initialiser_.

    b.  Let _v_ be ToObject(GetValue(_defaultValue_)).

1.  2.  

1.  ReturnIfAbrupt(_v_).

2.  Return the result of performing Binding Initialisation for
    _BindingPattern_ passing _v_ and _environment_ as arguments.

_SingleNameBinding_ : _BindingIdentifier Initialiser_~opt~

1.  2.  

1.  

1.  Let _v_ be the result of Get(_obj_, _propertyName_).

1.  ReturnIfAbrupt(_v_).

2.  3.  If _Initialiser_~opt~ is present and _v_ is UNDEFINED, then

    a.  Let _defaultValue_ be the result of evaluating _Initialiser_.

    b.  Let _v_ be GetValue(_defaultValue_).

    c.  i.  

4.  ReturnIfAbrupt(_v_).

5.  Return the result of performing Binding Initialisation for
    _BindingIdentifier_ passing _v_ and _environment_ as arguments.


12.3 Empty Statement

Syntax

EmptyStatement :

;

Runtime Semantics

RUNTIME SEMANTICS: EVALUATION

_EmptyStatement_ : ;

1.  Return NormalCompletion(empty).


12.4 Expression Statement

Syntax

ExpressionStatement :

[lookahead ∉ {{, FUNCTION, CLASS }] Expression ;

NOTE An _ExpressionStatement_ cannot start with an opening curly brace
because that might make it ambiguous with a _Block_. Also, an
_ExpressionStatement_ cannot start with the FUNCTION or CLASS keywords
because that would make it ambiguous with a _FunctionDeclaration_, a
_GeneratorDeclaration_, or a _ClassDeclaration_.

Runtime Semantics

RUNTIME SEMANTICS: EVALUATION

_ExpressionStatement_ : [lookahead ∉ {{, FUNCTION, CLASS }]
_Expression_;


12.5 The if Statement

Syntax

IfStatement :

IF ( Expression ) Statement ELSE Statement
IF ( Expression ) Statement

Each ELSE for which the choice of associated IF is ambiguous shall be
associated with the nearest possible IF that would otherwise have no
corresponding ELSE.

STATIC SEMANTICS: VARDECLAREDNAMES

_IfStatement_ : IF ( _Expression_ ) _Statement_ ELSE _Statement

1.  Let _names_ be VarDeclaredNames of the first _Statement_.

2.  Append to _names_ the elements of the VarDeclaredNames of the second
    _Statement._

3.  Return _names_.

_IfStatement_ : IF ( _Expression_ ) _Statement 

1.  Return the VarDeclaredNames of _Statement_.

Runtime Semantics

RUNTIME SEMANTICS: EVALUATION

_IfStatement_ : IF ( _Expression_ ) _Statement_ ELSE _Statement

1.  

_IfStatement_ : IF ( _Expression_ ) _Statement


12.6 Iteration Statements

Syntax

IterationStatement :

DO Statement WHILE ( Expression )
WHILE ( Expression ) Statement
FOR (ExpressionNoIn~opt~; Expression~opt~ ; Expression~opt~ ) Statement
FOR ( VAR VariableDeclarationListNoIn; Expression~opt~ ; Expression~opt~
) Statement
FOR ( LexicalDeclarationNoIn; Expression~opt~ ; Expression~opt~ )
Statement
FOR ( LeftHandSideExpression IN Expression ) Statement
FOR ( VAR ForBinding IN Expression ) Statement
FOR ( ForDeclaration IN Expression ) Statement
FOR ( LeftHandSideExpression OF AssignmentExpression ) Statement
FOR ( VAR ForBinding OF AssignmentExpression ) Statement
FOR ( ForDeclaration OF AssignmentExpression ) Statement

ForDeclaration :

LetOrConst ForBinding

NOTE 1 _ForBinding_ is defined in 11.1.4.2.

NOTE 2 A semicolon is not required after a DO-WHILE statement.

RUNTIME SEMANTICS

RUNTIME SEMANTICS: LOOPCONTINUES ABSTRACT OPERATION

The abstract operation LoopContinues with arguments _completion_ and
_labelSet_ is defined by the following step:

NOTE Within the _Statement_ part of an _IterationStatement_ a
_ContinueStatement_ may be used to begin a new iteration.

12.6.1 The do-while Statement

STATIC SEMANTICS: VARDECLAREDNAMES

_IterationStatement_ : DO _Statement_ WHILE ( _Expression_ )

1.  Return the VarDeclaredNames of _Statement_.

Runtime Semantics

RUNTIME SEMANTICS: LABELLED EVALUATION

  With argument _labelSet_.

_IterationStatement_ : DO _Statement_ WHILE ( _Expression_ )

1.  Let _V_ = UNDEFINED.

2.  3.  Repeat

    a.  Let _stmt_ be the result of evaluating _Statement_.

    b.  If _stmt_.[[value]] is not empty, let _V_ = _stmt_.[[value]]_._

    c.  i.  

    d.  If _stmt_ is an abrupt completion and LoopContinues
        (_stmt_,_labelSet_) is FALSE, return _stmt_.

    e.  Let _exprRef_ be the result of evaluating _Expression_.

    f.  Let _exprValue_ be ToBoolean(GetValue(_exprRef_)).

    g.  If _exprValue_ is FALSE, Return NormalCompletion(_V_).

    h.  Else if _exprValue_ is not TRUE, then

        i.  Assert: _exprValue_ is an abrupt completion.

        ii. If LoopContinues (_exprValue_,_labelSet_) is FALSE, return
              _exprValue._

12.6.2 The while Statement

STATIC SEMANTICS: VARDECLAREDNAMES

_IterationStatement_ : WHILE ( _Expression_ ) _Statement

1.  Return the VarDeclaredNames of _Statement_.

Runtime Semantics

RUNTIME SEMANTICS: LABELLED EVALUATION

  With argument _labelSet_.

_IterationStatement_ : WHILE ( _Expression_ ) _Statement

12.6.3 The for Statement

Static Semantics

STATIC SEMANTICS: VARDECLAREDNAMES

_IterationStatement_ : FOR (_ExpressionNoIn_~opt~ ; _Expression_~opt~ ;
_Expression_~opt~) _Statement

1.  Return the VarDeclaredNames of _Statement_.

_IterationStatement_ : FOR ( VAR _VariableDeclarationListNoIn_ ;
_Expression_~opt~ ; _Expression_~opt~ ) _Statement

1.  Let _names_ be BoundNames of _VariableDeclarationListNoIn_.

2.  Append to _names_ the elements of the VarDeclaredNames of
    _Statement._

3.  Return _names_.

_IterationStatement_ : FOR (_LexicalDeclarationNoIn_; _Expression_~opt~
; _Expression_~opt~) _Statement_

1.  Return the VarDeclaredNames of _Statement_.

Runtime Semantics

RUNTIME SEMANTICS: LABELLED EVALUATION

  With argument _labelSet_.

_IterationStatement_ : FOR (_ExpressionNoIn_~opt~ ; _Expression_~opt~ ;
_Expression_~opt~) _Statement

1.  2.  a.  i.  ii. iii. iv. 

    b.  c.  d.  e.  f.  g.  i.  ii. iii. 

_IterationStatement_ : FOR ( VAR _VariableDeclarationListNoIn_ ;
_Expression_~opt~ ; _Expression_~opt~ ) _Statement

_IterationStatement_ : FOR ( _LexicalDeclarationNoIn_ ;
_Expression_~opt~ ; _Expression_~opt~ ) _Statement

1.  Let _oldEnv_ be the running execution context’s LexicalEnvironment.

2.  Let _loopEnv_ be the result of calling NewDeclarativeEnvironment
    passing _oldEnv_ as the argument.

3.  Let _isConst_ be the result of performing IsConstantDeclaration of
    _LexicalDeclarationNoIn_.

4.  For each element _dn_ of the BoundNames of _LexicalDeclarationNoIn
    do

    a.  If _isConst_ is TRUE, then

        i.  Call _loopEnv_’s CreateImmutableBinding concrete method
            passing _dn_ as the argument.

    b.  Else,

        i.  Call _loopEnv_’s CreateMutableBinding concrete method
            passing _dn_ and FALSE as the arguments.

5.  Set the running execution context’s LexicalEnvironment to _loopEnv_.

6.  Let _forDcl_ be the result of evaluating _LexicalDeclarationNoIn_.

7.  If LoopContinues(_forDcl_,_labelSet_) is FALSE, then

    a.  Set the running execution context’s LexicalEnvironment to
        _oldEnv_.

    b.  Return _forDcl_.

8.  Let _bodyResult_ be the result of performing For Body Evaluation
    with the first _Expression_ as the _testExpr_ argument, the second
    _Expression_ as the _incrementExpr_ argument, _Statement_ as the
    _stmt_ argument, and with _labelSet_.

9.  Set the running execution context’s LexicalEnvironment to _oldEnv_.

10. Return _bodyResult_.

RUNTIME SEMANTICS: FOR BODY EVALUATION ABSTRACT OPERATION

The abstract operation For Body Evaluation with arguments _testExpr_,
_incrementExpr_, _stmt_, and _labelSet_ is performed as follows:

1.  Let _V_ = UNDEFINED.

2.  Repeat

    a.  If _testExpr_ is not [empty], then

        i.  Let _testExprRef_ be the result of evaluating _testExpr_.

        ii. Let _testExprValue_ be ToBoolean(GetValue(_testExprRef_))

        iii. If _testExprValue_ is FALSE, return NormalCompletion(_V_).

        iv. Else if LoopContinues (_testExprValue_,_labelSet_) is FALSE,
            return _testExprValue._

    b.  Let _result_ be the result of evaluating _stmt_.

    c.  If _result_.[[value]] is not empty, let _V_ =
        _result_.[[value]].

    d.  If LoopContinues (_result_,_labelSet_) is FALSE, return
        _result_.

    e.  If _incrementExpr_ is not [empty], then

        i.  Let _incExprRef_ be the result of evaluating
            _incrementExpr_.

        ii. Let _incExprValue_ be GetValue(_incExprRef_).

        iii. If LoopContinues(_incExprValue_,_labelSet_) is FALSE,
            return _incExprValue._

12.6.4 The for-in and for-of Statements

Static Semantics

STATIC SEMANTICS: EARLY ERRORS

_IterationStatement_ :

  FOR (_LeftHandSideExpression_ IN _Expression_ ) _Statement_

  FOR (_LeftHandSideExpression_ OF _AssignmentExpression_ ) _Statement_

-   It is a Syntax Error _LeftHandSideExpression_ is either an
    _ObjectLiteral_ or an _ArrayLiteral_ and if the lexical token
    sequence matched by _LeftHandSideExpression_ cannot be parsed with
    no tokens left over using _AssignmentPattern_ as the goal symbol.

-   If _LeftHandSideExpression_ is either an _ObjectLiteral_ or an
    _ArrayLiteral_ and if the lexical token sequence matched by
    _LeftHandSideExpression_ can be parsed with no tokens left over
    using _AssignmentPattern_ as the goal symbol then the following
    rules are not applied. Instead, the Early Error rules for
    _AssignmentPattern_ are used.

-   It is a Syntax Error if the _LeftHandSideExpression_ is an
    _Identifier_ that can be statically determined to always resolve to
    a declarative environment record binding and the resolved binding is
    an immutable binding.

-   It is a Syntax Error if _LeftHandSideExpression_ is neither an
    _ObjectLiteral_ nor an _ArrayLiteral_ and
    IsValidSimpleAssignmentTarget of _LeftHandSideExpression_ is FALSE.

-   -   -   It is a Syntax Error if the _LeftHandSideExpression_ is
    _CoverParenthesisedExpressionAndArrowParameterList_ : ( _Expression_
    )
    and _Expression_ derived a production that would produce a Syntax
    Error according to these rules. This rule is recursively applied.

-   -   

_IterationStatement_ :

  FOR (_ForDeclaration_ IN _Expression_ ) _Statement_

  FOR (_ForDeclaration_ OF _AssignmentExpression_ ) _Statement_

-   It is a Syntax Error if any element of the BoundNames of
    _ForDeclaration_ also occurs in the VarDeclaredNames of _Statement_.

STATIC SEMANTICS: BOUNDNAMES

1.  

1.  

_ForDeclaration_ : _LetOrConst ForBinding 

1.  Return the BoundNames of _ForBinding_.

1.  

1.  

STATIC SEMANTICS: VARDECLAREDNAMES

_IterationStatement_ : FOR ( _LeftHandSideExpression_ IN _Expression_ )
_Statement

1.  Return the VarDeclaredNames of _Statement_.

_IterationStatement_ : FOR ( VAR _ForBinding_ IN _Expression_ )
_Statement

1.  Let _names_ be the BoundNames of _ForBinding_.

2.  Append to _names_ the elements of the VarDeclaredNames of
    _Statement._

3.  Return _names

_IterationStatement_ : FOR ( _ForDeclaration_ IN _Expression_ )
_Statement

1.  Return the VarDeclaredNames of _Statement_.

_IterationStatement_ : FOR ( _LeftHandSideExpression_ OF
_AssignmentExpression_ ) _Statement

1.  Return the VarDeclaredNames of _Statement_.

_IterationStatement_ : FOR ( VAR _ForBinding_ OF _AssignmentExpression
) _Statement_

1.  Let _names_ be the BoundNames of _ForBinding_.

2.  Append to _names_ the elements of the VarDeclaredNames of
    _Statement._

3.  Return _names

_IterationStatement_ : FOR ( _ForDeclaration_ OF _AssignmentExpression
) _Statement_

1.  Return the VarDeclaredNames of _Statement_.

Runtime Semantics

RUNTIME SEMANTICS: BINDING INSTANTIATION

  With arguments _value_ and _environment_.

_ForDeclaration_ : _LetOrConst ForBinding 

1.  For each element _name_ of the BoundNames of _ForBinding_ do

    a.  If IsConstantDeclaration of _LetOrConst_ is FALSE, then

        i.  Call _environment_’s CreateMutableBinding concrete method
            with argument _name_.

    b.  Else,

        i.  Call _environment_’s CreateImmutableBinding concrete method
            with argument _name_.

2.  Return the result of performing Binding Initialisation for
    _ForBinding_ passing _value_ and _environment_ as the arguments.

1.  

1.  

1.  

1.  

RUNTIME SEMANTICS: LABELLED EVALUATION

  With argument _labelSet_.

_IterationStatement_ : FOR ( _LeftHandSideExpression_ IN _Expression_ )
_Statement

1.  Let _keyResult_ be the result of performing For In/Of Expression
    Evaluation with _Expression_, enumerate, and _labelSet_.

2.  ReturnIfAbrupt(_keyResult_).

3.  Return the result of performing For In/Of Body Evaluation with
    _LeftHandSideExpression_, _Statement_, _keyResult_, assignment, and
    _labelSet_.

_IterationStatement_ : FOR ( VAR _ForBinding_ IN _Expression_ )
_Statement

_IterationStatement_ : FOR (_ForDeclaration_ IN _Expression_ )
_Statement

1.  Let _keyResult_ be the result of performing For In/Of Expression
    Evaluation with _Expression_, enumerate, and _labelSet_.

2.  ReturnIfAbrupt(_keyResult_).

3.  Return the result of performing For In/Of Body Evaluation with
    _ForDeclaration_, _Statement_, _keyResult_, lexicalBinding, and
    _labelSet_.

_IterationStatement_ : FOR ( _LeftHandSideExpression_ OF
_AssignmentExpression_ ) _Statement

1.  Let _keyResult_ be the result of performing For In/Of Expression
    Evaluation with _AssignmentExpression_, iterate, and _labelSet_.

2.  ReturnIfAbrupt(_keyResult_).

3.  Return the result of performing For In/Of Body Evaluation with
    _LeftHandSideExpression_, _Statement_, _keyResult_, assignment, and
    _labelSet_.

_IterationStatement_ : FOR ( VAR _ForBinding_ OF _AssignmentExpression
) _Statement_

1.  Let _keyResult_ be the result of performing For In/Of Expression
    Evaluation with _AssignmentExpression_, iterate, and _labelSet_.

2.  ReturnIfAbrupt(_keyResult_).

3.  Return the result of performing For In/Of Body Evaluation with
    _ForBinding_, _Statement_, _keyResult_, varBinding, and _labelSet_.

_IterationStatement_ : FOR (_ForDeclaration_ OF _AssignmentExpression_ )
_Statement

1.  Let _keyResult_ be the result of performing For In/Of Expression
    Evaluation with _AssignmentExpression_, iterate, and _labelSet_.

2.  ReturnIfAbrupt(_keyResult_).

3.  Return the result of performing For In/Of Body Evaluation with
    _ForDeclaration_, _Statement_, _keyResult_, lexicalBinding, and
    _labelSet_.

RUNTIME SEMANTICS: FOR IN/OF EXPRESSION EVALUATION ABSTRACT OPERATION

The abstract operation For In/Of Expression Evaluation is called with
arguments _expr_, _iterationKind_, and _labelSet_. The value of
_iterationKind_ is either ENUMERATE or ITERATE.

1.  Let _exprRef_ be the result of evaluating the production that is
    _expr_.

2.  Let _experValue_ be GetValue(_exprRef_).

3.  If _experValue_ is an abrupt completion,

    a.  If LoopContinues(_experValue_,_labelSet_) is FALSE, then return
        _experValue_.

    b.  Else, return Completion {[[type]]: break, [[value]]: empty,
        [[target]]: empty}.

4.  If _experValue_.[[value]] is NULL or UNDEFINED, return Completion
    {[[type]]: break, [[value]]: empty, [[target]]: empty}.

5.  Let _obj_ be ToObject(_experValue_).

6.  If _iterationKind_ is enumerate, then

    a.  Let _keys_ be the result of calling the [[Enumerate]] internal
        method of _obj_ with no arguments.

7.  Else,

    a.  Assert _iterationKind_ is iterate.

    b.  Let _iterator_ be the result of performing Invoke with arguments
        _obj_, @@iterator and an empty List.

    c.  Let _keys_ be ToObject(_iterator_).

    d.  

8.  If _keys_ is an abrupt completion, then

    a.  If LoopContinues(_experValue_,_labelSet_) is FALSE, then return
        _experValue_.

    b.  Assert: _keys_.[[type]] is continue

    c.  Return Completion {[[type]]: break, [[value]]: empty,
        [[target]]: empty}.

9.  Return _keys_.

RUNTIME SEMANTICS: FOR IN/OF BODY EVALUATION ABSTRACT OPERATION

The abstract operation For In/Of Body Evaluation is called with
arguments _lhs_, _stmt,_ _keys,_ _lhsKind_, and _labelSet._ The value of
_lhsKind_ is either ASSIGNMENT, VARBINDING or LEXICALBINDING.

1.  Let _oldEnv_ be the running execution context’s LexicalEnvironment.

2.  Let _noArgs_ be an empty List.

3.  Let _V_ = UNDEFINED .

4.  Repeat

    a.  Let _nextResult_ be the result of Invoke(_keys_, "NEXT").

    b.  ReturnIfAbrupt(_nextResult_).

    c.  If Type(_nextResult_) is not Object, then throw a TYPEERROR
        exception.

    d.  Let _done_ be IteratorComplete(_innerResult_).

    e.  ReturnIfAbrupt(_done_).

    f.  If _done_ is TRUE, then return NormalCompletion(_V_).

    g.  Let _nextValue_ be the result of IteratorValue(_nextResult_).

    h.  ReturnIfAbrupt(_nextValue_).

    i.  j.  k.  l.  m.  n.  If _lhsKind_ is assignment, then

        i.  Assert: _lhs_ is a _LeftHandSideExpression_.

        ii. If _lhs_ is neither an _ObjectLiteral_ nor an _ArrayLiteral_
            then

            1.  2.  Let _lhsRef_ be the result of evaluating _lhs_ ( it
                may be evaluated repeatedly).

            3.  Let _status_ be the result of performing
                PutValue(_lhsRef_, _nextValue_).

        iii. Else

            1.  Let _AssignmentPattern_ be the parse of the source code
                corresponding to _lhs_ using _AssignmentPattern_ as the
                goal symbol.

            2.  Let _rval_ be ToObject(_nextValue_).

            3.  If _rval_ is an abrupt completion, then let _status_ be
                _rval_.

            4.  Else, let _status_ be the result of performing
                Destructuring Assignment Evaluation of
                _AssignmentPattern_ using _rval_ as the argument.

    o.  Else if _lhsKind_ is varBinding, then

        i.  Assert: _lhs_ is a _ForBinding_.

        ii. Let _status_ be the result of performing Binding
            Initialisation for _lhs_ passing _nextValue_ and UNDEFINED
            as the arguments.

    p.  Else,

        i.  Assert _lhsKind_ is lexicalBinding.

        ii. Assert: _lhs_ is a _ForDeclaration_.

        iii. Let _iterationEnv_ be the result of calling
            NewDeclarativeEnvironment passing _oldEnv_ as the argument.

        iv. Perform Binding Instantiation for _lhs_ passing _nextValue_
            and _iterationEnv_ as arguments.

        v.  Let _status_ be NormalCompletion(empty)

        vi. Set the running execution context’s LexicalEnvironment to
            _iterationEnv_.

    q.  If _status_.[[type]] is normal, then

        i.  Let _status_ be the result of evaluating _stmt_.

        ii. If _status_.[[type]] is normal and _status_.[[value]] is not
            empty, then

            1.  Let _V_ = _status_.[[value]].

    r.  Set the running execution context’s LexicalEnvironment to
        _oldEnv_.

    s.  If _status_ is an abrupt completion and
        LoopContinues(_status_,_labelSet_) is FALSE, then return
        _status_.

        1.  2.  a.  


12.7 The continue Statement

Syntax

ContinueStatement :

CONTINUE ;
CONTINUE [no LineTerminator here] Identifier;

Static Semantics

STATIC SEMANTICS: EARLY ERRORS

_ContinueStatement_ : CONTINUE ;

-   It is a Syntax Error if this production is not nested, directly or
      indirectly (but not crossing function boundaries), within an
      _IterationStatement_.

_ContinueStatement_ : CONTINUE [no _LineTerminator_ here] _Identifier_;

-   It is a Syntax Error if _Identifier_ does not appear in the
      _CurrentLabelSet_ of an enclosing (but not crossing function
      boundaries) _IterationStatement_.

Runtime Semantics

RUNTIME SEMANTICS: EVALUATION

_ContinueStatement_ : CONTINUE ;

_ContinueStatement_ : CONTINUE [no _LineTerminator_ here] _Identifier_;

1.  Return Completion {[[type]]: continue, [[value]]: empty, [[target]]:
    _Identifier_}.


12.8 The break Statement

Syntax

BreakStatement :

BREAK ;
BREAK [no LineTerminator here] Identifier ;

Static Semantics

STATIC SEMANTICS: EARLY ERRORS

_BreakStatement_ : BREAK ;

-   It is a Syntax Error if this production is not nested, directly or
      indirectly (but not crossing function boundaries), within an
      _IterationStatement_ or a _SwitchStatement_.

_BreakStatement_ : BREAK [no _LineTerminator_ here] _Identifier_;

-   It is a Syntax Error if _Identifier_ does not appear in the
      _CurrentLabelSet_ of an enclosing (but not crossing function
      boundaries) _Statement_.

Runtime Semantics

RUNTIME SEMANTICS: EVALUATION

_BreakStatement_ : BREAK ;

_BreakStatement_ : BREAK [no _LineTerminator_ here] _Identifier_;


12.9 The return Statement

Syntax

ReturnStatement :

RETURN ;
RETURN [no LineTerminator here] Expression ;

NOTE A RETURN statement causes a function to cease execution and return
a value to the caller. If _Expression_ is omitted, the return value is
UNDEFINED. Otherwise, the return value is the value of _Expression_.

STATIC SEMANTICS

STATIC SEMANTICS: EARLY ERRORS

-   -   It is a Syntax Error if a RETURN statement is not within a
    _FunctionBody_ or a _GeneratorBody_.

Runtime Semantics

RUNTIME SEMANTICS: EVALUATION

_ReturnStatement_ : RETURN ;

_ReturnStatement_ : RETURN [no _LineTerminator_ here] _Expression_;

1.  Let _exprRef_ be the result of evaluating _Expression_.

2.  Let _exprValue_ be GetValue(_exprRef_).

3.  ReturnIfAbrupt(_exprValue_).

4.  Return Completion {[[type]]: return, [[value]]: _exprValue_,
    [[target]]: empty}.


12.10 The with Statement

Syntax

WithStatement :

WITH ( Expression ) Statement

NOTE The WITH statement adds an object environment record for a computed
object to the lexical environment of the running execution context. It
then executes a statement using this augmented lexical environment.
Finally, it restores the original lexical environment.

STATIC SEMANTICS

STATIC SEMANTICS: EARLY ERRORS

_WithStatement_ : WITH ( _Expression_ ) _Statement

-   It is a Syntax Error if the code that matches this production is
    contained in strict code.

STATIC SEMANTICS: VARDECLAREDNAMES

_WithStatement_ : WITH ( _Expression_ ) _Statement

1.  Return the VarDeclaredNames of _Statement_.

Runtime Semantics

RUNTIME SEMANTICS: EVALUATION

_WithStatement_ : WITH ( _Expression_ ) _Statement

NOTE No matter how control leaves the embedded _Statement_, whether
normally or by some form of abrupt completion or exception, the
LexicalEnvironment is always restored to its former state.


12.11 The switch Statement

Syntax

SwitchStatement :

SWITCH ( Expression ) CaseBlock

CaseBlock :

{ CaseClauses~opt~ }
{ CaseClauses~opt~ DefaultClause CaseClauses~opt~ }

CaseClauses :

CaseClause
CaseClauses CaseClause

CaseClause :

CASE Expression : StatementList~opt~

DefaultClause :

DEFAULT : StatementList~opt~

Static Semantics

STATIC SEMANTICS: EARLY ERRORS

_CaseBlock_ : { _CaseClauses_ }

-   It is a Syntax Error if the LexicallyDeclaredNames of _CaseClauses_
    contains any duplicate entries.

-   It is a Syntax Error if any element of the LexicallyDeclaredNames of
    _CaseClauses_ also occurs in the VarDeclaredNames of _CaseClauses_.

-   

STATIC SEMANTICS: LEXICALDECLARATIONS

_CaseBlock_ : { }

1.  Return a new empty List.

1.  

_CaseBlock_ : { _CaseClauses_~opt~ _DefaultClause CaseClauses_~opt~ }

1.  If the first _CaseClauses_ is present, let _declarations_ be the
    LexicalDeclarations of the first _CaseClauses_.

2.  Else let _declarations_ be a new empty List.

3.  Append to _declarations_ the elements of the LexicalDeclarations of
    the _DefaultClause._

4.  If the second _CaseClauses_ is not present, return _declarations_.

5.  Else return the result of appending to _declarations_ the elements
    of the LexicalDeclarations of the second _CaseClauses_.

1.  

_CaseClauses_ : _CaseClauses CaseClause

1.  Let _declarations_ be LexicalDeclarations of _CaseClauses_.

2.  Append to _declarations_ the elements of the LexicalDeclarations of
    _CaseClause._

3.  Return _declarations_.

_CaseClause_ : CASE _Expression_ : _StatementList_~opt~

1.  If the _StatementList_ is present, return the LexicalDeclarations of
    _StatementList_.

2.  Else return a new empty List.

_DefaultClause_ : DEFAULT : _StatementList_~opt~

1.  If the _StatementList_ is present, return the LexicalDeclarations of
    _StatementList_.

2.  Else return a new empty List.

STATIC SEMANTICS: LEXICALLYDECLAREDNAMES

_CaseBlock_ : { }

1.  Return a new empty List.

1.  

_CaseBlock_ : { _CaseClauses_~opt~ _DefaultClause CaseClauses_~opt~ }

1.  If the first _CaseClauses_ is present, let _names_ be the
    LexicallyDeclaredNames of the first _CaseClauses_.

2.  Else let _names_ be a new empty List.

3.  Append to _names_ the elements of the LexicallyDeclaredNames of the
    _DefaultClause._

4.  If the second _CaseClauses_ is not present, return _names_.

5.  Else return the result of appending to _names_ the elements of the
    LexicallyDeclaredNames of the second _CaseClauses_.

1.  

_CaseClauses_ : _CaseClauses CaseClause

1.  Let _names_ be LexicallyDeclaredNames of _CaseClauses_.

2.  Append to _names_ the elements of the LexicallyDeclaredNames of
    _CaseClause._

3.  Return _names_.

_CaseClause_ : CASE _Expression_ : _StatementList_~opt~

1.  If the _StatementList_ is present, return the LexicallyDeclaredNames
    of _StatementList_.

2.  Else return a new empty List.

_DefaultClause_ : DEFAULT : _StatementList_~opt~

1.  If the _StatementList_ is present, return the LexicallyDeclaredNames
    of _StatementList_.

2.  Else return a new empty List.

STATIC SEMANTICS: VARDECLAREDNAMES

_SwitchStatement_ : SWITCH ( _Expression_ ) _CaseBlock

1.  Return the VarDeclaredNames of _CaseBlock_.

_CaseBlock_ : { }

1.  Return a new empty List.

1.  

_CaseBlock_ : { _CaseClauses_~opt~ _DefaultClause CaseClauses_~opt~ }

1.  If the first _CaseClauses_ is present, let _names_ be the
    VarDeclaredNames of the first _CaseClauses_.

2.  Else let _names_ be a new empty List.

3.  Append to _names_ the elements of the VarDeclaredNames of the
    _DefaultClause._

4.  If the second _CaseClauses_ is not present, return _names_.

5.  Else return the result of appending to _names_ the elements of the
    VarDeclaredNames of the second _CaseClauses_.

1.  

_CaseClauses_ : _CaseClauses CaseClause

1.  Let _names_ be VarDeclaredNames of _CaseClauses_.

2.  Append to _names_ the elements of the VarDeclaredNames of
    _CaseClause._

3.  Return _names_.

_CaseClause_ : CASE _Expression_ : _StatementList_~opt~

1.  If the _StatementList_ is present, return the VarDeclaredNames of
    _StatementList_.

2.  Else return a new empty List.

_DefaultClause_ : DEFAULT : _StatementList_~opt~

1.  If the _StatementList_ is present, return the VarDeclaredNames of
    _StatementList_.

2.  Else return a new empty List.

Runtime Semantics

RUNTIME SEMANTICS: CASE BLOCK EVALUATION

1.  2.  3.  4.  5.  6.  7.  8.  

  With argument _input_.

_CaseBlock_ : { _CaseClauses_~opt~ }

1.  Let _V_ = UNDEFINED.

2.  Let _A_ be the list of _CaseClause_ items in source text order.

3.  Let _searching_ be TRUE.

4.  Repeat, while _searching_ is TRUE

    a.  Let _C_ be the next _CaseClause_ in _A_. If there is no such
        _CaseClause_, return NormalCompletion(_V_).

    b.  Let _clauseSelector_ be the result of evaluating _C_.

    c.  ReturnIfAbrupt(_clauseSelector_).

    d.  If _input_ is equal to _clauseSelector_ as defined by the Strict
        Equality Comparison Algorithm (11.9.1), then

        i.  Set _searching_ to FALSE.

        ii. If _C_ has a _StatementList_, then

            1.  Evaluate _C_’s _StatementList_ and let _R_ be the
                result.

            2.  ReturnIfAbrupt(_R_).

            3.  Let _V_ = _R_.[[value]].

5.  Repeat

    a.  Let _C_ be the next _CaseClause_ in _A_. If there is no such
        _CaseClause_, return NormalCompletion(_V_).

    b.  If _C_ has a _StatementList_, then

        i.  Evaluate _C_’s _StatementList_ and let _R_ be the result.

        ii. If _R_.[[value]] is not empty, then let _V_ = _R_.[[value]].

        iii. If _R_ is an abrupt completion, then return Completion
            {[[type]]: _R_.[[type]], [[value]]: _V_, [[target]]:
            _R_.[[target]]}.

_CaseBlock_ : { _CaseClauses_~opt~ _DefaultClause CaseClauses_~opt~ }

1.  Let _V_ = UNDEFINED.

2.  Let _A_ be the list of _CaseClause_ items in the first
    _CaseClauses_, in source text order.

3.  4.  Let _found_ be FALSE.

5.  Repeat letting _C_ be in order each _CaseClause_ in _A

    a.  If _found_ is FALSE, then

        i.  Let _clauseSelector_ be the result of Case Selector
            Evaluation of _C_.

        ii. If _clauseSelector_ is an abrupt completion, then

            1.  If _clauseSelector_.[[value]] is empty, then return
                Completion {[[type]]: _clauseSelector_.[[type]],
                [[value]]: UNDEFINED, [[target]]:
                _clauseSelector_.[[target]]}.

            2.  Else, return _clauseSelector_.

        iii. If _input_ is equal to _clauseSelector_ as defined by the
            Strict Equality Comparison Algorithm (11.9.1), then set
            _found_ to TRUE.

    b.  If _found_ is TRUE, then

        i.  ii. Evaluate _CaseClause_ _C_ and let _R_ be the result.

        iii. If _R_.[[value]] is not empty, then let _V_ =
            _R_.[[value]].

        iv. If _R_ is an abrupt completion, then return Completion
            {[[type]]: _R_.[[type]], [[value]]: _V_, [[target]]:
            _R_.[[target]]}.

6.  Let _foundInB_ be FALSE.

7.  If _found_ is FALSE, then

    a.  Let _B_ be a new list of the _CaseClause_ items in the second
        _CaseClauses_, in source text order.

    b.  Repeat, letting _C_ be in order each _CaseClause_ in _B_

        i.  If _foundInB_ is FALSE, then

            1.  2.  Let _clauseSelector_ be the result of Case Selector
                Evaluation of _C_.

            3.  If _clauseSelector_ is an abrupt completion, then

                a.  If _clauseSelector_.[[value]] is empty, then return
                    Completion {[[type]]: _clauseSelector_.[[type]],
                    [[value]]: UNDEFINED, [[target]]:
                    _clauseSelector_.[[target]]}.

                b.  Else, return _clauseSelector_.

            2.  If _input_ is equal to _clauseSelector_ as defined by
                the Strict Equality Comparison Algorithm (11.9.1), then

            3.  set _foundInB_ to TRUE.

        i.  If _foundInB_ is TRUE, then

6.  If _foundInB_ is TRUE, then return NormalCompletion(_V_).

7.  8.  Evaluate _DefaultClause_ and let _R_ be the result.

9.  If _R_.[[value]] is not empty, then let _V_ = _R_.[[value]].

10. If _R_ is an abrupt completion, then return Completion {[[type]]:
    _R_.[[type]], [[value]]: _V_, [[target]]: _R_.[[target]]}.

11. Let _B_ be a new list of the _CaseClause_ items in the second
    _CaseClauses_, in source text order.

12. Repeat, letting _C_ be in order each _CaseClause_ in _B_ (NOTE this
    is another complete iteration of the second _CaseClauses_)

    b.  c.  d.  Evaluate _CaseClause_ _C_ and let _R_ be the result.

    e.  If _R_.[[value]] is not empty, then let _V_ = _R_.[[value]].

    f.  If _R_ is an abrupt completion, then return Completion
        {[[type]]: _R_.[[type]], [[value]]: _V_, [[target]]:
        _R_.[[target]]}.

13. Return NormalCompletion(_V_).

RUNTIME SEMANTICS: CASE SELECTOR EVALUATION

_CaseClause_ : CASE _Expression_ : _StatementList_~opt~

NOTE Case Selector Evaluation does not execute the associated
_StatementList_. It simply evaluates the _Expression_ and returns the
value, which the _CaseBlock_ algorithm uses to determine which
_StatementList_ to start executing.

RUNTIME SEMANTICS: EVALUATION

_SwitchStatement_ : SWITCH ( _Expression_ ) _CaseBlock

1.  Let _exprRef_ be the result of evaluating _Expression_.

2.  Let _switchValue_ be GetValue(_exprRef_).

3.  ReturnIfAbrupt(_switchValue_).

4.  Let _oldEnv_ be the running execution context’s LexicalEnvironment.

5.  Let _blockEnv_ be the result of calling NewDeclarativeEnvironment
    passing _oldEnv_ as the argument.

6.  Perform Block Declaration Instantiation using _CaseBlock_ and
    _blockEnv_.

7.  Let _R_ be the result of performing Case Block Evaluation of
    _CaseBlock_ with argument _switchValue_.

8.  Set the running execution context’s LexicalEnvironment to _oldEnv_.

9.  10. Return _R_.

NOTE No matter how control leaves the _SwitchStatement_ the
LexicalEnvironment is always restored to its former state.

_CaseClause_ : CASE _Expression_ :

1.  Return NormalCompletion(empty).

_CaseClause_ : CASE _Expression_ : _StatementList

1.  Return the result of evaluating _StatementList_.

_DefaultClause_ : DEFAULT:

1.  Return NormalCompletion(empty).

_DefaultClause_ : DEFAULT: _StatementList

1.  Return the result of evaluating _StatementList_.


12.12 Labelled Statements

Syntax

LabelledStatement :

Identifier : Statement

NOTE A _Statement_ may be prefixed by a label. Labelled statements are
only used in conjunction with labelled BREAK and CONTINUE statements.
ECMAScript has no GOTO statement. A _Statement_ can be part of a
_LabelledStatement_, which itself can be part of a _LabelledStatement_,
and so on. The labels introduced this way are collectively referred to
as the “current label set” when describing the semantics of individual
statements. A _LabelledStatement_ has no semantic meaning other than the
introduction of a label to a _label set_. The label set of an
_IterationStatement_ or a _SwitchStatement_ initially contains the
single element EMPTY. The label set of any other statement is initially
empty.

Static Semantics

STATIC SEMANTICS: EARLY ERRORS

-   It is a Syntax Error if a _LabelledStatement_ is enclosed by a
    _LabelledStatement_ with the same _Identifier_ as the enclosed
    _LabelledStatement_. This does not apply to a _LabelledStatement_
    appearing within the body of a _FunctionDeclaration_ and a
    _LabelledStatement_ that encloses, directly or indirectly the
    _FunctionDeclaration_ .

STATIC SEMANTICS: VARDECLAREDNAMES

_LabelledStatement_ : _Identifier_ : _Statement

1.  Return the VarDeclaredNames of _Statement_.

Runtime Semantics

RUNTIME SEMANTICS: LABELLED EVALUATION

  With argument _labelSet_.

_LabelledStatement_ : _Identifier_ : _Statement

1.  Let _label_ be the StringValue of _Identifier_.

2.  Let _newLabelSet_ be a new List containing _label_ and the elements
    of _labelSet_.

3.  If _Statement_ is either _LabelledStatement_ or
    _BreakableStatement_, then

    a.  Let _stmtResult_ be the result of performing Labelled Evaluation
        of _Statement_ with argument _newLabelSet_.

4.  Else,

    a.  Let _stmtResult_ be the result of evaluating _Statement_.

5.  If _stmtResult_.[[type]] is BREAK and _stmtResult_.[[target]] is the
    same value as _label_, then

    a.  Let _result_ be NormalCompletion(_stmtResult_.[[value]]).

6.  Else,

    a.  Let _result_ be _stmtResult_.

7.  Return _result_.

RUNTIME SEMANTICS: EVALUATION

_LabelledStatement_ : _Identifier_ : _Statement

1.  Let _newLabelSet_ be a new empty List.

2.  Return the result of performing Labelled Evaluation of this
    _LabelledStatement_ with argument _newLabelSet_.


12.13 The throw Statement

Syntax

ThrowStatement :

THROW [no LineTerminator here] Expression ;

RUNTIME SEMANTICS: EVALUATION

The production _ThrowStatement_ : THROW [no _LineTerminator_ here]
_Expression_ ; is evaluated as follows:


12.14 The try Statement

Syntax

TryStatement :

TRY Block Catch~
~TRY Block Finally~
~TRY Block Catch Finally

Catch :

CATCH ( CatchParameter ) Block

Finally :

FINALLY Block

CatchParameter :

BindingIdentifier~
~BindingPattern

NOTE The TRY statement encloses a block of code in which an exceptional
condition can occur, such as a runtime error or a THROW statement. The
CATCH clause provides the exception-handling code. When a catch clause
catches an exception, its _CatchParameter_ is bound to that exception.

Static Semantics

STATIC SEMANTICS: EARLY ERRORS

_Catch_ : CATCH ( _CatchParameter_ ) _Block

-   It is a Syntax Error if any element of the BoundNames of
    _CatchParameter_ also occurs in the LexicallyDeclaredNames of
    _Block_.

-   It is a Syntax Error if any element of the BoundNames of
    _CatchParameter_ also occurs in the VarDeclaredNames of _Block_.

1.  

1.  

STATIC SEMANTICS: VARDECLAREDNAMES

_TryStatement_ : TRY _Block_ _Catch

1.  Let _names_ be VarDeclaredNames of _Block_.

2.  Append to _names_ the elements of the VarDeclaredNames of _Catch.

3.  Return _names_.

_TryStatement_ : TRY _Block_ _Finally

1.  Let _names_ be VarDeclaredNames of _Block_.

2.  Append to _names_ the elements of the VarDeclaredNames of _Finally.

3.  Return _names_.

_TryStatement_ : TRY _Block_ _Catch_ _Finally

1.  Let _names_ be VarDeclaredNames of _Block_.

2.  Append to _names_ the elements of the VarDeclaredNames of _Catch.

3.  Append to _names_ the elements of the VarDeclaredNames of _Finally.

4.  Return _names_.

_Catch_ : CATCH ( _CatchParameter_ ) _Block

1.  Return the VarDeclaredNames of _Block_.

Runtime Semantics

RUNTIME SEMANTICS: BINDING INITIALISATION

  With arguments _value_ and _environment_.

NOTE UNDEFINED is passed for _environment_ to indicate that a PutValue
operation should be used to assign the initialisation value. This is the
case for VAR statements formal parameter lists of non-strict functions.
In those cases a lexical binding is hosted and preinitialised prior to
evaluation of its initialiser.

1.  

_CatchParameter_: _BindingPattern

1.  Let _exceptionObj_ be ToObject(_value_).

2.  ReturnIfAbrupt(_exceptionObj_).

3.  Return the result of performing Binding Initialisation for
    _BindingPattern_ passing _exceptionObj_ and _environment_ as the
    arguments.

RUNTIME SEMANTICS: CATCH CLAUSE EVALUATION

with parameter _thrownValue_

_Catch_ : CATCH ( _CatchParameter_ ) _Block

1.  Let _oldEnv_ be the running execution context’s LexicalEnvironment.

2.  Let _catchEnv_ be the result of calling NewDeclarativeEnvironment
    passing _oldEnv_ as the argument.

3.  For each element _argName_ of the BoundNames of _CatchParameter_, do

    a.  Call the CreateMutableBinding concrete method of _catchEnv_
        passing _argName_ as the argument.

4.  Let _status_ be the result of performing Binding Initialisation for
    _CatchParameter_ passing _thrownValue_ and _catchEnv_ as arguments.

5.  ReturnIfAbrupt(_status_).

6.  Set the running execution context’s LexicalEnvironment to
    _catchEnv_.

7.  Let _B_ be the result of evaluating _Block_.

8.  Set the running execution context’s LexicalEnvironment to _oldEnv_.

9.  Return _B_.

NOTE No matter how control leaves the _Block_ the LexicalEnvironment is
always restored to its former state.

RUNTIME SEMANTICS: EVALUATION

_TryStatement_ : TRY _Block_ _Catch

_TryStatement_ : TRY _Block_ _Finally

_TryStatement_ : TRY _Block_ _Catch_ _Finally

1.  Let _B_ be the result of evaluating _Block_.

2.  If _B_.[[type]] is throw, then

    a.  Let _C_ be the result of performing Catch Clause Evaluation of
        _Catch_ with parameter _B_.value.

3.  Else _B_.[[type]] is not throw,

    a.  Let _C_ be _B_.

4.  Let _F_ be the result of evaluating _Finally_.

5.  If _F_.[[type]] is normal, return _C_.

6.  Return _F_.


12.15 The debugger statement

Syntax

DebuggerStatement :

DEBUGGER ;

RUNTIME SEMANTICS: EVALUATION

NOTE Evaluating the _DebuggerStatement_ production may allow an
implementation to cause a breakpoint when run under a debugger. If a
debugger is not present or active this statement has no observable
effect.

The production _DebuggerStatement_ : DEBUGGER ; is evaluated as follows:


13.1 Function Definitions

Syntax

FunctionDeclaration :

FUNCTION BindingIdentifier ( FormalParameters ) { FunctionBody }

FunctionExpression :

FUNCTION BindingIdentifier~opt~ ( FormalParameters ) { FunctionBody }

StrictFormalParameters :

FormalParameters

FormalParameters :

[empty]
FormalParameterList

FormalParameterList :

FunctionRestParameter
FormalsList
FormalsList, FunctionRestParameter

FormalsList :

FormalParameter
FormalsList , FormalParameter

FunctionRestParameter :

... BindingIdentifier

FormalParameter :

BindingElement

FunctionBody :

FunctionStatementList

FunctionStatementList :

StatementList~opt~

Supplemental Syntax

The following productions are used as an aid in specifying the semantics
of certain ECMAScript language features. They are not used when parsing
ECMAScript source code.

FunctionBody :

ThrowTypeError

ThrowTypeError :

[empty]

Static Semantics

STATIC SEMANTICS: EARLY ERRORS

_FunctionDeclaration_ : FUNCTION _BindingIdentifier_ (
_FormalParameters_ ) { _FunctionBody_ }
and
_FunctionExpression_ : FUNCTION _BindingIdentifier_~opt~ (
_FormalParameters_ ) { _FunctionBody_ }

-   It is a Syntax Error if _FunctionBody_ Contains _YieldExpression_ is
    TRUE.

-   -   -   -   It is a Syntax Error if IsSimpleParameterList of
    _FormalParameters_ is FALSE and any element of the BoundNames of
    _FormalParameters_ also occurs in the VarDeclaredNames of
    _FunctionBody_.

-   -   -   -   It is a Syntax Error if any element of the BoundNames of
    _FormalParameters_ also occurs in the LexicallyDeclaredNames of
    _FunctionBody_.

-   

NOTE The LexicallyDeclaredNames of a _FunctionBody_ does not include
identifiers bound using var or function declarations. Simple parameter
lists bind identifiers as VarDeclaredNames. Parameter lists that contain
destructuring patterns, default value initialisers, or a rest parameter
bind identifiers as LexicallyDeclaredNames.

_StrictFormalParameters_ : _FormalParameters 

-   It is a Syntax Error if BoundNames of _FormalParameterList_ contains
    any duplicate elements.

-   It is a Syntax Error if BoundNames of _FormalParameterList_ contains
    either ″EVAL″ or ″ARGUMENTS″.

_FormalParameters_ : _FormalParameterList 

-   It is a Syntax Error if _FormalParameters_ Contains
    _YieldExpression_ is TRUE.

-   It is a Syntax Error if IsSimpleParameterList of
    _FormalParameterList_ is FALSE and BoundNames of
    _FormalParameterList_ contains any duplicate elements.

-   It is a Syntax Error if IsSimpleParameterList of
    _FormalParameterList_ is FALSE and BoundNames of
    _FormalParameterList_ contains either ″EVAL″ or ″ARGUMENTS″.

-   It is a Syntax Error if the source code matching this production is
    strict code and BoundNames of _FormalParameterList_ contains any
    duplicate elements.

NOTE Multiple occurrences of the same _Identifier_ in a
_FormalParamterList_ is only allowed for non-strict functions and
generator functions that have simple parameter lists.

_FunctionStatementList_ : _StatementList 

-   It is a Syntax Error if the LexicallyDeclaredNames of
    _StatementList_ contains any duplicate entries.

-   It is a Syntax Error if any element of the LexicallyDeclaredNames of
    _StatementList_ also occurs in the VarDeclaredNames of
    _StatementList_.

-   -   -   -   -   -   -   

-   -   

_FormalParameter_ : _BindingElement

-   It is a Syntax Error if _BindingElement_ Contains _YieldExpression._

STATIC SEMANTICS: BOUNDNAMES

_FunctionDeclaration_ : FUNCTION _BindingIdentifier_ (
_FormalParameters_ ) { _FunctionBody_ }

1.  Return the BoundNames of _BindingIdentifier_.

FormalParameters : [empty]

1.  Return an empty List.

1.  

1.  

FormalParameterList : FormalsList , FunctionRestParameter

1.  Let _names_ be BoundNames of _FormalsList_.

2.  Append to _names_ the BoundNames of _FunctionRestParameter.

3.  Return _names_.

_FormalsList_ : _FormalsList ,_ _FormalParameter

1.  Let _names_ be BoundNames of _FormalsList_.

2.  Append to _names_ the elements of BoundNames of _FormalParameter.

3.  Return _names_.

1.  

1.  

STATIC SEMANTICS: CONTAINS

  With parameter _symbol_.

_FunctionDeclaration_ : FUNCTION _BindingIdentifier_ (
_FormalParameters_ ) { _FunctionBody_ }

1.  Return FALSE.

_FunctionExpression_ : FUNCTION _BindingIdentifier_~opt~ (
_FormalParameters_ ) { _FunctionBody_ }

1.  Return FALSE.

NOTE Static semantic rules that depend upon substructure generally do
not look into function definitions.

STATIC SEMANTICS: EXPECTEDARGUMENTCOUNT

FormalParameters : [empty]

1.  Return 0.

FormalParameterList :

FunctionRestParameter

1.  Return 0.

FormalParameterList :

FormalsList , FunctionRestParameter

1.  Return the ExpectedArgumentCount of _FormalsList_.

NOTE The ExpectedArgumentCount of a _FormalParameterList_ is the number
of _FormalParameters_ to the left of either the rest parameter or the
first _FormalParameter_ with an Initialiser. A _FormalParameter_ without
an initializer is allowed after the first parameter with an initializer
but such parameters are considered to be optional with UNDEFINED as
their default value.

_FormalsList_ : _FormalParameter

1.  If HasInitialiser of _FormalParameter_ is FALSE return 

2.  Return 1.

_FormalsList_ : _FormalsList,_ _FormalParameter

1.  Let _count_ be the ExpectedArgumentCount of _FormalsList.

2.  If HasInitialiser of _FormalsList_ is TRUE or HasInitialiser of
    _FormalParameter_ is TRUE, then return _count_.

3.  Return _count_+1.

STATIC SEMANTICS: HASINITIALISER

1.  

_FormalsList_ : _FormalsList ,_ _FormalParameter

1.  If HasInitialiser of _FormalsList_ is TRUE, then return TRUE.

2.  Return HasInitialiser of _FormalParameter_.

1.  

STATIC SEMANTICS: ISCONSTANTDECLARATION

_FunctionDeclaration_ : FUNCTION _BindingIdentifier_ (
_FormalParameters_ ) { _FunctionBody_ }

1.  Return FALSE.

STATIC SEMANTICS: ISSIMPLEPARAMETERLIST

FormalParameters : [empty]

1.  Return TRUE.

FormalParameterList : FunctionRestParameter

1.  Return FALSE.

FormalParameterList : FormalsList , FunctionRestParameter

1.  Return FALSE.

_FormalsList_ : _FormalsList ,_ _FormalParameter

1.  If IsSimpleParameterList of _FormalsList_ is FALSE, return FALSE.

2.  Return IsSimpleParameterList of _FormalParameter_.

_FormalParameter_ : _BindingElement

1.  If HasInitialiser of _BindingElement_ is TRUE, return FALSE.

2.  If _FormalParameter_ Contains _BindingPattern_ is TRUE, return
    FALSE.

3.  Return TRUE.

STATIC SEMANTICS: ISSTRICT

_FunctionStatementList_ : _StatementList_~opt~

1.  If this _FunctionStatementList_ is contained in strict code or if
    _StatementList_ is strict code, then return TRUE. Otherwise, return
    FALSE.

2.  

STATIC SEMANTICS: LEXICALLYDECLAREDNAMES

_FunctionDeclaration_ : FUNCTION _BindingIdentifier_ (
_FormalParameters_ ) { _FunctionBody_ }

1.  Return the BoundNames of _BindingIdentifier_.

FunctionStatementList : [empty]

1.  Return an empty List.

FunctionStatementList : StatementList

1.  Return TopLevelLexicallyDeclaredNames of _StatementList_.

1.  

STATIC SEMANTICS: VARDECLAREDNAMES

_FunctionDeclaration_ : FUNCTION _BindingIdentifier_ (
_FormalParameters_ ) { _FunctionBody_ }

1.  Return an empty List.

FunctionBody : [empty]

1.  Return an empty List.

FunctionBody : StatementList

1.  Return TopLevelVarDeclaredNames of _StatementList_.

Runtime Semantics

RUNTIME SEMANTICS: BINDING INITIALISATION

  With parameters _value_ and _environment_.

NOTE When UNDEFINED is passed for _environment_ it indicates that a
PutValue operation should be used to assign the initialisation value.
This is the case for formal parameter lists of non-strict functions. In
that case the formal parameter bindings are preinitialised in order to
deal with the possibility of multiple parameters with the same name.

FormalParameters : [empty]

1.  Return NormalCompletion(empty).

FormalParameterList : FunctionRestParameter

1.  Return the result of performing Indexed Binding Initialisation for
    _FunctionRestParameter_ using _value_, 0, and _environment_ as the
    arguments

2.  .

FormalParameterList : FormalsList

1.  2.  3.  Return the result of performing Indexed Binding
    Initialisation for _FormalsList_ using _value_, 0, and _environment_
    as the arguments.

4.  

FormalParameterList : FormalsList , FunctionRestParameter

1.  Let _restIndex_ be the result of performing Indexed Binding
    Initialisation for _FormalsList_ using _value_, 0, and _environment_
    as the arguments.

2.  ReturnIfAbrupt(_restIndex_).

3.  Return the result of performing Indexed Binding Initialisation for
    _FunctionRestParameter_ using _value_, _restIndex_, and
    _environment_ as the arguments.

RUNTIME SEMANTICS EVALUATEBODY

  With parameter _functionObject_.

_FunctionBody_ : _FunctionStatementList_~opt~

_FunctionBody_ : _ThrowTypeError

1.  Throw a TYPEERROR exception.

1.  

RUNTIME SEMANTICS: INDEXED BINDING INITIALISATION

  With parameters _array_, _nextIndex,_ and _environment_.

FormalsList : FormalParameter

1.  Let _status_ be the result of performing Indexed Binding
    Initialisation for _FormalParameter_ using _array_, _nextIndex_, and
    _environment_ as the arguments.

2.  ReturnIfAbrupt(_status_).

3.  Return _nextIndex_ + 1.

FormalsList : FormalsList , FormalParameter

1.  Let _lastIndex_ be the result of performing Indexed Binding
    Initialisation for _FormalsList_ using _array_, _nextIndex_, and
    _environment_ as the arguments.

2.  ReturnIfAbrupt(_lastIndex_).

3.  Let _status_ be the result of performing Indexed Binding
    Initialisation for _FormalParameter_ using _array_, _lastIndex_, and
    _environment_ as the arguments.

4.  ReturnIfAbrupt(_status_).

5.  Return _lastIndex_ + 1.

FunctionRestParameter : ... BindingIdentifier

1.  Assert: _array_ is a well formed arguments object and hence it has a
    valid integer valued "LENGTH" property.

2.  Let _status_ be the result of Get(_array_, "LENGTH").

3.  Let _argumentsLength_ be _status_.[[value]].

4.  Let _A_ be the result of the abstract operation ArrayCreate with
    argument 0.

5.  Let _n_=0;

6.  Repeat, while _nextIndex_ < _argumentsLength

    a.  Let _P_ be ToString(_nextIndex_).

    b.  Assert: _array_ is a well formed arguments object, hence it must
          have a property _P_.

    c.  Let _v_ be the result of Get(_array_, _P_).

    d.  Call the [[DefineOwnProperty]] internal method of _A_ with
          arguments ToString(_n_) and Property Descriptor {[[Value]]:
          _v_.[[value]], [[Writable]]: TRUE, [[Enumerable]]: TRUE,
          [[Configurable]]: TRUE}.

    e.  Let _n_ = _n_+1.

    f.  Let _nextIndex_ = _nextIndex_ +1.

7.  Return the result of performing Binding Initialisation for
    _BindingIdentifier_ using _A_ and _environment_ as arguments.

1.  

RUNTIME SEMANTICS: INSTANTIATEFUNCTIONOBJECT

  With parameter _scope_.

_FunctionDeclaration_ : FUNCTION _BindingIdentifier_ (
_FormalParameters_ ) { _FunctionBody_ }

1.  If the _FunctionDeclaration_ is contained in strict code or if its
    _FunctionBody_ is strict code, then let _strict_ be TRUE. Otherwise
    let _strict_ be FALSE.

2.  3.  Let _F_ be the result of performing the FunctionCreate abstract
    operation with arguments Normal, _FormalParameters_, _FunctionBody,
    scope_, and _strict_.

4.  Perform the abstract operation MakeConstructor with argument _F_.

5.  Return _F_.

RUNTIME SEMANTICS: EVALUATION

_FunctionDeclaration_ : FUNCTION _BindingIdentifier_ (
_FormalParameters_ ) { _FunctionBody_ }

1.  Return NormalCompletion(empty)

_FunctionExpression_ : FUNCTION ( _FormalParameters_ ) { _FunctionBody
}

1.  If the _FunctionExpression_ is contained in strict code or if its
    _FunctionBody_ is strict code, then let _strict_ be TRUE. Otherwise
    let _strict_ be FALSE.

2.  Let _scope_ be the LexicalEnvironment of the running execution
    context.

3.  Let _closure_ be the result of performing the FunctionCreate
    abstract operation with arguments Normal, _FormalParameters_,
    _FunctionBody, scope_, and _strict_.

4.  Perform the abstract operation MakeConstructor with argument
    _closure_.

5.  Return _closure_.

_FunctionExpression_ : FUNCTION _BindingIdentifier_ ( _FormalParameters
) { _FunctionBody_ }

NOTE 1 The _BindingIdentifier_ in a _FunctionExpression_ can be
referenced from inside the _FunctionExpression's_ _FunctionBody_ to
allow the function to call itself recursively. However, unlike in a
_FunctionDeclaration_, the _BindingIdentifier_ in a _FunctionExpression
cannot be referenced from and does not affect the scope enclosing the
_FunctionExpression_.

NOTE 2 A PROTOTYPE property is automatically created for every function
defined using a _FunctionDeclaration_ or _FunctionExpression_, to allow
for the possibility that the function will be used as a constructor.


13.2 Arrow Function Definitions

Syntax

ArrowFunction :

ArrowParameters => ConciseBody

ArrowParameters :

BindingIdentifier
CoverParenthesisedExpressionAndArrowParameterList

ConciseBody :

[lookahead ∉ { { }] AssignmentExpression
{ FunctionBody }

Supplemental Syntax

When processing the production _ArrowParameters_ :
_CoverParenthesisedExpressionAndArrowParameterList_ the following
grammar is used to refine the interpretation of
_CoverParenthesisedExpressionAndArrowParameterList_.

ArrowFormalParameters :

( StrictFormalParameters )

Static Semantics

STATIC SEMANTICS: EARLY ERRORS

_ArrowFunction_ : _ArrowParameters_ _=>_ _ConciseBody

-   It is a Syntax Error if any element of the BoundNames of
    _ArrowParameters_ also occurs in the VarDeclaredNames of
    _ConciseBody_.

-   -   -   -   -   It is a Syntax Error if any element of the
    BoundNames of _ArrowParameters_ also occurs in the
    LexicallyDeclaredNames of _ConciseBody_.

-   

_ArrowParameters_ : _BindingIdentifier

-   It is a Syntax Error if the StringValue of the sole element of the
    BoundNames of _BindingIdentifier_ is EVAL or ARGUMENTS.

-   

_ArrowParameters_ : _CoverParenthesisedExpressionAndArrowParameterList

-   It is a Syntax Error if the lexical token sequence matched by
    _CoverParenthesisedExpressionAndArrowParameterList_ cannot be parsed
    with no tokens left over using _ArrowFormalParameters_ as the goal
    symbol.

-   It is a Syntax Error if any early errors are present for
    CoveredFormalsList of
    _CoverParenthesisedExpressionAndArrowParameterList_.

-   

_ConciseBody_ : [lookahead ∉ { { }] _AssignmentExpression

-   It is a Syntax Error if _AssignmentExpression_ Contains
    _YieldExpression_.

STATIC SEMANTICS: BOUNDNAMES

_ArrowParameters_ : _CoverParenthesisedExpressionAndArrowParameterList

1.  Let _formals_ be CoveredFormalsList of
    _CoverParenthesisedExpressionAndArrowParameterList_.

2.  Return the BoundNames of _formals_.

1.  

1.  

1.  

1.  

1.  

1.  2.  3.  

1.  

STATIC SEMANTICS: CONTAINS

  With parameter _symbol_.

_ArrowFunction_ : _ArrowParameters =>_ _ConciseBody

1.  If _symbol_ is neither SUPER or THIS, then return FALSE.

2.  If _ArrowParameters_ Contains _symbol_ is TRUE, return TRUE;

3.  Return _ConciseBody_ Contains _symbol_ .

NOTE Normally, Contains does not look inside most function forms
However, Contains is used to detect THIS and SUPER usage within an
_ArrowFunction_.

_ArrowParameters_ : _CoverParenthesisedExpressionAndArrowParameterList

1.  Let _formals_ be CoveredFormalsList of
    _CoverParenthesisedExpressionAndArrowParameterList_.

2.  Return _formals_ Contains _symbol_.

STATIC SEMANTICS: COVEREDFORMALSLIST

_ArrowParameters_ : _BindingIdentifier

1.  Return _BindingIdentifier_.

CoverParenthesisedExpressionAndArrowParameterList :

( Expression )
( )
( ... Identifier )
( Expression , ... Identifier)

1.  Return the result of parsing the lexical token stream matched by
    _CoverParenthesisedExpressionAndArrowParameterList_ using
    _ArrowFormalParameters_ as the goal symbol.

STATIC SEMANTICS: EXPECTEDARGUMENTCOUNT

_ArrowParameters_ : _BindingIdentifier

1.  Return 1.

1.  

1.  

_ArrowParameters_ : _CoverParenthesisedExpressionAndArrowParameterList

1.  Let _formals_ be CoveredFormalsList of
    _CoverParenthesisedExpressionAndArrowParameterList_.

2.  Return the ExpectedArgumentCount of _formals_.

STATIC SEMANTICS: ISSIMPLEPARAMETERLIST

_ArrowParameters_ : _BindingIdentifier

1.  Return TRUE.

_ArrowParameters_ : _CoverParenthesisedExpressionAndArrowParameterList

1.  Let _formals_ be CoveredFormalsList of
    _CoverParenthesisedExpressionAndArrowParameterList_.

2.  Return the IsSimpleParameterList of _formals_.

STATIC SEMANTICS: LEXICALLYDECLAREDNAMES

ConciseBody : [lookahead ∉ { { }] AssignmentExpression

1.  Return an empty List.

Runtime Semantics

RUNTIME SEMANTICS: BINDING INITIALISATION

  With parameters _value_ and _environment_.

NOTE When UNDEFINED is passed for _environment_ it indicates that a
PutValue operation should be used to assign the initialisation value.
This is the case for formal parameter lists of non-strict functions. In
that case the formal parameter bindings are preinitialised in order to
deal with the possibility of multiple parameters with the same name.

_ArrowParameters_ : _BindingIdentifier

1.  Return the result of performing Binding Initialisation for
    _BindingIdentifier_ using _value_ and _environment_ as the
    arguments.

_ArrowParameters_ : _CoverParenthesisedExpressionAndArrowParameterList

1.  Let _formals_ be CoveredFormalsList of
    _CoverParenthesisedExpressionAndArrowParameterList_.

2.  Return the result of performing Binding Initialisation of _formals
    with arguments _value_ and _environment_.

RUNTIME SEMANTICS EVALUATEBODY

  With parameter _functionObject_.

ConciseBody : [lookahead ∉ { { }] AssignmentExpression

1.  The code of this _ConciseBody_ is strict mode code if it is
    contained in strict mode code or if any of the conditions in 10.1.1
    apply If the code of this _ConciseBody_ is strict mode code,
    _AssignmentExpression_ is evaluated in the following steps as strict
    mode code. Otherwise, _AssignmentExpression_ is evaluated in the
    following steps as non-strict mode code.

2.  Let _exprRef_ be the result of evaluating _AssignmentExpression_.

3.  Let _exprValue_ be GetValue(_exprRef_).

4.  If _exprValue_.[[type]] is return then return
    NormalCompletion(_exprValue_.[[value]]).

5.  ReturnIfAbrupt(_exprValue_).

6.  Return NormalCompletion(_exprValue_).

NOTE In the absence of extensions to this specification, the test is
step 4 will never be TRUE.

1.  

1.  

1.  

1.  

1.  2.  3.  

RUNTIME SEMANTICS: EVALUATION

_ArrowFunction_ : _ArrowParameters_ => _ConciseBody

1.  Let _strict_ be TRUE.

2.  Let _scope_ be the LexicalEnvironment of the running execution
    context.

3.  Let _parameters_ be CoveredFormalsList of _ArrowParameters_.

4.  Let _closure_ be the result of performing the FunctionCreate
    abstract operation with arguments Arrow, _parameters_, _ConciseBody,
    scope_, and _strict_.

5.  Return _closure_.

NOTE Even though an _ArrowFunction_ may contain references to SUPER, the
FunctionCreate call in step 3 is not passed the optional _homeObject_
and _methodName_ parameters. An _ArrowFunction_ that references SUPER is
always contained within a non-_ArrowFunction_ and the necessary state to
implement SUPER is accessible via the _scope_ that is captured by the
function object of the _ArrowFunction_.

1.  2.  3.  4.  5.  6.  


13.3 Method Definitions

Syntax

MethodDefinition :

PropertyName ( StrictFormalParameters ) { FunctionBody }
GeneratorMethod
GET PropertyName ( ) { FunctionBody }
SET PropertyName ( PropertySetParameterList ) { FunctionBody }

PropertySetParameterList :

BindingIdentifier
BindingPattern

NOTE The single element of a _PropertySetParameterList_ may not have a
default value _Initialiser_ because set accessor are always called with
an implicitly provided argument.

Static Semantics

STATIC SEMANTICS: EARLY ERRORS

-   -   -   -   -   -   -   

_MethodDefinition_ : _PropertyName_ ( _StrictFormalParameters_ ) {
_FunctionBody_ }

-   It is a Syntax Error if any element of the BoundNames of
    _StrictFormalParameters_ also occurs in the VarDeclaredNames of
    _FunctionBody_.

-   It is a Syntax Error if any element of the BoundNames of
    _StrictFormalParameters_ also occurs in the LexicallyDeclaredNames
    of _FunctionBody_.

-   -   -   

_MethodDefinition_ : SET _PropertyName_ ( _PropertySetParameterList_ ) {
_FunctionBody_ }

-   It is a Syntax Error if IsSimpleParameterList of
    _PropertySetParameterList_ is FALSE and any element of the
    BoundNames of _PropertySetParameterList_ also occurs in the
    VarDeclaredNames of _FunctionBody_.

-   It is a Syntax Error if IsSimpleParameterList of
    _PropertySetParameterList_ is FALSE and BoundNames of
    _PropertySetParameterList_ contains any duplicate elements.

-   It is a Syntax Error if IsSimpleParameterList of
    _PropertySetParameterList_ is FALSE and BoundNames of
    _PropertySetParameterList_ contains either ″EVAL″ or ″ARGUMENTS″.

-   It is a Syntax Error if BoundNames of _PropertySetParameterList_
    contains any duplicate elements.

-   It is a Syntax Error if any element of the BoundNames of
    _PropertySetParameterList_ also occurs in the LexicallyDeclaredNames
    of _FunctionBody_.

-   It is a Syntax Error if _PropertySetParameterList_ Contains
    _YieldExpression_.

-   

-   

1.  

1.  

STATIC SEMANTICS: EXPECTEDARGUMENTCOUNT

_PropertySetParameterList_ : _BindingIdentifier 

1.  Return 1.

_PropertySetParameterList_ : _BindingPattern 

1.  Return 1.

STATIC SEMANTICS: ISSIMPLEPARAMETERLIST

PropertySetParameterList : BindingIdentifier

1.  Return TRUE.

_PropertySetParameterList_ : _BindingPattern 

1.  Return FALSE.

STATIC SEMANTICS: PROPNAME

MethodDefinition :

PropertyName ( FormalParameters ) { FunctionBody }
GET PropertyName ( ) { FunctionBody }
SET PropertyName ( PropertySetParametcerList ) { FunctionBody }

1.  Return PropName of _PropertyName_.

1.  

1.  

1.  

STATIC SEMANTICS: REFERENCESSUPER

MethodDefinition :

PropertyName ( FormalParameters ) { FunctionBody

1.  If _FormalParameters_ Contains SUPER is TRUE, then return TRUE.

2.  Return _FunctionBody_ Contains SUPER.

MethodDefinition : GET PropertyName ( ) { FunctionBody }

1.  Return _FunctionBody_ Contains SUPER.

MethodDefinition : SET PropertyName ( PropertySetParameterList ) {
FunctionBody }

1.  If _PropertySetParameterList_ Contains SUPER is TRUE, then return
    TRUE.

2.  Return _FunctionBody_ Contains SUPER.

STATIC SEMANTICS: SPECIALMETHOD

_MethodDefinition_ : _PropertyName_ (_StrictFormalParameters_ ) {
_FunctionBody_ }

1.  Return FALSE.

MethodDefinition :

GeneratorMethod
GET PropertyName ( ) { FunctionBody }
SET PropertyName ( PropertySetParameterList ) { FunctionBody }

1.  Return TRUE.

Runtime Semantics

RUNTIME SEMANTICS: PROPERTY DEFINITION EVALUATION

  With parameter _object_ and optional parameter _functionPrototype_.

_MethodDefinition_ : _PropertyName_ (_StrictFormalParameters_ ) {
_FunctionBody_ }

1.  Let _propName_ be PropName of _PropertyName_.

2.  Let _strict_ be IsStrict of _FunctionBody_.

3.  Let _scope_ be the running execution context’s LexicalEnvironment.

4.  5.  6.  If ReferencesSuper of _MethodDefinition_ is TRUE, then

    a.  Let _closure_ be the result of performing the FunctionCreate
        abstract operation with arguments Method,
        _StrictFormalParameters_, _FunctionBody, scope_, and _strict_
        and with _object_ as the _homeObject_ optional argument and
        _propName_ as the _methodName_ optional argument. If
        _functionPrototype_ was passed as a parameter then also pass its
        value as the _functionPrototype_ optional argument of
        FunctionCreate.

7.  Else

    a.  Let _closure_ be the result of performing the FunctionCreate
        abstract operation with arguments Method,
        _StrictFormalParameters_, _FunctionBody, scope_, and _strict_.
        If _functionPrototype_ was passed as a parameter then also pass
        its value as the _functionPrototype_ optional argument of
        FunctionCreate.

8.  Let _desc_ be the Property Descriptor{[[Value]]: _closure_,
    [[Writable]]: TRUE, [[Enumerable]]: TRUE, [[Configurable]]: TRUE}.

9.  Let _status_ be the result of DefinePropertyOrThrow(_object_,
    _propName_ _desc_).

10. ReturnIfAbrupt(_status_).

11. NormalCompletion(closure).

_MethodDefinition_ : _GeneratorMethod

See 13.4.

1.  2.  3.  4.  5.  6.  a.  

7.  a.  

8.  9.  10. 11. 12. 

_MethodDefinition_ : GET _PropertyName_ ( ) { _FunctionBody_ }

1.  Let _propName_ be PropName of _PropertyName_.

2.  Let _strict_ be IsStrict of _FunctionBody_.

3.  Let _scope_ be the running execution context’s LexicalEnvironment.

4.  Let _formalParameterList_ be the production _FormalParameters_:
    [empty]

5.  6.  If ReferencesSuper of _MethodDefinition_ is TRUE, then

    a.  Let _closure_ be the result of performing the FunctionCreate
        abstract operation with arguments Method, _formalParameterList_,
        _FunctionBody, scope_, and _strict_ and with _object_ as the
        _homeObject_ optional argument and _propName_ as the
        _methodName_ optional argument.

7.  Else

    a.  Let _closure_ be the result of performing the FunctionCreate
        abstract operation with arguments Method, _formalParameterList_,
        _FunctionBody, scope_, and _strict_.

8.  9.  10. Let _desc_ be the Property Descriptor {[[Get]]: _closure_,
    [[Enumerable]]: TRUE, [[Configurable]]: TRUE}

11. Let _status_ be the result of calling the [[DefineOwnProperty]]
    internal method of _object_ with arguments _propName_ and _desc_.

12. ReturnIfAbrupt(_status_).

13. Return NormalCompletion(_closure_).

_MethodDefinition_ : SET _PropertyName_ ( _PropertySetParameterList_ ) {
_FunctionBody_ }

1.  Let _propName_ be PropName of _PropertyName_.

2.  Let _strict_ be IsStrict of _FunctionBody_.

3.  Let _scope_ be the running execution context’s LexicalEnvironment.

4.  5.  6.  If ReferencesSuper of _MethodDefinition_ is TRUE, then

    a.  Let _closure_ be the result of performing the FunctionCreate
        abstract operation with arguments Method,
        _PropertySetParameterList_, _FunctionBody, scope_, and _strict_
        and with _object_ as the _homeObject_ optional argument and
        _propName_ as the _methodName_ optional argument.

7.  Else

    a.  Let _closure_ be the result of performing the FunctionCreate
        abstract operation with arguments Method,
        _PropertySetParameterList_, _FunctionBody, scope_, and _strict_.

8.  9.  10. Let _desc_ be the Property Descriptor {[[Set]]: _closure_,
    [[Enumerable]]: TRUE, [[Configurable]]: TRUE}

11. Let _status_ be the result of DefinePropertyOrThrow(_object_,
    _propName_ _desc_).

12. ReturnIfAbrupt(_status_).

13. Return NormalCompletion(_closure_).


13.4 Generator Function Definitions

Syntax

GeneratorMethod :

* PropertyName (StrictFormalParameters) { FunctionBody }

GeneratorDeclaration :

FUNCTION * BindingIdentifier ( FormalParameters ) { FunctionBody }

GeneratorExpression :

FUNCTION * BindingIdentifier~opt~ ( FormalParameters ) { FunctionBody }

YieldExpression :

YIELD YieldDelegator~opt~ [Lexical goal InputElementRegExp]
AssignmentExpression

YieldDelegator :

*

Supplemental Syntax

The following productions are used as an aid in specifying the semantics
of certain ECMAScript language features. They are not used when parsing
ECMAScript source code.

GeneratorBody :

FunctionBody
Comprehension

Static Semantics

STATIC SEMANTICS: EARLY ERRORS

_GeneratorMethod_ : * _PropertyName_ (_StrictFormalParameters_) {
_FunctionBody_ }

and
_GeneratorDeclaration_ : FUNCTION * _BindingIdentifier_ (
_FormalParameters_ ) { _FunctionBody_ }
and
_GeneratorExpression_ : FUNCTION * _BindingIdentifier_~opt~ (
_FormalParameters_ ) { _FunctionBody_ }

-   -   It is a Syntax Error if _FunctionBody_ Contains
    _YieldExpression_ is FALSE_._

_GeneratorMethod_ : * _PropertyName_ (_StrictFormalParameters_ ) {
_FunctionBody_ }

-   It is a Syntax Error if any element of the BoundNames of
    _StrictFormalParameters_ also occurs in the VarDeclaredNames of
    _FunctionBody_.

-   It is a Syntax Error if any element of the BoundNames of
    _StrictFormalParameters_ also occurs in the LexicallyDeclaredNames
    of _FunctionBody_.

_GeneratorDeclaration_ : FUNCTION * _BindingIdentifier_ (
_FormalParameters_ ) { _FunctionBody_ }
and
_GeneratorExpression_ : FUNCTION * _BindingIdentifier_~opt~ (
_FormalParameters_ ) { _FunctionBody_ }

-   It is a Syntax Error if IsSimpleParameterList of _FormalParameters_
    is FALSE and any element of the BoundNames of _FormalParameters_
    also occurs in the VarDeclaredNames of _FunctionBody_.

-   It is a Syntax Error if any element of the BoundNames of
    _FormalParameters_ also occurs in the LexicallyDeclaredNames of
    _FunctionBody_.

_YieldExpression_ : YIELD _YieldDelegator_~opt~ _AssignmentExpression

-   It is a Syntax Error if _AssignmentExpression_ Contains
    _YieldExpression_.

STATIC SEMANTICS: BOUNDNAMES

_GeneratorDeclaration_ : FUNCTION * _BindingIdentifier_ (
_FormalParameters_ ) { _FunctionBody_ }

1.  Return the BoundNames of _BindingIdentifier_.

STATIC SEMANTICS: CONTAINS

  With parameter _symbol_.

_GeneratorDeclaration_ : FUNCTION * _BindingIdentifier_ (
_FormalParameters_) { _FunctionBody_ }

1.  Return FALSE.

_GeneratorExpression_ : FUNCTION * _BindingIdentifier_~opt~ (
_FormalParameters_ ) { _FunctionBody_ }

1.  Return FALSE.

NOTE Static semantic rules that depend upon substructure generally do
not look into function definitions.

STATIC SEMANTICS: ISCONSTANTDECLARATION

_GeneratorDeclaration_ : FUNCTION * _BindingIdentifier_ (
_FormalParameters_ ) { _FunctionBody_ }

1.  Return FALSE.

STATIC SEMANTICS: LEXICALLYDECLAREDNAMES

_GeneratorDeclaration_ : FUNCTION * _BindingIdentifier_ (
_FormalParameters_ ) { _FunctionBody_ }

1.  Return the BoundNames of _BindingIdentifier_.

STATIC SEMANTICS: PROPNAME

_GeneratorMethod_ : * _PropertyName_ ( _FormalParameters_ ) {
_FunctionBody_ }

1.  Return PropName of _PropertyName_.

STATIC SEMANTICS: REFERENCESSUPER

GeneratorMethod : * PropertyName ( FormalParameters ) { FunctionBody }

1.  If _FormalParameters_ Contains SUPER is TRUE, then return TRUE.

2.  Return _FunctionBody_ Contains SUPER.

STATIC SEMANTICS: VARDECLAREDNAMES

_GeneratorDeclaration_ : FUNCTION * _BindingIdentifier_ (
_FormalParameters_ ) { _FunctionBody_ }

1.  Return an empty List.

Runtime Semantics

NOTE: Abstract operations relating to generator objects are defined in
15.19.4.3.3.

RUNTIME SEMANTICS EVALUATEBODY

  With parameter _functionObject_.

_GeneratorBody_ : _FunctionBody

1.  Let _G_ be the THIS value.

2.  If Type(_G_) is not Object or if Type(_G_) is Object and _G_ does
    not have a [[GeneratorState]] internal data property, then

    a.  Let _G_ be the result of calling
        OrdinaryCreateFromConstructor(_functionObject_,
        "%GENERATORPROTOTYPE%", ( [[GeneratorState]],
        [[GeneratorContext]]) ).

    b.  ReturnIfAbrupt(_G_).

3.  Return the result of GeneratorStart(_G_, _FunctionBody_).

_GeneratorBody_ : _Comprehension 

1.  Let _G_ be the result of ObjectCreate("%GENERATORPROTOTYPE%", (
    [[GeneratorState]], [[GeneratorContext]]) ).

2.  ReturnIfAbrupt(_G_).

3.  If the value of _G’s_ [[GeneratorState]] ]] internal data property
    is not UNDEFINED, then throw a TYPEERROR exception.

4.  Let _startStatus be_ the result of GeneratorStart(_G_,
    _Comprehension_).

5.  ReturnIfAbrupt(_startStatus_).

6.  Return _G_.

RUNTIME SEMANTICS: INSTANTIATEFUNCTIONOBJECT

  With parameter _scope_.

_GeneratorDeclaration_ : FUNCTION * _BindingIdentifier_ (
_FormalParameters_) { _FunctionBody_ }

1.  If the _GeneratorDeclaration_ is contained in strict code or if its
    _FunctionBody_ is strict code, then let _strict_ be TRUE. Otherwise
    let _strict_ be FALSE.

2.  Using _FunctionBody_ from the production that is being evaluated,
    let _body_ be the supplemental syntactic grammar production:
    _GeneratorBody_ : _FunctionBody_.

3.  Let _F_ be the result of performing the GeneratorFunctionCreate
    abstract operation with arguments Normal, _FormalParameters_, _body,
    scope_, and _strict_.

4.  Let _prototype_ be the result of the abstract operation ObjectCreate
    with the intrinsic object %GeneratorPrototype% as its argument.

5.  Perform the abstract operation MakeConstructor with arguments _F_,
    TRUE, and _prototype_.

6.  Return _F_.

RUNTIME SEMANTICS: PROPERTY DEFINITION EVALUATION

  With parameter _object_ and optional parameter _functionPrototype_.

_GeneratorMethod_ : * _PropertyName_ ( _StrictFormalParameters_ ) {
_FunctionBody_ }

1.  Let _propName_ be PropName of _PropertyName_.

2.  Let _strict_ be IsStrict of _FunctionBody_.

3.  Let _scope_ be the running execution context’s LexicalEnvironment.

4.  Using _FunctionBody_ from the production that is being evaluated,
    let _body_ be the supplemental syntactic grammar production:
    _GeneratorBody_ : _FunctionBody_.

5.  If ReferencesSuper of _GeneratorMethod_ is TRUE, then

    a.  Let _closure_ be the result of performing the
        GeneratorFunctionCreate abstract operation with arguments
        Method, _StrictormalParameters_, _body, scope_, and _strict_ and
        with _object_ as the _homeObject_ optional argument and
        _propName_ as the _methodName_ optional argument.

6.  Else

    a.  Let _closure_ be the result of performing the
        GeneratorFunctionCreate abstract operation with arguments
        Method, _StrictFormalParameters_, _body, scope_, and _strict_.

7.  Let _prototype_ be the result of the abstract operation ObjectCreate
    with the intrinsic object %GeneratorPrototype% as its argument.

8.  Perform the abstract operation MakeConstructor with arguments
    _closure_, TRUE, and _prototype_.

9.  Let _desc_ be the Property Descriptor{[[Value]]: _closure_,
    [[Writable]]: TRUE, [[Enumerable]]: TRUE, [[Configurable]]: TRUE}.

10. Let _status_ be the result of DefinePropertyOrThrow(_object_,
    _propName_ _desc_).

11. ReturnIfAbrupt(_status_).

12. Return NormalCompletion(_closure_).

RUNTIME SEMANTICS: EVALUATION

_GeneratorDeclaration_ : FUNCTION * _BindingIdentifier_ (
_FormalParameters_ ) { _FunctionBody_ }

1.  Return NormalCompletion(empty)

_GeneratorExpression_ : FUNCTION * ( _FormalParameters_ ) {
_FunctionBody_ }

1.  If the _GeneratorExpression_ is contained in strict code or if its
    _FunctionBody_ is strict code, then let _strict_ be TRUE. Otherwise
    let _strict_ be FALSE.

2.  Using _FunctionBody_ from the production that is being evaluated,
    let _body_ be the supplemental syntactic grammar production:
    _GeneratorBody_ : _FunctionBody_.

3.  Let _scope_ be the LexicalEnvironment of the running execution
    context.

4.  Let _closure_ be the result of performing the
    GeneratorFunctionCreate abstract operation with arguments Normal,
    _FormalParameters_, _body, scope_, and _strict_.

5.  Let _prototype_ be the result of the abstract operation ObjectCreate
    with the intrinsic object %GeneratorPrototype% as its argument.

6.  Perform the abstract operation MakeConstructor with arguments
    _closure_, TRUE, and _prototype_.

7.  Return _closure_.

_GeneratorExpression_ : FUNCTION * _BindingIdentifier_ (
_FormalParameters_) { _FunctionBody_ }

1.  If the _GeneratorExpression_ is contained in strict code or if its
    _FunctionBody_ is strict code, then let _strict_ be TRUE. Otherwise
    let _strict_ be FALSE.

2.  Using _FunctionBody_ from the production that is being evaluated,
    let _body_ be the supplemental syntactic grammar production:
    _GeneratorBody_ : _FunctionBody_.

3.  Let _funcEnv_ be the result of calling NewDeclarativeEnvironment
    passing the running execution context’s Lexical Environment as the
    argument

4.  Let _envRec_ be _funcEnv’s_ environment record.

5.  Let _name_ be StringValue of _BindingIdentifier_.

6.  Call the CreateImmutableBinding concrete method of _envRec_ passing
    _name_ as the argument.

7.  Let _closure_ be the result of performing the
    GeneratorFunctionCreate abstract operation with arguments Normal,
    _FormalParameters_, _body, funcEnv_, and _strict_.

8.  Let _prototype_ be the result of the abstract operation ObjectCreate
    with the intrinsic object %GeneratorPrototype% as its argument.

9.  Perform the abstract operation MakeConstructor with arguments
    _closure_, TRUE, and _prototype_.

10. Call the InitialiseBinding concrete method of _envRec_ passing
    _name_ and _closure_ as the arguments.

11. Return NormalCompletion(_closure_).

NOTE 1 The _BindingIdentifier_ in a _GeneratorExpression_ can be
referenced from inside the _GeneratorExpression's_ _FunctionBody_ to
allow the generator code to call itself recursively. However, unlike in
a _GeneratorDeclaration_, the _BindingIdentifier_ in a
_GeneratorExpression_ cannot be referenced from and does not affect the
scope enclosing the _GeneratorExpression_.

_YieldExpression_ : YIELD _YieldDelegator_~opt~ _AssignmentExpression 

1.  Let _exprRef_ be the result of evaluating _AssignmentExpression_.

2.  Let _value_ be GetValue(_exprRef_).

3.  ReturnIfAbrupt(_value_).

4.  If _YieldDelegator_ is present, then

    a.  If Type(_value_) is not then throw a TYPEERROR exception.

    b.  Let _iterator_ be the result of performing Invoke with arguments
        _value_, @@iterator and an empty List.

    c.  ReturnIfAbrupt(_iterator_)_._

    d.  If Type(_iterator_) is not then throw a TYPEERROR exception.

    e.  Let _received_ be UNDEFINED.

    f.  Repeat

        i.  Let _innerResult_ be the result of Invoke(_iterator_,
            "VALUE", (_received_)).

        ii. ReturnIfAbrupt(_innerResult_).

        iii. If Type(_innerResult_) is not Object, then throw a
            TYPEERROR exception.

        iv. Let _done_ be IteratorComplete(_innerResult_).

        v.  ReturnIfAbrupt(_done_).

        vi. If _done_ is TRUE, then

            1.  Let _innerValue_ be the result of Get (_innerResult_,
                "VALUE").

            2.  Return _innerValue_.

        vii. Let _yieldCompletion_ be the result of
            GeneratorYield(_innerResult_).

        viii. Let _received_ be _yieldCompletion_.[[value]].

        ix. If _yieldCompletion_.[[type]] is throw, then

            1.  If HasProperty(_iterator_, "THROW" is TRUE, then

                a.  Let _innerResult_ be the result of
                    Invoke(_iterator_, "THROW", (_received_)).

                b.  ReturnIfAbrupt(_innerResult_).

            2.  Return _yieldCompletion._

5.  Return the result of GeneratorYield(CreateItrResultObject(_value_,
    FALSE)).


13.5 Class Definitions

Syntax

ClassDeclaration :

CLASS BindingIdentifier ClassTail

ClassExpression :

CLASS BindingIdentifier~opt~ ClassTail

ClassTail :

ClassHeritage~opt~ { ClassBody~opt~ }

ClassHeritage :

EXTENDS AssignmentExpression

ClassBody :

ClassElementList

ClassElementList :

ClassElement
ClassElementList ClassElement

ClassElement :

MethodDefinition
STATIC MethodDefinition
;

NOTE A _ClassBody_ is always strict code.

Static Semantics

STATIC SEMANTICS: EARLY ERRORS

-   

_ClassBody_ : _ClassElementList

-   It is a Syntax Error if PrototypePropertyNameList of
    _ClassElementList_ contains any duplicate entries, unless the
    following condition is true for each duplicate entry: The duplicated
    entry occurs exactly twice in the list and one occurrence was
    obtained from a GET accessor _MethodDefinition_ and the other
    occurrence was obtained from a SET accessor _MethodDefinition_.

-   It is a Syntax Error if StaticPropertyNameList of _ClassElementList_
    contains any duplicate entries, unless the following condition is
    true for each duplicate entry: The duplicated entry occurs exactly
    twice in the list and one occurrence was obtained from a GET
    accessor _MethodDefinition_ and the other occurrence was obtained
    from a SET accessor _MethodDefinition_.

-   

_ClassElement_ : _MethodDefinition

-   It is a Syntax Error if PropName of _MethodDefinition_ is
    ″CONSTRUCTOR″ and SpecialMethod of _MethodDefinition_ is TRUE.

_ClassElement_ : STATIC _MethodDefinition

-   It is a Syntax Error if PropName of _MethodDefinition_ is
    ″PROTOTYPE″.

STATIC SEMANTICS: BOUNDNAMES

_ClassDeclaration_: CLASS _BindingIdentifier_ _ClassTail

1.  Return the BoundNames of _BindingIdentifier_.

STATIC SEMANTICS: CONSTRUCTORMETHOD

_ClassBody_ : _ClassElementList

1.  Let _list_ be PrototypeMethodDefinitions of _ClassElementList_.

2.  For each _MethodDefinition_ _m_ in _list_, do

    a.  If PropName of _m_ is ″CONSTRUCTOR″, return _m_.

3.  Return empty.

NOTE Early Error rules ensure that there is only one method definition
named ″CONSTRUCTOR″ and that it isn’t an accessor property or generator
definition.

STATIC SEMANTICS: CONTAINS

  With parameter _symbol_.

_ClassTail_ : _ClassHeritage_~opt~ { _ClassBody_ }

1.  If _symbol_ is _ClassBody_, return TRUE.

2.  If _ClassHeritage_ is not present, return FALSE.

3.  If _symbol_ is _ClassHeritage_, return TRUE.

4.  Return the result of Contains for _ClassHeritage_ with argument
    _symbol_.

NOTE Static semantic rules that depend upon substructure generally do
not look into class bodies.

STATIC SEMANTICS: ISCONSTANTDECLARATION

_ClassDeclaration_: CLASS _BindingIdentifier_ _ClassTail

1.  Return FALSE.

STATIC SEMANTICS: ISSTATIC

_ClassElement_ : _MethodDefinition

1.  Return FALSE.

_ClassElement_ : STATIC _MethodDefinition

1.  Return TRUE.

_ClassElement_ : ;

1.  Return FALSE.

STATIC SEMANTICS: LEXICALLYDECLAREDNAMES

_ClassDeclaration_: CLASS _BindingIdentifier_ _ClassTail

1.  Return the BoundNames of _BindingIdentifier_.

STATIC SEMANTICS: PROTOTYPEMETHODDEFINITIONS

_ClassElementList_ : _ClassElement

1.  If PropName of _ClassElement_ is empty or ″CONSTRUCTOR″, return a
    new empty List.

2.  If IsStatic of _ClassElement_ is TRUE, return a new empty List.

3.  Return a List containing _ClassElement_.

_ClassElementList_ : _ClassElementList_ _ClassElement

1.  Let _list_ be PrototypeMethodDefinitions of _ClassElementList_.

2.  If PropName of _ClassElement_ is empty or ″CONSTRUCTOR″, return
    _list_.

3.  If IsStatic of _ClassElement_ is TRUE, return _list_.

4.  Append _ClassElement_ to the end of _list_.

5.  Return _list_.

STATIC SEMANTICS: PROTOTYPEPROPERTYNAMELIST

_ClassElementList_ : _ClassElement

1.  If PropName of _ClassElement_ is empty, return a new empty List.

2.  If IsStatic of _ClassElement_ is TRUE, return a new empty List.

3.  Return a List containing PropName of _ClassElement_.

_ClassElementList_ : _ClassElementList_ _ClassElement

1.  Let _list_ be PrototypePropertyNameList of _ClassElementList_.

2.  If PropName of _ClassElement_ is empty, return _list_.

3.  If IsStatic of _ClassElement_ is TRUE, return _list_.

4.  Append PropName of _ClassElement_ to the end of _list_.

5.  Return _list_.

STATIC SEMANTICS: PROPNAME

_ClassElement_ : ;

1.  Return empty.

STATIC SEMANTICS: STATICPROPERTYNAMELIST

_ClassElementList_ : _ClassElement

1.  If PropName of _ClassElement_ is empty, return a new empty List.

2.  If IsStatic of _ClassElement_ is FALSE, return a new empty List.

3.  Return a List containing PropName of _ClassElement_.

_ClassElementList_ : _ClassElementList_ _ClassElement

1.  Let _list_ be StaticPropertyNameList of _ClassElementList_.

2.  If PropName of _ClassElement_ is empty, return _list_.

3.  If IsStatic of _ClassElement_ is FALSE, return _list_.

4.  Append PropName of _ClassElement_ to the end of _list_.

5.  Return _list_.

STATIC SEMANTICS: STATICMETHODDEFINITIONS

_ClassElementList_ : _ClassElement

1.  If PropName of _ClassElement_ is empty, return a new empty List.

2.  If IsStatic of _ClassElement_ is FALSE, return a new empty List.

3.  Return a List containing _ClassElement_.

_ClassElementList_ : _ClassElementList_ _ClassElement

1.  Let _list_ be StaticMethodDefinitions of _ClassElementList_.

2.  If PropName of _ClassElement_ is empty, return _list_.

3.  If IsStatic of _ClassElement_ is FALSE, return _list_.

4.  Append _ClassElement_ to the end of _list_.

5.  Return _list_.

STATIC SEMANTICS: VARDECLAREDNAMES

_ClassDeclaration_: CLASS _BindingIdentifier_ _ClassTail

1.  Return an empty List.

Runtime Semantics

RUNTIME SEMANTICS: CLASSDEFINITIONEVALUATION

  With parameter _className_.

_ClassTail_ : _ClassHeritage_~opt~ { _ClassBody_ }

1.  If _ClassHeritage_~opt~ is not present, then

    a.  let _protoParent_ be the intrinsic object %ObjectPrototype%.

    b.  Let _constructorParent_ be the intrinsic object
        %FunctionPrototype%.

2.  Else

    a.  Let _superclass_ be the result of evaluating _ClassHeritage_.

    b.  ReturnIfAbrupt(_superclass_).

    c.  If _superclass_ is NULL, then

        i.  Let _protoParent_ be NULL.

        ii. Let _constructorParent_ be the intrinsic object
            %FunctionPrototype%.

    d.  Else if Type(_superclass_) is not Object, throw a TYPEERROR
        exception.

    e.  Else if IsConstructor(_superclass_) is FALSE, then

    f.  throw a TYPEERROR exception.

        i.  

    g.  Else

        i.  Let _protoParent_ be the result of Get(_superclass_,
            "PROTOTYPE").

        ii. ReturnIfAbrupt(_protoParent_).

        iii. If Type(_protoParent_) is neither Object or Null, throw a
            TYPEERROR exception.

        iv. Let _constructorParent_ be _superclass_.

3.  Let _proto_ be the result of the abstract operation ObjectCreate
    with argument _protoParent_.

4.  5.  Let _lex_ be the LexicalEnvironment of the running execution
    context.

6.  If _className_ is not UNDEFINED, then

    a.  Let _scope_ be the result of calling NewDeclarativeEnvironment
        passing _lex_ as the argument

    b.  Let _envRec_ be _scope’s_ environment record.

    c.  Call the CreateImmutableBinding concrete method of _envRec_
        passing _className_ as the argument.

    d.  Set the running execution context’s LexicalEnvironment to
        _scope_.

7.  Let _constructor_ be ConstructorMethod of _ClassBody_.

8.  If _constructor_ is empty, then

    a.  If _ClassHeritage_~opt~ is present, then

        i.  Let _constructor_ be the result of parsing the String
            "CONSTRUCTOR(... ARGS){SUPER (...ARGS);}" using the
            syntactic grammar with the goal symbol _MethodDefinition_.

    b.  Else,

        i.  Let _constructor_ be the result of parsing the String
            "CONSTRUCTOR( ){ }" using the syntactic grammar with the
            goal symbol _MethodDefinition_.

9.  Let _strict_ be TRUE.

10. Let _F_ be the result of performing Property Definition Evaluation
    for _constructor_ with argument _proto_ and _constructorParent_ as
    the optional _funtionPrototype_ argument.

11. Perform the abstract operation MakeConstructor with argument _F_ and
    FALSE as the optional _writablePrototype_ argument and _proto_ as
    the optional _prototype_ argument.

12. If _className_ is not UNDEFINED, then

    a.  Calll the InitialiseBinding concrete method of _envRec_ passing
        _className_ and _F_ as the arguments.

13. Let _desc_ be the Property Descriptor{[[Enumerable]]: FALSE,
    [[Writable]]: TRUE, [[Configurable]]: TRUE}.

14. Call the [[DefineOwnProperty]] internal method of _proto_ with
    arguments "CONSTRUCTOR" and _desc_

15. Let _protoMethods_ be PrototypeMethodDefinitions of _ClassBody_.

16. For each _MethodDefinition_ _m_ in order from _protoMethods

    a.  Perform Property Definition Evaluation for _m_ with argument
        _proto_.

17. Let _staticMethods_ be StaticMethodDefinitions of _ClassBody_.

18. For each _MethodDefinition_ _s_ in order from _staticMethods

    a.  Perform Property Definition Evaluation for _s_ with argument
        _F_.

19. Set the running execution context’s LexicalEnvironment to _lex_.

20. Return _F_.

RUNTIME SEMANTICS: EVALUATION

_ClassDeclaration_: CLASS _BindingIdentifier_ _ClassTail

1.  2.  Let _value_ be the result of ClassDefinitionEvaluation of
    _ClassTail_ with argument UNDEFINED.

3.  ReturnIfAbrupt(_value_).

4.  Let _env_ be the running execution context’s LexicalEnvironment.

5.  Let _status_ be the result of performing Binding Initialisation for
    _BindingIdentifier_ passing _value_ and _env_ as the arguments.

6.  ReturnIfAbrupt(_status_).

7.  Return NormalCompletion(empty).

NOTE The argument to ClassDefinitionEvaluation controls whether or not
the class that is defined with a BindingIdentifier has a local binding
to the identifier. Only a _ClassExpression_ gets a local name binding of
its name. A _ClassDeclaration_ never has such a binding. This maintains
the parallel with _FunctionExpression_ and _FunctionDeclaration_.

_ClassExpression_: CLASS _BindingIdentifier_~opt~ _ClassTail

1.  If _BindingIdentifier_~opt~ is not present, then let _className_ be
    UNDEFINED.

2.  Else, let _className_ be StringValue of _BindingIdentifier_.

3.  Let _value_ be the result of ClassDefinitionEvaluation of
    _ClassTail_ with argument _className_.

4.  ReturnIfAbrupt(_value_).

5.  Return NormalCompletion(_value_).


1.  2.  

3.  a.  

4.  5.  6.  7.  a.  b.  c.  d.  

7.  

1.  

8.  

1.  2.  3.  4.  5.  6.  7.  a.  

8.  a.  b.  i.  ii. iii. 

    c.  

9.  10. 11. 12. 13. a.  b.  

14. 15. 16. 17. 18. 19. 20. 21. 

1.  2.  3.  4.  5.  6.  7.  8.  9.  10. 11. 

1.  2.  

3.  4.  


13.6 Tail Position Calls

The wiki proposal has a preliminary attempt at defining tail position.
See _http://wiki.ecmascript.org/doku.php?id=harmony:proper_tail_calls_.

This material still needs to be reviewed and updated for incorporation
here.


14.1 Script

Syntax

Script :

ScriptBody~opt~

ScriptBody :

OuterStatementList

OuterStatementList :

OuterItem
OuterStatementList OuterItem

OuterItem :

ModuleDeclaration
ImportDeclaration
StatementListItem

Static Semantics

STATIC SEMANTICS: EARLY ERRORS

_ScriptBody_ : _OuterStatementList

-   It is a Syntax Error if the LexicallyDeclaredNames of
    _OuterStatementList_ contains any duplicate entries.

-   It is a Syntax Error if any element of the LexicallyDeclaredNames of
    _OuterStatementList_ also occurs in the VarDeclaredNames of
    _OuterStatementList_.

-   It is a Syntax Error if _OuterStatementList_ Contains
    _ReturnStatement_.

-   It is a Syntax Error if _OuterStatementList_ Contains SUPER.

-   It is a Syntax Error if _OuterStatementList_ Contains
    _YieldExpression_.

NOTE Additional error conditions relating to conflicting or duplicate
declarations are checked during module linking prior to evaluation of a
_Script_. If any such errors are detected the _Script_ is not evaluated.

STATIC SEMANTICS: ISSTRICT

_ScriptBody_ : _OuterStatementList

1.  If this _ScriptBody_ is contained in strict code or if
    _OuterStatementList_ is strict code, then return TRUE. Otherwise,
    return FALSE.

STATIC SEMANTICS: LEXICALLYDECLAREDNAMES

_OuterStatementList_ : _OuterStatementList OuterItem

1.  Let _names_ be LexicallyDeclaredNames of _OuterStatementList_.

2.  Append to _names_ the elements of the LexicallyDeclaredNames of
    _OuterItem._

3.  Return _names_.

OuterItem : ModuleDeclaration

1.  Return the BoundNames of _ModuleDeclaration_.

OuterItem : ImportDeclaration

1.  Return the BoundNames of _ImportDeclaration_.

OuterItem : StatementListItem

1.  Return TopLevelLexicallyDeclaredNames of _StatementListItem_.

NOTE At the top level of a _Script_, function declarations are treated
like var declarations rather than like lexical declarations.

STATIC SEMANTICS: LEXICALLYSCOPEDDECLARATIONS

_OuterStatementList_ : _OuterStatementList OuterItem

1.  Let _declarations_ be LexicallyScopedDeclarations of
    _OuterStatementList_.

2.  Append to _declarations_ the elements of the
    LexicallyScopedDeclarations of _OuterItem._

3.  Return _declarations_.

OuterItem : ModuleDeclaration

1.  Return a new List containing _ModuleDeclaration_.

OuterItem : ImportDeclaration

1.  Return a new List containing _ImportDeclaration_.

OuterItem : StatementListItem

1.  Return TopLevelLexicallyScopedDeclarations of _StatementListItem_.

STATIC SEMANTICS: VARDECLAREDNAMES

_OuterStatementList_ : _OuterStatementList OuterItem

1.  Let _names_ be VarDeclaredNames of _OuterStatementList_.

2.  Append to _names_ the elements of the VarDeclaredNames of
    _OuterItem._

3.  Return _names_.

OuterItem : ModuleDeclaration

1.  Return an empty List.

OuterItem : ImportDeclaration

1.  Return an empty List.

OuterItem : StatementListItem

1.  Return TopLevelVarDeclaredNames of _StatementListItem_.

STATIC SEMANTICS: VARSCOPEDDECLARATIONS

_OuterStatementList_ : _OuterStatementList OuterItem

1.  Let _declarations_ be VarScopedDeclarations of _OuterStatementList_.

2.  Append to _declarations_ the elements of the VarScopedDeclarations
    of _OuterItem._

3.  Return _declarations_.

OuterItem : ModuleDeclaration

1.  Return a new empty List.

OuterItem : ImportDeclaration

1.  Return a new empty List.

OuterItem : StatementListItem

1.  Return the TopLevelVarScopedDeclarations of _StatementListItem_.

Runtime Semantics

RUNTIME SEMANTICS: SCRIPT EVALUATION

  With argument _realm_ and _deletableBindings_.

_Script_ : _ScriptBody_~opt~

NOTE The processes for initiating the evaluation of a _Script_ and for
dealing with the result of such an evaluation are defined by an
ECMAScript implementation and not by this specification.

RUNTIME SEMANTICS: EVALUATION

_OuterStatementList_ : _OuterStatementList_ _OuterItem

1.  Let _sl_ be the result of evaluating _OuterStatementList_.

2.  ReturnIfAbrupt(_sl_).

3.  Let _s_ be the result of evaluating _OuterItem_.

4.  If _s_.[[type]] is throw, return _s_.

5.  If _s_.[[value]] is empty, let _V_ = _sl_.[[value]], otherwise let
    _V_ = _s_.[[value]].

6.  Return Completion {[[type]]: _s_.[[type]], [[value]]: _V_,
    [[target]]: _s_.[[target]]}.

NOTE See the 12.1 NOTE regarding evaluation of _StatementList_ :
_StatementList StatementListItem.

14.1.1 Directive Prologues and the Use Strict Directive

A Directive Prologue is the longest sequence of _ExpressionStatement_
productions occurring as the initial _StatementListItem_ productions of
a _ScriptBody_ or _FunctionBody_ and where each _ExpressionStatement_ in
the sequence consists entirely of a _StringLiteral_ token followed by a
semicolon. The semicolon may appear explicitly or may be inserted by
automatic semicolon insertion. A Directive Prologue may be an empty
sequence.

A Use Strict Directive is an _ExpressionStatement_ in a Directive
Prologue whose _StringLiteral_ is either the exact character sequences
"USE STRICT" or 'USE STRICT'. A Use Strict Directive may not contain an
_EscapeSequence_ or _LineContinuation_.

A Directive Prologue may contain more than one Use Strict Directive.
However, an implementation may issue a warning if this occurs.

NOTE The _ExpressionStatement_ productions of a Directive Prologue are
evaluated normally during evaluation of the containing production.
Implementations may define implementation specific meanings for
_ExpressionStatement_ productions which are not a Use Strict Directive
and which occur in a Directive Prologue. If an appropriate notification
mechanism exists, an implementation should issue a warning if it
encounters in a Directive Prologue an _ExpressionStatement_ that is not
a Use Strict Directive or which does not have a meaning defined by the
implementation.


14.2 Modules

There are certain built-in objects available whenever an ECMAScript
program begins execution. One, the global object, is part of the lexical
environment of the executing program. Others are accessible as initial
properties of the global object.

Unless specified otherwise, a built-in object that is callable as a
function is a Build-in Function object with the characteristics
described in 8.4.7. Unless specified otherwise, the [[Extensible]]
internal data property of a built-in object initially has the value
TRUE.

Many built-in objects are functions: they can be invoked with arguments.
Some of them furthermore are constructors: they are functions intended
for use with the NEW operator. For each built-in function, this
specification describes the arguments required by that function and
properties of the Function object. For each built-in constructor, this
specification furthermore describes properties of the prototype object
of that constructor and properties of specific object instances returned
by a NEW expression that invokes that constructor.

Unless otherwise specified in the description of a particular function,
if a function or constructor described in this clause is given fewer
arguments than the function is specified to require, the function or
constructor shall behave exactly as if it had been given sufficient
additional arguments, each such argument being the UNDEFINED value.

Unless otherwise specified in the description of a particular function,
if a function or constructor described in this clause is given more
arguments than the function is specified to allow, the extra arguments
are evaluated by the call and then ignored by the function. However, an
implementation may define implementation specific behaviour relating to
such arguments as long as the behaviour is not the throwing of a
TYPEERROR exception that is predicated simply on the presence of an
extra argument.

NOTE Implementations that add additional capabilities to the set of
built-in functions are encouraged to do so by adding new functions
rather than adding new parameters to existing functions.

Every built-in function and every built-in constructor has the Function
prototype object, which is the initial value of the expression
FUNCTION.PROTOTYPE (15.3.3), as the value of its [[Prototype]] internal
data property.

Unless otherwise specified every built-in prototype object has the
Object prototype object, which is the initial value of the expression
OBJECT.PROTOTYPE (15.2.4), as the value of its [[Prototype]] internal
data property, except the Object prototype object itself.

None of the built-in functions described in this clause that are not
constructors shall implement the [[Construct]] internal method unless
otherwise specified in the description of a particular function. The
behaviour specified in this clause for each built-in function is the
specification of the [[Call]] internal method behaviour for that
function with [[Call]] thisArgument providing the THIS value and
[[Call]] _argumentList_ providing the named parameters for each built-in
function. None of the built-in functions described in this clause shall
have a PROTOTYPE property unless otherwise specified in the description
of a particular function.

This clause generally describes distinct behaviours for when a
constructor is “called as a function” and for when it is “called as part
of a NEW expression”. The “called as a function” behaviour corresponds
to the invocation of the constructor’s [[Call]] internal method and the
“called as part of a new expression” behaviour corresponds to the
invocation of the constructor’s [[Construct]] internal method.

Every built-in Function object, _F_, described in this clause—whether as
a constructor, an ordinary function, or both—has the properties that are
defined by performing the following step when the function object is
created:

1. Perform the AddRestrictedFunctionProperties (13.6.3) abstract
operation with argument _F_.

Every built-in Function object described in this clause—whether as a
constructor, an ordinary function, or both—has a LENGTH property whose
value is an integer. Unless otherwise specified, this value is equal to
the largest number of named arguments shown in the subclause headings
for the function description, including optional parameters.

NOTE For example, the Function object that is the initial value of the
slice property of the String prototype object is described under the
subclause heading “String.prototype.slice (start, end)” which shows the
two named arguments start and end; therefore the value of the length
property of that Function object is 2.

In every case, the LENGTH property of a built-in Function object
described in this clause has the attributes { [[Writable]]: FALSE,
[[Enumerable]]: FALSE, [[Configurable]]: FALSE }.

Every other data property described in this clause has the attributes {
[[Writable]]: TRUE, [[Enumerable]]: FALSE, [[Configurable]]: TRUE }
unless otherwise specified.

Every accessor property described in this clause has the attributes
{[[Enumerable]]: FALSE, [[Configurable]]: TRUE } unless otherwise
specified. If only a get accessor function is described, the set
accessor function is the default value, UNDEFINED. If only a set
accessor is function is described the get accessor is the default value,
UNDEFINED.


15.1 The Global Object

The unique _global object_ is created before control enters any
execution context.

Unless otherwise specified, the standard built-in properties of the
global object have attributes {[[Writable]]: TRUE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE}.

The global object does not have a [[Construct]] internal method; it is
not possible to use the global object as a constructor with the NEW
operator.

The global object does not have a [[Call]] internal method; it is not
possible to invoke the global object as a function.

The value of the [[Prototype]] internal data property of the global
object is implementation-dependent.

In addition to the properties defined in this specification the global
object may have additional host defined properties. This may include a
property whose value is the global object itself; for example, in the
HTML document object model the WINDOW property of the global object is
the global object itself.

15.1.1 Value Properties of the Global Object

15.1.1.1 NaN

The value of NAN is NAN (see 8.5). This property has the attributes {
[[Writable]]: FALSE, [[Enumerable]]: FALSE, [[Configurable]]: FALSE }.

15.1.1.2 Infinity

The value of INFINITY is +∞ (see 8.5). This property has the attributes
{ [[Writable]]: FALSE, [[Enumerable]]: FALSE, [[Configurable]]: FALSE }.

15.1.1.3 undefined

The value of UNDEFINED is UNDEFINED (see 8.1). This property has the
attributes { [[Writable]]: FALSE, [[Enumerable]]: FALSE,
[[Configurable]]: FALSE }.

15.1.2 Function Properties of the Global Object

15.1.2.1 eval (x)

When the EVAL function is called with one argument _x_, the following
steps are taken:

1.  If Type(_x_) is not String, return _x_.

2.  Let _script_ be the ECMAScript code that is the result of parsing
    _x_, interpreted as UTF-16 encoded Unicode text as described in
    8.4_,_ for the goal symbol _Script_. If the parse fails or any early
    errors are detected, throw a SYNTAXERROR exception (but see also
    clause 16).

3.  If _script_ Contains _ScriptBody_ is FALSE, return UNDEFINED.

4.  Let _strictScript_ be IsStrict of _script_.

5.  If this is a direct call to eval (15.1.2.1.1), let _direct_ be TRUE,
    otherwise let _direct_ be FALSE.

6.  If _direct_ is TRUE and the code that made the direct call to eval
    is strict code, then let _strictCaller_ be TRUE_._ Otherwise, let
    _strictCaller_ be FALSE_._

7.  Let _ctx_ be the running execution context. If _direct_ is TRUE
    _ctx_ will be the execution context that performed the direct eval.
    If _direct_ is FALSE _ctx_ will be the execution context for the
    invocation of the eval function.

8.  Let _evalRealm_ be _ctx’s_ Realm.

9.  If _direct_ is FALSE and _strictScript_ is FALSE, then

    a.  Return the result of Script Evaluation for _script_ with
        arguments _evalRealm_ and TRUE.

10. If _direct_ is TRUE, _strictScript_ is FALSE, _strictCaller_ is
    FALSE, and ctx’s LexicalEnvironment is the same as
    _evalRealm_.[[globalEnv]], then

    a.  Return the result of Script Evaluation for _script_ with
        arguments _evalRealm_ and TRUE.

11. If _direct_ is TRUE, then

    a.  If the code that made the direct call to eval is function code
        and ValidInFunction of _script_ is FALSE, then throw a
        SYNTAXERROR exception.

    b.  If the code that made the direct call to eval is module code and
        ValidInModule of _script_ is FALSE, then throw a SYNTAXERROR
        exception.

12. 13. a.  

14. If _direct_ is TRUE, then

    a.  b.  Let _lexEnv_ be _ctx’s_ LexicalEnvironment.

    c.  Let _varEnv_ be _ctx’s_ VariableEnvironment.

15. Else,

    a.  Let _lexEnv_ be _evalRealm_.[[globalEnv]].

    b.  Let _varEnv_ be _evalRealm_.[[globalEnv]].

16. If _strictScript_ is TRUE or if _direct_ is TRUE and _strictCaller
    is TRUE , then

    a.  Let _strictVarEnv_ be the result of calling
        NewDeclarativeEnvironment passing the _lexEnv_ as the argument.

    b.  Let _lexEnv_ be _strictVarEnv_.

    c.  let _varEnv_ be _strictVarEnv_.

    d.  

17. Let _status_ be the result of performing Eval Declaration
    Instantiation as described in 10.5.5 with _script_, _varEnv_, and
    _lexEnv_.

18. ReturnIfAbrupt(_status_).

19. Let _evalCxt_ be a new ECMAScript code execution context.

20. Set the _evalCxt’s_ Realm to _evalRealm_.

21. Set the _evalCxt’s_ VariableEnvironment to _varEnv_.

22. Set the _evalCxt’s_ LexicalEnvironment to _lexEnv_.

23. If there is a currently running execution context, suspend it.

24. Push _evalCxt_ on to the execution context stack; _evalCxt_ is now
    the running execution context.

25. Let _result_ be the result of evaluating _script_.

26. Suspend _evalCxt_ and remove it from the execution context stack.

27. Resume the context that is now on the top of the execution context
    stack as the running execution context.

28. 29. 30. 31. Return _result_.

NOTE The eval code cannot instantiate variable or function bindings in
the variable environment of the calling context that invoked the eval if
either the code of the calling context or the eval code is strict code.
Instead such bindings are instantiated in a new VariableEnvironment that
is only accessible to the eval code.

15.1.2.1.1 Direct Call to Eval

A direct call to the eval function is one that is expressed as a
_CallExpression_ that meets the following two conditions:

The Reference that is the result of evaluating the _MemberExpression_ in
the _CallExpression_ has an environment record as its base value and its
reference name is "EVAL".

The result of calling the abstract operation GetValue with that
Reference as the argument is the standard built-in function defined in
15.1.2.1.

15.1.2.2 parseInt (string , radix)

The PARSEINT function produces an integer value dictated by
interpretation of the contents of the _string_ argument according to the
specified _radix_. Leading white space in _string_ is ignored. If
_radix_ is UNDEFINED or 0, it is assumed to be 10 except when the number
begins with the character pairs 0X or 0X, in which case a radix of 16 is
assumed. If _radix_ is 16, the number may also optionally begin with the
character pairs 0X or 0X.

When the PARSEINT function is called, the following steps are taken:

NOTE PARSEINT may interpret only a leading portion of _string_ as an
integer value; it ignores any characters that cannot be interpreted as
part of the notation of an integer, and no indication is given that any
such characters were ignored.

15.1.2.3 parseFloat (string)

The PARSEFLOAT function produces a Number value dictated by
interpretation of the contents of the _string_ argument as a decimal
literal.

When the PARSEFLOAT function is called, the following steps are taken:

1.  Let _inputString_ be ToString(_string_).

2.  ReturnIfAbrupt(_string_).

3.  Let _trimmedString_ be a substring of _inputString_ consisting of
    the leftmost character that is not a _StrWhiteSpaceChar_ and all
    characters to the right of that character. (In other words, remove
    leading white space.) If _inputString_ does not contain any such
    characters, let _trimmedString_ be the empty string.

4.  If neither _trimmedString_ nor any prefix of _trimmedString
    satisfies the syntax of a _StrDecimalLiteral_ (see 9.3.1), return
    NAN.

5.  Let _numberString_ be the longest prefix of _trimmedString_, which
    might be _trimmedString_ itself, that satisfies the syntax of a
    _StrDecimalLiteral_.

6.  Return the Number value for the MV of _numberString_.

NOTE PARSEFLOAT may interpret only a leading portion of _string_ as a
Number value; it ignores any characters that cannot be interpreted as
part of the notation of an decimal literal, and no indication is given
that any such characters were ignored.

15.1.2.4 isNaN (number)

Returns TRUE if the argument coerces to NAN, and otherwise returns
FALSE.

1.  Let _num_ be ToNumber(_number_).

2.  ReturnIfAbrupt(_num_).

3.  If _num_ is NAN, return TRUE.

4.  Otherwise, return FALSE.

NOTE A reliable way for ECMAScript code to test if a value X is a NAN is
an expression of the form X !== X. The result will be TRUE if and only
if X is a NAN.

15.1.2.5 isFinite (number)

Returns FALSE if the argument coerces to NAN, +∞, or −∞, and otherwise
returns TRUE.

15.1.3 URI Handling Function Properties

Uniform Resource Identifiers, or URIs, are Strings that identify
resources (e.g. web pages or files) and transport protocols by which to
access them (e.g. HTTP or FTP) on the Internet. The ECMAScript language
itself does not provide any support for using URIs except for functions
that encode and decode URIs as described in 15.1.3.1, 15.1.3.2, 15.1.3.3
and 15.1.3.4.

NOTE Many implementations of ECMAScript provide additional functions and
methods that manipulate web pages; these functions are beyond the scope
of this standard.

A URI is composed of a sequence of components separated by component
separators. The general form is:

_Scheme_ : _First_ / _Second_ ; _Third_ ? _Fourth

where the italicised names represent components and “:”, “/”, “;” and
“?” are reserved characters used as separators. The ENCODEURI and
DECODEURI functions are intended to work with complete URIs; they assume
that any reserved characters in the URI are intended to have special
meaning and so are not encoded. The ENCODEURICOMPONENT and
DECODEURICOMPONENT functions are intended to work with the individual
component parts of a URI; they assume that any reserved characters
represent text and so must be encoded so that they are not interpreted
as reserved characters when the component is part of a complete URI.

The following lexical grammar specifies the form of encoded URIs.

Syntax

uri :::

uriCharacters~opt~

uriCharacters :::

uriCharacter uriCharacters~opt~

uriCharacter :::

uriReserved
uriUnescaped
uriEscaped

uriReserved ::: ONE OF

; / ? : @ & = + $ ,

uriUnescaped :::

uriAlpha
DecimalDigit
uriMark

uriEscaped :::

% HexDigit HexDigit

uriAlpha ::: ONE OF

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

uriMark ::: ONE OF

- _ . ! ~ * ' ( )

NOTE The above syntax is based upon RFC 2396 and does not reflect
changes introduced by the more recent RFC 3986.

RUNTIME SEMANTICS

When a character to be included in a URI is not listed above or is not
intended to have the special meaning sometimes given to the reserved
characters, that character must be encoded. The character is transformed
into its UTF-8 encoding, with surrogate pairs first converted from
UTF-16 to the corresponding code point value. (Note that for code units
in the range [0,127] this results in a single octet with the same
value.) The resulting sequence of octets is then transformed into a
String with each octet represented by an escape sequence of the form
“%xx”.

RUNTIME SEMANTICS: ENCODE ABSTRACT OPERATION

The encoding and escaping process is described by the abstract operation
Encode taking two String arguments _string_ and _unescapedSet_.

RUNTIME SEMANTICS: DECODE ABSTRACT OPERATION

The unescaping and decoding process is described by the abstract
operation Decode taking two String arguments _string_ and _reservedSet_.

NOTE This syntax of Uniform Resource Identifiers is based upon RFC 2396
and does not reflect the more recent RFC 3986 which replaces RFC 2396. A
formal description and implementation of UTF-8 is given in RFC 3629.

In UTF-8, characters are encoded using sequences of 1 to 6 octets. The
only octet of a "sequence" of one has the higher-order bit set to 0, the
remaining 7 bits being used to encode the character value. In a sequence
of n octets, n>1, the initial octet has the n higher-order bits set to
1, followed by a bit set to 0. The remaining bits of that octet contain
bits from the value of the character to be encoded. The following octets
all have the higher-order bit set to 1 and the following bit set to 0,
leaving 6 bits in each to contain bits from the character to be encoded.
The possible UTF-8 encodings of ECMAScript characters are specified in
Table 31.

Table 31 — UTF-8 Encodings

  ------------------- --------------------- --------------- --------------- --------------- ---------------
  _CODE UNIT VALUE_   _REPRESENTATION_      _1^ST^ OCTET_   _2^ND^ OCTET_   _3^RD^ OCTET_   _4^TH^ OCTET_

  0X0000 - 0X007F     00000000 0_zzzzzzz_   0_zzzzzzz_                                      

  0X0080 - 0X07FF     00000_yyy yyzzzzzz_   110_yyyyy_      10_zzzzzz_                      

  0X0800 - 0XD7FF     _xxxxyyyy yyzzzzzz_   1110_xxxx_      10_yyyyyy_      10_zzzzzz_      

  0XD800 - 0XDBFF     110110_vv vvwwwwxx_   11110_uuu_      10_uuwwww_      10_xxyyyy_      10_zzzzzz_
                                                                                            
  _followed by_       _followed by_                                                         
                                                                                            
  0XDC00 – 0XDFFF     110111_yy yyzzzzzz_                                                   

  0XD800 - 0XDBFF     _causes_ URIERROR                                                     
                                                                                            
  _not followed by_                                                                         
                                                                                            
  0XDC00 – 0XDFFF                                                                           

  0XDC00 – 0XDFFF     _causes_ URIERROR                                                     

  0XE000 - 0XFFFF     _xxxxyyyy yyzzzzzz_   1110_xxxx_      10_yyyyyy_      10_zzzzzz_      
  ------------------- --------------------- --------------- --------------- --------------- ---------------

Where

_uuuuu_ = _vvvv_ + 

to account for the addition of 0x10000 as in Surrogates, section 3.7, of
the Unicode Standard.

The range of code unit values 0xD800-0xDFFF is used to encode surrogate
pairs; the above transformation combines a UTF-16 surrogate pair into a
UTF-32 representation and encodes the resulting 21-bit value in UTF-8.
Decoding reconstructs the surrogate pair.

RFC 3629 prohibits the decoding of invalid UTF-8 octet sequences. For
example, the invalid sequence C0 80 must not decode into the character
U+0000. Implementations of the Decode algorithm are required to throw a
URIERROR when encountering such invalid sequences.

15.1.3.1 decodeURI (encodedURI)

The DECODEURI function computes a new version of a URI in which each
escape sequence and UTF-8 encoding of the sort that might be introduced
by the ENCODEURI function is replaced with the character that it
represents. Escape sequences that could not have been introduced by
ENCODEURI are not replaced.

When the DECODEURI function is called with one argument _encodedURI_,
the following steps are taken:

1.  Let _uriString_ be ToString(_encodedURI_).

2.  ReturnIfAbrupt(_uriString_).

3.  Let _reservedURISet_ be a String containing one instance of each
    character valid in _uriReserved_ plus “#”.

4.  Return the result of calling Decode(_uriString_, _reservedURISet_)

NOTE The character “#” is not decoded from escape sequences even though
it is not a reserved URI character.

15.1.3.2 decodeURIComponent (encodedURIComponent)

The DECODEURICOMPONENT function computes a new version of a URI in which
each escape sequence and UTF-8 encoding of the sort that might be
introduced by the ENCODEURICOMPONENT function is replaced with the
character that it represents.

When the DECODEURICOMPONENT function is called with one argument
_encodedURIComponent_, the following steps are taken:

1.  Let _componentString_ be ToString(_encodedURIComponent_).

2.  ReturnIfAbrupt(_componentString_).

3.  Let _reservedURIComponentSet_ be the empty String.

4.  Return the result of calling Decode(_componentString_,
    _reservedURIComponentSet_)

15.1.3.3 encodeURI (uri)

The ENCODEURI function computes a new version of a URI in which each
instance of certain characters is replaced by one, two, three, or four
escape sequences representing the UTF-8 encoding of the character.

When the ENCODEURI function is called with one argument _uri_, the
following steps are taken:

NOTE The character “#” is not encoded to an escape sequence even though
it is not a reserved or unescaped URI character.

15.1.3.4 encodeURIComponent (uriComponent)

The ENCODEURICOMPONENT function computes a new version of a URI in which
each instance of certain characters is replaced by one, two, three, or
four escape sequences representing the UTF-8 encoding of the character.

When the ENCODEURICOMPONENT function is called with one argument
_uriComponent_, the following steps are taken:

15.1.4 Constructor Properties of the Global Object

15.1.4.1 Object ( . . . )

See 15.2.1 and 15.2.2.

15.1.4.2 Function ( . . . )

See 15.3.1.

15.1.4.3 Array ( . . . )

See 15.4.1.

15.1.4.4 String ( . . . )

See 15.5.1 and 15.5.2.

15.1.4.5 Boolean ( . . . )

See 15.6.1 and 15.6.2.

15.1.4.6 Number ( . . . )

See 15.7.1 and 15.7.2.

15.1.4.7 Date ( . . . )

See 15.9.2.

15.1.4.8 RegExp ( . . . )

See 15.10.3 and 15.10.4.

15.1.4.9 Error ( . . . )

See 15.11.1 and 15.11.2.

15.1.4.10 EvalError ( . . . )

See 15.11.6.1.

15.1.4.11 RangeError ( . . . )

See 15.11.6.2.

15.1.4.12 ReferenceError ( . . . )

See 15.11.6.3.

15.1.4.13 SyntaxError ( . . . )

See 15.11.6.4.

15.1.4.14 TypeError ( . . . )

See 15.11.6.5.

15.1.4.15 URIError ( . . . )

See 15.11.6.6.

15.1.4.16 Map ( . . . )

See 15.14.3.

15.1.4.17 WeakMap ( . . . )

See 15.15.3.

15.1.4.18 Set ( . . . )

See 15.16.3.

15.1.5 Other Properties of the Global Object

15.1.5.1 Math

See 15.8.

15.1.5.2 JSON

See 15.12.


15.2 Object Objects

15.2.1 The Object Constructor Called as a Function

When OBJECT is called as a function rather than as a constructor, it
performs a type conversion.

15.2.1.1 Object ( [ value ] )

When the OBJECT function is called with no arguments or with one
argument _value_, the following steps are taken:

15.2.2 The Object Constructor

When OBJECT is called as part of a NEW expression, it is a constructor
that may create an object.

15.2.2.1 new Object ( [ value ] )

When the OBJECT constructor is called with no arguments or with one
argument _value_, the following steps are taken:

15.2.3 Properties of the Object Constructor

The value of the [[Prototype]] internal data property of the Object
constructor is the standard built-in Function prototype object.

Besides the LENGTH property (whose value is 1), the Object constructor
has the following properties:

15.2.3.1 Object.prototype

The initial value of OBJECT.PROTOTYPE is the standard built-in Object
prototype object (15.2.4).

This property has the attributes {[[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

15.2.3.2 Object.getPrototypeOf ( O )

When the GETPROTOTYPEOF function is called with argument _O_, the
following steps are taken:

15.2.3.3 Object.getOwnPropertyDescriptor ( O, P ) 

When the GETOWNPROPERTYDESCRIPTOR function is called, the following
steps are taken:

15.2.3.4 Object.getOwnPropertyNames ( O )

When the GETOWNPROPERTYNAMES function is called, the following steps are
taken:

1.  If Type(_O_) is not Object, throw a TYPEERROR exception.

2.  Let _keys_ be the result of calling the [[OwnPropertyKeys]] internal
    method of _O_.

3.  ReturnIfAbrupt(_keys_).

4.  Let _nameList_ be a new empty List.

5.  Let _gotAllNames_ be FALSE.

6.  Repeat while _gotAllNames_ is FALSE,

    a.  Let _next_ be the result of Invoke(_keys_, "NEXT").

    b.  ReturnIfAbrupt(_next_).

    c.  If Type(_next_) is not Object, then throw a TYPEERROR exception.

    d.  Let _done_ be IteratorComplete(_next_).

    e.  ReturnIfAbrupt(_done_).

    f.  If _done_ is TRUE, then let _gotAllNames_ be TRUE.

    g.  Else,

        i.  ii. iii. iv. Let _nextKey_ be IteratorValue(_next_).

        v.  ReturnIfAbrupt(_nextKey_).

        vi. If Type(_nextKey_) is String, then

            1.  Append _nextKey_ as the last element of _nameList_.

7.  Return CreateArrayFromList(_keys_).

1.  2.  3.  4.  5.  6.  a.  b.  c.  

7.  

15.2.3.5 Object.create ( O [, Properties] )

The CREATE function creates a new object with a specified prototype.
When the CREATE function is called, the following steps are taken:

15.2.3.6 Object.defineProperty ( O, P, Attributes )

The DEFINEPROPERTY function is used to add an own property and/or update
the attributes of an existing own property of an object. When the
DEFINEPROPERTY function is called, the following steps are taken:

15.2.3.7 Object.defineProperties ( O, Properties )

The DEFINEPROPERTIES function is used to add own properties and/or
update the attributes of existing own properties of an object. When the
DEFINEPROPERTIES function is called, the following steps are taken:

1.  Return the result of the abstract operation ObjectDefineProperties
    with arguments _O_ and _Properties_.

RUNTIME SEMANTICS: OBJECTDEFINEPROPERTIES ABSTRACT OPERATION

The abstract operation ObjectDefineProperties with arguments _O_ and
_Properties_ performs the following steps:

If an implementation defines a specific order of enumeration for the
for-in statement, that same enumeration order must be used to order the
list elements in step 3 of this algorithm.

NOTE An exception in defining an individual property in step 7 does not
terminate the process of defining other properties. All valid property
definitions are processed.

15.2.3.8 Object.seal ( O )

When the SEAL function is called, the following steps are taken:

15.2.3.9 Object.freeze ( O )

When the FREEZE function is called, the following steps are taken:

15.2.3.10 Object.preventExtensions ( O )

When the PREVENTEXTENSIONS function is called, the following steps are
taken:

15.2.3.11 Object.isSealed ( O )

When the ISSEALED function is called with argument _O_, the following
steps are taken:

1.  If Type(_O_) is not Object throw a TYPEERROR exception.

2.  a.  b.  

3.  4.  5.  6.  Return the result of calling the [[HasIntegrity]]
    internal methods of _O_ with argument "SEALED".

15.2.3.12 Object.isFrozen ( O )

When the ISFROZEN function is called with argument _O_, the following
steps are taken:

1.  If Type(_O_) is not Object throw a TYPEERROR exception.

2.  a.  b.  c.  i.  

    d.  

3.  4.  5.  6.  Return the result of calling the [[HasIntegrity]]
    internal methods of _O_ with argument "FROZEN".

15.2.3.13 Object.isExtensible ( O )

When the ISEXTENSIBLE function is called with argument _O_, the
following steps are taken:

15.2.3.14 Object.keys ( O )

When the KEYS function is called with argument _O_, the following steps
are taken:

1.  If Type(_O_) is not Object, throw a TYPEERROR exception.

2.  Let _keys_ be the result of calling the [[OwnPropertyKeys]] internal
    method of _O_.

3.  ReturnIfAbrupt(_keys_).

4.  Let _nameList_ be a new empty List.

5.  Let _gotAllNames_ be FALSE.

6.  Repeat while _gotAllNames_ is FALSE,

    a.  Let _next_ be the result of Invoke(_keys_, "NEXT").

    b.  ReturnIfAbrupt(_next_).

    c.  If Type(_next_) is not Object, then throw a TYPEERROR exception.

    d.  Let _done_ be IteratorComplete(_next_).

    e.  ReturnIfAbrupt(_done_).

    f.  If _done_ is TRUE, then let _gotAllNames_ be TRUE.

    g.  Else,

        i.  Let _nextKey_ be IteratorValue(_next_).

        ii. ReturnIfAbrupt(_nextKey_).

        iii. iv. v.  vi. If Type(_nextKey_) is String, then

            1.  Let _desc_ be the result of calling the
                [[GetOwnProperty]] internal method of _O_ with argument
                _nextKey_.

            2.  ReturnIfAbrupt(_desc_).

            3.  If _desc_ is not UNDEFINED and _desc_.[[Enumerable]] is
                TRUE, then

                a.  Append _nextKey_ as the last element of _nameList_.

7.  Return CreateArrayFromList(_keys_).

If an implementation defines a specific order of enumeration for the
for-in statement, the same order must be used for the elements of the
array returned in step 7.

15.2.3.15 Object.getOwnPropertyKeys ( O )

When the GETOWNPROPERTYKEYS function is called with argument _O_, the
following steps are taken:

1.  If Type(_O_) is not Object, throw a TYPEERROR exception.

2.  Let _keys_ be the result of calling the [[OwnPropertyKeys]] internal
    method of _O_.

3.  Return _keys_.

TODO :

-   May need to say something about order of enumeration and post call
    property additions and deletions

15.2.3.16 Object.is ( value1, value2 )

When the IS function is called with arguments _value1_ and _value2_ the
following steps are taken:

1.  Return SameValue(_value1_, _value2_).

1.  2.  3.  4.  a.  b.  c.  

5.  

15.2.3.17 Object.assign ( target, source )

TODO :

-   Only enumerable own properties of source

-   Invoke [[Get]] on property list derived from source, for each
    property in list [[Put]] on target

-   private names are not copied

-   unique names are copied

-   super mechanism (rebind super)

-   Returns modified "target"

15.2.3.18 Object.mixin ( target, source )

Don’t have TC39 concensus on including this or its name. Hower, there
appears to be strong interest both within TC39 and on es-disuss and
reasonable use cases. “mixin” seems to be the favorate name from
es-discuss, although concerns have been raised that it might clash with
some existing libraries.

TODO :

-   All non-private properties of source

-   Uses [[GetOwnProperty]]/[[DefineOwnProperty]]

-   private symbols are not copied

-   non-symbols are copied

-   super mechanism (rebind super)

-   Returns modified "target"

15.2.3.2 Object.setPrototypeOf ( O, proto )

When the SETPROTOTYPEOF function is called with arguments _O_ and proto,
the following steps are taken:

1.  If Type(_O_) is not Object, then throw a TYPEERROR exception.

2.  If Type(_proto_) is neither Object or Null, then throw a TYPEERROR
    exception.

3.  Let _status_ be the result of calling the [[SetInheritance]]
    internal method of _O_ with argument _proto_.

4.  ReturnIfAbrupt(_status_).

5.  If _status_ is FALSE, then throw a TYPEERROR exception.

6.  Return _O_.

15.2.4 Properties of the Object Prototype Object

The Object prototype object is an ordinary object.

The value of the [[Prototype]] internal data property of the Object
prototype object is NULL and the initial value of the [[Extensible]]
internal data property is TRUE.

15.2.4.1 Object.prototype.constructor

The initial value of OBJECT.PROTOTYPE.CONSTRUCTOR is the standard
built-in OBJECT constructor.

15.2.4.2 Object.prototype.toString ( )

When the TOSTRING method is called, the following steps are taken:

  -- --
     
     
     
     
     
     
     
     
     
     
     
  -- --

NOTE Historically, this function was occasionally used to access the
string value of the [[Class]] internal data property that was used in
previous editions of this specification as a nominal type tag for
various built-in objects. The above definition of TOSTRING preserves the
ability to use it as a reliable test for those specific kinds of
built-in objects but it does not provide a reliable type testing
mechanism for other kinds of built-in or program defined objects.

15.2.4.3 Object.prototype.toLocaleString ( )

When the TOLOCALESTRING method is called, the following steps are taken:

1.  Let _O_ be the THIS value.

2.  ReturnIfAbrupt(_O_).

3.  4.  5.  Return the result of Invoke(_O_, "TOSTRING").

NOTE 1 This function is provided to give all Objects a generic
TOLOCALESTRING interface, even though not all may use it. Currently,
ARRAY, NUMBER, and DATE provide their own locale-sensitive
TOLOCALESTRING methods.

NOTE 2 The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that implementations
do not use this parameter position for anything else.

15.2.4.4 Object.prototype.valueOf ( )

When the VALUEOF method is called, the following steps are taken:

15.2.4.5 Object.prototype.hasOwnProperty (V)

When the HASOWNPROPERTY method is called with argument _V_, the
following steps are taken:

NOTE The ordering of steps 1 and 3 is chosen to ensure that any
exception that would have been thrown by step 1 in previous editions of
this specification will continue to be thrown even if the THIS value is
UNDEFINED or NULL.

15.2.4.6 Object.prototype.isPrototypeOf (V)

When the ISPROTOTYPEOF method is called with argument _V_, the following
steps are taken:

1.  If _V_ is not an object, return FALSE.

2.  Let _O_ be the result of calling ToObject passing the THIS value as
    the argument.

3.  ReturnIfAbrupt(_O_).

4.  Repeat

    a.  Let _V_ be the result of calling the [[GetInheritance]] internal
        method of _V_ with no arguments.

    b.  if _V_ is NULL, return FALSE

    c.  If _O_ and _V_ refer to the same object, return TRUE.

NOTE The ordering of steps 1 and 2 is chosen to preserve the behaviour
specified by previous editions of this specification for the case where
V is not an object and the this value is UNDEFINED or null.

15.2.4.7 Object.prototype.propertyIsEnumerable (V)

When the PROPERTYISENUMERABLE method is called with argument _V_, the
following steps are taken:

1.  Let _P_ be ToString(_V_).

2.  ReturnIfAbrupt(_P_).

3.  Let _O_ be the result of calling ToObject passing the THIS value as
    the argument.

4.  ReturnIfAbrupt(_O_).

5.  Let _desc_ be the result of calling the [[GetOwnProperty]] internal
    method of _O_ passing _P_ as the argument.

6.  If _desc_ is UNDEFINED, return FALSE.

7.  Return the value of _desc_.[[Enumerable]].

NOTE 1 This method does not consider objects in the prototype chain.

NOTE 2 The ordering of steps 1 and 2 is chosen to ensure that any
exception that would have been thrown by step 1 in previous editions of
this specification will continue to be thrown even if the THIS value is
UNDEFINED or NULL.

15.2.5 Properties of Object Instances

Object instances have no special properties beyond those inherited from
the Object prototype object.


15.3 Function Objects

15.3.1 The Function Constructor

The Function constructor is the %Function% instrinsic object and the
initial value of the FUNCTION property of the global OBJECT. When
FUNCTION is called as a function rather than as a constructor, it
creates and initialises a new Function object. Thus the function call
FUNCTION(…) is equivalent to the object creation expression NEW
FUNCTION(…) with the same arguments. However, if the THIS value value
passed in the call is an Object with an [[Code]] internal data property
whose value is UNDEFINED, it initializes the THIS value using the
argument values. This permits FUNCTION to be used both as factory method
and to perform constructor instance initialization.

FUNCTION may be subclassed and subclass constructors may perform a SUPER
invocation of the FUNCTION constructor to initialize subclass instances.
However, all syntactic forms for defining function objects create
instances of FUNCTION. There is no syntactic means to create instances
of FUNCTION subclasses except for the built-in Generator Function
subclass.

15.3.1.1 Function (p1, p2, … , pn, body)

The last argument specifies the body (executable code) of a function;
any preceding arguments specify formal parameters.

When the FUNCTION function is called with some arguments _p1_, _p2_, … ,
_pn_, _body_ (where _n_ might be 0, that is, there are no “_p_”
arguments, and where _body_ might also not be provided), the following
steps are taken:

A PROTOTYPE property is automatically created for every function created
using the FUNCTION constructor, to provide for the possibility that the
function will be used as a constructor.

NOTE It is permissible but not necessary to have one argument for each
formal parameter to be specified. For example, all three of the
following expressions produce the same result:

  new Function("a", "b", "c", "return a+b+c")

  new Function("a, b, c", "return a+b+c")

  new Function("a,b", "c", "return a+b+c")

15.3.1.2 new Function ( ... argumentsList)

When FUNCTION is called as part of a NEW expression, it is a
constructor: it initialises the newly created object.

1.  Let _F_ be the FUNCTION function object on which the NEW operator
    was applied.

2.  Let _argumentsList_ be the _argumentsList_ argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of OrdinaryConstruct (_F_, _argumentsList_).

If FUNCTIUON is implemented as an ordinary function object, its
[[Construct]] internal method will perform the above steps.

15.3.2 Properties of the Function Constructor

The Function constructor is itself a built-in Function object. The value
of the [[Prototype]] internal data property of the Function constructor
is %FunctionPrototype%, the intrinsic Function prototype object
(15.3.3).

The value of the [[Extensible]] internal data property of the Function
constructor is TRUE.

The Function constructor has the following properties:

15.3.2.1 Function.prototype

The value of FUNCTION.PROTOTYPE is the %FunctionPrototype%, the
intrinsic Function prototype object (15.3.3).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

15.3.2.2 Function.length

This is a data property with a value of 1. This property has the
attributes { [[Writable]]: FALSE, [[Enumerable]]: FALSE,
[[Configurable]]: FALSE }.

15.3.2.3 Function[ @@create ] ( )

The @@create method of an object _F_ performs the following steps:

1.  Let _F_ be the THIS value.

2.  Let _proto_ be the result of GetPrototypeFromConstructor(_F_,
    "%FUNCTIONPROTOTYPE%").

3.  ReturnIfAbrupt(_proto_).

4.  Let _obj_ be the result of calling FunctionAllocate with agument
    _proto_.

5.  Return _obj_.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

NOTE The Function @@CREATE function is intentionally generic; it does
not require that its THIS value be the Function constructor object. It
can be transferred to other constructor functions for use as a @@CREATE
method. When used with other constructors, this function will create a
exotic function object whose [[Prototype]] value is obtained from the
associated constructor.

15.3.3 Properties of the Function Prototype Object

The Function prototype object is itself a Built-in Function object. When
invoked, it accepts any arguments and returns UNDEFINED.

NOTE The Function prototype object is specified to be a function object
to ensure compatability with ECMAScript code that was created prior to
the 6^th^ Edition of this specification.

The value of the [[Prototype]] internal data property of the Function
prototype object is the intrinsic object %ObjectPrototype% (15.2.4). The
initial value of the [[Extensible]] internal data property of the
Function prototype object is TRUE.

The function prototype object does not have a PROTOTYPE property.

The LENGTH property of the Function prototype object is 0.

15.3.3.1 Function.prototype.constructor

The initial value of FUNCTION.PROTOTYPE.CONSTRUCTOR is the intrinsic
object %Function%.

15.3.3.2 Function.prototype.toString ( )

An implementation-dependent representation of the function is returned.
This representation has the syntax of a _FunctionDeclaration_. Note in
particular that the use and placement of white space, line terminators,
and semicolons within the representation String is
implementation-dependent.

The TOSTRING function is not generic; it throws a TYPEERROR exception if
its THIS value is not a Function object. Therefore, it cannot be
transferred to other kinds of objects for use as a method.

15.3.3.3 Function.prototype.apply (thisArg, argArray)

When the APPLY method is called on an object _func_ with arguments
_thisArg_ and _argArray_, the following steps are taken:

The LENGTH property of the APPLY method is 2.

NOTE The thisArg value is passed without modification as the THIS value.
This is a change from Edition 3, where a UNDEFINED or NULL thisArg is
replaced with the global object and ToObject is applied to all other
values and that result is passed as the THIS value.

15.3.3.4 Function.prototype.call (thisArg [ , arg1 [ , arg2, … ] ] )

When the CALL method is called on an object _func_ with argument
_thisArg_ and optional arguments _arg1_, _arg2_ etc, the following steps
are taken:

The LENGTH property of the CALL method is 1.

NOTE The thisArg value is passed without modification as the THIS value.
This is a change from Edition 3, where a UNDEFINED or NULL thisArg is
replaced with the global object and ToObject is applied to all other
values and that result is passed as the THIS value.

15.3.3.5 Function.prototype.bind (thisArg [, arg1 [, arg2, …]])

The bind method takes one or more arguments, _thisArg_ and (optionally)
_arg1_, _arg2_, etc, and returns a new function object by performing the
following steps:

The LENGTH property of the BIND method is 1.

NOTE Function objects created using FUNCTION.PROTOTYPE.BIND are exotic
objects. They also do not have a PROTOTYPE property.

15.3.3.6 Function.prototype[ @@create ] ( )

The @@create method of an object _F_ performs the following steps:

1.  Return the result of calling OrdinaryCreateFromConstructor(_F_,
    "%OBJECTPROTOTYPE%").

NOTE This is default @@create method that is inherited by all ordinary
constructor functions that do not explicitly over-ride it.

15.3.3.7 Function.prototype[@@hasInstance] (V)

When the @@hasInstance method of an object _F_ is called with value _V_,
the following steps are taken:

1.  Let _F_ be the THIS value.

2.  Return the result of OrdinaryHasInstance(_F_, _V_).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

NOTE This is the default implementation of @@HASINSTANCE that most
functions inherit. @@HASINSTANCE is called by the INSTANCEOF operator to
deterimine whether a value is an instance of a specific constructor. An
expression such as

V INSTANCEOF F

evaluates as

F[@@HASINSTANCE](V)

A constructor function can control which objects are recoginze as its
instances by INSTANCEOF by exposing a different @@HASINSTANCE method on
the function.

This property is non-writable and non-configurable to prevent tampering
that could be used to globally expose the target function of a bound
function.

15.3.4 Function Instances

Every function instance is an ordinary function object and has the
internal data properties listed in Table 13.

Function instances that correspond to strict mode functions and function
instances created using the FUNCTION.PROTOTYPE.BIND METHOD (15.3.3.5)
have properties named CALLER and ARGUMENTS that throw a TYPEERROR
exception. An ECMAScript implementation must not associate any
implementation specific behaviour with accesses of these properties from
strict mode function code.

The Function instances have the following properties:

15.3.4.1 length

The value of the LENGTH property is an integer that indicates the
typical number of arguments expected by the function. However, the
language permits the function to be invoked with some other number of
arguments. The behaviour of a function when invoked on a number of
arguments other than the number specified by its LENGTH property depends
on the function. This property has the attributes { [[Writable]]: FALSE,
[[Enumerable]]: FALSE, [[Configurable]]: FALSE }.

15.3.4.2 prototype

Function instances that can be used used as a constructor have a
PROTOTYPE property. Whenever such a function instance is created another
ordinary object is also created and is the initial value of the
function’s PROTOTYPE property. Unless otherwise specified, the value of
the prototype property is used to initialise the [[Prototype]] internal
data property of a newly created ordinay object before the Function
object is invoked as a constructor for that newly created object.

This property has the attributes { [[Writable]]: TRUE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

NOTE Function objects created using FUNCTION.PROTOTYPE.BIND, or by
evaluating a _MethodDefinition_ (that is not a _GeneratorMethod_) or an
_ArrowFunction_ grammar production do not have a PROTOTYPE property.

1.  2.  3.  4.  5.  a.  b.  

6.  


15.4 Array Objects

Array objects are exotic objects that give special treatment to a
certain class of property names. See 8.4.3 for a definition of this
special treatment.

An Array object, _O_, is said to be _sparse_ if the following algorithm
returns TRUE:

1.  Let _len_ be the result of Get(_O_, "LENGTH").

2.  For each integer _i_ in the range 0≤_i_<ToUint32(_len_)

    a.  Let _elem_ be the result of calling the [[GetOwnProperty]]
        internal method of _O_ with argument ToString(_i_).

    b.  If _elem_ is UNDEFINED, return TRUE.

3.  Return FALSE.

1.  2.  3.  4.  5.  6.  7.  8.  9.  

15.4.1 The Array Constructor 

The Array constructor is the %Array% instrinsic object and the initial
value of the ARRAY property of the global object. When ARRAY is called
as a function rather than as a constructor, it creates and initialises a
new Array object. Thus the function call ARRAY(…) is equivalent to the
object creation expression NEW ARRAY(…) with the same arguments.

However, if the THIS value value passed in the call is an Object with an
[[ArrayInitialisationState]] internal data property whose value is
UNDEFINED, it initializes the THIS value using the argument values. This
permits ARRAY to be used both as factory method and to perform
constructor instance initialization.

ARRAY may be subclassed and subclass constructors may perform a super
invocation of the ARRAY constructor to initialize subclass instances.

15.4.1.1 Array ( [ item1 [ , item2 [ , … ] ] ] )

This description applies if and only if the Array constructor is given
no arguments or at least two arguments.

When the ARRAY function is called the following steps are taken:

1.  

15.4.1.2 Array (len)

This description applies if and only if the Array constructor is given
exactly one argument.

1.  Let _numberOfArgs_ be the number of arguments passed to this
    constructor call.

2.  Assert: _numberOfArgs_ = 1.

3.  Let _O_ be the THIS value.

4.  If Type(_O_) is Object and _O_ has an [[ArrayInitialisationState]]
    internal data property and the value of [[ArrayInitialisationState]]
    is FALSE, then

    a.  Set the value of _O’s_ [[ArrayInitialisationState]] internal
        data property to TRUE.

    b.  Let _array_ be _O_.

5.  Else,

    a.  Let _F_ be this function.

    b.  Let _proto_ be the result of GetPrototypeFromConstructor(_F_,
        "%ARRAYPROTOTYPE%").

    c.  ReturnIfAbrupt(_proto_).

    d.  Let _array_ be the result of the abstract operation ArrayCreate
        with argument 0 and _proto_.

6.  ReturnIfAbrupt(_array_).

7.  If Type(_len_) is not Number, then

    a.  b.  c.  Let _defineStatus_ be the result of
        DefinePropertyOrThrow(_array_, "0", Property Descriptor
        {[[Value]]: _len_, [[Writable]]: TRUE, [[Enumerable]]: TRUE,
        [[Configurable]]: TRUE}).

    d.  ReturnIfAbrupt(_defineStatus_).

    e.  Let _intLen_ be 1.

8.  Else,

    a.  Let _intLen_ be ToUint32(_len_).

    b.  If _intLen_ ≠ _len_, then throw a RANGEERROR exception.

9.  Let _putStatus_ be the result of Put(_array_, "LENGTH", _intLen_,
    TRUE).

10. ReturnIfAbrupt(_putStatus_).

11. 12. Return _array_.

15.4.1.3 new Array ( ... argumentsList)

When ARRAY is called as part of a NEW expression, it is a constructor:
it initialises a newly created object.

1.  Let _F_ be the ARRAY function object on which the NEW operator was
    applied.

2.  Let _argumentsList_ be the _argumentsList_ argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of OrdinaryConstruct (_F_, _argumentsList_).

If ARRAY is implemented as an ordinary function object, its
[[Construct]] internal method will perform the above steps.

15.4.2 Properties of the Array Constructor

The value of the [[Prototype]] internal data property of the Array
constructor is the Function prototype object (15.3.3).

Besides and the LENGTH property (whose value is 1), the Array
constructor has the following properties:

15.4.2.1 Array.prototype

The value of ARRAY.PROTOTYPE is %ArrayPrototype% the intrinsic Array
prototype object (15.4.3).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

15.4.2.2 Array.isArray ( arg )

The isArray function takes one argument _arg_, and performs the
following steps are taken:

1.  If Type(_arg_) is not Object, return FALSE.

2.  If _arg_ is an exotic Array object, then return TRUE.

3.  Return FALSE.

15.4.2.3 Array.of ( ...items )

When the OF method is called with any number of arguments, the following
steps are taken:

1.  Let _lenValue_ be the result of Get(_items_, "LENGTH").

2.  Let _len_ be ToInteger(_lenValue_).

3.  Let _C_ be the THIS value.

4.  If IsConstructor(_C_) is TRUE, then

    a.  Let _newObj_ be the result of calling the [[Construct]] internal
        method of _C_ with an argument list containing the single item
        _len_.

    b.  Let _A_ be ToObject(_newObj_).

5.  Else,

    a.  Let _A_ be the result of the abstract operation ArrayCreate with
        argument _len_.

6.  ReturnIfAbrupt(_A_).

7.  Let _k_ be 0.

8.  Repeat, while _k_ < _len

    a.  Let _Pk_ be ToString(_k_).

    b.  Let _kValue_ be the result of Get(_items_, _Pk_).

    c.  Let _defineStatus_ be the result of
        DefinePropertyOrThrow(_A_,_Pk_, Property Descriptor {[[Value]]:
        _kValue_.[[value]], [[Writable]]: TRUE, [[Enumerable]]: TRUE,
        [[Configurable]]: TRUE}).

    d.  ReturnIfAbrupt(_defineStatus_).

    e.  Increase _k_ by 1.

9.  Let _putStatus_ be the result of Put(_A_, "LENGTH", _len_, TRUE).

10. ReturnIfAbrupt(_putStatus_).

11. Return _A_.

The LENGTH property of the OF method is 0.

NOTE 1 The _items_ argument is assume to be a well-formed rest argument
value.

NOTE 2 The OF function is an intentionally generic factory method; it
does not require that its THIS value be the Array constructor. Therefore
it can be transferred to or inherited by other constructors that may be
called with a single numeric argument.

15.4.2.4 Array.from ( arrayLike , mapfn=undefined, thisArg=undefined )

When the FROM method is called with argument _arrayLike_, the following
steps are taken:

1.  Let _items_ be ToObject(_arrayLike_).

2.  ReturnIfAbrupt(_items_).

3.  Let _lenValue_ be the result of Get(_items_, "LENGTH").

4.  Let _len_ be ToInteger(_lenValue_).

5.  ReturnIfAbrupt(_len_).

6.  Let _C_ be the THIS value.

7.  If IsConstructor(_C_) is TRUE, then

    a.  Let _newObj_ be the result of calling the [[Construct]] internal
        method of _C_ with an argument list containing the single item
        _len_.

    b.  Let _A_ be ToObject(_newObj_).

8.  Else,

    a.  Let _A_ be the result of the abstract operation ArrayCreate with
        argument _len_.

9.  ReturnIfAbrupt(_A_).

10. Let _k_ be 0.

11. Repeat, while _k_ < _len

    a.  Let _Pk_ be ToString(_k_).

    b.  Let _kPresent_ be the result of HasProperty(_items_, _Pk_).

    c.  ReturnIfAbrupt(_kPresent_).

    d.  If _kPresent_ is TRUE, then

        i.  Let _kValue_ be the result of Get(_items_, _Pk_).

        ii. ReturnIfAbrupt(_kValue_).

        iii. Let _defineStatus_ be the result of
            DefinePropertyOrThrow(_A_, _Pk_ Property Descriptor
            {[[Value]]: _kValue_.[[value]], [[Writable]]: TRUE,
            [[Enumerable]]: TRUE, [[Configurable]]: TRUE}).

        iv. ReturnIfAbrupt(_defineStatus_).

    e.  Increase _k_ by 1.

12. Let _putStatus_ be the result of Put(_A_, "LENGTH", _len_, TRUE).

13. ReturnIfAbrupt(_putStatus_).

14. Return _A_.

NOTE The FROM function is an intentionally generic factory method; it
does not require that its THIS value be the Array constructor. Therefore
it can be transferred to or inherited by any other constructors that may
be called with a single numeric argument.

15.4.2.5 Array[ @@create ] ( )

The @@create method of an object _F_ performs the following steps:

1.  Let _F_ be the THIS value.

2.  Let _proto_ be the result of GetPrototypeFromConstructor(_F_,
    "%ARRAYPROTOTYPE%").

3.  ReturnIfAbrupt(_proto_).

4.  Let _obj_ be the result of calling ArrayCreate with arguments
    UNDEFINED and _proto_.

5.  Return _obj_.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

NOTE 1 Passing UNDEFINED as the first argument to ArrayCreate causes the
[[ArrayInitialisationState]] internal data property of the array to be
initially assigned the value FALSE. This is a flag used to indicate that
the instance has not yet been initialized by the ARRAY constructor. This
flag value is never directly exposed to ECMAScript code; hence
implementation may choose to encode the flag in any unobservable manner.

NOTE 2 The Array @@CREATE function is intentionally generic; it does not
require that its THIS value be the Array constructor object. It can be
transferred to other constructor functions for use as a @@CREATE method.
When used with other constructors, this function will create an exotic
Array object whose [[Prototype]] value is obtained from the associated
constructor.

15.4.3 Properties of the Array Prototype Object

The value of the [[Prototype]] internal data property of the Array
prototype object is the intrinsic object %ObjectPrototype%.

The Array prototype object is itself an ordinary object. It is not an
Array instance and does not have, a LENGTH property .

In following descriptions of functions that are properties of the Array
prototype object, the phrase “this object” refers to the object that is
the THIS value for the invocation of the function. It is permitted for
the THIS object to be an object which is not an exotic Array object.

NOTE The Array prototype object does not have a VALUEOF property of its
own; however, it inherits the VALUEOF property from the standard
built-in Object prototype Object.

15.4.3.1 Array.prototype.constructor

The initial value of ARRAY.PROTOTYPE.CONSTRUCTOR is the standard
built-in ARRAY constructor.

15.4.3.2 Array.prototype.toString ( )

When the TOSTRING method is called, the following steps are taken:

1.  Let _array_ be the result of calling ToObject on the THIS value.

2.  ReturnIfAbrupt(_array_).

3.  Let _func_ be the result of Get(_array_, "JOIN").

4.  ReturnIfAbrupt(_func_).

5.  If IsCallable(_func_) is FALSE, then let _func_ be the standard
    built-in method Object.prototype.toString (15.2.4.2).

6.  Return the result of calling the [[Call]] internal method of _func
    providing _array_ as _thisArgument_ and an empty List as
    _argumentsList_.

NOTE The TOSTRING function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the TOSTRING
function can be applied successfully to an exotic object that is not an
Array is implementation-dependent.

15.4.3.3 Array.prototype.toLocaleString ( )

The elements of the array are converted to Strings using their
TOLOCALESTRING methods, and these Strings are then concatenated,
separated by occurrences of a separator String that has been derived in
an implementation-defined locale-specific way. The result of calling
this function is intended to be analogous to the result of TOSTRING,
except that the result of this function is intended to be
locale-specific.

The result is calculated as follows:

1.  Let _array_ be the result of calling ToObject passing the THIS value
    as the argument.

2.  ReturnIfAbrupt(_array_).

3.  Let _arrayLen_ be the result of Get(_array_, "LENGTH").

4.  Let _len_ be ToUint32(_arrayLen_).

5.  ReturnIfAbrupt(_len_).

6.  Let _separator_ be the String value for the list-separator String
    appropriate for the host environment’s current locale (this is
    derived in an implementation-defined way).

7.  If _len_ is zero, return the empty String.

8.  Let _firstElement_ be the result of Get(_array_, "0").

9.  Let _noArgs_ be an empty List.

10. ReturnIfAbrupt(_firstElement_).

11. If _firstElement_ is UNDEFINED or NULL, then

    a.  Let _R_ be the empty String.

12. Else

    a.  b.  c.  d.  Let _R_ be the result of Invoke(_firstElement_,
        "TOLOCALESTRING").

    e.  Let _R_ be ToString(_R_).

    f.  ReturnIfAbrupt(_R_).

13. Let _k_ be 1.

14. Repeat, while _k_ < _len

    a.  Let _S_ be a String value produced by concatenating _R_ and
        _separator_.

    b.  Let _nextElement_ be the result of Get(_array_,ToString(_k_)).

    c.  ReturnIfAbrupt(_nextElement_).

    d.  If _nextElement_ is UNDEFINED or NULL, then

        i.  Let _R_ be the empty String.

    e.  Else

        i.  ii. Let _R_ be the result of Invoke(_nextElement_,
            "TOLOCALESTRING").

        iii. Let _R_ be ToString(_R_).

        iv. ReturnIfAbrupt(_R_).

        v.  vi. vii. 

    f.  Let _R_ be a String value produced by concatenating _S_ and _R_.

    g.  Increase _k_ by 1.

15. Return _R_.

NOTE 1 The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that implementations
do not use this parameter position for anything else.

NOTE 2 The TOLOCALESTRING function is intentionally generic; it does not
require that its THIS value be an Array object. Therefore it can be
transferred to other kinds of objects for use as a method. Whether the
TOLOCALESTRING function can be applied successfully to an exotic object
that is not an Array is implementation-dependent.

15.4.3.4 Array.prototype.concat ( [ item1 [ , item2 [ , … ] ] ] )

When the CONCAT method is called with zero or more arguments _item1_,
_item2_, etc., it returns an array containing the array elements of the
object followed by the array elements of each argument in order.

The following steps are taken:

1.  Let _O_ be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(_O_).

3.  Let _A_ be the result of the abstract operation ArrayCreate with
    argument 0.

4.  Let _n_ be 0.

5.  Let _items_ be an internal List whose first element is _O_ and whose
    subsequent elements are, in left to right order, the arguments that
    were passed to this function invocation.

6.  Repeat, while _items_ is not empty

    a.  Remove the first element from _items_ and let _E_ be the value
        of the element.

    b.  If _E_ is an exotic Array object, then

        i.  Let _k_ be 0.

        ii. Let _len_ be the result of Get(_E_, "LENGTH").

        iii. ReturnIfAbrupt(_len_).

        iv. Repeat, while _k_ < _len_

            1.  Let _P_ be ToString(_k_).

            2.  Let _exists_ be the result of HasProperty(_E_, _P_).

            3.  ReturnIfAbrupt(_exists_).

            4.  If _exists_ is TRUE, then

                a.  Let _subElement_ be the result of Get(_E_, _P_).

                b.  Call the [[DefineOwnProperty]] internal method of
                    _A_ with arguments ToString(_n_) and Property
                    Descriptor {[[Value]]: _subElement_, [[Writable]]:
                    TRUE, [[Enumerable]]: TRUE, [[Configurable]]: TRUE}.

            5.  Increase _n_ by 1.

            6.  Increase _k_ by 1.

    c.  Else _E_ is not an Array,

        i.  Call the [[DefineOwnProperty]] internal method of _A_ with
            arguments ToString(_n_) and Property Descriptor {[[Value]]:
            _E_, [[Writable]]: TRUE, [[Enumerable]]: TRUE,
            [[Configurable]]: TRUE}.

        ii. Increase _n_ by 1.

7.  Let _putStatus_ be the result of Put(_A_, "LENGTH", _n_, TRUE).

8.  ReturnIfAbrupt(_putStatus_).

9.  Return _A_.

The LENGTH property of the CONCAT method is 1.

NOTE 1 The explicit setting of the LENGTH property in step 7 is
necessary to ensure that its value is correct in situations where the
trailing elements of the result Array are not present.

NOTE 2 The CONCAT function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the CONCAT
function can be applied successfully to an exotic object that is not an
Array is implementation-dependent.

15.4.3.5 Array.prototype.join (separator)

The elements of the array are converted to Strings, and these Strings
are then concatenated, separated by occurrences of the _separator_. If
no separator is provided, a single comma is used as the separator.

The JOIN method takes one argument, _separator_, and performs the
following steps:

The LENGTH property of the JOIN method is 1.

NOTE The JOIN function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore, it can be transferred
to other kinds of objects for use as a method. Whether the JOIN function
can be applied successfully to an exotic object that is not an Array is
implementation-dependent.

15.4.3.6 Array.prototype.pop ( )

The last element of the array is removed from the array and returned.

NOTE The POP function is intentionally generic; it does not require that
its THIS value be an Array object. Therefore it can be transferred to
other kinds of objects for use as a method. Whether the POP function can
be applied successfully to an exotic object that is not an Array is
implementation-dependent.

15.4.3.7 Array.prototype.push ( [ item1 [ , item2 [ , … ] ] ] )

The arguments are appended to the end of the array, in the order in
which they appear. The new length of the array is returned as the result
of the call.

When the PUSH method is called with zero or more arguments _item1_,
_item2_, etc., the following steps are taken:

The LENGTH property of the PUSH method is 1.

NOTE The PUSH function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the PUSH function
can be applied successfully to an exotic object that is not an Array is
implementation-dependent.

15.4.3.8 Array.prototype.reverse ( )

The elements of the array are rearranged so as to reverse their order.
The object is returned as the result of the call.

NOTE The REVERSE function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore, it can be transferred
to other kinds of objects for use as a method. Whether the REVERSE
function can be applied successfully to an exotic object that is not an
Array is implementation-dependent.

15.4.3.9 Array.prototype.shift ( )

The first element of the array is removed from the array and returned.

1.  Let _O_ be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(_O_).

3.  Let _lenVal_ be the result of Get(_O_, "LENGTH").

4.  Let _len_ be ToUint32(_lenVal_).

5.  ReturnIfAbrupt(_len_).

6.  If _len_ is zero, then

    a.  Let _putStatus_ be the result of Put(_O_, "LENGTH", 0, TRUE).

    b.  ReturnIfAbrupt(_putStatus_).

    c.  Return UNDEFINED.

7.  Let _first_ be the result of Get(_O_, "0").

8.  ReturnIfAbrupt(_first_).

9.  Let _k_ be 1.

10. Repeat, while _k_ < _len

    a.  Let _from_ be ToString(_k_).

    b.  Let _to_ be ToString(_k_–1).

    c.  Let _fromPresent_ be the result of HasProperty(_O_, _from_).

    d.  ReturnIfAbrupt(_fromPresent_).

    e.  If _fromPresent_ is TRUE, then

        i.  Let _fromVal_ be the result of Get(_O_, _from_).

        ii. ReturnIfAbrupt(_fromVal_).

        iii. Let _putStatus_ be the result of Put(_O_, _to_, _fromVal_,
            TRUE).

        iv. ReturnIfAbrupt(_putStatus_).

    f.  Else _fromPresent_ is FALSE,

        i.  Let _deleteStatus_ be the result of
            DeletePropertyOrThrow(_O_, _to_).

        ii. ReturnIfAbrupt(_deleteStatus_).

    g.  Increase _k_ by 1.

11. Let _deleteStatus_ be the result of DeletePropertyOrThrow(_O_,
    ToString(_len_–1)).

12. ReturnIfAbrupt(_deleteStatus_).

13. Let _putStatus_ be the result of Put(_O_, "LENGTH", _len_–1, TRUE).

14. ReturnIfAbrupt(_putStatus_).

15. Return _first_.

NOTE The SHIFT function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the SHIFT
function can be applied successfully to an exotic object that is not an
Array is implementation-dependent.

15.4.3.10 Array.prototype.slice (start, end)

The SLICE method takes two arguments, _start_ and _end_, and returns an
array containing the elements of the array from element _start_ up to,
but not including, element _end_ (or through the end of the array if
_end_ is UNDEFINED). If _start_ is negative, it is treated as
_length_+_start_ where _length_ is the length of the array. If _end_ is
negative, it is treated as _length_+_end_ where _length_ is the length
of the array. The following steps are taken:

The LENGTH property of the SLICE method is 2.

NOTE 1 The explicit setting of the LENGTH property of the result Array
in step 15 is necessary to ensure that its value is correct in
situations where the trailing elements of the result Array are not
present.

NOTE 2 The SLICE function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the SLICE
function can be applied successfully to an exotic object that is not an
Array is implementation-dependent.

15.4.3.11 Array.prototype.sort (comparefn)

The elements of this array are sorted. The sort is not necessarily
stable (that is, elements that compare equal do not necessarily remain
in their original order). If _comparefn_ is not UNDEFINED, it should be
a function that accepts two arguments _x_ and _y_ and returns a negative
value if _x_ < _y_, zero if _x_ = _y_, or a positive value if _x_ > _y_.

Let _obj_ be the result of calling ToObject passing the THIS value as
the argument.

Let _len_ be the result of applying Uint32 to the result of Get(_obj_,
"LENGTH").

If _comparefn_ is not UNDEFINED and is not a consistent comparison
function for the elements of this array (see below), the behaviour of
SORT is implementation-defined.

Let _proto_ be the result of calling the [[GetInheritance]] internal
method of _obj_. If _proto_ is not NULL and there exists an integer _j_
such that all of the conditions below are satisfied then the behaviour
of SORT is implementation-defined:

-   _obj_ is sparse (15.4)

-   0 ≤ _j_ < _len_

-   The result of HasProperty(_proto_, ToString(_j_)) is TRUE.

The behaviour of SORT is also implementation defined if _obj_ is sparse
and any of the following conditions are true:

-   The result of the predicate IsExtensible(_obj_) is FALSE.

-   Any array index property of _obj_ whose name is a nonnegative
    integer less than _len_ is a data property whose [[Configurable]]
    attribute is FALSE.

The behaviour of SORT is also implementation defined if any array index
property of _obj_ whose name is a nonnegative integer less than _len_ is
an accessor property or is a data property whose [[Writable]] attribute
is FALSE.

Otherwise, the following steps are taken.

The returned object must have the following two properties.

-   There must be some mathematical permutation π of the nonnegative
    integers less than _len_, such that for every nonnegative integer
    _j_ less than _len_, if property old[_j_] existed, then new[π(_j_)]
    is exactly the same value as old[_j_],. But if property old[_j_] did
    not exist, then new[π(_j_)] does not exist.

-   Then for all nonnegative integers _j_ and _k_, each less than _len_,
    if SortCompare(_j_,_k_) < 0 (see SortCompare below), then Π(_j_) <
    Π(_k_).

Here the notation old[_j_] is used to refer to the hypothetical result
of calling the [[Get]] internal method of _obj_ with argument _j_ before
this function is executed, and the notation new[_j_] to refer to the
hypothetical result of calling the [[Get]] internal method of _obj_ with
argument _j_ after this function has been executed.

A function _comparefn_ is a consistent comparison function for a set of
values _S_ if all of the requirements below are met for all values _a_,
_b_, and _c_ (possibly the same value) in the set _S_: The notation
_a_ <~CF~ _b_ means _comparefn_(_a_,_b_) < 0; _a_ =~CF~ _b_ means
_comparefn_(_a_,_b_) = 0 (of either sign); and _a_ >~CF~ _b_ means
_comparefn_(_a_,_b_) > 0.

-   Calling _comparefn_(_a_,_b_) always returns the same value _v_ when
    given a specific pair of values _a_ and _b_ as its two arguments.
    Furthermore, Type(_v_) is Number, and _v_ is not NaN. Note that this
    implies that exactly one of _a_ <~CF~ _b_, _a_ =~CF~ _b_, and
    _a_ >~CF~ _b_ will be true for a given pair of _a_ and _b_.

-   Calling _comparefn_(_a_,_b_) does not modify the THIS object.

-   _a_ =~CF~ _a_ (reflexivity)

-   If _a_ =~CF~ _b_, then _b_ =~CF~ _a_ (symmetry)

-   If _a_ =~CF~ _b_ and _b_ =~CF~ _c_, then _a_ =~CF~ _c_ (transitivity
    of =~CF~)

-   If _a_ <~CF~ _b_ and _b_ <~CF~ _c_, then _a_ <~CF~ _c_ (transitivity
    of <~CF~)

-   If _a_ >~CF~ _b_ and _b_ >~CF~ _c_, then _a_ >~CF~ _c_ (transitivity
    of >~CF~)

NOTE The above conditions are necessary and sufficient to ensure that
_comparefn_ divides the set _S_ into equivalence classes and that these
equivalence classes are totally ordered.

RUNTIME SEMANTICS: SORTCOMPARE ABSTRACT OPERATION

When the SortCompare abstract operation is called with two arguments _j_
and _k_, the following steps are taken:

NOTE 1 Because non-existent property values always compare greater than
UNDEFINED property values, and UNDEFINED always compares greater than
any other value, UNDEFINED property values always sort to the end of the
result, followed by non-existent property values.

NOTE 2 The SORT function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore, it can be transferred
to other kinds of objects for use as a method. Whether the SORT function
can be applied successfully to an exotic object that is not an Array is
implementation-dependent.

15.4.3.12 Array.prototype.splice (start, deleteCount [ , item1 [ , item2 [ , … ] ] ] )

When the SPLICE method is called with two or more arguments _start_,
_deleteCount_ and (optionally) _item1_, _item2_, etc., the _deleteCount
elements of the array starting at array index _start_ are replaced by
the arguments _item1_, _item2_, etc. An Array object containing the
deleted elements (if any) is returned. The following steps are taken:

1.  Let _O_ be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(_O_).

3.  Let _A_ be the result of the abstract operation ArrayCreate with
    argument 0.

4.  Let _lenVal_ be the result of Get(_O_, "LENGTH")

5.  Let _len_ be ToUint32(_lenVal_).

6.  ReturnIfAbrupt(_len_).

7.  Let _relativeStart_ be ToInteger(_start_).

8.  ReturnIfAbrupt(_relativeStart_).

9.  If _relativeStart_ is negative, let _actualStart_ be max((_len_ +
    _relativeStart_),0); else let _actualStart_ be min(_relativeStart_,
    _len_).

10. Let _actualDeleteCount_ be min(max(ToInteger(_deleteCount_),0),
    _len_ – _actualStart_).

11. Let _k_ be 0.

12. Repeat, while _k_ < _actualDeleteCount

    a.  Let _from_ be ToString(_actualStart_+_k_).

    b.  Let _fromPresent_ be the result of HasProperty(_O_, _from_).

    c.  ReturnIfAbrupt(_fromPresent_).

    d.  If _fromPresent_ is TRUE, then

        i.  Let _fromValue_ be the result of Get(_O,_ _from_).

        ii. ReturnIfAbrupt(_fromValue_).

        iii. Call the [[DefineOwnProperty]] internal method of _A_ with
            arguments ToString(_k_) and Property Descriptor {[[Value]]:
            _fromValue_, [[Writable]]: TRUE, [[Enumerable]]: TRUE,
            [[Configurable]]: TRUE}.

    e.  Increment _k_ by 1.

13. Let _putStatus_ be the result of Put(_A_, "LENGTH",
    _actualDeleteCount_, TRUE).

14. ReturnIfAbrupt(_putStatus_).

15. Let _items_ be an internal List whose elements are, in left to right
    order, the portion of the actual argument list starting with
    _item1_. The list will be empty if no such items are present.

16. Let _itemCount_ be the number of elements in _items_.

17. If _itemCount_ < _actualDeleteCount_, then

    a.  Let _k_ be _actualStart_.

    b.  Repeat, while _k_ < (_len_ – _actualDeleteCount_)

        i.  Let _from_ be ToString(_k_+_actualDeleteCount_).

        ii. Let _to_ be ToString(_k_+_itemCount_).

        iii. Let _fromPresent_ be the result of HasProperty(_O_,
            _from_).

        iv. ReturnIfAbrupt(_fromPresent_).

        v.  If _fromPresent_ is TRUE, then

            1.  Let _fromValue_ be the result of Get(_O_, _from_).

            2.  ReturnIfAbrupt(_fromValue_).

            3.  Let _putStatus_ be the result of Put(_O_, _to_,
                _fromValue_, TRUE).

            4.  ReturnIfAbrupt(_putStatus_).

        vi. Else _fromPresent_ is FALSE,

            1.  Let _deleteStatus_ be the result of
                DeletePropertyOrThrow(_O_, _to_).

            2.  ReturnIfAbrupt(_deleteStatus_).

        vii. Increase k by 1.

    c.  Let _k_ be _len_.

    d.  Repeat, while _k_ > (_len_ – _actualDeleteCount_ + _itemCount_)

        i.  Let _deleteStatus_ be the result of
            DeletePropertyOrThrow(_O_, ToString(_k_–1)).

        ii. ReturnIfAbrupt(_deleteStatus_).

        iii. Decrease _k_ by 1.

18. Else if _itemCount_ > _actualDeleteCount_, then

    a.  Let _k_ be (_len_ – _actualDeleteCount_).

    b.  Repeat, while _k_ > _actualStart_

        i.  Let _from_ be ToString(_k_ + _actualDeleteCount_ – 1).

        ii. Let _to_ be ToString(_k_ + _itemCount_ – 1)

        iii. Let _fromPresent_ be the result of HasProperty(_O_,
            _from_).

        iv. ReturnIfAbrupt(_fromPresent_).

        v.  If _fromPresent_ is TRUE, then

            1.  Let _fromValue_ be the result of Get(_O_, _from_).

            2.  ReturnIfAbrupt(_fromValue_).

            3.  Let _putStatus_ be the result of Put(_O_, _to_,
                _fromValue_, TRUE).

            4.  ReturnIfAbrupt(_putStatus_).

        vi. Else _fromPresent_ is FALSE,

            1.  Let _deleteStatus_ be the result of
                DeletePropertyOrThrow(_O_, _to_).

            2.  ReturnIfAbrupt(_deleteStatus_).

        vii. Decrease _k_ by 1.

19. Let _k_ be _actualStart_.

20. Repeat, while _items_ is not empty

    a.  Remove the first element from _items_ and let _E_ be the value
        of that element.

    b.  Let _putStatus_ be the result of Put(_O_, ToString(_k_), _E_,
        TRUE).

    c.  ReturnIfAbrupt(_putStatus_).

    d.  Increase _k_ by 1.

21. Let _putStatus_ be the result of Put(_O_, "LENGTH", _len_ –
    _actualDeleteCount_ + _itemCount_, TRUE).

22. ReturnIfAbrupt(_putStatus_).

23. Return _A_.

The LENGTH property of the SPLICE method is 2.

NOTE 1 The explicit setting of the LENGTH property of the result Array
in step 13 is necessary to ensure that its value is correct in
situations where its trailing elements are not present.

NOTE 2 The SPLICE function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the SPLICE
function can be applied successfully to an exotic object that is not an
Array is implementation-dependent.

15.4.3.13 Array.prototype.unshift ( [ item1 [ , item2 [ , … ] ] ] )

The arguments are prepended to the start of the array, such that their
order within the array is the same as the order in which they appear in
the argument list.

When the UNSHIFT method is called with zero or more arguments _item1_,
_item2_, etc., the following steps are taken:

The LENGTH property of the UNSHIFT method is 1.

NOTE The UNSHIFT function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the UNSHIFT
function can be applied successfully to an exotic object that is not an
Array is implementation-dependent.

15.4.3.14 Array.prototype.indexOf ( searchElement [ , fromIndex ] )

INDEXOF compares _searchElement_ to the elements of the array, in
ascending order, using the internal Strict Equality Comparison Algorithm
(11.9.1), and if found at one or more positions, returns the index of
the first such position; otherwise, -1 is returned.

The optional second argument _fromIndex_ defaults to 0 (i.e. the whole
array is searched). If it is greater than or equal to the length of the
array, -1 is returned, i.e. the array will not be searched. If it is
negative, it is used as the offset from the end of the array to compute
_fromIndex_. If the computed index is less than 0, the whole array will
be searched.

When the INDEXOF method is called with one or two arguments, the
following steps are taken:

1.  Let _O_ be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(_O_).

3.  Let _lenValue_ be the result of Get(_O_, "LENGTH")

4.  Let _len_ be ToUint32(_lenValue_).

5.  ReturnIfAbrupt(_len_).

6.  If _len_ is 0, return -1.

7.  If argument _fromIndex_ was passed let _n_ be
    ToInteger(_fromIndex_); else let _n_ be 0.

8.  ReturnIfAbrupt(_n_).

9.  If _n_ ≥ _len_, return -1.

10. If _n_ ≥ 0, then

    a.  Let _k_ be _n_.

11. Else _n_<0,

    a.  Let _k_ be _len_ - abs(_n_).

    b.  If _k_ < 0, then let _k_ be 0.

12. Repeat, while _k_<_len

    a.  Let _kPresent_ be the result of HasProperty(_O_, ToString(_k_)).

    b.  ReturnIfAbrupt(_kPresent_).

    c.  If _kPresent_ is TRUE, then

        i.  Let _elementK_ be the result of Get(_O_, ToString(_k_)).

        ii. ReturnIfAbrupt(_elementK_).

        iii. Let _same_ be the result of performing the Strict Equality
            Comparison Algorithm _searchElement_ === _elementK_.

        iv. If _same_ is TRUE, return _k_.

    d.  Increase _k_ by 1.

13. Return -1.

The LENGTH property of the INDEXOF method is 1.

NOTE The INDEXOF function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the INDEXOF
function can be applied successfully to an exotic object that is not an
Array is implementation-dependent.

15.4.3.15 Array.prototype.lastIndexOf ( searchElement [ , fromIndex ] )

LASTINDEXOF compares _searchElement_ to the elements of the array in
descending order using the internal Strict Equality Comparison Algorithm
(11.9.1), and if found at one or more positions, returns the index of
the last such position; otherwise, -1 is returned.

The optional second argument _fromIndex_ defaults to the array's length
minus one (i.e. the whole array is searched). If it is greater than or
equal to the length of the array, the whole array will be searched. If
it is negative, it is used as the offset from the end of the array to
compute _fromIndex_. If the computed index is less than 0, -1 is
returned.

When the LASTINDEXOF method is called with one or two arguments, the
following steps are taken:

The LENGTH property of the LASTINDEXOF method is 1.

NOTE The LASTINDEXOF function is intentionally generic; it does not
require that its THIS value be an Array object. Therefore it can be
transferred to other kinds of objects for use as a method. Whether the
LASTINDEXOF function can be applied successfully to an exotic object
that is not an Array is implementation-dependent.

15.4.3.16 Array.prototype.every ( callbackfn [ , thisArg ] )

_callbackfn_ should be a function that accepts three arguments and
returns a value that is coercible to the Boolean value TRUE or FALSE.
EVERY calls _callbackfn_ once for each element present in the array, in
ascending order, until it finds one where _callbackfn_ returns FALSE. If
such an element is found, EVERY immediately returns FALSE. Otherwise, if
_callbackfn_ returned TRUE for all elements, EVERY will return TRUE.
_callbackfn_ is called only for elements of the array which actually
exist; it is not called for missing elements of the array.

If a _thisArg_ parameter is provided, it will be used as the THIS value
for each invocation of _callbackfn_. If it is not provided, UNDEFINED is
used instead.

_callbackfn_ is called with three arguments: the value of the element,
the index of the element, and the object being traversed.

EVERY does not directly mutate the object on which it is called but the
object may be mutated by the calls to _callbackfn_.

The range of elements processed by EVERY is set before the first call to
_callbackfn_. Elements which are appended to the array after the call to
EVERY begins will not be visited by _callbackfn_. If existing elements
of the array are changed, their value as passed to _callbackfn_ will be
the value at the time EVERY visits them; elements that are deleted after
the call to EVERY begins and before being visited are not visited. EVERY
acts like the "for all" quantifier in mathematics. In particular, for an
empty array, it returns TRUE.

When the EVERY method is called with one or two arguments, the following
steps are taken:

The LENGTH property of the EVERY method is 1.

NOTE The EVERY function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the EVERY
function can be applied successfully to an exotic object that is not an
Array is implementation-dependent.

15.4.3.17 Array.prototype.some ( callbackfn [ , thisArg ] )

_callbackfn_ should be a function that accepts three arguments and
returns a value that is coercible to the Boolean value TRUE or FALSE.
SOME calls _callbackfn_ once for each element present in the array, in
ascending order, until it finds one where _callbackfn_ returns TRUE. If
such an element is found, SOME immediately returns TRUE. Otherwise, SOME
returns FALSE. _callbackfn_ is called only for elements of the array
which actually exist; it is not called for missing elements of the
array.

If a _thisArg_ parameter is provided, it will be used as the THIS value
for each invocation of _callbackfn_. If it is not provided, UNDEFINED is
used instead.

_callbackfn_ is called with three arguments: the value of the element,
the index of the element, and the object being traversed.

SOME does not directly mutate the object on which it is called but the
object may be mutated by the calls to _callbackfn_.

The range of elements processed by SOME is set before the first call to
_callbackfn_. Elements that are appended to the array after the call to
SOME begins will not be visited by _callbackfn_. If existing elements of
the array are changed, their value as passed to _callbackfn_ will be the
value at the time that SOME visits them; elements that are deleted after
the call to SOME begins and before being visited are not visited. SOME
acts like the "exists" quantifier in mathematics. In particular, for an
empty array, it returns FALSE.

When the SOME method is called with one or two arguments, the following
steps are taken:

The LENGTH property of the SOME method is 1.

NOTE The SOME function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the SOME function
can be applied successfully to an exotic object that is not an Array is
implementation-dependent.

15.4.3.18 Array.prototype.forEach ( callbackfn [ , thisArg ] )

_callbackfn_ should be a function that accepts three arguments. FOREACH
calls _callbackfn_ once for each element present in the array, in
ascending order. _callbackfn_ is called only for elements of the array
which actually exist; it is not called for missing elements of the
array.

If a _thisArg_ parameter is provided, it will be used as the THIS value
for each invocation of _callbackfn_. If it is not provided, UNDEFINED is
used instead.

_callbackfn_ is called with three arguments: the value of the element,
the index of the element, and the object being traversed.

FOREACH does not directly mutate the object on which it is called but
the object may be mutated by the calls to _callbackfn_.

The range of elements processed by FOREACH is set before the first call
to _callbackfn_. Elements which are appended to the array after the call
to FOREACH begins will not be visited by _callbackfn_. If existing
elements of the array are changed, their value as passed to callback
will be the value at the time FOREACH visits them; elements that are
deleted after the call to FOREACH begins and before being visited are
not visited.

When the FOREACH method is called with one or two arguments, the
following steps are taken:

1.  Let _O_ be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(_O_).

3.  Let _lenValue_ be the result of Get(_O_, "LENGTH")

4.  Let _len_ be ToUint32(_lenValue_).

5.  ReturnIfAbrupt(_len_).

6.  If IsCallable(_callbackfn_) is FALSE, throw a TYPEERROR exception.

7.  If _thisArg_ was supplied, let _T_ be _thisArg_; else let _T_ be
    UNDEFINED.

8.  Let _k_ be 0.

9.  Repeat, while _k_ < _len

    a.  Let _Pk_ be ToString(_k_).

    b.  Let _kPresent_ be the result of HasProperty(_O_, _Pk_).

    c.  ReturnIfAbrupt(_kPresent_).

    d.  If _kPresent_ is TRUE, then

        i.  Let _kValue_ be the result of Get(_O_, _Pk_).

        ii. ReturnIfAbrupt(_kValue_).

        iii. Let _funcResult_ be the result of calling the [[Call]]
            internal method of _callbackfn_ with _T_ as _thisArgument_
            and a List containing _kValue_, _k_, and _O_ as
            _argumentsList_.

        iv. ReturnIfAbrupt(_funcResult_).

    e.  Increase _k_ by 1.

10. Return UNDEFINED.

The LENGTH property of the FOREACH method is 1.

NOTE The FOREACH function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the FOREACH
function can be applied successfully to an exotic object that is not an
Array is implementation-dependent.

15.4.3.19 Array.prototype.map ( callbackfn [ , thisArg ] )

_callbackfn_ should be a function that accepts three arguments. MAP
calls _callbackfn_ once for each element in the array, in ascending
order, and constructs a new Array from the results. _callbackfn_ is
called only for elements of the array which actually exist; it is not
called for missing elements of the array.

If a _thisArg_ parameter is provided, it will be used as the THIS value
for each invocation of _callbackfn_. If it is not provided, UNDEFINED is
used instead.

_callbackfn_ is called with three arguments: the value of the element,
the index of the element, and the object being traversed.

MAP does not directly mutate the object on which it is called but the
object may be mutated by the calls to _callbackfn_.

The range of elements processed by MAP is set before the first call to
_callbackfn_. Elements which are appended to the array after the call to
MAP begins will not be visited by _callbackfn_. If existing elements of
the array are changed, their value as passed to _callbackfn_ will be the
value at the time MAP visits them; elements that are deleted after the
call to MAP begins and before being visited are not visited.

When the MAP method is called with one or two arguments, the following
steps are taken:

The LENGTH property of the MAP method is 1.

NOTE The MAP function is intentionally generic; it does not require that
its THIS value be an Array object. Therefore it can be transferred to
other kinds of objects for use as a method. Whether the MAP function can
be applied successfully to an exotic object that is not an Array is
implementation-dependent.

15.4.3.20 Array.prototype.filter ( callbackfn [ , thisArg ] )

_callbackfn_ should be a function that accepts three arguments and
returns a value that is coercible to the Boolean value TRUE or FALSE.
FILTER calls _callbackfn_ once for each element in the array, in
ascending order, and constructs a new array of all the values for which
_callbackfn_ returns TRUE. _callbackfn_ is called only for elements of
the array which actually exist; it is not called for missing elements of
the array.

If a _thisArg_ parameter is provided, it will be used as the THIS value
for each invocation of _callbackfn_. If it is not provided, UNDEFINED is
used instead.

_callbackfn_ is called with three arguments: the value of the element,
the index of the element, and the object being traversed.

FILTER does not directly mutate the object on which it is called but the
object may be mutated by the calls to _callbackfn_.

The range of elements processed by FILTER is set before the first call
to _callbackfn_. Elements which are appended to the array after the call
to FILTER begins will not be visited by _callbackfn_. If existing
elements of the array are changed their value as passed to _callbackfn_
will be the value at the time FILTER visits them; elements that are
deleted after the call to FILTER begins and before being visited are not
visited.

When the FILTER method is called with one or two arguments, the
following steps are taken:

1.  Let _O_ be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(_O_).

3.  Let _lenValue_ be the result of Get(_O_, "LENGTH").

4.  Let _len_ be ToUint32(_lenValue_).

5.  ReturnIfAbrupt(_len_).

6.  If IsCallable(_callbackfn_) is FALSE, throw a TYPEERROR exception.

7.  If _thisArg_ was supplied, let _T_ be _thisArg_; else let _T_ be
    UNDEFINED.

8.  Let _A_ be the result of the abstract operation ArrayCreate with
    argument 0.

9.  Let _k_ be 0.

10. Let _to_ be 0.

11. Repeat, while _k_ < _len

    a.  Let _Pk_ be ToString(_k_).

    b.  Let _kPresent_ be the result of HasProperty(_O_, _Pk_).

    c.  ReturnIfAbrupt(_kPresent_).

    d.  If _kPresent_ is TRUE, then

        i.  Let _kValue_ be the result of Get(_O_, _Pk_).

        ii. ReturnIfAbrupt(_kValue_).

        iii. Let _selected_ be the result of calling the [[Call]]
            internal method of _callbackfn_ with _T_ as _thisArgument_
            and a List containing _kValue_, _k_, and _O_ as
            _argumentsList_.

        iv. ReturnIfAbrupt(_selected_).

        v.  If ToBoolean(_selected_) is TRUE, then

            1.  Call the [[DefineOwnProperty]] internal method of _A_
                with arguments ToString(_to_) and Property Descriptor
                {[[Value]]: _kValue_, [[Writable]]: TRUE,
                [[Enumerable]]: TRUE, [[Configurable]]: TRUE}.

            2.  Increase _to_ by 1.

    e.  Increase _k_ by 1.

12. Return _A_.

The LENGTH property of the FILTER method is 1.

NOTE The FILTER function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the FILTER
function can be applied successfully to an exotic object that is not an
Array is implementation-dependent.

15.4.3.21 Array.prototype.reduce ( callbackfn [ , initialValue ] )

_callbackfn_ should be a function that takes four arguments. REDUCE
calls the callback, as a function, once for each element present in the
array, in ascending order.

_callbackfn_ is called with four arguments: the _previousValue_ (or
value from the previous call to _callbackfn_), the _currentValue_ (value
of the current element), the _currentIndex_, and the object being
traversed. The first time that callback is called, the _previousValue_
and _currentValue_ can be one of two values. If an _initialValue_ was
provided in the call to REDUCE, then _previousValue_ will be equal to
_initialValue_ and _currentValue_ will be equal to the first value in
the array. If no _initialValue_ was provided, then _previousValue_ will
be equal to the first value in the array and _currentValue_ will be
equal to the second. It is a TYPEERROR if the array contains no elements
and _initialValue_ is not provided.

REDUCE does not directly mutate the object on which it is called but the
object may be mutated by the calls to _callbackfn_.

The range of elements processed by REDUCE is set before the first call
to _callbackfn_. Elements that are appended to the array after the call
to REDUCE begins will not be visited by _callbackfn_. If existing
elements of the array are changed, their value as passed to _callbackfn_
will be the value at the time REDUCE visits them; elements that are
deleted after the call to REDUCE begins and before being visited are not
visited.

When the REDUCE method is called with one or two arguments, the
following steps are taken:

1.  Let _O_ be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(_O_).

3.  Let _lenValue_ be the result of Get(_O_, "LENGTH").

4.  Let _len_ be ToUint32(_lenValue_).

5.  ReturnIfAbrupt(_len_).

6.  If IsCallable(_callbackfn_) is FALSE, throw a TYPEERROR exception.

7.  If _len_ is 0 and _initialValue_ is not present, throw a TYPEERROR
    exception.

8.  Let _k_ be 0.

9.  If _initialValue_ is present, then

    a.  Set _accumulator_ to _initialValue_.

10. Else _initialValue_ is not present,

    a.  Let _kPresent_ be FALSE.

    b.  Repeat, while _kPresent_ is FALSE and _k_ < _len_

        i.  Let _Pk_ be ToString(_k_).

        ii. Let _kPresent_ be the result of HasProperty(_O_, _Pk_).

        iii. ReturnIfAbrupt(_kPresent_).

        iv. If _kPresent_ is TRUE, then

            1.  Let _accumulator_ be the result of Get(_O_, _Pk_).

            2.  ReturnIfAbrupt(_accumulator_).

        v.  Increase _k_ by 1.

    c.  If _kPresent_ is FALSE, throw a TYPEERROR exception.

11. Repeat, while _k_ < _len

    a.  Let _Pk_ be ToString(_k_).

    b.  Let _kPresent_ be the result of HasProperty(_O_, _Pk_).

    c.  ReturnIfAbrupt(_kPresent_).

    d.  If _kPresent_ is TRUE, then

        i.  Let _kValue_ be the result of Get(_O_, _Pk_).

        ii. ReturnIfAbrupt(_kValue_).

        iii. Let _accumulator_ be the result of calling the [[Call]]
            internal method of _callbackfn_ with UNDEFINED as
            _thisArgument_ and a List containing _accumulator_,
            _kValue_, _k_, and _O_ as _argumentsList_.

        iv. ReturnIfAbrupt(_accumulator_).

    e.  Increase _k_ by 1.

12. Return _accumulator_.

The LENGTH property of the REDUCE method is 1.

NOTE The REDUCE function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the REDUCE
function can be applied successfully to an exotic object that is not an
Array is implementation-dependent.

15.4.3.22 Array.prototype.reduceRight ( callbackfn [ , initialValue ] )

_callbackfn_ should be a function that takes four arguments. REDUCERIGHT
calls the callback, as a function, once for each element present in the
array, in descending order.

_callbackfn_ is called with four arguments: the _previousValue_ (or
value from the previous call to _callbackfn_), the _currentValue_ (value
of the current element), the _currentIndex_, and the object being
traversed. The first time the function is called, the _previousValue_
and _currentValue_ can be one of two values. If an _initialValue_ was
provided in the call to REDUCERIGHT, then _previousValue_ will be equal
to _initialValue_ and _currentValue_ will be equal to the last value in
the array. If no _initialValue_ was provided, then _previousValue_ will
be equal to the last value in the array and _currentValue_ will be equal
to the second-to-last value. It is a TYPEERROR if the array contains no
elements and _initialValue_ is not provided.

REDUCERIGHT does not directly mutate the object on which it is called
but the object may be mutated by the calls to _callbackfn_.

The range of elements processed by REDUCERIGHT is set before the first
call to _callbackfn_. Elements that are appended to the array after the
call to REDUCERIGHT begins will not be visited by _callbackfn_. If
existing elements of the array are changed by _callbackfn_, their value
as passed to _callbackfn_ will be the value at the time REDUCERIGHT
visits them; elements that are deleted after the call to REDUCERIGHT
begins and before being visited are not visited.

When the REDUCERIGHT method is called with one or two arguments, the
following steps are taken:

The LENGTH property of the REDUCERIGHT method is 1.

NOTE The REDUCERIGHT function is intentionally generic; it does not
require that its this value be an Array object. Therefore it can be
transferred to other kinds of objects for use as a method. Whether the
REDUCERIGHT function can be applied successfully to an exotic object
that is not an Array is implementation-dependent.

15.4.3.23 Array.prototype.find ( predicate , thisArg = undefined )

_predicate_ should be a function that accepts three arguments and
returns a value that is coercible to the Boolean value TRUE or FALSE.
FIND calls _predicate_ once for each element present in the array, in
ascending order, until it finds one where _predicate_ returns TRUE. If
such an element is found, FIND immediately returns that element value.
Otherwise, FIND returns UNDEFINED. _predicate_ is called only for
elements of the array which actually exist; it is not called for missing
elements of the array.

If a _thisArg_ parameter is provided, it will be used as the THIS value
for each invocation of _predicate_. If it is not provided, UNDEFINED is
used instead.

_predicate_ is called with three arguments: the value of the element,
the index of the element, and the object being traversed.

FIND does not directly mutate the object on which it is called but the
object may be mutated by the calls to _predicate_.

The range of elements processed by FIND is set before the first call to
_callbackfn_. Elements that are appended to the array after the call to
FIND begins will not be visited by _callbackfn_. If existing elements of
the array are changed, their value as passed to _predicate_ will be the
value at the time that FIND visits them; elements that are deleted after
the call to FIND begins and before being visited are not visited.

When the FIND method is called with one or two arguments, the following
steps are taken:

1.  Let _O_ be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(_O_).

3.  Let _lenValue_ be the result of Get(_O_, "LENGTH").

4.  Let _len_ be ToInteger(_lenValue_).

5.  ReturnIfAbrupt(_len_).

6.  If IsCallable(_predicate_) is FALSE, throw a TYPEERROR exception.

7.  If _thisArg_ was supplied, let _T_ be _thisArg_; else let _T_ be
    UNDEFINED.

8.  Let _k_ be 0.

9.  Repeat, while _k_ < _len

    a.  Let _Pk_ be ToString(_k_).

    b.  Let _kPresent_ be the result of HasProperty(_O_, _Pk_).

    c.  ReturnIfAbrupt(_kPresent_).

    d.  If _kPresent_ is TRUE, then

        i.  Let _kValue_ be the result of Get(_O_, _Pk_).

        ii. ReturnIfAbrupt(_kValue_).

        iii. Let _testResult_ be the result of calling the [[Call]]
            internal method of _predicate_ with _T_ as _thisArgument_
            and a List containing _kValue_, _k_, and _O_ as
            _argumentsList_.

        iv. ReturnIfAbrupt(_testResult_).

        v.  If ToBoolean(_testResult)_ is TRUE, return _kValue_.

    e.  Increase _k_ by 1.

10. Return UNDEFINED.

The LENGTH property of the FIND method is 1.

NOTE The FIND function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the FIND function
can be applied successfully to an exotic object that is not an Array is
implementation-dependent.

15.4.3.24 Array.prototype.findIndex ( predicate , thisArg = undefined )

_predicate_ should be a function that accepts three arguments and
returns a value that is coercible to the Boolean value TRUE or FALSE.
FINDINDEX calls _predicate_ once for each element present in the array,
in ascending order, until it finds one where _predicate_ returns TRUE.
If such an element is found, FINDINDEX immediately returns the index of
that element value. Otherwise, FINDINDEX returns -1. _predicate_ is
called only for elements of the array which actually exist; it is not
called for missing elements of the array.

If a _thisArg_ parameter is provided, it will be used as the THIS value
for each invocation of _predicate_. If it is not provided, UNDEFINED is
used instead.

_predicate_ is called with three arguments: the value of the element,
the index of the element, and the object being traversed.

FINDINDEX does not directly mutate the object on which it is called but
the object may be mutated by the calls to _predicate_.

The range of elements processed by FINDINDEX is set before the first
call to _callbackfn_. Elements that are appended to the array after the
call to FIND begins will not be visited by _callbackfn_. If existing
elements of the array are changed, their value as passed to _predicate_
will be the value at the time that FINDINDEX visits them; elements that
are deleted after the call to FINDINDEX begins and before being visited
are not visited.

When the FINDINDEX method is called with one or two arguments, the
following steps are taken:

1.  Let _O_ be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(_O_).

3.  Let _lenValue_ be the result of Get(_O_, "LENGTH").

4.  Let _len_ be ToInteger(_lenValue_).

5.  ReturnIfAbrupt(_len_).

6.  If IsCallable(_predicate_) is FALSE, throw a TYPEERROR exception.

7.  If _thisArg_ was supplied, let _T_ be _thisArg_; else let _T_ be
    UNDEFINED.

8.  Let _k_ be 0.

9.  Repeat, while _k_ < _len

    a.  Let _Pk_ be ToString(_k_).

    b.  Let _kPresent_ be the result of HasProperty(_O_, _Pk_).

    c.  ReturnIfAbrupt(_kPresent_).

    d.  If _kPresent_ is TRUE, then

        i.  Let _kValue_ be the result of Get(_O_, _Pk_).

        ii. ReturnIfAbrupt(_kValue_).

        iii. Let _testResult_ be the result of calling the [[Call]]
            internal method of _predicate_ with _T_ as _thisArgument_
            and a List containing _kValue_, _k_, and _O_ as
            _argumentsList_.

        iv. ReturnIfAbrupt(_testResult_).

        v.  If ToBoolean(_testResult)_ is TRUE, return _k_.

    e.  Increase _k_ by 1.

10. Return -1.

The LENGTH property of the FINDINDEX method is 1.

NOTE The FINDINDEX function is intentionally generic; it does not
require that its THIS value be an Array object. Therefore it can be
transferred to other kinds of objects for use as a method. Whether the
FINDINDEX function can be applied successfully to an exotic object that
is not an Array is implementation-dependent.

15.4.3.25 Array.prototype.entries ( )

The following steps are taken:

1.  Let _O_ be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(_O_).

3.  Return the result of calling the CreateArrayIterator abstract
    operation with arguments _O_ and "KEY+VALUE".

15.4.3.26 Array.prototype.keys ( )

The following steps are taken:

1.  Let _O_ be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(_O_).

3.  Return the result of calling the CreateArrayIterator abstract
    operation with arguments _O_ and "KEY".

15.4.3.27 Array.prototype.values ( )

The following steps are taken:

1.  Let _O_ be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(_O_).

3.  Return the result of calling the CreateArrayIterator abstract
    operation with arguments _O_ and "VALUE".

15.4.3.28 Array.prototype.@@iterator ( )

The initial value of the @@iterator property is the same function object
as the initial value of the ARRAY.PROTOTYPE.VALUES property.

15.4.4 Properties of Array Instances

Array instances are exotic Array objects and have the internal methods
specified for such objects. Array instances inherit properties from the
Array prototype object. Array instances also have a
[Array[InitialisationState]] internal data property .

Array instances have a LENGTH property, and a set of enumerable
properties with array index names.

15.4.4.1 length

The LENGTH property of this Array object is a data property whose value
is always numerically greater than the name of every deletable property
whose name is an array index.

The LENGTH property initially has the attributes { [[Writable]]: TRUE,
[[Enumerable]]: FALSE, [[Configurable]]: FALSE }.

NOTE Attempting to set the length property of an Array object to a value
that is numerically less than or equal to the largest numeric property
name of an existing array indexed non-deletable property of the array
will result in the length being set to a numeric value that is one
greater than that largest numeric property name. See 8.4.2.1.

15.4.5 Array Iterator Object Structure

An Array Iterator is an object, with the structure defined below, that
represent a specific iteration over some specific Array instance object.
There is not a named constructor for Array Iterator objects. Instead,
Array iterator objects are created by calling certain methods of Array
instance objects.

15.4.5.1 CreateArrayIterator Abstract Operation

Several methods of Array objects return Iterator objects. The abstract
operation CreateArrayIterator with arguments _array_ and _kind_ is used
to create and such iterator objects. It performs the following steps:

1.  Let _O_ be the result of calling ToObject(_array_).

2.  ReturnIfAbrupt(_O_).

3.  Let _itr_ be the result of the abstract operation ObjectCreate with
    the intrinsic object %ArrayIteratorPrototype% as its argument.

4.  Add a [[IteratedObject]] internal data property to _itr_ with value
    _O_.

5.  Add a [[ArrayIteratorNextIndex]] internal data property to _itr
    with value 0.

6.  Add a [[ArrayIterationKind]] internal data property of _itr_ with
    value _kind_.

7.  Return _itr_.

15.4.5.2 The Array Iterator Prototype

All Array Iterator Objects inherit properties from a common Array
Iterator Prototype object. The [[Prototype]] internal data property of
the Array Iterator Prototype is the %ObjectPrototype% intrinsic object.
In addition, the Array Iterator Prototype as the following properties:

15.4.5.2.1 _ArrayIterator_.prototype.constructor

15.4.5.2.2 _ArrayIterator_.prototype.next( )

1.  Let _O_ be the THIS value.

2.  If Type(_O_) is not Object, throw a TYPEERROR exception.

3.  If _O_ does not have all of the internal properties of a Array
    Iterator Instance (15.4.5.1.2), throw a TYPEERROR exception.

4.  Let _a_ be the value of the [[IteratedObject]] internal data
    property of _O_.

5.  Let _index_ be the value of the [[ArrayIteratorNextIndex]] internal
    data property of _O_.

6.  Let _itemKind_ be the value of the [[ArrayIterationKind]] internal
    data property of _O_.

7.  Let _lenValue_ be the result of Get(_a_, "LENGTH").

8.  Let _len_ be ToUint32(_lenValue_).

9.  ReturnIfAbrupt(_len_).

10. If _itemKind_ contains the substring "SPARSE", then

    a.  Let _found_ be FALSE.

    b.  Repeat, while _found_ is FALSE and _index_ < _len_

        i.  Let _elementKey_ be ToString(_index_).

        ii. Let _found_ be the result of HasProperty(_a_, _elementKey_).

        iii. ReturnIfAbrupt(_found_).

        iv. If _found_ is FALSE, then

            1.  Increase _index_ by 1.

11. If _index_ ≥ _len_, then

    a.  Set the value of the [[ArrayIteratorNextIndex]] internal data
        property of _O_ to +∞.

    b.  Return CreateItrResultObject(UNDEFINED, TRUE).

12. Let _elementKey_ be ToString(_index_).

13. Set the value of the [[ArrayIteratorNextIndex]] internal data
    property of _O_ to _index_+1.

14. If _itemKind_ contains the substring "VALUE", then

    a.  Let _elementValue_ be the result of Get(_a_, _elementKey_).

    b.  ReturnIfAbrupt(_elementValue_).

15. If _itemKind_ contains the substring "KEY+VALUE", then

    a.  Let _result_ be the result of the abstract operation ArrayCreate
        with argument 2.

    b.  Assert: _result_ is a new, well-formed Array object so the
        following operations will never fail.

    c.  Call the [[DefineOwnProperty]] internal method of _result_ with
        arguments "0" and Property Descriptor {[[Value]]: _elementKey_,
        [[Writable]]: TRUE, [[Enumerable]]: TRUE, [[Configurable]]:
        TRUE}.

    d.  Call the [[DefineOwnProperty]] internal method of _result_ with
        arguments "1" and Property Descriptor {[[Value]]:
        _elementValue_, [[Writable]]: TRUE, [[Enumerable]]: TRUE,
        [[Configurable]]: TRUE}.

    e.  Return CreateItrResultObject(_result_, FALSE).

16. Else If _itemKind_ contains the substring "KEY" then, return
    CreateItrResultObject(_elementKey_, FALSE).

17. Assert: _itemKind_ contains the substring "VALUE",

18. Return CreateItrResultObject(_elementValue_, FALSE).

15.4.5.2.3 _ArrayIterator_.prototype.@@iterator ( )

The following steps are taken:

1.  Return the THIS value.

15.4.5.2.4 _ArrayIterator_.prototype.@@toStringTag

The initial value of the @@toStringTag property is the string value
"ARRAY ITERATOR".

15.4.5.3 Properties of Array Iterator Instances

Array Iterator instances inherit properties from the Array Iterator
prototype (the intrinsic, %ArrayIteratorPrototype%.) Array Iterator
instances are initially created with the internal properties listed in
Table 32.

Table 32 — Internal Data Properties of Array Iterator Instances

  ----------------------------- --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  INTERNAL DATA PROPERTY NAME   DESCRIPTION
  [[IteratedObject]]            The object whose array elements are being iterated.
  [[ArrayIteratorNextIndex]]    The integer index of the next array index to be examined by this iteration.
  [[ArrayIterationKind]]        A string value that identifies what is to be returned for each element of the iteration. The possible values are: "KEY", "VALUE", "KEY+VALUE", "SPARSE:KEY", "SPARSE:VALUE", "SPARSE:KEY+VALUE".
  ----------------------------- --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


15.5 String Objects

15.5.1 The String Constructor Called as a Function

When STRING is called as a function rather than as a constructor, it
performs a type conversion. However, if the THIS value value passed in
the call is an Object with an uninitialized [[StringData]] internal data
property, it initializes the THIS value using the argument value. This
permits STRING to be used both to perform type conversion and to perform
constructor instance initialization.

STRING may be subclassed and subclass constructors may perform a super
invocation of the STRING constructor to initialize the [[StringData]]
state of subclass instances.

15.5.1.1 String ( [ value ] )

Returns a String value (not a String object) computed by
ToString(_value_). If _value_ is not supplied, the empty String "" is
returned.

When STRING is called with argument _value_, the following steps are
taken:

1.  Let _O_ be the THIS value.

2.  If no arguments were passed to this function invocation, then let
    _s_ be "".

3.  Else, let _s_ be ToString(_value_).

4.  ReturnIfAbrupt(_s_).

5.  If Type(_O_) is Object and _O_ has a [[StringData]] internal data
    property and the value of [[StringData]] is UNDEFINED, then

    a.  Let _length_ be the number of code unit elements in _s._

    b.  Let _status_ be the result of DefinePropertyOrThrow(_O_,
        "LENGTH", Property Descriptor{[[Value]]: _length_, [[Writable]]:
        FALSE, [[Enumerable]]: FALSE, [[Configurable]]: FALSE }).

    c.  ReturnIfAbrupt(_status_).

    d.  Set the value of _O’s_ [[StringData]] internal data property to
        _s_.

    e.  Return _O_.

6.  Return _s_.

15.5.2 The String Constructor

When STRING is called as part of a NEW expression, it is a constructor:
it initialises the newly created exotic String object.

15.5.2.1 new String ( value )

STRING called as part of a new expression with optional argument _value_
performs the following steps:

1.  Let _F_ be the STRING function object on which the NEW operator was
    applied.

2.  Let _argumentsList_ be the _argumentsList_ argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of OrdinaryConstruct (_F_, _argumentsList_).

If STRING is implemented as an ordinary function object, its
[[Construct]] internal method will perform the above steps.

15.5.3 Properties of the String Constructor

The value of the [[Prototype]] internal data property of the String
constructor is the standard built-in Function prototype object (15.3.3).

Besides the LENGTH property (whose value is 1), the String constructor
has the following properties:

15.5.3.1 String.prototype

The initial value of STRING.PROTOTYPE is the standard built-in String
prototype object (15.5.4).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

15.5.3.2 String.fromCharCode ( ...codeUnits)

The STRING.FROMCHARCODE function may be called with a variable number of
arguments which form the rest parameter _codeUnits_. The following steps
are taken:

The LENGTH property of the FROMCHARCODE function is 1.

15.5.3.3 String.fromCodePoint ( ...codePoints)

The STRING.FROMCODEPOINT function may be called with a variable number
of arguments which form the rest parameter _codePoints_. The following
steps are taken:

1.  Assert: _codePoints_ is a well-formed rest parameter object.

2.  Let _length_ be the result of Get(_codePoints_, "LENGTH").

3.  Let _elements_ be a new List.

4.  Let _nextIndex_ be 0.

5.  Repeat while _nextIndex_ < _length

    a.  Let _next_ be the result of Get(_codePoints_,
        ToString(_nextIndex_)).

    b.  Let _nextCP_ be ToNumber(_next_).

    c.  ReturnIfAbrupt(_nextCP_).

    d.  If SameValue(_nextCP_, ToInteger(_nextCP_)) is FALSE,then throw
        a RANGEERROR exception.

    e.  If _nextCP_ < 0 or _nextCP_ > 0x10FFFF, then throw a RANGEERROR
        exception.

    f.  Append the elements of the UTF-16 Encoding (clause 6) of
        _nextCP_ to the end of _elements_.

    g.  Let _nextIndex_ be _nextIndex_ + 1.

6.  Return the String value whose elements are, in order, the elements
    in the List _elements_. If _length_ is 0, the empty string is
    returned.

The LENGTH property of the FROMCODEPOINT function is 0.

15.5.3.4 String.raw ( callSite, ...substitutions)

The STRING.RAW function may be called with a variable number of
arguments. The first argument is _callSite_ and the remainder of the
arguments form the rest parameter _substitutions_. The following steps
are taken:

1.  Assert: _substitutions_ is a well-formed rest parameter object.

2.  Let _cooked_ be ToObject(_callSite_).

3.  ReturnIfAbrupt(_cooked_).

4.  Let _rawValue_ be the result of Get(_cooked_, "RAW").

5.  Let _raw_ be ToObject(_rawValue_).

6.  ReturnIfAbrupt(_raw_).

7.  Let _len_ be the result of Get(_raw_, "LENGTH").

8.  Let _literalSegments_ be ToUint(_len_).

9.  ReturnIfAbrupt(_literalSegments_).

10. If _literalSegments_ = 0, then return the empty string.

11. Let _stringElements_ be a new List.

12. Let _nextIndex_ be 0.

13. Repeat

    a.  Let _nextKey_ be ToString(_nextIndex_).

    b.  Let _next_ be the result of Get(_raw_, _nextKey_).

    c.  Let _nextSeg_ be ToString(_next_).

    d.  ReturnIfAbrupt(_nextSeg_).

    e.  Append in order the code unit elements of _nextSeg_ to the end
        of _stringElements_.

    f.  If _nextIndex_ + 1 = _literalSegments_, then

        i.  Return the string value whose elements are, in order, the
            elements in the List _stringElements_. If _length_ is 0, the
            empty string is returned.

    g.  Let _next_ be the result of Get(_substitutions_, _nextKey_).

    h.  Let _nextSub_ be ToString(_next_).

    i.  ReturnIfAbrupt(_nextSub_).

    j.  Append in order the code unit elements of _nextSub_ to the end
        of _stringElements_.

    k.  Let _nextIndex_ be _nextIndex_ + 1.

The LENGTH property of the RAW function is 1.

NOTE String.raw is intended for use as a tag function of a Tagged
Template String (11.2.6). When called as such the first argument will be
a well formed template call site object and the rest parameter will
contain the substitution values.

15.5.3.5 String[ @@create ] ( )

The @@create method of an object _F_ performs the following steps:

1.  Let _F_ be the THIS value.

2.  Let _proto_ be the result of GetPrototypeFromConstructor(_F_,
    "%STRINGPROTOTYPE%").

3.  ReturnIfAbrupt(_proto_).

4.  Let _obj_ be the result of calling StringCreate (_proto_).

5.  Return _obj_.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

NOTE [[StringData]] is initially assigned the value UNDEFINED as a flag
to indicate that the instance has not yet been initialized by the String
constructor. This flag value is never directly exposed to ECMAScript
code; hence implementation may choose to encode the flag in some other
manner.

15.5.4 Properties of the String Prototype Object

The String prototype object is itself an ordinary object. It is not a
String instance and does not have a [[StringData]] internal data
property.

The value of the [[Prototype]] internal data property of the String
prototype object is the standard built-in Object prototype object
(15.2.4).

Unless explicitly stated otherwise, the methods of the String prototype
object defined below are not generic and the this value passed to them
must be either a String value or an object that has a [[StringData]]
internal data property that has been initialized to a String value.

The abstract operation thisStringValue(_value_) performs the following
steps:

1.  If Type(_value_) is String, return _value_.

2.  If Type(_value)_ is Object and _value_ has a [[StringData]] internal
    data property, then

    a.  Let _s_ be the value of _value’s_ [[StringData]] internal data
        property.

    b.  If _s_ is not UNDEFINED, then return _s_.

3.  Throw a TYPEERROR exception.

The phrase “this String value” within the specification of a method
refers to the result returned by calling the abstract operation
thisStringValue with the THIS value of the method invocation passed as
the argument.

15.5.4.1 String.prototype.constructor

The initial value of STRING.PROTOTYPE.CONSTRUCTOR is the built-in STRING
constructor.

15.5.4.2 String.prototype.toString ( )

When the TOSTRING method is called, the following steps are taken:

NOTE For a String object, the TOSTRING method happens to return the same
thing as the VALUEOF method.

15.5.4.3 String.prototype.valueOf ( )

When the VALUEOF method is called, the following steps are taken:

1.  Let _s_ be thisStringValue(THIS value).

2.  Return _s_.

15.5.4.4 String.prototype.charAt (pos)

NOTE Returns a single element String containing the code unit at element
position _pos_ in the String value resulting from converting this object
to a String. If there is no element at that position, the result is the
empty String. The result is a String value, not a String object.

If _pos_ is a value of Number type that is an integer, then the result
of X.CHARAT(_pos_) is equal to the result of X.SUBSTRING(_pos_,
_pos_+1).

When the CHARAT method is called with one argument _pos_, the following
steps are taken:

1.  Let _O_ be CheckObjectCoercible(THIS value).

2.  Let _S_ be ToString(_O_).

3.  ReturnIfAbrupt(_S_).

4.  Let _position_ be ToInteger(_pos_).

5.  ReturnIfAbrupt(_position_).

6.  Let _size_ be the number of elements in _S_.

7.  If _position_ < 0 or _position_ ≥ _size_, return the empty String.

8.  Return a String of length 1, containing one code unit from _S_,
    namely the code unit at position _position_, where the first
    (leftmost) code unit in _S_ is considered to be at position 0, the
    next one at position 1, and so on.

NOTE The CHARAT function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

15.5.4.5 String.prototype.charCodeAt (pos)

NOTE Returns a Number (a nonnegative integer less than 2^16^) that is
the code unit value of the string element at position _pos_ in the
String resulting from converting this object to a String. If there is no
element at that position, the result is NAN.

When the CHARCODEAT method is called with one argument _pos_, the
following steps are taken:

1.  Let _O_ be CheckObjectCoercible(THIS value).

2.  Let _S_ be ToString(_O_).

3.  ReturnIfAbrupt(_S_).

4.  Let _position_ be ToInteger(_pos_).

5.  ReturnIfAbrupt(_position_).

6.  Let _size_ be the number of elements in _S_.

7.  If _position_ < 0 or _position_ ≥ _size_, return NAN.

8.  Return a value of Number type, whose value is the code unit value of
    the element at position _position_ in the String _S_, where the
    first (leftmost) element in _S_ is considered to be at position 0,
    the next one at position 1, and so on.

NOTE The CHARCODEAT function is intentionally generic; it does not
require that its THIS value be a String object. Therefore it can be
transferred to other kinds of objects for use as a method.

15.5.4.6 String.prototype.concat ( ...args )

NOTE When the CONCAT method is called with zero or more arguments, it
returns a String consisting of the string elements of this object
(converted to a String) followed by the string elements of each of the
arguments converted to a String. The result is a String value, not a
String object.

The following steps are taken:

The LENGTH property of the CONCAT method is 1.

NOTE The CONCAT function is intentionally generic; it does not require
that its THIS value be a String object. Therefore it can be transferred
to other kinds of objects for use as a method.

15.5.4.7 String.prototype.indexOf (searchString, position)

If _searchString_ appears as a substring of the result of converting
this object to a String, at one or more positions that are greater than
or equal to _position_, then the index of the smallest such position is
returned; otherwise, 1 is returned. If _position_ is UNDEFINED, 0 is
assumed, so as to search all of the String.

The INDEXOF method takes two arguments, _searchString_ and _position_,
and performs the following steps:

The LENGTH property of the INDEXOF method is 1.

NOTE The INDEXOF function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

15.5.4.8 String.prototype.lastIndexOf (searchString, position)

If _searchString_ appears as a substring of the result of converting
this object to a String at one or more positions that are smaller than
or equal to _position_, then the index of the greatest such position is
returned; otherwise, 1 is returned. If _position_ is UNDEFINED, the
length of the String value is assumed, so as to search all of the
String.

The LASTINDEXOF method takes two arguments, _searchString_ and
_position_, and performs the following steps:

The LENGTH property of the LASTINDEXOF method is 1.

NOTE The LASTINDEXOF function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

15.5.4.9 String.prototype.localeCompare (that)

When the LOCALECOMPARE method is called with one argument _that_, it
returns a Number other than NAN that represents the result of a
locale-sensitive String comparison of the this value (converted to a
String) with _that_ (converted to a String). The two Strings are _S_ and
_That_. The two Strings are compared in an implementation-defined
fashion. The result is intended to order String values in the sort order
specified by the system default locale, and will be negative, zero, or
positive, depending on whether _S_ comes before _That_ in the sort
order, the Strings are equal, or _S_ comes after _That_ in the sort
order, respectively.

Before perform the comparisons the following steps are performed to
prepare the Strings:

1.  Let _O_ be CheckObjectCoercible(THIS value).

2.  Let _S_ be ToString(_O_).

3.  ReturnIfAbrupt(_S_).

4.  Let _That_ be ToString(_that_).

5.  ReturnIfAbrupt(_That_).

The LOCALECOMPARE method, if considered as a function of two arguments
THIS and _that_, is a consistent comparison function (as defined in
15.4.3.11) on the set of all Strings.

The actual return values are implementation-defined to permit
implementers to encode additional information in the value, but the
function is required to define a total ordering on all Strings and to
return 0 when comparing Strings that are considered canonically
equivalent by the Unicode standard.

If no language-sensitive comparison at all is available from the host
environment, this function may perform a bitwise comparison.

NOTE 1 The LOCALECOMPARE method itself is not directly suitable as an
argument to ARRAY.PROTOTYPE.SORT because the latter requires a function
of two arguments.

NOTE 2 This function is intended to rely on whatever language-sensitive
comparison functionality is available to the ECMAScript environment from
the host environment, and to compare according to the rules of the host
environment’s current locale. It is strongly recommended that this
function treat Strings that are canonically equivalent according to the
Unicode standard as identical (in other words, compare the Strings as if
they had both been converted to Normalised Form C or D first). It is
also recommended that this function not honour Unicode compatibility
equivalences or decompositions.

NOTE 3 The second parameter to this function is likely to be used in a
future version of this standard; it is recommended that implementations
do not use this parameter position for anything else.

NOTE 4 The LOCALECOMPARE function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

15.5.4.10 String.prototype.match (regexp)

When the MATCH method is called with argument _regexp_, the following
steps are taken:

NOTE The MATCH function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

15.5.4.11 String.prototype.replace (searchValue, replaceValue)

When the REPLACE method is called with arguments _searchValue_ and
_replaceValue_ the following steps are taken:

1.  Let _O_ be CheckObjectCoercible(THIS value).

2.  Let _string_ be ToString(_O_).

3.  ReturnIfAbrupt(_string_).

4.  If Type(_searchValue_) is Object and HasProperty(_searchValue_,
    @@isRegExp) is TRUE, then

    a.  Let _args_ be a new List with elements _string_ and
        _replaceValue_.

    b.  Return the result of Invoke(_searchValue_, "REPLACE", _args_).

    c.  

5.  6.  Let _searchString_ be ToString(_searchValue_).

7.  ReturnIfAbrupt(_searchString_).

8.  Search _string_ for the first occurrence of _searchString_ and let
    _pos_ be the index position within _string_ of the first code unit
    of the matched substring and let _matched_ be _searchString_. If no
    occurrences of _searchString_ were found, return _string_.

9.  If IsCallable(_replaceValue_) is TRUE, then

    a.  Let _replValue_ be the result of calling the [[Call]] internal
        methods of _replaceValue_ passing UNDEFINED as the THIS value
        and a List containing _matched_, _pos_, and _string_ as the
        argument list.

    b.  Let _replStr_ be ToString(_replValue_).

    c.  ReturnIfAbrupt(_replStr_).

10. Else,

    a.  Let _captures_ be an empty List.

    b.  Let _replStr_ be the result of the abstract operation
        GetReplaceSubstitution(_matched_, _string_, _pos_, _captures_).

11. Let _tailPos_ be _pos_ + the number of code units in _matched_.

12. Let _newString_ be the String formed by concatenating the first
    _pos_ code units of _string_, _replString_, and the trailing
    substring of _string_ starting at index _tailPos_. If _pos_ is 0,
    the first element of the concatenation will be the empty String.

13. Return _newString_.

NOTE The REPLACE function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

RUNTIME SEMANTICS: GETREPLACESUBSTITUTION ABSTRACT OPERATION

The abstract operation GetReplaceSubstitution(_matched_, _string_,
_position_, _captures_) performs the following steps:

1.  Assert: Type(_matched_) is String.

2.  Let _matchLength_ be the number of code units in _matched_.

3.  Assert: Type(_string_) is String.

4.  Let _stringLength_ be the number of code units in _string_.

5.  Assert: _position_ is a non-negative integer.

6.  Assert: _position_ ≤ _stringLength_.

7.  Assert: _captures_ is a possibly empty List of Strings.

8.  Let _tailPos_ be _position_ + _matchLength_.

9.  Let _m_ be the number of elements in _captures_.

10. Let _result_ be a String value derived from _matched_ by replacing
    code unit elements in _matched_ by replacement text as specified in
    Table 33. These $ replacements are done left-to-right, and, once
    such a replacement is performed, the new replacement text is not
    subject to further replacements.

11. 12. Return _result_.

Table 33 — Replacement Text Symbol Substitutions

  --------------------- ------------------------------------------------------------------------- --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  Code unit             Unicode Characters                                                        Replacement text

  0x0024, 0x0024        $$                                                                        $

  0x0024, 0x0026        $&                                                                        _matched_

  0x0024, 0x0060        $`                                                                        If _position_ is 0, the replacement is the empty String. Otherwise the replacement is the substring of _string_ that starts at index 0 and whose last code point is at index _position_ -1.

  0x0024, 0x0027        $'                                                                        If _tailPos_ ≥ _stringLength_, the replacement is the empty String. Otherwise the replacement is the substring of _string_ that starts at index _tailPos_ and continues to the end of _string_.

  0x0024, N where       $N where                                                                  The _n_^th^ element of _captures_, where _n_ is a single digit in the range 1 to 9. If _n_≤_m_ and the _n_th element of _captures_ is UNDEFINED, use the empty String instead. If _n_>_m_, the result is implementation-defined.
  0x0031 ≤ N ≤ 0x0039   N is one of 1 2 3 4 5 6 7 8 9 and $N is not followed by a decimal digit   

  0x0024, N, N where    $NN where                                                                 The _nn_^th^ elemet of _captures_, where _nn_ is a two-digit decimal number in the range 01 to 99. If _nn_≤_m_ and the _nn_^th^ element of _captures_ is UNDEFINED, use the empty String instead. If _nn_ is 00 or _nn_>_m_, the result is implementation-defined.
  0x0030 ≤ N ≤ 0x0039   N is one of 0 1 2 3 4 5 6 7 8 9                                           

  0x0024                $ in any context that does not match on of the above.                     $
  --------------------- ------------------------------------------------------------------------- --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

15.5.4.12 String.prototype.search (regexp)

When the search method is called with argument _regexp_, the following
steps are taken:

NOTE The SEARCH function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

15.5.4.13 String.prototype.slice (start, end)

The SLICE method takes two arguments, _start_ and _end_, and returns a
substring of the result of converting this object to a String, starting
from element position _start_ and running to, but not including, element
position _end_ (or through the end of the String if _end_ is UNDEFINED).
If _start_ is negative, it is treated as _sourceLength_+_start_ where
_sourceLength_ is the length of the String. If _end_ is negative, it is
treated as _sourceLength_+_end_ where _sourceLength_ is the length of
the String. The result is a String value, not a String object. The
following steps are taken:

The LENGTH property of the SLICE method is 2.

NOTE The SLICE function is intentionally generic; it does not require
that its THIS value be a String object. Therefore it can be transferred
to other kinds of objects for use as a method.

15.5.4.14 String.prototype.split (separator, limit)

Returns an Array object into which substrings of the result of
converting this object to a String have been stored. The substrings are
determined by searching from left to right for occurrences of
_separator_; these occurrences are not part of any substring in the
returned array, but serve to divide up the String value. The value of
_separator_ may be a String of any length or it may be a RegExp object.

The value of _separator_ may be an empty String, an empty regular
expression, or a regular expression that can match an empty String. In
this case, _separator_ does not match the empty substring at the
beginning or end of the input String, nor does it match the empty
substring at the end of the previous separator match. (For example, if
_separator_ is the empty String, the String is split up into individual
code unit elements; the length of the result array equals the length of
the String, and each substring contains one code unit.) If _separator_
is a regular expression, only the first match at a given position of the
THIS String is considered, even if backtracking could yield a
non-empty-substring match at that position. (For example,
"AB".SPLIT(/A*?/) evaluates to the array ["A","B"], while
"AB".SPLIT(/A*/) evaluates to the array["","B"].)

If the THIS object is (or converts to) the empty String, the result
depends on whether _separator_ can match the empty String. If it can,
the result array contains no elements. Otherwise, the result array
contains one element, which is the empty String.

If _separator_ is a regular expression that contains capturing
parentheses, then each time _separator_ is matched the results
(including any UNDEFINED results) of the capturing parentheses are
spliced into the output array. For example,

  "A<B>BOLD</B>AND<CODE>CODED</CODE>".SPLIT(/<(\/)?([^<>]+)>/)

evaluates to the array

  ["A", UNDEFINED, "B", "BOLD", "/", "B", "AND", UNDEFINED,
   "CODE", "CODED", "/", "CODE", ""]

If _separator_ is UNDEFINED, then the result array contains just one
String, which is the THIS value (converted to a String). If _limit_ is
not UNDEFINED, then the output array is truncated so that it contains no
more than _limit_ elements.

When the SPLIT method is called, the following steps are taken:

RUNTIME SEMANTICS: SPLITMATCH ABSTRACT OPERATION

The abstract operation _SplitMatch_ takes three parameters, a String
_S_, an integer _q_, and a String _R_, and performs the following in
order to return either FALSE or the end index of a match:

The LENGTH property of the SPLIT method is 2.

NOTE The SPLIT function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

15.5.4.15 String.prototype.substring (start, end)

The SUBSTRING method takes two arguments, _start_ and _end_, and returns
a substring of the result of converting this object to a String,
starting from element position _start_ and running to, but not
including, element position _end_ of the String (or through the end of
the String is _end_ is UNDEFINED). The result is a String value, not a
String object.

If either argument is NAN or negative, it is replaced with zero; if
either argument is larger than the length of the String, it is replaced
with the length of the String.

If _start_ is larger than _end_, they are swapped.

The following steps are taken:

The LENGTH property of the SUBSTRING method is 2.

NOTE The SUBSTRING function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

15.5.4.16 String.prototype.toLowerCase ( )

This function interprets a string value as a sequence of code points, as
described in 8.4. The following steps are taken:

The result must be derived according to the case mappings in the Unicode
character database (this explicitly includes not only the
UnicodeData.txt file, but also the SpecialCasings.txt file that
accompanies it).

NOTE 1 The case mapping of some code points may produce multiple code
points . In this case the result String may not be the same length as
the source String. Because both TOUPPERCASE and TOLOWERCASE have
context-sensitive behaviour, the functions are not symmetrical. In other
words, S.TOUPPERCASE().TOLOWERCASE() is not necessarily equal to
S.TOLOWERCASE().

NOTE 2 The TOLOWERCASE function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

15.5.4.17 String.prototype.toLocaleLowerCase ( )

This function interprets a string value as a sequence of code points, as
described in 8.4.

This function works exactly the same as TOLOWERCASE except that its
result is intended to yield the correct result for the host
environment’s current locale, rather than a locale-independent result.
There will only be a difference in the few cases (such as Turkish) where
the rules for that language conflict with the regular Unicode case
mappings.

NOTE 1 The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that implementations
do not use this parameter position for anything else.

NOTE 2 The TOLOCALELOWERCASE function is intentionally generic; it does
not require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

15.5.4.18 String.prototype.toUpperCase ( )

This function interprets a string value as a sequence of code points, as
described in 8.4.

This function behaves in exactly the same way as
STRING.PROTOTYPE.TOLOWERCASE, except that code points are mapped to
their _uppercase_ equivalents as specified in the Unicode Character
Database.

NOTE The TOUPPERCASE function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

15.5.4.19 String.prototype.toLocaleUpperCase ( )

This function interprets a string value as a sequence of code points, as
described in 8.4.

This function works exactly the same as TOUPPERCASE except that its
result is intended to yield the correct result for the host
environment’s current locale, rather than a locale-independent result.
There will only be a difference in the few cases (such as Turkish) where
the rules for that language conflict with the regular Unicode case
mappings.

NOTE 1 The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that implementations
do not use this parameter position for anything else.

NOTE 2 The TOLOCALEUPPERCASE function is intentionally generic; it does
not require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

15.5.4.20 String.prototype.trim ( )

This function interprets a string value as a sequence of code points, as
described in 8.4.

The following steps are taken:

NOTE The TRIM function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

15.5.4.21 STRING.PROTOTYPE.REPEAT (COUNT)

The following steps are taken:

1.  Let _O_ be CheckObjectCoercible(THIS value).

2.  Let _S_ be ToString(_O_).

3.  ReturnIfAbrupt(_S_).

4.  Let _n_ be the result of calling ToInteger(_count_).

5.  ReturnIfAbrupt(_n_).

6.  If _n_ < 0, then throw a RANGEERROR exception.

7.  If _n_ is +∞, then throw a RANGEERROR exception.

8.  Let _T_ be a String value that is made from _n_ copies of _S
    appended together. If _n_ is 0, _T_ is the empty String.

9.  Return _T_.

NOTE 1 This method creates a String consisting of the string elements of
this object (converted to String) repeated _count_ time.

NOTE 2 The REPEAT function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

15.5.4.22 STRING.PROTOTYPE.STARTSWITH (SEARCHSTRING [, POSITION ] )

The following steps are taken:

1.  Let _O_ be CheckObjectCoercible(THIS value).

2.  Let _S_ be ToString(_O_).

3.  ReturnIfAbrupt(_S_).

4.  Let _searchStr_ be ToString(_searchString_).

5.  ReturnIfAbrupt(_searchStr_).

6.  Let _pos_ be ToInteger(_position_). (If _position_ is UNDEFINED,
    this step produces the value 0).

7.  ReturnIfAbrupt(_pos_).

8.  Let _len_ be the number of elements in _S_.

9.  Let _start_ be min(max(_pos_, 0), _len_).

10. Let _searchLength_ be the number of elements in _searchString_.

11. If _searchLength+start_ is greater than _len_, return FALSE_.

12. If the _searchLength_ sequence of elements of _S_ starting at
    _start_ is the same as the full element sequence of _searchString_,
    return TRUE.

13. Otherwise, return FALSE.

The LENGTH property of the STARTSWITH method is 1.

NOTE 1 This method returns TRUE if the sequence of elements of
_searchString_ converted to a String is the same as the corresponding
elements of this object (converted to a String) starting at _position_.
Otherwise returns FALSE.

NOTE 2 The STARTSWITH function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

15.5.4.23 STRING.PROTOTYPE.ENDSWITH (SEARCHSTRING [, ENDPOSITION] )

The following steps are taken:

1.  Let _O_ be CheckObjectCoercible(THIS value).

2.  Let _S_ be ToString(_O_).

3.  ReturnIfAbrupt(_S_).

4.  Let _searchStr_ be ToString(_searchString_).

5.  ReturnIfAbrupt(_searchStr_).

6.  Let _len_ be the number of elements in _S_.

7.  If _endPosition_ is UNDEFINED, let _pos_ be _len_, else let _pos_ be
    ToInteger(_endPosition_).

8.  ReturnIfAbrupt(_pos_).

9.  Let _end_ be min(max(_pos_, 0), _len_).

10. Let _searchLength_ be the number of elements in _searchString_.

11. Let _start_ be _end_ - _searchLength_.

12. If _start_ is less than 0, return FALSE_.

13. If the _searchLength_ sequence of elements of _S_ starting at
    _start_ is the same as the full element sequence of _searchString_,
    return TRUE.

14. Otherwise, return FALSE.

The LENGTH property of the ENDSWITH method is 1.

NOTE 1 Returns TRUE if the sequence of elements of _searchString_
converted to a String is the same as the corresponding elements of this
object (converted to a String) starting at _endPosition_ – length(this).
Otherwise returns FALSE.

NOTE 2 The ENDSWITH function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

15.5.4.24 STRING.PROTOTYPE.CONTAINS (SEARCHSTRING, POSITION = 0 )

The CONTAINS method takes two arguments, _searchString_ and _position_,
and performs the following steps:

1.  Let _O_ be CheckObjectCoercible(THIS value).

2.  Let _S_ be ToString(_O_).

3.  ReturnIfAbrupt(_S_).

4.  Let _searchStr_ be ToString(_searchString_).

5.  ReturnIfAbrupt(_searchStr_).

6.  Let _pos_ be ToInteger(_position_). (If _position_ is UNDEFINED,
    this step produces the value 0).

7.  ReturnIfAbrupt(_pos_).

8.  Let _len_ be the number of elements in _S_.

9.  Let _start_ be min(max(_pos_, 0), _len_).

10. Let _searchLen_ be the number of characters in _searchStr_.

11. If there exists any integer _k_ not smaller than _start_ such that
    _k_ + _searchLen_ is not greater than _len_, and for all nonnegative
    integers _j_ less than _searchLen_, the character at position
    _k_+_j_ of _S_ is the same as the character at position _j_ of
    _searchStr,_ return TRUE; but if there is no such integer _k_,
    return FALSE.

The LENGTH property of the CONTAINS method is 1.

NOTE 1 If _searchString_ appears as a substring of the result of
converting this object to a String, at one or more positions that are
greater than or equal to _position_, then return TRUE; otherwise,
returns FALSE. If _position_ is UNDEFINED, 0 is assumed, so as to search
all of the String.

NOTE 2 The CONTAINS function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

15.5.4.25 String.prototype.codePointAt (pos)

NOTE Returns a Number (a nonnegative integer less than 1114112) that is
the UTF-16 encoded code point value starting at the string element at
position _pos_ in the String resulting from converting this object to a
String. If there is no element at that position, the result is NAN. If a
valid UTF-16 surrogate pair does not begin at _pos_, the result is the
code unit at _pos_.

When the CODEPOINTAT method is called with one argument _pos_, the
following steps are taken:

1.  Let _O_ be CheckObjectCoercible(THIS value).

2.  Let _S_ be ToString(_O_).

3.  ReturnIfAbrupt(_S_).

4.  Let _position_ be ToInteger(_pos_).

5.  ReturnIfAbrupt(_position_).

6.  Let _size_ be the number of elements in _S_.

7.  If _position_ < 0 or _position_ ≥ _size_, return UNDEFINED.

8.  Let _first_ be the code unit value of the element at index
    _position_ in the String _S_.

9.  If _first_ < 0xD800 or _first_ > 0xDBFF or _position_+1 = _size_,
    then return _first_.

10. Let _second_ be the code unit value of the element at index
    _position_+1 in the String _S_.

11. If _second_ < 0xDC00 or _second_ > 0xDFFF, then return _first_.

12. Return ((_first_ – 0xD800) × 1024) + (_second_ – 0xDC00) + 0x10000.

NOTE The CODEPOINTAT function is intentionally generic; it does not
require that its THIS value be a String object. Therefore it can be
transferred to other kinds of objects for use as a method.

15.5.4.26 String.prototype.normalize ( form = "NFC" )

When the NORMALIZE method is called with one argument _form_, the
following steps are taken:

1.  Let _O_ be CheckObjectCoercible(THIS value).

2.  Let _S_ be ToString(_O_).

3.  ReturnIfAbrupt(_S_).

4.  If _form_ is not provided or UNDEFINED let _form_ be "NFC".

5.  Let _f_ be ToString(_form_).

6.  ReturnIfAbrupt(_f_).

7.  If _f_ is not one of "NFC", "NFD", "NFKC", or "NFKD", then throw a
    RANGEERROR Exception.

8.  Let _ns_ be the String value is the result of normalizing _S_ into
    the normalization form named by _f_ as specified in _UTR 15, Unicode
    Normalization Forms_.

9.  Return _ns_.

NOTE The NORMALIZE function is intentionally generic; it does not
require that its THIS value be a String object. Therefore it can be
transferred to other kinds of objects for use as a method.

15.5.5 Properties of String Instances

String instances are String exotic objects and have the internal methods
specified for such objects. String instances inherit properties from the
String prototype object. String instances also have a [[StringData]]
internal data property.

String instances have a LENGTH property, and a set of enumerable
properties with array index names.

15.5.5.1 length

The number of elements in the String value represented by this String
object.

Once a String object is initialized, this property is unchanging. It has
the attributes { [[Writable]]: FALSE, [[Enumerable]]: FALSE,
[[Configurable]]: FALSE }.


15.6 Boolean Objects

15.6.1 The Boolean Constructor Called as a Function

When BOOLEAN is called as a function rather than as a constructor, it
performs a type conversion. However, if the THIS value passed in the
call is an Object with an uninitialized [[BooleanData]] internal data
property, it initializes the THIS value using the argument value. This
permits BOOLEAN to be used both to perform type conversion and to
perform constructor instance initialization.

BOOLEAN may be subclassed and subclass constructors may perform a super
invocation of the BOOLEAN constructor to initialize the [[BooleanData]]
state of subclass instances.

15.6.1.1 Boolean (value)

When BOOLEAN is called with argument _value_, the following steps are
taken:

1.  Let _O_ be the THIS value.

2.  Let _b_ be ToBoolean(_value_).

3.  If Type(_O_) is Object and _O_ has a [[BooleanData]] internal data
    property and the value of [[BooleanData]] is UNDEFINED, then

    a.  Set the value of _O’s_ [[BooleanData]] internal data property to
        _b_.

    b.  Return _O_.

4.  Return _b_.

15.6.2 The Boolean Constructor

When BOOLEAN is called as part of a NEW expression it is a constructor:
it initialises the newly created ordinary object.

15.6.2.1 new Boolean (value)

BOOLEAN called as part of a new expression with optional argument
_value_ performs the following steps:

1.  Let _F_ be the BOOLEAN function object on which the NEW operator was
    applied.

2.  Let _argumentsList_ be the _argumentsList_ argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of OrdinaryConstruct (_F_, _argumentsList_).

If BOOLEAN is implemented as an ordinary function object, its
[[Construct]] internal method will perform the above steps.

15.6.3 Properties of the Boolean Constructor

The value of the [[Prototype]] internal data property of the Boolean
constructor is the Function prototype object (15.3.3).

Besides the LENGTH property (whose value is 1), the Boolean constructor
has the following property:

15.6.3.1 Boolean.prototype

The initial value of BOOLEAN.PROTOTYPE is the Boolean prototype object
(15.6.4).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

15.6.3.2 Boolean[ @@create ] ( )

The @@create method of an object _F_ performs the following steps:

1.  Let _F_ be the THIS value.

2.  Let _obj_ be the result of calling
    OrdinaryCreateFromConstructor(_F_, "%BOOLEANPROTOTYPE%", (
    [[BooleanData]]) ).

3.  Return _obj_.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

NOTE [[BooleanData]] is initially assigned the value UNDEFINED as a flag
to indicate that the instance has not yet been initialized by the
Boolean constructor. This flag value is never directly exposed to
ECMAScript code; hence implementation may choose to encode the flag in
some other manner.

15.6.4 Properties of the Boolean Prototype Object

The Boolean prototype object is an ordinary object. It is not a Boolean
instance and does not have a [[BooleanData]] internal data property.

The value of the [[Prototype]] internal data property of the Boolean
prototype object is the standard built-in Object prototype object
(15.2.4).

The abstract operation thisBooleanValue(_value_) performs the following
steps:

1.  If Type(_value_) is Boolean, return _value_.

2.  If Type(_value)_ is Object and _value_ has a [[BooleanData]]
    internal data property, then

    a.  Let _b_ be the value of _value’s_ [[BooleanData]] internal data
        property.

    b.  If _b_ is not UNDEFINED, then return _n_.

3.  Throw a TYPEERROR exception.

15.6.4.1 Boolean.prototype.constructor

The initial value of BOOLEAN.PROTOTYPE.CONSTRUCTOR is the built-in
BOOLEAN constructor.

15.6.4.2 Boolean.prototype.toString ( )

The following steps are taken:

15.6.4.3 Boolean.prototype.valueOf ( )

The following steps are taken:

15.6.5 Properties of Boolean Instances

Boolean instances are ordinary objects that inherit properties from the
Boolean prototype object. Boolean instances have a [[BooleanData]]
internal data property.

The [[BooleanData]] internal data property is the Boolean value
represented by this Boolean object.


15.7 Number Objects

15.7.1 The Number Constructor Called as a Function

When NUMBER is called as a function rather than as a constructor, it
performs a type conversion. However, if the THIS value value passed in
the call is an Object with an uninitialized [[NumberData]] internal data
property, it initializes the THIS value using the argument value. This
permits NUMBER to be used both to perform type conversion and to perform
constructor instance initialization.

NUMBER may be subclassed and subclass constructors may perform a super
invocation of the NUMBER constructor to initialize the [[NumberData]]
state of subclass instances.

15.7.1.1 Number ( [ value ] )

When NUMBER is called with argument _number_, the following steps are
taken:

1.  Let _O_ be the THIS value.

2.  If no arguments were passed to this function invocation, then let
    _n_ be +0.

3.  Else, let _n_ be ToNumber(_value_).

4.  ReturnIfAbrupt(_n_).

5.  If Type(_O_) is Object and _O_ has a [[NumberData]] internal data
    property and the value of [[NumberData]] is UNDEFINED, then

    a.  Set the value of _O’s_ [[NumberData]] internal data property to
        _n_.

    b.  Return _O_.

6.  Return _n_.

15.7.2 The Number Constructor

When NUMBER is called as part of a NEW expression it is a constructor:
it initialises the newly created ordinary object.

15.7.2.1 new Number ( ...args )

NUMBER called as part of a new expression with argument list _args_ it
performs the following steps:

1.  Let _F_ be the NUMBER function object on which the NEW operator was
    applied.

2.  Let _argumentsList_ be the _argumentsList_ argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of OrdinaryConstruct (_F_, _argumentsList_).

If NUMBER is implemented as an ordinary function object, its
[[Construct]] internal method will perform the above steps.

15.7.3 Properties of the Number Constructor

The value of the [[Prototype]] internal data property of the Number
constructor is the Function prototype object (15.3.3).

Besides the LENGTH property (whose value is 1), the Number constructor
has the following properties:

15.7.3.1 Number.prototype

The initial value of NUMBER.PROTOTYPE is the Number prototype object
(15.7.4).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

15.7.3.2 Number.MAX_VALUE

The value of NUMBER.MAX_VALUE is the largest positive finite value of
the Number type, which is approximately 1.7976931348623157 × 10^308^.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

15.7.3.3 Number.MIN_VALUE

The value of NUMBER.MIN_VALUE is the smallest positive value of the
Number type, which is approximately 5 × 10^324^.

In the IEEE-764 double precision binary representation, the smallest
possible value is a denormalized number. If an implementation does not
support denormalized values, the value of NUMBER.MIN_VALUE must be the
smallest non-zero positive value that can actually be represented by the
implementation.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

15.7.3.4 Number.NaN

The value of NUMBER.NAN is NAN.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

15.7.3.5 Number.NEGATIVE_INFINITY

The value of Number.NEGATIVE_INFINITY is −∞.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

15.7.3.6 Number.POSITIVE_INFINITY

The value of Number.POSITIVE_INFINITY is +∞.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

15.7.3.7 NUMBER.EPSILON

The value of Number.EPSILON is the difference between 1 and the smallest
value greater than 1 that is representable as a Number value, which is
approximately 2.2204460492503130808472633361816 x 10^-16^.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

15.7.3.8 NUMBER.MAX_INTEGER

The value of Number.MAX_INTEGER is the largest integer value that can be
represented as a Number value without losing precision, which is
9007199254740991.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

15.7.3.9 NUMBER.PARSEINT (STRING, RADIX)

Same as 15.1.2.2.

15.7.3.10 NUMBER.PARSEFLOAT (STRING)

Same as 15.1.2.3.

15.7.3.11 NUMBER.ISNAN (NUMBER)

When the NUMBER.ISNAN is called with one argument _number_, the
following steps are taken:

1.  If Type(_number_) is not Number, return FALSE.

2.  If _number_ is NAN, return TRUE.

3.  Otherwise, return FALSE.

NOTE This function differs from the global isNaN function (15.1.2.4) is
that it does not convert its argument to a Number before determining
whether it is NaN.

15.7.3.12 NUMBER.ISFINITE (NUMBER)

When the NUMBER.ISFINITE is called with one argument _number_, the
following steps are taken:

15.7.3.13 NUMBER.ISINTEGER (NUMBER)

When the NUMBER.ISINTEGER is called with one argument _number_, the
following steps are taken:

1.  If Type(_number_) is not Number, return FALSE.

2.  Let _integer_ be ToInteger(_number_).

3.  If _integer_ is not equal to _number_, return FALSE.

4.  Otherwise, return TRUE.

15.7.3.14 NUMBER.TOINTEGER (NUMBER)

When the NUMBER.TOINTEGER is called with one argument _number_, the
following steps are taken:

1.  Return ToInteger(_number_).

2.  

15.7.3.15 Number[ @@create ] ( )

The @@create method of an object _F_ performs the following steps:

1.  Let _F_ be the THIS value.

2.  Let _obj_ be the result of calling
    OrdinaryCreateFromConstructor(_F_, "%NUMBERPROTOTYPE%", (
    [[NumberData]])).

3.  Return _obj_.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

NOTE [[NumberData]] is initially assigned the value UNDEFINED as a flag
to indicate that the instance has not yet been initialized by the Number
constructor. This flag value is never directly exposed to ECMAScript
code; hence implementation may choose to encode the flag in some other
manner.

15.7.4 Properties of the Number Prototype Object

The Number prototype object is an ordinary object. It is not a Number
instance and does not have a [[NumberData]] internal data property.

The value of the [[Prototype]] internal data property of the Number
prototype object is the standard built-in Object prototype object
(15.2.4).

Unless explicitly stated otherwise, the methods of the Number prototype
object defined below are not generic and the this value passed to them
must be either a Number value or an object that has a [[NumberData]]
internal data property that has been initialized to a Number value.

The abstract operation thisNumberValue(_value_) performs the following
steps:

1.  If Type(_value_) is Number, return _value_.

2.  If Type(_value)_ is Object and _value_ has a [[NumberData]] internal
    data property, then

    a.  Let _n_ be the value of _value’s_ [[NumberData]] internal data
        property.

    b.  If _n_ is not UNDEFINED, then return _n_.

3.  Throw a TYPEERROR exception.

The phrase “this Number value” within the specification of a method
refers to the result returned by calling the abstract operation
thisNumberValue with the THIS value of the method invocation passed as
the argument.

15.7.4.1 Number.prototype.constructor

The initial value of NUMBER.PROTOTYPE.CONSTRUCTOR is the built-in NUMBER
constructor.

15.7.4.2 Number.prototype.toString ( [ radix ] )

The optional _radix_ should be an integer value in the inclusive range 2
to 36. If _radix_ not present or is UNDEFINED the Number 10 is used as
the value of _radix_. If ToInteger(_radix_) is the Number 10 then this
Number value is given as an argument to the ToString abstract operation;
the resulting String value is returned.

If ToInteger(_radix_) is not an integer between 2 and 36 inclusive throw
a RANGEERROR exception. If ToInteger(_radix_) is an integer from 2 to
36, but not 10, the result is a String representation of this Number
value using the specified radix. Letters A-Z are used for digits with
values 10 through 35. The precise algorithm is implementation-dependent
if the radix is not 10, however the algorithm should be a generalisation
of that specified in 9.1.8.1.

The TOSTRING function is not generic; it throws a TYPEERROR exception if
its THIS value is not a Number or a Number object. Therefore, it cannot
be transferred to other kinds of objects for use as a method.

15.7.4.3 Number.prototype.toLocaleString()

Produces a String value that represents this Number value formatted
according to the conventions of the host environment’s current locale.
This function is implementation-dependent, and it is permissible, but
not encouraged, for it to return the same thing as TOSTRING.

NOTE The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that implementations
do not use this parameter position for anything else.

15.7.4.4 Number.prototype.valueOf ( )

1.  Let _x_ be thisNumberValue(THIS value).

2.  Return _x_.

15.7.4.5 Number.prototype.toFixed (fractionDigits)

Note TOFIXED returns a String containing this Number value represented
in decimal fixed-point notation with _fractionDigits_ digits after the
decimal point. If _fractionDigits_ is UNDEFINED, 0 is assumed.

The following steps are performed:

1.  Let _x_ be thisNumberValue(THIS value).

2.  ReturnIfAbrupt(_x_).

3.  Let _f_ be ToInteger(_fractionDigits_). (If _fractionDigits_ is
    UNDEFINED, this step produces the value 0).

4.  ReturnIfAbrupt(_f_).

5.  If _f_ < 0 or _f_ > 20, throw a RANGEERROR exception.

6.  7.  8.  If _x_ is NAN, return the String "NAN".

9.  Let _s_ be the empty String.

10. If _x_ < 0, then

    a.  Let s be "-".

    b.  Let x = –x.

11. If _x_ ≥ 10^21^, then

    a.  Let _m_ = ToString(_x_).

12. Else _x_ < 10^21^,

    a.  Let _n_ be an integer for which the exact mathematical value of
        _n_ ÷ 10^f^ – _x_ is as close to zero as possible. If there are
        two such _n_, pick the larger _n_.

    b.  If _n_ = 0, let _m_ be the String "0". Otherwise, let _m_ be the
        String consisting of the digits of the decimal representation of
        _n_ (in order, with no leading zeroes).

    c.  If _f_ ≠ 0, then

        i.  Let _k_ be the number of elements in _m_.

        ii. If _k_ ≤ _f_, then

            1.  Let _z_ be the String consisting of _f_+1–_k_
                occurrences of the code unit 0x0030.

            2.  Let _m_ be the concatenation of Strings _z_ and _m_.

            3.  Let _k_ = _f_ + 1.

        iii. Let _a_ be the first _k_–_f_ elements of _m_, and let _b_
            be the remaining _f_ elements of _m_.

        iv. Let _m_ be the concatenation of the three Strings _a_, ".",
            and _b_.

13. Return the concatenation of the Strings _s_ and _m_.

The LENGTH property of the TOFIXED method is 1.

If the TOFIXED method is called with more than one argument, then the
behaviour is undefined (see clause 15).

An implementation is permitted to extend the behaviour of TOFIXED for
values of _fractionDigits_ less than 0 or greater than 20. In this case
TOFIXED would not necessarily throw RANGEERROR for such values.

NOTE The output of TOFIXED may be more precise than TOSTRING for some
values because toString only prints enough significant digits to
distinguish the number from adjacent number values. For example,

(1000000000000000128).TOSTRING() returns "1000000000000000100",
while (1000000000000000128).TOFIXED(0) returns "1000000000000000128".

15.7.4.6 Number.prototype.toExponential (fractionDigits)

Return a String containing this Number value represented in decimal
exponential notation with one digit before the significand's decimal
point and _fractionDigits_ digits after the significand's decimal point.
If _fractionDigits_ is UNDEFINED, include as many significand digits as
necessary to uniquely specify the Number (just like in ToString except
that in this case the Number is always output in exponential notation).
Specifically, perform the following steps:

The LENGTH property of the TOEXPONENTIAL method is 1.

If the TOEXPONENTIAL method is called with more than one argument, then
the behaviour is undefined (see clause 15).

An implementation is permitted to extend the behaviour of TOEXPONENTIAL
for values of _fractionDigits_ less than 0 or greater than 20. In this
case TOEXPONENTIAL would not necessarily throw RANGEERROR for such
values.

NOTE For implementations that provide more accurate conversions than
required by the rules above, it is recommended that the following
alternative version of step 9.b.i be used as a guideline:

i.  Let _e_, _n_, and _f_ be integers such that _f_ ≥ 0, 10_^f^_ ≤ n <
    10^_f_+1^, the number value for n × 10^_e_–_f_^ is x, and _f_ is as
    small as possible. If there are multiple possibilities for _n_,
    choose the value of _n_ for which _n_ × 10^_e_–_f_^ is closest in
    value to _x_. If there are two such possible values of _n_, choose
    the one that is even.

15.7.4.7 Number.prototype.toPrecision (precision)

Return a String containing this Number value represented either in
decimal exponential notation with one digit before the significand's
decimal point and _precision_–1 digits after the significand's decimal
point or in decimal fixed notation with _precision_ significant digits.
If _precision_ is UNDEFINED, call ToString (9.8.1) instead.
Specifically, perform the following steps:

The LENGTH property of the TOPRECISION method is 1.

If the TOPRECISION method is called with more than one argument, then
the behaviour is undefined (see clause 15).

An implementation is permitted to extend the behaviour of TOPRECISION
for values of _precision_ less than 1 or greater than 21. In this case
TOPRECISION would not necessarily throw RANGEERROR for such values.

15.7.4.8 NUMBER.PROTOTYPE.CLZ ()

When the NUMBER.PROTOTYPE.CLZ is called with one argument _number_, the
following steps are taken:

1.  Let _x_ be thisNumberValue(THIS value).

2.  Let _n_ be ToUint32(_x_).

3.  ReturnIfAbrupt(_n_).

4.  Let _p_ be the number of leading zero bits in the 32-bit binary
    representation of _n_.

5.  Return _p_.

NOTE If _n_ is 0, _p_ will be 32. If the most significant bit of the
32-bit binary encoding of _n_ is 1, _p_ will be 0.

15.7.5 Properties of Number Instances

Number instances are ordinary objects that inherit properties from the
Number prototype object. Number instances also have a [[NumberData]]
internal data property.

The [[NumberData]] internal data property is the Number value
represented by this Number object.


15.8 The Math Object

The Math object is a single ordinary object.

The value of the [[Prototype]] internal data property of the Math object
is the standard built-in Object prototype object (15.2.4). The Math
object has a [[MathTag]] internal data property whose value is TRUE.

The Math is not a function object. It does not have a [[Construct]]
internal method; it is not possible to use the Math object as a
constructor with the NEW operator.

The Math object also does not have a [[Call]] internal method; it is not
possible to invoke the Math object as a function.

NOTE In this specification, the phrase “the Number value for _x_” has a
technical meaning defined in 8.5.

15.8.1 Value Properties of the Math Object

15.8.1.1 Math.E

The Number value for _e_, the base of the natural logarithms, which is
approximately 2.7182818284590452354.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

15.8.1.2 Math.LN

The Number value for the natural logarithm of 10, which is approximately
2.302585092994046.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

15.8.1.3 Math.LN

The Number value for the natural logarithm of 2, which is approximately
0.6931471805599453.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

15.8.1.4 Math.LOG2E

The Number value for the base-2 logarithm of _e_, the base of the
natural logarithms; this value is approximately 1.4426950408889634.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

NOTE The value of MATH.LOG2E is approximately the reciprocal of the
value of MATH.LN2.

15.8.1.5 Math.LOG10E

The Number value for the base-10 logarithm of _e_, the base of the
natural logarithms; this value is approximately 0.4342944819032518.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

NOTE The value of MATH.LOG10E is approximately the reciprocal of the
value of MATH.LN10.

15.8.1.6 Math.PI

The Number value for π, the ratio of the circumference of a circle to
its diameter, which is approximately 3.1415926535897932.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

15.8.1.7 Math.SQRT

The Number value for the square root of ½, which is approximately
0.7071067811865476.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

NOTE The value of MATH.SQRT1_2 is approximately the reciprocal of the
value of MATH.SQRT2.

15.8.1.8 Math.SQRT

The Number value for the square root of 2, which is approximately
1.4142135623730951.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

15.8.2 Function Properties of the Math Object

Each of the following MATH object functions applies the ToNumber
abstract operation to each of its arguments (in left-to-right order if
there is more than one). If ToNumber returns an abrupt completion, that
completion record is immediately returned. Otherwise, functction
performs a computation on the resulting Number value(s).

In the function descriptions below, the symbols NaN, −0, +0, −∞ and +∞
refer to the Number values described in 8.5.

NOTE The behaviour of the functions ACOS, ASIN, ATAN, ATAN2, COS, EXP,
LOG, POW, SIN, SQRT, and TAN is not precisely specified here except to
require specific results for certain argument values that represent
boundary cases of interest. For other argument values, these functions
are intended to compute approximations to the results of familiar
mathematical functions, but some latitude is allowed in the choice of
approximation algorithms. The general intent is that an implementer
should be able to use the same mathematical library for ECMAScript on a
given hardware platform that is available to C programmers on that
platform.

Although the choice of algorithms is left to the implementation, it is
recommended (but not specified by this standard) that implementations
use the approximation algorithms for IEEE 754 arithmetic contained in
FDLIBM, the freely distributable mathematical library from Sun
Microsystems (http://www.netlib.org/fdlibm).

15.8.2.1 Math.abs (x)

Returns the absolute value of _x_; the result has the same magnitude as
_x_ but has positive sign.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is −0, the result is +0.

-   If _x_ is −∞, the result is +∞.

15.8.2.2 Math.acos (x)

Returns an implementation-dependent approximation to the arc cosine of
_x_. The result is expressed in radians and ranges from +0 to +π.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is greater than 1, the result is NaN.

-   If _x_ is less than −1, the result is NaN.

-   If _x_ is exactly 1, the result is +0.

15.8.2.3 Math.asin (x)

Returns an implementation-dependent approximation to the arc sine of
_x_. The result is expressed in radians and ranges from −π/2 to +π/2.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is greater than 1, the result is NaN.

-   If _x_ is less than –1, the result is NaN.

-   If _x_ is +0, the result is +0.

-   If _x_ is −0, the result is −0.

15.8.2.4 Math.atan (x)

Returns an implementation-dependent approximation to the arc tangent of
_x_. The result is expressed in radians and ranges from −π/2 to +π/2.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is +0, the result is +0.

-   If _x_ is −0, the result is −0.

-   If _x_ is +∞, the result is an implementation-dependent
      approximation to +π/2.

-   If _x_ is −∞, the result is an implementation-dependent
      approximation to −π/2.

15.8.2.5 Math.atan2 (y, x)

Returns an implementation-dependent approximation to the arc tangent of
the quotient _y_/_x_ of the arguments _y_ and _x_, where the signs of
_y_ and _x_ are used to determine the quadrant of the result. Note that
it is intentional and traditional for the two-argument arc tangent
function that the argument named _y_ be first and the argument named _x_
be second. The result is expressed in radians and ranges from −π to +π.

-   If either _x_ or _y_ is NaN, the result is NaN.

-   If _y_>0 and _x_ is +0, the result is an implementation-dependent
      approximation to +π/2.

-   If _y_>0 and _x_ is −0, the result is an implementation-dependent
      approximation to +π/2.

-   If _y_ is +0 and _x_>0, the result is +0.

-   If _y_ is +0 and _x_ is +0, the result is +0.

-   If _y_ is +0 and _x_ is −0, the result is an
      implementation-dependent approximation to +π.

-   If _y_ is +0 and _x_<0, the result is an implementation-dependent
      approximation to +π.

-   If _y_ is −0 and _x_>0, the result is −0.

-   If _y_ is −0 and _x_ is +0, the result is −0.

-   If _y_ is −0 and _x_ is −0, the result is an
      implementation-dependent approximation to −π.

-   If _y_ is −0 and _x_<0, the result is an implementation-dependent
      approximation to −π.

-   If _y_<0 and _x_ is +0, the result is an implementation-dependent
      approximation to −π/2.

-   If _y_<0 and _x_ is −0, the result is an implementation-dependent
      approximation to −π/2.

-   If _y_>0 and _y_ is finite and _x_ is +∞, the result is +0.

-   If _y_>0 and _y_ is finite and _x_ is −∞, the result if an
      implementation-dependent approximation to +π.

-   If _y_<0 and _y_ is finite and _x_ is +∞, the result is −0.

-   If _y_<0 and _y_ is finite and _x_ is −∞, the result is an
      implementation-dependent approximation to −π.

-   If _y_ is +∞ and _x_ is finite, the result is an
      implementation-dependent approximation to +π/2.

-   If _y_ is −∞ and _x_ is finite, the result is an
      implementation-dependent approximation to −π/2.

-   If _y_ is +∞ and _x_ is +∞, the result is an
      implementation-dependent approximation to +π/4.

-   If _y_ is +∞ and _x_ is −∞, the result is an
      implementation-dependent approximation to +3π/4.

-   If _y_ is −∞ and _x_ is +∞, the result is an
      implementation-dependent approximation to −π/4.

-   If _y_ is −∞ and _x_ is −∞, the result is an
      implementation-dependent approximation to −3π/4.

15.8.2.6 Math.ceil (x)

Returns the smallest (closest to −∞) Number value that is not less than
_x_ and is equal to a mathematical integer. If _x_ is already an
integer, the result is _x_.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is +0, the result is +0.

-   If _x_ is −0, the result is −0.

-   If _x_ is +∞, the result is +∞.

-   If _x_ is −∞, the result is −∞.

-   If _x_ is less than 0 but greater than -1, the result is −0.

The value of MATH.CEIL(X) is the same as the value of -MATH.FLOOR(-X).

15.8.2.7 Math.cos (x)

Returns an implementation-dependent approximation to the cosine of _x_.
The argument is expressed in radians.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is +0, the result is 1.

-   If _x_ is −0, the result is 1.

-   If _x_ is +∞, the result is NaN.

-   If _x_ is −∞, the result is NaN.

15.8.2.8 Math.exp (x)

Returns an implementation-dependent approximation to the exponential
function of _x_ (_e_ raised to the power of _x_, where _e_ is the base
of the natural logarithms).

-   If _x_ is NaN, the result is NaN.

-   If _x_ is +0, the result is 1.

-   If _x_ is −0, the result is 1.

-   If _x_ is +∞, the result is +∞.

-   If _x_ is −∞, the result is +0.

15.8.2.9 Math.floor (x)

Returns the greatest (closest to +∞) Number value that is not greater
than _x_ and is equal to a mathematical integer. If _x_ is already an
integer, the result is _x_.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is +0, the result is +0.

-   If _x_ is −0, the result is −0.

-   If _x_ is +∞, the result is +∞.

-   If _x_ is −∞, the result is −∞.

-   If _x_ is greater than 0 but less than 1, the result is +0.

NOTE The value of MATH.FLOOR(X) is the same as the value of
-MATH.CEIL(-X).

15.8.2.10 Math.log (x)

-   Returns an implementation-dependent approximation to the natural
      logarithm of _x_.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is less than 0, the result is NaN.

-   If _x_ is +0 or −0, the result is −∞.

-   If _x_ is 1, the result is +0.

-   If _x_ is +∞, the result is +∞.

15.8.2.11 Math.max ( [ value1 [ , value2 [ , … ] ] ] )

Given zero or more arguments, calls ToNumber on each of the arguments
and returns the largest of the resulting values.

-   If no arguments are given, the result is −∞.

-   If any value is NaN, the result is NaN.

-   The comparison of values to determine the largest value is done
      using the Abstract Relational Comparison Algorithm ( 11.8.1)
      except that +0 is considered to be larger than −0.

The LENGTH property of the MAX method is 2.

15.8.2.12 Math.min ( [ value1 [ , value2 [ , … ] ] ] )

Given zero or more arguments, calls ToNumber on each of the arguments
and returns the smallest of the resulting values.

-   If no arguments are given, the result is +∞.

-   If any value is NaN, the result is NaN.

-   The comparison of values to determine the smallest value is done
      using the Abstract Relational Comparison Algorithm (11.8.1) except
      that +0 is considered to be larger than −0.

The LENGTH property of the MIN method is 2.

15.8.2.13 Math.pow (x, y)

Returns an implementation-dependent approximation to the result of
raising _x_ to the power _y_.

-   If _y_ is NaN, the result is NaN.

-   If _y_ is +0, the result is 1, even if _x_ is NaN.

-   If _y_ is −0, the result is 1, even if _x_ is NaN.

-   If _x_ is NaN and _y_ is nonzero, the result is NaN.

-   If abs(_x_)>1 and _y_ is +∞, the result is +∞.

-   If abs(_x_)>1 and _y_ is −∞, the result is +0.

-   If abs(_x_) is 1 and _y_ is +∞, the result is NaN.

-   If abs(_x_) is 1 and _y_ is −∞, the result is NaN.

-   If abs(_x_)<1 and _y_ is +∞, the result is +0.

-   If abs(_x_)<1 and _y_ is −∞, the result is +∞.

-   If _x_ is +∞ and _y_>0, the result is +∞.

-   If _x_ is +∞ and _y_<0, the result is +0.

-   If _x_ is −∞ and _y_>0 and _y_ is an odd integer, the result is −∞.

-   If _x_ is −∞ and _y_>0 and _y_ is not an odd integer, the result
      is +∞.

-   If _x_ is −∞ and _y_<0 and _y_ is an odd integer, the result is −0.

-   If _x_ is −∞ and _y_<0 and _y_ is not an odd integer, the result
      is +0.

-   If _x_ is +0 and _y_>0, the result is +0.

-   If _x_ is +0 and _y_<0, the result is +∞.

-   If _x_ is −0 and _y_>0 and _y_ is an odd integer, the result is −0.

-   If _x_ is −0 and _y_>0 and _y_ is not an odd integer, the result
      is +0.

-   If _x_ is −0 and _y_<0 and _y_ is an odd integer, the result is −∞.

-   If _x_ is −0 and _y_<0 and _y_ is not an odd integer, the result
      is +∞.

-   If _x_<0 and _x_ is finite and _y_ is finite and _y_ is not an
      integer, the result is NaN.

15.8.2.14 Math.random ( )

Returns a Number value with positive sign, greater than or equal to 0
but less than 1, chosen randomly or pseudo randomly with approximately
uniform distribution over that range, using an implementation-dependent
algorithm or strategy. This function takes no arguments.

15.8.2.15 Math.round (x)

Returns the Number value that is closest to _x_ and is equal to a
mathematical integer. If two integer Number values are equally close to
_x_, then the result is the Number value that is closer to +∞. If _x_ is
already an integer, the result is _x_.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is +0, the result is +0.

-   If _x_ is −0, the result is −0.

-   If _x_ is +∞, the result is +∞.

-   If _x_ is −∞, the result is −∞.

-   If _x_ is greater than 0 but less than 0.5, the result is +0.

-   If _x_ is less than 0 but greater than or equal to -0.5, the result
      is −0.

NOTE 1 MATH.ROUND(3.5) returns 4, but MATH.ROUND(–3.5) returns –3.

NOTE 2 The value of MATH.ROUND(X) is the same as the value of
MATH.FLOOR(X+0.5), except when X is −0 or is less than 0 but greater
than or equal to -0.5; for these cases MATH.ROUND(X) returns −0, but
MATH.FLOOR(X+0.5) returns +0.

15.8.2.16 Math.sin (x)

Returns an implementation-dependent approximation to the sine of _x_.
The argument is expressed in radians.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is +0, the result is +0.

-   If _x_ is −0, the result is −0.

-   If _x_ is +∞ or −∞, the result is NaN.

15.8.2.17 Math.sqrt (x)

Returns an implementation-dependent approximation to the square root of
_x_.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is less than 0, the result is NaN.

-   If _x_ is +0, the result is +0.

-   If _x_ is −0, the result is −0.

-   If _x_ is +∞, the result is +∞.

15.8.2.18 Math.tan (x)

Returns an implementation-dependent approximation to the tangent of _x_.
The argument is expressed in radians.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is +0, the result is +0.

-   If _x_ is −0, the result is −0.

-   If _x_ is +∞ or −∞, the result is NaN.

15.8.2.19 Math.log10 (x)

Returns an implementation-dependent approximation to the base 10
logarithm of _x_.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is less than 0, the result is NaN.

-   If _x_ is +0, the result is −∞.

-   If _x_ is −0, the result is −∞.

-   If _x_ is 1, the result is +0.

-   If _x_ is +∞, the result is +∞.

15.8.2.20 Math.log2 (x)

Returns an implementation-dependent approximation to the base 2
logarithm of _x_.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is less than 0, the result is NaN.

-   If _x_ is +0, the result is −∞.

-   If _x_ is −0, the result is −∞.

-   If _x_ is 1, the result is +0.

-   If _x_ is +∞, the result is +∞.

15.8.2.21 Math.log1p (x)

Returns an implementation-dependent approximation to the natural
logarithm of 1 + _x_. The result is computed in a way that is accurate
even when the value of x is close to zero.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is less than -1, the result is NaN.

-   If x is -1, the result is -∞.

-   If _x_ is +0, the result is +0.

-   If _x_ is −0, the result is −0.

-   If _x_ is +∞, the result is +∞.

15.8.2.22 Math.expm1 (x)

Returns an implementation-dependent approximation to subtracting 1 from
the exponential function of _x_ (_e_ raised to the power of _x_, where
_e_ is the base of the natural logarithms). The result is computed in a
way that is accurate even when the value of x is close 0.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is +0, the result is +0.

-   If _x_ is −0, the result is −0.

-   If _x_ is +∞, the result is +∞.

-   If _x_ is −∞, the result is -1.

15.8.2.23 Math.cosh(x)

Returns an implementation-dependent approximation to the hyperbolic
cosine of _x_.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is +0, the result is 1.

-   If _x_ is −0, the result is 1.

-   If _x_ is +∞, the result is +∞.

-   If _x_ is −∞, the result is +∞.

NOTE The value of cosh(x) is the same as _(exp(x) + exp(-x))/2_.

15.8.2.24 Math.sinh(x)

Returns an implementation-dependent approximation to the hyperbolic sine
of _x_.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is +0, the result is +0.

-   If _x_ is −0, the result is −0.

-   If _x_ is +∞, the result is +∞.

-   If x is −∞, the result is −∞.

NOTE The value of cosh(x) is the same as _(exp(x) - exp(-x))/2_.

15.8.2.25 Math.tanh(x)

Returns an implementation-dependent approximation to the hyperbolic
tangent of _x_.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is +0, the result is +0.

-   If _x_ is −0, the result is −0.

-   If _x_ is +∞, the result is +1.

-   If _x_ is −∞, the result is -1.

NOTE The value of tanh(x) is the same as _(exp(x) - exp(-x))/(exp(x) +
exp(-x))_.

15.8.2.26 Math.acosh(x)

Returns an implementation-dependent approximation to the inverse
hyperbolic cosine of _x_.

-   If _x_ is NaN, the result is NaN.

-   If x is less than 1, the result is NaN.

-   If x is 1, the result is +0.

-   If _x_ is +∞, the result is +∞.

15.8.2.27 Math.asinh(x)

Returns an implementation-dependent approximation to the inverse
hyperbolic sine of _x_.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is +0, the result is +0.

-   If _x_ is −0, the result is −0.

-   If _x_ is +∞, the result is +∞.

-   If x is −∞, the result is −∞.

15.8.2.28 Math.atanh(x)

Returns an implementation-dependent approximation to the inverse
hyperbolic tangent of _x_.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is less than −1, the result is NaN.

-   If _x_ is greater than 1, the result is NaN.

-   If _x_ is −1, the result is −∞.

-   If _x_ is +1, the result is +∞.

-   If _x_ is +0, the result is +0.

-   If _x_ is −0, the result is −0.

15.8.2.29 Math.hypot( value1 , value2, value3 = 0 )

Given two or three arguments, hypot returns an implementation-dependent
approximation of the square root of the sum of squares of up to three
arguments.

-   If any argument is +∞, the result is +∞.

-   If any argument is −∞, the result is +∞.

-   If no argument is +∞ or −∞, and any argument is NaN, the result is
      NaN.

-   If all arguments are either +0 or -0, the result is +0.

The length property of the HYPOT function is 2.

-   -   -   -   -   

15.8.2.30 Math.trunc(x)

Returns the integral part of the number _x_, removing any fractional
digits. If _x_ is already an integer, the result is _x_.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is −0, the result is −0.

-   If _x_ is +0, the result is +0.

-   If _x_ is +∞, the result is +∞.

-   If x is −∞, the result is −∞.

15.8.2.31 Math.sign(x)

Returns the sign of the x, indicating whether x is positive, negative or
zero.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is −0, the result is −0.

-   If _x_ is +0, the result is +0.

-   If _x_ is negative and not −0, the result is −1.

-   If _x_ is positive and not +0, the result is +1.

15.8.2.32 Math.cbrt(x)

Returns an implementation-dependent approximation to the cube root of
_x_.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is +0, the result is +0.

-   If _x_ is −0, the result is −0.

-   If _x_ is +∞, the result is +∞.

-   If _x_ is −∞, the result is −∞.

15.8.2.33 Math.imul(x, y)

15.7.4.8 MATH. IMUL ()

When the MATH.IMUL is called with arguments _x_ and _y_ the following
steps are taken:

1.  Let _a_ be ToUint32(_x_).

2.  ReturnIfAbrupt(_a_).

3.  Let _a_ be ToUint32(_y_).

4.  ReturnIfAbrupt(_b_).

5.  Let _product_ be (_a_ × _b_) _x_ modulo modulo 2^32^.

6.  If _product_ ≥ 2^31^, return _product_ − 2^32^, otherwise return
    _product_.


15.9 Date Objects

15.9.1 Overview of Date Objects and Definitions of Abstract Operations

The following functions are abstract operations that operate on time
values (defined in 15.9.1.1). Note that, in every case, if any argument
to one of these functions is NAN, the result will be NAN.

15.9.1.1 Time Values and Time Range

A Date object contains a Number indicating a particular instant in time
to within a millisecond. Such a Number is called a _time value_. A time
value may also be NAN, indicating that the Date object does not
represent a specific instant of time.

Time is measured in ECMAScript in milliseconds since 01 January, 1970
UTC. In time values leap seconds are ignored. It is assumed that there
are exactly 86,400,000 milliseconds per day. ECMAScript Number values
can represent all integers from –9,007,199,254,740,992 to
9,007,199,254,740,992; this range suffices to measure times to
millisecond precision for any instant that is within approximately
285,616 years, either forward or backward, from 01 January, 1970 UTC.

The actual range of times supported by ECMAScript Date objects is
slightly smaller: exactly –100,000,000 days to 100,000,000 days measured
relative to midnight at the beginning of 01 January, 1970 UTC. This
gives a range of 8,640,000,000,000,000 milliseconds to either side of 01
January, 1970 UTC.

The exact moment of midnight at the beginning of 01 January, 1970 UTC is
represented by the value +0.

15.9.1.2 Day Number and Time within Day

A given time value _t_ belongs to day number

  Day(_t_) = floor(_t_ / msPerDay)

where the number of milliseconds per day is

  msPerDay = 86400000

The remainder is called the time within the day:

  TimeWithinDay(_t_) = _t_ modulo msPerDay

15.9.1.3 Year Number

ECMAScript uses an extrapolated Gregorian system to map a day number to
a year number and to determine the month and date within that year. In
this system, leap years are precisely those which are (divisible by 4)
and ((not divisible by 100) or (divisible by 400)). The number of days
in year number _y_ is therefore defined by

  DaysInYear(_y_) = 365 if (_y_ modulo 4) ≠ 0
  = 366 if (_y_ modulo 4) = 0 and (_y_ modulo 100) ≠ 0
  = 365 if (_y_ modulo 100) = 0 and (_y_ modulo 400) ≠ 0
  = 366 if (_y_ modulo 400) = 0

All non-leap years have 365 days with the usual number of days per month
and leap years have an extra day in February. The day number of the
first day of year _y_ is given by:

  DayFromYear(_y_) = 365 × (_y_−1970) + floor((_y_−1969)/4) −
  floor((_y_−1901)/100) + floor((_y_−1601)/400)

The time value of the start of a year is:

  TimeFromYear(_y_) = msPerDay × DayFromYear(_y_)

A time value determines a year by:

  YearFromTime(_t_) = the largest integer _y_ (closest to positive
  infinity) such that TimeFromYear(_y_) ≤ _t_

The leap-year function is 1 for a time within a leap year and otherwise
is zero:

  InLeapYear(_t_) = 0 if DaysInYear(YearFromTime(_t_)) = 365
  = 1 if DaysInYear(YearFromTime_(t_)) = 366

15.9.1.4 Month Number

Months are identified by an integer in the range 0 to 11, inclusive. The
mapping MonthFromTime(_t_) from a time value _t_ to a month number is
defined by:

  MonthFromTime(_t_) = 0 if 0 ≤ DayWithinYear(_t_) < 31
   = 1 if 31 ≤ DayWithinYear (_t_) < 59+InLeapYear(_t_)
   = 2 if 59+InLeapYear(_t_) ≤ DayWithinYear (_t_) < 90+InLeapYear(_t_)
   = 3 if 90+InLeapYear(_t_) ≤ DayWithinYear (_t_) < 120+InLeapYear(_t_)
   = 4 if 120+InLeapYear(_t_) ≤ DayWithinYear (_t_) <
  151+InLeapYear(_t_)
   = 5 if 151+InLeapYear(_t_) ≤ DayWithinYear (_t_) <
  181+InLeapYear(_t_)
   = 6 if 181+InLeapYear(_t_) ≤ DayWithinYear (_t_) <
  212+InLeapYear(_t_)
   = 7 if 212+InLeapYear(_t_) ≤ DayWithinYear (_t_) <
  243+InLeapYear(_t_)
   = 8 if 243+InLeapYear(_t_) ≤ DayWithinYear (_t_) <
  273+InLeapYear(_t_)
   = 9 if 273+InLeapYear(_t_) ≤ DayWithinYear (_t_) <
  304+InLeapYear(_t_)
   = 10 if 304+InLeapYear(_t_) ≤ DayWithinYear (_t_) <
  334+InLeapYear(_t_)
   = 11 if 334+InLeapYear(_t_) ≤ DayWithinYear (_t_) <
  365+InLeapYear(_t_)

where

  DayWithinYear(_t_) = Day(_t_)−DayFromYear(YearFromTime(_t)_)

A month value of 0 specifies January; 1 specifies February; 2 specifies
March; 3 specifies April; 4 specifies May; 5 specifies June; 6 specifies
July; 7 specifies August; 8 specifies September; 9 specifies October; 10
specifies November; and 11 specifies December. Note that
MonthFromTime(0) = 0, corresponding to Thursday, 01 January, 1970.

15.9.1.5 Date Number

A date number is identified by an integer in the range 1 through 31,
inclusive. The mapping DateFromTime(_t_) from a time value _t_ to a
month number is defined by:

  DateFromTime(_t_) = DayWithinYear(_t_)+1 if MonthFromTime(_t_)=0
   = DayWithinYear(_t_)−30 if MonthFromTime(_t_)=1
   = DayWithinYear(_t_)−58−InLeapYear(_t_) if MonthFromTime(_t_)=2
   = DayWithinYear(_t_)−89−InLeapYear(_t_) if MonthFromTime(_t_)=3
   = DayWithinYear(_t_)−119−InLeapYear(_t_) if MonthFromTime(_t_)=4
   = DayWithinYear(_t_)−150−InLeapYear(_t_) if MonthFromTime(_t_)=5
   = DayWithinYear(_t_)−180−InLeapYear(_t_) if MonthFromTime(_t_)=6
   = DayWithinYear(_t_)−211−InLeapYear(_t_) if MonthFromTime(_t_)=7
   = DayWithinYear(_t_)−242−InLeapYear(_t_) if MonthFromTime(_t_)=8
   = DayWithinYear(_t_)−272−InLeapYear(_t_) if MonthFromTime(_t_)=9
   = DayWithinYear(_t_)−303−InLeapYear(_t_) if MonthFromTime(_t_)=10
   = DayWithinYear(_t_)−333−InLeapYear(_t_) if MonthFromTime(_t_)=11

15.9.1.6 Week Day

The weekday for a particular time value _t_ is defined as

  WeekDay(_t_) = (Day(_t_) + 4) modulo 7

A weekday value of 0 specifies Sunday; 1 specifies Monday; 2 specifies
Tuesday; 3 specifies Wednesday; 4 specifies Thursday; 5 specifies
Friday; and 6 specifies Saturday. Note that WeekDay(0) = 4,
corresponding to Thursday, 01 January, 1970.

15.9.1.7 Local Time Zone Adjustment

An implementation of ECMAScript is expected to determine the local time
zone adjustment. The local time zone adjustment is a value LocalTZA
measured in milliseconds which when added to UTC represents the local
_standard_ time. Daylight saving time is _not_ reflected by LocalTZA.

NOTE It is recommended that implementations use the time zone
information of the IANA Time Zone Database.

15.9.1.8 Daylight Saving Time Adjustment

An implementation of ECMAScript is expected to make its best effort to
determine the local daylight saving time adjustment. An implementation
dependent algorithm using best available information on time zones to
determine the local daylight saving time adjustment
DaylightSavingTA(_t_), measured in milliseconds.

15.9.1.9 Local Time

Conversion from UTC to local time is defined by

  LocalTime(_t_) = _t_ + LocalTZA + DaylightSavingTA(_t_)

Conversion from local time to UTC is defined by

  UTC(_t_) = _t_ – LocalTZA – DaylightSavingTA(_t_ – LocalTZA)

Note that UTC(LocalTime(_t_)) is not necessarily always equal to _t_.

15.9.1.10 Hours, Minutes, Second, and Milliseconds

The following functions are useful in decomposing time values:

  HourFromTime(_t_) = floor(_t_ / msPerHour) modulo HoursPerDay

  MinFromTime(_t_) = floor(_t_ / msPerMinute) modulo MinutesPerHour

  SecFromTime(_t_) = floor(_t_ / msPerSecond) modulo SecondsPerMinute

  msFromTime(_t_) = _t_ modulo msPerSecond

where

  HoursPerDay = 24

  MinutesPerHour = 60

  SecondsPerMinute = 60

  msPerSecond = 1000

  msPerMinute = 60000 = msPerSecond × SecondsPerMinute

  msPerHour = 3600000 = msPerMinute × MinutesPerHour

15.9.1.11 MakeTime (hour, min, sec, ms)

The operator MakeTime calculates a number of milliseconds from its four
arguments, which must be ECMAScript Number values. This operator
functions as follows:

1.  If _hour_ is not finite or _min_ is not finite or _sec_ is not
    finite or _ms_ is not finite, return NAN.

2.  Let _h_ be ToInteger(_hour_).

3.  Let _m_ be ToInteger(_min_).

4.  Let _s_ be ToInteger(_sec_).

5.  Let _milli_ be ToInteger(_ms_).

6.  Let _t_ be _h_ * msPerHour + _m_ * msPerMinute + _s_ * msPerSecond +
    _milli_, performing the arithmetic according to IEEE 754 rules (that
    is, as if using the ECMAScript operators * and +).

7.  Return _t_.

15.9.1.12 MakeDay (year, month, date)

The operator MakeDay calculates a number of days from its three
arguments, which must be ECMAScript Number values. This operator
functions as follows:

15.9.1.13 MakeDate (day, time)

The operator MakeDate calculates a number of milliseconds from its two
arguments, which must be ECMAScript Number values. This operator
functions as follows:

15.9.1.14 TimeClip (time)

The operator TimeClip calculates a number of milliseconds from its
argument, which must be an ECMAScript Number value. This operator
functions as follows:

NOTE The point of step 3 is that an implementation is permitted a choice
of internal representations of time values, for example as a 64-bit
signed integer or as a 64-bit floating-point value. Depending on the
implementation, this internal representation may or may not distinguish
−0 and +0.

15.9.1.15 Date Time String Format

ECMAScript defines a string interchange format for date-times based upon
a simplification of the ISO 8601 Extended Format. The format is as
follows: YYYY-MM-DDTHH:MM:SS.SSS_Z_

Where the fields are as follows:

This format includes date-only forms:

YYYY
YYYY-MM
YYYY-MM-DD

It also includes “date-time” forms that consist of one of the above
date-only forms immediately followed by one of the following time forms
with an optional time zone offset appended:

THH:MM
THH:MM:SS
THH:MM:SS.SSS

All numbers must be base 10. If the MM or DD fields are absent “01” is
used as the value. If the HH, MM, or SS fields are absent “00” is used
as the value and the value of an absent SSS field is “000”. If the time
zone offset is absent, the date-time is interpreted as a local time.

Illegal values (out-of-bounds as well as syntax errors) in a format
string means that the format string is not a valid instance of this
format.

NOTE 1 As every day both starts and ends with midnight, the two
notations 00:00 and 24:00 are available to distinguish the two midnights
that can be associated with one date. This means that the following two
notations refer to exactly the same point in time: 1995-02-04T24:00 and
1995-02-05T00:

NOTE 2 There exists no international standard that specifies
abbreviations for civil time zones like CET, EST, etc. and sometimes the
same abbreviation is even used for two very different time zones. For
this reason, ISO 8601 and this format specifies numeric representations
of date and time.

15.9.1.15.1 Extended years

ECMAScript requires the ability to specify 6 digit years (extended
years); approximately 285,426 years, either forward or backward, from 01
January, 1970 UTC. To represent years before 0 or after 9999, ISO 8601
permits the expansion of the year representation, but only by prior
agreement between the sender and the receiver. In the simplified
ECMAScript format such an expanded year representation shall have 2
extra year digits and is always prefixed with a + or – sign. The year 0
is considered positive and hence prefixed with a + sign.

NOTE Examples of extended years:

  -283457-03-21T15:00:59.008Z   283458 B.C.
  -000001-01-01T00:00:00Z          2 B.C.
  +000000-01-01T00:00:00Z         1 B.C.
  +000001-01-01T00:00:00Z         1 A.D.
  +001970-01-01T00:00:00Z         1970 A.D.
  +002009-12-15T00:00:00Z         2009 A.D.
  +287396-10-12T08:59:00.992Z 287396 A.D.

15.9.2 The Date Constructor Called as a Function

When DATE is called as a function rather than as a constructor, it
returns a String representing the current time (UTC). However, if the
THIS value value passed in the call is an Object with an uninitialized
[[DateValue]] internal data property, DATE initializes the THIS object
using the argument value. This permits DATE to be used both as a
function for creating data strings and to perform constructor instance
initialization.

DATE may be subclassed and subclass constructors may perform a super
invocation of the DATE constructor to initialize the [[DateValue]] state
of subclass instances.

15.9.2.1 Date (year, month [, date [, hours [, minutes [, seconds [, ms ] ] ] ] ] )

This description applies only if the Date constructor is called with at
least two arguments.

When the DATE function is called the following steps are taken:

15.9.2.2 Date (value)

This description applies only if the Date constructor is called with
exactly one argument.

When the DATE function is called the following steps are taken:

1.  Let _numberOfArgs_ be the number of arguments passed to this
    constructor call.

2.  Assert: _numberOfArgs_ = 1.

3.  Let _O_ be the THIS value.

4.  If Type(_O_) is Object and _O_ has a [[DateValue]] internal data
    property and the value of [[DateValue]] is UNDEFINED, then

    a.  If Type(_value_) is Object and _value_ has a [[DateValue]]
        internal data property, then

        i.  Let _tv_ be thisTimeValue(_value_).

    b.  Else,

        i.  ii. iii. iv. v.  Let _v_ be ToPrimitive(_value_).

        vi. If Type(_v_) is String, then

            1.  Let _tv_ be the result of parsing _v_ as a date, in
                exactly the same manner as for the PARSE method
                (15.9.4.2). If the parse resulted in an abrupt
                completion, _tv_ is the Completion Record.

        vii. Else,

            1.  Let _tv_ be ToNumber(_v_).

    c.  ReturnIfAbrupt(_tv_).

    d.  Set the [[DateValue]] internal data property of _O_ to
        TimeClip(_tv_).

    e.  Return _O_.

5.  6.  Else,

    a.  Return the result computed as if by the expression (NEW
        DATE()).TOSTRING() where DATE is this function and TOSTRING is
        the standard built-in method DATE.PROTOTYPE.TOSTRING.

15.9.2.3 Date ( )

This description applies only if the Date constructor is called with no
arguments.

When the DATE function is called the following steps are taken:

1.  Let _numberOfArgs_ be the number of arguments passed to this
      constructor call.

2.  Assert: _numberOfArgs_ = 0.

3.  Let _O_ be the THIS value.

4.  If Type(_O_) is Object and _O_ has a [[DateValue]] internal data
      property and the value of [[DateValue]] is UNDEFINED, then

    a.  Set the [[DateValue]] internal data property of _O_ to the time
          value (UTC) identifying the current time.

    b.  Return _O_.

5.  Else,

    a.  Return the result computed as if by the expression (NEW
          DATE()).TOSTRING() where DATE is this function and TOSTRING is
          the standard built-in method DATE.PROTOTYPE.TOSTRING.

15.9.3 The Date Constructor

When DATE is called as part of a NEW expression, it is a constructor: it
initialises the newly created ordinary object.

15.9.3.1 new Date ( ...args )

DATE called as part of a new expression with argument list _args_
performs the following steps:

1.  Let _F_ be the DATE function object on which the NEW operator was
    applied.

2.  Let _argumentsList_ be the _argumentsList_ argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of OrdinaryConstruct (_F_, _argumentsList_).

If DATE is implemented as an ordinary function object, its [[Construct]]
internal method will perform the above steps.

15.9.4 Properties of the Date Constructor

The value of the [[Prototype]] internal data property of the Date
constructor is the Function prototype object (15.3.3).

Besides the LENGTH property (whose value is 7), the Date constructor has
the following properties:

15.9.4.1 Date.prototype

The initial value of DATE.PROTOTYPE is the built-in Date prototype
object (15.9.5).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

15.9.4.2 Date.parse (string)

The PARSE function applies the ToString operator to its argument. If
ToString results in an abrupt completion the Completion Record is
immediately returned. Otherwise, PARSE interprets the resulting String
as a date and time; it returns a Number, the UTC time value
corresponding to the date and time. The String may be interpreted as a
local time, a UTC time, or a time in some other time zone, depending on
the contents of the String. The function first attempts to parse the
format of the String according to the rules called out in Date Time
String Format (15.9.1.15). If the String does not conform to that format
the function may fall back to any implementation-specific heuristics or
implementation-specific date formats. Unrecognisable Strings or dates
containing illegal element values in the format String shall cause
DATE.PARSE to return NAN.

If _x_ is any Date object whose milliseconds amount is zero within a
particular implementation of ECMAScript, then all of the following
expressions should produce the same numeric value in that
implementation, if all the properties referenced have their initial
values:

  _X_.VALUEOF()

  DATE.PARSE(_X_.TOSTRING())

  DATE.PARSE(_X_.TOUTCSTRING())

  DATE.PARSE(_X_.TOISOSTRING())

However, the expression

  DATE.PARSE(_X_.TOLOCALESTRING())

is not required to produce the same Number value as the preceding three
expressions and, in general, the value produced by DATE.PARSE is
implementation-dependent when given any String value that does not
conform to the Date Time String Format (15.9.1.15) and that could not be
produced in that implementation by the TOSTRING or TOUTCSTRING method.

15.9.4.3 Date.UTC (year, month [, date [, hours [, minutes [, seconds [, ms ] ] ] ] ] )

When the UTC function is called with fewer than two arguments, the
behaviour is implementation-dependent. When the UTC function is called
with two to seven arguments, it computes the date from _year_, _month_
and (optionally) _date_, _hours_, _minutes_, _seconds_ and _ms_. The
following steps are taken:

The LENGTH property of the UTC function is 7.

NOTE The UTC function differs from the Date constructor in two ways: it
returns a time value as a Number, rather than creating a Date object,
and it interprets the arguments in UTC rather than as local time.

15.9.4.4 Date.now ( )

The NOW function return a Number value that is the time value
designating the UTC date and time of the occurrence of the call to NOW.

15.9.4.5 Date[ @@create ] ( )

The @@create method of an object _F_ performs the following steps:

1.  Let _obj_ be the result of calling
    OrdinaryCreateFromConstructor(_F_, "%DATEPROTOTYPE%", (
    [[DateValue]])).

2.  ReturnIfAbrupt(_obj_).

3.  4.  5.  6.  Return _obj_.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

NOTE [[DateValue]] is initially assigned the value UNDEFINED as a flag
to indicate that the instance has not yet been initialized by the Date
constructor. This flag value is never directly exposed to ECMAScript
code; hence implementation may choose to encode the flag in some other
manner.

15.9.5 Properties of the Date Prototype Object

The Date prototype object is itself an ordinary object. It is not a Date
instance and does not have a [[DateValue]] internal data property.

The value of the [[Prototype]] internal data property of the Date
prototype object is the standard built-in Object prototype object
(15.2.4).

Unless explicitly stated otherwise, the methods of the Date prototype
object defined below are not generic and the THIS value passed to them
must be an object that has a [[DateValue]] internal data property that
has been initialized to a time value.

The abstract operation thisTimeValue(_value_) performs the following
steps:

1.  If Type(_value)_ is Object and _value_ has a [[DateValue]] internal
    data property, then

    a.  Let _n_ be the Number that is the value of _value’s_
        [[NumberData]] internal data property.

    b.  If _n_ is not UNDEFINED, then return _n_.

2.  Throw a TYPEERROR exception.

In following descriptions of functions that are properties of the Date
prototype object, the phrase “this Date object” refers to the object
that is the THIS value for the invocation of the function. The phrase
“this time value” within the specification of a method refers to the
result returned by calling the abstract operation thisTimeValue with the
THIS value of the method invocation passed as the argument.

15.9.5.1 Date.prototype.constructor

The initial value of DATE.PROTOTYPE.CONSTRUCTOR is the built-in DATE
constructor.

15.9.5.2 Date.prototype.toString ( )

This function returns a String value. If this time value is NaN, the
String value is "INVALID DATE", otherwise the contents of the String are
implementation-dependent, but are intended to represent the Date in the
current time zone in a convenient, human-readable form.

NOTE For any Date value _d_ whose milliseconds amount is zero, the
result of Date.parse(_d_.toString()) is equal to _d_.valueOf(). See
15.9.4.2.

15.9.5.3 Date.prototype.toDateString ( )

This function returns a String value. The contents of the String are
implementation-dependent, but are intended to represent the “date”
portion of the Date in the current time zone in a convenient,
human-readable form.

15.9.5.4 Date.prototype.toTimeString ( )

This function returns a String value. The contents of the String are
implementation-dependent, but are intended to represent the “time”
portion of the Date in the current time zone in a convenient,
human-readable form.

15.9.5.5 Date.prototype.toLocaleString ( )

This function returns a String value. The contents of the String are
implementation-dependent, but are intended to represent the Date in the
current time zone in a convenient, human-readable form that corresponds
to the conventions of the host environment’s current locale.

NOTE The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that implementations
do not use this parameter position for anything else.

15.9.5.6 Date.prototype.toLocaleDateString ( )

This function returns a String value. The contents of the String are
implementation-dependent, but are intended to represent the “date”
portion of the Date in the current time zone in a convenient,
human-readable form that corresponds to the conventions of the host
environment’s current locale.

NOTE The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that implementations
do not use this parameter position for anything else.

15.9.5.7 Date.prototype.toLocaleTimeString ( )

This function returns a String value. The contents of the String are
implementation-dependent, but are intended to represent the “time”
portion of the Date in the current time zone in a convenient,
human-readable form that corresponds to the conventions of the host
environment’s current locale.

NOTE The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that implementations
do not use this parameter position for anything else.

15.9.5.8 Date.prototype.valueOf ( )

The VALUEOF function returns a Number, which is this time value.

15.9.5.9 Date.prototype.getTime ( )

15.9.5.10 Date.prototype.getFullYear ( )

15.9.5.11 Date.prototype.getUTCFullYear ( )

15.9.5.12 Date.prototype.getMonth ( )

15.9.5.13 Date.prototype.getUTCMonth ( )

1.  Let _t_ be this time value.

2.  ReturnIfAbrupt(_t_).

3.  If _t_ is NAN, return NAN.

4.  Return MonthFromTime(_t_).

15.9.5.14 Date.prototype.getDate ( )

1.  Let _t_ be this time value.

2.  ReturnIfAbrupt(_t_).

3.  If _t_ is NAN, return NAN.

4.  Return DateFromTime(LocalTime(_t_)).

15.9.5.15 Date.prototype.getUTCDate ( )

15.9.5.16 Date.prototype.getDay ( )

1.  Let _t_ be this time value.

2.  ReturnIfAbrupt(_t_).

3.  If _t_ is NAN, return NAN.

4.  Return WeekDay(LocalTime(_t_)).

15.9.5.17 Date.prototype.getUTCDay ( )

15.9.5.18 Date.prototype.getHours ( )

15.9.5.19 Date.prototype.getUTCHours ( )

15.9.5.20 Date.prototype.getMinutes ( )

1.  Let _t_ be this time value.

2.  ReturnIfAbrupt(_t_).

3.  If _t_ is NAN, return NAN.

4.  Return MinFromTime(LocalTime(_t_)).

15.9.5.21 Date.prototype.getUTCMinutes ( )

1.  Let _t_ be this time value.

2.  ReturnIfAbrupt(_t_).

3.  If _t_ is NAN, return NAN.

4.  Return MinFromTime(_t_).

15.9.5.22 Date.prototype.getSeconds ( )

15.9.5.23 Date.prototype.getUTCSeconds ( )

15.9.5.24 Date.prototype.getMilliseconds ( )

15.9.5.25 Date.prototype.getUTCMilliseconds ( )

1.  Let _t_ be this time value.

2.  ReturnIfAbrupt(_t_).

3.  If _t_ is NAN, return NAN.

4.  Return msFromTime(_t_).

15.9.5.26 Date.prototype.getTimezoneOffset ( )

Returns the difference between local time and UTC time in minutes.

15.9.5.27 Date.prototype.setTime (time)

15.9.5.28 Date.prototype.setMilliseconds (ms)

1.  Let _t_ be the result of LocalTime(this time value).

2.  Let _time_ be MakeTime(HourFromTime(_t_), MinFromTime(_t_),
    SecFromTime(_t_), ToNumber(_ms_)).

3.  Let _u_ be TimeClip(UTC(MakeDate(Day(_t_), _time_))).

4.  Set the [[DateValue]] internal data property of this Date object to
    _u_.

5.  Return _u_.

15.9.5.29 Date.prototype.setUTCMilliseconds (ms)

15.9.5.30 Date.prototype.setSeconds (sec [, ms ] )

If _ms_ is not specified, this behaves as if _ms_ were specified with
the value GETMILLISECONDS().

The LENGTH property of the SETSECONDS method is 2.

15.9.5.31 Date.prototype.setUTCSeconds (sec [, ms ] )

If _ms_ is not specified, this behaves as if _ms_ were specified with
the value GETUTCMILLISECONDS().

1.  Let _t_ be this time value.

2.  ReturnIfAbrupt(_t_).

3.  Let _s_ be ToNumber(_sec_).

4.  If _ms_ is not specified, then let _milli_ be msFromTime(_t_);
    otherwise, let _milli_ be ToNumber(_ms_).

5.  Let _date_ be MakeDate(Day(_t_), MakeTime(HourFromTime(_t_),
    MinFromTime(_t_), _s_, _milli_)).

6.  Let _v_ be TimeClip(_date_).

7.  Set the [[DateValue]] internal data property of this Date object to
    _v_.

8.  Return _v_.

The LENGTH property of the SETUTCSECONDS method is 2.

15.9.5.32 Date.prototype.setMinutes (min [, sec [, ms ] ] )

If _sec_ is not specified, this behaves as if _sec_ were specified with
the value GETSECONDS().

If _ms_ is not specified, this behaves as if _ms_ were specified with
the value GETMILLISECONDS().

The LENGTH property of the SETMINUTES method is 3.

15.9.5.33 Date.prototype.setUTCMinutes (min [, sec [, ms ] ] )

If _sec_ is not specified, this behaves as if _sec_ were specified with
the value GETUTCSECONDS().

If _ms_ is not specified, this function behaves as if _ms_ were
specified with the value return by GETUTCMILLISECONDS().

The LENGTH property of the SETUTCMINUTES method is 3.

15.9.5.34 Date.prototype.setHours (hour [, min [, sec [, ms ] ] ] )

If _min_ is not specified, this behaves as if _min_ were specified with
the value GETMINUTES().

If _sec_ is not specified, this behaves as if _sec_ were specified with
the value GETSECONDS().

If _ms_ is not specified, this behaves as if _ms_ were specified with
the value GETMILLISECONDS().

The LENGTH property of the SETHOURS method is 4.

15.9.5.35 Date.prototype.setUTCHours (hour [, min [, sec [, ms ] ] ] )

If _min_ is not specified, this behaves as if _min_ were specified with
the value GETUTCMINUTES().

If _sec_ is not specified, this behaves as if _sec_ were specified with
the value GETUTCSECONDS().

If _ms_ is not specified, this behaves as if _ms_ were specified with
the value GETUTCMILLISECONDS().

The LENGTH property of the SETUTCHOURS method is 4.

15.9.5.36 Date.prototype.setDate (date)

15.9.5.37 Date.prototype.setUTCDate (date)

1.  Let _t_ be this time value.

2.  ReturnIfAbrupt(_t_).

3.  Let _dt_ be ToNumber(_date_).

4.  Let _newDate_ be MakeDate(MakeDay(YearFromTime(_t_),
    MonthFromTime(_t_), _dt_), TimeWithinDay(_t_)).

5.  Let _v_ be TimeClip(_newDate_).

6.  Set the [[DateValue]] internal data property of this Date object to
    _v_.

7.  Return _v_.

15.9.5.38 Date.prototype.setMonth (month [, date ] )

If _date_ is not specified, this behaves as if _date_ were specified
with the value GETDATE().

The LENGTH property of the SETMONTH method is 2.

15.9.5.39 Date.prototype.setUTCMonth (month [, date ] )

If _date_ is not specified, this behaves as if _date_ were specified
with the value GETUTCDATE().

1.  Let _t_ be this time value.

2.  ReturnIfAbrupt(_t_).

3.  Let _m_ be ToNumber(_month_).

4.  If _date_ is not specified, then let _dt_ be DateFromTime(_t_);
    otherwise, let _dt_ be ToNumber(_date_).

5.  Let _newDate_ be MakeDate(MakeDay(YearFromTime(_t_), _m_, _dt_),
    TimeWithinDay(_t_)).

6.  Let _v_ be TimeClip(_newDate_).

7.  Set the [[DateValue]] internal data property of this Date object to
    _v_.

8.  Return _v_.

The LENGTH property of the SETUTCMONTH method is 2.

15.9.5.40 Date.prototype.setFullYear (year [, month [, date ] ] )

If _month_ is not specified, this behaves as if _month_ were specified
with the value GETMONTH().

If _date_ is not specified, this behaves as if _date_ were specified
with the value GETDATE().

The LENGTH property of the SETFULLYEAR method is 3.

15.9.5.41 Date.prototype.setUTCFullYear (year [, month [, date ] ] )

If _month_ is not specified, this behaves as if _month_ were specified
with the value GETUTCMONTH().

If _date_ is not specified, this behaves as if _date_ were specified
with the value GETUTCDATE().

The LENGTH property of the SETUTCFULLYEAR method is 3.

15.9.5.42 Date.prototype.toUTCString ( )

This function returns a String value. The contents of the String are
implementation-dependent, but are intended to represent the Date in a
convenient, human-readable form in UTC.

NOTE The intent is to produce a String representation of a date that is
more readable than the format specified in 15.9.1.15. It is not
essential that the chosen format be unambiguous or easily machine
parsable. If an implementation does not have a preferred human-readable
format it is recommended to use the format defined in 15.9.1.15 but with
a space rather than a “T” used to separate the date and time elements.

15.9.5.43 Date.prototype.toISOString ( )

This function returns a String value represent the instance in time
represented by this Date object. The format of the String is the Date
Time string format defined in 15.9.1.15. All fields are present in the
String. The time zone is always UTC, denoted by the suffix Z. If the
time value of this object is not a finite Number a RANGEERROR exception
is thrown.

15.9.5.44 Date.prototype.toJSON ( key )

This function provides a String representation of a Date object for use
by JSON.STRINGIFY (15.12.3).

When the TOJSON method is called with argument _key_, the following
steps are taken:

NOTE 1 The argument is ignored.

NOTE 2 The TOJSON function is intentionally generic; it does not require
that its THIS value be a Date object. Therefore, it can be transferred
to other kinds of objects for use as a method. However, it does require
that any such object have a TOISOSTRING method. An object is free to use
the argument _key_ to filter its stringification.

15.9.5.45 Date.prototype.@@ToPrimitive ( hint )

This function is called by ECMAScript language operators to convert an
object to a primitive value. The allowed values for _hint_ are
"DEFAULT", "NUMBER", and "STRING". Date objects, are unique among
built-in ECMAScript object in that they treat "DEFAULT" as being
equivalent to "STRING", All other built-in ECMAScript objects treat
"DEFAULT" as being equivalent to "NUMBER".

When the @@TOPRIMITIVE method is called with argument _hint_, the
following steps are taken:

1.  Let _O_ be this Date object.

2.  If Type(_O_) is not Object, then throw a TYPEERROR exception.

3.  If _hint_ is the string value "STRING" or the string value "DEFAULT"
    , then

    a.  Let _tryFirst_ be "STRING".

4.  Else if _hint_ is the string value "NUMBER", then

    a.  Let _tryFirst_ be "NUMBER".

5.  Else, throw a TYPEERROR exception.

6.  Return the result of OrdinaryToPrimitive(_O_,_tryFirst_).

15.9.6 Properties of Date Instances

Date instances are ordinary objects that inherit properties from the
Date prototype object. Date instances also have a [[DateValue]] internal
data property.

The [[DateValue]] internal data property is the time value represented
by this Date object.


15.10 RegExp (Regular Expression) Objects

A RegExp object contains a regular expression and the associated flags.

NOTE The form and functionality of regular expressions is modelled after
the regular expression facility in the Perl 5 programming language.

15.10.1 Patterns

The REGEXP constructor applies the following grammar to the input
pattern String. An error occurs if the grammar cannot interpret the
String as an expansion of _Pattern_.

Syntax

Pattern ::

Disjunction

Disjunction ::

Alternative
 Alternative | Disjunction

Alternative ::

[empty]
Alternative Term

Term ::

Assertion
Atom
Atom Quantifier

Assertion ::

^
$
\ B
\ B
( ? = Disjunction )
( ? ! Disjunction )

Quantifier ::

QuantifierPrefix
QuantifierPrefix ?

QuantifierPrefix ::

*
+
?
{ DecimalDigits }
{ DecimalDigits , }
{ DecimalDigits , DecimalDigits }

Atom ::

PatternCharacter
.
\ AtomEscape
CharacterClass
( Disjunction )
( ? : Disjunction )

PatternCharacter ::

SourceCharacter BUT NOT ONE OF
 ^ $ \ . * + ? ( ) [ ] { } |

AtomEscape ::

DecimalEscape
CharacterEscape
CharacterClassEscape

CharacterEscape ::

ControlEscape
C ControlLetter
HexEscapeSequence
UnicodeEscapeSequence
IdentityEscape

ControlEscape :: ONE OF

F N R T V

ControlLetter :: ONE OF

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

IdentityEscape ::

SourceCharacter BUT NOT IdentifierPart
<ZWJ>
<ZWNJ>

DecimalEscape ::

DecimalIntegerLiteral [lookahead ∉ DecimalDigit]

CharacterClassEscape :: ONE OF

D D S S W W

CharacterClass ::

[ [lookahead ∉ {^}] ClassRanges ]
[ ^ ClassRanges ]

ClassRanges ::

[empty]
NonemptyClassRanges

NonemptyClassRanges ::

ClassAtom
ClassAtom NonemptyClassRangesNoDash
ClassAtom - ClassAtom ClassRanges

NonemptyClassRangesNoDash ::

ClassAtom
ClassAtomNoDash NonemptyClassRangesNoDash
ClassAtomNoDash - ClassAtom ClassRanges

ClassAtom ::

-
ClassAtomNoDash

ClassAtomNoDash ::

SourceCharacter BUT NOT ONE OF \ OR ] OR -
\ ClassEscape

ClassEscape ::

DecimalEscape
B
CharacterEscape
CharacterClassEscape

15.10.2 Pattern Semantics

A regular expression pattern is converted into an internal procedure
using the process described below. An implementation is encouraged to
use more efficient algorithms than the ones listed below, as long as the
results are the same. The internal procedure is used as the value of a
RegExp object’s [[RegExpMatcher]] internal data property.

15.10.2.1 Notation

The descriptions below use the following variables:

-   _Input_ is the String being matched by the regular expression
      pattern. The notation _input_[_n_] means the _n^th^_ character of
      _input_, where _n_ can range between 0 (inclusive) and
      _InputLength_ (exclusive).

-   _InputLength_ is the number of characters in the _Input_ String.

-   _NcapturingParens_ is the total number of left capturing parentheses
      (i.e. the total number of times the _Atom_ :: ( _Disjunction_ )
      production is expanded) in the pattern. A left capturing
      parenthesis is any ( pattern character that is matched by the (
      terminal of the _Atom_ :: ( _Disjunction_ ) production.

-   _IgnoreCase_ is the setting of the RegExp object's IGNORECASE
      property.

-   _Multiline_ is the setting of the RegExp object’s MULTILINE
      property.

Furthermore, the descriptions below use the following internal data
structures:

-   A _CharSet_ is a mathematical set of characters.

-   A _State_ is an ordered pair (_endIndex_, _captures_) where
      _endIndex_ is an integer and _captures_ is an internal array of
      _NcapturingParens_ values. _States_ are used to represent partial
      match states in the regular expression matching algorithms. The
      _endIndex_ is one plus the index of the last input character
      matched so far by the pattern, while _captures_ holds the results
      of capturing parentheses. The _n^th^_ element of _captures_ is
      either a String that represents the value obtained by the _n^th^_
      set of capturing parentheses or UNDEFINED if the _n^th^_ set of
      capturing parentheses hasn’t been reached yet. Due to
      backtracking, many _States_ may be in use at any time during the
      matching process.

-   A _MatchResult_ is either a _State_ or the special token FAILURE
      that indicates that the match failed.

-   A _Continuation_ procedure is an internal closure (i.e. an internal
      procedure with some arguments already bound to values) that takes
      one _State_ argument and returns a _MatchResult_ result. If an
      internal closure references variables bound in the function that
      creates the closure, the closure uses the values that these
      variables had at the time the closure was created. The
      _Continuation_ attempts to match the remaining portion (specified
      by the closure's already-bound arguments) of the pattern against
      the input String, starting at the intermediate state given by its
      _State_ argument. If the match succeeds, the _Continuation_
      returns the final _State_ that it reached; if the match fails, the
      _Continuation_ returns FAILURE.

-   A _Matcher_ procedure is an internal closure that takes two
      arguments -- a _State_ and a _Continuation_ -- and returns a
      _MatchResult_ result. A _Matcher_ attempts to match a middle
      subpattern (specified by the closure's already-bound arguments) of
      the pattern against the input String, starting at the intermediate
      state given by its _State_ argument. The _Continuation_ argument
      should be a closure that matches the rest of the pattern. After
      matching the subpattern of a pattern to obtain a new _State_, the
      _Matcher_ then calls _Continuation_ on that new _State_ to test if
      the rest of the pattern can match as well. If it can, the
      _Matcher_ returns the _State_ returned by _Continuation_; if not,
      the _Matcher_ may try different choices at its choice points,
      repeatedly calling _Continuation_ until it either succeeds or all
      possibilities have been exhausted.

-   An _AssertionTester_ procedure is an internal closure that takes a
      _State_ argument and returns a Boolean result. The assertion
      tester tests a specific condition (specified by the closure's
      already-bound arguments) against the current place in the input
      String and returns TRUE if the condition matched or FALSE if not.

-   An _EscapeValue_ is either a character or an integer. An
      _EscapeValue_ is used to denote the interpretation of a
      _DecimalEscape_ escape sequence: a character _ch_ means that the
      escape sequence is interpreted as the character _ch_, while an
      integer _n_ means that the escape sequence is interpreted as a
      backreference to the _n_^th^ set of capturing parentheses.

15.10.2.2 Pattern

The production _Pattern_ :: _Disjunction_ evaluates as follows:

1.  Let _Input_ be the given String _str_. This variable will be used
      throughout the algorithms in 15.10.2.

2.  Let _InputLength_ be the length of _Input_. This variable will be
      used throughout the algorithms in 15.10.2.

3.  Let _c_ be a Continuation that always returns its State argument as
      a successful MatchResult.

4.  Let _cap_ be an internal array of _NcapturingParens_ UNDEFINED
      values, indexed 1 through _NcapturingParens_.

5.  Let _x_ be the State (_index_, _cap_).

6.  Call _m_(_x_, _c_) and return its result.

NOTE A Pattern evaluates ("compiles") to an internal procedure value.
REGEXP.PROTOTYPE.EXEC can then apply this procedure to a String and an
offset within the String to determine whether the pattern would match
starting at exactly that offset within the String, and, if it does
match, what the values of the capturing parentheses would be. The
algorithms in 15.10.2 are designed so that compiling a pattern may throw
a SYNTAXERROR exception; on the other hand, once the pattern is
successfully compiled, applying its result internal procedure to find a
match in a String cannot throw an exception (except for any host-defined
exceptions that can occur anywhere such as out-of-memory).

15.10.2.3 Disjunction

The production _Disjunction_ :: _Alternative_ evaluates by evaluating
_Alternative_ to obtain a Matcher and returning that Matcher.

The production _Disjunction_ :: _Alternative_ | _Disjunction_ evaluates
as follows:

NOTE The | regular expression operator separates two alternatives. The
pattern first tries to match the left _Alternative_ (followed by the
sequel of the regular expression); if it fails, it tries to match the
right _Disjunction_ (followed by the sequel of the regular expression).
If the left _Alternative_, the right _Disjunction_, and the sequel all
have choice points, all choices in the sequel are tried before moving on
to the next choice in the left _Alternative_. If choices in the left
_Alternative_ are exhausted, the right _Disjunction_ is tried instead of
the left _Alternative_. Any capturing parentheses inside a portion of
the pattern skipped by | produce UNDEFINED values instead of Strings.
Thus, for example,

  /a|ab/.exec("abc")

returns the result "A" and not "AB". Moreover,

  /((a)|(ab))((c)|(bc))/.exec("abc")

returns the array

  ["abc", "a", "a", undefined, "bc", undefined, "bc"]

and not

  ["abc", "ab", undefined, "ab", "c", "c", undefined]

15.10.2.4 Alternative

The production _Alternative_ :: [empty] evaluates by returning a Matcher
that takes two arguments, a State _x_ and a Continuation _c_, and
returns the result of calling _c_(_x_).

The production _Alternative_ :: _Alternative_ _Term_ evaluates as
follows:

NOTE Consecutive _Terms_ try to simultaneously match consecutive
portions of the input String. If the left _Alternative_, the right
_Term_, and the sequel of the regular expression all have choice points,
all choices in the sequel are tried before moving on to the next choice
in the right _Term_, and all choices in the right _Term_ are tried
before moving on to the next choice in the left _Alternative_.

15.10.2.5 Term

The production _Term_ :: _Assertion_ evaluates by returning an internal
Matcher closure that takes two arguments, a State _x_ and a Continuation
_c_, and performs the following:

The production _Term_ :: _Atom_ evaluates by evaluating _Atom_ to obtain
a Matcher and returning that Matcher.

The production _Term_ :: _Atom_ _Quantifier_ evaluates as follows:

RUNTIME SEMANTICS: REPEATMATCHER ABSTRACT OPERATION

The abstract operation RepeatMatcher takes eight parameters, a Matcher
_m_, an integer _min_, an integer (or ∞) _max_, a Boolean _greedy_, a
State _x_, a Continuation _c_, an integer _parenIndex_, and an integer
_parenCount_, and performs the following:

NOTE 1 An _Atom_ followed by a _Quantifier_ is repeated the number of
times specified by the _Quantifier_. A _Quantifier_ can be non-greedy,
in which case the _Atom_ pattern is repeated as few times as possible
while still matching the sequel, or it can be greedy, in which case the
_Atom_ pattern is repeated as many times as possible while still
matching the sequel. The _Atom_ pattern is repeated rather than the
input String that it matches, so different repetitions of the _Atom_ can
match different input substrings.

NOTE 2 If the _Atom_ and the sequel of the regular expression all have
choice points, the _Atom_ is first matched as many (or as few, if
non-greedy) times as possible. All choices in the sequel are tried
before moving on to the next choice in the last repetition of _Atom_.
All choices in the last (n^th^) repetition of _Atom_ are tried before
moving on to the next choice in the next-to-last (n–1)^st^ repetition of
_Atom_; at which point it may turn out that more or fewer repetitions of
_Atom_ are now possible; these are exhausted (again, starting with
either as few or as many as possible) before moving on to the next
choice in the (n-1)^st^ repetition of _Atom_ and so on.

Compare

  /a[a-z]{2,4}/.exec("abcdefghi")

which returns "ABCDE" with

  /a[a-z]{2,4}?/.exec("abcdefghi")

which returns "ABC".

Consider also

  /(aa|aabaac|ba|b|c)*/.exec("aabaac")

which, by the choice point ordering above, returns the array

  ["aaba", "ba"]

and not any of:

  ["aabaac", "aabaac"]

  ["aabaac", "c"]

The above ordering of choice points can be used to write a regular
expression that calculates the greatest common divisor of two numbers
(represented in unary notation). The following example calculates the
gcd of 10 and 15:

  "aaaaaaaaaa,aaaaaaaaaaaaaaa".replace(/^(a+)\1*,\1+$/,"$1")

which returns the gcd in unary notation "AAAAA".

NOTE 3 Step 4 of the RepeatMatcher clears _Atom's_ captures each time
_Atom_ is repeated. We can see its behaviour in the regular expression

  /(z)((a+)?(b+)?(c))*/.exec("zaacbbbcac")

which returns the array

  ["zaacbbbcac", "z", "ac", "a", undefined, "c"]

and not

  ["zaacbbbcac", "z", "ac", "a", "bbb", "c"]

because each iteration of the outermost * clears all captured Strings
contained in the quantified _Atom_, which in this case includes capture
Strings numbered 2, 3, 4, and 5.

NOTE 4 Step 1 of the RepeatMatcher's _d_ closure states that, once the
minimum number of repetitions has been satisfied, any more expansions of
_Atom_ that match the empty String are not considered for further
repetitions. This prevents the regular expression engine from falling
into an infinite loop on patterns such as:

  /(a*)*/.exec("b")

or the slightly more complicated:

  /(a*)b\1+/.exec("baaaac")

which returns the array

  ["b", ""]

15.10.2.6 Assertion

The production _Assertion_ :: ^ evaluates by returning an internal
AssertionTester closure that takes a State argument _x_ and performs the
following:

The production _Assertion_ :: $ evaluates by returning an internal
AssertionTester closure that takes a State argument _x_ and performs the
following:

The production _Assertion_ :: \ B evaluates by returning an internal
AssertionTester closure that takes a State argument _x_ and performs the
following:

The production _Assertion_ :: \ B evaluates by returning an internal
AssertionTester closure that takes a State argument _x_ and performs the
following:

The production _Assertion_ :: ( ? = _Disjunction_ ) evaluates as
follows:

The production _Assertion_ :: ( ? ! _Disjunction_ ) evaluates as
follows:

1.  Evaluate _Disjunction_ to obtain a Matcher _m_.

2.  Return an internal Matcher closure that takes two arguments, a State
    _x_ and a Continuation _c_, and performs the following steps:

    1.  Let _d_ be a Continuation that always returns its State argument
          as a successful MatchResult.

    2.  Call _m_(_x_, _d_) and let _r_ be its result.

    3.  If _r_ isn't FAILURE, return FAILURE.

    4.  Call _c_(_x_) and return its result.

RUNTIME SEMANTICS: ISWORDCHAR ABSTRACT OPERATION

The abstract operation _IsWordChar_ takes an integer parameter _e_ and
performs the following:

  --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
  a   b   c   d   e   f   g   h   i   j   k   l   m   n   o   p   q   r   s   t   u   v   w   x   y   z
  A   B   C   D   E   F   G   H   I   J   K   L   M   N   O   P   Q   R   S   T   U   V   W   X   Y   Z
  0   1   2   3   4   5   6   7   8   9   _                                                           
  --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---

15.10.2.7 Quantifier

The production _Quantifier_ :: _QuantifierPrefix_ evaluates as follows:

The production _Quantifier_ :: _QuantifierPrefix_ ? evaluates as
follows:

The production _QuantifierPrefix_ :: * evaluates by returning the two
results 0 and ∞.

The production _QuantifierPrefix_ :: + evaluates by returning the two
results 1 and ∞.

The production _QuantifierPrefix_ :: ? evaluates by returning the two
results 0 and 1.

The production _QuantifierPrefix_ :: { _DecimalDigits_ } evaluates as
follows:

The production _QuantifierPrefix_ :: { _DecimalDigits_ , } evaluates as
follows:

The production _QuantifierPrefix_ :: { _DecimalDigits_ , _DecimalDigits_
} evaluates as follows:

15.10.2.8 Atom

The production _Atom_ :: _PatternCharacter_ evaluates as follows:

The production _Atom_ :: . evaluates as follows:

The production _Atom_ :: \ _AtomEscape_ evaluates by evaluating
_AtomEscape_ to obtain a Matcher and returning that Matcher.

The production _Atom_ :: _CharacterClass_ evaluates as follows:

The production _Atom_ :: ( _Disjunction_ ) evaluates as follows:

1.  Evaluate _Disjunction_ to obtain a Matcher _m_.

2.  Let _parenIndex_ be the number of left capturing parentheses in the
    entire regular expression that occur to the left of this production
    expansion's initial left parenthesis. This is the total number of
    times the _Atom_ :: ( _Disjunction _) production is expanded prior
    to this production's _Atom_ plus the total number of
    _Atom_ :: ( _Disjunction_ ) productions enclosing this _Atom_.

3.  Return an internal Matcher closure that takes two arguments, a State
    _x_ and a Continuation _c_, and performs the following steps:

    1.  Create an internal Continuation closure _d_ that takes one State
          argument _y_ and performs the following steps:

        1.  Let _cap_ be a fresh copy of _y_'s _captures_ internal
              array.

        2.  Let _xe_ be _x_'s _endIndex_.

        3.  Let _ye_ be _y_'s _endIndex_.

        4.  Let _s_ be a fresh String whose characters are the
              characters of _Input_ at positions _xe_ (inclusive)
              through _ye_ (exclusive).

        5.  Set _cap_[_parenIndex_+1] to _s_.

        6.  Let _z_ be the State (_ye_, _cap_).

        7.  Call _c_(_z_) and return its result.

    2.  Call _m_(_x_, _d_) and return its result.

The production _Atom_ :: ( ? : _Disjunction_ ) evaluates by evaluating
_Disjunction_ to obtain a Matcher and returning that Matcher.

RUNTIME SEMANTICS: CHARACTERSETMATCHER ABSTRACT OPERATION

The abstract operation _CharacterSetMatcher_ takes two arguments, a
CharSet _A_ and a Boolean flag _invert_, and performs the following:

a.  If there does not exist a member _a_ of set _A_ such that
      _Canonicalize_(_a_) is _cc_, return FAILURE.

a.  If there exists a member _a_ of set _A_ such that
      _Canonicalize_(_a_) is _cc_, return FAILURE.

RUNTIME SEMANTICS: CANONICALIZE ABSTRACT OPERATION

The abstract operation _Canonicalize_ takes a character parameter _ch_
and performs the following steps:

NOTE 1 Parentheses of the form ( _Disjunction_ ) serve both to group the
components of the _Disjunction_ pattern together and to save the result
of the match. The result can be used either in a backreference (\
followed by a nonzero decimal number), referenced in a replace String,
or returned as part of an array from the regular expression matching
internal procedure. To inhibit the capturing behaviour of parentheses,
use the form (?: _Disjunction_ ) instead.

NOTE 2 The form (?= _Disjunction_ ) specifies a zero-width positive
lookahead. In order for it to succeed, the pattern inside _Disjunction_
must match at the current position, but the current position is not
advanced before matching the sequel. If _Disjunction_ can match at the
current position in several ways, only the first one is tried. Unlike
other regular expression operators, there is no backtracking into a (?=
form (this unusual behaviour is inherited from Perl). This only matters
when the _Disjunction_ contains capturing parentheses and the sequel of
the pattern contains backreferences to those captures.

For example,

  /(?=(a+))/.exec("baaabac")

matches the empty String immediately after the first B and therefore
returns the array:

  ["", "aaa"]

To illustrate the lack of backtracking into the lookahead, consider:

  /(?=(a+))a*b\1/.exec("baaabac")

This expression returns

  ["aba", "a"]

and not:

  ["aaaba", "a"]

NOTE 3 The form (?! _Disjunction_ ) specifies a zero-width negative
lookahead. In order for it to succeed, the pattern inside _Disjunction_
must fail to match at the current position. The current position is not
advanced before matching the sequel. _Disjunction_ can contain capturing
parentheses, but backreferences to them only make sense from within
_Disjunction_ itself. Backreferences to these capturing parentheses from
elsewhere in the pattern always return UNDEFINED because the negative
lookahead must fail for the pattern to succeed. For example,

  /(.*?)a(?!(a+)b\2c)\2(.*)/.exec("baaabaac")

looks for an A not immediately followed by some positive number n of
A's, a B, another n A's (specified by the first \2) and a C. The second
\2 is outside the negative lookahead, so it matches against UNDEFINED
and therefore always succeeds. The whole expression returns the array:

  ["baaabaac", "ba", undefined, "abaac"]

In case-insignificant matches all characters are implicitly converted to
upper case immediately before they are compared. However, if converting
a character to upper case would expand that character into more than one
character (such as converting "SS" (\u00DF) into "SS"), then the
character is left as-is instead. The character is also left as-is if it
is not an ASCII character but converting it to upper case would make it
into an ASCII character. This prevents Unicode characters such as \u0131
and \u017F from matching regular expressions such as /[AZ]/I, which are
only intended to match ASCII letters. Furthermore, if these conversions
were allowed, then /[^\W]/I would match each of A, B, …, H, but not I or
S.

15.10.2.9 AtomEscape

The production _AtomEscape_ :: _DecimalEscape_ evaluates as follows:

The production _AtomEscape_ :: _CharacterEscape_ evaluates as follows:

1.  Evaluate _CharacterEscape_ to obtain a character _ch_.

2.  Let _A_ be a one-element CharSet containing the character _ch_.

3.  Call _CharacterSetMatcher_(_A_, FALSE) and return its Matcher
    result.

The production _AtomEscape_ :: _CharacterClassEscape_ evaluates as
follows:

1.  Evaluate _CharacterClassEscape_ to obtain a CharSet _A_.

2.  Call _CharacterSetMatcher_(_A_, FALSE) and return its Matcher
    result.

NOTE An escape sequence of the form \ followed by a nonzero decimal
number _n_ matches the result of the _n_th set of capturing parentheses
(see 15.10.2.11). It is an error if the regular expression has fewer
than _n_ capturing parentheses. If the regular expression has _n_ or
more capturing parentheses but the _n_th one is UNDEFINED because it has
not captured anything, then the backreference always succeeds.

15.10.2.10 CharacterEscape

The production _CharacterEscape_ :: _ControlEscape_ evaluates by
returning the character according to Table 34.

Table 34 — ControlEscape Character Values

  --------------- ----------- ---------------------- --------
  ControlEscape   Code Unit   Name                   Symbol
  T               \U0009      horizontal tab         <HT>
  N               \U000A      line feed (new line)   <LF>
  V               \U000B      vertical tab           <VT>
  F               \U000C      form feed              <FF>
  R               \U000D      carriage return        <CR>
  --------------- ----------- ---------------------- --------

The production _CharacterEscape_ :: C _ControlLetter_ evaluates as
follows:

1.  Let _ch_ be the character represented by _ControlLetter_.

2.  Let _i_ be _ch_'s code unit value.

3.  Let _j_ be the remainder of dividing _i_ by 32.

4.  Return the character whose code unit value is _j_.

The production _CharacterEscape_ :: _HexEscapeSequence_ evaluates by
evaluating the CV of the _HexEscapeSequence_ (see 7.8.6) and returning
its character result.

The production _CharacterEscape_ :: _UnicodeEscapeSequence_ evaluates by
evaluating the CV of the _UnicodeEscapeSequence_ (see 7.8.6) and
returning its character result.

The production _CharacterEscape_ :: _IdentityEscape_ evaluates by
returning the character represented by _IdentityEscape_.

15.10.2.11 DecimalEscape

The production _DecimalEscape_ :: _DecimalIntegerLiteral_ [lookahead ∉
_DecimalDigit_] evaluates as follows:

The definition of “the MV of _DecimalIntegerLiteral_” is in 7.8.3.

NOTE If \ is followed by a decimal number _n_ whose first digit is not
0, then the escape sequence is considered to be a backreference. It is
an error if _n_ is greater than the total number of left capturing
parentheses in the entire regular expression. \0 represents the <NUL>
character and cannot be followed by a decimal digit.

15.10.2.12 CharacterClassEscape

The production _CharacterClassEscape_ :: D evaluates by returning the
ten-element set of characters containing the characters 0 through 9
inclusive.

The production _CharacterClassEscape_ :: D evaluates by returning the
set of all characters not included in the set returned by
_CharacterClassEscape_ :: D.

The production _CharacterClassEscape_ :: S evaluates by returning the
set of characters containing the characters that are on the right-hand
side of the _WhiteSpace_ (7.2) or _LineTerminator_ (7.3) productions.

The production _CharacterClassEscape_ :: S evaluates by returning the
set of all characters not included in the set returned by
_CharacterClassEscape_ :: S.

The production _CharacterClassEscape_ :: W evaluates by returning the
set of characters containing the sixty-three characters:

  --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
  a   b   c   d   e   f   g   h   i   j   k   l   m   n   o   p   q   r   s   t   u   v   w   x   y   z
  A   B   C   D   E   F   G   H   I   J   K   L   M   N   O   P   Q   R   S   T   U   V   W   X   Y   Z
  0   1   2   3   4   5   6   7   8   9   _                                                           
  --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---

The production _CharacterClassEscape_ :: W evaluates by returning the
set of all characters not included in the set returned by
_CharacterClassEscape_ :: W.

15.10.2.13 CharacterClass

The production _CharacterClass_ :: [ [lookahead ∉ {^}] _ClassRanges_ ]
evaluates by evaluating _ClassRanges_ to obtain a CharSet and returning
that CharSet and the Boolean FALSE.

The production _CharacterClass_ :: [ ^ _ClassRanges_ ] evaluates by
evaluating _ClassRanges_ to obtain a CharSet and returning that CharSet
and the Boolean TRUE.

15.10.2.14 ClassRanges

The production _ClassRanges_ :: [empty] evaluates by returning the empty
CharSet.

The production _ClassRanges_ :: _NonemptyClassRanges_ evaluates by
evaluating _NonemptyClassRanges_ to obtain a CharSet and returning that
CharSet.

15.10.2.15 NonemptyClassRanges

The production _NonemptyClassRanges_ :: _ClassAtom_ evaluates by
evaluating _ClassAtom_ to obtain a CharSet and returning that CharSet.

The production _NonemptyClassRanges_ :: _ClassAtom_
_NonemptyClassRangesNoDash_ evaluates as follows:

1.  Evaluate _ClassAtom_ to obtain a CharSet _A_.

2.  Evaluate _NonemptyClassRangesNoDash_ to obtain a CharSet _B_.

3.  Return the union of CharSets _A_ and _B_.

The production _NonemptyClassRanges_ :: _ClassAtom_ - _ClassAtom_
_ClassRanges_ evaluates as follows:

1.  Evaluate the first _ClassAtom_ to obtain a CharSet _A_.

2.  Evaluate the second _ClassAtom_ to obtain a CharSet _B_.

3.  Evaluate _ClassRanges_ to obtain a CharSet _C_.

4.  Call _CharacterRange_(_A_, _B_) and let _D_ be the resulting
    CharSet.

5.  Return the union of CharSets _D_ and _C_.

RUNTIME SEMANTICS: CHARACTERRANGE ABSTRACT OPERATION

The abstract operation _CharacterRange_ takes two CharSet parameters _A_
and _B_ and performs the following:

15.10.2.16 NonemptyClassRangesNoDash

The production _NonemptyClassRangesNoDash_ :: _ClassAtom_ evaluates by
evaluating _ClassAtom_ to obtain a CharSet and returning that CharSet.

The production _NonemptyClassRangesNoDash_ :: _ClassAtomNoDash_
_NonemptyClassRangesNoDash_ evaluates as follows:

The production _NonemptyClassRangesNoDash_ :: _ClassAtomNoDash_ -
_ClassAtom_ _ClassRanges_ evaluates as follows:

1.  Evaluate _ClassAtomNoDash_ to obtain a CharSet _A_.

2.  Evaluate _ClassAtom_ to obtain a CharSet _B_.

3.  Evaluate _ClassRanges_ to obtain a CharSet _C_.

4.  Call _CharacterRange_(_A_, _B_) and let _D_ be the resulting
    CharSet.

5.  Return the union of CharSets _D_ and _C_.

NOTE 1 _ClassRanges_ can expand into single _ClassAtoms_ and/or ranges
of two _ClassAtoms_ separated by dashes. In the latter case the
_ClassRanges_ includes all characters between the first _ClassAtom_ and
the second _ClassAtom_, inclusive; an error occurs if either _ClassAtom_
does not represent a single character (for example, if one is \W) or if
the first _ClassAtom's_ code unit value is greater than the second
_ClassAtom's_ code unit value.

NOTE 2 Even if the pattern ignores case, the case of the two ends of a
range is significant in determining which characters belong to the
range. Thus, for example, the pattern /[E-F]/I matches only the letters
E, F, E, and F, while the pattern /[E-F]/I matches all upper and
lower-case ASCII letters as well as the symbols [, \, ], ^, _, and `.

NOTE 3 A - character can be treated literally or it can denote a range.
It is treated literally if it is the first or last character of
_ClassRanges_, the beginning or end limit of a range specification, or
immediately follows a range specification.

15.10.2.17 ClassAtom

The production _ClassAtom_ :: - evaluates by returning the CharSet
containing the one character -.

The production _ClassAtom_ :: _ClassAtomNoDash_ evaluates by evaluating
_ClassAtomNoDash_ to obtain a CharSet and returning that CharSet.

15.10.2.18 ClassAtomNoDash

The production _ClassAtomNoDash_ :: _SourceCharacter_ BUT NOT ONE OF \
OR ] OR - evaluates by returning a one-element CharSet containing the
character represented by _SourceCharacter_.

The production _ClassAtomNoDash_ :: \ _ClassEscape_ evaluates by
evaluating _ClassEscape_ to obtain a CharSet and returning that CharSet.

15.10.2.19 ClassEscape

The production _ClassEscape_ :: _DecimalEscape_ evaluates as follows:

The production _ClassEscape_ :: B evaluates by returning the CharSet
containing the one character <BS> (Unicode value 0008).

The production _ClassEscape_ :: _CharacterEscape_ evaluates by
evaluating _CharacterEscape_ to obtain a character and returning a
one-element CharSet containing that character.

The production _ClassEscape_ :: _CharacterClassEscape_ evaluates by
evaluating _CharacterClassEscape_ to obtain a CharSet and returning that
CharSet.

NOTE A _ClassAtom_ can use any of the escape sequences that are allowed
in the rest of the regular expression except for \B, \B, and
backreferences. Inside a _CharacterClass_, \B means the backspace
character, while \B and backreferences raise errors. Using a
backreference inside a _ClassAtom_ causes an error.

15.10.3 The RegExp Constructor Called as a Function

When REGEXP is called as a function rather than as a constructor, it
creates and initialises a new RegExp object. Thus the function call
REGEXP(…) is equivalent to the object creation expression NEW REGEXP(…)
with the same arguments. However, if the THIS value value passed in the
call is an Object with an [[RegExpMatcher]] internal data property whose
value is UNDEFINED, it initializes the THIS value using the argument
values. This permits REGEXP to be used both as factory method and to
perform constructor instance initialization.

REGEXP may be subclassed and subclass constructors may perform a super
invocation of the REGEXP constructor to initialize subclass instances.

15.10.3.1 RegExp(pattern, flags)

The following steps are taken:

NOTE If pattern is supplied using a _StringLiteral_, the usual escape
sequence substitutions are performed before the String is processed by
RegExp. If pattern must contain an escape sequence to be recognised by
RegExp, any backslash \ characters must be escaped within the
_StringLiteral_ to prevent them being removed when the contents of the
_StringLiteral_ are formed.

RUNTIME SEMANTICS: REGEXPALLOC ABSTRACT OPERATION

When the abstract operation RegExpAlloc with argument _constructor_ is
called, the following steps are taken:

1.  Assert: _constructor_ is a constructable function.

2.  Let _obj_ be the result of calling
    OrdinaryCreateFromConstructor(_constructor_, "%REGEXPPROTOTYPE%", (
    [[RegExpMatcher]], [[OriginalSource]], [[OriginalFlags]])).

3.  Let _status_ be the result of DefinePropertyOrThrow(_obj_,
    "LASTINDEX", PropertyDescriptor {[[Writable]]: TRUE,
    [[Enumberable]]: FALSE, [[Configurable]]: FALSE}).

4.  ReturnIfAbrupt(_status_).

5.  Return _obj_.

NOTE [[RegExpMatcher]] is initially assigned the value UNDEFINED as a
flag to indicate that the instance has not yet been initialized by the
REGEXP constructor. This flag value is never directly exposed to
ECMAScript code; hence implementation may choose to encode the flag in
some other manner.

RUNTIME SEMANTICS: REGEXPINITIALIZE ABSTRACT OPERATION

When the abstract operation RegExpInitialize with arguments _obj,_
_pattern_, and _flags_ is called, the following steps are taken:

1.  If _pattern_ is UNDEFINED, then let _P_ be the empty String.

2.  Else, let _P_ be ToString(_pattern_).

3.  ReturnIfAbrupt(_P_).

4.  If _flags_ is UNDEFINED, then let _F_ be the empty String.

5.  Else, let _F_ be ToString(_flags_).

6.  ReturnIfAbrupt(_F_).

7.  8.  If _F_ contains any character other than "G", "I", "M", "U", or
    "Y" or if it contains the same character more than once, then throw
    a SYNTAXERROR exception.

9.  Parse _P_ interpreted as UTF-16 encoded Unicode characters using the
    grammars in 15.10.1 for the goal symbol _Pattern_. Throw a
    SYNTAXERROR exception if _P_ did not conform to the grammar or if
    all characters of _P_ where not matched by the parse.

10. Set _obj’s_ [[RegExpMatcher]] internal data property to the internal
    procedure obtained by evaluating ("compiling") the step 3’s parse of
    _P_ and applying the semantics provided in 15.10.2.

11. Set the value of _obj’s_ [[OriginalSource]] internal data property
    to _P_.

12. Set the value of _obj’s_ [[OriginalFlags]] internal data property to
    _F_.

13. 14. Let _putStatus_ be the result of Put(_obj_, "LASTINDEX", 0,
    TRUE).

15. ReturnIfAbrupt(_putStatus_).

16. Return _obj_.

RUNTIME SEMANTICS: REGEXPCREATE ABSTRACT OPERATION

When the abstract operation RegExpCreate with arguments _P_ and _F_ is
called, the following steps are taken:

1.  2.  Let _obj_ be the result of calling the abstract operation
    RegExpAlloc with argument %RegExp%.

3.  ReturnIfAbrupt(_obj_).

4.  Return the result of the abstract operation RegExpInitialize with
    arguments _obj,_ _P_, and _F_ .

RUNTIME SEMANTICS: ESCAPEREGEXPPATTERN ABSTRACT OPERATION

When the abstract operation EscapeRegExpPattern with arguments _P_ and
_F_ is called, the following occurs:

Let _S_ be a String in the form of a _Pattern_ equivalent to _P_
interpreted as UTF-16 encoded Unicode characters, in which certain
characters are escaped as described below. _S_ may or may not be
identical to _P_ or _pattern_; however, the internal procedure that
would result from evaluating _S_ as a _Pattern_ must behave identically
to the internal procedure given by the constructed object's
[[RegExpMatcher]] internal data property. Separate calls to this
abstract operation using the same values for _P_ and _F_ must produce
identical results.

The characters / occurring in the pattern shall be escaped in _S_ as
necessary to ensure that the String value formed by concatenating the
Strings "/", _S_, "/", and _F_ can be parsed (in an appropriate lexical
context) as a _RegularExpressionLiteral_ that behaves identically to the
constructed regular expression. For example, if _P_ is "/", then _S_
could be "\/" or "\U002F", among other possibilities, but not "/",
because /// followed by _F_ would be parsed as a _SingleLineComment_
rather than a _RegularExpressionLiteral_. If _P_ is the empty String,
this specification can be met by letting _S_ be "(?:)".

Return _S_.

15.10.4 The RegExp Constructor

When REGEXP is called as part of a NEW expression, it is a constructor:
it initialises the newly created object.

15.10.4.1 new RegExp(... args)

REGEXP called as part of a new expression with argument list _args_ it
performs the following steps:

1.  Let _F_ be the REGEXP function object on which the NEW operator was
    applied.

2.  Let _argumentsList_ be the _argumentsList_ argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of OrdinaryConstruct (_F_, _argumentsList_).

If REGEXP is implemented as an ordinary function object, its
[[Construct]] internal method will perform the above steps.

15.10.5 Properties of the RegExp Constructor

The value of the [[Prototype]] internal data property of the RegExp
constructor is the standard built-in Function prototype object (15.3.3).

Besides the LENGTH property (whose value is 2), the RegExp constructor
has the following properties:

15.10.5.1 RegExp.prototype

The initial value of REGEXP.PROTOTYPE is the RegExp prototype object
(15.10.6).

This property shall have the attributes { [[Writable]]: FALSE,
[[Enumerable]]: FALSE, [[Configurable]]: FALSE }.

15.10.5.2 RegExp[ @@create ] ( )

The @@create method of an object _F_ performs the following:

1.  Return the result of calling the abstract operation RegExpAlloc with
    argument _F_.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

15.10.6 Properties of the RegExp Prototype Object

The RegExp prototype object is an ordinary object. It is not a RegExp
instance and does not have a [[RegExpMatcher]] internal data property or
any of the other internal data properties of RegExp instance objects.

The value of the [[Prototype]] internal data property of the RegExp
prototype object is the standard built-in Object prototype object
(15.2.4).

The RegExp prototype object does not have a VALUEOF property of its own;
however, it inherits the VALUEOF property from the Object prototype
object.

15.10.6.1 RegExp.prototype.constructor

The initial value of REGEXP.PROTOTYPE.CONSTRUCTOR is the standard
built-in REGEXP constructor.

15.10.6.2 RegExp.prototype.exec(string)

Performs a regular expression match of _string_ against the regular
expression and returns an Array object containing the results of the
match, or NULL if _string_ did not match.

The String ToString(_string_) is searched for an occurrence of the
regular expression pattern as follows:

1.  Let _R_ be the THIS value.

2.  If Type(_R)_ is not Object, then throw a TYPEERROR exception.

3.  If _R_ does not have a [[RegExpMatcher]] internal data property,
    then throw a TYPEERROR exception.

4.  If the value of _R’s_ [[RegExpMatcher]] internal data property is
    UNDEFINED, then throw a TYPEERROR exception.

5.  6.  7.  Let _S_ be the value of ToString(_string_)

8.  ReturnIfAbrupt(_S_).

9.  Return the result of the RegExpExec abstract operation with
    arguments _R_ and _S_.

RUNTIME SEMANTICS: REGEXPEXEC ABSTRACT OPERATION

The abstract operation RegExpExec with arguments _R_ (an object) and _S_
(a string) performs the following steps:

1.  Assert: _R_ is an initialized RegExp instance.

2.  Let _matcher_ be the value of _R’s_ [[RegExpMatcher]] internal data
    property.

3.  Let _length_ be the length of _S_.

4.  Let _lastIndex_ be the result of Get(_R_,"LASTINDEX").

5.  Let _i_ be the value of ToInteger(_lastIndex_).

6.  ReturnIfAbrupt(_i_).

7.  Let _global_ be the result of ToBoolean(Get(_R_, "GLOBAL")).

8.  ReturnIfAbrupt(_global_).

9.  If _global_ is FALSE, then let _i_ = 0.

10. Let _matchSucceeded_ be FALSE.

11. Repeat, while _matchSucceeded_ is FALSE

    a.  If _i_ < 0 or _i_ > _length_, then

        i.  Let _putStatus_ be the result of Put(_R_, "LASTINDEX", 0,
            TRUE).

        ii. ReturnIfAbrupt(_putStatus_).

        iii. Return NULL.

    b.  Let _r_ be the result of calling the _matcher_ with arguments
        _S_ and _i_.

    c.  If _r_ is FAILURE, then

        i.  Let _i_ = _i_+1.

    d.  else

        i.  Assert: _r_ is a State.

        ii. Set _matchSucceeded_ to TRUE.

12. Let _e_ be _r_'s _endIndex_ value.

13. If _global_ is TRUE,

    a.  Let _putStatus_ be the result of Put(_R_, "LASTINDEX", _e_,
        TRUE).

    b.  ReturnIfAbrupt(_putStatus_).

14. Let _n_ be the length of _r_'s _captures_ array. (This is the same
    value as 15.10.2.1's _NcapturingParens_.)

15. Let _A_ be the result of the abstract operation ArrayCreate with
    argument 0.

16. Let _matchIndex_ be _i_.

17. Assert: The following [DefineOwnProperty]] calls will not result in
    an abrupt completion.

18. Call the [[DefineOwnProperty]] internal method of _A_ with arguments
    "INDEX" and Property Descriptor {[[Value]]: _matchIndex_,
    [[Writable]]: TRUE, [[Enumerable]]: TRUE, [[Configurable]]: TRUE}.

19. Call the [[DefineOwnProperty]] internal method of _A_ with arguments
    "INPUT" and Property Descriptor {[[Value]]: _S_, [[Writable]]: TRUE,
    [[Enumerable]]: TRUE, [[Configurable]]: TRUE}.

20. Call the [[DefineOwnProperty]] internal method of _A_ with arguments
    "LENGTH" and Property Descriptor {[[Value]]: _n_ + 1}.

21. Let _matchedSubstr_ be the matched substring (i.e. the portion of
    _S_ between offset _i_ inclusive and offset _e_ exclusive).

22. Call the [[DefineOwnProperty]] internal method of _A_ with arguments
    "0" and Property Descriptor {[[Value]]: _matchedSubstr_,
    [[Writable]]: TRUE, [[Enumerable]]: TRUE, [[Configurable]]: TRUE}.

23. For each integer _i_ such that _i_ > 0 and _i_ ≤ _n

    a.  Let _captureI_ be _i_^th^ element of _r_'s _captures_ array.

    b.  Call the [[DefineOwnProperty]] internal method of _A_ with
        arguments ToString(_i_) and Property Descriptor {[[Value]]:
        _captureI_, [[Writable]]: TRUE, [[Enumerable]]: TRUE,
        [[Configurable]]: TRUE}.

24. Return _A_.

15.10.6.3 get RegExp.prototype.global 

REGEXP.PROTOTYPE.GLOBAL is an accessor property whose set accessor
function is UNDEFINED. Its get accessor function performs the following
steps:

1.  Let _R_ be the THIS value.

2.  If Type(_R)_ is not Object, then throw a TYPEERROR exception.

3.  If _R_ does not have a [[OriginalFlags]] internal data property
    throw a TYPEERROR exception.

4.  Let _flags_ be the value of _R’s_ [[OriginalFlags]] internal data
    property.

5.  If _flags_ is UNDEFINED, then throw a TYPEERROR exception.

6.  If _flags_ contains the character "G", then return TRUE.

7.  Return FALSE.

15.10.6.4 get RegExp.prototype.ignoreCase 

REGEXP.PROTOTYPE.IGNORECASE is an accessor property whose set accessor
function is UNDEFINED. Its get accessor function performs the following
steps:

1.  Let _R_ be the THIS value.

2.  If Type(_R)_ is not Object, then throw a TYPEERROR exception.

3.  If _R_ does not have a [[OriginalFlags]] internal data property
    throw a TYPEERROR exception.

4.  Let _flags_ be the value of _R’s_ [[OriginalFlags]] internal data
    property.

5.  If _flags_ is UNDEFINED, then throw a TYPEERROR exception.

6.  If _flags_ contains the character "I", then return TRUE.

7.  Return FALSE.

15.10.6.5 get RegExp.prototype.multiline 

REGEXP.PROTOTYPE.MULTILINE is an accessor property whose set accessor
function is UNDEFINED. Its get accessor function performs the following
steps:

1.  Let _R_ be the THIS value.

2.  If Type(_R)_ is not Object, then throw a TYPEERROR exception.

3.  If _R_ does not have a [[OriginalFlags]] internal data property
    throw a TYPEERROR exception.

4.  Let _flags_ be the value of _R’s_ [[OriginalFlags]] internal data
    property.

5.  If _flags_ is UNDEFINED, then throw a TYPEERROR exception.

6.  If _flags_ contains the character "M", then return TRUE.

7.  Return FALSE.

15.10.6.6 get RegExp.prototype.source 

REGEXP.PROTOTYPE.SOURCE is an accessor property whose set accessor
function is UNDEFINED. Its get accessor function performs the following
steps:

1.  Let _R_ be the THIS value.

2.  If Type(_R)_ is not Object, then throw a TYPEERROR exception.

3.  If _R_ does not have a [[OriginalSource]] internal data property
    throw a TYPEERROR exception.

4.  If _R_ does not have a [[OriginalFlags]] internal data property
    throw a TYPEERROR exception.

5.  Let _src_ be the value of _R’s_ [[OriginalSource]] internal data
    property.

6.  Let _flags_ be the value of _R’s_ [[OriginalFlags]] internal data
    property.

7.  If either _src_ or _flags_ is UNDEFINED, then throw a TYPEERROR
    exception.

8.  Return the result of the abstract operation EscapeRegExpPattern with
    arguments _src_ and _flags_.

15.10.6.7 get RegExp.prototype.sticky 

REGEXP.PROTOTYPE.STICKY is an accessor property whose set accessor
function is UNDEFINED. Its get accessor function performs the following
steps:

1.  Let _R_ be the THIS value.

2.  If Type(_R)_ is not Object, then throw a TYPEERROR exception.

3.  If _R_ does not have a [[OriginalFlags]] internal data property
    throw a TYPEERROR exception.

4.  Let _flags_ be the value of _R’s_ [[OriginalFlags]] internal data
    property.

5.  If _flags_ is UNDEFINED, then throw a TYPEERROR exception.

6.  If _flags_ contains the character "Y", then return TRUE.

7.  Return FALSE.

15.10.6.8 RegExp.prototype.test(string)

The following steps are taken:

15.10.6.9 get RegExp.prototype.unicode 

REGEXP.PROTOTYPE.UNICODE is an accessor property whose set accessor
function is UNDEFINED. Its get accessor function performs the following
steps:

1.  Let _R_ be the THIS value.

2.  If Type(_R)_ is not Object, then throw a TYPEERROR exception.

3.  If _R_ does not have a [[OriginalFlags]] internal data property
    throw a TYPEERROR exception.

4.  Let _flags_ be the value of _R’s_ [[OriginalFlags]] internal data
    property.

5.  If _flags_ is UNDEFINED, then throw a TYPEERROR exception.

6.  If _flags_ contains the character "U", then return TRUE.

7.  Return FALSE.

15.10.6.10 RegExp.prototype.toString()

1.  Let _R_ be the THIS value.

2.  If Type(_R)_ is not Object, then throw a TYPEERROR exception.

3.  If _R_ does not have a [[RegExpMatcher]] internal data property,
    then throw a TYPEERROR exception.

4.  If the value of _R’s_ [[RegExpMatcher]] internal data property is
    UNDEFINED, then throw a TYPEERROR exception.

5.  Let _pattern_ be the result of ToString(Get(_R_, "SOURCE")).

6.  ReturnIfAbrupt(_pattern_).

7.  Let _result_ be the String value formed by concatenating "/",
    _pattern_, and "/".

8.  Let _global_ be the result of ToBoolean(Get(_R_, "GLOBAL")).

9.  ReturnIfAbrupt(_global_).

10. If _global_ is TRUE, then append "G" as the last character of
    _result_.

11. Let _ignoreCase_ be the result of ToBoolean(Get(_R_, "IGNORECASE")).

12. ReturnIfAbrupt(_ignoreCase_).

13. If _ignoreCase_ is TRUE, then append "I" as the last character of
    _result_.

14. Let _multiline_ be the result of ToBoolean(Get(_R_, "MULTILINE")).

15. ReturnIfAbrupt(_multiline_).

16. If _multiline_ is TRUE, then append "M" as the last character of
    _result_.

17. Let _unicode_ be the result of ToBoolean(Get(_R_, "UNICODE")).

18. ReturnIfAbrupt(_unicode_).

19. If _unicode_ is TRUE, then append "U" as the last character of
    _result_.

20. Let _sticky_ be the result of ToBoolean(Get(_R_, "STICKY")).

21. ReturnIfAbrupt(_sticky_).

22. If _sticky_ is TRUE, then append "Y" as the last character of
    _result_.

23. Return _result_.

NOTE The returned String has the form of a _RegularExpressionLiteral_
that evaluates to another RegExp object with the same behaviour as this
object.

15.10.6.11 RegExp.prototype.match (string)

When the MATCH method is called with argument _string_, the following
steps are taken:

1.  Let _rx_ be the THIS value.

2.  If Type(_rx)_ is not Object, then throw a TYPEERROR exception.

3.  If _rx_ does not have a [[RegExpMatcher]] internal data property,
    then throw a TYPEERROR exception.

4.  If the value of _rx’s_ [[RegExpMatcher]] internal data property is
    UNDEFINED, then throw a TYPEERROR exception.

5.  Let _S_ be the value of ToString(_string_)

6.  ReturnIfAbrupt(_S_).

7.  Let _global_ be the result of ToBoolean(Get(_rx_, "GLOBAL")).

8.  ReturnIfAbrupt(_global_).

9.  If _global_ is not TRUE, then

    a.  Return the result of calling the abstract operation RegExpExec
        (see 15.10.6.2) with arguments _rx_ and _S_.

10. Else _global_ is TRUE,

    a.  Let _putStatus_ be the result of Put(_rx_, "LASTINDEX", 0,
        TRUE).

    b.  ReturnIfAbrupt(_putStatus_).

    c.  Let _A_ be the result of the abstract operation ArrayCreate with
        argument 0.

    d.  Let _previousLastIndex_ be 0.

    e.  Let _n_ be 0.

    f.  Let _lastMatch_ be TRUE.

    g.  Repeat, while _lastMatch_ is TRUE

        i.  Let _result_ be the result of the abstract operation
            RegExpExec with arguments _rx_ and _S_.

        ii. ReturnIfAbrupt(_result_).

        iii. If _result_ is NULL, then set _lastMatch_ to FALSE.

        iv. Else _result_ is not NULL,

            1.  Let _thisIndex_ be the result of ToInteger(Get(_rx_,
                "LASTINDEX")).

            2.  ReturnIfAbrupt(_thisIndex_).

            3.  If _thisIndex_ = _previousLastIndex_ then

                a.  Let _putStatus_ be the result of Put(_rx_,
                    "LASTINDEX", _thisIndex_+1, TRUE).

                b.  ReturnIfAbrupt(_putStatus_).

                c.  Set _previousLastIndex_ to _thisIndex_+1.

            4.  Else,

                a.  Set _previousLastIndex_ to _thisIndex_.

            5.  Let _matchStr_ be the result of Get(_result_, "0").

            6.  Let _defineStatus_ be the result of
                DefinePropertyOrThrow(_A_, ToString(_n_), Property
                Descriptor {[[Value]]: _matchStr_, [[Writable]]: TRUE,
                [[Enumerable]]: TRUE, [[configurable]]: TRUE}).

            7.  ReturnIfAbrupt(_defineStatus_).

            8.  Increment _n_.

    h.  If _n_ = 0, then return NULL.

    i.  Return _A_.

15.10.6.12 RegExp.prototype.replace (S, replaceValue)

When the REPLACE method is called with arguments _S_ and _replaceValue_
the following steps are taken:

TODO: need tol finish this and have it make use of
GETREPLACESUBSTITUTION operation in 15.5.4.11

1.  Let _rx_ be the THIS value.

2.  If Type(_rx)_ is not Object, then throw a TYPEERROR exception.

3.  If _rx_ does not have a [[RegExpMatcher]] internal data property,
    then throw a TYPEERROR exception.

4.  If the value of _rx’s_ [[RegExpMatcher]] internal data property is
    UNDEFINED, then throw a TYPEERROR exception.

5.  Let _string_ be ToString(_S_).

6.  ReturnIfAbrupt(_string_).

7.  If _searchValue_.global is FALSE, then search _string_ for the first
    match of the regular expression _searchValue_. If
    _searchValue_.global is TRUE, then search _string_ for all matches
    of the regular expression _searchValue_. Do the search in the same
    manner as in REGEXP.PROTOTYPE.MATCH, including the update of
    _searchValue_.LASTINDEX. Let _m_ be the number of left capturing
    parentheses in _searchValue_ (using _NcapturingParens_ as specified
    in 15.10.2.1).

8.  If _replaceValue_ is a function, then

    a.  For each matched substring, call the function with the following
        _m_ + 3 arguments. Argument 1 is the substring that matched. If
        _searchValue_ is a regular expression, the next _m_ arguments
        are all of the captures in the MatchResult (see 15.10.2.1).
        Argument _m_ + 2 is the offset within _string_ where the match
        occurred, and argument _m_ + 3 is _string_. The result is a
        String value derived from the original input by replacing each
        matched substring with the corresponding return value of the
        function call, converted to a String if need be.

9.  Else,

Let _newstring_ denote the result of converting _replaceValue_ to a
String. The result is a String value derived from the original input
String by replacing each matched substring with a String derived from
_newstring_ by replacing elements in _newstring_ by replacement text as
specified in

Table 33

a.  . These $ replacements are done left-to-right, and, once such a
    replacement is performed, the new replacement text is not subject to
    further replacements. For example, "$1,$2".REPLACE(/(\$(\D))/G,
    "$$1-$1$2") returns "$1-$11,$1-$22". A $ in _newstring_ that does
    not match any of the forms below is left as is.

15.10.6.13 RegExp.prototype.search (S)

When the search method is called with argument _S_, the following steps
are taken:

1.  Let _rx_ be the THIS value.

2.  If Type(_rx)_ is not Object, then throw a TYPEERROR exception.

3.  If _rx_ does not have a [[RegExpMatcher]] internal data property,
    then throw a TYPEERROR exception.

4.  If the value of _rx’s_ [[RegExpMatcher]] internal data property is
    UNDEFINED, then throw a TYPEERROR exception.

5.  Let _string_ be ToString(_S_).

6.  ReturnIfAbrupt(_string_).

7.  Search the value _string_ from its beginning for an occurrence of
    the regular expression pattern _rx_. Let _result_ be a Number
    indicating the offset within _string_ where the pattern matched, or
    –1 if there was no match. If an abrupt completion occurs during the
    search, _result_ is that Completion Record. The LASTINDEX and GLOBAL
    properties of _regexp_ are ignored when performing the search. The
    LASTINDEX property of _regexp_ is left unchanged.

8.  Return _result_.

15.10.6.14 RegExp.prototype.split (string, limit)

Returns an Array object into which substrings of the result of
converting _string_ to a String have been stored. The substrings are
determined by searching from left to right for matches of the THIS value
regular expression; these occurrences are not part of any substring in
the returned array, but serve to divide up the String value.

The this value may be an empty regular expression or a regular
expression that can match an empty String. In this case, regular
expression does not match the empty substring at the beginning or end of
the input String, nor does it match the empty substring at the end of
the previous separator match. (For example, if the regular expression
matches the empty String, the String is split up into individual code
unit elements; the length of the result array equals the length of the
String, and each substring contains one code unit.) Only the first match
at a given position of the THIS String is considered, even if
backtracking could yield a non-empty-substring match at that position.
(For example, /A*?/.SPLIT("AB") evaluates to the array ["A","B"], while
/A*/.SPLIT("AB") evaluates to the array["","B"].)

If the _string_ is (or converts to) the empty String, the result depends
on whether the regular expression can match the empty String. If it can,
the result array contains no elements. Otherwise, the result array
contains one element, which is the empty String.

If the regular expression that contains capturing parentheses, then each
time _separator_ is matched the results (including any UNDEFINED
results) of the capturing parentheses are spliced into the output array.
For example,

  /<(\/)?([^<>]+)>/.SPLIT("A<B>BOLD</B>AND<CODE>CODED</CODE>")

evaluates to the array

  ["A", UNDEFINED, "B", "BOLD", "/", "B", "AND", UNDEFINED,
   "CODE", "CODED", "/", "CODE", ""]

If _limit_ is not UNDEFINED, then the output array is truncated so that
it contains no more than _limit_ elements.

When the SPLIT method is called, the following steps are taken:

1.  Let _rx_ be the THIS value.

2.  If Type(_rx)_ is not Object, then throw a TYPEERROR exception.

3.  If _rx_ does not have a [[RegExpMatcher]] internal data property,
    then throw a TYPEERROR exception.

4.  If the value of _rx’s_ [[RegExpMatcher]] internal data property is
    UNDEFINED, then throw a TYPEERROR exception.

5.  Let _matcher_ be the value of _rx’s_ [[RegExpMatcher]] internal data
    property.

6.  Let _S_ be ToString(_string_).

7.  ReturnIfAbrupt(_S_).

8.  Let _A_ be the result of the abstract operation ArrayCreate with
    argument 0.

9.  ReturnIfAbrupt(_A_).

10. Let _lengthA_ be 0.

11. If _limit_ is UNDEFINED, let _lim_ = 2^32^–1; else let _lim_ =
    ToUint32(_limit_).

12. Let _s_ be the number of elements in _S_.

13. Let _p_ = 0.

14. If _lim_ = 0, return _A_.

15. If _s_ = 0, then

    a.  Let _z_ be the result of calling the _matcher_ with arguments
        _S_ and 0.

    b.  ReturnIfAbrupt(_z_).

    c.  If _z_ is not FAILURE, return _A_.

    d.  Call the [[DefineOwnProperty]] internal method of _A_ with
        arguments "0" and Property Descriptor {[[Value]]: _S_,
        [[Writable]]: TRUE, [[Enumerable]]: TRUE, [[Configurable]]:
        TRUE}.

    e.  Assert: the previous step will never result in an abrupt
        completion.

    f.  Return _A_.

16. Let _q_ = _p_.

17. Repeat, while _q_ ≠ _s

    a.  Let _z_ be the result of calling the _matcher_ with arguments
        _S_ and _q_

    b.  ReturnIfAbrupt(_z_).

    c.  If _z_ is FAILURE, then let _q_ = _q_+1.

    d.  Else _z_ is not FAILURE,

        i.  _z_ must be a State. Let _e_ be _z_'s _endIndex_ and let
            _cap_ be _z_'s _captures_ array.

        ii. If _e_ = _p_, then let _q_ = _q_+1.

        iii. Else _e_ ≠ _p_,

            1.  Let _T_ be a String value equal to the substring of _S_
                consisting of the elements at positions _p_ (inclusive)
                through _q_ (exclusive).

            2.  Call the [[DefineOwnProperty]] internal method of _A_
                with arguments ToString(_lengthA_) and Property
                Descriptor {[[Value]]: _T_, [[Writable]]: TRUE,
                [[Enumerable]]: TRUE, [[Configurable]]: TRUE}.

            3.  Assert: the previous step will never result in an abrupt
                completion.

            4.  Increment _lengthA_ by 1.

            5.  If _lengthA_ = _lim_, return _A_.

            6.  Let _p_ = _e_.

            7.  Let _i_ = 0.

            8.  Repeat, while _i_ is not equal to the number of elements
                in _cap_.

                a.  Let _i_ = _i_+1.

                b.  Call the [[DefineOwnProperty]] internal method of
                    _A_ with arguments ToString(_lengthA_) and Property
                    Descriptor {[[Value]]: _cap_[_i_], [[Writable]]:
                    TRUE, [[Enumerable]]: TRUE, [[Configurable]]: TRUE}.

                c.  Assert: the previous step will never result in an
                    abrupt completion.

                d.  Increment _lengthA_ by 1.

                e.  If _lengthA_ = _lim_, return _A_.

            9.  Let _q_ = _p_.

18. Let _T_ be a String value equal to the substring of _S_ consisting
    of the elements at positions _p_ (inclusive) through _s_
    (exclusive).

19. Call the [[DefineOwnProperty]] internal method of _A_ with arguments
    ToString(_lengthA_) and Property Descriptor {[[Value]]: _T_,
    [[Writable]]: TRUE, [[Enumerable]]: TRUE, [[Configurable]]: TRUE}.

20. Assert: the previous step will never result in an abrupt completion.

21. Return _A_.

The LENGTH property of the SPLIT method is 2.

NOTE 1 The SPLIT method ignores the value of the GLOBAL property of this
RegExp object.

15.10.6.15 RegExp.prototype.@@isRegExp 

The initial value of the @@isRegExp property is TRUE.

15.10.7 Properties of RegExp Instances

RegExp instances are ordinary objects that inherit properties from the
RegExp prototype object. RegExp instances have internal data properties
[[RegExpMatcher]], [[OriginalSource]], and [[OriginalFlags]].

The value of the [[RegExpMatcher]] internal data property is an
implementation dependent representation of the _Pattern_ of the RegExp
object.

RegExp instances also have the following properties.

15.10.7.1 lastIndex

The value of the LASTINDEX property specifies the String position at
which to start the next match. It is coerced to an integer when used
(see 15.10.6.2). This property shall have the attributes { [[Writable]]:
TRUE, [[Enumerable]]: FALSE, [[Configurable]]: FALSE }.

NOTE Unlike the other standard built-in properties of RegExp instances,
LASTINDEX is writable.


15.11 Error Objects

Instances of Error objects are thrown as exceptions when runtime errors
occur. The Error objects may also serve as base objects for user-defined
exception classes.

15.11.1 The Error Constructor Called as a Function

When ERROR is called as a function rather than as a constructor, it
creates and initialises a new Error object. Thus the function call
ERROR(…) is generally equivalent to the object creation expression NEW
ERROR(…) with the same arguments. However, if the THIS value value
passed in the call is an Object with an uninitialized [[ErrorData]]
internal data property, it initializes the THIS value using the argument
value rather than creating a new object. This permits ERROR to be used
both as factory method and to perform constructor instance
initialization.

ERROR may be subclassed and subclass constructors may perform a super
invocation of the ERROR constructor to initialize subclass instances.

15.11.1.1 Error (message)

The following steps are taken:

1.  Let _func_ be this ERROR function object.

2.  Let _O_ be the THIS value.

3.  If Type(_O_) is not Object or Type(_O_) is Object and _O_ does not
    have an [[ErrorData]] internal data property or Type(_O_) is Object
    and _O_ has an [[ErrorData]] internal data property and the value of
    [[ErrorData]] is not UNDEFINED, then

    a.  Let _O_ be the result of calling
        OrdinaryCreateFromConstructor(_func_, "%ERRORPROTOTYPE%",
        ( [[ErrorData]]) ).

    b.  ReturnIfAbrupt(_O_).

4.  Assert: Type(_O_) is Object.

5.  Set the value of _O’s_ [[ErrorData]] internal data property to any
    value other than UNDEFINED.

6.  7.  If _message_ is not UNDEFINED, then

    a.  Let _msg_ be ToString(_message_).

    b.  ReturnIfAbrupt(_msg_).

    c.  d.  Let _msgDesc_ be the Property Descriptor.
        {[[Value]]: _msg_, [[Writable]]: TRUE, [[Enumerable]]: FALSE,
        [[Configurable]]: TRUE}.

    e.  Let _status_ be the result of calling the [[DefineOwnProperty]]
        internal method of _O_ passing "MESSAGE" and _msgDesc_ as
        arguments.

    f.  ReturnIfAbrupt(_status_).

    g.  If _status_ is FALSE, then throw a TYPEERROR exception.

8.  Return _O_.

15.11.2 The Error Constructor

When ERROR called as part of a NEW expression, it is a constructor; it
initialises the newly created object.

15.11.2.1 new Error(... args)

When ERROR called as part of a new expression with argument list _args_
it performs the following steps:

1.  Let _F_ be the ERROR function object on which the NEW operator was
    applied.

2.  Let _argumentsList_ be the _argumentsList_ argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of OrdinaryConstruct (_F_, _argumentsList_).

If ERROR is implemented as an ordinary function object, its
[[Construct]] internal method will perform the above steps.

15.11.3 Properties of the Error Constructor

The value of the [[Prototype]] internal data property of the Error
constructor is the Function prototype object (15.3.3).

Besides the internal properties and the LENGTH property (whose value is
1), the Error constructor has the following property:

15.11.3.1 Error.prototype

The initial value of ERROR.PROTOTYPE is the Error prototype object
(15.11.4).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

15.11.3.2 Error[ @@create ] ( )

The @@create method of an object _F_ performs the following steps:

1.  Let _F_ be the THIS value.

2.  Let _obj_ be the result of calling
    OrdinaryCreateFromConstructor(_F_, "%ERRORPROTOTYPE%", (
    [[ErrorData]]) ).

3.  Return _obj_.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

NOTE [[ErrorData]] is initially assigned the value UNDEFINED as a flag
to indicate that the instance has not yet been initialized by the
Boolean constructor. This flag value is never directly exposed to
ECMAScript code; hence implementation may choose to encode the flag in
some other manner.

15.11.4 Properties of the Error Prototype Object

The Error prototype object is an ordinary object. It is not an Error
instance and does not have an [[ErrorData] internal data property.

The value of the [[Prototype]] internal data property of the Error
prototype object is the standard built-in Object prototype object
(15.2.4).

15.11.4.1 Error.prototype.constructor

The initial value of ERROR.PROTOTYPE.CONSTRUCTOR is the built-in ERROR
constructor.

15.11.4.2 Error.prototype.name

The initial value of ERROR.PROTOTYPE.NAME is "ERROR".

15.11.4.3 Error.prototype.message

The initial value of ERROR.PROTOTYPE.MESSAGE is the empty String.

15.11.4.4 Error.prototype.toString ( )

The following steps are taken:

15.11.5 Properties of Error Instances

Error instances are ordinary objects that inherit properties from the
Error prototype object and have a [[ErrorData]] internal data property
whose initial value is UNDEFINED. The only specified uses of
[[ErrorData]] is to flag whether or not an Error instance has been
initialized by the Error constructor and to identify them as Error
objects within OBJECT.PROTOTYPE.TOSTRING.

15.11.6 Native Error Types Used in This Standard

One of the _BuiltinError_ objects below is thrown when a runtime error
is detected. All of these objects share the same structure, as described
in 15.11.7.

15.11.6.1 EvalError

This exception is not currently used within this specification. This
object remains for compatibility with previous editions of this
specification.

15.11.6.2 RangeError

Indicates a numeric value has exceeded the allowable range. See
15.4.2.2, 15.4.5.1, 15.7.4.2, 15.7.4.5, 15.7.4.6, 15.7.4.7, and
15.9.5.43.

15.11.6.3 ReferenceError

Indicate that an invalid reference value has been detected. See 8.9.1,
8.9.2, 10.2.1, 10.2.1.1.4, 10.2.1.2.4, and 11.13.1.

15.11.6.4 SyntaxError

Indicates that a parsing error has occurred. See 11.1.5, 11.3.1, 11.3.2,
11.4.1, 11.4.4, 11.4.5, 11.13.1, 11.13.2, 12.2.1, 12.10.1, 12.14.1,
13.1, 15.1.2.1, 15.3.2.1, 15.10.2.2, 15.10.2.5, 15.10.2.9, 15.10.2.15,
15.10.2.19, 15.10.4.1, and 15.12.2.

15.11.6.5 TypeError

Indicates the actual type of an operand is different than the expected
type. See 8.6.2, 8.9.2, 8.10.5, 8.12.5, 8.12.7, 8.12.8, 8.12.9, 9.9,
9.10, 10.2.1, 10.2.1.1.3, 10.6, 11.2.2, 11.2.3, 11.4.1, 11.8.6, 11.8.7,
11.3.1, 13.2, 13.2.3, 15, 15.2.3.2, 15.2.3.3, 15.2.3.4, 15.2.3.5,
15.2.3.6, 15.2.3.7, 15.2.3.8, 15.2.3.9, 15.2.3.10, 15.2.3.11, 15.2.3.12,
15.2.3.13, 15.2.3.14, 15.2.4.3, 15.3.3.2, 15.3.3.3, 15.3.3.4, 15.3.3.5,
15.3.3.5.2, 15.3.3.5.3, 15.3.4, 15.3.4.3, 15.3.4.4, 15.4.3.3, 15.4.3.11,
15.4.3.16, 15.4.3.17, 15.4.3.18, 15.4.3.19, 15.4.3.20, 15.4.3.21,
15.4.3.22, 15.4.5.1, 15.5.4.2, 15.5.4.3, 15.6.4.2, 15.6.4.3, 15.7.4,
15.7.4.2, 15.7.4.4, 15.9.5, 15.9.5.44, 15.10.4.1, 15.10.6, 15.11.4.4 and
15.12.3.

15.11.6.6 URIError

Indicates that one of the global URI handling functions was used in a
way that is incompatible with its definition. See 15.1.3.

15.11.7 _NativeError_ Object Structure

When an ECMAScript implementation detects a runtime error, it throws an
instance of one of the _NativeError_ objects defined in 15.11.6. Each of
these objects has the structure described below, differing only in the
name used as the constructor name instead of _NativeError_, in the NAME
property of the prototype object, and in the implementation-defined
MESSAGE property of the prototype object.

For each error object, references to _NativeError_ in the definition
should be replaced with the appropriate error object name from 15.11.6.

15.11.7.1 _NativeError_ Constructors Called as Functions

When a _NativeError_ constructor is called as a function rather than as
a constructor, it creates and initialises a new object. A call of the
object as a function is equivalent to calling it as a constructor with
the same arguments. However, if the THIS value value passed in the call
is an Object with an uninitialized [[ErrorData]] internal data property,
it initializes the THIS value using the argument value. This permits
ERROR to be used both as factory method and to perform constructor
instance initialization.

A _NativeError_ constructor may be subclassed and subclass constructors
may perform a super invocation of the _NativeError_ constructor to
initialize subclass instances.

15.11.7.1.1 _NativeError_ (message)

1.  Let _func_ be this _NativeError_ function object.

2.  Let _O_ be the THIS value.

3.  If Type(_O_) is not Object or Type(_O_) is Object and _O_ does not
    have an [[ErrorData]] internal data property or Type(_O_) is Object
    and _O_ has an [[ErrorData]] internal data property and the value of
    [[ErrorData]] is not UNDEFINED, then

    a.  Let _O_ be the result of calling
        OrdinaryCreateFromConstructor(_func_,
        "%_NATIVEERROR_PROTOTYPE%", ( [[ErrorData]]) ).

    b.  ReturnIfAbrupt(_O_).

4.  Assert: Type(_O_) is Object.

5.  Set the value of _O’s_ [[ErrorData]] internal data property to any
    value other than UNDEFINED.

6.  7.  If _message_ is not UNDEFINED, then

    a.  Let _msg_ be ToString(_message_).

    b.  c.  d.  Let _msgDesc_ be the Property Descriptor.
        {[[Value]]: _msg_, [[Writable]]: TRUE, [[Enumerable]]: FALSE,
        [[Configurable]]: TRUE}.

    e.  Let _status_ be the result of calling the [[DefineOwnProperty]]
        internal method of _O_ passing "MESSAGE" and _msgDesc_ as
        arguments.

    f.  ReturnIfAbrupt(_status_).

    g.  If _status_ is FALSE, then throw a TYPEERROR exception.

8.  Return _O_.

The actual value of the string passed in step 3.a is either
"%EVALERRORPROTOTYPE%", "%RANGEERRORPROTOTYPE%",
"%REFERENCEERRORPROTOTYPE%", "%SYNTAXERRORPROTOTYPE%",
"%TYPEERRORPROTOTYPE%", or "%URIERRORPROTOTYPE%" corresponding to which
_NativeError_ constructor is being defined.

15.11.7.2 The _NativeError_ Constructors

When a _NativeError_ constructor is called as part of a NEW expression,
it is a constructor: it initialises the newly created object.

15.11.7.2.1 new _NativeError_ (... args)

When a _NativeError_ constructor is called as part of a new expression
with argument list _args_ it performs the following steps:

1.  Let _F_ be this _NativeError_ function object on which the NEW
    operator was applied.

2.  Let _argumentsList_ be the _argumentsList_ argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of OrdinaryConstruct (_F_, _argumentsList_).

If a _NativeError_ constructor is implemented as an ordinary function
object, its [[Construct]] internal method will perform the above steps.

15.11.7.3 Properties of the _NativeError_ Constructors

The value of the [[Prototype]] internal data property of a _NativeError_
constructor is the Error constructor object (15.11.1).

Besides the LENGTH property (whose value is 1), each _NativeError_
constructor has the following property:

15.11.7.3.1 _NativeError_.prototype

The initial value of _NATIVEERROR_.PROTOTYPE is a _NativeError_
prototype object (15.11.7.4). Each _NativeError_ constructor has a
separate prototype object.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

15.11.7.3.2 _NativeError_ [ @@create ] ( )

The @@create method of an object _F_ performs the following steps:

1.  Let _F_ be the THIS value.

2.  Let _obj_ be the result of calling
    OrdinaryCreateFromConstructor(_F_, _NativeErrorPrototype_, (
    [[ErrorData]]) ).

3.  Return _obj_.

The actual value passed as _NativeErrorPrototype_ in step 2 is either
"%EVALERRORPROTOTYPE%", "%RANGEERRORPROTOTYPE%",
"%REFERENCEERRORPROTOTYPE%", "%SYNTAXERRORPROTOTYPE%",
"%TYPEERRORPROTOTYPE%", or "%URIERRORPROTOTYPE%" corresponding to which
_NativeError_ constructor is being defined.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

NOTE [[ErrorData]] is initially assigned the value UNDEFINED as a flag
to indicate that the instance has not yet been initialized by the
Boolean constructor. This flag value is never directly exposed to
ECMAScript code; hence implementation may choose to encode the flag in
some other manner.

15.11.7.4 Properties of the _NativeError_ Prototype Objects

Each _NativeError_ prototype object is an an ordinary object. It is not
an Error instance and does not have an [[ErrorData] internal data
property.

The value of the [[Prototype]] internal data property of each
_NativeError_ prototype object is the standard built-in Error prototype
object (15.11.4).

15.11.7.4.1 _NativeError_.prototype.constructor

The initial value of the CONSTRUCTOR property of the prototype for a
given _NativeError_ constructor is the _NativeError_ constructor
function itself (15.11.7).

15.11.7.4.2 _NativeError_.prototype.name

The initial value of the NAME property of the prototype for a given
_NativeError_ constructor is a string consisting of the name of the
constructor (the name used instead of _NativeError_).

15.11.7.4.3 _NativeError_.prototype.message

The initial value of the MESSAGE property of the prototype for a given
_NativeError_ constructor is the empty String.

15.11.7.5 Properties of _NativeError_ Instances

_NativeError_ instances are ordinary objects that inherit properties
from their _NativeError_ prototype object and have a [[ErrorData]]
internal data property whose initial value is UNDEFINED. The only
specified use of [[ErrorData]] is to flag whether or not an Error or
_NativeError_ instance has been initialized by its constructor.


15.12 The JSON Object

The JSON object is a single ordinary object that contains two functions,
PARSE and STRINGIFY, that are used to parse and construct JSON texts.
The JSON Data Interchange Format is described in RFC 4627
<http://www.ietf.org/rfc/rfc4627.txt>. The JSON interchange format used
in this specification is exactly that described by RFC 4627 with two
exceptions:

-   The top level _JSONText_ production of the ECMAScript JSON grammar
    may consist of any _JSONValue_ rather than being restricted to being
    a _JSONObject_ or a _JSONArray_ as specified by RFC 4627.

-   Conforming implementations of JSON.PARSE and JSON.STRINGIFY must
    support the exact interchange format described in this specification
    without any deletions or extensions to the format. This differs from
    RFC 4627 which permits a JSON parser to accept non-JSON forms and
    extensions.

The value of the [[Prototype]] internal data property of the JSON object
is the standard built-in Object prototype object (15.2.4). The JSON
object has a [[JSONTag]] internal data property whose value is TRUE .
The value of the [[Extensible]] internal data property of the JSON
object is set to TRUE.

The JSON object does not have a [[Construct]] internal method; it is not
possible to use the JSON object as a constructor with the NEW operator.

The JSON object does not have a [[Call]] internal method; it is not
possible to invoke the JSON object as a function.

15.12.1 The JSON Grammar 

JSON.stringify produces a String that conforms to the following JSON
grammar. JSON.parse accepts a String that conforms to the JSON grammar.

15.12.1.1 The JSON Lexical Grammar

JSON is similar to ECMAScript source text in that it consists of a
sequence of Unicode characters conforming to the rules of
_SourceCharacter_. The JSON Lexical Grammar defines the tokens that make
up a JSON text similar to the manner that the ECMAScript lexical grammar
defines the tokens of an ECMAScript source text. The JSON Lexical
grammar only recognises the white space character specified by the
production _JSONWhiteSpace_. The JSON lexical grammar shares some
productions with the ECMAScript lexical grammar. All nonterminal symbols
of the grammar that do not begin with the characters “JSON” are defined
by productions of the ECMAScript lexical grammar.

Syntax

_JSONWhiteSpace_ ::

<TAB>
<CR>
<LF>
<SP>

JSONString ::

" JSONStringCharacters~opt~ "

JSONStringCharacters ::

JSONStringCharacter JSONStringCharacters~opt~

_JSONStringCharacter_ ::

SourceCharacter BUT NOT ONE OF " OR \ OR U+0000 THROUGH U+001F

\ JSONEscapeSequence

JSONEscapeSequence ::

JSONEscapeCharacter

U HexDigit HexDigit HexDigit HexDigit

JSONEscapeCharacter :: ONE OF

" / \ B F N R T

JSONNumber ::

-~opt~ DecimalIntegerLiteral JSONFraction~opt~ ExponentPart~opt~

JSONFraction ::

. DecimalDigits

JSONNullLiteral ::

NullLiteral

JSONBooleanLiteral ::

BooleanLiteral

15.12.1.2 The JSON Syntactic Grammar

The JSON Syntactic Grammar defines a valid JSON text in terms of tokens
defined by the JSON lexical grammar. The goal symbol of the grammar is
_JSONText_.

Syntax

JSONText :

JSONValue

JSONValue :

JSONNullLiteral
JSONBooleanLiteral
JSONObject
JSONArray
JSONString
JSONNumber

JSONObject :

{ }
{ JSONMemberList }

JSONMember :

JSONString : JSONValue

JSONMemberList :

JSONMember
JSONMemberList , JSONMember

JSONArray :

[ ]
[ JSONElementList ]

JSONElementList :

JSONValue
JSONElementList , JSONValue

15.12.2 JSON.parse ( text [ , reviver ] )

The PARSE function parses a JSON text (a JSON-formatted String) and
produces an ECMAScript value. The JSON format is a restricted form of
ECMAScript literal. JSON objects are realized as ECMAScript objects.
JSON arrays are realized as ECMAScript arrays. JSON strings, numbers,
booleans, and null are realized as ECMAScript Strings, Numbers,
Booleans, and NULL. JSON uses a more limited set of white space
characters than _WhiteSpace_ and allows Unicode code points U+2028 and
U+2029 to directly appear in _JSONString_ literals without using an
escape sequence. The process of parsing is similar to 11.1.4 and 11.1.5
as constrained by the JSON grammar.

The optional _reviver_ parameter is a function that takes two
parameters, (_key_ and _value_). It can filter and transform the
results. It is called with each of the _key_/_value_ pairs produced by
the parse, and its return value is used instead of the original value.
If it returns what it received, the structure is not modified. If it
returns UNDEFINED then the property is deleted from the result.

RUNTIME SEMANTICS: WALK ABSTRACT OPERATION

The abstract operation Walk is a recursive abstract operation that takes
two parameters: a _holder_ object and the String _name_ of a property in
that object. Walk uses the value of _reviver_ that was originally passed
to the above parse function.

It is not permitted for a conforming implementation of JSON.PARSE to
extend the JSON grammars. If an implementation wishes to support a
modified or extended JSON interchange format it must do so by defining a
different parse function.

NOTE In the case where there are duplicate name Strings within an
object, lexically preceding values for the same key shall be
overwritten.

15.12.3 JSON.stringify ( value [ , replacer [ , space ] ] )

The STRINGIFY function returns a String in UTF-16 encoded JSON format
representing an ECMAScript value. It can take three parameters. The
_value_ parameter is an ECMAScript value, which is usually an object or
array, although it can also be a String, Boolean, Number or NULL. The
optional _replacer_ parameter is either a function that alters the way
objects and arrays are stringified, or an array of Strings and Numbers
that acts as a white list for selecting the object properties that will
be stringified. The optional _space_ parameter is a String or Number
that allows the result to have white space injected into it to improve
human readability.

These are the steps in stringifying an object:

1.  Let _stack_ be an empty List.

2.  Let _indent_ be the empty String.

3.  Let _PropertyList_ and _ReplacerFunction_ be UNDEFINED.

4.  If Type(_replacer_) is Object, then

    a.  If IsCallable(_replacer_) is TRUE, then

        i.  Let _ReplacerFunction_ be _replacer_.

    b.  Else if _replacer_ is an exotic Array object, then

        i.  Let _PropertyList_ be an empty internal List

        ii. For each value _v_ of a property of _replacer_ that has an
            array index property name. The properties are enumerated in
            the ascending array index order of their names.

            1.  Let _item_ be UNDEFINED.

            2.  If Type(_v_) is String then let _item_ be _v._

            3.  Else if Type(_v_) is Number then let _item_ be
                ToString(_v_).

            4.  Else if Type(_v_) is Object then,

                a.  If _v_ has a [[StringData]] or [[NumberData]]
                    internal data property, then let _item_ be
                    ToString(_v_).

            5.  If _item_ is not UNDEFINED and _item_ is not currently
                an element of _PropertyList_ then,

                a.  Append _item_ to the end of _PropertyList_.

5.  If Type(_space_) is Object then,

    a.  If _space_ has a [[NumberData]] internal data property then,

        i.  Let _space_ be ToNumber(_space_).

    b.  Else if _space_ has a [[StringData]] internal data property
        then,

        i.  Let _space_ be ToString(_space_).

6.  If Type(_space_) is Number

    a.  Let _space_ be min(10, ToInteger(_space_)).

    b.  Set _gap_ to a String containing _space_ occurrences of code
        unit 0x0020 (the Unicode space character). This will be the
        empty String if _space_ is less than 1.

7.  Else if Type(_space)_ is String

    a.  If the number of elements in _space_ is 10 or less, set _gap_ to
        _space_ otherwise set _gap_ to a String consisting of the first
        10 elements of _space_.

8.  Else

    a.  Set _gap_ to the empty String.

9.  Let _wrapper_ be the result of the abstract operation ObjectCreate
    with the intrinsic object %ObjectPrototype% as its argument.

10. Call CreateOwnDataProperty(_wrapper_, the empty String, _value_).

11. Return the result of calling the abstract operation Str with the
    empty String and _wrapper_.

RUNTIME SEMANTICS: STR ABSTRACT OPERATION

The abstract operation _Str_(_key_, _holder_) has access to
_ReplacerFunction_ from the invocation of the STRINGIFY method. Its
algorithm is as follows:

1.  Let _value_ be the result of Get(_holder_, _key_).

2.  ReturnIfAbrupt(_value_).

3.  If Type(_value_) is Object, then

    a.  Let _toJSON_ be the result of Get(_value_, "TOJSON").

    b.  If IsCallable(_toJSON_) is TRUE

        i.  Let _value_ be the result of calling the [[Call]] internal
            method of _toJSON_ passing _value_ as _thisArgument_ and a
            List containing _key_ as _argumentsList_.

        ii. ReturnIfAbrupt(_value_).

4.  If _ReplacerFunction_ is not UNDEFINED, then

    a.  Let _value_ be the result of calling the [[Call]] internal
        method of _ReplacerFunction_ passing _holder_ as the THIS value
        and with an argument list consisting of _key_ and _value_.

    b.  ReturnIfAbrupt(_value_).

5.  If Type(_value_) is Object then,

    a.  If _value_ has an [[NumberData]] internal data property then,

        i.  Let _value_ be ToNumber(_value_).

    b.  Else if _value_ has an [[StringData]] internal data property
        then,

        i.  Let _value_ be ToString(_value_).

    c.  Else if _value_ has an [[BooleanData]] internal data property
        then,

        i.  Let _value_ be the value of the [[BooleanData]] internal
            data property of _value_.

6.  If _value_ is NULL then return "NULL".

7.  If _value_ is TRUE then return "TRUE".

8.  If _value_ is FALSE then return "FALSE".

9.  If Type(_value_) is String, then return the result of calling the
    abstract operation Quote with argument _value_.

10. If Type(_value_) is Number

    a.  If _value_ is finite then return ToString(_value_).

    b.  Else, return "NULL".

11. If Type(_value_) is Object, and IsCallable(_value_) is FALSE

    a.  If _value_ is an exotic Array object then

        i.  Return the result of calling the abstract operation _JA_
            with argument _value_.

    b.  Else, return the result of calling the abstract operation _JO_
        with argument _value_.

12. Return UNDEFINED.

RUNTIME SEMANTICS: QUOTE ABSTRACT OPERATION

The abstract operation Quote(_value_) wraps a String value in double
quotes and escapes characters within it.

1.  Let _product_ be code unit 0x0022 (the Unicode double quote
    character).

2.  For each code unit _C_ in _value

    a.  If _C_ is 0x0022 or 0x005C (the Unicode reverse solidus
        character)

        i.  Let _product_ be the concatenation of _product_ and code
            unit 0x005C.

        ii. Let _product_ be the concatenation of _product_ and _C_.

    b.  Else if _C_ is backspace, formfeed, newline, carriage return, or
        tab

        i.  Let _product_ be the concatenation of _product_ and code
            unit 0x005C (the Unicode backslash character).

        ii. Let _abbrev_ be the string value corresponding to the value
            of _C_ as follows:

  backspace "B"

  formfeed "F"

  newline "N"

  carriage return "R"

  tab "T"

i.  Let _product_ be the concatenation of _product_ and _abbrev_.

a.  Else if _C_ has a code unit value less than 0x0020 (the Unicode
    space character)

    i.  Let _product_ be the concatenation of _product_ and code unit
        0x005C (the Unicode backslash character).

    ii. Let _product_ be the concatenation of _product_ and "U".

    iii. Let _hex_ be the string result of converting the numeric code
        unit value of _C_ to a String of four hexadecimal digits.
        Alphabetic hexadecimal digits are presented as lowercase
        characters.

    iv. Let _product_ be the concatenation of _product_ and _hex_.

b.  Else

    i.  Let _product_ be the concatenation of _product_ and _C_.

1.  Let _product_ be the concatenation of _product_ and code unit 0x
    (the Unicode double quote character).

2.  Return _product_.

RUNTIME SEMANTICS: JO ABSTRACT OPERATION

The abstract operation _JO_(_value_) serializes an object. It has access
to the _stack_, _indent_, _gap_, and _PropertyList_ of the invocation of
the stringify method.

RUNTIME SEMANTICS: JA ABSTRACT OPERATION

The abstract operation _JA_(_value_) serializes an array. It has access
to the _stack_, _indent_, and _gap_ of the invocation of the stringify
method. The representation of arrays includes only the elements between
zero and ARRAY.LENGTH – 1 inclusive. Properties whose keys are not array
indexes are excluded from the stringification. An array is stringified
as an open left bracket, elements separated by comma, and a closing
right bracket.

NOTE 1 JSON structures are allowed to be nested to any depth, but they
must be acyclic. If _value_ is or contains a cyclic structure, then the
stringify function must throw a TYPEERROR exception. This is an example
of a value that cannot be stringified:

  a = [];

  a[0] = a;

  my_text = JSON.stringify(a); // This must throw an TypeError.

NOTE 2 Symbolic primitive values are rendered as follows:

-   The NULL value is rendered in JSON text as the String null.

-   The UNDEFINED value is not rendered.

-   The TRUE value is rendered in JSON text as the String true.

-   The FALSE value is rendered in JSON text as the String FALSE.

NOTE 3 String values are wrapped in double quotes. The characters " and
\ are escaped with \ prefixes. Control characters are replaced with
escape sequences \UHHHH, or with the shorter forms, \B (backspace), \F
(formfeed), \N (newline), \R (carriage return), \T (tab).

NOTE 4 Finite numbers are stringified as if by calling
ToString(_number_). NAN and Infinity regardless of sign are represented
as the String NULL.

NOTE 5 Values that do not have a JSON representation (such as UNDEFINED
and functions) do not produce a String. Instead they produce the
UNDEFINED value. In arrays these values are represented as the String
NULL. In objects an unrepresentable value causes the property to be
excluded from stringification.

NOTE 6 An object is rendered as an opening left brace followed by zero
or more properties, separated with commas, closed with a right brace. A
property is a quoted String representing the key or property name, a
colon, and then the stringified property value. An array is rendered as
an opening left bracket followed by zero or more values, separated with
commas, closed with a right bracket.


15.13 Binary Data Objects

15.13.1 The BinaryData Module

15.13.2 The BinaryData.Type Object

15,13.2.5 BinaryData._ScalarType_ Type Instance Objects

15.13.3 The BinaryData.ArrayType Object

15.13.4 The BinaryData.StructType Object

15.13.5 ArrayBuffer Objects

15.13.5.1 Abstract Operations For ArrayBuffer Objects

15.13.5.1.1 AllocateArrayBuffer(constructor)

The abstract operation AllocateArrayBuffer with argument _constructor_
is used to create an unitialized ArrayBuffer object. It performs the
following steps:

1.  2.  Let _obj_ be the result of calling
    OrdinaryCreateFromConstructor(_constructor_,
    "%ARRAYBUFFERPROTOTYPE%", ( [[ArrayBufferData]],
    [[ArrayBufferByteLength]]) ).

3.  ReturnIfAbrupt(_obj_).

4.  5.  Set the [[ArrayBufferByteLength]] internal data property of
    _obj_ to 0.

6.  7.  8.  Return _obj_.

15.13.5.1.2 SetArrayBufferData(arrayBuffer, bytes)

The abstract operation SetArrayBufferData with arguments _arrayBuffer_
and _bytes_ is used to initialize the storage block encapsulated by an
ArrayBuffer object. It performs the following steps:

1.  Assert: _arrayBuffer_ has an [[ArrayBufferData]] internal data
    property.

2.  Assert: _bytes_ is positive integer.

3.  Let _block_ be the result of CreateByteArrayBlock(_bytes_).

4.  ReturnIfAbrupt(_block_).

5.  Set _arrayBuffer’s_ [[ArrayBufferData]] to _block_.

6.  Set _arrayBuffer_’s [[ArrayBufferByteLength]] internal data property
    to _bytes_.

7.  Return _arrayBuffer_.

15.13.5.1.3 GetValueFromBuffer (arrayBuffer, byteIndex, type, isBigEndian)

The abstract operation GetValueFromBuffer takes four parameters, an
ArrayBuffer _arrayBuffer_, an integer _byteIndex_, a String _valueType_,
and optionally a Boolean _isBigEndian_. If _isBigEndian_ is not present,
its default value is UNDEFINED. This operation performs the follow
steps:

1.  Assert: There are sufficient bytes in _arrayBuffer_ starting at
    _byteIndex_ to represent a value of _valueType_.

2.  Assert: _byteIndex_ is a positive integer.

3.  Let _block_ be _arrayBuffer’s_ [[ArrayBufferData]] internal data
    property.

4.  Let _elementSize_ be the Number value of the Element Size value
    specified in Table 36 for _valueType_.

5.  Let _rawValue_ be the _elementSize_ bytes starting at _byteIndex_ of
    _block_.

6.  If _isBigEndian_ is UNDEFINED, set _isBigEndian_ to either TRUE or
    FALSE. The choice is implementation dependent and should be the
    alternative that is most efficient for the implementation. An
    implementation must use the same value each time this step is
    executed and the same value must be used for the corresponding step
    in the SetValueInBuffer abstraction operation.

7.  If _isBigEndian_ is TRUE, reverse the order of the bytes of
    _rawValue_.

8.  If _type_ is “Float32” , then

    a.  _rawValue_ is interpreted, taking into accont the value of
        _isBigEndian_, as a bit string encoding of an IEEE 754-208
        binary32 value.

    b.  If _rawValue_ is an IEEE 754-208 binary32 NaN value, return the
        NAN Number value.

    c.  Return the Number value that is encoded by _rawValue_.

9.  If _type_ is “Float64” , then

    a.  _rawValue_ is interpreted, taking into accont the value of
        _isBigEndian_, as a bit string encoding of an IEEE 754-208
        binary64 value.

    b.  If _rawValue_ is an IEEE 754-208 binary64 NaN value, return the
        NAN Number value.

    c.  Return the Number value that is encoded by _rawValue_.

10. If the first characger of _type_ is "U", then

    a.  Let _intValue_ be the positive integer that is the result of
        interpreting, taking into accont the value of _isBigEndian_,
        _rawValue_ as an unsigned binary number.

11. Else

    a.  Let _intValue_ be the signed integer that is the result of
        interpreting, taking into accont the value of _isBigEndian_,
        _rawValue_ as a binary 2’s complement number of bit length
        _elementSize_ × 4.

12. Return _intValue_.

NOTE The default number storage formal for all implementation is little
endian, regardless of the native endianness of the underlying hardward.

15.13.5.1.4 SetValueInBuffer (arrayBuffer, byteIndex, type, value, isBigEndian)

The abstract operation SetValueFromBuffer takes five parameters, an
ArrayBuffer _arrayBuffer_, an integer _byteIndex_, a String _valueType_,
a Number _value_, and optionally a Boolean _isBigEndian_. If
_isBigEndian_ is not present, its default value is FALSE. This operation
performs the follow steps:

1.  Assert: There are sufficient bytes in _arrayBuffer_ starting at
    _byteIndex_ to represent a value of _valueType_.

2.  Assert: _byteIndex_ is a positive integer.

3.  Let _block_ be _arrayBuffer’s_ [[ArrayBufferData]] internal data
    property.

4.  Let _elementSize_ be the Number value of the Element Size value
    specified in Table 35 on the row with Element Type is _type_.

5.  Let _rawValue_ be the _elementSize_ bytes starting at _byteIndex_ of
    _arrayBuffer_.

6.  If _isBigEndian_ is UNDEFINED, set _isBigEndian_ to either TRUE or
    FALSE. The choice is implementation dependent and should be the
    alternative that is most efficient for the implementation. An
    implementation must use the same value each time this step is
    executed and the same value must be used for the corresponding step
    in the GetValueFromBuffer abstraction operation.

7.  If _isBigEndian_ is TRUE, reverse the order of the bytes of
    _rawValue_.

8.  If _type_ is “Float32” , then

    a.  Set _rawValue_ to the 4 bytes that are the result of converting
        _value_ to IEEE-868-2005 binary32 format using “Round to
        nearest, ties to even” rounding mode. If _isBigEndian_ is TRUE,
        the bytes are arranged in big endian order. Otherwise, the bytes
        are arranged in little endian order. If _value_ is NAN,
        _rawValue_ is may be set of any implementation choosen
        non-signaling NaN encoding.

9.  Else, if _type_ is “Float64” , then

    a.  Set _rawValue_ to the 8 bytes that are the IEEE-868-2005
        binary64 format encoding of _value_. If _isBigEndian_ is TRUE,
        the bytes are arranged in big endian order. Otherwise, the bytes
        are arranged in little endian order. If _value_ is NAN,
        _rawValue_ is may be set to any implementation choosen
        non-signaling NaN encoding.

10. Else,

    a.  Let _n_ be the Size Element value in Table 35 for the row
        containing the value of _type_ as its Element Type entry.

    b.  Let _convOp_ be the abstract operation named in the Conversion
        Opoeration column in Table 35 for the row containing the value
        of _type_ as its Element Type entry.

    c.  Let _intValue_ be the result of calling _convOp_ with _value_ as
        its argument .

    d.  If _intValue_ ≥ 0, then

        i.  Let _rawBytes_ be the _n_-byte binary encoding of
            _intValue_. If _isBigEndian_ is TRUE, the bytes are arranged
            in big endian order. Otherwise, the bytes are arranged in
            little endian order.

    e.  Else,

        i.  Let _rawBytes_ be the _n_-byte binary 2’s complement
            encoding of _intValue_. If _isBigEndian_ is TRUE, the bytes
            are arranged in big endian order. Otherwise, the bytes are
            arranged in little endian order.

11. Store the individual bytes of _rawBytes_ in order starting at
    position _byteIndex_ of _block_.

12. Return NormalCompletion (UNDEFINED).

15.13.5.2 The ArrayBuffer Object Called as a Function

When ARRAYBUFFER is called as a function rather than as a constructor,
it initializes its THIS value with the internal state that supports the
ARRAYBUFFER.PROTOTYPE internal methods. This permits super invocation of
the ARRAYBUFFER constructor by ARRAYBUFFER subclasses. If its this value
is undefined, it creates and initialises a new ArrayBuffer object. Thus
the function call ARRAYBUFFER(…) is equivalent to the object creation
expression NEW ARRAYBUFFER (…) with the same arguments.

15.13.5.2.1 ArrayBuffer(length)

ArrayBuffer called as function with argument _length_ performs the
following steps:

1.  Let _O_ be the THIS value.

2.  If Type(_O_) is neither Object or Undefined, then throw a TYPEERROR
    exception

3.  If _O_ is UNDEFINED or does not have an [[ArrayBufferData]] internal
    data property, then

    a.  Let _F_ be this function object.

    b.  Let _argumentsList_ be the _argumentsList_ argument of the
        [[Call]] internal method that invoked _F_.

    c.  Return the result of calling OrdinaryCreateFromConstructor (_F_,
        _argumentsList_).

4.  If the value of _O’s_ [[ArrayBufferData]] internal data property is
    not UNDEFINED, then throw a TYPEERROR exception,

5.  Let _numberLength_ be ToNumber(_length_).

6.  Let _byteLength_ be ToInteger(_numberLength_).

7.  ReturnIfAbrupt(_byteLength_).

8.  If _numberLength_ ≠ _byteLength_ or _byteLength_ < 0, then throw a
    RANGEERROR exception.

9.  Return the result of SetArrayBufferData(_O_, _byteLength_).

15.13.5.3 The ArrayBuffer Constructor

When ArrayBuffer is called as part of a new expression, it is a
constructor: it initialises the newly created object.

The ArrayBuffer constructor is designed to be subclassable. It may be
used as the value of an EXTENDS clause of a class declaration. Subclass
constructors that intended to inherit the specified ArrayBuffer
behaviour must include a SUPER call to ArrayBuffer.

15.13.5.3.1 new ArrayBuffer( ...args )

ArrayBuffer called as part of a new expression with argument _length_
performs the following steps:

1.  Let _F_ be the ArrayBuffer function object on which the NEW operator
    was applied.

2.  Let _argumentsList_ be the _argumentsList_ argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of OrdinaryConstruct(_F_, _argumentsList_).

If ArrayBuffer is implemented as an ordinary function object, its
[[Construct]] internal method will perform the above steps.

15.13.5.4 Properties of the ArrayBuffer Constructor

The value of the [[Prototype]] internal data property of the ArrayBuffer
constructor is the Function prototype object (15.3.3).

Besides its LENGTH property (whose value is 1), the ArrayBuffer
constructor has the following properties:

15.13.5.4.1 ArrayBuffer.prototype

The initial value of ArrayBuffer.prototype is the ArrayBuffer prototype
object (15.13.5.4).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

15.13.5.4.2 ArrayBuffer.isView ( arg )

The isView function takes one argument _arg_, and performs the following
steps are taken:

1.  If Type(_arg_) is not Object, return FALSE.

2.  If _arg_ is an exotic Array object, then return TRUE.

3.  If _arg_ has a [[ViewedArrayBuffer]] internal data property, then
    return TRUE.

4.  Return FALSE.

15.13.5.4.3 ArrayBuffer[ @@create ] ( )

The @@create method of a ArrayBuffer function object _F_ performs the
following steps:

1.  Let _F_ be the THIS value.

2.  3.  Return the result of calling AllocateArrayBuffer(_F_).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

15.13.5.5 Properties of the ArrayBuffer Prototype Object

The value of the [[Prototype]] internal data property of the ArrayBuffer
prototype object is the standard built-in Object prototype object
(15.2.4). The ArrayBuffer prototype object is an ordinary object. It
does not have a [[ArrayBufferData]] or [[ArrayBufferByteLength]]
internal data property.

15.13.5.5.1 ArrayBuffer.prototype.constructor

The initial value of ArrayBuffer.prototype.constructor is the standard
built-in ArrayBuffer constructor.

15.13.5.5.2 get ArrayBuffer.prototype.byteLength 

ARRAYBUFFER.PROTOTYPE.BYTELENGTH is an accessor property whose set
accessor function is UNDEFINED. Its get accessor function performs the
following steps:

1.  Let _O_ be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(_O_).

3.  If _O_ does not have a [[ArrayBufferByteLength]] internal data
    property throw a TYPEERROR exception.

4.  Let _length_ be the value of _O_’s [[ArrayBufferByteLength]]
    internal data property.

5.  Return _length_.

15.13.5.5.3 ArrayBuffer.prototype.slice ( start , end)

The following steps are taken:

1.  Let _O_ be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(_O_).

3.  If _O_ does not have a [[ArrayBufferData]] internal data property
    throw a TYPEERROR exception.

4.  Let _len_ be the value of _O_’s [[ArrayBufferByteLength]] internal
    data property.

5.  Let _relativeStart_ be ToInteger(_start_).

6.  ReturnIfAbrupt(_relativeStart_).

7.  If _relativeStart_ is negative, let _first_ be max((_len_ +
    _relativeStart_),0); else let _first_ be min(_relativeStart_,
    _len_).

8.  If _end_ is UNDEFINED, let _relativeEnd_ be _len_; else let
    _relativeEnd_ be ToInteger(_end_).

9.  ReturnIfAbrupt(_relativeEnd_).

10. If _relativeEnd_ is negative, let _final_ be max((_len_ +
    _relativeEnd_),0); else let _final_ be min(_relativeEnd_, _len_).

11. Let _newLen_ be _final_-_first_.

12. Let _ctor_ be the result of GetMethod(_O_, "CONSTRUCTOR").

13. ReturnIfAbrupt(_ctor_).

14. If IsConstructor(_ctor_) is FALSE, then throw a TYPEERROR exception.

15. Let _new_ be the result of calling the [[Construct]] internal method
    of _ctor_ with a new List containing the single element _newLen_.

16. ReturnIfAbrupt(_new_).

17. If _new_ does not have a [[ArrayBufferData]] internal data property
    throw a TYPEERROR exception.

18. Let _fromBuf_ be the value of _O_’s [[ArrayBufferData]] internal
    data property.

19. Let _toBuf_ be the value of _new_’s [[ArrayBufferData]] internal
    data property.

20. Let _status_ be the result of CopyBlockElements(_fromBuf_, _first_,
    _toBuf_, 0, _newLen_).

21. ReturnIfAbrupt(_status_).

22. Return _new_.

15.13.5.5.4 ArrayBuffer.prototype.@@toStringTag 

The initial value of the @@toStringTag property is the string value
"ARRAYBUFFER".

15.13.5.6 Properties of the ArrayBuffer Instances

ArrayBuffer instances inherit properties from the ArrayBuffer prototype
object. After initialisation by the ArrayBuffer constructor, ArrayBuffer
instances also have a [[ArrayBufferData]] internal data property and a
[[ArrayBufferByteLength]] internal data property.

15.13.6 _TypedArray_ Object Structures

For each constructor in the Table 35 is a separate _TypedArray_
constructor object, with corresponding prototype and instances. Each of
these _TypedArray_ constructor objects has the structure described
below, differing only in the name used as the constructor name instead
of _TypedArray_, in Table 35.

Table 35 – The _TypedArray_ Constructors

  ------------------------------------------------------------------------------------------------------------------------------
  Constructor Name    Element   Element Size   Conversion Operation   Description                            Equivalent C Type
                      Type                                                                                   
  ------------------- --------- -------------- ---------------------- -------------------------------------- -------------------
  Int8Array           Int8      1              ToInt8                 8-bit 2’s complement signed integer    signed char

  Uint8Array          Uint8     1              ToUint8                8-bit unsigned integer                 unsigned char

  Uint8ClampedArray   Uint8C    1              ToUint8Clamp           8-bit unsigned integer (clamped)       unsigned char

  Int16Array          Int16     2              ToInt16                16-bit 2’s complement signed integer   Short

  Uint16Array         Uint16    2              ToUint16               16-bit unsigned integer                unsigned short

  Int32Array          Int32     4              ToInt32                32-bit 2’s complement signed integer   Int

  Uint32Array         Uint32    4              ToUint32               32-bit unsigned integer                unsigned int

  Float32Array        Float32   4                                     32-bit IEEE floating point             Float

  Float64Array        Float64   8                                     64-bit IEEE floating point             Double
  ------------------------------------------------------------------------------------------------------------------------------

In the definitions below, references to _TypedArray_ should be replaced
with the appropriate constructor name from the above table. The phrase
“the element size in bytes” refers to the value in the Element Size
column of the table in the row corresponding to the constructor. The
phrase “element Type” refers to the value in the Element Type column for
that row.

15.13.6.1 _TypedArray_ Constructors Called as a Function

When a _TypedArray_ constructor is called as a function rather than as a
constructor, it initializes its THIS value with the internal state that
supports the _TYPEDARRAY_.PROTOTYPE internal methods. This permits super
invocation of the _TYPEDARRAY_ constructor by _TYPEDARRAY_ subclasses.
If the this value is undefined, it creates and initialises a new
_TypedArray_ object. Thus the function call _TYPEDARRAY_ (…) is
equivalent to the object creation expression NEW _TYPEDARRAY_ (…) with
the same arguments.

15.13.6.1.1 _TypedArray_ ( length )

_TypedArray_ called as function with argument _length_ performs the
following steps:

1.  Assert: Type(_length_) is not Object.

2.  Let _elementType_ be the string value of the Element Type value in
    Table 35 for this _TypedArray_ constructor.

3.  Let _O_ be the THIS value.

4.  If Type(_O_) is neither Object or Undefined, then throw a TYPEERROR
    exception

5.  If _O_ is UNDEFINED or does not have an [[ViewedArrayBuffer]]
    internal data property, then

    a.  Let _F_ be this function object.

    b.  Let _argumentsList_ be the _argumentsList_ argument of the
        [[Call]] internal method that invoked _F_.

    c.  Return the result of calling OrdinaryConstruct (_F_,
        _argumentsList_).

6.  If the value of _O’s_ [[ViewedArrayBuffer]] internal data property
    is not UNDEFINED, then throw a TYPEERROR exception,

7.  Let _numberLength_ be ToNumber(_length_).

8.  Let _elementLength_ be ToInteger(_numberLength_).

9.  ReturnIfAbrupt(_elementLength_).

10. If _numberLength_ ≠ _elementLength_ or _elementLength_ < 0, then
    throw a RANGEERROR exception.

11. Let _data_ be the result of calling
    AllocateArrayBuffer(%ArrayBuffer%).

12. ReturnIfAbrupt(_data_).

13. Let _elementSize_ be the Size Element value in Table 35 for this
    _TypedArray_ constructor.

14. Let _byteLength_ be _elementSize_ × _elementLength_.

15. Let _status_ be the result of SetArrayBufferData(_data_,
    _byteLength_)

16. ReturnIfAbrupt(_status_).

17. Set _O’s_ [[ViewedArrayBuffer]] to _data_.

18. Set _O_’s [[TypedArrayElementKind]] internal data property to
    _elementType_.

19. Set _O_’s [[ByteLength]] internal data property to _byteLength_.

20. Set _O_’s [[ByteOffset]] internal data property to 0.

21. Set _O_’s [[ArrayLength]] internal data property to _elementLength_.

22. Return _O_.

15.13.6.1.2 _TypedArray_ ( typedArray )

_TypedArray_ called as function with argument _typedArray_ performs the
following steps:

1.  Assert: Type(_typedArray_) is Object and _typedArray_ has a
    [[ViewedArrayBuffer]] internal data property.

2.  Let _srcArray_ be _typedArray_.

3.  Let _elementType_ be the string value of the Element Type value in
    Table 35 for this _TypedArray_ constructor.

4.  Let _O_ be the THIS value.

5.  If Type(_O_) is neither Object or Undefined, then throw a TYPEERROR
    exception

6.  If _O_ is UNDEFINED or does not have an [[ViewedArrayBuffer]]
    internal data property, then

    a.  Let _F_ be this function object.

    b.  Let _argumentsList_ be the _argumentsList_ argument of the
        [[Call]] internal method that invoked _F_.

    c.  Return the result of calling OrdinaryConstruct(_F_,
        _argumentsList_).

7.  If the value of _O’s_ [[ViewedArrayBuffer]] internal data property
    is not UNDEFINED, then throw a TYPEERROR exception,

8.  Let _elementLength_ be the value of _srcArray’s_ [[ArrayLength]]
    internal data property.

9.  Let _srcType_ be the value of _srcArray’s_ [[TypedArrayElementKind]]
    internal data property.

10. Let _srcData_ be the value of _srcArray’s_ [[ViewedArrayBuffer]]
    internal data property.

11. Let _data_ be the result of calling CloneArrayBuffer(_srcData_,
    _srcType,elementType_, _elementLength_).

12. ReturnIfAbrupt(_data_).

13. Let _elementSize_ be the Size Element value in Table 35 for this
    _TypedArray_ constructor.

14. Let _byteLength_ be _elementSize_ × _elementLength_.

15. Let _data_ be the result of SetArrayBufferData(_data_,
    _byteLength_).

16. ReturnIfAbrupt(_data_).

17. Set _O’s_ [[ViewedArrayBuffer]] to _data_.

18. Set _O_’s [[TypedArrayElementKind]] internal data property to
    _elementType_.

19. Set _O_’s [[ByteLength]] internal data property to _byteLength_.

20. Set _O_’s [[ByteOffset]] internal data property to 0.

21. Set _O_’s [[ArrayLength]] internal data property to _elementLength_.

22. Return _O_.

15.13.6.1.3 _TypedArray_ ( array )

_TypedArray_ called as function with argument _array_ performs the
following steps:

1.  Assert: Type(_array_) is Object and _array_ does not have either a
    [[ViewedArrayBuffer]] or a [[ArrayBufferData]] internal data
    property.

2.  Let _O_ be the THIS value.

3.  If Type(_O_) is neither Object or Undefined, then throw a TYPEERROR
    exception

4.  Let _srcArray_ be _array_.

5.  Let _elementType_ be the string value of the Element Type value in
    Table 35 for this _TypedArray_ constructor.

6.  If _O_ is UNDEFINED or does not have an [[ViewedArrayBuffer]]
    internal data property, then

    a.  Let _F_ be this function object.

    b.  Let _argumentsList_ be the _argumentsList_ argument of the
        [[Call]] internal method that invoked _F_.

    c.  Return the result of calling OrdinaryConstruct (_F_,
        _argumentsList_).

7.  If the value of _O’s_ [[ViewedArrayBuffer]] internal data property
    is not UNDEFINED, then throw a TYPEERROR exception,

8.  Let _arrayLength_ be the result of Get(_array_, "LENGTH").

9.  Let _numberLength_ be ToNumber(_arrayLength_).

10. Let _elementLength_ be ToInteger(_numberLength_).

11. ReturnIfAbrupt(_elementLength_).

12. If _numberLength_ ≠ _elementLength_ or _elementLength_ < 0, then
    throw a TYPEERROR exception.

13. Let _data_ be the result of calling
    AllocateArrayBuffer(%ArrayBuffer%).

14. ReturnIfAbrupt(_data_).

15. Let _elementSize_ be the Size Element value in Table 35 for this
    _TypedArray_ constructor.

16. Let _byteLength_ be _elementSize_ × _elementLength_.

17. Let _status_ be the result of SetArrayBufferData(_data_,
    _byteLength_)

18. Let _k_ be 0.

19. Repeat, while _k_ < _elementLength

    a.  Let _Pk_ be ToString(_k_).

    b.  Let _kValue_ be the result of Get(_O_, _Pk_).

    c.  Let _kNumber_ be ToNumber(_kValue_).

    d.  ReturnIfAbrupt(_kNumber_).

    e.  Perform SetValueInBuffer(_data_, _k_ _× elementSize_,
        _elementType_, _kNumber_).

    f.  Increase _k_ by 1.

20. Set _O’s_ [[ViewedArrayBuffer]] to _data_.

21. Set _O_’s [[TypedArrayElementKind]] internal data property to
    _elementType_.

22. Set _O_’s [[ByteLength]] internal data property to _byteLength_.

23. Set _O_’s [[ByteOffset]] internal data property to 0.

24. Set _O_’s [[ArrayLength]] internal data property to _elementLength_.

25. Return _O_.

15.13.6.1.4 _TypedArray_ ( buffer, byteOffset=0, length=undefined )

_TypedArray_ called as function with arguments _buffer_, _byteOffset_,
and _length_ performs the following steps:

1.  Assert: Type(_buffer_) is Object and _buffer_ has a
    [[ArrayBufferData]] internal data property.

2.  Let _O_ be the THIS value.

3.  If Type(_O_) is neither Object or Undefined, then throw a TYPEERROR
    exception

4.  Let _elementType_ be the String value of the Element Type value in
    Table 35 for this _TypedArray_ constructor.

5.  Let _elementSize_ be the Number value of the Element Size value in
    Table 35 for this _TypedArray_ constructor.

6.  Let _offset_ be ToInteger(_byteOffset_).

7.  ReturnIfAbrupt(_offset_).

8.  If _offset_ < 0, then throw a RANGEERROR exception.

9.  If _offset_ modulo _elementSize_ ≠ 0, then throw a RANGEERROR
    exception.

10. Let _bufferByteLength_ be the value of _buffer’s
    [[ArrayBufferByteLength]] internal data property.

11. If _offset_ + _elementSize_ ≥ _bufferByteLength_, then throw a
    RANGEERROR exception.

12. If _length_ is UNDEFINED, then

    a.  If _bufferByteLength_ modulo _elementSize_ ≠ 0, then throw a
        RANGEERROR exception.

    b.  Let _newByteLength_ be _bufferByteLength_ – _offset_.

13. Else,

    a.  Let _numberLength_ be ToNumber(_length_).

    b.  Let _newLength_ be ToInteger (_numberLength)._

    c.  ReturnIfAbrupt(_newLength_).

    d.  If _numberLength_ ≠ _newLength_ or _newLength_ < 0, then throw a
        RANGEERROR exception.

    e.  Let _newByteLength_ be _newLength_ × _elementSize_.

    f.  If offset+newByteLength > _bufferByteLength_, then throw a
        RANGEERROR exception.

14. If the value of _O’s_ [[ViewedArrayBuffer]] internal data property
    is not UNDEFINED, then throw a TYPEERROR exception,

15. Set _O’s_ [[ViewedArrayBuffer]] to _buffer_.

16. Set _O_’s [[TypedArrayElementKind]] internal data property to
    _elementType_.

17. Set _O_’s [[ByteLength]] internal data property to _newByteLength_.

18. Set _O_’s [[ByteOffset]] internal data property to _offset_.

19. Set _O_’s [[ArrayLength]] internal data property to _newByteLength
    _/ elementSize_ .

20. Return _O_.

15.13.6.1.5 _TypedArray_ ( binary data stuff )

15.13.6.2 The _TypedArray_ Constructors

When a _TypedArray_ function is called as part of a new expression, it
is a constructor: it initialises the newly created object.

The _TypedArray_ constructors is designed to be subclassable. They may
be used as the value of an EXTENDS clause of a class declaration.
Subclass constructors that intended to inherit the specified
_TypedArray_ behaviour must include a SUPER call to the _TypedArray_.

15.13.6.2.1 new _TypedArray_ (...args)

When a _TypedArray_ function called as part of a new expression with
argument lists _args_ performs the following steps:

1.  Let _F_ be the _TypedArray_ function object on which the NEW
    operator was applied.

2.  Let _argumentsList_ be the _argumentsList_ argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of OrdinaryConstruct(_F_, _argumentsList_).

If _TypedArray_ is implemented as an ordinary function object, its
[[Construct]] internal method will perform the above steps.

1.  a.  b.  c.  d.  e.  f.  g.  

2.  a.  b.  c.  d.  i.  ii. iii. iv. v.  vi. vii. viii. ix. x.  xi. 

    e.  i.  ii. iii. iv. v.  vi. vii. 1.  2.  3.  4.  

        viii. ix. 

15.13.6.3 Properties of the _TypedArray_ Constructors

The value of the [[Prototype]] internal data property of each
_TypedArray_ constructor is the Function prototype object (15.3.3).

Besides a LENGTH property (whose value is 3), each _TypedArray_
constructor has the following properties:

15.13.6.3.1 _TypedArray_.prototype

The initial value of _TypedArray_.prototype is the corresponding
_TypedArray_ prototype object (15.13.5.4).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

15.13.6.3.2 _TypedArray_[ @@create ] ( )

The @@create method of a _TypedArray_ function object _F_ performs the
following steps:

1.  Let _F_ be the THIS value.

2.  Let _proto_ be the result of GetPrototypeFromConstructor(_F_,
    "%_TypedArray_PROTOTYPE%").

3.  4.  5.  ReturnIfAbrupt(_proto_).

6.  a.  b.  i.  ii. 

    c.  

7.  Let _obj_ be the result of calling IntegerIndexedObjectCreate
    (_proto_).

8.  Add a [[ViewedArrayBuffer]] internal data property to _obj_ and set
    its initial value to UNDEFINED.

9.  Add a [[TypedArrayElementKind]] internal data property to _obj_ and
    set its initial value to UNDEFINED.

10. Add a [[ByteLength]] internal data property to _obj_ and set its
    initial value to 0.

11. Add a [[ByteOffset]] internal data property to _obj_ and set its
    initial value to 0.

12. Add a [[ArrayLength]] internal data property to _obj_ and set its
    initial value to 0.

13. 14. Return _obj_.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

15.13.6.4 Properties of the _TypedArray_ Prototype Object

The value of the [[Prototype]] internal data property of each
_TypedArray_ prototype object is the standard built-in Object prototype
object (15.2.4). The _TypedArray_ prototype objects are ordinary
objects. They do not have a [[ViewedArrayBuffer]] or or any other of the
internal data properties that are specific to _TypedArray_ instance
objects.

15.13.6.4.1 _TypedArray_.prototype.constructor

The initial value of _TypedArray_.prototype.constructor is the standard
built-in _TypedArray_ constructor.

15.13.6.4.2 _TypedArray_.prototype.BYTES_PER_ELEMENT

The value of _TypedArray_.prototype.BYTES_PER_ELEMENT is the Number
value of the Element Size value specified in Table 35 for _TypedArray_.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

15.13.6.4.3 get _TypedArray_.prototype.buffer

_TypedArray_.prototype.BUFFER is an accessor property whose set accessor
function is UNDEFINED. Its get accessor function performs the following
steps:

1.  Let _O_ be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(_O_).

3.  If _O_ does not have a [[ViewedArrayBuffer]] internal data property
    throw a TYPEERROR exception.

4.  Let _buffer_ be the value of _O_’s [[ViewedArrayBuffer]] internal
    data property.

5.  If _buffer_ is UNDEFINED, then throw a TYPEERROR exception.

6.  Return _buffer_.

15.13.6.4.4 get _TypedArray_.prototype.byteLength

_TypedArray_.prototype.BYTELENGTH is an accessor property whose set
accessor function is UNDEFINED. Its get accessor function performs the
following steps:

1.  Let _O_ be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(_O_).

3.  If _O_ does not have a [[ViewedArrayBuffer]] internal data property
    throw a TYPEERROR exception.

4.  Let _buffer_ be the value of _O_’s [[ViewedArrayBuffer]] internal
    data property.

5.  If _buffer_ is UNDEFINED, then throw a TYPEERROR exception.

6.  Let _size_ be the value of _O_’s [[ByteLength]] internal data
    property.

7.  Return _size_.

15.13.6.4.5 get _TypedArray_.prototype.byteOffset

_TypedArray_.prototype.BYTEOFFSET is an accessor property whose set
accessor function is UNDEFINED. Its get accessor function performs the
following steps:

1.  Let _O_ be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(_O_).

3.  If _O_ does not have a [[ViewedArrayBuffer]] internal data property
    throw a TYPEERROR exception.

4.  Let _buffer_ be the value of _O_’s [[ViewedArrayBuffer]] internal
    data property.

5.  If _buffer_ is UNDEFINED, then throw a TYPEERROR exception.

6.  Let _offset_ be the value of _O_’s [[ByteOffset]] internal data
    property.

7.  Return _offset_.

15.13.6.4.6 get _TypedArray_.prototype.length

_TypedArray_.prototype.LENGTH is an accessor property whose set accessor
function is UNDEFINED. Its get accessor function performs the following
steps:

1.  Let _O_ be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(_O_).

3.  If _O_ does not have a [[ViewedArrayBuffer]] internal data property
    throw a TYPEERROR exception.

4.  Let _buffer_ be the value of _O_’s [[ViewedArrayBuffer]] internal
    data property.

5.  If _buffer_ is UNDEFINED, then throw a TYPEERROR exception.

6.  Let _length_ be the value of _O_’s [[ArrayLength]] internal data
    property.

7.  Return _length_.

15.13.6.4.7 _TypedArray_.prototype.set(array, offset = 0 )

Set multiple values in this _TypedArray_, reading the values from the
object _array_. The optional _offset_ value indicates the first element
index in this _TypedArray_ where values are written. If omitted, it is
assumed to be 0.

1.  Assert: _typedArray_ does not have a [[ViewedArrayBuffer]] internal
    data property. If it does, the definition in 15.13.6.6.8 applies.

2.  Let _target_ be the result of calling ToObject with the THIS value
    as its argument.

3.  ReturnIfAbrupt(_target_).

4.  If _target_ does not have a [[ViewedArrayBuffer]] internal data
    property throw a TYPEERROR exception.

5.  Let _targetBuffer_ be the value of _target_’s [[ViewedArrayBuffer]]
    internal data property.

6.  If _targetBuffer_ is UNDEFINED, then throw a TYPEERROR exception.

7.  Let _targetLength_ be the value of _target_’s [[ArrayLength]]
    internal data property.

8.  Let _targetOffset_ be ToInteger (_offset_)

9.  ReturnIfAbrupt(_targe_t_Offset_).

10. If target_Offset_ < 0, then throw a RANGEERROR exception.

11. Let _targetType_ be the value of _target_’s
    [[TypedArrayElementKind]] internal data property.

12. Let _targetElementSize_ be the Number value of the Element Size
    value specified in Table 35 for _targetType_.

13. Let _targetByteOffset_ be the value of _target_’s [[ByteOffset]]
    internal data property.

14. Let _src_ be the result of ToObject(_array_).

15. ReturnIfAbrupt(_src_).

16. Let _srcLen_ be the result of Get(_src_, "LENGTH").

17. Let _numberLength_ be ToNumber(_srcLen_).

18. Let _srcLength_ be ToInteger(_numberLength_).

19. ReturnIfAbrupt(_srcLength_).

20. If _numberLength_ ≠ _srcLength_ or _srcLength_ < 0, then throw a
    TYPEERROR exception.

21. 22. 23. If _srcLength_ + _targetOffset_ > _targetLength_, then throw
    a RANGEERROR exception.

24. Let _targetByteIndex_ be _targetOffset_ × _targetElementSize_ +
    _targetByteOffset_.

25. Let _k_ be 0.

26. Let _limit_ be _targetByteIndex_ + _targetElementSize_ ×
    min(_srcLength_, _targetLength_ – _targetOffset_).

27. Repeat, while _targetByteIndex_ < _limit

    a.  Let _Pk_ be ToString(_k_).

    b.  Let _kValue_ be the result of Get(_src_, _Pk_).

    c.  Let _kNumber_ be ToNumber(_kValue_).

    d.  ReturnIfAbrupt(_kNumber_).

    e.  Perform SetValueInBuffer(_targetBuffer_, _k ×
        targetElementSize_, _targetType_, _kNumber_).

    f.  Set _k_ to _k_ + 1.

    g.  Set _targetByteIndex_ to _targetByteIndex_ +
        _targetElementSize_.

28. Return UNDEFINED.

15.13.6.4.8 _TypedArray_.prototype.set(typedArray, offset = 0 )

Set multiple values in this _TypedArray_, reading the values from the
_typedArray_ parameter object. The optional _offset_ value indicates the
first element index in this _TypedArray_ where values are written. If
omitted, it is assumed to be 0.

1.  Assert: _typedArray_ has a [[ViewedArrayBuffer]] internal data
    property. If it does not, the definition in 15.13.6.6.7 applies.

2.  Let _target_ be the result of calling ToObject with the THIS value
    as its argument.

3.  ReturnIfAbrupt(_target_).

4.  If _target_ does not have a [[ViewedArrayBuffer]] internal data
    property throw a TYPEERROR exception.

5.  Let _targetBuffer_ be the value of _target_’s [[ViewedArrayBuffer]]
    internal data property.

6.  If _targetBuffer_ is UNDEFINED, then throw a TYPEERROR exception.

7.  Let _targetLength_ be the value of _target_’s [[ArrayLength]]
    internal data property.

8.  9.  Let _targetOffset_ be ToInteger (_offset_)

10. ReturnIfAbrupt(_targetOffset_).

11. If target_Offset_ < 0, then throw a RANGEERROR exception.

12. Let _targetType_ be the value of _target_’s
    [[TypedArrayElementKind]] internal data property.

13. Let _targetElementSize_ be the Number value of the Element Size
    value specified in Table 36 for _targetType_.

14. Let _targetByteOffset_ be the value of _target_’s [[ByteOffset]]
    internal data property.

15. 16. 17. 18. Let _srcBuffer_ be the value of _typedArray_’s
    [[ViewedArrayBuffer]] internal data property.

19. If _srcBuffer_ is UNDEFINED, then throw a TYPEERROR exception.

20. Let _srcType_ be the value of _typedArray_’s
    [[TypedArrayElementKind]] internal data property.

21. Let _srcElementSize_ be the Number value of the Element Size value
    specified in Table 36 for _srcType_.

22. Let _srcLength_ be the value of _typedArray_’s [[ArrayLength]]
    internal data property.

23. Let _srcByteOffset_ be the value of _typedArray_’s [[ByteOffset]]
    internal data property.

24. If _srcLength_ + _targetOffset_ > _targetLength_, then throw a
    RANGEERROR exception.

25. 26. If SameValue(_srcBuffer_, _targetBuffer_) is TRUE, then

    a.  Let _srcBuffer_ be the result of calling
        CloneArrayBuffer(_srcBuffer_, _srcType,_ _srcType_,
        _srcLength_).

27. Let _targetByteIndex_ be _targetOffset_ × _targetElementSize_ +
    _targetByteOffset_.

28. Let _srcByteIndex_ be _srcByteOffset_.

29. Let _limit_ be _targetByteIndex_ + _targetElementSize_ ×
    min(_srcLength_, _targetLength_ – _targetOffset_).

30. Repeat, while _targetByteIndex_ < _limit

    a.  Let _value_ be the result of GetValueFromBuffer (_srcBuffer_,
        _srcByteIndex_, _srcType_).

    b.  Let _status_ be the result of SetValueInBuffer (_targetBuffer_,
        _targetByteIndex_, _targetType_, _value_).

    c.  Set _srcByteIndex_ to _srcByteIndex_ + _srcElementSize_.Return

    d.  Set _targetByteIndex_ to _targetByteIndex_ +
        _targetElementSize_.

31. Return UNDEFINED.

1.  2.  3.  a.  b.  

4.  5.  a.  

1.  

15.13.6.4.9 _TypedArray_.prototype.subarray(begin = 0, end = this.length )

Returns a new _TypedArray_ object whose element types is the same as
this _TypedArray_ and whose ArrayBuffer is the same as the ArrayBuffer
of this _TypedArray_, referencing the elements at _begin_, inclusive, up
to _end_, exclusive. If either _begin_ or _end_ is negative, it refers
to an index from the end of the array, as opposed to from the beginning.

1.  Let _O_ be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(_O_).

3.  If _O_ does not have a [[ViewedArrayBuffer]] internal data property
    throw a TYPEERROR exception.

4.  Let _buffer_ be the value of _O_’s [[ViewedArrayBuffer]] internal
    data property.

5.  If _buffer_ is UNDEFINED, then throw a TYPEERROR exception.

6.  7.  Let _srcLength_ be the value of _O_’s [[ArrayLength]] internal
    data property.

8.  Let _beginInt_ be ToInteger(_begin_)

9.  ReturnIfAbrupt(_beginInt_).

10. If _beginInt_ < 0, then let _beginInt_ be _srcLength_ + _beginInt_.

11. Let _beginIndex_ be min(_srcLength_, max(0, _beginInt_)).

12. If _end_ is UNDEFINED, then let _end_ be _srcLength_.

13. Let _endInt_ be ToInteger(_end_).

14. ReturnIfAbrupt(_endInt_).

15. If _endInt_ < 0, then let _endInt_ be _srcLength_ + _endInt_.

16. Let _endIndex_ be max(0,min(_srcLength_, _endInt_)).

17. If _endIndex_ < _beginIndex_, then let _endIndex_ be _beginIndex_.

18. Let _newLength_ be _endIndex_ - _beginIndex_.

19. Let _elementType_ be the value of _O_’s [[TypedArrayElementKind]]
    internal data property.

20. Let _elementSize_ be the Number value of the Element Size value
    specified in Table 35 for _elementType_.

1.  Let _srcByteOffset_ be the value of _O_’s [[ByteOffset]] internal
    data property.

2.  Let _beginByteOffset_ be _srcByteOffset_ + _beginIndex_ ×
    _elementSize_.

3.  Let _constructor_ be the result of Get(_O_, "CONSTRUCTOR").

4.  ReturnIfAbrupt(_constructor_).

5.  If IsConstructor(_constructor_) is FALSE, then throw a TYPEERROR
    exception.

6.  Let _argumentsList_ be a List consisting of _buffer_,
    _beginByteOffset_, and _newLength_.

7.  Return the result of calling the [[Construct]] internal method of
    _constructor_ with _argumentsList_ as the argument.

1.  

-   -   -   -   

15.13.6.4.10 _TypedArray_.prototype.@@elementGet ( index )

1.  Assert: Type(_index_) is number and index is an integer.

2.  Let _O_ be the result of calling ToObject with the THIS value as its
    argument.

3.  ReturnIfAbrupt(_O_).

4.  If _O_ does not have a [[ViewedArrayBuffer]] internal data property
    throw a TYPEERROR exception.

5.  Let _buffer_ be the value of _O_’s [[ViewedArrayBuffer]] internal
    data property.

6.  If _buffer_ is UNDEFINED, then throw a TYPEERROR exception.

7.  Let _length_ be the value of _O_’s [[ArrayLength]] internal data
    property.

8.  9.  10. If _index_ < 0 or _index_ ≥ _length_, then return UNDEFINED.

11. Let _offset_ be the value of _O_’s [[ByteOffset]] internal data
    property.

12. Let _elementSize_ be the Number value of the Element Size value
    specified in Table 36 for _TypedArray_.

13. Let _indexedPosition_ = (_index_ × _elementSize_) + _offset_.

14. Let _elementType_ be the value of _O_’s [[TypedArrayElementKind]]
    internal data property.

15. Return the result of GetValueFromBuffer(_buffer_, _indexedPosition_,
    _elementType_).

15.13.6.4.11 _TypedArray_.prototype.@@elementSet ( index, value )

1.  Assert: Type(_index_) is number and index is an integer.

2.  Let _O_ be the result of calling ToObject with the THIS value as its
    argument.

3.  ReturnIfAbrupt(_O_).

4.  If _O_ does not have a [[ViewedArrayBuffer]] internal data property
    throw a TYPEERROR exception.

5.  Let _buffer_ be the value of _O_’s [[ViewedArrayBuffer]] internal
    data property.

6.  If _buffer_ is UNDEFINED, then throw a TYPEERROR exception.

7.  Let _length_ be the value of _O_’s [[ArrayLength]] internal data
    property.

8.  9.  10. Let _numValue_ be ToNumber(_value)_.

11. ReturnIfAbrupt(_numValue_).

12. If _index_ < 0 or _index_ ≥ _length_, then return _numValue_.

13. Let _offset_ be the value of _O_’s [[ByteOffset]] internal data
    property.

14. Let _elementSize_ be the Number value of the Element Size value
    specified in Table 36 for _TypedArray_.

15. Let _indexedPosition_ = (_index_ × _elementSize_) + _offset_.

16. Let _elementType_ be the value of _O_’s [[TypedArrayElementKind]]
    internal data property.

17. Let _status_ be the result of SetValueInBuffer(_buffer_,
    _indexedPosition_, _elementType_, _numValue_).

18. ReturnIfAbrupt(_status_).

19. Return _numValue_.

15.13.6.4.12 _TypedArray_.prototype [ @@toStringTag ]

The initial value of the @@toStringTag property is the string value of
the name _TypedArray_.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

15.13.6.5 Properties of _TypedArray_ instances

_TypedArray_ instances are exotic Index Delegation objects. Each
_TypedArray_ instances inherits properties from the corresponding
_TypedArray_ prototype object. After initialisation by a _TypedArray
constructor, _TypedArray_ instances have the following internal data
properties: [[ViewedArrayBuffer]], [[TypedArrayElementKind]],
[[ByteLength]], [[ByteOffset]], and [[ArrayLength]].

1.  2.  3.  4.  5.  6.  7.  

1.  2.  3.  4.  

1.  2.  3.  4.  5.  6.  7.  8.  9.  

1.  2.  3.  4.  5.  6.  

15.13.7 DataView Objects

The following sections define DataViews is derived from the Kronos
specification. This material is a very early draft based upon the
strawman at
_http://wiki.ecmascript.org/doku.php?id=strawman:typed_arrays_ . This
material still needs significant work to fully integrate it into the ES6
spec. and also to integrate typed arrays with ES6 binary data.

Don’t waste a lot of time reviewing this material until it is closer to
a finished state.

15.13.7.1 The DataView Constructor Called as a Function

When DataView is called as a function rather than as a constructor, it
creates and initialises a new DataView object. Thus the function call
DataView(…) is equivalent to the object creation expression new
DataView(…) with the same arguments.

15.13.7.2 The DataView Constructor

When DataView is called as part of a new expression, it is a
constructor: it initialises the newly created object.

15.13.7.2.1 new DataView(buffer [, byteOffset [, byteLength]])

The [[Prototype]] internal data property of the newly constructed object
is set to the original DataView prototype object, the one that is the
initial value of DataView.prototype (15.13.3.3.1). The [[Class]]
internal data property of the newly constructed object is set to
“DataView”. The [[Extensible]] internal data property of the newly
constructed object is set to TRUE.

The remaining properties are set as follows:

1.  Let O be ToObject(buffer)

2.  If the [[Class]] internal data property of O is not “ArrayBuffer”,
    throw a TYPEERROR exception.

3.  Let byteOffset be the result of calling ToUInt32 on byteOffset, if
    provided, or else 0.

4.  Let bufferLength be the result of Get(_O_, "BYTELENGTH").

5.  Let byteLength be the result of calling ToUInt32 on byteLength, if
    provided, or else bufferLength – byteOffset.

6.  If byteOffset + byteLength is greater than bufferLength, throw a
    RANGEERROR exception.

7.  The byteLength property of the newly constructed object is set to
    byteLength.

8.  The buffer property of the newly constructed object is set to O.

9.  The byteOffset property of the newly constructed object is set to
    byteOffset.

15.13.7.3 Properties of the DataView Constructor

The value of the [[Prototype]] internal data property of the DataView
constructor is the Function prototype object (15.3.3).

Besides the internal properties and the length property (whose value is
3), the DataView constructor has the following properties:

15.13.7.3.1 DataView.prototype

The initial value of DataView.prototype is the DataView prototype object
(15.13.3.4).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

15.13.7.4 Properties of the DataView Prototype Object

The value of the [[Prototype]] internal data property of the DataView
prototype object is the standard built-in Object prototype object
(15.2.4). The [[Class]] internal data property of the newly constructed
object is set to “Object”. The [[Extensible]] internal data property of
the newly constructed object is set to TRUE.

The abstract operation GetValue(byteOffset, isLittleEndian, type) used
by functions on DataView instances is defined as follows:

1.  Let byteOffsetInt be ToUInt32(byteOffset)

2.  Let totalOffset be byteOffsetInt plus the result of Get(this,
    "BYTEOFFSET").

3.  Let byteLength be the result of Get(this, "BYTELENGTH").

4.  If totalOffset ≥ byteLength, throw a RANGEERROR exception.

5.  Let value be the result of calling the GetValueFromBuffer abstract
    operation (2.5.2) with arguments this.buffer.[[NativeBuffer]],
    totalOffset, 0 and type.

6.  Return value

The abstract operation SetValue(byteOffset, isLittleEndian, type, value)
used by functions on DataView instances is defined as follows:

1.  Let byteOffsetInt be ToUInt32(byteOffset)

2.  Let totalOffset be byteOffsetInt plus the result of Get(this,
    "BYTEOFFSET").

3.  Let byteLength be the result of Get(this, "BYTELENGTH").

4.  If totalOffset ≥ byteLength, throw a RANGEERROR exception.

5.  Let value be the result of calling the SetValueInBuffer abstract
    operation (2.5.2) with arguments this.buffer.[[NativeBuffer]],
    totalOffset, 0, value and type.

6.  Return value

15.13.7.4.1 DataView.prototype.constructor

The initial value of DataView.prototype.constructor is the standard
built-in DataView constructor.

15.13.7.4.2 DataView.prototype.getInt8(byteOffset)

Gets the Int8 value at offset byteOffset in the DataView.

1.  Let O be ToObject(this)

2.  If the [[Class]] internal data property of O is not “DataView”,
    throw a TYPEERROR exception.

3.  Return GetValue(byteOffset, TRUE, Int8)

15.13.7.4.3 DataView.prototype.getUint8(byteOffset)

Gets the UInt8 value at offset byteOffset in the DataView.

1.  Let O be ToObject(this)

2.  If the [[Class]] internal data property of O is not “DataView”,
    throw a TYPEERROR exception.

3.  Return GetValue(byteOffset, TRUE, UInt8)

15.13.7.4.4 DataView.prototype.getInt16(byteOffset, littleEndian)

Gets the Int16 value at offset byteOffset in the DataView, using the
provided endianness.

1.  Let O be ToObject(this)

2.  Let isLittleEndian be ToBoolean(littleEndian) if provided, else
    FALSE

3.  If the [[Class]] internal data property of O is not “DataView”,
    throw a TYPEERROR exception.

4.  Return GetValue(byteOffset, isLittleEndian, Int16)

15.13.7.4.5 DataView.prototype.getUint16(byteOffset, littleEndian)

Gets the Uint16 value at offset byteOffset in the DataView, using the
provided endianness.

1.  Let O be ToObject(this)

2.  Let isLittleEndian be ToBoolean(littleEndian) if provided, else
    FALSE

3.  If the [[Class]] internal data property of O is not “DataView”,
    throw a TYPEERROR exception.

4.  Return GetValue(byteOffset, isLittleEndian, Uint16)

15.13.7.4.6 DataView.prototype.getInt32(byteOffset, littleEndian)

Gets the Int32 value at offset byteOffset in the DataView, using the
provided endianness.

1.  Let O be ToObject(this)

2.  Let isLittleEndian be ToBoolean(littleEndian) if provided, else
    FALSE

3.  If the [[Class]] internal data property of O is not “DataView”,
    throw a TYPEERROR exception.

4.  Return GetValue(byteOffset, isLittleEndian, Int32)

15.13.7.4.7 DataView.prototype.getUint32(byteOffset, littleEndian)

Gets the Uint32 value at offset byteOffset in the DataView, using the
provided endianness.

1.  Let O be ToObject(this)

2.  Let isLittleEndian be ToBoolean(littleEndian) if provided, else
    FALSE

3.  If the [[Class]] internal data property of O is not “DataView”,
    throw a TYPEERROR exception.

4.  Return GetValue(byteOffset, isLittleEndian, Uint32)

15.13.7.4.8 DataView.prototype.getFloat32(byteOffset, littleEndian)

Gets the Float32 value at offset byteOffset in the DataView, using the
provided endianness.

1.  Let O be ToObject(this)

2.  Let isLittleEndian be ToBoolean(littleEndian) if provided, else
    FALSE

3.  If the [[Class]] internal data property of O is not “DataView”,
    throw a TYPEERROR exception.

4.  Return GetValue(byteOffset, isLittleEndian, Float32)

15.13.7.4.9 DataView.prototype.getFloat64(byteOffset, littleEndian)

Gets the Float64 value at offset byteOffset in the DataView, using the
provided endianness.

1.  Let O be ToObject(this)

2.  Let isLittleEndian be ToBoolean(littleEndian) if provided, else
    FALSE

3.  If the [[Class]] internal data property of O is not “DataView”,
    throw a TYPEERROR exception.

4.  Return GetValue(byteOffset, isLittleEndian, Float64)

15.13.7.4.10 DataView.prototype.setInt8(byteOffset, value)

Sets the Int8 value at offset byteOffset in the DataView.

1.  Let O be ToObject(this)

2.  If the [[Class]] internal data property of O is not “DataView”,
    throw a TYPEERROR exception.

3.  Return SetValue(byteOffset, TRUE, Int8, ToInt8(value) )

15.13.7.4.11 DataView.prototype.setUint8(byteOffset, value)

Sets the Uint8 value at offset byteOffset in the DataView.

1.  Let O be ToObject(this)

2.  If the [[Class]] internal data property of O is not “DataView”,
    throw a TYPEERROR exception.

3.  Return SetValue(byteOffset, TRUE, Uint8, ToUint8(value) )

15.13.7.4.12 DataView.prototype.setInt16(byteOffset, value, littleEndian)

Sets the Int16 value at offset byteOffset in the DataView.

1.  Let O be ToObject(this)

2.  Let isLittleEndian be ToBoolean(littleEndian) if provided, else
    FALSE

3.  If the [[Class]] internal data property of O is not “DataView”,
    throw a TYPEERROR exception.

4.  Return SetValue(byteOffset, isLittleEndian, Int16, ToInt16(value))

15.13.7.4.13 DataView.prototype.setUint16(byteOffset, value, littleEndian)

Sets the Uint16 value at offset byteOffset in the DataView.

1.  Let O be ToObject(this)

2.  Let isLittleEndian be ToBoolean(littleEndian) if provided, else
    FALSE

3.  If the [[Class]] internal data property of O is not “DataView”,
    throw a TYPEERROR exception.

4.  Return SetValue(byteOffset, isLittleEndian, Uint16, ToUint16(value))

15.13.7.4.14 DataView.prototype.setInt32(byteOffset, value, littleEndian)

Sets the Int32 value at offset byteOffset in the DataView.

1.  Let O be ToObject(this)

2.  Let isLittleEndian be ToBoolean(littleEndian) if provided, else
    FALSE

3.  If the [[Class]] internal data property of O is not “DataView”,
    throw a TYPEERROR exception.

4.  Return SetValue(byteOffset, isLittleEndian, Int32, ToInt32(value))

15.13.7.4.15 DataView.prototype.setUint32(byteOffset, value, littleEndian)

Sets the Uint32 value at offset byteOffset in the DataView.

1.  Let O be ToObject(this)

2.  Let isLittleEndian be ToBoolean(littleEndian) if provided, else
    FALSE

3.  If the [[Class]] internal data property of O is not “DataView”,
    throw a TYPEERROR exception.

4.  Return GetValue(byteOffset, isLittleEndian, Uint32, ToUint32(value))

15.13.7.4.16 DataView.prototype.setFloat32(byteOffset, value, littleEndian)

Sets the Float32 value at offset byteOffset in the DataView.

1.  Let O be ToObject(this)

2.  Let isLittleEndian be ToBoolean(littleEndian) if provided, else
    FALSE

3.  If the [[Class]] internal data property of O is not “DataView”,
    throw a TYPEERROR exception.

4.  Return SetValue(byteOffset, isLittleEndian, Float32,
    ToFloat32(value))

15.13.7.4.17 DataView.prototype.setUint16(byteOffset, value, littleEndian)

Sets the Float64 value at offset byteOffset in the DataView.

1.  Let O be ToObject(this)

2.  Let isLittleEndian be ToBoolean(littleEndian) if provided, else
    FALSE

3.  If the [[Class]] internal data property of O is not “DataView”,
    throw a TYPEERROR exception.

4.  Return SetValue(byteOffset, isLittleEndian, Float64,
    ToFloat64(value))

15.13.7.5 Propeties of DataView Instances

DataView instances inherit properties from the DataView prototype object
and their [[Class]] internal data property value is “DataView”. DataView
instances also have the following properties.

15.13.7.5.1 byteLength

The value of the byteLength property is the length of the DataView
object, which was fixed at creation. This property has attributes {
[[Writable]]: FALSE, [[Enumerable]]: FALSE, [[Configurable]]:FALSE }.

15.13.7.5.2 buffer

The value of the buffer property is the length of the DataView object,
which was fixed at creation. This property has attributes {
[[Writable]]: FALSE, [[Enumerable]]: FALSE, [[Configurable]]:FALSE }.

15.13.7.5.3 byteOffset

The value of the byteOffset property is the length of the DataView
object, which was fixed at creation. This property has attributes {
[[Writable]]: FALSE, [[Enumerable]]: FALSE, [[Configurable]]:FALSE }.


15.14 Map Objects

Map objects are collections of key/value pairs where both the keys and
values may be arbitrary ECMAScript language values. A distinct key value
may only occur in one key/value pair within the Map’s collection.
Distinct key values as discriminated using the a comparision algorithm
that is selected when the Map is created.

A Map object can iterate its elements in insertion order. Map object
must be implemented using either hash tables or other mechanisms that,
on average, provide access times that are sublinear on the number of
elements in the collection. The data structures used in this Map objects
specification is only intended to describe the required observable
semantics of Map objects. It is not intended to be a viable
implementation model.

1.  2.  3.  4.  a.  b.  c.  d.  e.  f.  g.  h.  

5.  6.  7.  8.  a.  b.  c.  d.  e.  f.  g.  h.  i.  j.  

15.14.1 The Map Constructor Called as a Function

When MAP is called as a function rather than as a constructor, it
initializes its THIS value with the internal state necessary to support
the MAP.PROTOTYPE internal methods. The MAP constructor is designed to
be subclassable. It may be used as the value in an EXTENDS clause of a
class definition. Subclass constructors that intend to inherit the
specified MAP behaviour must include a SUPER call to MAP.

15.14.1.1 Map (iterable = undefined , comparator = undefined ) 

When the MAP function is called with optional arguments _iterable_ and
_comparator_ the following steps are taken:

1.  Let _map_ be the THIS value.

2.  If Type(_map_) is not Object then, throw a TYPEERROR exception.

3.  If _map_ does not have a [[MapData]] internal data property, then
    throw a TYPEERROR exception.

4.  If _map’s_ [[MapData]] internal data property is not UNDEFINED, then
    throw a TYPEERROR exception.

5.  a.  

6.  7.  8.  9.  If _iterable_ is not present, let _iterable_ be
    UNDEFINED.

10. If _iterable_ is either UNDEFINED or NULL, then let _itr_ be
    UNDEFINED.

11. Else,

    a.  Let _hasValues_ be the result of HasProperty(_iterable_,
        "ENTRIES").

    b.  ReturnIfAbrupt(_hasValues_).

    c.  If _hasValues_ is TRUE, then

        i.  Let _itr_ be the result of Invoke(_iterable_, "ENTRIES").

    d.  Else,

        i.  Let _iterator_ be the well-known symbol @@iterator.

        ii. Let _itr_ be the result of Invoke(_iterable_, _iterator_).

    e.  ReturnIfAbrupt(_itr_).

    f.  ReturnIfAbrupt(_itr_).

    g.  Let _adder_ be the result of Get(_map_, "SET").

    h.  ReturnIfAbrupt(_adder_).

    i.  If IsCallable(_adder_) is FALSE, throw a TYPEERROR Exception.

12. If _comparator_ is not UNDEFINED, then

    a.  If _comparator_ is not "IS", then throw a RANGEERROR Exception.

13. Set _map’s_ [[MapData]] internal data property to a new empty List.

14. Set _map’s_ [[MapComparator]] internal data property to
    _comparator_.

15. If _itr_ is UNDEFINED, then return _map_.

16. Repeat

    a.  Let _next_ be the result of Invoke(_itr_, "NEXT").

    b.  ReturnIfAbrupt(_next_).

    c.  If Type(_next_) is not Object, then throw a TYPEERROR exception.

    d.  Let _done_ be IteratorComplete(_next_).

    e.  ReturnIfAbrupt(_done_).

    f.  If _done_ is TRUE, then return NormalCompletion(_map_).

    g.  h.  i.  Let _nextItem_ be IteratorValue(_next_).

    j.  ReturnIfAbrupt(_nextItem_).

    k.  Let _k_ be the result of Get(_nextItem_, "0").

    l.  ReturnIfAbrupt(_k_).

    m.  Let _v_ be the result of Get(_nextItem_, "1").

    n.  ReturnIfAbrupt(_v_).

    o.  Let _status_ be the result of calling the [[Call]] internal
        method of _adder_ with _map_ as _thisArgument_ and a List whose
        elements are _k_ and _v_ as _argumentsList_.

17. a.  ReturnIfAbrupt(_status_).

1.  

NOTE If the parameter _iterable_ is present, it is expected to be an
object that implements an @@iterator method that returns an iterator
object that produces two element array-like objects whose first element
is a value that will be used as an Map key and whose second element is
the value to associate with that key.

15.14.2 The Map Constructor

When MAP is called as part of a NEW expression it is a constructor: it
initialises a newly created object.

The MAP constructor is designed to be subclassable. It may be used as
the value of an EXTENDS clause of a class declaration. Subclass
constructors that intended to inherit the specified MAP behaviour must
include a SUPER call to MAP.

15.14.2.1 new Map ( ... args )

MAP called as part of a new expression with argument list _args_
performs the following steps:

1.  Let _F_ be the Map function object on which the NEW operator was
    applied.

2.  Let _argumentsList_ be the _argumentsList_ argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of OrdinaryConstruct(_F_, _argumentsList_).

If Map is implemented as an ordinary function object, its [[Construct]]
internal method will perform the above steps.

1.  2.  3.  4.  5.  

15.14.3 Properties of the Map Constructor

The value of the [[Prototype]] internal data property of the Map
constructor is the Function prototype object (15.3.3).

Besides the LENGTH property (whose value is 0), the Map constructor has
the following property:

15.14.3.1 Map.prototype

The initial value of MAP.PROTOTYPE is the Map prototype object
(15.14.4).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

15.14.3.2 Map[ @@create ] ( )

The @@create method of a Map function object _F_ performs the following
steps:

1.  Let _F_ be the THIS value.

2.  Let _obj_ be the result of calling
    OrdinaryCreateFromConstructor(_F_, "%MAPPROTOTYPE%", ( [[MapData]] ,
    [[MapComparator]]) ).

3.  4.  5.  Return _obj_.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

15.14.4 Properties of the Map Prototype Object

The value of the [[Prototype]] internal data property of the Map
prototype object is the standard built-in Object prototype object
(15.2.4). The Map prototype object is an ordinary object. It does not
have a [[MapData]] or a [[MapComparator]] internal data property.

15.14.4.1 Map.prototype.constructor

The initial value of MAP.PROTOTYPE.CONSTRUCTOR is the built-in MAP
constructor.

15.14.4.2 Map.prototype.clear ()

The following steps are taken:

1.  Let _M_ be the THIS value.

2.  If Type(_M)_ is not Object, then throw a TYPEERROR exception.

3.  If _M_ does not have a [[MapData]] internal data property throw a
    TYPEERROR exception.

4.  If _M’s_ [[MapData]] internal data property is UNDEFINED, then throw
    a TYPEERROR exception.

5.  Let _entries_ be the List that is the value of _M_’s [[MapData]]
    internal data property.

6.  Repeat for each Record {[[key]], [[value]]} _p_ that is an element
    of _entries,_

    a.  Set _p_.[[key]] to empty_._

    b.  Set _p_.[[value]] to empty_._

7.  8.  Return UNDEFINED.

15.14.4.3 Map.prototype.delete ( key )

The following steps are taken:

1.  Let _M_ be the THIS value.

2.  If Type(_M)_ is not Object, then throw a TYPEERROR exception.

3.  If _M_ does not have a [[MapData]] internal data property throw a
    TYPEERROR exception.

4.  If _M’s_ [[MapData]] internal data property is UNDEFINED, then throw
    a TYPEERROR exception.

5.  If _M’s_ [[MapComparator]] internal data property is UNDEFINED, then
    let _same_ be the abstract operation SameValueZero.

6.  Else, let _same_ be the abstract operation SameValue.

7.  Let _entries_ be the List that is the value of _M_’s [[MapData]]
    internal data property.

8.  Repeat for each Record {[[key]], [[value]]} _p_ that is an element
    of _entries,_

    a.  If _same_(_p_.[[key]], _key_), then

        i.  Set _p_.[[key]] to empty_._

        ii. Set _p_.[[value]] to empty_._

        iii. Return TRUE.

9.  Return FALSE.

15.14.4.4 Map.prototype.forEach ( callbackfn , thisArg = undefined )

_callbackfn_ should be a function that accepts three arguments. FOREACH
calls _callbackfn_ once for each key/value pair present in the map
object, in key insertion order. _callbackfn_ is called only for keys of
the map which actually exist; it is not called for keys that have been
deleted from the map.

If a _thisArg_ parameter is provided, it will be used as the THIS value
for each invocation of _callbackfn_. If it is not provided, UNDEFINED is
used instead.

NOTE If _callbackfn_ is an Arrow Function, THIS was lexically bound when
the function was created so _thisArg_ will have no effect.

_callbackfn_ is called with three arguments: the value of the item, the
key of the item, and the Map object being traversed.

FOREACH does not directly mutate the object on which it is called but
the object may be mutated by the calls to _callbackfn_.

NOTE Each key is visited only once with the value that is current at the
time of the visit. If the value associated with a key is modified after
it has been visited, it is not re-visited. Keys that are deleted after
the call to FOREACH begins and before being visited are not visited. New
keys added, after the call to FOREACH begins are visited.

When the FOREACH method is called with one or two arguments, the
following steps are taken:

1.  Let _M_ be the THIS value.

2.  If Type(_M)_ is not Object, then throw a TYPEERROR exception.

3.  If _M_ does not have a [[MapData]] internal data property throw a
    TYPEERROR exception.

4.  If _M’s_ [[MapData]] internal data property is UNDEFINED, then throw
    a TYPEERROR exception.

5.  If IsCallable(_callbackfn_) is FALSE, throw a TYPEERROR exception.

6.  If _thisArg_ was supplied, let _T_ be _thisArg_; else let _T_ be
    UNDEFINED.

7.  Let _entries_ be the List that is the value of _M_’s [[MapData]]
    internal data property.

8.  Repeat for each Record {[[key]], [[value]]} _e_ that is an element
    of _entries,_ in original key insertion order

    a.  If _e_.[[key]] is not empty, then

        i.  Let _funcResult_ be the result of calling the [[Call]]
            internal method of _callbackfn_ with _T_ as _thisArgument_
            and a List containing _e_.[[value]], _e_.[[key]], and _M_ as
            _argumentsList_.

        ii. ReturnIfAbrupt(_funcResult_).

9.  Return UNDEFINED.

The LENGTH property of the FOREACH method is 1.

15.14.4.5 Map.prototype.get ( key )

The following steps are taken:

1.  Let _M_ be the THIS value.

2.  If Type(_M)_ is not Object, then throw a TYPEERROR exception.

3.  If _M_ does not have a [[MapData]] internal data property throw a
    TYPEERROR exception.

4.  If _M’s_ [[MapData]] internal data property is UNDEFINED, then throw
    a TYPEERROR exception.

5.  Let _entries_ be the List that is the value of _M_’s [[MapData]]
    internal data property.

6.  If _M’s_ [[MapComparator]] internal data property is UNDEFINED, then
    let _same_ be the abstract operation SameValueZero.

7.  Else, let _same_ be the abstract operation SameValue.

8.  Repeat for each Record {[[key]], [[value]]} _p_ that is an element
    of _entries,_

    a.  If _same_(_p_.[[key]], _key_), then return _p_.[[value]]

9.  Return UNDEFINED.

15.14.4.6 Map.prototype.has ( key )

The following steps are taken:

1.  Let _M_ be the THIS value.

2.  If Type(_M)_ is not Object, then throw a TYPEERROR exception.

3.  If _M_ does not have a [[MapData]] internal data property throw a
    TYPEERROR exception.

4.  If _M’s_ [[MapData]] internal data property is UNDEFINED, then throw
    a TYPEERROR exception.

5.  Let _entries_ be the List that is the value of _M_’s [[MapData]]
    internal data property.

6.  If _M’s_ [[MapComparator]] internal data property is UNDEFINED, then
    let _same_ be the abstract operation SameValueZero.

7.  Else, let _same_ be the abstract operation SameValue.

8.  Repeat for each Record {[[key]], [[value]]} _p_ that is an element
    of _entries,_

    a.  If _same_(_p_.[[key]], _key_), then return TRUE_._

9.  Return FALSE.

15.14.4.7 Map.prototype.entries ( )

The following steps are taken:

1.  Let _M_ be the THIS value.

2.  If Type(_M)_ is not Object, then throw a TYPEERROR exception.

3.  Return the result of calling the CreateMapIterator abstract
    operation with arguments _M_ and "KEY+VALUE".

15.14.4.8 Map.prototype.keys ( )

The following steps are taken:

1.  Let _M_ be the THIS value.

2.  If Type(_M)_ is not Object, then throw a TYPEERROR exception.

3.  Return the result of calling the CreateMapIterator abstract
    operation with arguments _M_ and "KEY".

15.14.4.9 Map.prototype.set ( key , value )

The following steps are taken:

1.  Let _M_ be the THIS value.

2.  If Type(_M)_ is not Object, then throw a TYPEERROR exception.

3.  If _M_ does not have a [[MapData]] internal data property throw a
    TYPEERROR exception.

4.  If _M’s_ [[MapData]] internal data property is UNDEFINED, then throw
    a TYPEERROR exception.

5.  Let _entries_ be the List that is the value of _M_’s [[MapData]]
    internal data property.

6.  If _M’s_ [[MapComparator]] internal data property is UNDEFINED, then
    let _same_ be the abstract operation SameValueZero.

7.  Else, let _same_ be the abstract operation SameValue.

8.  Repeat for each Record {[[key]], [[value]]} _p_ that is an element
    of _entries,_

    a.  If _same_(_p_.[[key]], _key_), then

        i.  Set _p_.[[value]] to _value._

        ii. Return _M_.

9.  Let _p_ be the Record {[[key]]: _key_, [[value]]: _value_}

10. Append _p_ as the last element of _entries_.

11. Return _M_.

15.14.4.10 get Map.prototype.size 

Map.prototype.size is an accessor property whose set accessor function
is UNDEFINED. Its get accessor function performs the following steps:

1.  Let _M_ be the THIS value.

2.  If Type(_M)_ is not Object, then throw a TYPEERROR exception.

3.  If _M_ does not have a [[MapData]] internal data property throw a
    TYPEERROR exception.

4.  If _M’s_ [[MapData]] internal data property is UNDEFINED, then throw
    a TYPEERROR exception.

5.  Let _entries_ be the List that is the value of _M_’s [[MapData]]
    internal data property.

6.  Let _count_ be 0.

7.  For each Record {[[key]], [[value]]} _p_ that is an element of
    _entries_

    a.  If _p_.[[key]] is not empty then

        i.  Set _count_ to _count_+1.

8.  Return _count_.

15.14.4.11 Map.prototype.values ( )

The following steps are taken:

1.  Let _M_ be the THIS value.

2.  If Type(_M)_ is not Object, then throw a TYPEERROR exception.

3.  Return the result of calling the CreateMapIterator abstract
    operation with arguments _M_ and "VALUE".

15.14.4.12 Map.prototype.@@iterator ( )

The initial value of the @@iterator property is the same function object
as the initial value of the ENTRIES property.

15.14.4.13 Map.prototype [ @@toStringTag ]

The initial value of the @@toStringTag property is the string value
"MAP".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

15.14.5 Properties of Map Instances

Map instances inherit properties from the Map prototype. After
initialisation by the Map constructor, Map instances also have a
[[MapData]] internal data property and a [[MapComparator]] internal data
property.

15.14.6 Map Iterator Object Structure

A Map Iterator is an object, with the structure defined below, that
represent a specific iteration over some specific Map instance object.
There is not a named constructor for Map Iterator objects. Instead, map
iterator objects are created by calling certain methods of Map instance
objects.

15.14.6.1 CreateMapIterator Abstract Operation

Several methods of Map objects return Iterator objects. The abstract
operation CreateMapIterator with arguments _map_ and _kind_ is used to
create and such iterator objects. It performs the following steps:

1.  Let _M_ be the result of calling ToObject(_map_).

2.  ReturnIfAbrupt(_M_).

3.  If _M_ does not have a [[MapData]] internal data property throw a
    TYPEERROR exception.

4.  Let _entries_ be the List that is the value of _M_’s [[MapData]]
    internal data property.

5.  Let _itr_ be the result of ObjectCreate(%MapIteratorPrototype%,
    ([[Map]], [[MapNextIndex]], [[MapIterationKind]])).

6.  Set _itr’s_ [[Map]] internal data property to _M_.

7.  Set _itr’s_ [[MapNextIndex]] internal data property to 0.

8.  Set _itr’s_ [[MapIterationKind]] internal data property to _kind_.

9.  Return _itr_.

15.14.6.2 The Map Iterator Prototype

All Map Iterator Objects inherit properties from a common Map Iterator
Prototype object. The [[Prototype]] internal data property of the Map
Iterator Prototype is the %ObjectPrototype% intrinsic object. In
addition, the Map Iterator Prototype as the following properties:

15.14.6.2.1 _MapIterator_.prototype.constructor

15.14.6.2.2 _MapIterator_.prototype.next( )

1.  Let _O_ be the THIS value.

2.  If Type(_O_) is not Object, throw a TYPEERROR exception.

3.  If _O_ does not have all of the internal properties of a Map
    Iterator Instance (15.14.7.1.2), throw a TYPEERROR exception.

4.  Let _m_ be the value of the [[Map]] internal data property of _O_.

5.  Let _index_ be the value of the [[MapNextIndex]] internal data
    property of _O_.

6.  Let _itemKind_ be the value of the [[MapIterationKind]] internal
    data property of _O_.

7.  Assert: _m_ has a [[MapData]] internal data property and _m_ has
    been initialized so the value of [[MapData]] is not UNDEFINED.

8.  Let _entries_ be the List that is the value of the [[MapData]]
    internal data property of _m_.

9.  Repeat while _index_ is less than the total number of element of
    _entries_. The number of elements must be redetermined each time
    this method is evaluated.

    a.  Let _e_ be the Record {[[key]], [[value]]} at 0-origined
        insertion position _index_ of _entries_.

    b.  Set _index_ to _index_+1;

    c.  Set the [[MapNextIndex]] internal data property of _O_ to
        _index_.

    d.  If _e_.[[key]] is not empty, then

        i.  If _itemKind_ is "KEY" then, let _result_ be _e_.[[key]].

        ii. Else if _itemKind_ is "VALUE" then, let _result_ be
            _e_.[[value]].

        iii. Else,

            1.  Assert: _itemKind_ is "KEY+VALUE".

            2.  Let _result_ be the result of the abstract operation
                ArrayCreate with argument 2.

            3.  Assert: _result_ is a new, well-formed Array object so
                the following operations will never fail.

            4.  Call CreateOwnDataProperty(_result_, "0", _e_.[[key]]) .

            5.  Call CreateOwnDataProperty(_result_, "1",
                _e_.[[value]]).

        iv. Return CreateItrResultObject(_result_, FALSE).

10. Return CreateItrResultObject(UNDEFINED, TRUE).

15.14.6.2.3 _MapIterator_.prototype.@@iterator ( )

The following steps are taken:

1.  Return the THIS value.

15.14.6.2.4 _MapIterator_.prototype.@@toStringTag

The initial value of the @@toStringTag property is the string value "MAP
ITERATOR".

15.14.6.3 Properties of Map Iterator Instances

Map Iterator instances inherit properties from the Map Iterator
prototype (the intrinsic, %MapIteratorPrototype%.) Map Iterator
instances are initially created with the internal properties described
in Table 36.

Table 36 — Internal Data Properties of Map Iterator Instances

  ----------------------------- ------------------------------------------------------------------------------------------------------------------------------------------------
  INTERNAL DATA PROPERTY NAME   DESCRIPTION
  [[Map]]                       The Map object that is being iterated.
  [[MapNextIndex]]              The integer index of the next Map data element to be examined by this iteration.
  [[MapIterationKind]]          A string value that identifies what is to be returned for each element of the iteration. The possible values are: "KEY", "VALUE", "KEY+VALUE".
  ----------------------------- ------------------------------------------------------------------------------------------------------------------------------------------------


15.15 WeakMap Objects

WeakMap objects are collections of key/value pairs where the keys are
ECMAScript objects and values may be arbitrary ECMAScript language
values. A WeakMap may be queried to see if it contains an key/value pair
with a specific key, but no mechanisms is provided for enumerating the
objects it holds as keys. If an object that is being used as the key of
a WeakMap key/value pair is only reachable by following a chain of
references that start within that WeakMap, then that key/value pair is
inaccessible and is automatically removed from the WeakMap. WeakMap
implementations must detect and remove such key/value pairs and any
associated resources.

An implementation may impose an arbitrarily determined latency between
the time a key/value pair of a WeakMap becomes inaccessible and the time
when the key/value pair is removed from the WeakMap. If this latency was
observable to ECMAScript program, it would be a source of indeterminacy
that could impact program execution.  For that reason, an ECMAScript
implementation must not provide any means to observe a key of a WeakMap
that does not require the observer to present the observed key. 

WeakMap objects must be implemented using either hash tables or other
mechanisms that, on average, provide access times that are sublinear on
the number of key/value pairs in the collection. The data structures
used in this WeakMap objects specification are only intended to describe
the required observable semantics of WeakMap objects. It is not intended
to be a viable implementation model.

NOTE WeakMap are intended to provide a mechanism for dynamically
associating state with an object in a manner that does not “leak” memory
resources if, in the absence of the WeakMap, the object otherwise became
inaccessible and subject to resource reclamation by the implementation’s
garbage collection mechanisms. Achieving this characteristic requires
coordination between the WeakMap implementation and the garbage
collector. The following references describe mechanism that may be
useful to implementations of WeakMap:

  Barry Hayes. 1997. Ephemerons: a new finalization mechanism. In
  _Proceedings of the 12th ACM SIGPLAN conference on Object-oriented
  programming, systems, languages, and applications (OOPSLA '97)_, A.
  Michael Berman (Ed.). ACM, New York, NY, USA, 176-183.
  _http://doi.acm.org/10.1145/263698.263733_

  Alexandra Barros, Roberto Ierusalimschy, Eliminating Cycles in Weak
  Tables. Journal of Universal Computer Science - J.UCS , vol. 14, no.
  21, pp. 3481-3497, 2008.
  _http://www.jucs.org/jucs_14_21/eliminating_cycles_in_weak_

1.  2.  3.  4.  a.  b.  c.  d.  e.  f.  g.  h.  

5.  6.  7.  8.  a.  b.  c.  d.  e.  f.  g.  h.  i.  j.  

15.15.1 The WeakMap Constructor Called as a Function

When WEAKMAP is called as a function rather than as a constructor, it
initializes its THIS value with the internal state necessary to support
the WEAKMAP.PROTOTYPE methods.

The WEAKMAP constructor is designed to be subclassable. It may be used
as the value in an EXTENDS clause of a class definition. Subclass
constructors that intend to inherit the specified WEAKMAP behaviour must
include a SUPER call to WEAKMAP.

15.15.1.1 WeakMap (iterable = undefined )

When the WEAKMAP function is called with optional argument _iterable_
the following steps are taken:

1.  Let _map_ be the THIS value.

2.  a.  

3.  4.  If Type(_map_) is not Object then, throw a TYPEERROR exception.

5.  If _map_ does not have a [[WeakMapData]] internal data property,
    then throw a TYPEERROR exception.

6.  If _map’s_ [[WeakMapData]] internal data property is not UNDEFINED,
    then throw a TYPEERROR exception.

7.  If _iterable_ is not present, let _iterable_ be UNDEFINED.

8.  If _iterable_ is either UNDEFINED or NULL, then let _itr_ be
    UNDEFINED.

9.  Else,

    a.  Let _iterator_ be the well-known symbol @@iterator.

    b.  Let _itr_ be the result of Invoke(_iterable_ , _iterator_).

    c.  ReturnIfAbrupt(_itr_).

    d.  Let _adder_ be the result of Get(_map_, "SET").

    e.  ReturnIfAbrupt(_adder_).

    f.  If IsCallable(_adder_) is FALSE, throw a TYPEERROR Exception.

10. Set _map’s_ [[WeakMapData]] internal data property to a new empty
    List.

11. If _itr_ is UNDEFINED, then return _map_.

12. Repeat

    a.  Let _next_ be the result of Invoke(_itr_, "NEXT").

    b.  c.  d.  ReturnIfAbrupt(_next_).

    e.  If Type(_next_) is not Object, then throw a TYPEERROR exception.

    f.  Let _done_ be IteratorComplete(_next_).

    g.  ReturnIfAbrupt(_done_).

    h.  If _done_ is TRUE, then return NormalCompletion(_map_).

    i.  Let _nextValue_ be IteratorValue(_next_).

    j.  ReturnIfAbrupt(_nextValue_).

    k.  Let _k_ be the result of Get(_nextValue_, "0").

    l.  ReturnIfAbrupt(_k_).

    m.  Let _v_ be the result of Get(_nextValue_, "1").

    n.  ReturnIfAbrupt(_v_).

    o.  Let _status_ be the result of calling the [[Call]] internal
        method of _adder_ with _map_ as _thisArgument_ and a List whose
        elements are _k_ and _v_ as _argumentsList_.

13. a.  ReturnIfAbrupt(_status_).

14. 

NOTE If the parameter _iterable_ is present, it is expected to be an
object that implements an @@iterator method that returns an iterator
object that produces two element array-like objects whose first element
is a value that will be used as a WeakMap key and whose second element
is the value to associate with that key.

15.15.2 The WeakMap Constructor

When WEAKMAP is called as part of a NEW expression it is a constructor:
it initialises a newly created object.

15.15.2.1 new WeakMap ( ... args )

WEAKMAP called as part of a new expression with argument list _args_
performs the following steps:

1.  Let _F_ be the WeakMap function object on which the NEW operator was
    applied.

2.  Let _argumentsList_ be the _argumentsList_ argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of OrdinaryConstruct(_F_, _argumentsList_).

If WeakMap is implemented as an ordinary function object, its
[[Construct]] internal method will perform the above steps.

1.  2.  3.  4.  5.  

15.15.3 Properties of the WeakMap Constructor

The value of the [[Prototype]] internal data property of the WeakMap
constructor is the Function prototype object (15.3.3).

Besides the LENGTH property (whose value is 0), the WeakMap constructor
has the following property:

15.15.3.1 WeakMap.prototype

The initial value of WEAKMAP.PROTOTYPE is the WeakMap prototype object
(15.15.4).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

15.15.3.2 WeakMap[ @@create ] ( )

The @@create method of a WeakMap object _F_ performs the following
steps:

1.  Let _F_ be the THIS value.

2.  Let _obj_ be the result of calling
    OrdinaryCreateFromConstructor(_F_, "%WEAKMAPPROTOTYPE%", (
    [[WeakMapData]] )).

3.  4.  5.  Return _obj_.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

15.15.4 Properties of the WeakMap Prototype Object

The value of the [[Prototype]] internal data property of the WeakMap
prototype object is the standard built-in Object prototype object
(15.2.4). The WeakMap prototype object is an ordinary object. It does
not have a [[WeakMapData]] internal data property.

15.15.4.1 WeakMap.prototype.constructor

The initial value of WEAKMAP.PROTOTYPE.CONSTRUCTOR is the built-in
WEAKMAP constructor.

15.15.4.2 WeakMap.prototype.clear ()

The following steps are taken:

1.  Let _M_ be the THIS value.

2.  If Type(_M)_ is not Object, then throw a TYPEERROR exception.

3.  If _M_ does not have a [[WeakMapData]] internal data property throw
    a TYPEERROR exception.

4.  If _M’s_ [[WeakMapData]] internal data property is UNDEFINED, then
    throw a TYPEERROR exception.

5.  Set the value of _M_’s [[WeakMapData]] internal data property to a
    new empty List.

6.  Return UNDEFINED.

15.15.4.3 WeakMap.prototype.delete ( key )

The following steps are taken:

1.  Let _M_ be the THIS value.

2.  If Type(_M)_ is not Object, then throw a TYPEERROR exception.

3.  If _M_ does not have a [[WeakMapData]] internal data property throw
    a TYPEERROR exception.

4.  Let _entries_ be the List that is the value of _M_’s [[WeakMapData]]
    internal data property.

5.  If _entries_ is UNDEFINED, then throw a TYPEERROR exception.

6.  If Type(_key_) is not Object, then throw a TYPEERROR exception.

7.  8.  9.  Repeat for each Record {[[key]], [[value]]} _p_ that is an
    element of _entries,_

    a.  If _p_.[[key]] and _key_ are the same object, then

        i.  Set _p_.[[key]] to empty_._

        ii. Set _p_.[[value]] to empty_._

        iii. Return TRUE.

10. Return FALSE.

15.15.4.4 WeakMap.prototype.get ( key )

The following steps are taken:

1.  Let _M_ be the THIS value.

2.  If Type(_M)_ is not Object, then throw a TYPEERROR exception.

3.  If _M_ does not have a [[WeakMapData]] internal data property throw
    a TYPEERROR exception.

4.  Let _entries_ be the List that is the value of _M_’s [[WeakMapData]]
    internal data property.

5.  If _entries_ is UNDEFINED, then throw a TYPEERROR exception.

6.  If Type(_key_) is not Object, then throw a TYPEERROR exception.

7.  8.  9.  Repeat for each Record {[[key]], [[value]]} _p_ that is an
    element of _entries,_

    a.  If _p_.[[key]] and _key_ are the same object, then return
        _p_.[[value]]

10. Return UNDEFINED_.

15.15.4.5 WeakMap.prototype.has ( key )

The following steps are taken:

1.  Let _M_ be the THIS value.

2.  If Type(_M)_ is not Object, then throw a TYPEERROR exception.

3.  If _M_ does not have a [[WeakMapData]] internal data property throw
    a TYPEERROR exception.

4.  Let _entries_ be the List that is the value of _M_’s [[WeakMapData]]
    internal data property.

5.  If _entries_ is UNDEFINED, then throw a TYPEERROR exception.

6.  If Type(_key_) is not Object, then throw a TYPEERROR exception.

7.  8.  9.  Repeat for each Record {[[key]], [[value]]} _p_ that is an
    element of _entries,_

    a.  If _p_.[[key]] and _key_ are the same object, then return
        TRUE_._

10. Return FALSE.

15.15.4.6 WeakMap.prototype.set ( key , value )

The following steps are taken:

1.  Let _M_ be the THIS value.

2.  If Type(_M)_ is not Object, then throw a TYPEERROR exception.

3.  If _M_ does not have a [[WeakMapData]] internal data property throw
    a TYPEERROR exception.

4.  Let _entries_ be the List that is the value of _M_’s [[WeakMapData]]
    internal data property.

5.  If _entries_ is UNDEFINED, then throw a TYPEERROR exception.

6.  If Type(_key_) is not Object, then throw a TYPEERROR exception.

7.  8.  9.  Repeat for each Record {[[key]], [[value]]} _p_ that is an
    element of _entries,_

    a.  If _p_.[[key]] and _key_ are the same object, then

        i.  Set _p_.[[value]] to _value._

        ii. Return _M_.

10. Let _p_ be the Record {[[key]]: _key_, [[value]]: _value_}

11. Append _p_ as the last element of _entries_.

12. Return _M_.

15.15.4.7 WeakMap.prototype [ @@toStringTag ]

The initial value of the @@toStringTag property is the string value
"WEAKMAP".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

15.15.5 Properties of WeakMap Instances

WeakMap instances are ordinary objects that inherit properties from the
WeakMap prototype. WeakMap instances also have a [[WeakMapData]]
internal data property.


15.16 Set Objects

Set objects are collections of ECMAScript language values. A distinct
value may only occur once as an element of a Set’s collection. Distinct
values are discriminated using a comparision algorithm that is selected
when the Set is created.

A Set object can iterate its elements in insertion order. Set objects
must be implemented using either hash tables or other mechanisms that,
on average, provide access times that are sublinear on the number of
elements in the collection. The data structures used in this Set objects
specification is only intended to describe the required observable
semantics of Set objects. It is not intended to be a viable
implementation model.

1.  2.  3.  4.  a.  b.  c.  d.  e.  i.  

    f.  i.  ii. 

    g.  h.  i.  j.  

5.  6.  7.  8.  a.  b.  c.  d.  e.  f.  g.  

15.16.1 The Set Constructor Called as a Function

When SET is called as a function rather than as a constructor, it
initializes its THIS value with the internal state necessary to support
the SET.PROTOTYPE internal methods. The SET constructor is designed to
be subclassable. It may be used as the value in an EXTENDS clause of a
class definition. Subclass constructors that intend to inherit the
specified SET behaviour must include a SUPER call to SET.

15.16.1.1 Set (iterable = undefined, comparator = undefined )

When the SET function is called with optional arguments _iterable_ and
_comparator_ the following steps are taken:

1.  Let _set_ be the THIS value.

2.  a.  

3.  4.  5.  6.  If Type(_set_) is not Object then, throw a TYPEERROR
    exception.

7.  If _set_ does not have a [[SetData]] internal data property, then
    throw a TYPEERROR exception.

8.  If _set’s_ [[SetData]] internal data property is not UNDEFINED, then
    throw a TYPEERROR exception.

9.  If _iterable_ is not present, let _iterable_ be UNDEFINED.

10. If _iterable_ is NULL, then let _itr_ be UNDEFINED.

11. Else,

    a.  Let _iterator_ be the well-known symbol @@iterator.

    b.  Let _itr_ be the result of Invoke(_iterable_ , _iterator_).

    c.  ReturnIfAbrupt(_itr_).

    d.  Let _adder_ be the result of Get(_set_, "ADD").

    e.  ReturnIfAbrupt(_adder_).

    f.  If IsCallable(_adder_) is FALSE, throw a TYPEERROR Exception.

12. If _comparator_ is not present, let _comparator_ be UNDEFINED.

13. If _comparator_ is not UNDEFINED, then

    a.  If _comparator_ is not "IS", then throw a RANGEERROR Exception.

14. Set _set’s_ [[SetData]] internal data property to a new empty List.

15. Set _set’s_ [[SetComparator]] internal data property to
    _comparator_.

16. If _itr_ is UNDEFINED, then return _set_.

17. Repeat

    a.  Let _next_ be the result of Invoke(_itr_, "NEXT").

    b.  ReturnIfAbrupt(_next_).

    c.  If Type(_next_) is not Object, then throw a TYPEERROR exception.

    d.  Let _done_ be IteratorComplete(_next_).

    e.  ReturnIfAbrupt(_done_).

    f.  If _done_ is TRUE, then return NormalCompletion(_set_).

    g.  h.  Let _nextValue_ be IteratorValue(_next_).

    i.  ReturnIfAbrupt(_nextValue_).

    j.  Let _status_ be the result of calling the [[Call]] internal
        method of _adder_ with _set_ as _thisArgument_ and a List whose
        sole element is _nextValue_ as _argumentsList_.

18. a.  ReturnIfAbrupt(_status_).

19. 

15.16.2 The Set Constructor

When SET is called as part of a NEW expression it is a constructor: it
initialises a newly created object.

15.16.2.1 new Set ( ... args)

SET called as part of a new expression with argument list _args_
performs the following steps:

1.  2.  3.  4.  5.  

1.  Let _F_ be the Set function object on which the NEW operator was
    applied.

2.  Let _argumentsList_ be the _argumentsList_ argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of OrdinaryConstruct(_F_, _argumentsList_).

If Set is implemented as an ordinary function object, its [[Construct]]
internal method will perform the above steps.

15.16.3 Properties of the Set Constructor

The value of the [[Prototype]] internal data property of the Set
constructor is the Function prototype object (15.3.3).

Besides the LENGTH property (whose value is 0), the Set constructor has
the following property:

15.16.3.1 Set.prototype

The initial value of SET.PROTOTYPE is the intrinsic %SetPrototype%
object (15.16.4).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

15.16.3.2 Set[ @@create ] ( )

The @@create method of a Set function object _F_ performs the following
steps:

1.  Let _F_ be the THIS value.

2.  Let _obj_ be the result of calling
    OrdinaryCreateFromConstructor(_F_, "%SETPROTOTYPE%", ( [[SetData]] ,
    [[SetComparator]] )).

3.  4.  5.  Return _obj_.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

15.16.4 Properties of the Set Prototype Object

The value of the [[Prototype]] internal data property of the Set
prototype object is the standard built-in Object prototype object
(15.2.4). The set prototype object is an ordinary object. It does not
have a [[SetData]] or a [[SetComparator]] internal data property.

15.16.4.1 Set.prototype.constructor

The initial value of SET.PROTOTYPE.CONSTRUCTOR is the built-in SET
constructor.

15.16.4.2 Set.prototype.add (value )

The following steps are taken:

1.  Let _S_ be the THIS value.

2.  If Type(_S)_ is not Object, then throw a TYPEERROR exception.

3.  If _S_ does not have a [[SetData]] internal data property throw a
    TYPEERROR exception.

4.  If _S’s_ [[SetData]] internal data property is UNDEFINED, then throw
    a TYPEERROR exception.

5.  Let _entries_ be the List that is the value of _S_’s [[SetData]]
    internal data property.

6.  If _S’s_ [[SetComparator]] internal data property is UNDEFINED, then
    let _same_ be the abstract operation SameValueZero.

7.  Else, let _same_ be the abstract operation SameValue.

8.  Repeat for each _e_ that is an element of _entries,_ in original
    insertion order

9.  a.  If _e_ is not empty and _same_(_e_, _value_) is TRUE, then

        i.  Return _S_.

10. Append _value_ as the last element of _entries_.

11. Return _S_.

15.16.4.3 Set.prototype.clear ()

The following steps are taken:

1.  Let _S_ be THIS value.

2.  If Type(_S)_ is not Object, then throw a TYPEERROR exception.

3.  If _S_ does not have a [[SetData]] internal data property throw a
    TYPEERROR exception.

4.  If _S’s_ [[SetData]] internal data property is UNDEFINED, then throw
    a TYPEERROR exception.

5.  Let _entries_ be the List that is the value of _S_’s [[SetData]]
    internal data property.

6.  Repeat for each e that is an element of _entries,

    a.  Replace the element of _entries_ whose value is _e_ with an
        element whose value is empty_._

7.  8.  Return UNDEFINED.

15.16.4.4 Set.prototype.delete ( value )

The following steps are taken:

1.  Let _S_ be the THIS value.

2.  If Type(_S)_ is not Object, then throw a TYPEERROR exception.

3.  If _S_ does not have a [[SetData]] internal data property throw a
    TYPEERROR exception.

4.  If _S’s_ [[SetData]] internal data property is UNDEFINED, then throw
    a TYPEERROR exception.

5.  Let _entries_ be the List that is the value of _S_’s [[SetData]]
    internal data property.

6.  If _S’s_ [[SetComparator]] internal data property is UNDEFINED, then
    let _same_ be the abstract operation SameValueZero.

7.  Else, let _same_ be the abstract operation SameValue.

8.  Repeat for each _e_ that is an element of _entries_, in original
    insertion order

    a.  If _e_ is not empty and _same_(_e_, _value_) is TRUE, then

        i.  Replace the element of _entries_ whose value is _e_ with an
            element whose value is empty_._

        ii. Return TRUE.

9.  Return FALSE.

15.16.4.5 Set.prototype.entries ( )

The following steps are taken:

1.  Let _S_ be the THIS value.

2.  If Type(_S)_ is not Object, then throw a TYPEERROR exception.

3.  Return the result of calling the CreateSetIterator abstract
    operation with arguments _S_ and "KEY+VALUE".

NOTE For iteration purposes, a Set appears similar to a Map where each
entry has the same value for its key and value.

15.16.4.6 Set.prototype.forEach ( callbackfn , thisArg = undefined )

_callbackfn_ should be a function that accepts three arguments. FOREACH
calls _callbackfn_ once for each value present in the set object, in
value insertion order. _callbackfn_ is called only for values of the Set
which actually exist; it is not called for keys that have been deleted
from the set.

If a _thisArg_ parameter is provided, it will be used as the THIS value
for each invocation of _callbackfn_. If it is not provided, UNDEFINED is
used instead.

NOTE 1 If _callbackfn_ is an Arrow Function, THIS was lexically bound
when the function was created so _thisArg_ will have no effect.

_callbackfn_ is called with three arguments: the first two arguments are
a value contained in the Set. The same value of passed for both
arguments. The Set object being traversed is passed as the third
argument.

NOTE 2 The _callbackfn_ is called with three arguments to be consistent
with the call back functions used by FOREACH methods for Map and Array.
For Sets, each item value is considered to be both the key and the
value.

FOREACH does not directly mutate the object on which it is called but
the object may be mutated by the calls to _callbackfn_.

NOTE 3 Each value is normally visited only once. However, a value will
be revisited if it is deleted after it has been visited and then
re-added before the to FOREACH call completes. Values that are deleted
after the call to FOREACH begins and before being visited are not
visited unless the value is added again before the to FOREACH call
completes. New values added, after the call to FOREACH begins are
visited.

When the FOREACH method is called with one or two arguments, the
following steps are taken:

1.  Let _S_ be the THIS value.

2.  If Type(_S)_ is not Object, then throw a TYPEERROR exception.

3.  If _S_ does not have a [[SetData]] internal data property throw a
    TYPEERROR exception.

4.  If _S’s_ [[SetData]] internal data property is UNDEFINED, then throw
    a TYPEERROR exception.

5.  If IsCallable(_callbackfn_) is FALSE, throw a TYPEERROR exception.

6.  If _thisArg_ was supplied, let _T_ be _thisArg_; else let _T_ be
    UNDEFINED.

7.  Let _entries_ be the List that is the value of _S_’s [[SetData]]
    internal data property.

8.  Repeat for each _e_ that is an element of _entries,_ in original
    insertion order

    a.  If _e_ is not empty, then

        i.  Let _funcResult_ be the result of calling the [[Call]]
            internal method of _callbackfn_ with _T_ as _thisArgument_
            and a List containing _e_, _e_, and _S_ as _argumentsList_.

        ii. ReturnIfAbrupt(_funcResult_).

9.  Return UNDEFINED.

The LENGTH property of the FOREACH method is 1.

15.16.4.7 Set.prototype.has ( value )

The following steps are taken:

1.  Let _S_ be the THIS value.

2.  If Type(_S)_ is not Object, then throw a TYPEERROR exception.

3.  If _S_ does not have a [[SetData]] internal data property throw a
    TYPEERROR exception.

4.  If _S’s_ [[SetData]] internal data property is UNDEFINED, then throw
    a TYPEERROR exception.

5.  Let _entries_ be the List that is the value of _S_’s [[SetData]]
    internal data property.

6.  If _S’s_ [[SetComparator]] internal data property is UNDEFINED, then
    let _same_ be the abstract operation SameValueZero.

7.  Else, let _same_ be the abstract operation SameValue.

8.  Repeat for each _e_ that is an element of _entries,

    a.  If _e_ is not empty and _same_(_e_, _value_), then return
        TRUE_._

9.  Return FALSE.

15.16.4.8 Set.prototype.keys ( )

The initial value of the KEYS property is the same function object as
the initial value of the VALUES property.

NOTE For iteration purposes, a Set appears similar to a Map where each
entry has the same value for its key and value.

15.16.4.9 get Set.prototype.size 

SET.PROTOTYPE.SIZE is an accessor property whose set accessor function
is UNDEFINED. Its get accessor function performs the following steps:

1.  Let _S_ be the THIS value.

2.  If Type(_S)_ is not Object, then throw a TYPEERROR exception.

3.  If _S_ does not have a [[SetData]] internal data property throw a
    TYPEERROR exception.

4.  If _S’s_ [[SetData]] internal data property is UNDEFINED, then throw
    a TYPEERROR exception.

5.  Let _entries_ be the List that is the value of _S_’s [[SetData]]
    internal data property.

6.  Let _count_ be 0.

7.  For each _e_ that is an element of _entries

    a.  If _e_ is not empty then

        i.  Set _count_ to _count_+1.

8.  Return _count_.

15.16.4.10 Set.prototype.values ( )

The following steps are taken:

1.  Let _S_ be the THIS value.

2.  If Type(_S)_ is not Object, then throw a TYPEERROR exception.

3.  Return the result of calling the CreateSetIterator abstract
    operation with argument _S_ and "VALUE".

15.16.4.11 Set.prototype [@@iterator ] ( )

The initial value of the @@iterator property is the same function object
as the initial value of the VALUES property.

15.16.4.12 Set.prototype [ @@toStringTag ]

The initial value of the @@toStringTag property is the string value
"SET".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

15.16.5 Properties of Set Instances

Set instances inherit properties from the Set prototype. After
initialisation by the Set constructor, Set instances also have a
[[SetData]] internal data property and a [[SetComparator]] internal data
property.

15.16.6 Set Iterator Object Structure

A Set Iterator is an ordinary object, with the structure defined below,
that represents a specific iteration over some specific Set instance
object. There is not a named constructor for Set Iterator objects.
Instead, set iterator objects are created by calling certain methods of
Set instance objects.

15.16.6.1 CreateSetIterator Abstract Operation

Several methods of Set objects return Iterator objects. The abstract
operation CreateSetIterator with arguments _set_ and _kind_ is used to
create and such iterator objects. It performs the following steps:

1.  Let _S_ be the result of calling ToObject(_set_).

2.  ReturnIfAbrupt(_S_).

3.  If _S_ does not have a [[SetData]] internal data property throw a
    TYPEERROR exception.

4.  If _S’s_ [[SetData]] internal data property is UNDEFINED, then throw
    a TYPEERROR exception.

5.  Let _entries_ be the List that is the value of _S_’s [[SetData]]
    internal data property.

6.  Let _itr_ be the result of ObjectCreate(%SetIteratorPrototype%,
    ([[IteratedSet]], [[SetNextIndex]], [[SetIterationKind]])).

7.  Set _itr’s_ [[IteratedSet]] internal data property to _S_.

8.  Set _itr’s_ [[SetNextIndex]] internal data property torn 0.

9.  Set _itr’s_ [[SetIterationKind]] internal data property to _kind_.

10. Return _itr_.

15.16.6.2 The Set Iterator Prototype

All Set Iterator Objects inherit properties from a common Set Iterator
Prototype object. The [[Prototype]] internal data property of the Set
Iterator Prototype is the %ObjectPrototype% intrinsic object. In
addition, the Set Iterator Prototype as the following properties:

15.16.6.2.1 _SetIterator_.prototype.constructor

15.16.6.2.2 _SetIterator_.prototype.next( )

1.  Let _O_ be the THIS value.

2.  If Type(_O_) is not Object, throw a TYPEERROR exception.

3.  If _O_ does not have all of the internal properties of a Set
    Iterator Instance (15.16.7.1.2), throw a TYPEERROR exception.

4.  Let _s_ be the value of the [[IteratedSet]] internal data property
    of _O_.

5.  Let _index_ be the value of the [[SetNextIndex]] internal data
    property of _O_.

6.  Let _itemKind_ be the value of the [[SetIterationKind]] internal
    data property of _O_.

7.  Assert: _s_ has a [[SetData]] internal data property and _s_ has
    been initialized so the value of [[SetData]] is not UNDEFINED.

8.  Let _entries_ be the List that is the value of the [[SetData]]
    internal data property of _s_.

9.  Repeat while _index_ is less than the total number of element of
    _entries_. The number of elements must be redetermined each time
    this method is evaluated.

    a.  Let _e_ be the element at 0-origined insertion position _index_
        of _entries_.

    b.  Set _index_ to _index_+1;

    c.  Set the [[SetNextIndex]] internal data property of _O_ to
        _index_.

    d.  If _e_ is not empty, then

        i.  If _itemKind_ is "KEY+VALUE" then,

            1.  Let _result_ be the result of the abstract operation
                ArrayCreate with argument 2.

            2.  Assert: _result_ is a new, well-formed Array object so
                the following operations will never fail.

            3.  Call CreateOwnDataProperty(_result_, "0", _e_) .

            4.  Call CreateOwnDataProperty(_result_, "1", _e_).

            5.  Return CreateItrResultObject(_result_, FALSE).

        ii. Return _e_.

10. Return CreateItrResultObject(UNDEFINED, TRUE).

15.16.6.2.3 _SetIterator_.prototype.@@iterator ( )

The following steps are taken:

1.  Return the THIS value.

15.16.6.2.4 _SetIterator_.prototype.@@toStringTag

The initial value of the @@toStringTag property is the string value "SET
ITERATOR".

15.16.6.3 Properties of Set Iterator Instances

Set Iterator instances inherit properties from the Set Iterator
prototype (the intrinsic, %SetIteratorPrototype%.) Set Iterator
instances are initially created with the internal properties specified
in Table 37.

Table 37 — Internal Data Properties of Set Iterator Instances

  ----------------------------- -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  INTERNAL DATA PROPERTY NAME   DESCRIPTION
  [[IteratedSet]]               The Set object that is being iterated.
  [[SetNextIndex]]              The integer index of the next Set data element to be examined by this iteration.
  [[SetIterationKind]]          A string value that identifies what is to be returned for each element of the iteration. The possible values are: "KEY", "VALUE", "KEY+VALUE". "KEY" and "VALUE" have the same meaning.
  ----------------------------- -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


15.17 The Reflect Module

This is a place holder for the material in
_http://wiki.ecmascript.org/doku.php?id=harmony:reflect_api

15.17.1 Exported Function Properties Reflecting the Essentional Internal Methods 

15.17.1.1 Reflect.getPrototypeOf (target)

When the GETPROTOTYPEOF function is called with argument _target_ the
following steps are taken:

1.  Let _obj_ be ToObject(_target_).

2.  ReturnIfAbrupt(_obj_).

3.  Return the result of calling the [[GetInheritance]] internal method
    of _obj_.

15.17.1.2 Reflect.setPrototypeOf (target, proto)

When the SETPROTOTYPEOF function is called with arguments _target_ and
_propertyKey_, the following steps are taken:

1.  Let _obj_ be ToObject(_target_).

2.  ReturnIfAbrupt(_obj_).

3.  If Type(_proto_) is not Object and _proto_ is not NULL, then throw a
    TYPEERROR exception

4.  Return the result of calling the [[SetInheritance]] internal method
    of _obj_ with argument _proto_.

15.17.1.3 Reflect.isExtensible (target)

When the ISEXTENSIBLE function is called with argument _target_ the
following steps are taken:

1.  Let _obj_ be ToObject(_target_).

2.  ReturnIfAbrupt(_obj_).

3.  Return the result of calling IsExtensible(_obj_).

15.17.1.4 Reflect.preventExtensions (target)

When the PREVENTEXTENSIONS function is called with argument _target_,
the following steps are taken:

1.  Let _obj_ be ToObject(_target_).

2.  ReturnIfAbrupt(_obj_).

3.  Return the result of calling the [[SetIntegrity]] internal method of
    _obj_ with argument "NONEXTENSIBLE".

15.17.1.5 Reflect.has (target, propertyKey)

When the HASOWN function is called with arguments _target_ and
_propertyKey_, the following steps are taken:

1.  Let _obj_ be ToObject(_target_).

2.  ReturnIfAbrupt(_obj_).

3.  Let _key_ be ToPropertyKey(_propertyKey_).

4.  ReturnIfAbrupt(_key_).

5.  Return the result of calling the [[HasProperty]] internal method of
    _obj_ with argument _key_.

15.17.1.6 Reflect.hasOwn (target, propertyKey)

When the HASOWN function is called with arguments _target_ and
_propertyKey_, the following steps are taken:

1.  Let _obj_ be ToObject(_target_).

2.  ReturnIfAbrupt(_obj_).

3.  Let _key_ be ToPropertyKey(_propertyKey_).

4.  ReturnIfAbrupt(_key_).

5.  Return the result of calling the [[HasOwnProperty]] internal method
    of _obj_ with argument _key_.

15.17.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)

When the GETOWNPROPERTYDESCRIPTOR function is called with arguments
_target_ and _propertyKey_, the following steps are taken:

1.  Let _obj_ be ToObject(_target_).

2.  ReturnIfAbrupt(_obj_).

3.  Let _key_ be ToPropertyKey(_propertyKey_).

4.  ReturnIfAbrupt(_key_).

5.  Let _desc_ be the result of calling the [[GetOwnProperty]] internal
    method of _obj_ with argument _key_.

6.  ReturnIfAbrupt(_desc_).

7.  Return the result of calling FromPropertyDescriptor(_desc_).

15.17.1.8 Reflect.get (target, propertyKey, receiver=target)

When the GET function is called with arguments _target_, _propertyKey_,
and _receiver_ the following steps are taken:

1.  Let _obj_ be ToObject(_target_).

2.  ReturnIfAbrupt(_obj_).

3.  Let _key_ be ToPropertyKey(_propertyKey_).

4.  ReturnIfAbrupt(_key_).

5.  If _receiver_ is not present, then

    a.  Let _receiver_ be _target_.

6.  Return the result of calling the [[Get]] internal method of _obj
    with arguments _key_, and _receiver_.

15.17.1.9 Reflect.set (target, propertyKey, V, receiver=target)

When the SET function is called with arguments _target_, _V_,
_propertyKey_, and _receiver_ the following steps are taken:

1.  Let _obj_ be ToObject(_target_).

2.  ReturnIfAbrupt(_obj_).

3.  Let _key_ be ToPropertyKey(_propertyKey_).

4.  ReturnIfAbrupt(_key_).

5.  If _receiver_ is not present, then

    a.  Let _receiver_ be _target_.

6.  Return the result of calling the [[Set]] internal method of _obj
    with arguments _key_, _V_, and _receiver_.

15.17.1.10 Reflect.deleteProperty (target, propertyKey)

When the DELETEPROPERTY function is called with arguments _target_ and
_propertyKey_, the following steps are taken:

1.  Let _obj_ be ToObject(_target_).

2.  ReturnIfAbrupt(_obj_).

3.  Let _key_ be ToPropertyKey(_propertyKey_).

4.  ReturnIfAbrupt(_key_).

5.  Return the result of calling the [[Delete]] internal method of _obj
    with argument _key_.

15.17.1.11 Reflect.defineProperty(target, propertyKey, attributes)

When the DEFINEPROPERTY function is called with arguments _target_,
_propertyKey_, and _attributes_ the following steps are taken:

1.  Let _obj_ be ToObject(_target_).

2.  ReturnIfAbrupt(_obj_).

3.  Let _key_ be ToPropertyKey(_propertyKey_).

4.  ReturnIfAbrupt(_key_).

5.  Let _desc_ be the result of calling ToPropertyDescriptor with
    _attributes_ as the argument.

6.  ReturnIfAbrupt(_desc_).

7.  Return the result of calling the [[DefineOwnProperty]] internal
    method of _obj_ with arguments _key_, and _desc_.

15.17.1.12 Reflect.enumerate (target)

When the ENUMERATE function is called with argument _target_ the
following steps are taken:

1.  Let _obj_ be ToObject(_target_).

2.  ReturnIfAbrupt(_obj_).

3.  Let _itr_ be the result of calling the [[Enumerate]] internal method
    of _obj_.

4.  Return _itr_.

1.  2.  3.  4.  5.  

15.17.1.13 Reflect.ownKeys (target)

When the OWNKEYS function is called with argument _target_ the following
steps are taken:

1.  Let _obj_ be ToObject(_target_).

2.  ReturnIfAbrupt(_obj_).

3.  4.  5.  Let _keys_ be the result of calling the [[OwnPropertyKeys]]
    internal method of _obj_.

15.17.1.14 Reflect.freeze (target)

When the FREEZE function is called with argument _target_ the following
steps are taken:

1.  Let _obj_ be ToObject(_target_).

2.  ReturnIfAbrupt(_obj_).

3.  Return the result of calling the [[Freeze]] internal method of
    _obj_.

15.17.1.15 Reflect.seal (target)

When the SEAL function is called with argument _target_ the following
steps are taken:

1.  Let _obj_ be ToObject(_target_).

2.  ReturnIfAbrupt(_obj_).

3.  Return the result of calling the [[Seal]] internal method of _obj_.

15.17.1.16 Reflect.isFrozen (target)

When the ISFROZEN function is called with argument _target_ the
following steps are taken:

1.  Let _obj_ be ToObject(_target_).

2.  ReturnIfAbrupt(_obj_).

3.  Return the result of calling the [[IsFrozen]] internal method of
    _obj_.

15.17.1.17 Reflect.isSealed (target)

When the ISSEALED function is called with argument _target_ the
following steps are taken:

1.  Let _obj_ be ToObject(_target_).

2.  ReturnIfAbrupt(_obj_).

3.  Return the result of calling the [[IsSealed]] internal method of
    _obj_.


15.18 Proxy Objects


15.19 The "std:iteration" Module

The "STD:ITERATION" module defines built-in objects that support the
for-of statement and similar iteration use cases. It also defines the
built-in objects that support Generator Funtions.


15.19.1 Common Iteration Interfaces

An interface is a set of object property keys whose associated values
match a specific specification. Any object that provides all the
properties of an interface in conformance to the interface’s
specification _conforms_ to that interface. An interface isn’t
represented by a single object and there may be many distinctly
implemented objects that conform to any interface. An individual object
may conform to multiple interfaces.

15.19.1.1 The _Iterable_ Iterface

The _Iterable_ interface includes the following property:

  PROPERTY     VALUE                                               REQUIREMENTS
  ------------ --------------------------------------------------- ---------------------------------------------------------------------------
  @@ITERATOR   A zero arguments function that returns an object.   The function returns an object that conforms to the _iterator_ interface.

15.19.1.2 The _Iterator_ Iterface

The _Iterator_ interface includes the following properties:

  PROPERTY   VALUE                                REQUIREMENTS
  ---------- ------------------------------------ ----------------------------------------------------------------------------
  NEXT       A function that returns an object.   The function returns an object that conforms to the _ItrResult_ interface.

NOTE Arguments may be passed to the next function but their
interpretation and validity is dependent upon the target Iterator.
Generic use of Iterators should not pass any arguments.

15.19.1.3 The _ItrResult_ Iterface

The _ItrResult_ interface includes the following properties:

  PROPERTY   VALUE                           REQUIREMENTS
  ---------- ------------------------------- ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  DONE       Either TRUE or FALSE.           This is the result status of the an _iterator_ NEXT method call. If the end of the iterator was reached DONE is TRUE. If the end was not reached DONE is FALSE and a value is available.
  VALUE      Any ECMAScript languge value.   If done is FALSE, this is the current iteration element value. If done is TRUE, this is the return value of the iterator, if it supplied one. If the iterator does not have a return value, VALUE is UNDEFINED. In that case, the VALUE property may be absent form the conforming object if it does not inherit an explicit VALUE property.

15.19.2 "std:iteration" Exports 

The "STD:ITERATION" module exports the names:

-   Iterator$

-   GeneratorFunction

-   Generator

15.19.3 GeneratorFunction Objects

GENERATOR FUNCTION objects are constructor functions that are usually
created by evaluating _GeneratorDeclaration_, _GeneratorExpression_, and
_GeneratorMethod_ syntactic productions. They may also be created by
calling the GENERATORFUNCTION constructor.

1.  2.  3.  4.  5.  

1.  

  --
  --

Figure 2 (Informative) -- Generator Objects Relationships

15.19.3.1 The GeneratorFunction Constructor

The GeneratorFunction constructor is the %GeneratorFunction% instrinsic
object and the value of the name GENERATORFUNCTION exported from the
built-in module "STD:ITERATION". When GENERATORFUNCTION is called as a
function rather than as a constructor, it creates and initialises a new
GeneratorFunction object. Thus the function call GENERATORFUNCTION (…)
is equivalent to the object creation expression NEW GENERATORFUNCTION
(…) with the same arguments. However, if the THIS value value passed in
the call is an Object with an [[Code]] internal data property whose
value is UNDEFINED, it initializes the THIS value using the argument
values. This permits GENERATORFUNCTION to be used both as factory method
and to perform constructor instance initialization.

GENERATORFUNCTION may be subclassed and subclass constructors may
perform a SUPER invocation of the GENERATORFUNCTION constructor to
initialize subclass instances. However, all syntactic forms for defining
generator function objects create direct instances of GENERATORFUNCTION.
There is no syntactic means to create instances of GENERATORFUNCTION
subclasses.

15.19.3.1.1 GeneratorFunction (p1, p2, … , pn, body)

The last argument specifies the body (executable code) of a generator
function; any preceding arguments specify formal parameters.

When the GENERATORFUNCTION function is called with some arguments _p1_,
_p2_, … , _pn_, _body_ (where _n_ might be 0, that is, there are no
“_p_” arguments, and where _body_ might also not be provided), the
following steps are taken:

1.  Let _argCount_ be the total number of arguments passed to this
    function invocation.

2.  Let _P_ be the empty String.

3.  If _argCount_ = 0, let _bodyText_ be the empty String.

4.  Else if _argCount_ = 1, let _bodyText_ be that argument.

5.  Else _argCount_ > 1,

    a.  Let _firstArg_ be the first argument.

    b.  Let _P_ be ToString(_firstArg_).

    c.  ReturnIfAbrupt(_P_).

    d.  Let _k_ be 2.

    e.  Repeat, while _k_ < _argCount_

        i.  Let _nextArg_ be the _k_’th argument.

        ii. Let _nextArgString_ be ToString(_nextArg_).

        iii. ReturnIfAbrupt(_nextArgString_).

        iv. Let _P_ be the result of concatenating the previous value of
            _P_, the String "," (a comma), and _nextArgString_.

        v.  Increase _k_ by 1.

    f.  Let _bodyText_ be the _k_’th argument.

6.  Let _bodyText_ be ToString(_bodyText_).

7.  ReturnIfAbrupt(_bodyText_).

8.  Let _parameters_ be the result of parsing _P_, interpreted as UTF-
    encoded Unicode text as described in 8.4_,_ using _FormalParameters_
    as the goal symbol. Throw a SYNTAXERROR exception if the parse
    fails.

9.  Let _funcBody_ be the result of parsing _bodyText_, interpreted as
    UTF-16 encoded Unicode text as described in 8.4_,_ using
    _FunctionBody_ as the goal symbol. Throw a SYNTAXERROR exception if
    the parse fails or if any static semantics errors are detected.

10. If _funcBody_ Contains _YieldExpression_ is FALSE, then throw a
    SYNTAXERROR exception.

11. If IsSimpleParameterList of _parameters_ is FALSE and any element of
    the BoundNames of _parameters_ also occurs in the VarDeclaredNames
    of _funcBody_, then throw a SYNTAXERROR exception.

12. If any element of the BoundNames of _parameters_ also occurs in the
    LexicallyDeclaredNames of _funcBody_, then throw a SYNTAXERROR
    exception.

13. Let _scope_ be the Global Environment.

14. Let _F_ be the THIS value.

15. If Type(_F_) is not Object or if _F_ does not have a [[Code]]
    internal data property or if the value of [[Code]] is not UNDEFINED,
    then

    a.  Let _F_ be the result of calling FunctionAllocate with arguments
        %GENERATOR% and "GENERATOR".

16. If the value of _F’s_ [[FunctionKind]] internal data property is not
    "GENERATOR", then throw a TYPEERROR exception.

17. Using _funcBody_ as the _FunctionBody_ production, let _body_ be the
    supplemental syntactic grammar production: _GeneratorBody_ :
    _FunctionBody_.

18. Perform the FunctionInitialize abstract operation with arguments
    _F_, Normal, _parameters_, _body, scope_, and _strict_.

19. Let _prototype_ be the result of the abstract operation ObjectCreate
    with the intrinsic object %GeneratorPrototype% as its argument.

20. Perform the abstract operation MakeConstructor with arguments _F_,
    TRUE, and _prototype_.

21. Return _F_.

A PROTOTYPE property is automatically created for every function created
using the GENERATORFUNCTION constructor, to provide for the possibility
that the function will be used as a constructor.

15.19.3.1.2 new GeneratorFunction ( ... argumentsList)

When GENERATORFUNCTION is called as part of a NEW expression, it creates
and initialises a newly created object.

1.  Let _F_ be the GENERATORFUNCTION function object on which the NEW
    operator was applied.

2.  Let _argumentsList_ be the _argumentsList_ argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of OrdinaryConstruct (_F_, _argumentsList_).

If GENERATORFUNCTION is implemented as an ordinary function object, its
[[Construct]] internal method will perform the above steps.

15.19.3.2 Properties of the GeneratorFunction Constructor

The GeneratorFunction constructor is a built-in Function object that
inherits from the Function constructor. The value of the [[Prototype]]
internal data property of the GeneratorFunction constructor is the
intrinsic object %Function%.

The value of the [[Extensible]] internal data property of the
GeneratorFunction constructor is TRUE.

The GeneratorFunction constructor has the following properties:

15.19.3.2.1 GeneratorFunction.prototype

The initial value of GENERATORFUNCTION.PROTOTYPE is %Generator%, the
standard built-in GeneratorFunction prototype.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

15.19.3.2.2 GeneratorFunction.length

This is a data property with a value of 1. This property has the
attributes { [[Writable]]: FALSE, [[Enumerable]]: FALSE,
[[Configurable]]: FALSE }.

15.19.3.2.3 GeneratorFunction[ @@create ] ( )

The @@create method of an object _F_ performs the following steps:

1.  Let _F_ be the THIS value.

2.  Let _proto_ be the result of GetPrototypeFromConstructor(_F_,
    "%GENERATOR%").

3.  ReturnIfAbrupt(_proto_).

4.  Let _obj_ be the result of calling FunctionAllocate with agument
    _proto_ and "GENERATOR".

5.  Return _obj_.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

NOTE The GeneratorFunction @@CREATE function is intentionally generic;
it does not require that its THIS value be the GeneratorFunction
constructor object. It can be transferred to other constructor functions
for use as a @@CREATE method. When used with other constructors, this
function will create a function object whose [[Prototype]] value is
obtained from the associated constructor.

15.19.3.3 Properties of the GeneratorFunction Prototype Object

The GeneratorFunction prototype object is an ordinary object. It is not
a function object and does not have a [[Code]] internal data property or
any other of the internal data properties listed in Table 13. In
addition to being the value of the prototype property of the
%GeneratorFunction% intrinsic and is itself the %Generator% instrinsic.

The value of the [[Prototype]] internal data property of the
GeneratorFunction prototype object is the %FunctionPrototype% instrinsic
object. The initial value of the [[Extensible]] internal data property
of the GeneratorFunction prototype object is TRUE.

15.19.3.3.1 GeneratorFunction.prototype.constructor

The initial value of GENERATORFUNCTION.PROTOTYPE.CONSTRUCTOR is the
intrinsic object %GeneratorFunction%.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

15.19.3.3.2 Generator Function.prototype.prototype

The value of FUNCTION.PROTOTYPE.PROTOTYPE is the %GeneratorPrototype.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

15.19.3.3.3 GeneratorFunction.prototype [ @@toStringTag ]

The initial value of the @@toStringTag property is the string value
"GENERATORFUNCTION".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

15.19.3.3.4 GeneratorFunction.prototype [ @@create ] ( )

The @@create method of an object _F_ performs the following steps:

1.  Let _F_ be the THIS value.

2.  Let _obj_ be the result of calling
    OrdinaryCreateFromConstructor(_F_, "%GENERATORPROTOTYPE%", (
    [[GeneratorState]], [[GeneratorContext]]) ).

3.  Return _obj_.

This property has the attributes { [[Writable]]: TRUE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

15.19.3.4 GeneratorFunction Instances

Every GeneratorFunction instance is an ordinary function object and has
the internal data properties listed in Table 13. The value of the
[[FunctionKind]] internal data property for all such instances is
"GENERATOR".

The GeneratorFunction instances have the following own properties:

15.3.4.1 length

The value of the LENGTH property is an integer that indicates the
typical number of arguments expected by the GeneratorFunction. However,
the language permits the function to be invoked with some other number
of arguments. The behaviour of a GeneratorFunction when invoked on a
number of arguments other than the number specified by its LENGTH
property depends on the function.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

15.3.4.2 prototype

Whenever a GeneratorFunction instance is created another ordinary object
is also created and is the initial value of the generator function’s
PROTOTYPE property. The value of the prototype property is used to
initialise the [[Prototype]] internal data property of a newly created
Generator object before the generator function object is invoked as a
constructor for that newly created object.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

NOTE Unlike function instances, the object that is the value of the a
GeneratorFunction’s PROTOTYPE property does not have a CONSTRUCTOR
property whose value is the GeneratorFunction instance.

15.19. 4 Generator Objects

A Generator object is an instance of a generator function and conforms
to both the _Iterator_ and _Iterable_ interfaces.

Generator instances directly inherit properties from the object that is
the value of the PROTOTYPE property of the Generator function that
created the instance. Generator instances indirectly inherit properties
from the Generator Prototype intrinsic, %GeneratorPrototype%.

15.19.4.2 Properties of Generator Prototype

The Generator prototype object is the %GeneratorPrototype% intrinsic. It
is also the initial value of the PROTOTYPE property of the %Generator%
intrinsic (the GeneratorFrunction.prototype).

The Generator prototype is an ordinary object. It is not a Generator
instance and does not have a [[GeneratorState]] internal data property.

The value of the [[Prototype]] internal data property of the Generator
prototype object is the intrinsic object %ObjectPrototype% (15.2.4). The
initial value of the [[Extensible]] internal data property of the
Function prototype object is TRUE.

All Generator instances indirectly inherit properties of the Generator
prototype object.

15.19.4.2.1 Generator.prototype.constructor

The initial value of GENERATOR.PROTOTYPE.CONSTRUCTOR is the intrinsic
object %Generator%.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

15.19.4.2.3 Generator.prototype.next ( value )

The NEXT method performs the following steps:

1.  Let _g_ be the THIS value.

2.  Return the result of GeneratorResume(_g_, _value_).

15.19.4.2.4 Generator.prototype.throw ( exception )

The THROW method performs the following steps:

1.  Let _g_ be the THIS value.

2.  If Type(_generator_) is not Object, then throw a TYPEERROR
    exception.

3.  If _generator_ does not have a [[GeneratorState]] internal data
    property, then throw a TYPEERROR exception.

4.  Let _state_ be the value of _generator’s_ [[GeneratorState]]
    internal data property.

5.  Asset: _generator_ also has a [[GeneratorContext]] internal data
    property.

6.  If _state_ is neither "SUSPENDEDSTART" or "SUSPENDEDYIELD", then
    throw a TYPEERROR exception.

7.  Let _E_ be Completion {[[type]]: throw, [[value]]: _exception_,
    [[target]]: empty}.

8.  If _state_ is "SUSPENDEDSTART" then,

    a.  Set _generator’s_ [[GeneratorState]] internal data property to
        "COMPLETED".

    b.  Once a generator enters the "COMPLETED" state it never leaves it
        and its associated execution context is never resumed. Any
        execution state associated with _geneator_ can be discard at
        this point.

    c.  Return _E_.

9.  Let _gContext_ be value of _generator’s_ [[GeneratorContext]]
    internal data property.

10. Let _methodContext_ be the running execution context.

11. Suspend _methodContext_.

12. Set _generator’s_ [[GeneratorState]] internal data property to
    "EXECUTING".

13. Push _gContext_ onto the execution context stack; _gContext_ is now
    the running execution context.

14. Resume the suspended evaluation of _gContext_ using _E_ as the
    result of the operation that suspended it. Let _result_ be the value
    returned by the resumed compation.

15. Assert: When we return here, _gContext_ has already been removed
    from the execution context stack and _methodContext_ is the
    currently running execution context.

16. Return _result_.

15.19.4.2.5 Generator.prototype [ @@toStringTag ]

The initial value of the @@toStringTag property is the string value
"GENERATOR".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

15.19.4.2 Properties of Generator Instances

Generator instances are initially created with the internal data
properties described in Table 36.

Table 36 — Internal Data Properties of Generator Instances

  ----------------------------- -----------------------------------------------------------------------------------------------------------------------------------------------------
  INTERNAL DATA PROPERTY NAME   DESCRIPTION
  [[GeneratorState]]            The current execution state of the generator. The possible values are: UNDEFINED, "SUSPENDEDSTART", "SUSPENDEDYIELD", "EXECUTING", and "COMPLETED".
  [[GeneratorContext]]          The execution context that is used when executing the code of this generator.
  ----------------------------- -----------------------------------------------------------------------------------------------------------------------------------------------------

15.19.4.2.1 @@iterator 

The value of the @@iterator own property of a Generator instance is that
Generator instance.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

15.19.4.3 Iteration Related Abstract Operations

15.19.4.3.1 GeneratorStart (_generator_, _generatorBody_)

1.  Let _genContext_ be the running execution context.

2.  Set the Generator component of _genContext_ to _generator.

3.  Set the code evaluation state of _genContext_ such that when
    evaluation is resumed for that execution context the following steps
    will be performed:

    a.  Let _result_ be the result of evaluating _generatorBody_.

    b.  Assert: If we return here, the generator either threw an
        exception or performed either an implicit or explicit return.

    c.  Remove _genContext_ from the execution context stack and restore
        the execution context that is at the top of the execution
        context stack as the running execution context.

    d.  Set _g’s_ [[GeneratorState]] internal data property to
        "COMPLETED".

    e.  Once a generator enters the "COMPLETED" state it never leaves it
        and its associated execution context is never resumed. Any
        execution state associated with _geneator_ can be discard at
        this point.

    f.  ReturnIfAbrupt(_result_).

    g.  Return CreateItrResultObject(_result_, TRUE).

4.  Set _generator’s_ [[GeneratorContext]] internal data property to
    _genContext_.

5.  Set _generator’s_ [[GeneratorState]] internal data property to
    "SUSPENDEDSTART".

6.  Return NormalCompletion(_generator_).

15.19.4.3.2 GeneratorResume ( generator, value )

The abstract operation GeneratorResume with arguments _generator_ and
_value_ performs the following steps:

1.  If Type(_generator_) is not Object, then throw a TYPEERROR
    exception.

2.  If _generator_ does not have a [[GeneratorState]] internal data
    property, then throw a TYPEERROR exception.

3.  Let _state_ be the value of _generator’s_ [[GeneratorState]]
    internal data property.

4.  Asset: _generator_ also has a [[GeneratorContext]] internal data
    property.

5.  If _state_ is neither "SUSPENDEDSTART" or "SUSPENDEDYIELD", then
    throw a TYPEERROR exception.

6.  If _state_ is "SUSPENDEDSTART" and _value_ is not UNDEFINED, then
    throw a TYPEERROR exception.

7.  Let _gContext_ be value of _generator’s_ [[GeneratorContext]]
    internal data property.

8.  Let _methodContext_ be the running execution context.

9.  Suspend _methodContext_.

10. Set _generator’s_ [[GeneratorState]] internal data property to
    "EXECUTING".

11. Push _gContext_ onto the execution context stack; _gContext_ is now
    the running execution context.

12. Resume the suspended evaluation of _gContext_ using
    NormalCompletion(_value_) as the result of the operation that
    suspended it. Let _result_ be the value returned by the resumed
    computation.

13. Assert: When we return here, _gContext_ has already been removed
    from the execution context stack and _methodContext_ is the
    currently running execution context.

14. Return _result_.

15.19.4.3.3 GeneratorYield ( itrNextObj )

The abstract operation GeneratorYield with argument _itrNextObj_
performs the following steps:

1.  Assert: _itrNextObj_ is an Object that implemented the _ItrResult
    interface.

2.  Let _genContext_ be the running execution context.

3.  Assert; _genContext_ is the execution context of a generator.

4.  Let _generator_ be the value of the Generator component of
    _genContext_.

5.  Set the value of _generator’s_ [[GeneratorState]] internal data
    property to "SUSPENDEDYIELD".

6.  Remove _genContext_ from the execution context stack and restore the
    execution context that is at the top of the execution context stack
    as the running execution context.

7.  Set the code evaluation state of _genContext_ such that when
    evaluation is resumed with a Completion _resumptionValue_ the
    following steps will be performed:

    a.  Return _resumptionValue_.

    b.  NOTE: This returns to the evaluation of the _YieldExpression_
        production that originally called this abstradt operation.

8.  Resume the suspended evaluation of _gContext_ using
    NormalCompletion(_value_) as the result of the operation that
    suspended it. Let _result_ be the value returned by the resumed
    computation.

9.  Assert: When we return here, _gContext_ has already been removed
    from the execution context stack and _methodContext_ is the
    currently running execution context.

10. Return NormalCompletion(_itrNextObj_).

11. NOTE: This returns to the evaluation of the operation that had most
    previously resumed evaluation of _gContext_.

15.19.4.3.4 CreateItrResultObject (_value_, _done_)

The abstract operation CreateItrResultObject with arguments _value_ and
_done_ creates an object that supports the ItrResult interface by
performing the following steps:

1.  Assert: Type(_done_) is Boolean.

2.  Let _obj_ be the result of performing ObjectCreate().

3.  Perform CreateOwnDataProperty(_obj_, "VALUE", _value_).

4.  Perform CreateOwnDataProperty(_obj_, "DONE", _done_).

5.  Return _obj_.

15.19.4.3.5 IteratorComplete (_itrResult_)

The abstract operation IteratorComplete with argument _itrResult_
performing the following steps:

1.  Assert: Type(_itrResult_) is Object.

2.  Let _done_ be the result of Get(_itrResult_, "DONE").

3.  Return ToBoolean(_done_).

15.19.4.3.6 IteratorValue (_itrResult_)

The abstract operation IteratorValue with argument _itrResult_
performing the following steps:

1.  Assert: Type(_itrResult_) is Object.

2.  Return the result of Get(_itrResult_, "VALUE).

An implementation must report most errors at the time the relevant
ECMAScript language construct is evaluated. An _early error_ is an error
that can be detected and reported prior to the evaluation of any
construct in the _Script_ containing the error. An implementation must
report early errors in a _Script_ prior to the first evaluation of that
_Script_. Early errors in EVAL code are reported at the time EVAL is
called but prior to evaluation of any construct within the EVAL code.
All errors that are not early errors are runtime errors.

An implementation must treat as an early error any instance of an early
error that is specified in a static

-   

An implementation shall not treat other kinds of errors as early errors
even if the compiler can prove that a construct cannot execute without
error under any circumstances. An implementation may issue an early
warning in such a case, but it should not report the error until the
relevant construct is actually executed.

An implementation shall report all errors as specified, except for the
following:

-   An implementation may extend script syntax and regular expression
      pattern or flag syntax. To permit this, all operations (such as
      calling EVAL, using a regular expression literal, or using the
      FUNCTION or REGEXP constructor) that are allowed to throw
      SYNTAXERROR are permitted to exhibit implementation-defined
      behaviour instead of throwing SYNTAXERROR when they encounter an
      implementation-defined extension to the script syntax or regular
      expression pattern or flag syntax.

-   An implementation may provide additional types, values, objects,
      properties, and functions beyond those described in this
      specification. This may cause constructs (such as looking up a
      variable in the global scope) to have implementation-defined
      behaviour instead of throwing an error (such as REFERENCEERROR).

-   An implementation may define behaviour other than throwing
      RANGEERROR for TOFIXED, TOEXPONENTIAL, and TOPRECISION when the
      _fractionDigits_ or _precision_ argument is outside the specified
      range.

(informative)
Grammar Summary


Lexical Grammar

SourceCharacter :: See clause 6

any Unicode code unit

InputElementDiv :: See clause 7

WhiteSpace
LineTerminator
Comment
Token
DivPunctuator

InputElementRegExp :: See clause 7

WhiteSpace
LineTerminator
Comment
Token
RegularExpressionLiteral

WhiteSpace :: See 7.2

<TAB>
<VT>
<FF>
<SP>
<NBSP>
<BOM>
<USP>

LineTerminator :: See 7.3

<LF>
<CR>
<LS>
<PS>

LineTerminatorSequence :: See 7.3

<LF>
<CR> [lookahead ∉ <LF> ]
<LS>
<PS>
<CR> <LF>

Comment :: See 7.4

MultiLineComment
SingleLineComment

MultiLineComment :: See 7.4

/* MultiLineCommentChars~opt~ */

MultiLineCommentChars :: See 7.4

MultiLineNotAsteriskChar MultiLineCommentChars~opt~
* PostAsteriskCommentChars~opt~

PostAsteriskCommentChars :: See 7.4

MultiLineNotForwardSlashOrAsteriskChar MultiLineCommentChars~opt~
* PostAsteriskCommentChars~opt~

MultiLineNotAsteriskChar :: See 7.4

SourceCharacter BUT NOT *

MultiLineNotForwardSlashOrAsteriskChar :: See 7.4

SourceCharacter BUT NOT ONE OF / OR *

SingleLineComment :: See 7.4

// SingleLineCommentChars~opt~

SingleLineCommentChars :: See 7.4

SingleLineCommentChar SingleLineCommentChars~opt~

SingleLineCommentChar :: See 7.4

SourceCharacter BUT NOT LineTerminator

Token :: See 7.5

IdentifierName
Punctuator
NumericLiteral
StringLiteral

Identifier :: See 7.6

IdentifierName BUT NOT ReservedWord

IdentifierName :: See 7.6

IdentifierStart
IdentifierName IdentifierPart

IdentifierStart :: See 7.6

UnicodeLetter
$
_
\ UnicodeEscapeSequence

IdentifierPart :: See 7.6

IdentifierStart
UnicodeCombiningMark
UnicodeDigit
UnicodeConnectorPunctuation
<ZWNJ>
<ZWJ>

UnicodeLetter :: See 7.6

any character in the Unicode categories “Uppercase letter (Lu)”,
“Lowercase letter (Ll)”, “Titlecase letter (Lt)”, “Modifier letter
(Lm)”, “Other letter (Lo)”, or “Letter number (Nl)”.

UnicodeCombiningMark :: See 7.6

any character in the Unicode categories “Non-spacing mark (Mn)” or
“Combining spacing mark (Mc)”

UnicodeDigit :: See 7.6

any character in the Unicode category “Decimal number (Nd)”

UnicodeConnectorPunctuation :: See 7.6

any character in the Unicode category “Connector punctuation (Pc)”

ReservedWord :: See 7.6.1

Keyword
FutureReservedWord
NullLiteral
BooleanLiteral

Keyword :: ONE OF See 7.6.1.1

  ---------- ---------- ------------ --------
  break      do         instanceof   typeof
  case       else       new          var
  catch      finally    return       void
  continue   for        switch       while
  debugger   function   this         with
  default    if         throw        
  delete     in         try          
  ---------- ---------- ------------ --------

FutureReservedWord :: ONE OF See 7.6.1.2

  ------- -------- --------- -------
  class   enum     extends   super
  const   export   import    
  ------- -------- --------- -------

  The following tokens are also considered to be _FutureReservedWords_
  when parsing strict mode code (see 10.1.1).

  ------------ --------- ----------- --------
  implements   let       private     public
  interface    package   protected   static
  yield                              
  ------------ --------- ----------- --------

Punctuator :: ONE OF See 7.7

  ----- ------ ----- ----- ----- -----
  {     }      (     )     [     ]
  .     ;      ,     <     >     <=
  >=    ==     !=    ===   !==   
  +     -      *     %     ++    --
  <<    >>     >>>   &     |     ^
  !     ~      &&    ||    ?     :
  =     +=     -=    *=    %=    <<=
  >>=   >>>=   &=    |=    ^=    
  ----- ------ ----- ----- ----- -----

DivPunctuator :: ONE OF See 7.7

  --- ---- -- -- -- --
  /   /=            
  --- ---- -- -- -- --

Literal :: See 7.8

NullLiteral
BooleanLiteral
NumericLiteral
StringLiteral
RegularExpressionLiteral

NullLiteral :: See 7.8.1

NULL

BooleanLiteral :: See 7.8.2

TRUE
FALSE

_NumericLiteral_ :: See 7.8.

DecimalLiteral
HexIntegerLiteral

DecimalLiteral :: See 7.8.3

DecimalIntegerLiteral . DecimalDigits~opt~ ExponentPart~opt~
. DecimalDigits ExponentPart~opt~
DecimalIntegerLiteral ExponentPart~opt~

DecimalIntegerLiteral :: See 7.8.3

0
NonZeroDigit DecimalDigits~opt~

DecimalDigits :: See 7.8.3

DecimalDigit
DecimalDigits DecimalDigit

DecimalDigit :: ONE OF See 7.8.3

0 1 2 3 4 5 6 7 8 

NonZeroDigit :: ONE OF See 7.8.3

1 2 3 4 5 6 7 8 

ExponentPart :: See 7.8.3

ExponentIndicator SignedInteger

ExponentIndicator :: ONE OF See 7.8.3

E E

SignedInteger :: See 7.8.3

DecimalDigits
+ DecimalDigits
- DecimalDigits

HexIntegerLiteral :: See 7.8.3

0X HexDigit
0X HexDigit
HexIntegerLiteral HexDigit

HexDigit :: ONE OF See 7.8.3

0 1 2 3 4 5 6 7 8 9 A B C D E F A B C D E F

StringLiteral :: See 7.8.4

" DoubleStringCharacters~opt~ "
' SingleStringCharacters~opt~ '

DoubleStringCharacters :: See 7.8.4

DoubleStringCharacter DoubleStringCharacters~opt~

SingleStringCharacters :: See 7.8.4

SingleStringCharacter SingleStringCharacters~opt~

DoubleStringCharacter :: See 7.8.4

SourceCharacter BUT NOT ONE OF " OR \ OR LineTerminator
\ EscapeSequence
LineContinuation

SingleStringCharacter :: See 7.8.4

SourceCharacter BUT NOT ONE OF ' OR \ OR LineTerminator
\ EscapeSequence
LineContinuation

LineContinuation :: See 7.8.4

\ LineTerminatorSequence

EscapeSequence :: See 7.8.4

CharacterEscapeSequence
0 [lookahead ∉ DecimalDigit]
HexEscapeSequence
UnicodeEscapeSequence

CharacterEscapeSequence :: See 7.8.4

SingleEscapeCharacter
NonEscapeCharacter

SingleEscapeCharacter :: ONE OF See 7.8.4

' " \ B F N R T V

NonEscapeCharacter :: See 7.8.4

SourceCharacter BUT NOT ONE OF EscapeCharacter OR LineTerminator

EscapeCharacter :: See 7.8.4

SingleEscapeCharacter
DecimalDigit
X
U

HexEscapeSequence :: See 7.8.4

X HexDigit HexDigit

UnicodeEscapeSequence :: See 7.8.4

U HexDigit HexDigit HexDigit HexDigit

RegularExpressionLiteral :: See 7.8.5

/ RegularExpressionBody / RegularExpressionFlags

RegularExpressionBody :: See 7.8.5

RegularExpressionFirstChar RegularExpressionChars

RegularExpressionChars :: See 7.8.5

[empty]
RegularExpressionChars RegularExpressionChar

RegularExpressionFirstChar :: See 7.8.5

RegularExpressionNonTerminator BUT NOT ONE OF * OR \ OR / OR [
RegularExpressionBackslashSequence
RegularExpressionClass

RegularExpressionChar :: See 7.8.5

RegularExpressionNonTerminator BUT NOT \ OR / OR [
RegularExpressionBackslashSequence
RegularExpressionClass

RegularExpressionBackslashSequence :: See 7.8.5

\ RegularExpressionNonTerminator

RegularExpressionNonTerminator :: See 7.8.5

SourceCharacter BUT NOT LineTerminator

RegularExpressionClass :: See 7.8.5

[ RegularExpressionClassChars ]

RegularExpressionClassChars :: See 7.8.5

[empty]
RegularExpressionClassChars RegularExpressionClassChar

RegularExpressionClassChar :: See 7.8.5

RegularExpressionNonTerminator BUT NOT ] OR \
RegularExpressionBackslashSequence

RegularExpressionFlags :: See 7.8.5

[empty]
RegularExpressionFlags IdentifierPart


Number Conversions

StringNumericLiteral ::: See 9.1.3.1

StrWhiteSpace~opt~
StrWhiteSpace~opt~ StrNumericLiteral StrWhiteSpace~opt~

StrWhiteSpace ::: See 9.1.3.1

StrWhiteSpaceChar StrWhiteSpace~opt~

StrWhiteSpaceChar ::: See 9.1.3.1

WhiteSpace
LineTerminator

StrNumericLiteral ::: See 9.1.3.1

StrDecimalLiteral
HexIntegerLiteral

StrDecimalLiteral ::: See 9.1.3.1

StrUnsignedDecimalLiteral
+ StrUnsignedDecimalLiteral
- StrUnsignedDecimalLiteral

StrUnsignedDecimalLiteral ::: See 9.1.3.1

INFINITY
DecimalDigits . DecimalDigits~opt~ ExponentPart~opt~
. DecimalDigits ExponentPart~opt~
DecimalDigits ExponentPart~opt~

DecimalDigits ::: See 9.1.3.1

DecimalDigit
DecimalDigits DecimalDigit

DecimalDigit ::: ONE OF See 9.1.3.1

0 1 2 3 4 5 6 7 8 

ExponentPart ::: See 9.1.3.1

ExponentIndicator SignedInteger

ExponentIndicator ::: ONE OF See 9.1.3.1

E E

SignedInteger ::: See 9.1.3.1

DecimalDigits
+ DecimalDigits
- DecimalDigits

HexIntegerLiteral ::: See 9.1.3.1

0X HexDigit
0X HexDigit
HexIntegerLiteral HexDigit

HexDigit ::: ONE OF See 9.1.3.1

0 1 2 3 4 5 6 7 8 9 A B C D E F A B C D E F


Expressions

PrimaryExpression : See 11.1

THIS
Identifier
Literal
ArrayLiteral
ObjectLiteral
( Expression )

ArrayLiteral : See 11.1.4

[ Elision~opt~ ]
[ ElementList ]
[ ElementList , Elision~opt~ ]

ElementList : See 11.1.4

Elision~opt~ AssignmentExpression
ElementList , Elision~opt~ AssignmentExpression

Elision : See 11.1.4

,
Elision ,

ObjectLiteral : See 11.1.5

{ }
{ PropertyDefinitionList }
{ PropertyDefinitionList , }

PropertyDefinitionList : See 11.1.5

PropertyDefinition
PropertyDefinitionList , PropertyDefinition

PropertyDefinition : See 11.1.5

PropertyName : AssignmentExpression
GET PropertyName ( ) { FunctionBody }
SET PropertyName ( PropertySetParameterList ) { FunctionBody }

PropertyName : See 11.1.5

IdentifierName
StringLiteral
NumericLiteral

PropertySetParameterList : See 11.1.5

Identifier

MemberExpression : See 11.2

PrimaryExpression
FunctionExpression
MemberExpression [ Expression ]
MemberExpression . IdentifierName
NEW MemberExpression _Arguments_

NewExpression : See 11.2

MemberExpression
NEW NewExpression

CallExpression : See 11.2

MemberExpression Arguments
CallExpression Arguments
CallExpression [ Expression ]
CallExpression . IdentifierName

Arguments : See 11.2

( )
( ArgumentList )

ArgumentList : See 11.2

AssignmentExpression
ArgumentList , AssignmentExpression

LeftHandSideExpression : See 11.2

NewExpression
CallExpression

PostfixExpression : See 11.3

LeftHandSideExpression
LeftHandSideExpression [no LineTerminator here] ++
LeftHandSideExpression [no LineTerminator here] --

UnaryExpression : See 11.4

PostfixExpression
DELETE UnaryExpression
VOID UnaryExpression
TYPEOF UnaryExpression
++ UnaryExpression
-- UnaryExpression
+ UnaryExpression
- UnaryExpression
~ UnaryExpression
! UnaryExpression

MultiplicativeExpression : See 11.5

UnaryExpression
MultiplicativeExpression * UnaryExpression
MultiplicativeExpression / UnaryExpression
MultiplicativeExpression % UnaryExpression

AdditiveExpression : See 11.6

MultiplicativeExpression
AdditiveExpression + MultiplicativeExpression
AdditiveExpression - MultiplicativeExpression

ShiftExpression : See 11.7

AdditiveExpression
ShiftExpression << AdditiveExpression
ShiftExpression >> AdditiveExpression
ShiftExpression >>> AdditiveExpression

RelationalExpression : See 11.8

ShiftExpression
RelationalExpression < ShiftExpression
RelationalExpression > ShiftExpression
RelationalExpression <= ShiftExpression
RelationalExpression >= ShiftExpression
RelationalExpression INSTANCEOF ShiftExpression
RelationalExpression IN ShiftExpression

RelationalExpressionNoIn : See 11.8

ShiftExpression
RelationalExpressionNoIn < ShiftExpression
RelationalExpressionNoIn > ShiftExpression
RelationalExpressionNoIn <= ShiftExpression
RelationalExpressionNoIn >= ShiftExpression
RelationalExpressionNoIn INSTANCEOF ShiftExpression

EqualityExpression : See 11.9

RelationalExpression
EqualityExpression == RelationalExpression
EqualityExpression != RelationalExpression
EqualityExpression === RelationalExpression
EqualityExpression !== RelationalExpression

EqualityExpressionNoIn : See 11.9

RelationalExpressionNoIn
EqualityExpressionNoIn == RelationalExpressionNoIn
EqualityExpressionNoIn != RelationalExpressionNoIn
EqualityExpressionNoIn === RelationalExpressionNoIn
EqualityExpressionNoIn !== RelationalExpressionNoIn

BitwiseANDExpression : See 11.10

EqualityExpression
BitwiseANDExpression & EqualityExpression

BitwiseANDExpressionNoIn : See 11.10

EqualityExpressionNoIn
BitwiseANDExpressionNoIn & EqualityExpressionNoIn

BitwiseXORExpression : See 11.10

BitwiseANDExpression
BitwiseXORExpression ^ BitwiseANDExpression

BitwiseXORExpressionNoIn : See 11.10

BitwiseANDExpressionNoIn
BitwiseXORExpressionNoIn ^ BitwiseANDExpressionNoIn

BitwiseORExpression : See 11.10

BitwiseXORExpression
BitwiseORExpression | BitwiseXORExpression

BitwiseORExpressionNoIn : See 11.10

BitwiseXORExpressionNoIn
BitwiseORExpressionNoIn | BitwiseXORExpressionNoIn

LogicalANDExpression : See 11.11

BitwiseORExpression
LogicalANDExpression && BitwiseORExpression

LogicalANDExpressionNoIn : See 11.11

BitwiseORExpressionNoIn
LogicalANDExpressionNoIn && BitwiseORExpressionNoIn

LogicalORExpression : See 11.11

LogicalANDExpression
LogicalORExpression || LogicalANDExpression

LogicalORExpressionNoIn : See 11.11

LogicalANDExpressionNoIn
LogicalORExpressionNoIn || LogicalANDExpressionNoIn

ConditionalExpression : See 11.12

LogicalORExpression
LogicalORExpression ? AssignmentExpression : AssignmentExpression

ConditionalExpressionNoIn : See 11.12

LogicalORExpressionNoIn
LogicalORExpressionNoIn ? AssignmentExpression :
AssignmentExpressionNoIn

AssignmentExpression : See 11.13

ConditionalExpression
LeftHandSideExpression = AssignmentExpression
LeftHandSideExpression AssignmentOperator AssignmentExpression

AssignmentExpressionNoIn : See 11.13

ConditionalExpressionNoIn
LeftHandSideExpression = AssignmentExpressionNoIn
LeftHandSideExpression AssignmentOperator AssignmentExpressionNoIn

AssignmentOperator : ONE OF See 11.13

  ---- ---- ---- ---- ---- ----- ----- ------ ---- ---- ----
  *=   /=   %=   +=   -=   <<=   >>=   >>>=   &=   ^=   |=
  ---- ---- ---- ---- ---- ----- ----- ------ ---- ---- ----

Expression : See 11.14

AssignmentExpression
Expression , AssignmentExpression

ExpressionNoIn : See 11.14

AssignmentExpressionNoIn
ExpressionNoIn , AssignmentExpressionNoIn


Statements

Statement : See clause 12

Block
VariableStatement
EmptyStatement
ExpressionStatement
IfStatement
IterationStatement
ContinueStatement
BreakStatement
ReturnStatement
WithStatement
LabelledStatement
SwitchStatement
ThrowStatement
TryStatement
DebuggerStatement

Block : See 12.1

{ StatementList~opt~ }

StatementList : See 12.1

Statement
StatementList Statement

VariableStatement : See 12.2

VAR VariableDeclarationList ;

VariableDeclarationList : See 12.2

VariableDeclaration
VariableDeclarationList , VariableDeclaration

VariableDeclarationListNoIn : See 12.2

VariableDeclarationNoIn
VariableDeclarationListNoIn , VariableDeclarationNoIn

VariableDeclaration : See 12.2

Identifier Initialiser~opt~

VariableDeclarationNoIn : See 12.2

Identifier InitialiserNoIn~opt~

Initialiser : See 12.2

= AssignmentExpression

InitialiserNoIn : See 12.2

= AssignmentExpressionNoIn

EmptyStatement : See 12.3

;

ExpressionStatement : See 12.4

[lookahead ∉ {{, FUNCTION}] Expression ;

IfStatement : See 12.5

IF ( Expression ) Statement ELSE Statement
IF ( Expression ) Statement

IterationStatement : See 12.6

DO Statement WHILE ( Expression );
WHILE ( Expression ) Statement
FOR (ExpressionNoIn~opt~; Expression~opt~ ; Expression~opt~ ) Statement
FOR ( VAR VariableDeclarationListNoIn; Expression~opt~ ; Expression~opt~
) Statement
FOR ( LeftHandSideExpression IN Expression ) Statement
FOR ( VAR VariableDeclarationNoIn IN Expression ) Statement

ContinueStatement : See 12.7

CONTINUE ;
CONTINUE [no LineTerminator here] Identifier ;

BreakStatement : See 12.8

BREAK ;
BREAK [no LineTerminator here] Identifier ;

ReturnStatement : See 12.9

RETURN ;
RETURN [no LineTerminator here] Expression ;

WithStatement : See 12.10

WITH ( Expression ) Statement

SwitchStatement : See 12.11

SWITCH ( Expression ) CaseBlock

CaseBlock : See 12.11

{ CaseClauses~opt~ }
{ CaseClauses~opt~ DefaultClause CaseClauses~opt~ }

CaseClauses : See 12.11

CaseClause
CaseClauses CaseClause

CaseClause : See 12.11

CASE Expression : StatementList~opt~

DefaultClause : See 12.11

DEFAULT : StatementList~opt~

LabelledStatement : See 12.12

Identifier : Statement

ThrowStatement : See 12.13

THROW [no LineTerminator here] Expression ;

TryStatement : See 12.14

TRY Block Catch~
~TRY Block Finally~
~TRY Block Catch Finally

Catch : See 12.14

CATCH ( Identifier ) Block

Finally : See 12.14

FINALLY Block

DebuggerStatement : See 12.15

DEBUGGER ;


Functions and Scripts

FunctionDeclaration : See clause 13

FUNCTION Identifier ( FormalParameterList~opt~ ) { FunctionBody }

FunctionExpression : See clause 13

FUNCTION Identifier~opt~ ( FormalParameterList~opt~ ) { FunctionBody }

FormalParameterList : See clause 13

Identifier
FormalParameterList , Identifier

FunctionBody : See clause 13

SourceElements~opt~

Program : See clause 14

SourceElements~opt~

SourceElements : See clause 14

SourceElement
SourceElements SourceElement

SourceElement : See clause 14

Statement
FunctionDeclaration


Universal Resource Identifier Character Classes

uri ::: See 15.1.3

uriCharacters~opt~

uriCharacters ::: See 15.1.3

uriCharacter uriCharacters~opt~

uriCharacter ::: See 15.1.3

uriReserved
uriUnescaped
uriEscaped

uriReserved ::: ONE OF See 15.1.3

; / ? : @ & = + $ ,

uriUnescaped ::: See 15.1.3

uriAlpha
DecimalDigit
uriMark

uriEscaped ::: See 15.1.3

% HexDigit HexDigit

uriAlpha ::: ONE OF See 15.1.3

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

uriMark ::: ONE OF See 15.1.3

- _ . ! ~ * ' ( )


Regular Expressions

Pattern :: See 15.10.1

Disjunction

Disjunction :: See 15.10.1

Alternative
 Alternative | Disjunction

Alternative :: See 15.10.1

[empty]
Alternative Term

Term :: See 15.10.1

Assertion
Atom
Atom Quantifier

Assertion :: See 15.10.1

^
$
\ B
\ B
( ? = Disjunction )
( ? ! Disjunction )

Quantifier :: See 15.10.1

QuantifierPrefix
QuantifierPrefix ?

QuantifierPrefix :: See 15.10.1

*
+
?
{ DecimalDigits }
{ DecimalDigits , }
{ DecimalDigits , DecimalDigits }

Atom :: See 15.10.1

PatternCharacter
.
\ AtomEscape
CharacterClass
( Disjunction )
( ? : Disjunction )

_PatternCharacter_ :: See 15.10.

_SourceCharacter_ BUT NOT ONE OF-
 ^ $ \ . * + ? ( ) [ ] { } |

AtomEscape :: See 15.10.1

DecimalEscape
CharacterEscape
CharacterClassEscape

CharacterEscape :: See 15.10.1

ControlEscape
C ControlLetter
HexEscapeSequence
UnicodeEscapeSequence
IdentityEscape

ControlEscape :: ONE OF See 15.10.1

F N R T V

ControlLetter :: ONE OF See 15.10.1

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

IdentityEscape :: See 15.10.1

SourceCharacter BUT NOT IdentifierPart
<ZWJ>
<ZWNJ>

DecimalEscape :: See 15.10.1

DecimalIntegerLiteral [lookahead ∉ DecimalDigit]

CharacterClassEscape :: ONE OF See 15.10.1

D D S S W W

CharacterClass :: See 15.10.1

[ [lookahead ∉ {^}] ClassRanges ]
[ ^ ClassRanges ]

ClassRanges :: See 15.10.1

[empty]
NonemptyClassRanges

NonemptyClassRanges :: See 15.10.1

ClassAtom
ClassAtom NonemptyClassRangesNoDash
ClassAtom – ClassAtom ClassRanges

NonemptyClassRangesNoDash :: See 15.10.1

ClassAtom
ClassAtomNoDash NonemptyClassRangesNoDash
ClassAtomNoDash – ClassAtom ClassRanges

ClassAtom :: See 15.10.1

-
ClassAtomNoDash

ClassAtomNoDash :: See 15.10.1

SourceCharacter BUT NOT ONE OF \ OR ] OR -
\ ClassEscape

ClassEscape :: See 15.10.1

DecimalEscape
B
CharacterEscape
CharacterClassEscape


JSON

JSON Lexical Grammar

_JSONWhiteSpace_ :: See 15.12.1.

_<TAB>
<CR>
<LF>
<SP>_

JSONString :: See 15.12.1.1

" JSONStringCharacters~opt~ "

JSONStringCharacters :: See 15.12.1.1

JSONStringCharacter JSONStringCharacters~opt~

JSONStringCharacter :: See 15.12.1.1

SourceCharacter BUT NOT ONE OF " OR \ OR U+0000 THROUGH U+001F

\ JSONEscapeSequence

JSONEscapeSequence :: See 15.12.1.1

JSONEscapeCharacter

UnicodeEscapeSequence

JSONEscapeCharacter :: ONE OF See 15.12.1.1

" / \ B F N R T

JSONNumber :: See 15.12.1.1

-~opt~ DecimalIntegerLiteral JSONFraction~opt~ ExponentPart~opt~

JSONFraction :: See 15.12.1.1

. DecimalDigits

JSONNullLiteral :: See 15.12.1.1

NullLiteral

JSONBooleanLiteral :: See 15.12.1.1

BooleanLiteral

JSON Syntactic Grammar

JSONText : See 15.12.1.2

JSONValue

JSONValue : See 15.12.1.2

JSONNullLiteral
JSONBooleanLiteral
JSONObject
JSONArray
JSONString
JSONNumber

JSONObject : See 15.12.1.2

{ }
{ JSONMemberList }

JSONMember : See 15.12.1.2

JSONString : JSONValue

JSONMemberList : See 15.12.1.2

JSONMember
JSONMemberList , JSONMember

JSONArray : See 15.12.1.2

[ ]
[ JSONElementList ]

JSONElementList : See 15.12.1.2

JSONValue
JSONElementList , JSONValue

(normative)
Additional ECMAScript Features for Web Browsers

The ECMAScript language syntax and semantics defined in this annex are
required when the ECMAScript host is a web browser. The content of this
annex is normative but optional if the ECMAScript host is not a web
browser.


Additional Syntax

Numeric Literals

The syntax and semantics of 7.8.3 is extended as follows except that
this extension is not allowed for strict mode code:

Syntax

NumericLiteral ::

DecimalLiteral
BinaryIntegerLiteral
OctalIntegerLiteral
HexIntegerLiteral
LegacyOctalIntegerLiteral

LegacyOctalIntegerLiteral ::

0 OctalDigit
LegacyOctalIntegerLiteral OctalDigit

STATIC

SEMANTICS

-   -   -   -   -   -   -   -   -   -   The MV of
      _LegacyOctalIntegerLiteral_ :: 0 _OctalDigit_ is the MV of
      _OctalDigit_.

-   The MV of _LegacyOctalIntegerLiteral_ :: _LegacyOctalIntegerLiteral_
      _OctalDigit_ is (the MV of _LegacyOctalIntegerLiteral_ times 8)
      plus the MV of _OctalDigit_.

String Literals

The syntax and semantics of 7.8.4 is extended as follows except that
this extension is not allowed for strict mode code:

Syntax

EscapeSequence ::

CharacterEscapeSequence
OctalEscapeSequence
HexEscapeSequence
UnicodeEscapeSequence

OctalEscapeSequence ::

OctalDigit [lookahead ∉ DecimalDigit]
ZeroToThree OctalDigit [lookahead ∉ DecimalDigit]
FourToSeven OctalDigit
ZeroToThree OctalDigit OctalDigit

ZeroToThree :: ONE OF

0 1 2 

FourToSeven :: ONE OF

4 5 6 

Static Semantics

-   The CV of _EscapeSequence_ :: _OctalEscapeSequence_ is the CV of the
    _OctalEscapeSequence_.

-   The CV of _OctalEscapeSequence_ :: _OctalDigit_ [lookahead ∉
    _DecimalDigit_] is the character whose code unit value is the MV of
    the _OctalDigit_.

-   The CV of _OctalEscapeSequence_ :: _ZeroToThree_ _OctalDigit_
    [lookahead ∉ _DecimalDigit_] is the character whose code unit value
    is (8 times the MV of the _ZeroToThree_) plus the MV of the
    _OctalDigit_.

-   The CV of _OctalEscapeSequence_ :: _FourToSeven_ _OctalDigit_ is the
    character whose code unit value is (8 times the MV of the
    _FourToSeven_) plus the MV of the _OctalDigit_.

-   The CV of _OctalEscapeSequence_ :: _ZeroToThree_ _OctalDigit_
    _OctalDigit_ is the character whose code unit value is (64 (that is,
    8^2^) times the MV of the _ZeroToThree_) plus (8 times the MV of the
    first _OctalDigit_) plus the MV of the second _OctalDigit_.

-   The MV of _ZeroToThree_ :: 0 is 0.

-   The MV of _ZeroToThree_ :: 1 is 1.

-   The MV of _ZeroToThree_ :: 2 is 2.

-   The MV of _ZeroToThree_ :: 3 is 3.

-   The MV of _FourToSeven_ :: 4 is 4.

-   The MV of _FourToSeven_ :: 5 is 5.

-   The MV of _FourToSeven_ :: 6 is 6.

-   The MV of _FourToSeven_ :: 7 is 7.

HTML-like Comments

TODO See _http://javascript.spec.whatwg.org/#comment-syntax_


Additional Properties

When the ECMAScript host is a web browser the following additional
properties of the standard built-in objects are defined.

Additional Properties of the Global Object

escape (string)

The ESCAPE function is a property of the global object. It computes a
new version of a String value in which certain characters have been
replaced by a hexadecimal escape sequence.

For those characters being replaced whose code unit value is 0XFF or
less, a two-digit escape sequence of the form %_xx_ is used. For those
characters being replaced whose code unit value is greater than 0XFF, a
four-digit escape sequence of the form %U_xxxx_ is used.

When the ESCAPE function is called with one argument _string_, the
following steps are taken:

NOTE The encoding is partly based on the encoding described in RFC 1738,
but the entire encoding specified in this standard is described above
without regard to the contents of RFC 1738. This encoding does not
reflect changes to RFC 1738 made by RFC 3986.

unescape (string)

The UNESCAPE function is a property of the global object. It computes a
new version of a String value in which each escape sequence of the sort
that might be introduced by the ESCAPE function is replaced with the
character that it represents.

When the UNESCAPE function is called with one argument _string_, the
following steps are taken:

Additional Properties of the Object.prototype Object

Object.prototype.__proto__ 

Object.prototype.__proto__ is an accessor property with attributes {
[[Enumerable]]: FALSE, [[Configurable]]: TRUE }. The [[Get]] and [[Set]]
attributes are defined as follows

get Object.prototype.__proto__ 

The value of the [[Get]] attribute is a built-in function that requires
no arguments. It performs the following steps:

1.  Let _O_ be the THIS value_.

2.  If Type(_O)_ is not Object, then throw a TYPEERROR exception.

3.  Return the result of calling the [[GetInheritance]] internal method
    of _O_.

set Object.prototype.__proto__ 

The value of the [[Set]] attribute is a built-in function that takes an
argument _proto_. It performs the following steps:

1.  Let _O_ be the THIS value_.

2.  If Type(_O)_ is not Object, then throw a TYPEERROR exception.

3.  If Type(_proto_) is neither Object or Null, then throw a TYPEERROR
    exception.

4.  Let _status_ be the result of calling the [[SetInheritance]]
    internal method of _O_ with argument _proto_.

5.  ReturnIfAbrupt(_status_).

6.  If _status_ is FALSE, then throw a TYPEERROR exception.

7.  Return _proto_.

Additional Properties of the String.prototype Object

String.prototype.substr (start, length)

The SUBSTR method takes two arguments, _start_ and _length_, and returns
a substring of the result of converting the this object to a String,
starting from character position _start_ and running for _length_
characters (or through the end of the String if _length_ is UNDEFINED).
If _start_ is negative, it is treated as (_sourceLength_+_start_) where
_sourceLength_ is the length of the String. The result is a String
value, not a String object. The following steps are taken:

The LENGTH property of the SUBSTR method is 2.

NOTE The SUBSTR function is intentionally generic; it does not require
that its THIS value be a String object. Therefore it can be transferred
to other kinds of objects for use as a method.

String.prototype.anchor ( name )

When the ANCHOR method is called with argument _name_, the following
steps are taken:

The abstract operation CreateHTML is called with arguments _string,
tag_, _attribute_, and _value_. The arguments _tag_ and _attribute_ must
be string values. The following steps are taken:

1.  Let _str_ be CheckObjectCoercible(_string_).

2.  Let _S_ be ToString(_str_).

3.  ReturnIfAbrupt(_S_).

4.  a.  b.  

5.  Let _p1_ be the string value that is the concatenation of "<" and
    _tag_.

6.  If _attribute_ is not the empty String, then

    a.  Let _V_ be the result of performing ToString(_value_).

    b.  ReturnIfAbrupt(_V_).

    c.  Let _escapedV_ be the string value that is the same as _V_
        except that each occurrence of the character " (code unit value
        0x0022) in _V_ has been replaced with the six character sequence
        "&QUOT;".

    d.  Let _p1_ be the string value that is the concatenation of the
        following string values:

-   _p1_

-   a single space code unit 0x0020

-   _attribute_

-   "="

-   ′"′

-   _escapedV_

-   ′"′

1.  Let _p2_ be the string value that is the concatenation of _p1_ and
    ">".

2.  Let _p3_ be the string value that is the concatenation of _p2_ and
    _S_.

3.  Let _p4_ be the string value that is the concatenation of _p2_,
    "</", _tag_, and ">".

4.  Return _p4_.

String.prototype.big ()

When the BIG method is called with no arguments, the following steps are
taken:

1.  Let _S_ be the THIS value.

2.  Return the result of performing the abstract operation CreateHTML
    with arguments _S_, "BIG", "" and "".

String.prototype.blink ()

When the BLINK method is called with no arguments, the following steps
are taken:

1.  Let _S_ be the THIS value.

2.  Return the result of performing the abstract operation CreateHTML
    with arguments _S_, "BLINK", "" and "".

String.prototype.bold ()

When the BOLD method is called with no arguments, the following steps
are taken:

1.  Let _S_ be the THIS value.

2.  Return the result of performing the abstract operation CreateHTML
    with arguments _S_, "B", "" and "".

String.prototype.fixed ()

When the FIXED method is called with no arguments, the following steps
are taken:

1.  Let _S_ be the THIS value.

2.  Return the result of performing the abstract operation CreateHTML
    with arguments _S_, "TT", "" and "".

String.prototype.fontcolor ( color )

When the FONTCOLOR method is called with argument _color_, the following
steps are taken:

1.  Let _S_ be the THIS value.

2.  Return the result of performing the abstract operation CreateHTML
    with arguments _S_, "FONT", "COLOR" and _color_.

String.prototype.fontsize ( size )

When the FONTSIZE method is called with argument _size_, the following
steps are taken:

1.  Let _S_ be the THIS value.

2.  Return the result of performing the abstract operation CreateHTML
    with arguments _S_, "FONT", "SIZE" and _size_.

String.prototype.italics ()

When the ITALICS method is called with no arguments, the following steps
are taken:

1.  Let _S_ be the THIS value.

2.  Return the result of performing the abstract operation CreateHTML
    with arguments _S_, "I", "" and "".

String.prototype.link ( url )

When the LINK method is called with argument _url_, the following steps
are taken:

1.  Let _S_ be the THIS value.

2.  Return the result of performing the abstract operation CreateHTML
    with arguments _S_, "A", "HREF" and _url_.

String.prototype.small ()

When the SMALL method is called with no arguments, the following steps
are taken:

1.  Let _S_ be the THIS value.

2.  Return the result of performing the abstract operation CreateHTML
    with arguments _S_, "SMALL", "" and "".

String.prototype.strike ()

When the STRIKE method is called with no arguments, the following steps
are taken:

1.  Let _S_ be the THIS value.

2.  Return the result of performing the abstract operation CreateHTML
    with arguments _S_, "STRIKE", "" and "".

String.prototype.sub ()

When the SUB method is called with no arguments, the following steps are
taken:

1.  Let _S_ be the THIS value.

2.  Return the result of performing the abstract operation CreateHTML
    with arguments _S_, "SUB", "" and "".

String.prototype.sup ()

When the SUP method is called with no arguments, the following steps are
taken:

1.  Let _S_ be the THIS value.

2.  Return the result of performing the abstract operation CreateHTML
    with arguments _S_, "SUP", "" and "".

Additional Properties of the Date.prototype Object

Date.prototype.getYear ( )

NOTE The GETFULLYEAR method is preferred for nearly all purposes,
because it avoids the “year 2000 problem.”

When the GETYEAR method is called with no arguments, the following steps
are taken:

1.  Let _t_ be this time value.

2.  ReturnIfAbrupt(_t_).

3.  If _t_ is NAN, return NAN.

4.  Return YearFromTime(LocalTime(_t_)) − 1900.

Date.prototype.setYear (year)

NOTE The SETFULLYEAR method is preferred for nearly all purposes,
because it avoids the “year 2000 problem.”

When the SETYEAR method is called with one argument _year_, the
following steps are taken:

Date.prototype.toGMTString ( )

NOTE The property TOUTCSTRING is preferred. The TOGMTSTRING property is
provided principally for compatibility with old code. It is recommended
that the TOUTCSTRING property be used in new ECMAScript code.

The Function object that is the initial value of
DATE.PROTOTYPE.TOGMTSTRING is the same Function object that is the
initial value of DATE.PROTOTYPE.TOUTCSTRING.

Additional Properties of the RegExp.prototype Object

RegExp.prototype.compile (pattern, flags )

When the COMPILE method is called with no arguments, the following steps
are taken:

1.  Let _O_ be the THIS value.

2.  If Type(_O_) is not Object or Type(_O_) is Object and _O_ does not
    have a [[RegExpMatcher]] internal data property, then

    a.  Throw a TYPEERROR exception.

3.  Let _extensible_ be the result of calling the [[IsExtensible]]
    internal method of _O_.

4.  If _extensible_ is FALSE, then throw a TYPEERROR exception.

5.  If Type(_pattern_) is Object and _pattern_ has a [[RegExpMatcher]]
    internal data property, then

    a.  If the value of _pattern’s_ [[RegExpMatcher]] internal data
        property is UNDEFINED, then throw a TYPEERROR exception.

    b.  If _flags_ is not UNDEFINED, then throw a TYPEERROR exception.

    c.  Let _P_ be the value of _pattern’s_ [[OriginalSource]] internal
        data property.

    d.  Let _F_ be the value of _pattern’s_ [[OriginalFlags]] internal
        data property.

6.  Else,

    a.  let _P_ be _pattern_.

    b.  let _F_ be _flags_.

7.  Return the result of the abstract operation RegExpInitialize with
    arguments _obj,_ _P_, and _F_ .

NOTE The COMPILE method completely reinitialized the this object RegExp
with a new pattern and flags. An implementaton may interpret use of this
method as an assertion that the resulting RegExp object will be used
multiple times and hence is a candidate for extra optimization.


Other Additional Features

__proto___ Property Names in Object Initialisers

In 11.1.5 the Property Definition Evaluation algorithm for the
production _PropertyDefinition_ : _PropertyName_ :
_AssignmentExpression_ is replaced with the following:

_PropertyDefinition_ : _PropertyName_ : _AssignmentExpression

1.  Let _propName_ be PropName of _PropertyName_.

2.  Let _exprValue_ be the result of evaluating _AssignmentExpression_.

3.  Let _propValue_ be GetValue(_exprValue_).

4.  ReturnIfAbrupt(_propValue_).

5.  If _propName_ is the string value "__PROTO__", then

    a.  If Type(_v_) is neither Object or Null, then throw a TYPEERROR
        exception.

    b.  Return the result of calling the [[SetInheritance]] internal
        method of _object_ with argument _propValue_.

6.  Let _desc_ be the Property Descriptor{[[Value]]: _propValue_,
    [[Writable]]: TRUE, [[Enumerable]]: TRUE, [[Configurable]]: TRUE}

7.  Return the result of DefinePropertyOrThrow(_object_, _propName
    _desc_).

    1.  Web Legacy Compatibility for Block-Level Function Declarations

1.  a.  b.  i.  

2.  

1.  a.  b.  i.  ii. iii. 

2.  

1.  a.  

2.  

1.  a.  i.  

2.  

1.  2.  3.  a.  b.  c.  i.  

    d.  

4.  5.  

5.  6.  

Prior to the Sixth Edition, the ECMAScript specification did not define
the occurrence of a _FunctionDeclaration_ as an element of a _Block_
statement’s _StatementList_. However, support for that form of
_FunctionDeclaration_ was an allowable extension and most browser-hosted
ECMAScript implementations permitted them. However, the semantics of
such declarations differ among those implementations. Because of these
semantic differences, existing web ECMAScript code that uses _Block_
level function declarations is only portable among browser
implementation if the usage only depends upon the semantic intersection
of all of the browser implementations for such declarations. The
following are the use cases that fall within that intersection
semantics:

1.  A function is declared and only referenced within a single block

    -   A function declaration with the name _f_ is declared exactly
        once within the function code of an enclosing function _g_ and
        that declaration is nested within a _Block_.

    -   No other declaration of _f_ that is not a VAR declaration occurs
        within the function code of _g_

    -   All references to _f_ occur within the _StatementList_ of the
        _Block_ containing the declaration of _f_.

2.  A function is declared and possibly used within a single _Block_ but
    also referenced by an inner function definition that is not
    contained within that same _Block_.

    -   A function declaration with the name _f_ is declared exactly
        once within the function code of an enclosing function _g_ and
        that declaration is nested within a _Block_.

    -   No other declaration of _f_ that is not a VAR declaration occurs
        within the function code of _g_

    -   References to _f_ may occur within the _StatementList_ of the
        _Block_ containing the declaration of _f_.

    -   References to _f_ occur within the function code of _g_ that
        lexically follows the _Block_ containing the declaration of _f_.

3.  A function is declared and possibly used within a single block but
    also referenced within subsequent blocks.

    -   A function declaration with the name _f_ is declared exactly
        once within the function code of an enclosing function _g_ and
        that declaration is nested within a _Block_.

    -   No other declaration of _f_ that is not a VAR declaration occurs
        within the function code of _g_

    -   References to _f_ may occur within the _StatementList_ of the
        _Block_ containing the declaration of _f_.

    -   References to _f_ occur within another function _h_ that is
        nested within _g_ and no other declaration of _f_ shadows the
        references to _f_ from within _h_.

    -   All invocations of _h_ occur after the declaration of _f_ has
        been evaluated.

The first use case is interoperable with the inclusion of _Block_ level
function declarations in the sixth edition. Any pre-existing ECMAScript
code that employees that use case will operate using the Block level
function declarations semantics defined by clauses 10 and 13 of this
specification.

Sixth edition interoperability for the second and third use cases
requires the following extensions to the clauses 10 and 13 semantics.
These extensions are applied to a non-strict mode functions _g_ if the
above pre-conditions of use cases 2 and 3 above exist at the time of
static semantic analysis of _g_. However, the last pre-condition of use
case 3 is not included in this determination and the determination is
not applied to any function declaration that is nested within syntactic
constructs that are specified in the Fifth edition of this
specification.

1.  Let _B_ be environment record for the construct within _g_ that
    introduces a new environment contour and which most closely encloses
    the declaration of _f_, all function code references to _f_, and the
    definitions of all nested functions that contain unshadowed
    references to _f_. This syntactic construct may be the definition of
    _g_ itself, in which case _B_ is the function environment record for
    _g_.

2.  As part of the instantiation of _B_, its CreateMutableBinding
    concrete method is called with arguments “f” (the string name of the
    function) and FALSE. This creates an unitialised binding for the
    name _f_. Any reference that resolves to that binding prior to step
    3 below will throw a REFERENCEERROR exception.

3.  When the InitialiseBinding concrete method is used to initialise the
    binding for the function declaration _f_ also invoke InitializeBind
    on _B_ using the same arguments.

If an ECMAScript implication has a mechanism that produces diagnostic
warning messages, a warning should be produced for each function _g_ for
which the above steps are performed.

(informative)
The Strict Mode of ECMAScript

THE STRICT MODE RESTRICTION AND EXCEPTIONS

-   The identifiers "IMPLEMENTS", "INTERFACE", "LET", "PACKAGE",
      "PRIVATE", "PROTECTED", "PUBLIC", "STATIC", and "YIELD" are
      classified as _FutureReservedWord_ tokens within strict mode code.
      (7.6.1.2).

-   A conforming implementation, when processing strict mode code, may
      not extend the syntax of _NumericLiteral_ (7.8.3) to include
      _OctalIntegerLiteral_ as described in B.1.1.

-   A conforming implementation, when processing strict mode code (see
      10.1.1), may not extend the syntax of _EscapeSequence_ to include
      _OctalEscapeSequence_ as described in B.1.2.

-   Assignment to an undeclared identifier or otherwise unresolvable
      reference does not create a property in the global object. When a
      simple assignment occurs within strict mode code, its
      _LeftHandSide_ must not evaluate to an unresolvable Reference. If
      it does a REFERENCEERROR exception is thrown (8.9.2). The
      _LeftHandSide_ also may not be a reference to a data property with
      the attribute value {[[Writable]]:FALSE}, to an accessor property
      with the attribute value {[[Set]]:UNDEFINED}, nor to a
      non-existent property of an object whose [[Extensible]] internal
      data property has the value FALSE. In these cases a TYPEERROR
      exception is thrown (11.13.1).

-   The identifier EVAL or ARGUMENTS may not appear as the
      _LeftHandSideExpression_ of an Assignment operator (11.13) or of a
      _PostfixExpression_ (11.3) or as the _UnaryExpression_ operated
      upon by a Prefix Increment (11.4.4) or a Prefix Decrement (11.4.5)
      operator.

-   Arguments objects for strict mode functions define non-configurable
      accessor properties named "CALLER" and "CALLEE" which throw a
      TYPEERROR exception on access (10.6).

-   Arguments objects for strict mode functions do not dynamically share
      their array indexed property values with the corresponding formal
      parameter bindings of their functions. (10.6).

-   For strict mode functions, if an arguments object is created the
      binding of the local identifier ARGUMENTS to the arguments object
      is immutable and hence may not be the target of an assignment
      expression. (10.5).

-   It is a SYNTAXERROR if strict mode code contains an _ObjectLiteral_
      with more than one definition of any data property (11.1.5).

-   It is a SYNTAXERROR if the _Identifier_ "EVAL" or the _Identifier_
      "ARGUMENTS" occurs as the _Identifier_ in a
      _PropertySetParameterList_ of a _PropertyDefinition_ that is
      contained in strict code or if its _FunctionBody_ is strict code
      (11.1.5).

-   Strict mode eval code cannot instantiate variables or functions in
      the variable environment of the caller to eval. Instead, a new
      variable environment is created and that environment is used for
      declaration binding instantiation for the eval code (10.4.2).

-   If THIS is evaluated within strict mode code, then the THIS value is
      not coerced to an object. A THIS value of NULL or UNDEFINED is not
      converted to the global object and primitive values are not
      converted to wrapper objects. The THIS value passed via a function
      call (including calls made using FUNCTION.PROTOTYPE.APPLY and
      FUNCTION.PROTOTYPE.CALL) do not coerce the passed this value to an
      object (10.4.3, 11.1.1, 15.3.3.3, 15.3.3.4).

-   When a DELETE operator occurs within strict mode code, a SYNTAXERROR
      is thrown if its _UnaryExpression_ is a direct reference to a
      variable, function argument, or function name(11.4.1).

-   When a DELETE operator occurs within strict mode code, a TYPEERROR
      is thrown if the property to be deleted has the attribute {
      [[Configurable]]:FALSE } (11.4.1).

-   It is a SYNTAXERROR if a _VariableDeclaration_ or
      _VariableDeclarationNoIn_ occurs within strict code and its
      _Identifier_ is EVAL or ARGUMENTS (12.2.1).

-   Strict mode code may not include a _WithStatement_. The occurrence
      of a _WithStatement_ in such a context is an SYNTAXERROR (12.10).

-   It is a SYNTAXERROR if a _TryStatement_ with a _Catch_ occurs within
      strict code and the _Identifier_ of the _Catch_ production is EVAL
      or ARGUMENTS (12.14.1)

-   It is a SYNTAXERROR if the identifier EVAL or ARGUMENTS appears
      within the _FormalParameters_ of a strict mode
      _FunctionDeclaration_ or _FunctionExpression_ (13.1)

-   A strict mode function may not have two or more formal parameters
      that have the same name. An attempt to create such a function
      using a _FunctionDeclaration_, _FunctionExpression_, or FUNCTION
      constructor is a SYNTAXERROR (13.1, 15.3.1).

-   An implementation may not extend, beyond that defined in this
      specification, the meanings within strict mode functions of
      properties named CALLER or ARGUMENTS of function instances.
      ECMAScript code may not create or modify properties with these
      names on function objects that correspond to strict mode functions
      (8.3.15.6, 10.6, 15.3.3.5.3).

-   It is a SYNTAXERROR to use within strict mode code the identifiers
      EVAL or ARGUMENTS as the _Identifier_ of a _FunctionDeclaration_
      or _FunctionExpression_ or as a formal parameter name (13.1).
      Attempting to dynamically define such a strict mode function using
      the FUNCTION constructor (15.3.1) will throw a SYNTAXERROR
      exception.

(informative)
Corrections and Clarifications with Possible Compatibility Impact

IN EDITION 6

15.9.1.14: Previous editions permitted the TimeClip abstract operation
to return either +0 or −0 as the representation of a 0 time value. The
6^th^ Edition specifies that +0 always returned. This means that for the
6^th^ Edition the time value of a Date object is never observably −0 and
methods that return time values never return −0.

15.9.1.15: If a time zone offset is not present, the local time zone is
used. Edition 5.1 incorrectly stated that a missing time zone should be
interpreted as “z”.

15.9.5.2: Previous editions did not specify the value returned by
Date.prototype.toString when this time value is NaN. The 6^th^ Edition
specifies the result to be the String value is "INVALID DATE"

IN EDITION 5.1

7.8.4: CV definitions added for _DoubleStringCharacter_ ::
_LineContinuation_ and _SingleStringCharacter_ :: _LineContinuation_.

10.2.1.1.3: The argument S is not ignored. It controls whether an
exception is thrown when attempting to set an immutable binding.

10.2.1.2.2: In algorithm step 5, TRUE is passed as the last argument to
[[DefineOwnProperty]].

10.5: Former algorithm step 5.e is now 5.f and a new step 5.e was added
to restore compatibility with 3^rd^ Edition when redefining global
functions.

11.5.3: In the final bullet item, use of IEEE 754 round-to-nearest mode
is specified.

12.6.3: Missing ToBoolean restored in step 3.a.ii of both algorithms.

12.6.4: Additional final sentences in each of the last two paragraphs
clarify certain property enumeration requirements.

12.7, 12.8, 12.9: BNF modified to clarify that a CONTINUE or BREAK
statement without an _Identifier_ or a RETURN statement without an
_Expression_ may have a _LineTerminator_ before the semi-colon.

12.14: Step 3 of algorithm 1 and step 2.a of algorithm 3 are corrected
such that the value field of _B_ is passed as a parameter rather than
_B_ itself.

15.1.2.2: In step 2 of algorithm, clarify that _S_ may be the empty
string.

15.1.2.3: In step 2 of algorithm clarify that _trimmedString_ may be the
empty string.

15.1.3: Added notes clarifying that ECMAScript’s URI syntax is based
upon RFC 2396 and not the newer RFC 3986. In the algorithm for Decode, a
step was removed that immediately preceded the current step 4.d.vii.10.a
because it tested for a condition that cannot occur.

15.2.3.7: Corrected use of variable _P_ in steps 5 and 6 of algorithm.

15.2.4.2: Edition 5 handling of UNDEFINED and NULL as THIS value caused
existing code to fail. Specification modified to maintain compatibility
with such code. New steps 1 and 2 added to the algorithm.

15.3.3.3: Steps 5 and 7 of Edition 5 algorithm have been deleted because
they imposed requirements upon the _argArray_ argument that are
inconsistent with other uses of generic array-like objects.

15.4.3.12: In step 9.a, incorrect reference to _relativeStart_ was
replaced with a reference to _actualStart_.

15.4.3.15: Clarified that the default value for _fromIndex_ is the
length minus 1 of the array.

15.4.3.18: In step 9 of the algorithm, UNDEFINED is now the specified
return value.

15.4.3.22: In step 9.c.ii the first argument to the [[Call]] internal
method has been changed to UNDEFINED for consistency with the definition
of Array.prototype.reduce.

15.4.5.1: In Algorithm steps 3.l.ii and 3.l.iii the variable name was
inverted resulting in an incorrectly inverted test.

15.5.4.9: Normative requirement concerning canonically equivalent
strings deleted from paragraph following algorithm because it is listed
as a recommendation in NOTE 2.

15.5.4.14: In split algorithm step 11.a and 13.a, the positional order
of the arguments to _SplitMatch_ was corrected to match the actual
parameter signature of _SplitMatch_. In step 13.a.iii.7.d, _lengthA_
replaces _A_.length.

15.5.5.2: In first paragraph, removed the implication that the
individual character property access had “array index” semantics.
Modified algorithm steps 3 and 5 such that they do not enforce “array
index” requirement.

15.9.1.15: Specified legal value ranges for fields that lacked them.
Eliminated “time-only” formats. Specified default values for all
optional fields.

15.10.2.2: The step numbers of the algorithm for the internal closure
produced by step 2 were incorrectly numbered in a manner that implied
that they were steps of the outer algorithm.

15.10.2.6: In the abstract operation _IsWordChar_ the first character in
the list in step 3 is “A” rather than “A”.

15.10.2.8: In the algorithm for the closure returned by the abstract
operation _CharacterSetMatcher_, the variable defined by step 3 and
passed as an argument in step 4 was renamed to _ch_ in order to avoid a
name conflict with a formal parameter of the closure.

15.10.6.2: Step 9.e was deleted because It performed an extra increment
of _i_.

15.11.1.1: Removed requirement that the message own property is set to
the empty String when the _message_ argument is UNDEFINED.

15.11.1.2: Removed requirement that the message own property is set to
the empty String when the _message_ argument is UNDEFINED.

15.11.4.4: Steps 6-10 modified/added to correctly deal with missing or
empty message property value.

15.11.1.2: Removed requirement that the message own property is set to
the empty String when the _message_ argument is UNDEFINED.

15.12.3: In step 10.b.iii of the _JA_ abstract operation, the last
element of the concatenation is “]”.

B.2.1: Added to NOTE that the encoding is based upon RFC 1738 rather
than the newer RFC 3986.

Annex C: An item was added corresponding to 7.6.12 regarding
_FutureReservedWords_ in strict mode.

IN EDITION 5

Throughout: In the Edition 3 specification the meaning of phrases such
as “as if by the expression NEW ARRAY()” are subject to
misinterpretation. In the Edition 5 specification text for all internal
references and invocations of standard built-in objects and methods has
been clarified by making it explicit that the intent is that the actual
built-in object is to be used rather than the current dynamically
resolved value of the correspondingly identifier binding.

11.8.1: ECMAScript generally uses a left to right evaluation order,
however the Edition 3 specification language for the > and <= operators
resulted in a partial right to left order. The specification has been
corrected for these operators such that it now specifies a full left to
right evaluation order. However, this change of order is potentially
observable if side-effects occur during the evaluation process.

11.1.4: Edition 5 clarifies the fact that a trailing comma at the end of
an _ArrayInitialiser_ does not add to the length of the array. This is
not a semantic change from Edition 3 but some implementations may have
previously misinterpreted this.

11.2.3: Edition 5 reverses the order of steps 2 and 3 of the algorithm.
The original order as specified in Editions 1 through 3 was incorrectly
specified such that side-effects of evaluating _Arguments_ could affect
the result of evaluating _MemberExpression_.

12.4: In Edition 3, an object is created, as if by NEW OBJECT()to serve
as the scope for resolving the name of the exception parameter passed to
a CATCH clause of a TRY statement. If the actual exception object is a
function and it is called from within the CATCH clause, the scope object
will be passed as the THIS value of the call. The body of the function
can then define new properties on its THIS value and those property
names become visible identifiers bindings within the scope of the CATCH
clause after the function returns. In Edition 5, when an exception
parameter is called as a function, UNDEFINED is passed as the THIS
value.

13: In Edition 3, the algorithm for the production _FunctionExpression
with an _Identifier_ adds an object created as if by NEW OBJECT() to the
scope chain to serve as a scope for looking up the name of the function.
The identifier resolution rules (10.1.4 in Edition 3) when applied to
such an object will, if necessary, follow the object’s prototype chain
when attempting to resolve an identifier. This means all the properties
of Object.prototype are visible as identifiers within that scope. In
practice most implementations of Edition 3 have not implemented this
semantics. Edition 5 changes the specified semantics by using a
Declarative Environment Record to bind the name of the function.

14: In Edition 3, the algorithm for the production _SourceElements_ :
_SourceElements SourceElement_ did not correctly propagate statement
result values in the same manner as _Block_. This could result in the
EVAL function producing an incorrect result when evaluating a _Program_
text. In practice most implementations of Edition 3 have implemented the
correct propagation rather than what was specified in Edition 5.

15.10.6: RegExp.prototype is now a RegExp object rather than an instance
of Object. The value of its [[Class]] internal data property which is
observable using Object.prototype.toString is now “RegExp” rather than
“Object”.

(informative)
Additions and Changes that
Introduce Incompatibilities with Prior Editions


In the 6^th^ Edition

12.6: In Edition 6, a terminating semi-colon is no longer required at
the end of a do-while statement.

12.14: In Edition 6, it is an early error for a _Catch_ clause to
contained a VAR declaration for the same _Identifier_ that appears as
the _Catch_ clause parameter. In previous editions, such a variable
declaration would be instantiated in the enclosing variable environment
but the declaration’s _Initializer_ value would be assigned to the
_Catch_ parameter.

13.3 In Edition 6, the function objects that are created as the values
of the [[Get]] or [[Set]] attribute of accessor properties in an
_ObjectLiteral_ are not constructor functions. In Edition 5, they were
constructors.

15.2.3.5 and 15.2.3.7: In Edition 6, all property additions and changes
are processed, even if one of them throws an acception. If an exception
occurs during such processing, the first such exception is thrown after
all propertie are processed. In Edition 5, processing of property
additions and changes immediately terminated when the first exception
occurred.

15.5.4 In Edition 6, the Array prototype object is not a Arrayn
instance. In previous editions it was an Array instance with a length
property whose value was +0.

15.5.4 In Edition 6, the String prototype object is not a String
instance. In previous editions it was a String instance whose String
value was the empty string.

15.6.4 In Edition 6, the Boolean prototype object is not a Boolean
instance. In previous editions it was a Boolean instance whose Boolean
value was FALSE.

15.7.4 In Edition 6, the Number prototype object is not a Number
instance. In previous editions it was a Number instance whose number
value was +0.

15.9.5 In Edition 6, the Date prototype object is not a Date instance.
In previous editions it was a Date instance whose TimeValue was NaN.

15.10.6 In Edition 6, the RegExp prototype object is not a RegExp
instance. In previous editions it was a RegExp instance whose pattern is
the empty string.

15.10.7 In Edition 6, SOURCE, GLOBAL, IGNORECASE, and MULTILINE are
accessor properties defined on the RegExp prototype object. In previous
editions they were data properties defined on RegExp instances.


In the 5^th^ Edition

7.1: Unicode format control characters are no longer stripped from
ECMAScript source text before processing. In Edition 5, if such a
character appears in a _StringLiteral_ or _RegularExpressionLiteral_ the
character will be incorporated into the literal where in Edition 3 the
character would not be incorporated into the literal.

7.2: Unicode character <BOM> is now treated as whitespace and its
presence in the middle of what appears to be an identifier could result
in a syntax error which would not have occurred in Edition 3

7.3: Line terminator characters that are preceded by an escape sequence
are now allowed within a string literal token. In Edition 3 a syntax
error would have been produced.

7.8.5: Regular expression literals now return a unique object each time
the literal is evaluated. This change is detectable by any programs that
test the object identity of such literal values or that are sensitive to
the shared side effects.

7.8.5: Edition 5 requires early reporting of any possible RegExp
constructor errors that would be produced when converting a
_RegularExpressionLiteral_ to a RegExp object. Prior to Edition 
implementations were permitted to defer the reporting of such errors
until the actual execution time creation of the object.

7.8.5: In Edition 5 unescaped “/” characters may appear as a
_CharacterClass_ in a regular expression literal. In Edition 3 such a
character would have been interpreted as the final character of the
literal.

10.4.2: In Edition 5, indirect calls to the EVAL function use the global
environment as both the variable environment and lexical environment for
the eval code. In Edition 3, the variable and lexical environments of
the caller of an indirect EVAL was used as the environments for the eval
code.

15.4.3: In Edition 5 all methods of ARRAY.PROTOTYPE are intentionally
generic. In Edition 3 TOSTRING and TOLOCALESTRING were not generic and
would throw a TYPEERROR exception if applied to objects that were not
instances of Array.

10.6: In Edition 5 the array indexed properties of argument objects that
correspond to actual formal parameters are enumerable. In Edition 3,
such properties were not enumerable.

10.6: In Edition 5 the value of the [[Class]] internal data property of
an arguments object is "ARGUMENTS". In Edition 3, it was "OBJECT". This
is observable if TOSTRING is called as a method of an arguments object.

12.6.4: for-in statements no longer throw a TYPEERROR if the IN
expression evaluates to NULL or UNDEFINED. Instead, the statement
behaves as if the value of the expression was an object with no
enumerable properties.

15: In Edition 5, the following new properties are defined on built-in
objects that exist in Edition 3: OBJECT.GETPROTOTYPEOF,
OBJECT.GETOWNPROPERTYDESCRIPTOR, OBJECT.GETOWNPROPERTYNAMES,
OBJECT.CREATE, OBJECT.DEFINEPROPERTY, OBJECT.DEFINEPROPERTIES,
OBJECT.SEAL, OBJECT.FREEZE, OBJECT.PREVENTEXTENSIONS, OBJECT.ISSEALED,
OBJECT.ISFROZEN, OBJECT.ISEXTENSIBLE, OBJECT.KEYS,
FUNCTION.PROTOTYPE.BIND, ARRAY.PROTOTYPE.INDEXOF,
ARRAY.PROTOTYPE.LASTINDEXOF, ARRAY.PROTOTYPE.EVERY,
ARRAY.PROTOTYPE.SOME, ARRAY.PROTOTYPE.FOREACH, ARRAY.PROTOTYPE.MAP,
ARRAY.PROTOTYPE.FILTER, ARRAY.PROTOTYPE.REDUCE,
ARRAY.PROTOTYPE.REDUCERIGHT, STRING.PROTOTYPE.TRIM, DATE.NOW,
DATE.PROTOTYPE.TOISOSTRING, DATE.PROTOTYPE.TOJSON.

15: Implementations are now required to ignore extra arguments to
standard built-in methods unless otherwise explicitly specified. In
Edition 3 the handling of extra arguments was unspecified and
implementations were explicitly allowed to throw a TYPEERROR exception.

15.1.1: The value properties NAN, INFINITY, and UNDEFINED of the Global
Object have been changed to be read-only properties.

15.1.2.1. Implementations are no longer permitted to restrict the use of
eval in ways that are not a direct call. In addition, any invocation of
eval that is not a direct call uses the global environment as its
variable environment rather than the caller’s variable environment.

15.1.2.2: The specification of the function PARSEINT no longer allows
implementations to treat Strings beginning with a 0 character as octal
values.

15.3.3.3: In Edition 3, a TYPEERROR is thrown if the second argument
passed to FUNCTION.PROTOTYPE.APPLY is neither an array object nor an
arguments object. In Edition 5, the second argument may be any kind of
generic array-like object that has a valid LENGTH property.

15.3.3.3, 15.3.3.4: In Edition 3 passing UNDEFINED or NULL as the first
argument to either FUNCTION.PROTOTYPE.APPLY or FUNCTION.PROTOTYPE.CALL
causes the global object to be passed to the indirectly invoked target
function as the THIS value. If the first argument is a primitive value
the result of calling ToObject on the primitive value is passed as the
THIS value. In Edition 5, these transformations are not performed and
the actual first argument value is passed as the THIS value. This
difference will normally be unobservable to existing ECMAScript Edition
3 code because a corresponding transformation takes place upon
activation of the target function. However, depending upon the
implementation, this difference may be observable by host object
functions called using APPLY or CALL. In addition, invoking a standard
built-in function in this manner with NULL or UNDEFINED passed as the
THIS value will in many cases cause behaviour in Edition 5
implementations that differ from Edition 3 behaviour. In particular, in
Edition 5 built-in functions that are specified to actually use the
passed THIS value as an object typically throw a TYPEERROR exception if
passed NULL or UNDEFINED as the THIS value.

15.3.4.2: In Edition 5, the PROTOTYPE property of Function instances is
not enumerable. In Edition 3, this property was enumerable.

15.5.5.2: In Edition 5, the individual characters of a String object’s
[[StringData]] may be accessed as array indexed properties of the String
object. These properties are non-writable and non-configurable and
shadow any inherited properties with the same names. In Edition 3, these
properties did not exist and ECMAScript code could dynamically add and
remove writable properties with such names and could access inherited
properties with such names.

15.9.4.2: DATE.PARSE is now required to first attempt to parse its
argument as an ISO format string. Programs that use this format but
depended upon implementation specific behaviour (including failure) may
behave differently.

15.10.2.12: In Edition 5, \S now additionally matches <BOM>.

15.10.4.1: In Edition 3, the exact form of the String value of the
SOURCE property of an object created by the REGEXP constructor is
implementation defined. In Edition 5, the String must conform to certain
specified requirements and hence may be different from that produced by
an Edition 3 implementation.

15.10.6.4: In Edition 3, the result of REGEXP.PROTOTYPE.TOSTRING need
not be derived from the value of the RegExp object’s SOURCE property. In
Edition 5 the result must be derived from the SOURCE property in a
specified manner and hence may be different from the result produced by
an Edition 3 implementation.

15.11.2.1, 15.11.4.3: In Edition 5, if an initial value for the MESSAGE
property of an Error object is not specified via the ERROR constructor
the initial value of the property is the empty String. In Edition 3,
such an initial value is implementation defined.

15.11.4.4: In Edition 3, the result of ERROR.PROTOTYPE.TOSTRING is
implementation defined. In Edition 5, the result is fully specified and
hence may differ from some Edition 3 implementations.

15.12: In Edition 5, the name JSON is defined in the global environment.
In Edition 3, testing for the presence of that name will show it to be
UNDEFINED unless it is defined by the program or implementation.

(informative)
Static Semantic Rule Cross Reference

  ROUTINE NAME                 PURPOSE                                                                                                                                                                                            DEFINITIONS                                                     USES
  ---------------------------- -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- --------------------------------------------------------------- ------
  BoundNames                   Produces a list of the Identifiers bound by a production. Does not include Identifiers that are bound within inner environments associated with the production.                                    12.2.1, 12.2.2, 12.2.4, 12.6.4, 13.1, 13.2, 13.5                
  ConstructorMethod            From a _ClassBody_ return the first _ClassElement_ whose PropName is ″CONSTRUCTOR″. Returns empty if the _ClassBody_ does not contain one.                                                         13.5                                                            
  Contains                     Determine if a grammar production either directly or indirectly includes a grammar symbol.                                                                                                         5.3, 13.1, 13.2, 13.5                                           
  CoveredFormalsList           Reparse a covered _Expression_ using _FormalsList_ as the goal symbol.                                                                                                                             13.2                                                            
  CV                           Determines the “character value” of a component of a _StringLiteral_.                                                                                                                              7.8.4                                                           
  Elision Width                Determine the number of commas in an _Elision_.                                                                                                                                                    11.1.4.1                                                        
  ExpectedArgumentCount        Determine the “length” of an argument list for the purpose of initializing the “length” property of a function object.                                                                             13.1, 13.2, 13.3                                                
  HasInitialiser               Determines whether the production contains an _Initialiser_ production.                                                                                                                            12.2.4, 13.1                                                    
  IsConstantDeclaration        Determines whether the production introduces a immutable environment record binding                                                                                                                12.2, 13.1, 13.5                                                
  IsInvalidAssignmentPattern   Determines if a _LeftHandSideExpression_ is a valid assignment target. Primarily for dealing with destructuring assignment targets.                                                                11.2                                                            
  LexicalDeclarations          Return a List containing the components of a production that are processed as lexical declarations                                                                                                 12.1, 12.11, 12.5                                               
  LexicallyDeclaredNames       Returns a list of the lexically scoped identifiers declared by a production.                                                                                                                       12.1, 13.1, 13.2, 13.5                                          
  PrototypeMethodDefinitions   Return a list of the non-static _MethodDefinition_ productions that are part of a _ClassElementList_.                                                                                              13.5                                                            
  MV                           Determines the “mathematical value” of a numeric lirteral or component of a numeric literal.                                                                                                       7.8.3                                                           
  PropName                     Determines the string value of the property name referenced by a production.                                                                                                                       11.1.5.1, 13.3, 13.5                                            
  PropNameList                 Returns a List of the string values of the property names referenced by a production. The list reflects the order of the references in the source text. The list may contain duplicate elements.   11.5.1, 13.5                                                    
  PrototypeMethodDefinitions   Return a list of the non-static _MethodDefinition_ productions that are part of a _ClassElementList_.                                                                                              13.5                                                            
  ReferencesSuper              Determine if a _MethodDefinition_ contains any references to the _ReservedWord_ SUPER.                                                                                                             13.3                                                            
  SpecialMethod                Determine if a _MethodDefinition_ defines a generator method or an accessor property.                                                                                                              13.3                                                            
  StaticMethodDefinitions      Return a list of the static _MethodDefinition_ productions that are part of a _ClassElementList_.                                                                                                  13.5                                                            
  SV                           Determines the “string value” of a _StringLiteral_ or component of a _StringLiteral_.                                                                                                              7.8.4                                                           
                                                                                                                                                                                                                                                                                                  
  VarDeclaredNames             Returns a list of the local top-level scoped identifiers declared by a production. These are identifier that are scoped as if by a var statement.                                                  12.1, 12.5, 12.6.1, 12.6.2, 12.6.3, 12.6.4, 12.12, 13.1, 13.5   

A place to temporarily hand on to stuff that’s been deleted

MemberExpression :

MemberExpression <| TriangleLiteral

TriangleLiteral :

SealedArrayLiteral
SealedObjectLiteral
FunctionExpression
ArrowFunction
ValueLiteral

CallExpression :

CallExpression <| TriangleLiteral

15.2.3.15 Object.isObject ( O )

When the ISOBJECT function is called with argument _O_, the following
steps are taken:

1.  If Type(_O_) is Object return TRUE.

2.  Return FALSE.

15.5.4.25 STRING.PROTOTYPE.TOARRAY()

The following steps are taken:

1.  Let _O_ be CheckObjectCoercible(THIS value).

2.  Let _S_ be ToString(_O_).

3.  ReturnIfAbrupt(_S_).

4.  Let _len_ be the number of characters in _S_.

5.  Let _array_ be the result of the abstract operation ArrayCreate with
    argument _len_.

6.  Let _n_ be 

7.  Repeat, while _n_ _<_ _len_:

    a.  Let _c_ be the character at position _n_ in _S_.

    b.  Call the [[DefineOwnProperty]] internal method of _array_ with
        arguments ToString(_n_), the PropertyDescriptor {[[Value]]: _c_,
        [[Writable]]: TRUE, [[Enumerable]]: TRUE, [[Configurable]]:
        TRUE}, and FALSE.

    c.  Increment _n_ by 1.

8.  Return _array_.

The LENGTH property of the TOARRAY method is 0.

NOTE 1 Returns an Array object with elements corresponding to the
characters of this object (converted to a String).

NOTE 2 The TOARRAY function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

STATIC SEMANTICS: TOPLEVELLEXICALLYDECLAREDNAMES

_OuterStatementList_ : _OuterStatementList OuterItem

1.  Let _names_ be TopLevelLexicallyDeclaredNames of
    _OuterStatementList_.

2.  Append to _names_ the elements of the TopLevelLexicallyDeclaredNames
    of _OuterItem._

3.  Return _names_.

_OuterItem_ : _StatementListItem

1.  Return a new empty List.

_StatementListItem_ : _Declaration

1.  If _Declaration_ is _Declaration_ : _FunctionDeclaration_, then
    return a new empty List.

2.  Return the BoundNames of _Declaration_.

8.4.4 Symbol Exotic Objects

A _Symbol object_ is an exotic object that may be used as a property
key. Symbol exotic objects are unique in that they are always immutable
and never observably reference any other object.

Exotic String objects have a single internal data properties named
[[Private]] that is set when the object is created and never modified.

Exotic Symbol objects provide alternative definitions for all of the
essential internal methods.

8.4.4.1 [[GetInheritance]] ( )

When the [[GetInheritance]] internal method of an exotic Symbol object
_O_ is called the following steps are taken:

1.  Return NULL.

8.4.4.2 [[SetInheritance]] (V)

When the [[SetInheritance]] internal method of an exotic Symbol object
_O_ is called with argument _V_ the following steps are taken:

1.  Assert: Either Type(_V_) is Object or Type(_V_) is Null.

2.  Return FALSE.

8.4.4.3 [[HasIntegrity]] ( Level )

When the [[HasIntegrity]] internal method of an exotic Symbol object _O_
is called the following steps are taken:

1.  Assert: _Level_ is one of "NONEXTENSIBLE", "SEALED", or "FROZEN".

2.  Return TRUE.

8.4.4.4 [[Setntegrity]] ( Level )

When the [[Setntegrity]] internal method of an exotic Symbol object an
exotic Symbol object _O_ is called the following steps are taken:

1.  Assert: _Level_ is one of "NONEXTENSIBLE", "SEALED", or "FROZEN".

2.  Return TRUE.

8.4.4.5 [[HasOwnProperty]] (P)

When the [[HasOwnProperty]] internal method of an exotic Symbol object
_O_ is called with property key _P_, the following steps are taken:

1.  Return FALSE.

8.4.4.6 [[GetOwnProperty]] (P)

When the [[GetOwnProperty]] internal method of an exotic Symbol object
_O_ is called with property key _P_, the following steps are taken:

1.  Return UNDEFINED.

8.4.4.7 [[DefineOwnProperty]] (P, Desc)

When the [[DefineOwnProperty]] internal method of an exotic Symbol
object _O_ is called with property key _P_ and property descriptor
_Desc_, the following steps are taken:

1.  Return FALSE.

8.4.4.8 [[HasProperty]] (P)

When the [[HasProperty]] internal method of an exotic Symbol object _O_
is called with property key _P_, the following steps are taken:

1.  Return FALSE.

8.4.4.9 [[Get]] (P, Receiver)

When the [[Get]] internal method of an exotic Symbol object _O_ is
called with property key _P_ and ECMAScript language value _Receiver_
the following steps are taken:

1.  Assert: IsPropertyKey(_P_) is TRUE.

2.  If _P_ is "TOSTRING", then

    a.  Let _ctx_ be the running execution context.

    b.  Let _ctxRealm_ be _ctx_’s Realm component.

    c.  Return _ctxRealm_.[[intrinsics]].% ObjProto_toString %.

3.  Return UNDEFINED.

8.4.4.10 [[Set]] ( P, V, Receiver)

When the [[Set]] internal method of an exotic Symbol object _O_ is
called with property key _P_, value _V_, and ECMAScript language value
_Receiver_, the following steps are taken:

1.  Return FALSE.

8.4.4.11 [[Delete]] (P)

When the [[Delete]] internal method of an exotic Symbol object _O_ is
called with property key _P_ the following steps are taken:

1.  Assert: IsPropertyKey(_P_) is TRUE.

2.  Return TRUE.

8.4.4.12 [[Enumerate]] ()

When the [[Enumerate]] internal method of an exotic Symbol object _O_ is
called the following steps are taken:

1.  Return an Iterator object (reference xxxx) whose next method
    immediately throws %StopIteration% and forms no other action.

8.4.4.13 [[OwnPropertyKeys]] ( )

When the [[OwnPropertyKeys]] internal method of an exotic Symbol object
_O_ is called the following steps are taken:

1.  Return an Iterator object (reference xxxx) whose next method
    immediately throws %StopIteration% and forms no other action.

8.3.10 [[Enumerate]] (includePrototype, onlyEnumerable )

When the [[Enumerate]] internal method of _O_ is called with Boolean
arguments _includePrototype_ and _onlyEnumerable_, the following steps
are taken:

1.  Return an Iterator object (reference xxxx) whose next method
    iterates over all the keys of enumerable property keys of _O_. If
    _includePrototype_ is FALSE, then only own properties of _O_ are
    included. If _onlyEnumerable_ is FALSE, then all properties that do
    not have private name keys are included. The mechanics and order of
    enumerating the properties is not specified but must conform to the
    rules specified below.

Enumerated properties do not include properties whose property key is a
private name. Properties of the object being enumerated may be deleted
during enumeration. If a property that has not yet been visited during
enumeration is deleted, then it will not be visited. If new properties
are added to the object being enumerated during enumeration, the newly
added properties are not guaranteed to be visited in the active
enumeration. A property name must not be visited more than once in any
enumeration.

Enumerating the properties of an object includes enumerating properties
of its prototype, and the prototype of the prototype, and so on,
recursively; but a property of a prototype is not enumerated if it is
“shadowed” because some previous object in the prototype chain has a
property with the same name. The values of [[Enumerable]] attributes are
not considered when determining if a property of a prototype object is
shadowed by a previous object on the prototype chain.

The following is an informative algorithm that conforms to these rules

1.  Let _obj_ be _O_.

2.  Let _proto_ be the value of the [[Prototype]] internal data property
    of _O_.

3.  If _includePrototype_ is FALSE or _proto_ is the value NULL, then

    a.  Let _propList_ be a new empty List.

4.  Else

    a.  Let _propList_ be the result of calling the [[Enumerate]]
        internal method of _proto_ with arguments TRUE and
        _onlyEnumerable_.

5.  For each string _name_ that is the property key of an own property
    of _O_

    a.  Let _desc_ be the result of calling the [[GetOwnProperty]]
        internal method of _O_ with argument _name_.

    b.  If _name_ is an element of _propList_, then remove _name_ as an
        element of _propList_.

    c.  If _onlyEnumerable_ is FALSE or _desc_.[[Enumerable]] is TRUE,
        then add _name_ as an element of _propList_.

6.  Order the elements of _propList_ in an implementation defined order.

7.  Return _propList_.

_This follow version places function body declarations in_ _scope of
parameter initializers_

9.1.11 ToPositiveInteger

The abstract operation ToInteger converts its argument to an integral
numeric value. This abstract operation functions as follows:

1.  Let _number_ be the result of calling ToNumber on the input
    argument.

2.  ReturnIfAbrupt(_number_).

3.  If _number_ is NAN, return +0.

4.  If _number_ is +∞, or −∞, return _number_.

5.  If _number_ ≤ 0, return +0.

6.  Return the result of computing floor(_number_).

10.5.3 Function Declaration Instantiation

NOTE When an execution context is established for evaluating function
code a new Declarative Environment Record is created and bindings for
each formal parameter, and each function level variable, constant, or
function declarated in the function are instantiated in the environment
record. Formal parameters and functions are initialized as part of this
process. All other bindings are initialized during execution of the
function code.

Function Declaration Instantiation is performed as follows using
arguments _func, argumentsList_, and _env_. _func_ is the function
object that for which the execution context is being established. _env_
is the declarative environment record in which bindings are to be
created.

1.  Let _code_ be the value of the [[Code]] internal property of _func_.

2.  Let _strict_ be the value of the [[Strict]] internal property of
    _func_.

3.  Let _formals_ be the value of the [[FormalParameterList]] internal
    property of _func_.

4.  Let _parameterNames_ be the BoundNames of _formals_.

5.  Let _varDeclarations_ be the VarScopedDeclarations of _code_.

6.  Let _functionsToInitialize_ be an emptyList.

7.  Let _argumentsObjectNotNeeded_ be FALSE.

8.  For each _d_ in _varDeclarations_, in reverse list order do

    a.  If _d_ is a _FunctionDeclaration_ then

        i.  NOTE If there are multiple _FunctionDeclarations_ for the
            same name, the last declaration is used.

        ii. Let _fn_ be the sole element of the BoundNames of _d._

        iii. If _fn_ is "ARGUMENTS", then let _argumentsObjectNotNeeded_
            be TRUE.

        iv. Let _alreadyDeclared_ be the result of calling _env’s_
            HasBinding concrete method passing _fn_ as the argument.

        v.  If _alreadyDeclared_ is FALSE, then

            1.  Let _status_ be the result of calling _env’s_
                CreateMutableBinding concrete method passing _fn_ as the
                argument.

            2.  Assert: _status_ is never an Abrupt Completion.

            3.  Append _d_ to _functionsToInitialize_.

9.  For each String _paramName_ in _parameterNames_, do

    a.  Let _alreadyDeclared_ be the result of calling _env’s_
        HasBinding concrete method passing _paramName_ as the argument.

    b.  NOTE Duplicate parameter names can only occur in non-strict
        functions. Parameter names that are the same as function
        declaration names do not get initialized to UNDEFINED.

    c.  If _alreadyDeclared_ is FALSE, then

        i.  If _paramName_ is "ARGUMENTS", then let
            _argumentsObjectNotNeeded_ be TRUE.

        ii. Let _status_ be the result of calling _env’s_
            CreateMutableBinding concrete method passing _paramName_ as
            the argument.

        iii. Assert: _status_ is never an Abrupt Completion

        iv. Call _env_’s InitialiseBinding concrete method passing
            _paramName_, and UNDEFINED as the arguments.

10. NOTE If there is a function declaration or formal parameter with the
    name "ARGUMENTS" then an argument object is not created.

11. If _argumentsObjectNotNeeded_ is FALSE, then

    a.  If _strict_ is TRUE, then

        i.  Call _env_’s CreateImmutableBinding concrete method passing
            the String "ARGUMENTS" as the argument.

    b.  Else,

        i.  Call _env_’s CreateMutableBinding concrete method passing
            the String "ARGUMENTS" as the argument.

12. Let _varNames_ be the VarDeclaredNames of _code_.

13. For each String _varName_ in _varNames_, in list order do

    a.  Let _alreadyDeclared_ be the result of calling _env’s_
        HasBinding concrete method passing _varName_ as the argument.

    b.  NOTE A VarDeclaredNames is only instantiated and initialied here
        if it is not also the name of a formal parameter or a
        _FunctionDeclarations_.

    c.  If _alreadyDeclared_ is FALSE, then

        i.  Call _env’s_ CreateMutableBinding concrete method passing
            _varName_ as the argument.

14. Let _lexDeclarations_ be the LexicalDeclarations of _code_.

15. For each element _d_ in _lexDeclarations_ do

    a.  NOTE A lexically declared name cannot be the same as a function
        declaration, formal parameter, or a var name. Lexically
        declarated names are only instantiated here but not initialized.

    b.  For each element _dn_ of the BoundNames of _d_ do

        i.  If IsConstantDeclaration of _d_ is TRUE, then

            1.  Call _env_’s CreateImmutableBinding concrete method
                passing _dn_ as the argument.

        ii. Else,

            1.  Call _env_’s CreateMutableBinding concrete method
                passing _dn_ and FALSE as the arguments.

16. For each _FunctionDeclaration_ _f_ in _functionsToInitialize_, do

    a.  Let _fn_ be the sole element of the BoundNames of _f._

    b.  Let _fo_ be the result of performing InstantiateFunctionObject
        for _f_ with argument _env_.

    c.  Call _env_’s SetMutableMinding concrete method passing _fn_,
        _fo_, and FALSE as the arguments.

17. NOTE Function declaration are initialised prior to parameter
    initialisation so that default value expressions may reference them.
    it is not extended code. "ARGUMENTS" is not initialized until after
    parameter initialization.

18. Let _ao_ be the result of InstantiateArgumentsObject with argument
    _argumentsList._

19. NOTE If _argumentsObjectNotNeeded_ is TRUE then the value of _ao_ is
    not directly observable to ECMAScript code and need not actually
    exist. In that case, its use in the above steps is strictly as a
    device for specifying formal parameter initialisation semantics.

20. If _argumentsObjectNotNeeded_ is FALSE, then

    a.  If _strict_ is TRUE, then

        i.  Perform the abstract operation CompleteStrictArgumentsObject
            with argument _a0._

    b.  Else,

        i.  Perform the abstract operation CompleteMappedArgumentsObject
            with arguments _a0, func_, _formals_, and _env_.

    c.  Call _env_’s InitialiseBinding concrete method passing
        "ARGUMENTS" and _ao_ as arguments.

21. Let _formalStatus_ be the result of performing Binding
    Initialisation for _formals_ with _ao_ and UNDEFINED as arguments.

22. ReturnIfAbrupt(_formalStatus_).

23. Return NormalCompletion(empty).

The __proto__ pseudo property.

Object.prototype.__proto__

The initial value of the __PROTO__ property of the Object prototype
object is a data property whose initial value is NULL. This property
initially has the attributes { [[Writable]]: TRUE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Manipulations of this property as tracked by the Boolean valued
primordial internal variable UnderscoreProtoEnabled. The default initial
value of UnderscoreProtoEnabled is TRUE only if this property is
initially present on the primordial Object prototype object.

NOTE Any modification of this property or its attributes causes
UnderscoreProtoEnabled to be set to FALSE.

 Changes To Internal Methods__

The definition of the [[Get]] internal method given in 8.12.3 is
replaced with the following:

1.  If _P_ is the string value "__PROTO__" and UnderscoreProtoEnabled is
    TRUE, then

    a.  Let _desc_ be the result of calling the [[GetProperty]] internal
        method of _O_ with property name _P_.

    b.  If _desc_ is not UNDEFINED and was created by step 1.a to
        describe the property defined in B.3.1.1 then,

        i.  Return the value of the [[Prototype]] internal data property
            of _O_.

2.  Continue by executing the steps of 8.12.3 starting with step 1.

The definition of the [[Put]] internal method given in 8.12.5 is
replaced with the following:

1.  If _P_ is the string value "__PROTO__" and UnderscoreProtoEnabled is
    TRUE and _O_ is not the standard built-in Object prototype object,
    then

    a.  Let _desc_ be the result of calling the [[GetProperty]] internal
        method of _O_ with property name _P_.

    b.  If _desc_ is not UNDEFINED and was created by step 1.a to
        describe the property defined in B.3.1.1 then,

        i.  If the type of _V_ is neither Object or Null, return

        ii. Set the value of the [[Prototype]] internal data property of
            _O_ to _V_.

        iii. Return.

2.  Continue by executing the steps of 8.12.5 starting with step 1.

The definition of the [[Delete]] internal method given in 8.12.7 is
replaced with the following:

1.  If UnderscoreProtoEnabled is TRUE and _P_ is the string value
    "__PROTO__" and _O_ is the standard built-in Object prototype
    object, then

    a.  Set UnderscoreProtoEnabled to FALSE.

2.  Continue by executing the steps of 8.12.7 starting with step 1.

The definition of the [[DefineOwnProperty]] internal method given in
8.12.9 is replaced with the following:

1.  If UnderscoreProtoEnabled is TRUE and _P_ is the string value
    "__PROTO__" and _O_ is the standard built-in Object prototype
    object, then

    a.  If any attribute contained in _Desc_ is not present or has a
        different value from the corresponding attribute in {
        [[Writable]]: TRUE, [[Enumerable]]: TRUE, [[Configurable]]: TRUE
        }then,

        i.  Set UnderscoreProtoEnabled to FALSE.

2.  Continue by executing the steps of 8.12.9 starting with step 1.

__proto___ Object Initialisers 

Definitions of two algorithms in 11.1.5 are replaced with the following:

The production _PropertyDefinitionList_ : _PropertyDefinition_ is
evaluated as follows:

1.  Let _obj_ be the result of the abstract operation ObjectCreate with
    the intrinsic object %ObjectPrototype% as its argument.

2.  Let _propId_ be the result of evaluating _PropertyDefinition_.

3.  If _propId_.name is the string value "__PROTO__" and
    UnderscoreProtoEnabled is TRUE and
    IsDataDescriptor(_propId_.descriptor) is TRUE, then

    a.  Let _v_ be _propId_.descriptor.value.

    b.  If _desc be propId_.descriptor

    c.  If the type of _v_ is either Object or Null,

        i.  Set the value of the [[Prototype]] internal data property of
            _obj_ to _v_.

    d.  Return _obj_.

4.  Call the [[DefineOwnProperty]] internal method of _obj_ with
    arguments _propId_.name, _propId_.descriptor, and FALSE.

5.  Return _obj_.

The production
 _PropertyDefinitionList_ : _PropertyDefinitionList_ ,
_PropertyDefinition
is evaluated as follows:

5.  Call the [[DefineOwnProperty]] internal method of _obj_ with
    arguments _propId_.name, _propId_.descriptor, and FALSE.

6.  Return _obj_.

Table 1 — Internal Properties Only Defined for Some Objects

  _INTERNAL PROPERTY_       _VALUE TYPE DOMAIN_                           _DESCRIPTION_
  ------------------------- --------------------------------------------- ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  [[BuiltinBrand]]          The BuiltinBrand enumeration.                 A tag value used by this specification to categorize various kinds of ECMAScript objects defined in this specification.
  [[PrimitiveValue]]        _primitive_                                   Internal state information associated with this object. Of the standard built-in ECMAScript objects, only Boolean, Date, Number, and String objects implement [[PrimitiveValue]].
  [[Scope]]                 Lexical Environment                           A lexical environment that is the environment in which a Function object is executed. Of the standard built-in ECMAScript objects, only Function objects implement [[Scope]].
  [[FormalParameters]]      Parse Tree                                    A parse tree for ECMAScript code parsed with _FormalParameters_ as the goal symbol. Of the standard built-in ECMAScript objects, only Function objects implement [[FormalParameters]].
  [[Code]]                  Parse Tree                                    A parse tree for ECMAScript code parsed with _FunctionBody_ as the goal symbol. Of the standard built-in ECMAScript objects, only Function objects implement [[Code]].
  [[Strict]]                Boolean                                       TRUE if a Function object is a strict mode function. Of the standard built-in ECMAScript objects, only Function objects implement [[Strict]].
  [[BoundTargetFunction]]   Object                                        The target function of a function object created using the standard built-in Function.prototype.bind method. Only ECMAScript objects created using Function.prototype.bind have a [[BoundTargetFunction]] internal property.
  [[BoundThis]]             _any_                                         The pre-bound this value of a function Object created using the standard built-in Function.prototype.bind method. Only ECMAScript objects created using Function.prototype.bind have a [[BoundThis]] internal property.
  [[BoundArguments]]        List of _any_                                 The pre-bound argument values of a function Object created by the standard built-in Function.prototype.bind method. Only objects created by Function.prototype.bind have a [[BoundArguments]] internal property.
  [[RegExpMatcher]]         SpecOp(_String_, _index_) _→_ _MatchResult_   Tests for a regular expression match and returns a MatchResult value (see 15.10.2.1). Of the standard built-in ECMAScript objects, only RegExp objects implement [[RegExpMatch]].
  [[ParameterMap]]          Object                                        Provides a mapping between the properties of an arguments object (see 10.6) and the formal parameters of the associated function. Only objects that are arguments objects have a [[ParameterMap]] internal property.

Bibliography

IEEE Std 754-2008: IEEE Standard for Floating-Point Arithmetic.
Institute of Electrical and Electronic Engineers, New York (2008)

The Unicode Consortium. The Unicode Standard, Version 3.0, defined by:
The Unicode Standard, Version 3.0 (Reading, MA, Addison-Wesley, 2000.
ISBN 0-201-61633-5)

ISO 8601:2004(E) _Data elements and interchange formats – Information
interchange -- Representation of dates and times_

RFC 1738 “Uniform Resource Locators (URL)”, available at
<_http://tools.ietf.org/html/rfc1738_>

RFC 2396 “Uniform Resource Identifiers (URI): Generic Syntax”, available
at <_http://tools.ietf.org/html/rfc2396_>

RFC 3629 “UTF-8, a transformation format of ISO 10646”, available at
<_http://tools.ietf.org/html/rfc3629_>

RFC 4627 “The application/json Media Type for JavaScript Object Notation
(JSON)” , available at <_http://tools.ietf.org/html/rfc4627_>

Unicode Inc. (2010), Unicode Technical Report #15: “Unicode
Normalization Forms”, available at
<_http://www.unicode.org/reports/tr15/tr15-29.html_>

[1] Note: Please note that for ECMAScript Edition 4 the Ecma standard
number “ECMA-262 Edition 4” was reserved but not used in the Ecma
publication process. Therefore “ECMA-262 Edition 4” as an Ecma
International publication does not exist.
