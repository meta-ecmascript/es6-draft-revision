Contents Page

Introduction vii

1 Scope 1

2 Conformance 1

3 _Normative references_ 1

4 Overview 1

4.1 _Web Scripting_ 2

4.2 _Language Overview_ 2

4.2.1 Objects 3

4.2.2 _The Strict Variant of ECMAScript_ 4

4.3 _Terms and definitions_ 4

5 _Notational Conventions_ 7

5.1 _Syntactic and Lexical Grammars_ 7

5.1.1 _Context-Free Grammars_ 7

5.1.2 _The Lexical and RegExp Grammars_ 8

5.1.3 _The Numeric String Grammar_ 8

5.1.4 _The Syntactic Grammar_ 8

5.1.5 _The JSON Grammar_ 9

5.1.6 _Grammar Notation_ 9

5.2 _Algorithm Conventions_ 12

5.3 _Static Semantic Rules_ 13

6 _Source Text_ 14

7 _Lexical Conventions_ 15

7.1 _Unicode Format-Control Characters_ 16

7.2 _White Space_ 16

7.3 _Line Terminators_ 17

7.4 Comments 17

7.5 Tokens 18

7.6 _Identifier Names and Identifiers_ 19

7.6.1 _Reserved Words_ 20

7.7 Punctuators 21

7.8 Literals 21

7.8.1 _Null Literals_ 21

7.8.2 _Boolean Literals_ 21

7.8.3 _Numeric Literals_ 22

7.8.4 _Regular Expression Literals_ 24

7.8.5 _Template Literal Lexical Components_ 26

7.8.6 _String Literals_ 28

7.9 _Automatic Semicolon Insertion_ 30

7.9.1 _Rules of Automatic Semicolon Insertion_ 30

7.9.2 _Examples of Automatic Semicolon Insertion_ 31

8 Types 32

8.1 _ECMAScript Language Types_ 33

8.1.1 _The Undefined Type_ 33

8.1.2 _The Null Type_ 33

8.1.3 _The Boolean Type_ 33

8.1.4 _The String Type_ 33

8.1.5 _The Number Type_ 33

8.1.6 _The Object Type_ 34

8.2 _ECMAScript Specification Types_ 47

8.2.1 _Data Blocks_ 47

8.2.2 _The List and Record Specification Type_ 47

8.2.3 _The Completion Record Specification Type_ 48

8.2.4 _The Reference Specification Type_ 49

8.2.5 _The Property Descriptor Specification Type_ 50

8.2.6 _The Lexical Environment and Environment Record Specification
Types_ 53

8.3 _Ordinary Object Internal Methods and Internal Data Properties_ 53

8.3.1 _[[GetInheritance]] ( )_ 53

8.3.2 _[[SetInheritance]] (V)_ 53

8.3.3 _[[IsExtensible]] ( )_ 54

8.3.4 _[[PreventExtensions]] ( )_ 54

8.3.5 _[[HasOwnProperty]] (P)_ 54

8.3.6 _[[GetOwnProperty]] (P)_ 54

8.3.7 _[[DefineOwnProperty]] (P, Desc)_ 55

8.3.8 [[HasProperty]](P) 56

8.3.9 _[[Get]] (P, Receiver)_ 56

8.3.10 _[[Set]] ( P, V, Receiver)_ 57

8.3.11 _[[Invoke]] (P, ArgumentsList, Receiver)_ 57

8.3.12 _[[Delete]] (P)_ 57

8.3.13 _[[Enumerate]] ()_ 58

8.3.14 _[[OwnPropertyKeys]] ( )_ 58

8.3.15 _ObjectCreate(proto, internalDataList) Abstract Operation_ 58

8.3.16 _Ordinary Function Objects_ 59

8.4 _Built-in Exotic Object Internal Methods and Data Fields_ 64

8.4.1 _Bound Function Exotic Objects_ 64

8.4.2 _Array Exotic Objects_ 65

8.4.3 _String Exotic Objects_ 67

8.4.4 _Symbol Exotic Objects_ 69

8.4.5 _Exotic Arguments Objects_ 71

8.4.6 _Integer Indexed Exotic Objects_ 71

8.4.7 _Built-in Function Objects_ 74

8.5 _Proxy Object Internal Methods and Internal Data Properties_ 74

8.5.1 _[[GetInheritance]] ( )_ 75

8.5.2 _[[SetInheritance]] (V)_ 75

8.5.3 _[[IsExtensible]] ( )_ 75

8.5.4 _[[PreventExtensions]] ( )_ 76

8.5.5 _[[HasOwnProperty]] (P)_ 76

8.5.6 _[[GetOwnProperty]] (P)_ 77

8.5.7 _[[DefineOwnProperty]] (P, Desc)_ 78

8.5.8 _[[HasProperty]] (P)_ 78

8.5.9 _[[Get]] (P, Receiver)_ 79

8.5.10 _[[Set]] ( P, V, Receiver)_ 80

8.5.11 _[[Invoke]] (P, ArgumentsList, Receiver)_ 80

8.5.12 _[[Delete]] (P)_ 80

8.5.13 _[[Enumerate]] ()_ 81

8.5.14 _[[OwnPropertyKeys]] ( )_ 81

8.5.15 _[[Call]] (thisArgument, argumentsList)_ 82

8.5.16 _[[Construct]] Internal Method_ 82

9 _Abstract Operations_ 82

9.1 _Type Conversion and Testing_ 82

9.1.1 ToPrimitive 83

9.1.2 ToBoolean 84

9.1.3 ToNumber 84

9.1.4 ToInteger 87

9.1.5 _ToInt32: (Signed 32 Bit Integer)_ 87

9.1.6 _ToUint32: (Unsigned 32 Bit Integer)_ 88

9.1.7 _ToUint16: (Unsigned 16 Bit Integer)_ 88

9.1.8 ToString 88

9.1.9 ToObject 90

9.1.10 ToPropertyKey 90

9.1.11 ToLength 90

9.2 _Testing and Comparison Operations_ 90

9.2.1 CheckObjectCoercible 90

9.2.2 IsCallable 91

9.2.3 _SameValue(x, y)_ 91

9.2.4 _SameValueZero(x, y)_ 91

9.2.5 IsConstructor 92

9.2.6 IsPropertyKey 92

9.2.7 _IsExtensible (O)_ 92

9.3 _Operations on Objects_ 92

9.3.1 _Get (O, P)_ 92

9.3.2 _Put (O, P, V, Throw)_ 93

9.3.3 _CreateOwnDataProperty (O, P, V)_ 93

9.3.4 _DefinePropertyOrThrow (O, P, desc)_ 93

9.3.5 _DeletePropertyOrThrow (O, P)_ 93

9.3.6 _HasProperty (O, P)_ 94

9.3.7 _GetMethod (O, P)_ 94

9.3.8 _Invoke(O,P, [args])_ 94

9.3.9 _SetIntegrityLevel (O, level)_ 94

9.3.10 _TestIntegrityLevel (O, level)_ 95

9.3.11 _CreateArrayFromList (elements)_ 95

9.3.12 _CreateListFromArrayLike (obj)_ 96

9.3.13 _OrdinaryHasInstance (C, O)_ 96

9.3.14 _GetPrototypeFromConstructor ( constructor,
intrinsicDefaultProto )_ 96

9.3.15 _OrdinaryCreateFromConstructor ( constructor,
intrinsicDefaultProto, internalDataList )_ 97

10 _Executable Code and Execution Contexts_ 97

10.1 _Types of Executable Code_ 97

10.1.1 _Strict Mode Code_ 97

10.1.2 _Non-ECMAScript Functions_ 98

10.2 _Lexical Environments_ 98

10.2.1 _Environment Records_ 99

10.2.2 _Lexical Environment Operations_ 109

10.3 _Code Realms_ 110

10.4 _Execution Contexts_ 111

10.4.1 _Identifier Resolution_ 112

10.4.2 GetThisEnvironment 112

10.4.3 ThisResolution 113

10.4.4 GetGlobalObject 113

10.5 _Declaration Binding Instantiation_ 113

10.5.1 _Global Declaration Instantiation_ 113

10.5.2 _Module Declaration Instantiation_ 114

10.5.3 _Function Declaration Instantiation_ 114

10.5.4 _Block Declaration Instantiation_ 116

10.5.5 _Eval Declaration Instantiation_ 117

10.6 _Arguments Object_ 117

11 Expressions 120

11.1 _Primary Expressions_ 120

11.1.1 _The this Keyword_ 121

11.1.2 _Identifier Reference_ 121

11.1.3 Literals 121

11.1.4 _Array Initialiser_ 122

11.1.5 _Object Initialiser_ 127

11.1.6 _Function Defining Expressions_ 131

11.1.7 _Generator Comprehensions_ 131

11.1.8 _Regular Expression Literals_ 132

11.1.9 _Template Literals_ 132

11.1.10 _The Grouping Operator_ 136

11.2 _Left-Hand-Side Expressions_ 136

11.2.1 _Property Accessors_ 138

11.2.2 _The new Operator_ 139

11.2.3 _Function Calls_ 139

11.2.4 _The super Keyword_ 141

11.2.5 _Argument Lists_ 142

11.2.6 _Tagged Templates_ 143

11.3 _Postfix Expressions_ 143

11.3.1 _Postfix Increment Operator_ 144

11.3.2 _Postfix Decrement Operator_ 144

11.4 _Unary Operators_ 144

11.4.1 _The delete Operator_ 145

11.4.2 _The void Operator_ 146

11.4.3 _The typeof Operator_ 146

11.4.4 _Prefix Increment Operator_ 147

11.4.5 _Prefix Decrement Operator_ 147

11.4.6 _Unary + Operator_ 147

11.4.7 _Unary - Operator_ 147

11.4.8 _Bitwise NOT Operator ( ~ )_ 148

11.4.9 _Logical NOT Operator ( ! )_ 148

11.5 _Multiplicative Operators_ 148

11.5.1 _Applying the * Operator_ 149

11.5.2 _Applying the / Operator_ 149

11.5.3 _Applying the % Operator_ 149

11.6 _Additive Operators_ 150

11.6.1 _The Addition operator ( + )_ 150

11.6.2 _The Subtraction Operator ( - )_ 151

11.6.3 _Applying the Additive Operators to Numbers_ 151

11.7 _Bitwise Shift Operators_ 152

11.7.1 _The Left Shift Operator ( << )_ 152

11.7.2 _The Signed Right Shift Operator ( >> )_ 152

11.7.3 _The Unsigned Right Shift Operator ( >>> )_ 153

11.8 _Relational Operators_ 153

11.8.1 _Runtime Semantics_ 154

11.9 _Equality Operators_ 156

11.9.1 _Runtime Semantics_ 156

11.10 _Binary Bitwise Operators_ 158

11.11 _Binary Logical Operators_ 159

11.12 _Conditional Operator ( ? : )_ 160

11.13 _Assignment Operators_ 160

11.13.1 _Static Semantics_ 160

11.13.2 _Runtime Semantics_ 161

11.13.3 _Destructuring Assignment_ 162

11.14 _Comma Operator ( , )_ 166

12 _Statements and Declarations_ 166

12.1 Block 167

12.1.1 _Static Semantics_ 168

12.1.2 _Runtime Semantics_ 170

12.2 _Declarations and the Variable Statement_ 171

12.2.1 _Let and Const Declarations_ 171

12.2.2 _Variable Statement_ 173

12.2.3 _Destructuring Binding Patterns_ 175

12.3 _Empty Statement_ 180

12.3.1 _Runtime Semantics_ 180

12.4 _Expression Statement_ 180

12.4.1 _Runtime Semantics_ 181

12.5 _The if Statement_ 181

12.5.1 _Runtime Semantics_ 181

12.6 _Iteration Statements_ 182

12.6.1 _The do-while Statement_ 182

12.6.2 _The while Statement_ 183

12.6.3 _The for Statement_ 183

12.6.4 _The for-in and for-of Statements_ 185

12.7 _The continue Statement_ 188

12.7.1 _Static Semantics_ 188

12.7.2 _Runtime Semantics_ 189

12.8 _The break Statement_ 189

12.8.1 _Static Semantics_ 189

12.8.2 _Runtime Semantics_ 189

12.9 _The return Statement_ 189

12.9.1 _Static Semantics_ 190

12.9.2 _Runtime Semantics_ 190

12.10 _The with Statement_ 190

12.10.1 _Static Semantics_ 190

12.10.2 _Runtime Semantics_ 190

12.11 _The switch Statement_ 191

12.11.1 _Static Semantics_ 191

12.11.2 _Runtime Semantics_ 193

12.12 _Labelled Statements_ 195

12.12.1 _Static Semantics_ 195

12.12.2 _Runtime Semantics_ 195

12.13 _The throw Statement_ 196

12.14 _The try Statement_ 196

12.14.1 _Static Semantics_ 197

12.14.2 _Runtime Semantics_ 197

12.15 _The debugger statement_ 198

13 _Functions and Generators_ 199

13.1 _Function Definitions_ 199

13.2 _Arrow Function Definitions_ 205

13.3 _Method Definitions_ 208

13.4 _Generator Function Definitions_ 211

13.5 _Class Definitions_ 215

13.6 _Tail Position Calls_ 220

13.6.1 _Runtime Semantics_ 220

14 _Scripts and Modules_ 221

14.1 Script 221

14.1.1 _Static Semantics_ 221

14.1.2 _Runtime Semantics_ 223

14.2 _Directive Prologues and the Use Strict Directive_ 223

14.3 Modules 224

15 _Standard Built-in ECMAScript Objects_ 224

15.1 _The Global Object_ 225

15.1.1 _Value Properties of the Global Object_ 226

15.1.2 _Function Properties of the Global Object_ 226

15.1.3 _URI Handling Function Properties_ 228

15.1.4 _Constructor Properties of the Global Object_ 233

15.1.5 _Other Properties of the Global Object_ 235

15.2 _Object Objects_ 235

15.2.1 _The Object Constructor Called as a Function_ 235

15.2.2 _The Object Constructor_ 236

15.2.3 _Properties of the Object Constructor_ 236

15.2.4 _Properties of the Object Prototype Object_ 240

15.2.5 _Properties of Object Instances_ 242

15.3 _Function Objects_ 243

15.3.1 _The Function Constructor_ 243

15.3.2 _Properties of the Function Constructor_ 244

15.3.3 _Properties of the Function Prototype Object_ 245

15.3.4 _Function Instances_ 247

15.4 _Array Objects_ 247

15.4.1 _The Array Constructor_ 248

15.4.2 _Properties of the Array Constructor_ 249

15.4.3 _Properties of the Array Prototype Object_ 252

15.4.4 _Properties of Array Instances_ 275

15.4.5 _Array Iterator Object Structure_ 276

15.5 _String Objects_ 277

15.5.1 _The String Constructor_ 277

15.5.2 _Properties of the String Constructor_ 278

15.5.3 _Properties of the String Prototype Object_ 280

15.5.4 _Properties of String Instances_ 292

15.6 _Boolean Objects_ 293

15.6.1 _The Boolean Constructor_ 293

15.6.2 _Properties of the Boolean Constructor_ 293

15.6.3 _Properties of the Boolean Prototype Object_ 294

15.6.4 _Properties of Boolean Instances_ 294

15.7 _Number Objects_ 294

15.7.1 _The Number Constructor_ 294

15.7.2 _Properties of the Number Constructor_ 295

15.7.3 _Properties of the Number Prototype Object_ 297

15.7.4 _Properties of Number Instances_ 301

15.8 _The Math Object_ 301

15.8.1 _Value Properties of the Math Object_ 302

15.8.2 _Function Properties of the Math Object_ 303

15.9 _Date Objects_ 310

15.9.1 _Overview of Date Objects and Definitions of Abstract
Operations_ 310

15.9.2 _The Date Constructor_ 315

15.9.3 _Properties of the Date Constructor_ 317

15.9.4 _Properties of the Date Prototype Object_ 318

15.9.5 _Properties of Date Instances_ 327

15.10 _RegExp (Regular Expression) Objects_ 327

15.10.1 Patterns 327

15.10.2 _Pattern Semantics_ 329

15.10.3 _The RegExp Constructor_ 341

15.10.4 _Properties of the RegExp Constructor_ 343

15.10.5 _Properties of the RegExp Prototype Object_ 343

15.10.6 _Properties of RegExp Instances_ 350

15.11 _Error Objects_ 350

15.11.1 _The Error Constructor_ 351

15.11.2 _Properties of the Error Constructor_ 351

15.11.3 _Properties of the Error Prototype Object_ 352

15.11.4 _Properties of Error Instances_ 353

15.11.5 _Native Error Types Used in This Standard_ 353

15.11.6 NativeError Object Structure 353

15.12 _The JSON Object_ 355

15.12.1 _The JSON Grammar_ 356

15.12.2 _JSON.parse ( text [ , reviver ] )_ 357

15.12.3 _JSON.stringify ( value [ , replacer [ , space ] ] )_ 359

15.13 _Binary Data Objects_ 363

15.13.1 _The BinaryData Module_ 363

15.13.2 _The BinaryData.Type Object_ 363

15.13.3 _The BinaryData.ArrayType Object_ 363

15.13.4 _The BinaryData.StructType Object_ 363

15.13.5 _ArrayBuffer Objects_ 363

15.13.6 TypedArray Objects 367

15.13.7 _DataView Objects_ 383

15.14 _Map Objects_ 389

15.14.1 _The Map Constructor_ 389

15.14.2 _Properties of the Map Constructor_ 390

15.14.3 _Properties of the Map Prototype Object_ 390

15.14.4 _Properties of Map Instances_ 394

15.14.5 _Map Iterator Object Structure_ 394

15.15 _WeakMap Objects_ 395

15.15.1 _The WeakMap Constructor_ 396

15.15.2 _Properties of the WeakMap Constructor_ 397

15.15.3 _Properties of the WeakMap Prototype Object_ 397

15.15.4 _Properties of WeakMap Instances_ 399

15.16 _Set Objects_ 399

15.16.1 _The Set Constructor_ 399

15.16.2 _Properties of the Set Constructor_ 400

15.16.3 _Properties of the Set Prototype Object_ 401

15.16.4 _Properties of Set Instances_ 404

15.16.5 _Set Iterator Object Structure_ 404

15.17 _WeakSet Objects_ 405

15.17.1 _The WeakSet Constructor_ 406

15.17.2 _Properties of the WeakSet Constructor_ 406

15.17.3 _Properties of the WeakSet Prototype Object_ 407

15.17.4 _Properties of WeakSet Instances_ 408

15.18 _The Reflect Module_ 408

15.18.1 _Exported Function Properties Reflecting the Essentional
Internal Methods_ 408

15.18.2 _Proxy Objects_ 411

15.19 _The "std:iteration" Module_ 411

15.19.1 _Common Iteration Interfaces_ 411

15.19.2 _"std:iteration" Exports_ 412

15.19.3 _GeneratorFunction Objects_ 412

15.19.4 _Generator Objects_ 417

16 Errors 420

_Annex A (informative) Grammar Summary_ 422

A.1 _Lexical Grammar_ 422

A.2 _Number Conversions_ 428

A.3 Expressions 429

A.4 Statements 432

A.5 _Functions and Scripts_ 434

A.6 _Universal Resource Identifier Character Classes_ 435

A.7 _Regular Expressions_ 435

A.8 JSON 437

A.8.1 _JSON Lexical Grammar_ 437

A.8.2 _JSON Syntactic Grammar_ 438

_Annex B (normative) Additional ECMAScript Features for Web Browsers_
440

B.1 _Additional Syntax_ 440

B.1.1 _Numeric Literals_ 440

B.1.2 _String Literals_ 440

B.1.3 _HTML-like Comments_ 441

B.2 _Additional Properties_ 441

B.2.1 _Additional Properties of the Global Object_ 441

B.2.2 _Additional Properties of the Object.prototype Object_ 442

B.2.3 _Additional Properties of the String.prototype Object_ 443

B.2.4 _Additional Properties of the Date.prototype Object_ 445

B.2.5 _Additional Properties of the RegExp.prototype Object_ 446

B.3 _Other Additional Features_ 446

B.3.1 __proto__ Property Names in Object Initialisers_ 446

B.3.2 _Web Legacy Compatibility for Block-Level Function Declarations_
447

_Annex C (informative) The Strict Mode of ECMAScript_ 449

_Annex D (informative) Corrections and Clarifications with Possible
Compatibility Impact_ 451

_Annex E (informative) Additions and Changes that Introduce
Incompatibilities with Prior Editions_ 454

E.1 _In the 6^th^ Edition_ 454

E.2 _In the 5^th^ Edition_ 455

_Annex F (informative) Static Semantic Rule Cross Reference_ 458

_Scrap Heap_ 460

16.1.2 _Preliminary work on Irrefutable Destructuring Binding
Patterns_ 461

16.1.3 _8.3.10 [[Enumerate]] (includePrototype, onlyEnumerable )_ 463

16.1.4 _9.1.11 ToPositiveInteger_ 464

16.1.5 _10.5.3 Function Declaration Instantiation_ 464

F.1.1 _The _proto_ pseudo property._ 465

Introduction

This Ecma Standard is based on several originating technologies, the
most well known being JavaScript (Netscape) and JScript (Microsoft). The
language was invented by Brendan Eich at Netscape and first appeared in
that company’s Navigator 2.0 browser. It has appeared in all subsequent
browsers from Netscape and in all browsers from Microsoft starting with
Internet Explorer 3.0.

The development of this Standard started in November 1996. The first
edition of this Ecma Standard was adopted by the Ecma General Assembly
of June 1997.

That Ecma Standard was submitted to ISO/IEC JTC 1 for adoption under the
fast-track procedure, and approved as international standard ISO/IEC
16262, in April 1998. The Ecma General Assembly of June 1998 approved
the second edition of ECMA-262 to keep it fully aligned with ISO/IEC
16262. Changes between the first and the second edition are editorial in
nature.

The third edition of the Standard introduced powerful regular
expressions, better string handling, new control statements, try/catch
exception handling, tighter definition of errors, formatting for numeric
output and minor changes in anticipation of forthcoming
internationalisation facilities and future language growth. The third
edition of the ECMAScript standard was adopted by the Ecma General
Assembly of December 1999 and published as ISO/IEC 16262:2002 in June
2002.

Since publication of the third edition, ECMAScript has achieved massive
adoption in conjunction with the World Wide Web where it has become the
programming language that is supported by essentially all web browsers.
Significant work was done to develop a fourth edition of ECMAScript.
Although that work was not completed and not published[1] as the fourth
edition of ECMAScript, it informs continuing evolution of the language.
The fifth edition of ECMAScript (published as ECMA-262 5^th^ edition)
codifies de facto interpretations of the language specification that
have become common among browser implementations and adds support for
new features that have emerged since the publication of the third
edition. Such features include accessor properties, reflective creation
and inspection of objects, program control of property attributes,
additional array manipulation functions, support for the JSON object
encoding format, and a strict mode that provides enhanced error checking
and program security.

The edition 5.1 of the ECMAScript Standard has been fully aligned with
the third edition of the international standard ISO/IEC 16262:2011.

This present sixth edition of the Standard………

ECMAScript is a vibrant language and the evolution of the language is
not complete. Significant technical enhancement will continue with
future editions of this specification.

This Ecma Standard has been adopted by the General Assembly of <month>
<year>.

"DISCLAIMER

_This draft document may be copied and furnished to others, and
derivative works that comment on or otherwise explain it or assist in
its implementation may be prepared, copied, published, and distributed,
in whole or in part, without restriction of any kind, provided that the
above copyright notice and this section are included on all such copies
and derivative works. However, this document itself may not be modified
in any way, including by removing the copyright notice or references to
Ecma International, except as needed for the purpose of developing any
document or deliverable produced by Ecma International._

_This disclaimer is valid only prior to final version of this document.
After approval all rights on the standard are reserved by Ecma
International._

_The limited permissions are granted through the standardization phase
and will not be revoked by Ecma International or its successors or
assigns during this time._

_This document and the information contained herein is provided on an
"AS IS" basis and ECMA INTERNATIONAL DISCLAIMS ALL WARRANTIES, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
THE INFORMATION HEREIN WILL NOT INFRINGE ANY OWNERSHIP RIGHTS OR ANY
IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE."_

ECMAScript Language Specification



SCOPE


This Standard defines the ECMAScript scripting language.



CONFORMANCE


A conforming implementation of ECMAScript must provide and support all
the types, values, objects, properties, functions, and program syntax
and semantics described in this specification.

A conforming implementation of this Standard shall interpret characters
in conformance with the Unicode Standard, Version 5.1.0 or later and
ISO/IEC 10646. If the adopted ISO/IEC 10646-1 subset is not otherwise
specified, it is presumed to be the Unicode set, collection 10646.

A conforming implementation of ECMAScript is permitted to provide
additional types, values, objects, properties, and functions beyond
those described in this specification. In particular, a conforming
implementation of ECMAScript is permitted to provide properties not
described in this specification, and values for those properties, for
objects that are described in this specification.

A conforming implementation of ECMAScript is permitted to support
program and regular expression syntax not described in this
specification. In particular, a conforming implementation of ECMAScript
is permitted to support program syntax that makes use of the “future
reserved words” listed in 7.6.1.2 of this specification.



NORMATIVE REFERENCES


The following referenced documents are indispensable for the application
of this document. For dated references, only the edition cited applies.
For undated references, the latest edition of the referenced document
(including any amendments) applies.

ISO/IEC 9899:1996_, Programming Languages – C, including amendment 1 and
technical corrigenda 1 and 2_

ISO/IEC 10646:2003: _Information Technology – Universal Multiple-Octet
Coded Character Set (UCS) plus Amendment 1:2005, Amendment 2:2006,
Amendment 3:2008, and Amendment 4:2008_, plus additional amendments and
corrigenda, or successor

_The Unicode Standard, Version 5.0_, as amended by Unicode 5.1.0, or
successor

_Unicode Standard Annex #15, Unicode Normalization Forms, version
Unicode 5.1.0_, or successor

_Unicode Standard Annex #31, Unicode Identifiers and Pattern Syntax,
version Unicode 5.1.0_, or successor.



OVERVIEW


This section contains a non-normative overview of the ECMAScript
language.

ECMAScript is an object-oriented programming language for performing
computations and manipulating computational objects within a host
environment. ECMAScript as defined here is not intended to be
computationally self-sufficient; indeed, there are no provisions in this
specification for input of external data or output of computed results.
Instead, it is expected that the computational environment of an
ECMAScript program will provide not only the objects and other
facilities described in this specification but also certain
environment-specific objects, whose description and behaviour are beyond
the scope of this specification except to indicate that they may provide
certain properties that can be accessed and certain functions that can
be called from an ECMAScript program.

A _SCRIPTING LANGUAGE_ is a programming language that is used to
manipulate, customise, and automate the facilities of an existing
system. In such systems, useful functionality is already available
through a user interface, and the scripting language is a mechanism for
exposing that functionality to program control. In this way, the
existing system is said to provide a host environment of objects and
facilities, which completes the capabilities of the scripting language.
A scripting language is intended for use by both professional and
non-professional programmers. ECMAScript was originally designed to be
used as a scripting language, but has become widely used as a general
purpose programming language.

ECMAScript was originally designed to be a _WEB SCRIPTING LANGUAGE_,
providing a mechanism to enliven Web pages in browsers and to perform
server computation as part of a Web-based client-server architecture.
ECMAScript is now used both as a general propose programming language
and to provide core scripting capabilities for a variety of host
environments. Therefore the core language is specified in this document
apart from any particular host environment.

Some of the facilities of ECMAScript are similar to those used in other
programming languages; in particular Java, Self, and Scheme as
described in:

Gosling, James, Bill Joy and Guy Steele. The Java^^ Language
Specification. Addison Wesley Publishing Co., 1996.

Ungar, David, and Smith, Randall B. Self: The Power of Simplicity.
OOPSLA '87 Conference Proceedings, pp. 227–241, Orlando, FL, October
1987.

IEEE Standard for the Scheme Programming Language. IEEE Std 1178-1990.


Web Scripting

A web browser provides an ECMAScript host environment for client-side
computation including, for instance, objects that represent windows,
menus, pop-ups, dialog boxes, text areas, anchors, frames, history,
cookies, and input/output. Further, the host environment provides a
means to attach scripting code to events such as change of focus, page
and image loading, unloading, error and abort, selection, form
submission, and mouse actions. Scripting code appears within the HTML
and the displayed page is a combination of user interface elements and
fixed and computed text and images. The scripting code is reactive to
user interaction and there is no need for a main program.

A web server provides a different host environment for server-side
computation including objects representing requests, clients, and files;
and mechanisms to lock and share data. By using browser-side and
server-side scripting together, it is possible to distribute computation
between the client and server while providing a customised user
interface for a Web-based application.

Each Web browser and server that supports ECMAScript supplies its own
host environment, completing the ECMAScript execution environment.


Language Overview

The following is an informal overview of ECMAScript—not all parts of the
language are described. This overview is not part of the standard
proper.

ECMAScript is object-based: basic language and host facilities are
provided by objects, and an ECMAScript program is a cluster of
communicating objects. An ECMAScript OBJECT is a collection of
PROPERTIES each with zero or more ATTRIBUTES that determine how each
property can be used—for example, when the Writable attribute for a
property is set to FALSE, any attempt by executed ECMAScript code to
change the value of the property fails. Properties are containers that
hold other objects, _PRIMITIVE VALUES_, or FUNCTIONS. A primitive
value is a member of one of the following built-in types: UNDEFINED,
NULL, BOOLEAN, NUMBER, and STRING; an object is a member of the
remaining built-in type OBJECT; and a function is a callable object. A
function that is associated with an object via a property is a METHOD.

ECMAScript defines a collection of _BUILT-IN OBJECTS_ that round out the
definition of ECMAScript entities. These built-in objects include the
global object, the OBJECT object, the FUNCTION object, the ARRAY object,
the STRING object, the BOOLEAN object, the NUMBER object, the MATH
object, the DATE object, the REGEXP object, the JSON object, and the
Error objects ERROR, EVALERROR, RANGEERROR, REFERENCEERROR, SYNTAXERROR,
TYPEERROR and URIERROR.

ECMAScript also defines a set of built-in OPERATORS. ECMAScript
operators include various unary operations, multiplicative operators,
additive operators, bitwise shift operators, relational operators,
equality operators, binary bitwise operators, binary logical operators,
assignment operators, and the comma operator.

ECMAScript syntax intentionally resembles Java syntax. ECMAScript syntax
is relaxed to enable it to serve as an easy-to-use scripting language.
For example, a variable is not required to have its type declared nor
are types associated with properties, and defined functions are not
required to have their declarations appear textually before calls to
them.

Objects

ECMAScript does not use classes such as those in C++, Smalltalk, or
Java. Instead objects may be created in various ways including via a
literal notation or via CONSTRUCTORS which create objects and then
execute code that initialises all or part of them by assigning initial
values to their properties. Each constructor is a function that has a
property named “PROTOTYPE” that is used to implement _PROTOTYPE-BASED
INHERITANCE_ and _SHARED PROPERTIES_. Objects are created by using
constructors in NEW expressions; for example, NEW DATE(2009,11) creates
a new Date object. Invoking a constructor without using NEW has
consequences that depend on the constructor. For example, DATE()
produces a string representation of the current date and time rather
than an object.

Every object created by a constructor has an implicit reference (called
the object’s prototype) to the value of its constructor’s “PROTOTYPE”
property. Furthermore, a prototype may have a non-null implicit
reference to its prototype, and so on; this is called the _prototype
chain_. When a reference is made to a property in an object, that
reference is to the property of that name in the first object in the
prototype chain that contains a property of that name. In other words,
first the object mentioned directly is examined for such a property; if
that object contains the named property, that is the property to which
the reference refers; if that object does not contain the named
property, the prototype for that object is examined next; and so on.

  --
  --

Figure 1 — Object/Prototype Relationships

In a class-based object-oriented language, in general, state is carried
by instances, methods are carried by classes, and inheritance is only of
structure and behaviour. In ECMAScript, the state and methods are
carried by objects, while structure, behaviour, and state are all
inherited.

All objects that do not directly contain a particular property that
their prototype contains share that property and its value. Figure 1
illustrates this:

CF is a constructor (and also an object). Five objects have been created
by using NEW expressions: CF~1~, CF~2~, CF~3~, CF~4~, and CF~5~. Each of
these objects contains properties named q1 and q2. The dashed lines
represent the implicit prototype relationship; so, for example, CF~3~’s
prototype is CF~P~. The constructor, CF, has two properties itself,
named P1 and P2, which are not visible to CF~P~, CF~1~, CF~2~, CF~3~,
CF~4~, or CF~5~. The property named CFP1 in CF~P~ is shared by CF~1~,
CF~2~, CF~3~, CF~4~, and CF~5~ (but not by CF), as are any properties
found in CF~P~’s implicit prototype chain that are not named q1, q2, or
CFP1. Notice that there is no implicit prototype link between CF and
CF~P~.

Unlike class-based object languages, properties can be added to objects
dynamically by assigning values to them. That is, constructors are not
required to name or assign values to all or any of the constructed
object’s properties. In the above diagram, one could add a new shared
property for CF~1~, CF~2~, CF~3~, CF~4~, and CF~5\ ~by assigning a new
value to the property in CF~P~.

The Strict Variant of ECMAScript

The ECMAScript Language recognises the possibility that some users of
the language may wish to restrict their usage of some features available
in the language. They might do so in the interests of security, to avoid
what they consider to be error-prone features, to get enhanced error
checking, or for other reasons of their choosing. In support of this
possibility, ECMAScript defines a strict variant of the language. The
strict variant of the language excludes some specific syntactic and
semantic features of the regular ECMAScript language and modifies the
detailed semantics of some features. The strict variant also specifies
additional error conditions that must be reported by throwing error
exceptions in situations that are not specified as errors by the
non-strict form of the language.

The strict variant of ECMAScript is commonly referred to as the _strict
mode_ of the language. Strict mode selection and use of the strict mode
syntax and semantics of ECMAScript is explicitly made at the level of
individual ECMAScript code units. Because strict mode is selected at the
level of a syntactic code unit, strict mode only imposes restrictions
that have local effect within such a code unit. Strict mode does not
restrict or modify any aspect of the ECMAScript semantics that must
operate consistently across multiple code units. A complete ECMAScript
program may be composed for both strict mode and non-strict mode
ECMAScript code units. In this case, strict mode only applies when
actually executing code that is defined within a strict mode code unit.

In order to conform to this specification, an ECMAScript implementation
must implement both the full unrestricted ECMAScript language and the
strict mode variant of the ECMAScript language as defined by this
specification. In addition, an implementation must support the
combination of unrestricted and strict mode code units into a single
composite program.


Terms and definitions

For the purposes of this document, the following terms and definitions
apply.

4.3.1

type

set of data values as defined in Clause 8 of this specification

4.3.2

primitive value

member of one of the types Undefined, Null, Boolean, Number, or String
as defined in Clause 8

NOTE A primitive value is a datum that is represented directly at the
lowest level of the language implementation.

4.3.3

object

member of the type Object

NOTE An object is a collection of properties and has a single prototype
object. The prototype may be the null value.

4.3.4

constructor

function object that creates and initialises objects

NOTE The value of a constructor’s “prototype” property is a prototype
object that is used to implement inheritance and shared properties.

4.3.5

prototype

object that provides shared properties for other objects

NOTE When a constructor creates an object, that object implicitly
references the constructor’s “PROTOTYPE” property for the purpose of
resolving property references. The constructor’s “PROTOTYPE” property
can be referenced by the program expression constructor.PROTOTYPE, and
properties added to an object’s prototype are shared, through
inheritance, by all objects sharing the prototype. Alternatively, a new
object may be created with an explicitly specified prototype by using
the OBJECT.CREATE built-in function.

4.3.6

ordinary object

object that has the default behaviour for the internal methods that must
be supported by all ECMAScript objects.

4.3.7

exotic object

object that has some alternative behaviour for one or more of the
internal methods that must be supported by all ECMAScript objects.

NOTE Any object that is not an ordinary object is an exotic object.

4.3.8

standard object

object whose semantics are defined by this specification.

4.3.9

built-in object

object supplied by an ECMAScript implementation, independent of the host
environment, that is present at the start of the execution of an
ECMAScript program

NOTE Standard built-in objects are defined in this specification, and an
ECMAScript implementation may specify and define others. A _built-in
constructor_ is a built-in object that is also a constructor.

4.3.10

undefined value

primitive value used when a variable has not been assigned a value

4.3.11

Undefined type

type whose sole value is the UNDEFINED value

4.3.12

null value

primitive value that represents the intentional absence of any object
value

4.3.13

Null type

type whose sole value is the null value

4.3.14

Boolean value

member of the Boolean type

NOTE There are only two Boolean values, TRUE and FALSE.

4.3.15

Boolean type

type consisting of the primitive values TRUE and FALSE

4.3.16

Boolean object

member of the Object type that is an instance of the standard built-in
BOOLEAN constructor

NOTE A Boolean object is created by using the BOOLEAN constructor in a
NEW expression, supplying a Boolean value as an argument. The resulting
object has an internal data property whose value is the Boolean value. A
Boolean object can be coerced to a Boolean value.

4.3.17

String value

primitive value that is a finite ordered sequence of zero or more 16-bit
unsigned integer

NOTE A String value is a member of the String type. Each integer value
in the sequence usually represents a single 16-bit unit of UTF-16 text.
However, ECMAScript does not place any restrictions or requirements on
the values except that they must be 16-bit unsigned integers.

4.3.18

String type

set of all possible String values

4.3.19

String object

member of the Object type that is an instance of the standard built-in
STRING constructor

NOTE A String object is created by using the STRING constructor in a NEW
expression, supplying a String value as an argument. The resulting
object has an internal data property whose value is the String value. A
String object can be coerced to a String value by calling the STRING
constructor as a function (15.5.1).

4.3.20

Number value

primitive value corresponding to a double-precision 64-bit binary format
IEEE 754 value

NOTE A Number value is a member of the Number type and is a direct
representation of a number.

4.3.21

Number type

set of all possible Number values including the special “Not-a-Number”
(NaN) value, positive infinity, and negative infinity

4.3.22

Number object

member of the Object type that is an instance of the standard built-in
NUMBER constructor

NOTE A Number object is created by using the NUMBER constructor in a NEW
expression, supplying a Number value as an argument. The resulting
object has an internal data property whose value is the Number value. A
Number object can be coerced to a Number value by calling the NUMBER
constructor as a function (15.7.1).

4.3.23

Infinity

number value that is the positive infinite Number value

4.3.24

NaN

number value that is a IEEE 754 “Not-a-Number” value

4.3.25

function

member of the Object type that may be invoked as a subroutine

NOTE In addition to its properties, a function contains executable code
and state that determine how it behaves when invoked. A function’s code
may or may not be written in ECMAScript.

4.3.26

built-in function

built-in object that is a function

NOTE Examples of built-in functions include PARSEINT and MATH.EXP. An
implementation may provide implementation-dependent built-in functions
that are not described in this specification.

4.3.27

property

association between a name and a value that is a part of an object

NOTE Depending upon the form of the property the value may be
represented either directly as a data value (a primitive value, an
object, or a function object) or indirectly by a pair of accessor
functions.

4.3.28

method

function that is the value of a property

NOTE When a function is called as a method of an object, the object is
passed to the function as its THIS value.

4.3.29

built-in method

method that is a built-in function

NOTE Standard built-in methods are defined in this specification, and an
ECMAScript implementation may specify and provide other additional
built-in methods.

4.3.30

attribute

internal value that defines some characteristic of a property

4.3.31

own property

property that is directly contained by its object

4.3.32

inherited property

property of an object that is not an own property but is a property
(either own or inherited) of the object’s prototype



NOTATIONAL CONVENTIONS


Syntactic and Lexical Grammars

Context-Free Grammars

A _context-free grammar_ consists of a number of productions. Each
production has an abstract symbol called a nonterminal as its
_left-hand side_, and a sequence of zero or more nonterminal and
terminal symbols as its _right-hand side_. For each grammar, the
terminal symbols are drawn from a specified alphabet.

A chain production is a production that has exactly one nonterminal
symbol on its right-hand side along with zero or more terminal symbols.

Starting from a sentence consisting of a single distinguished
nonterminal, called the _goal symbol_, a given context-free grammar
specifies a language, namely, the (perhaps infinite) set of possible
sequences of terminal symbols that can result from repeatedly replacing
any nonterminal in the sequence with a right-hand side of a production
for which the nonterminal is the left-hand side.

The Lexical and RegExp Grammars

A _lexical grammar_ for ECMAScript is given in clause 7. This grammar
has as its terminal symbols characters (Unicode code units) that conform
to the rules for SourceCharacter defined in Clause 6. It defines a set
of productions, starting from the goal symbol InputElementDiv or
InputElementRegExp, that describe how sequences of such characters are
translated into a sequence of input elements.

Input elements other than white space and comments form the terminal
symbols for the syntactic grammar for ECMAScript and are called
ECMAScript tokens. These tokens are the reserved words, identifiers,
literals, and punctuators of the ECMAScript language. Moreover, line
terminators, although not considered to be tokens, also become part of
the stream of input elements and guide the process of automatic
semicolon insertion (7.9). Simple white space and single-line comments
are discarded and do not appear in the stream of input elements for the
syntactic grammar. A MultiLineComment (that is, a comment of the form
“/*…*/” regardless of whether it spans more than one line) is likewise
simply discarded if it contains no line terminator; but if a
MultiLineComment contains one or more line terminators, then it is
replaced by a single line terminator, which becomes part of the stream
of input elements for the syntactic grammar.

A _RegExp grammar_ for ECMAScript is given in 15.10. This grammar also
has as its terminal symbols the characters as defined by
SourceCharacter. It defines a set of productions, starting from the
goal symbol Pattern, that describe how sequences of characters are
translated into regular expression patterns.

Productions of the lexical and RegExp grammars are distinguished by
having two colons “::” as separating punctuation. The lexical and RegExp
grammars share some productions.

The Numeric String Grammar

Another grammar is used for translating Strings into numeric values.
This grammar is similar to the part of the lexical grammar having to do
with numeric literals and has as its terminal symbols SourceCharacter.
This grammar appears in 9.3.1.

Productions of the numeric string grammar are distinguished by having
three colons “:::” as punctuation.

The Syntactic Grammar

The _syntactic grammar_ for ECMAScript is given in clauses 11, 12, 13
and 14. This grammar has ECMAScript tokens defined by the lexical
grammar as its terminal symbols (5.1.2). It defines a set of
productions, starting from the goal symbol Script, that describe how
sequences of tokens can form syntactically correct independent
components of an ECMAScript programs.

When a stream of characters is to be parsed as an ECMAScript script, it
is first converted to a stream of input elements by repeated application
of the lexical grammar; this stream of input elements is then parsed by
a single application of the syntactic grammar. The script is
syntactically in error if the tokens in the stream of input elements
cannot be parsed as a single instance of the goal nonterminal Script,
with no tokens left over.

Productions of the syntactic grammar are distinguished by having just
one colon “:” as punctuation.

The syntactic grammar as presented in clauses 11, 12, 13 and 14 is
actually not a complete account of which token sequences are accepted as
correct ECMAScript scripts. Certain additional token sequences are also
accepted, namely, those that would be described by the grammar if only
semicolons were added to the sequence in certain places (such as before
line terminator characters). Furthermore, certain token sequences that
are described by the grammar are not considered acceptable if a
terminator character appears in certain “awkward” places.

In certain cases in order to avoid ambiguities the syntactic grammar
uses generalize productions that permit token sequences that are not
valid ECMAScript scripts. For example, this technique is used in with
object literals and object destructuring patterns. In such cases a more
restrictive supplemental grammar is provided that further restricts
the acceptable token sequences. In certain contexts, when explicitly
specific, the input elements corresponding to such a production are
parsed again using a goal symbol of a supplemental grammar. The script
is syntactically in error if the tokens in the stream of input elements
cannot be parsed as a single instance of the supplemental goal symbol,
with no tokens left over.

The JSON Grammar

The JSON grammar is used to translate a String describing a set of
ECMAScript objects into actual objects. The JSON grammar is given in
15.12.1.

The JSON grammar consists of the JSON lexical grammar and the JSON
syntactic grammar. The JSON lexical grammar is used to translate
character sequences into tokens and is similar to parts of the
ECMAScript lexical grammar. The JSON syntactic grammar describes how
sequences of tokens from the JSON lexical grammar can form syntactically
correct JSON object descriptions.

Productions of the JSON lexical grammar are distinguished by having two
colons “::” as separating punctuation. The JSON lexical grammar uses
some productions from the ECMAScript lexical grammar. The JSON syntactic
grammar is similar to parts of the ECMAScript syntactic grammar.
Productions of the JSON syntactic grammar are distinguished by using one
colon “:” as separating punctuation.

Grammar Notation

Terminal symbols of the lexical, RegExp, and numeric string grammars,
and some of the terminal symbols of the other grammars, are shown in
FIXED WIDTH font, both in the productions of the grammars and throughout
this specification whenever the text directly refers to such a terminal
symbol. These are to appear in a script either exactly as written or
using equalvant Unicode escape sequences (see clause 6). All terminal
symbol characters specified in this way are to be understood as the
appropriate Unicode character from the ASCII range, as opposed to any
similar-looking characters from other Unicode ranges.

Nonterminal symbols are shown in italic type. The definition of a
nonterminal (also called a “production”) is introduced by the name of
the nonterminal being defined followed by one or more colons. (The
number of colons indicates to which grammar the production belongs.) One
or more alternative right-hand sides for the nonterminal then follow on
succeeding lines. For example, the syntactic definition:

WhileStatement :

WHILE ( Expression ) Statement

states that the nonterminal WhileStatement represents the token WHILE,
followed by a left parenthesis token, followed by an Expression,
followed by a right parenthesis token, followed by a Statement. The
occurrences of Expression and Statement are themselves nonterminals.
As another example, the syntactic definition:

ArgumentList :

AssignmentExpression
ArgumentList , AssignmentExpression

states that an ArgumentList may represent either a single
AssignmentExpression or an ArgumentList, followed by a comma,
followed by an AssignmentExpression. This definition of ArgumentList
is recursive, that is, it is defined in terms of itself. The result is
that an ArgumentList may contain any positive number of arguments,
separated by commas, where each argument expression is an
AssignmentExpression. Such recursive definitions of nonterminals are
common.

The subscripted suffix “~opt~”, which may appear after a terminal or
nonterminal, indicates an optional symbol. The alternative containing
the optional symbol actually specifies two right-hand sides, one that
omits the optional element and one that includes it. This means that:

VariableDeclaration :

Identifier Initialiser~opt~

is a convenient abbreviation for:

VariableDeclaration :

Identifier
Identifier Initialiser

and that:

IterationStatement :

FOR ( Expression~opt~ ; Expression~opt~ ; Expression~opt~ ) Statement

is a convenient abbreviation for:

IterationStatement :

FOR ( ; Expression~opt~ ; Expression~opt~ ) Statement
FOR ( Expression ; Expression~opt~ ; Expression~opt~ ) Statement

which in turn is an abbreviation for:

IterationStatement :

FOR ( ; ; Expression~opt~ ) Statement
FOR ( ; Expression ; Expression~opt~ ) Statement
FOR ( Expression ; ; Expression~opt~ ) Statement
FOR ( Expression ; Expression ; Expression~opt~ ) Statement

which in turn is an abbreviation for:

IterationStatement :

FOR ( ; ; ) Statement
FOR ( ; ; Expression ) Statement
FOR ( ; Expression ; ) Statement
FOR ( ; Expression ; Expression ) Statement
FOR ( Expression ; ; ) Statement
FOR ( Expression ; ; Expression ) Statement
FOR ( Expression ; Expression ; ) Statement
FOR ( Expression ; Expression ; Expression ) Statement

so the nonterminal IterationStatement actually has eight alternative
right-hand sides.

When the words “ONE OF” follow the colon(s) in a grammar definition,
they signify that each of the terminal symbols on the following line or
lines is an alternative definition. For example, the lexical grammar for
ECMAScript contains the production:

NonZeroDigit :: ONE OF

1 2 3 4 5 6 7 8 9

which is merely a convenient abbreviation for:

NonZeroDigit ::

1
2
3
4
5
6
7
8
9

If the phrase “[empty]” appears as the right-hand side of a production,
it indicates that the production's right-hand side contains no terminals
or nonterminals.

If the phrase “[lookahead ∉ set]” appears in the right-hand side of a
production, it indicates that the production may not be used if the
immediately following input token is a member of the given set. The
set can be written as a list of terminals enclosed in curly braces.
For convenience, the set can also be written as a nonterminal, in which
case it represents the set of all terminals to which that nonterminal
could expand. For example, given the definitions

DecimalDigit :: ONE OF

0 1 2 3 4 5 6 7 8 9

DecimalDigits ::

DecimalDigit
DecimalDigits DecimalDigit

the definition

LookaheadExample ::

N [lookahead ∉ {1, 3, 5, 7, 9}] DecimalDigits
DecimalDigit [lookahead ∉ DecimalDigit ]

matches either the letter N followed by one or more decimal digits the
first of which is even, or a decimal digit not followed by another
decimal digit.

If the phrase “[no LineTerminator here]” appears in the right-hand
side of a production of the syntactic grammar, it indicates that the
production is _a restricted production_: it may not be used if a
LineTerminator occurs in the input stream at the indicated position.
For example, the production:

ThrowStatement :

THROW [no LineTerminator here] Expression ;

indicates that the production may not be used if a LineTerminator
occurs in the script between the THROW token and the Expression.

Unless the presence of a LineTerminator is forbidden by a restricted
production, any number of occurrences of LineTerminator may appear
between any two consecutive tokens in the stream of input elements
without affecting the syntactic acceptability of the script.

The lexical grammar has multiple goal symbols and the appropriate goal
symbol to use depends upon the syntactic grammar context. If a phrase of
the form “[Lexical goal LexicalGoalSymbol]” appears on the
right-hand-side of a syntactic production then the next token must be
lexically recognised using the indicated goal symbol. In the absence of
such a phrase the default lexical goal symbol is used.

When an alternative in a production of the lexical grammar or the
numeric string grammar appears to be a multi-character token, it
represents the sequence of characters that would make up such a token.

The right-hand side of a production may specify that certain expansions
are not permitted by using the phrase “BUT NOT” and then indicating the
expansions to be excluded. For example, the production:

Identifier ::

IdentifierName BUT NOT ReservedWord

means that the nonterminal Identifier may be replaced by any sequence
of characters that could replace IdentifierName provided that the same
sequence of characters could not replace ReservedWord.

Finally, a few nonterminal symbols are described by a descriptive phrase
in sans-serif type in cases where it would be impractical to list all
the alternatives:

SourceCharacter ::

any Unicode character


Algorithm Conventions

The specification often uses a numbered list to specify steps in an
algorithm. These algorithms are used to precisely specify the required
semantics of ECMAScript language constructs. The algorithms are not
intended to imply the use of any specific implementation technique. In
practice, there may be more efficient algorithms available to implement
a given feature.

Algorithms may be explicitly parameterised, in which case the names and
usage of the parameters must be provided as part of the algorithm’s
definition. In order to facilitate their use in multiple parts of this
specification, some algorithms, called abstract operations, are
named and written in parameterised functional form so that they may be
referenced by name from within other algorithms.

Algorithms may be associated with productions of one of the ECMAScript
grammars. A production that has multiple alternative definitions will
typically have a distinct algorithm for each alternative. When an
algorithm is associated with a grammar production, it may reference the
terminal and non-terminal symbols of the production alternative as if
they were parameters of the algorithm. When used in this manner,
non-terminal symbols refer to the actual alternative definition that is
matched when parsing the script souce code.

Unless explicitly specified otherwise, all chain productions have an
implicit associated definition for every algorithm that is might be
applied to that production’s left-hand side nonterminal. The implicit
simply reapplies the same algorithm name with the same parameters, if
any, to the chain production’s sole right-hand side nonterminal and then
result. For example, assume there is a production

Block :

{ StatementList }

but there is no evalution algorithm that is explicitly specified for
that production. If in some algorithm there is a statement of the form:
“Return the result of evaluating Block” it is implicit that the
algorithm has an evalution algorithm of the form:

  RUNTIME SEMANTICS: EVALUATION

  Block : { StatementList }

1.  Return the result of evaluating StatementList

For clarity of expression, algorithm steps may be subdivided into
sequential substeps. Substeps are indented and may themselves be further
divided into indented substeps. Outline numbering conventions are used
to identify substeps with the first level of substeps labelled with
lower case alphabetic characters and the second level of substeps
labelled with lower case roman numerals. If more than three levels are
required these rules repeat with the fourth level using numeric labels.
For example:

Top-level step

Substep.

Substep.

Subsubstep.

Subsubstep.

Subsubsubstep

Subsubsubsubstep

  Subsubsubsubsubstep

A step or substep may be written as an “if” predicate that conditions
its substeps. In this case, the substeps are only applied if the
predicate is true. If a step or substep begins with the word “else”, it
is a predicate that is the negation of the preceding “if” predicate step
at the same level.

A step may specify the iterative application of its substeps.

A step may assert an invariant condition of its algorithm. Such
assertions are used to make explicit algorithmic invariants that would
otherwise be implicit. Such assertions add no additional semantic
requirements and hence need not be checked by an implementation. They
are used simply to clarify algorithms.

Mathematical operations such as addition, subtraction, negation,
multiplication, division, and the mathematical functions defined later
in this clause should always be understood as computing exact
mathematical results on mathematical real numbers, which do not include
infinities and do not include a negative zero that is distinguished from
positive zero. Algorithms in this standard that model floating-point
arithmetic include explicit steps, where necessary, to handle infinities
and signed zero and to perform rounding. If a mathematical operation or
function is applied to a floating-point number, it should be understood
as being applied to the exact mathematical value represented by that
floating-point number; such a floating-point number must be finite, and
if it is +0 or −0 then the corresponding mathematical value is simply 0.

The mathematical function abs(x) produces the absolute value of x,
which is −x if x is negative (less than zero) and otherwise is x
itself.

The mathematical function sign(x) produces 1 if x is positive and −1
if x is negative. The sign function is not used in this standard for
cases when x is zero.

The mathematical function min(x~1~, x~2~, ..., x~n~) produces the
mathematically smallest of x~1~ through x~n~.

The notation “x modulo y” (y must be finite and nonzero) computes
a value k of the same sign as y (or zero) such that abs(k) <
abs(y) and x_−_k = q × y for some integer q.

The mathematical function floor(x) produces the largest integer
(closest to positive infinity) that is not larger than x.

NOTE floor(x) = x_−(_x modulo 1).


Static Semantic Rules

Context-free grammars are not sufficiently powerful to express all the
rules that define whether a stream of input elements make up a valid
ECMAScript script that may be evaluated. In some situations additional
rules are needed that may be expressed using either ECMAScript algorithm
conventions or prose requirements. Such rules are always associated with
a production of a grammar and are called the _static semantics_ of the
production.

Static Semantic Rules have names and typically are defined using an
algorithm. Named Static Semantic Rules are associated with grammar
productions and a production that has multiple alternative definitions
will typically have for each alternative a distinct algorithm for each
applicable named static semantic rule.

Unless otherwise specified every grammar production alternative in this
specification implicitly has a definition for a static semantic rule
named Contains which takes an argument named symbol whose value is a
terminal or non-terminal of the grammar that includes the associated
production. The default definition of Contains is:

1.  For each terminal and non-terminal grammar symbol, sym, in the
    definition of this production do

    a.  If sym is the same grammar symbol as symbol, return TRUE.

    b.  If sym is a non-terminal, then

        i.  Let contained be the result of Contains for sym with
            argument symbol.

        ii. If contained is TRUE, return TRUE.

2.  Return FALSE.

The above definition is explicitly over-ridden for specific productions.

A special kind of static semantic rule is an Early Error Rule. Early
error rules define early error conditions (see clause 16) that are
associate with specific grammar productions. Evaluation of most early
error rules are not explicitly invoked within the algorithms of this
specification. A comforming implementation must, prior to the first
evaluation of a Script, validate all of the early error rules of the
productions used to parse that Script. If any of the early error rules
are violated the Script is invalid and cannot be evaluated.



SOURCE TEXT


Syntax

SourceCharacter ::

  any Unicode character

The ECMAScript code is expressed using Unicode, version 5.1 or later.
ECMAScript source text is a sequence of Unicode characters. The phrase
“Unicode character” refers to the abstract linguistic or typographical
unit represented by a single Unicode scalar value. The actual encodings
used to store and interchange ECMAScript source text is not relevant to
this specification. Any well-defined encoding such as UTF-32 or UTF-16
may be used. Source text might even be externally represented using a
non-Unicode character encoding. Regardless of the external source text
encoding, a conforming ECMAScript implementation processes the source
text as if it was an equivalent sequence of SourceCharacter values.
Each SourceCharacter being an abstract Unicode character with a
corresponding Unicode scalar value. Conforming ECMAScript
implementations are not required to perform any normalisation of text,
or behave as though they were performing normalisation of text.

The phrase “code point” refers to such a Unicode scalar value. “Unicode
character” only refers to entities represented by single Unicode scalar
values: the components of a combining character sequence are still
individual “Unicode characters,” even though a user might think of the
whole sequence as a single character.

In string literals, regular expression literals,template literals and
identifiers, any Unicode characters may also be expressed as a Unicode
escape sequence that explicitly express a code point’s numeric value.
Within a comment, such an escape sequence is effectively ignored as part
of the comment. Within other contexts, such an escape sequence
contextually contributes one Unicode character.

NOTE

ECMAScript differs from the Java programming language in the behaviour
of Unicode escape sequences. In a Java program, if the Unicode escape
sequence \U000A, for example, occurs within a single-line comment, it is
interpreted as a line terminator (Unicode character 000A is line feed)
and therefore the next Unicode character is not part of the comment.
Similarly, if the Unicode escape sequence \U000A occurs within a string
literal in a Java program, it is likewise interpreted as a line
terminator, which is not allowed within a string literal—one must write
\N instead of \U000A to cause a line feed to be part of the string value
of a string literal. In an ECMAScript program, a Unicode escape sequence
occurring within a comment is never interpreted and therefore cannot
contribute to termination of the comment. Similarly, a Unicode escape
sequence occurring within a string literal in an ECMAScript program
always contributes a Unicode character to the literal and is never
interpreted as a line terminator or as a quote mark that might terminate
the string literal.

ECMAScript String values (8.4) are computational sequences of 16-bit
integer values called “code units”. ECMAScript language constructs that
generate string values from SourceCharacter sequences use UTF-16
encoding to generate the code unit values.

STATIC SEMANTICS: UTF-16 ENCODING

The UTF-16 Encoding of a numeric code point value, cp, is determined
as follows:

1.  Assert: 0 ≤ cp ≤ 0x10FFFF

2.  If cp ≤ 65535, then return cp.

3.  Let cu1 be floor((cp – 65536) / 1024) + 55296. NOTE 55296 is
    0xD800.

4.  Let cu2 be ((cp – 65536) modulo 1024) + 56320. NOTE 56320 is
    0xDC00.

5.  Return the code unit sequence consisting of cu1 followed by cu2.



LEXICAL CONVENTIONS


The source text of an ECMAScript script is first converted into a
sequence of input elements, which are tokens, line terminators,
comments, or white space. The source text is scanned from left to right,
repeatedly taking the longest possible sequence of characters as the
next input element.

There are several situations where the identification of lexical input
elements is sensitive to the syntactic grammar context that is consuming
the input elements. This requires multiple goal symbols for the lexical
grammar. The InputElementDiv goal symbol is the default goal symbol
and is used in those syntactic grammar contexts where a leading division
(/) or division-assignment (/=) operator is permitted. The
InputElementRegExp goal symbol is used in all syntactic grammar
contexts where a RegularExpressionLiteral is permitted. The
InputElementTemplateTail goal is used in syntactic grammar contexts
where a TemplateLiteral logically continues after a substitution
element.

NOTE There are no syntactic grammar contexts where both a leading
division or division-assignment, and a leading
RegularExpressionLiteral are permitted. This is not affected by
semicolon insertion (see 7.9); in examples such as the following:

  A = B
  /HI/G.EXEC(C).MAP(D);

where the first non-whitespace, non-comment character after a
LineTerminator is slash (/) and the syntactic context allows division
or division-assignment, no semicolon is inserted at the
LineTerminator. That is, the above example is interpreted in the same
way as:

  A = B / HI / G.EXEC(C).MAP(D);

Syntax

InputElementDiv ::

WhiteSpace
LineTerminator
Comment
Token
DivPunctuator
RightBracePunctuator

InputElementRegExp ::

WhiteSpace
LineTerminator
Comment
Token
RightBracePunctuator
RegularExpressionLiteral

InputElementTemplateTail ::

WhiteSpace
LineTerminator
Comment
Token
DivPunctuator
TemplateSubstitutionTail


Unicode Format-Control Characters

The Unicode format-control characters (i.e., the characters in category
“Cf” in the Unicode Character Database such as left-to-right mark or
right-to-left mark) are control codes used to control the formatting of
a range of text in the absence of higher-level protocols for this (such
as mark-up languages).

It is useful to allow format-control characters in source text to
facilitate editing and display. All format control characters may be
used within comments, and within string literals, template literals, and
regular expression literals.

<ZWNJ> and <ZWJ> are format-control characters that are used to make
necessary distinctions when forming words or phrases in certain
languages. In ECMAScript source text, <ZWNJ> and <ZWJ> may also be used
in an identifier after the first character.

<BOM> is a format-control character used primarily at the start of a
text to mark it as Unicode and to allow detection of the text's encoding
and byte order. <BOM> characters intended for this purpose can sometimes
also appear after the start of a text, for example as a result of
concatenating files. <BOM> characters are treated as white space
characters (see 7.2).

The special treatment of certain format-control characters outside of
comments, string literals, and regular expression literals is summarised
in Table 1.

Table 1 — Format-Control Character Usage

  ---------------- ----------------------- --------------- ------------------
  CODE POINT   NAME                  _FORMAL NAME_   USAGE
  U+200C           Zero width non-joiner   <ZWNJ>          IdentifierPart
  U+200D           Zero width joiner       <ZWJ>           IdentifierPart
  U+FEFF           Byte Order Mark         <BOM>           Whitespace
  ---------------- ----------------------- --------------- ------------------


White Space

White space characters are used to improve source text readability and
to separate tokens (indivisible lexical units) from each other, but are
otherwise insignificant. White space characters may occur between any
two tokens and at the start or end of input. White space characters may
occur within a StringLiteral, a RegularExpressionLiteral, a
Template, or a TemplateSubstitutionTail where they are considered
significant characters forming part of a literal value. They may also
occur within a Comment, but cannot appear within any other kind of
token.

The ECMAScript white space characters are listed in Table 2.

Table 2 — Whitespace Characters

  --------------------- ------------------------------------- ---------------
  CODE POINT        NAME                                _FORMAL NAME_
  U+0009                Tab                                   <TAB>
  U+000B                Vertical Tab                          <VT>
  U+000C                Form Feed                             <FF>
  U+0020                Space                                 <SP>
  U+00A0                No-break space                        <NBSP>
  U+FEFF                Byte Order Mark                       <BOM>
  Other category “Zs”   Any other Unicode “space separator”   <USP>
  --------------------- ------------------------------------- ---------------

ECMAScript implementations must recognise all of the white space
characters defined in Unicode 5.1. Later editions of the Unicode
Standard may define other white space characters. ECMAScript
implementations may recognise white space characters from later editions
of the Unicode Standard.

Syntax

WhiteSpace ::

<TAB>
<VT>
<FF>
<SP>
<NBSP>
<BOM>
<USP>


Line Terminators

Like white space characters, line terminator characters are used to
improve source text readability and to separate tokens (indivisible
lexical units) from each other. However, unlike white space characters,
line terminators have some influence over the behaviour of the syntactic
grammar. In general, line terminators may occur between any two tokens,
but there are a few places where they are forbidden by the syntactic
grammar. Line terminators also affect the process of automatic semicolon
insertion (7.9). A line terminator cannot occur within any token except
a StringLiteral, Template, or TemplateSubstitutionTail. Line
terminators may only occur within a StringLiteral token as part of a
LineContinuation.

A line terminator can occur within a MultiLineComment (7.4) but cannot
occur within a SingleLineComment.

Line terminators are included in the set of white space characters that
are matched by the \S class in regular expressions.

The ECMAScript line terminator characters are listed in Table 3.

Table 3 — Line Terminator Characters

  ---------------- --------------------- ---------------
  CODE POINT   NAME                _FORMAL NAME_
  U+000A           Line Feed             <LF>
  U+000D           Carriage Return       <CR>
  U+2028           Line separator        <LS>
  U+2029           Paragraph separator   <PS>
  ---------------- --------------------- ---------------

Only the Unicode characters in Table 3 are treated as line terminators.
Other new line or line breaking Unicode characters are treated as white
space but not as line terminators. The sequence <CR><LF> is commonly
used as a line terminator. It should be considered a single
SourceCharacter for the purpose of reporting line numbers.

Syntax

LineTerminator ::

<LF>
<CR>
<LS>
<PS>

LineTerminatorSequence ::

<LF>
<CR> [lookahead ∉ <LF> ]
<LS>
<PS>
<CR> <LF>


Comments

Comments can be either single or multi-line. Multi-line comments cannot
nest.

Because a single-line comment can contain any Unicode character except a
LineTerminator character, and because of the general rule that a token
is always as long as possible, a single-line comment always consists of
all characters from the // marker to the end of the line. However, the
LineTerminator at the end of the line is not considered to be part of
the single-line comment; it is recognised separately by the lexical
grammar and becomes part of the stream of input elements for the
syntactic grammar. This point is very important, because it implies that
the presence or absence of single-line comments does not affect the
process of automatic semicolon insertion (see 7.9).

Comments behave like white space and are discarded except that, if a
MultiLineComment contains a line terminator character, then the entire
comment is considered to be a LineTerminator for purposes of parsing
by the syntactic grammar.

Syntax

Comment ::

MultiLineComment
SingleLineComment

MultiLineComment ::

/* MultiLineCommentChars~opt~ */

MultiLineCommentChars ::

MultiLineNotAsteriskChar MultiLineCommentChars~opt~
* PostAsteriskCommentChars~opt~

PostAsteriskCommentChars ::

MultiLineNotForwardSlashOrAsteriskChar MultiLineCommentChars~opt~
* PostAsteriskCommentChars~opt~

MultiLineNotAsteriskChar ::

SourceCharacter BUT NOT *

MultiLineNotForwardSlashOrAsteriskChar ::

SourceCharacter BUT NOT ONE OF / OR *

SingleLineComment ::

// SingleLineCommentChars~opt~

SingleLineCommentChars ::

SingleLineCommentChar SingleLineCommentChars~opt~

SingleLineCommentChar ::

SourceCharacter BUT NOT LineTerminator


Tokens

Syntax

Token ::

IdentifierName
Punctuator
NumericLiteral
StringLiteral
Template

NOTE The DivPunctuator, RegularExpressionLiteral,
RightBracePunctuator, and TemplateSubstitutionTail productions
define tokens, but are not included in the Token production.


Identifier Names and Identifiers

IdentifierName, Identifier, and ReservedWord are tokens that are
interpreted according to the Default Identifier Syntax given in Unicode
Standard Annex #31, Identifier and Pattern Syntax, with some small
modifications. ReservedWord is is an enumerated subset of
IdentifierName and Identifier is an IdentifierName that is not a
ReservedWord (see 7.6.1). The Unicode identifier grammar is based on
character properties specified by the Unicode Standard. The Unicode
characters in the specified categories in version 5.1.0 of the Unicode
standard must be treated as in those categories by all conforming
ECMAScript implementations. ECMAScript implementations may recognise
identifier characters defined in later editions of the Unicode Standard.

NOTE 1 This standard specifies specific character additions: The dollar
sign (U+0024) and the underscore (U+005F) are permitted anywhere in an
IdentifierName, and the characters zero width non-joiner (U+200C) and
zero width joiner (U+200D) are permitted anywhere after the first
character of an IdentifierName.

Unicode escape sequences are permitted in an IdentifierName, where
they contribute a single Unicode character to the IdentifierName. The
code point of the contributed character is expressed by the HexDigits
of the UnicodeEscapeSequence (see 7.8.6). The \ preceding the
UnicodeEscapeSequence and the U and { } characters, if they appear, do
not contribute characters to the IdentifierName. A
UnicodeEscapeSequence cannot be used to put a character into an
IdentifierName that would otherwise be illegal. In other words, if a \
UnicodeEscapeSequence sequence were replaced by the Unicode character
it constributes, the result must still be a valid IdentifierName that
has the exact same sequence of characters as the original
IdentifierName. All interpretations of IdentifierName within this
specification are based upon their actual characters regardless of
whether or not an escape sequence was used to contribute any particular
characters.

Two IdentifierName that are canonically equivalent according to the
Unicode standard are not equal unless they are represented by the
exact same sequence of code units (in other words, conforming ECMAScript
implementations are only required to do bitwise comparison on
IdentifierName values).

NOTE 2 If maximal portability is a concern, programmers should only
employ the identifier characters that were defined in Unicode 3.0.

Syntax

Identifier ::

IdentifierName BUT NOT ReservedWord

IdentifierName ::

IdentifierStart
IdentifierName IdentifierPart

IdentifierStart ::

UnicodeIDStart
$
_
\ UnicodeEscapeSequence

IdentifierPart ::

UnicodeIDContinue
$
_
\ UnicodeEscapeSequence
<ZWNJ>
<ZWJ>

UnicodeIDStart ::

any Unicode character with the Unicode property “ID_Start”.

UnicodeIDContinue ::

any Unicode character with the Unicode property “ID_Continue”

The definitions of the nonterminal UnicodeEscapeSequence is given in
7.8.6

STATIC SEMANTICS: STRINGVALUE

Identifier :: IdentifierName BUT NOT ReservedWord

1.  Return the StringValue of IdentifierName.

IdentifierName ::

IdentifierStart
IdentifierName IdentifierPart

1.  Return the String value consisting of the sequence of code units
    corresponding to IdentifierName. In determining the sequence any
    occurrences of \ UnicodeEscapeSequence are first replaced with the
    code point represented by the UnicodeEscapeSequence and then the
    code points of the entire IdentifierName are converted to code
    units by UTF-16 Encoding (clause 6) each code point.

Reserved Words

A reserved word is an IdentifierName that cannot be used as an
Identifier.

Syntax

ReservedWord ::

Keyword
FutureReservedWord
NullLiteral
BooleanLiteral

The ReservedWord definitions are specified as literal sequences of
Unicode characters. However, any Unicode character in a ReservedWord
can also be expressed by a \ UnicodeEscapeSequence that expresses that
same Unicode character’s code point. Use of such escape sequences does
not change the meaning of the ReservedWord.

Keywords

The following tokens are ECMAScript keywords and may not be used as
Identifiers in ECMAScript programs.

Syntax

Keyword :: ONE OF

  ---------- ---------- ------------ --------
  break      delete     import       this
  case       do         in           throw
  catch      else       instanceof   try
  class      export     let          typeof
  continue   finally    new          var
  const      for        return       void
  debugger   function   super        while
  default    if         switch       with
  ---------- ---------- ------------ --------

Future Reserved Words

The following words are used as keywords in proposed extensions and are
therefore reserved to allow for the possibility of future adoption of
those extensions.

Syntax

FutureReservedWord :: ONE OF

  -- ------ --------- --
     enum   extends   
                      
  -- ------ --------- --

The following tokens are also considered to be FutureReservedWords
when they occur within strict mode code (see 10.1.1). The occurrence of
any of these tokens within strict mode code in any context where the
occurrence of a FutureReservedWord would produce an error must also
produce an equivalent error:

  ------------ --------- ----------- -------- -------
  implements             private     public   yield
  interface    package   protected   static   
  ------------ --------- ----------- -------- -------


Punctuators

Syntax

Punctuator :: ONE OF

  ----- ------ ----- ----- ----- -----
  {     (      )     [     ]     .
  ...   ;      ,     <     >     <=
  >=    ==     !=    ===   !==   
  +     -      *     %     ++    --
  <<    >>     >>>   &     |     ^
  !     ~      &&    ||    ?     :
  =     +=     -=    *=    %=    <<=
  >>=   >>>=   &=    |=    ^=    =>
  ----- ------ ----- ----- ----- -----

DivPunctuator :: ONE OF

  --- ---- -- -- -- --
  /   /=            
  --- ---- -- -- -- --

RightBracePunctuator ::

  --- -- -- -- -- --
  }               
  --- -- -- -- -- --


Literals

Null Literals

Syntax

NullLiteral ::

NULL

Boolean Literals

Syntax

BooleanLiteral ::

TRUE
FALSE

Numeric Literals

Syntax

NumericLiteral ::

DecimalLiteral
BinaryIntegerLiteral
OctalIntegerLiteral
HexIntegerLiteral

DecimalLiteral ::

DecimalIntegerLiteral . DecimalDigits~opt~ ExponentPart~opt~
. DecimalDigits ExponentPart~opt~
DecimalIntegerLiteral ExponentPart~opt~

DecimalIntegerLiteral ::

0
NonZeroDigit DecimalDigits~opt~

DecimalDigits ::

DecimalDigit
DecimalDigits DecimalDigit

DecimalDigit :: ONE OF

0 1 2 3 4 5 6 7 8 9

NonZeroDigit :: ONE OF

1 2 3 4 5 6 7 8 9

ExponentPart ::

ExponentIndicator SignedInteger

ExponentIndicator :: ONE OF

E E

SignedInteger ::

DecimalDigits
+ DecimalDigits
- DecimalDigits

BinaryIntegerLiteral ::

0B BinaryDigits
0B BinaryDigits

BinaryDigits ::

BinaryDigit
BinaryDigits BinaryDigit

BinaryDigit :: ONE OF

0 1

OctalIntegerLiteral ::

0O OctalDigits
0O OctalDigits

OctalDigits ::

OctalDigit
OctalDigits OctalDigit

OctalDigit :: ONE OF

0 1 2 3 4 5 6 7

HexIntegerLiteral ::

0X HexDigits
0X HexDigits

HexDigits ::

HexDigit
HexDigits HexDigit

HexDigit :: ONE OF

0 1 2 3 4 5 6 7 8 9 A B C D E F A B C D E F

The SourceCharacter immediately following a NumericLiteral must not
be an IdentifierStart or DecimalDigit.

NOTE For example:

  3in

is an error and not the two input elements 3 and IN.

A conforming implementation, when processing strict mode code (see
10.1.1), must not extend the syntax of NumericLiteral to include
LegacyOctalIntegerLiteral as described in B.1.1.

Static Semantics: MV’s

A numeric literal stands for a value of the Number type. This value is
determined in two steps: first, a mathematical value (MV) is derived
from the literal; second, this mathematical value is rounded as
described below.

-   The MV of NumericLiteral :: DecimalLiteral is the MV of
    DecimalLiteral.

-   The MV of NumericLiteral :: BinaryIntegerLiteral is the MV of
    BinaryIntegerLiteral.

-   The MV of NumericLiteral :: OctalIntegerLiteral is the MV of
    OctalIntegerLiteral.

-   The MV of NumericLiteral :: HexIntegerLiteral is the MV of
    HexIntegerLiteral.

-   The MV of DecimalLiteral :: DecimalIntegerLiteral . is the MV of
    DecimalIntegerLiteral.

-   The MV of DecimalLiteral :: DecimalIntegerLiteral .
    DecimalDigits is the MV of DecimalIntegerLiteral plus (the MV of
    DecimalDigits × 10^–n^), where n is the number of characters
    in DecimalDigits.

-   The MV of DecimalLiteral :: DecimalIntegerLiteral .
    ExponentPart is the MV of DecimalIntegerLiteral × 10^e^, where
    e is the MV of ExponentPart.

-   The MV of DecimalLiteral :: DecimalIntegerLiteral .
    _DecimalDigits ExponentPart_ is (the MV of DecimalIntegerLiteral
    plus (the MV of DecimalDigits × 10^–n^)) × 10^e^, where n is
    the number of characters in DecimalDigits and e is the MV of
    ExponentPart.

-   The MV of DecimalLiteral ::. DecimalDigits is the MV of
    DecimalDigits × 10^–n^, where n is the number of characters in
    DecimalDigits.

-   The MV of DecimalLiteral ::. _DecimalDigits ExponentPart_ is the
    MV of DecimalDigits × 10^e_–_n^, where n is the number of
    characters in DecimalDigits and e is the MV of ExponentPart.

-   The MV of DecimalLiteral :: DecimalIntegerLiteral is the MV of
    DecimalIntegerLiteral.

-   The MV of DecimalLiteral :: _DecimalIntegerLiteral ExponentPart_
    is the MV of DecimalIntegerLiteral × 10^e^, where e is the MV
    of ExponentPart.

-   The MV of DecimalIntegerLiteral :: 0 is 0.

-   The MV of DecimalIntegerLiteral :: NonZeroDigit is the MV of
    NonZeroDigit.

-   The MV of DecimalIntegerLiteral :: NonZeroDigit DecimalDigits
    is (the MV of NonZeroDigit × 10^n^) plus the MV of
    DecimalDigits, where n is the number of characters in
    DecimalDigits.

-   The MV of DecimalDigits :: DecimalDigit is the MV of
    DecimalDigit.

-   The MV of DecimalDigits :: DecimalDigits DecimalDigit is (the
    MV of DecimalDigits × 10) plus the MV of DecimalDigit.

-   The MV of ExponentPart :: _ExponentIndicator SignedInteger_ is the
    MV of SignedInteger.

-   The MV of SignedInteger :: DecimalDigits is the MV of
    DecimalDigits.

-   The MV of SignedInteger :: + DecimalDigits is the MV of
    DecimalDigits.

-   The MV of SignedInteger :: - DecimalDigits is the negative of
    the MV of DecimalDigits.

-   The MV of DecimalDigit :: 0 or of HexDigit :: 0 or of
    OctalDigit :: 0 or of BinaryDigit :: 0 is 0.

-   The MV of DecimalDigit :: 1 or of NonZeroDigit :: 1 or of
    HexDigit :: 1 or of OctalDigit :: 1 or
    of BinaryDigit :: 1 is 1.

-   The MV of DecimalDigit :: 2 or of NonZeroDigit :: 2 or of
    HexDigit :: 2 or of OctalDigit :: 2 is 2.

-   The MV of DecimalDigit :: 3 or of NonZeroDigit :: 3 or of
    HexDigit :: 3 or of OctalDigit :: 3 is 3.

-   The MV of DecimalDigit :: 4 or of NonZeroDigit :: 4 or of
    HexDigit :: 4 or of OctalDigit :: 4 is 4.

-   The MV of DecimalDigit :: 5 or of NonZeroDigit :: 5 or of
    HexDigit :: 5 or of OctalDigit :: 5 is 5.

-   The MV of DecimalDigit :: 6 or of NonZeroDigit :: 6 or of
    HexDigit :: 6 or of OctalDigit :: 6 is 6.

-   The MV of DecimalDigit :: 7 or of NonZeroDigit :: 7 or of
    HexDigit :: 7 or of OctalDigit :: 7 is 7.

-   The MV of DecimalDigit :: 8 or of NonZeroDigit :: 8 or of
    HexDigit :: 8 is 8.

-   The MV of DecimalDigit :: 9 or of NonZeroDigit :: 9 or of
    HexDigit :: 9 is 9.

-   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   The
    MV of HexDigit :: A or of HexDigit :: A is 10.

-   The MV of HexDigit :: B or of HexDigit :: B is 11.

-   The MV of HexDigit :: C or of HexDigit :: C is 12.

-   The MV of HexDigit :: D or of HexDigit :: D is 13.

-   The MV of HexDigit :: E or of HexDigit :: E is 14.

-   The MV of HexDigit :: F or of HexDigit :: F is 15.

-   The MV of BinaryIntegerLiteral :: 0B BinaryDigits is the MV of
    BinaryDigits.

-   The MV of BinaryIntegerLiteral :: 0B BinaryDigits is the MV of
    BinaryDigits.

-   The MV of BinaryDigits :: BinaryDigit is the MV of
    BinaryDigit.

-   The MV of BinaryDigits :: BinaryDigits BinaryDigit is (the MV
    of BinaryDigits × 2) plus the MV of BinaryDigit.

-   The MV of OctalIntegerLiteral :: 0O OctalDigits is the MV of
    OctalDigits.

-   The MV of OctalIntegerLiteral :: 0O OctalDigits is the MV of
    OctalDigits.

-   The MV of OctalDigits :: OctalDigit is the MV of OctalDigit.

-   The MV of OctalDigits :: OctalDigits OctalDigit is (the MV of
    OctalDigits × 8) plus the MV of OctalDigit.

-   The MV of HexIntegerLiteral :: 0X HexDigits is the MV of
    HexDigits.

-   The MV of HexIntegerLiteral :: 0X HexDigits is the MV of
    HexDigits.

-   The MV of HexDigits :: HexDigit is the MV of HexDigit.

-   The MV of HexDigits :: HexDigits HexDigit is (the MV of
    HexDigits × 16) plus the MV of HexDigit.

Once the exact MV for a numeric literal has been determined, it is then
rounded to a value of the Number type. If the MV is 0, then the rounded
value is +0; otherwise, the rounded value must be the Number value for
the MV (as specified in 8.5), unless the literal is a DecimalLiteral
and the literal has more than 20 significant digits, in which case the
Number value may be either the Number value for the MV of a literal
produced by replacing each significant digit after the 20th with a 0
digit or the Number value for the MV of a literal produced by replacing
each significant digit after the 20th with a 0 digit and then
incrementing the literal at the 20th significant digit position. A digit
is significant if it is not part of an ExponentPart and

-   it is not 0; or

-   there is a nonzero digit to its left and there is a nonzero digit,
    not in the ExponentPart, to its right.

-   

-   -   -   -   -   -   -   -   -   -   

-   -   -   -   -   -   -   -   -   -   

  -- -- -- --
           
           
           
           
           
           
           
           
           
           
  -- -- -- --

Regular Expression Literals

NOTE A regular expression literal is an input element that is converted
to a RegExp object (see 15.10) each time the literal is evaluated. Two
regular expression literals in a program evaluate to regular expression
objects that never compare as === to each other even if the two
literals' contents are identical. A RegExp object may also be created at
runtime by NEW REGEXP (see 15.10.4) or calling the REGEXP constructor as
a function (15.10.3).

The productions below describe the syntax for a regular expression
literal and are used by the input element scanner to find the end of the
regular expression literal. The source code comprising the
RegularExpressionBody and the RegularExpressionFlags are
subsequently parsed using the more stringent ECMAScript Regular
Expression grammar (15.10.1).

An implementation may extend the ECMAScript Regular Expression grammar
defined in 15.10.1, but it must not extend the RegularExpressionBody
and RegularExpressionFlags productions defined below or the
productions used by these productions.

Syntax

RegularExpressionLiteral ::

/ RegularExpressionBody / RegularExpressionFlags

RegularExpressionBody ::

RegularExpressionFirstChar RegularExpressionChars

RegularExpressionChars ::

[empty]
RegularExpressionChars RegularExpressionChar

RegularExpressionFirstChar ::

RegularExpressionNonTerminator BUT NOT ONE OF * OR \ OR / OR [
RegularExpressionBackslashSequence
RegularExpressionClass

RegularExpressionChar ::

RegularExpressionNonTerminator BUT NOT ONE OF \ OR / OR [
RegularExpressionBackslashSequence
RegularExpressionClass

RegularExpressionBackslashSequence ::

\ RegularExpressionNonTerminator

RegularExpressionNonTerminator ::

SourceCharacter BUT NOT LineTerminator

RegularExpressionClass ::

[ RegularExpressionClassChars ]

RegularExpressionClassChars ::

[empty]
RegularExpressionClassChars RegularExpressionClassChar

RegularExpressionClassChar ::

RegularExpressionNonTerminator BUT NOT ONE OF ] OR \
RegularExpressionBackslashSequence

RegularExpressionFlags ::

[empty]
RegularExpressionFlags IdentifierPart

NOTE Regular expression literals may not be empty; instead of
representing an empty regular expression literal, the characters //
start a single-line comment. To specify an empty regular expression,
use: /(?:)/.

STATIC SEMANTICS: EARLY ERRORS

RegularExpressionFlags :: _RegularExpressionFlags IdentifierPart _

-   It is a Syntax Error if IdentifierPart contains a Unicode escape
    sequence.

STATIC SEMANTICS: BODYTEXT

RegularExpressionLiteral :: / RegularExpressionBody /
RegularExpressionFlags

1.  Return the source code that was recognised as
    RegularExpressionBody.

STATIC SEMANTICS: FLAGTEXT

RegularExpressionLiteral :: / RegularExpressionBody /
RegularExpressionFlags

1.  Return the source code that was recognised as
    RegularExpressionFlags.

Template Literal Lexical Components

Syntax

Template ::

NoSubstitutionTemplate
TemplateHead

NoSubstitutionTemplate ::

` TemplateCharacters~opt~ `

TemplateHead ::

` TemplateCharacters~opt~ ${

TemplateSubstitutionTail ::

TemplateMiddle
TemplateTail

TemplateMiddle ::

} TemplateCharacters~opt~ ${

TemplateTail ::

} TemplateCharacters~opt~ `

TemplateCharacters ::

TemplateCharacter TemplateCharacters~opt~

TemplateCharacter ::

SourceCharacter BUT NOT ONE OF ` OR \ OR $
$ [lookahead ∉ { ]
\ EscapeSequence
LineContinuation

STATIC SEMANTICS: TV’S AND TRV’S

A template literal component is interpreted as a sequence of Unicode
characters. The Template Value (TV) of a literal component is described
in terms of code unit values (CV, 7.8.4) contributed by the various
parts of the template literal component. As part of this process, some
Unicode characters within the template component are interpreted as
having a mathematical value (MV, 7.8.3). In determining a TV, escape
sequences are replaced by the code unit of the Unicode characters
represented by the escape sequence. The Template Raw Value (TRV) is
similar to a Template Value with the difference that in TRVs escape
sequences are interpreted literally.

-   The TV and TRV of NoSubstitutionTemplate :: `` is the empty code
    unit sequence.

-   The TV and TRV of TemplateHead :: `${ is the empty code unit
    sequence.

-   The TV and TRV of TemplateMiddle :: }${ is the empty code unit
    sequence.

-   The TV and TRV of TemplateTail :: }` is the empty code unit
    sequence.

-   The TV of NoSubstitutionTemplate :: ` TemplateCharacters ` is
    the TV of TemplateCharacters.

-   The TV of TemplateHead :: ` TemplateCharacters ${ is the TV of
    TemplateCharacters.

-   The TV of TemplateMiddle :: } TemplateCharacters ${ is the TV of
    TemplateCharacters.

-   The TV of TemplateTail :: } TemplateCharacters ` is the TV of
    TemplateCharacters.

-   The TV of TemplateCharacters :: TemplateCharacter is the TV of
    TemplateCharacter.

-   The TV of TemplateCharacters :: TemplateCharacter
    TemplateCharacters is a sequence consisting of the code units in
    the TV of TemplateCharacter followed by all the code units in the
    TV of TemplateCharacters in order.

-   The TV of TemplateCharacter :: SourceCharacter BUT NOT ONE OF `
    OR \ OR $ is the UTF-16 Encoding (clause 6) of the code point value
    of SourceCharacter.

-   The TV of TemplateCharacter :: $ [lookahead ∉ { ] is the code unit
    value 0x0024.

-   The TV of TemplateCharacter :: \ EscapeSequence is the CV of
    EscapeSequence.

-   The TV of TemplateCharacter :: LineContinuation is the TV of
    LineContinuation.

-   The TV of LineContinuation :: \ LineTerminatorSequence is the
    empty code unit sequence.

-   The TRV of NoSubstitutionTemplate :: ` TemplateCharacters ` is
    the TRV of TemplateCharacters.

-   The TRV of TemplateHead :: ` TemplateCharacters ${ is the TRV of
    TemplateCharacters.

-   The TRV of TemplateMiddle :: } TemplateCharacters ${ is the TRV
    of TemplateCharacters.

-   The TRV of TemplateTail :: } TemplateCharacters ` is the TRV of
    TemplateCharacters.

-   The TRV of TemplateCharacters :: TemplateCharacter is the TRV of
    TemplateCharacter.

-   The TRV of TemplateCharacters :: TemplateCharacter
    TemplateCharacters is a sequence consisting of the code units in
    the TRV of TemplateCharacter followed by all the code units in the
    TRV of TemplateCharacters, in order.

-   The TRV of TemplateCharacter :: SourceCharacter BUT NOT ONE OF `
    OR \ OR $ is the UTF-16 Encoding (clause 6) of the code point value
    of SourceCharacter.

-   The TRV of TemplateCharacter :: $ [lookahead ∉ { ] is the code
    unit value 0x0024.

-   The TRV of TemplateCharacter :: \ EscapeSequence is the sequence
    consisting of the code unit value 0x005C followed by the code units
    of TRV of EscapeSequence.

-   The TRV of TemplateCharacter :: LineContinuation is the TRV of
    LineContinuation.

-   The TRV of EscapeSequence :: CharacterEscapeSequence is the TRV
    of the CharacterEscapeSequence.

-   The TRV of EscapeSequence :: 0 [lookahead ∉ DecimalDigit] is the
    code unit value 0x0030.

-   The TRV of EscapeSequence :: HexEscapeSequence is the TRV of the
    HexEscapeSequence.

-   The TRV of EscapeSequence :: UnicodeEscapeSequence is the TRV of
    the UnicodeEscapeSequence.

-   The TRV of CharacterEscapeSequence :: SingleEscapeCharacter is
    the TRV of the SingleEscapeCharacter.

-   The TRV of CharacterEscapeSequence :: NonEscapeCharacter is the
    CV of the NonEscapeCharacter.

-   The TRV of SingleEscapeCharacter :: ONE OF ' " \ B F N R T V is
    the CV of the SourceCharacter that is that single character.

-   The TRV of HexEscapeSequence :: X _HexDigit HexDigit_ is the
    sequence consisting of code unit value 0x0078 followed by TRV of the
    first HexDigit followed by the TRV of the second HexDigit.

-   The TRV of UnicodeEscapeSequence :: U HexDigit HexDigit
    HexDigit HexDigit is the sequence consisting of code unit value
    0x0075 followed by TRV of the first HexDigit followed by the TRV
    of the second HexDigit followed by TRV of the third HexDigit
    followed by the TRV of the fourth HexDigit.

-   The TRV of UnicodeEscapeSequence :: U{ HexDigits } is the
    sequence consisting of code unit value 0x0075 followed by code unit
    value 0x007B followed by TRV of HexDigits followed by code unit
    value 0x007D.

-   The TRV of HexDigits :: HexDigit is the TRV of HexDigit.

-   The TRV of HexDigits :: HexDigits HexDigit is the sequence
    consisting of TRV of HexDigits followed by TRV of HexDigit.

-   The TRV of a HexDigit is the CV of the SourceCharacter that is
    that HexDigit.

-   The TRV of LineContinuation :: \ LineTerminatorSequence is the
    sequence consisting of the code unit value 0x005C followed by the
    code units of TRV of LineTerminatorSequence.

-   The TRV of LineTerminatorSequence :: <LF> is the code unit value
    0x000A.

-   The TRV of LineTerminatorSequence :: <CR> [lookahead ∉ <LF> ] is
    the code unit value 0x000D.

-   The TRV of LineTerminatorSequence :: <LS> is the code unit value
    0x2028.

-   The TRV of LineTerminatorSequence :: <PS> is the code unit value
    0x2029.

-   The TRV of LineTerminatorSequence :: <CR><LF> is the sequence
    consisting of the code unit value 0x000D followed by the code unit
    value 0x000A.

NOTE TV excludes the code units of LineContinuation while TRV includes
them.

String Literals

NOTE A string literal is zero or more Unicode code points enclosed in
single or double quotes. Unicode code points may also be represented by
an escape sequence. All characters may appear literally in a string
literal except for the closing quote character, backslash, carriage
return, line separator, paragraph separator, and line feed. Any
character may appear in the form of an escape sequence. String literals
evaluate to ECAMScript String values. When generating these string
values Unicode code points are UTF-16 encoded as defined in clause 6.
Code points belonging to Basic Multilingual Plane are encoded as a
single code unit element of the string. All other code points are
encoded as two code unit elements of the string.

Syntax

StringLiteral ::

" DoubleStringCharacters~opt~ "
' SingleStringCharacters~opt~ '

DoubleStringCharacters ::

DoubleStringCharacter DoubleStringCharacters~opt~

SingleStringCharacters ::

SingleStringCharacter SingleStringCharacters~opt~

DoubleStringCharacter ::

SourceCharacter BUT NOT ONE OF " OR \ OR LineTerminator
\ EscapeSequence
LineContinuation

SingleStringCharacter ::

SourceCharacter BUT NOT ONE OF ' OR \ OR LineTerminator
\ EscapeSequence
LineContinuation

LineContinuation ::

\ LineTerminatorSequence

EscapeSequence ::

CharacterEscapeSequence
0 [lookahead ∉ DecimalDigit]
HexEscapeSequence
UnicodeEscapeSequence

A conforming implementation, when processing strict mode code (see
10.1.1), must not extend the syntax of EscapeSequence to include
LegacyOctalEscapeSequence as described in B.1.2.

CharacterEscapeSequence ::

SingleEscapeCharacter
NonEscapeCharacter

SingleEscapeCharacter :: ONE OF

' " \ B F N R T V

NonEscapeCharacter ::

SourceCharacter BUT NOT ONE OF EscapeCharacter OR LineTerminator

EscapeCharacter ::

SingleEscapeCharacter
DecimalDigit
X
U

HexEscapeSequence ::

X HexDigit HexDigit

UnicodeEscapeSequence ::

U HexDigit HexDigit HexDigit HexDigit
U{ HexDigits }

The definition of the nonterminal HexDigit is given in 7.8.3.
SourceCharacter is defined in clause 6.

NOTE A line terminator character cannot appear in a string literal,
except as part of a LineContinuation to produce the empty character
sequence. The correct way to cause a line terminator character to be
part of the String value of a string literal is to use an escape
sequence such as \N or \U000A.

STATIC SEMANTICS

STATIC SEMANTICS: EARLY ERRORS

UnicodeEscapeSequence :: U{ HexDigits }

-   It is a Syntax Error if the MV of HexDigits > 1114111.

STATIC SEMANTICS: SV’S AND CV’S

A string literal stands for a value of the String type. The String value
(SV) of the literal is described in terms of code unit values (CV)
contributed by the various parts of the string literal. As part of this
process, some Unicode characters within the string literal are
interpreted as having a mathematical value (MV), as described below or
in 7.8.3.

-   The SV of StringLiteral :: "" is the empty code unit sequence.

-   The SV of StringLiteral :: '' is the empty code unit sequence.

-   The SV of StringLiteral :: " DoubleStringCharacters " is the SV
    of DoubleStringCharacters.

-   The SV of StringLiteral :: ' SingleStringCharacters ' is the SV
    of SingleStringCharacters.

-   The SV of DoubleStringCharacters :: DoubleStringCharacter is a
    sequence of one or two code units that is the CV of
    DoubleStringCharacter.

-   The SV of DoubleStringCharacters :: DoubleStringCharacter
    DoubleStringCharacters is a sequence of one or two code units that
    is the CV of DoubleStringCharacter followed by all the code units
    in the SV of DoubleStringCharacters in order.

-   The SV of SingleStringCharacters :: SingleStringCharacter is a
    sequence of one or two code units that is the CV of
    SingleStringCharacter.

-   The SV of SingleStringCharacters :: SingleStringCharacter
    SingleStringCharacters is a sequence of one or two code units that
    is the CV of SingleStringCharacter followed by all the code units
    in the SV of SingleStringCharacters in order.

-   The SV of LineContinuation :: \ LineTerminatorSequence is the
    empty code unit sequence.

-   The CV of DoubleStringCharacter :: SourceCharacter BUT NOT ONE
    OF " OR \ OR LineTerminator is the UTF-16 Encoding (clause 6) of
    the code point value of SourceCharacter.

-   The CV of DoubleStringCharacter :: \ EscapeSequence is the CV of
    the EscapeSequence.

-   The CV of DoubleStringCharacter :: LineContinuation is the empty
    character sequence.

-   The CV of SingleStringCharacter :: SourceCharacter BUT NOT ONE
    OF ' OR \ OR LineTerminator is the UTF-16 Encoding (clause 6) of
    the code point value of SourceCharacter .

-   The CV of SingleStringCharacter :: \ EscapeSequence is the CV of
    the EscapeSequence.

-   The CV of SingleStringCharacter :: LineContinuation is the empty
    character sequence.

-   The CV of EscapeSequence :: CharacterEscapeSequence is the CV of
    the CharacterEscapeSequence.

-   The CV of EscapeSequence :: 0 [lookahead ∉ DecimalDigit] is the
    code unit value 0.

-   The CV of EscapeSequence :: HexEscapeSequence is the CV of the
    HexEscapeSequence.

-   The CV of EscapeSequence :: UnicodeEscapeSequence is the CV of
    the UnicodeEscapeSequence.

-   The CV of CharacterEscapeSequence :: SingleEscapeCharacter is
    the character whose code unit value is determined by the
    SingleEscapeCharacter according to Table 4:

Table 4 — String Single Character Escape Sequences

  ------------------- ------------------- ---------------------- ----------
  _ESCAPE SEQUENCE_   _CODE UNIT VALUE_   NAME                 SYMBOL
  \B                  0X0008              backspace              <BS>
  \T                  0X0009              horizontal tab         <HT>
  \N                  0X000A              line feed (new line)   <LF>
  \V                  0X000B              vertical tab           <VT>
  \F                  0X000C              form feed              <FF>
  \R                  0X000D              carriage return        <CR>
  \"                  0X0022              double quote           "
  \'                  0X0027              single quote           '
  \\                  0X005C              backslash              \
  ------------------- ------------------- ---------------------- ----------

-   The CV of CharacterEscapeSequence :: NonEscapeCharacter is the
    CV of the NonEscapeCharacter.

-   The CV of NonEscapeCharacter :: SourceCharacter BUT NOT ONE OF
    EscapeCharacter OR LineTerminator is the UTF-16 Encoding (clause
    6) of the code point value of SourceCharacter .

-   The CV of HexEscapeSequence :: X HexDigit HexDigit is the code
    unit value that is (16 times the MV of the first HexDigit) plus
    the MV of the second HexDigit.

-   The CV of UnicodeEscapeSequence :: U HexDigit HexDigit
    HexDigit HexDigit is the code unit value that is (4096 times the
    MV of the first HexDigit) plus (256 times the MV of the second
    HexDigit) plus (16 times the MV of the third HexDigit) plus the
    MV of the fourth HexDigit.

-   The CV of UnicodeEscapeSequence :: U{ HexDigits } is the UTF-16
    Encoding (clause 6) of the MV of HexDigits.


Automatic Semicolon Insertion

Certain ECMAScript statements (empty statement, let and const
declarations, variable statement, expression statement, DEBUGGER
statement, CONTINUE statement, BREAK statement, RETURN statement, and
THROW statement) must be terminated with semicolons. Such semicolons may
always appear explicitly in the source text. For convenience, however,
such semicolons may be omitted from the source text in certain
situations. These situations are described by saying that semicolons are
automatically inserted into the source code token stream in those
situations.

Rules of Automatic Semicolon Insertion

There are three basic rules of semicolon insertion:

1.  When, as the script is parsed from left to right, a token (called
    the _offending token_) is encountered that is not allowed by any
    production of the grammar, then a semicolon is automatically
    inserted before the offending token if one or more of the following
    conditions is true:

-   The offending token is separated from the previous token by at least
    one LineTerminator.

-   The offending token is }.

    1.  When, as the script is parsed from left to right, the end of the
        input stream of tokens is encountered and the parser is unable
        to parse the input token stream as a single complete ECMAScript
        script, then a semicolon is automatically inserted at the end
        of the input stream.

    2.  When, as the script is parsed from left to right, a token is
        encountered that is allowed by some production of the grammar,
        but the production is a _restricted production_ and the token
        would be the first token for a terminal or nonterminal
        immediately following the annotation “[no LineTerminator
        here]” within the restricted production (and therefore such a
        token is called a restricted token), and the restricted token is
        separated from the previous token by at least one
        LineTerminator, then a semicolon is automatically inserted
        before the restricted token.

However, there is an additional overriding condition on the preceding
rules: a semicolon is never inserted automatically if the semicolon
would then be parsed as an empty statement or if that semicolon would
become one of the two semicolons in the header of a FOR statement (see
12.6.3).

NOTE The following are the only restricted productions in the grammar:

PostfixExpression :

LeftHandSideExpression [no LineTerminator here] ++
LeftHandSideExpression [no LineTerminator here] --

ContinueStatement :

CONTINUE [no LineTerminator here] Identifier ;

BreakStatement :

BREAK [no LineTerminator here] Identifier ;

ReturnStatement :

RETURN [no LineTerminator here] Expression ;

ThrowStatement :

THROW [no LineTerminator here] Expression ;

The practical effect of these restricted productions is as follows:

  When a ++ or -- token is encountered where the parser would treat it
  as a postfix operator, and at least one LineTerminator occurred
  between the preceding token and the ++ or -- token, then a semicolon
  is automatically inserted before the ++ or -- token.

  When a CONTINUE, BREAK, RETURN, or THROW token is encountered and a
  LineTerminator is encountered before the next token, a semicolon is
  automatically inserted after the CONTINUE, BREAK, RETURN, or THROW
  token.

The resulting practical advice to ECMAScript programmers is:

  A postfix ++ or -- operator should appear on the same line as its
  operand.

  An Expression in a RETURN or THROW statement should start on the
  same line as the RETURN or THROW token.

  An Identifier in a BREAK or CONTINUE statement should be on the same
  line as the BREAK or CONTINUE token.

Examples of Automatic Semicolon Insertion

The source

  { 1 2 } 3

is not a valid sentence in the ECMAScript grammar, even with the
automatic semicolon insertion rules. In contrast, the source

  { 1
  2 } 3

is also not a valid ECMAScript sentence, but is transformed by automatic
semicolon insertion into the following:

  { 1
  ;2 ;} 3;

which is a valid ECMAScript sentence.

The source

  for (a; b
  )

is not a valid ECMAScript sentence and is not altered by automatic
semicolon insertion because the semicolon is needed for the header of a
FOR statement. Automatic semicolon insertion never inserts one of the
two semicolons in the header of a FOR statement.

The source

  return
  a + b

is transformed by automatic semicolon insertion into the following:

  return;
  a + b;

NOTE The expression A + B is not treated as a value to be returned by
the RETURN statement, because a LineTerminator separates it from the
token RETURN.

The source

  a = b
  ++c

is transformed by automatic semicolon insertion into the following:

  a = b;
  ++c;

NOTE The token ++ is not treated as a postfix operator applying to the
variable B, because a LineTerminator occurs between B and ++.

The source

  if (a > b)
  else c = d

is not a valid ECMAScript sentence and is not altered by automatic
semicolon insertion before the ELSE token, even though no production of
the grammar applies at that point, because an automatically inserted
semicolon would then be parsed as an empty statement.

The source

  a = b + c
  (d + e).print()

is not transformed by automatic semicolon insertion, because the
parenthesised expression that begins the second line can be interpreted
as an argument list for a function call:

a = b + c(d + e).print()

In the circumstance that an assignment statement must begin with a left
parenthesis, it is a good idea for the programmer to provide an explicit
semicolon at the end of the preceding statement rather than to rely on
automatic semicolon insertion.



TYPES


Algorithms within this specification manipulate values each of which has
an associated type. The possible value types are exactly those defined
in this clause. Types are further subclassified into ECMAScript language
types and specification types.

Within this specification, the notation “Type(x)” is used as shorthand
for “the type of x” where “type” refers to the ECMAScript language and
specification types defined in this clause.


ECMAScript Language Types

An ECMAScript language type corresponds to values that are directly
manipulated by an ECMAScript programmer using the ECMAScript language.
The ECMAScript language types are Undefined, Null, Boolean, String,
Number, and Object. An ECMAScript language value is a value that is
characterized by an ECMAScript language type.

The Undefined Type

The Undefined type has exactly one value, called UNDEFINED. Any variable
that has not been assigned a value has the value UNDEFINED.

The Null Type

The Null type has exactly one value, called NULL.

The Boolean Type

The Boolean type represents a logical entity having two values, called
TRUE and FALSE.

The String Type

The String type is the set of all finite ordered sequences of zero or
more 16-bit unsigned integer values (“elements”). The String type is
generally used to represent textual data in a running ECMAScript
program, in which case each element in the String is treated as a UTF-16
code unit value. Each element is regarded as occupying a position within
the sequence. These positions are indexed with nonnegative integers. The
first element (if any) is at index 0, the next element (if any) at index
1, and so on. The length of a String is the number of elements (i.e.,
16-bit values) within it. The empty String has length zero and therefore
contains no elements.

Where ECMAScript operations interpret String values, each element is
interpreted as a single UTF-16 code unit. However, ECMAScript does not
place any restrictions or requirements on the sequence of code units in
a String value, so they may be ill-formed when interpreted as UTF-16
code unit sequences. Operations that do not interpret String contents
treat them as sequences of undifferentiated 16-bit unsigned integers. No
operations ensure that Strings are in a normalized form. Only operations
that are explicitly specified to be language or locale sensitive produce
language-sensitive results

-   

NOTE The rationale behind this design was to keep the implementation of
Strings as simple and high-performing as possible. If ECMAScript source
code is in Normalised Form C, string literals are guaranteed to also be
normalised, as long as they do not contain any Unicode escape sequences.

Some operations interpret String contents as UTF-16 encoded Unicode code
points. In that case the interpretation is:

-   A code unit in the range 0 to 0xD7FF or in the range 0xE000 to
    0xFFFF is interpreted as a code point with the same value.

-   A sequence of two code units, where the first code unit c1 is in
    the range 0xD800 to 0xDBFF and the second code unit c2 is in the
    range 0xDC00 to 0xDFFF, is a surrogate pair and is interpreted as a
    code point with the value (c1 - 0xD800) × 0x400 + (c2 –
    0xDC00) + 0x10000.

-   A code unit that is in the range 0xD800 to 0xDFFF, but is not part
    of a surrogate pair, is interpreted as a code point with the same
    value.

The Number Type

The Number type has exactly 18437736874454810627 (that is,
2^64^−2^53^+3) values, representing the double-precision 64-bit format
IEEE 754 values as specified in the IEEE Standard for Binary
Floating-Point Arithmetic, except that the 9007199254740990 (that is,
2^53^−2) distinct “Not-a-Number” values of the IEEE Standard are
represented in ECMAScript as a single special NAN value. (Note that the
NAN value is produced by the program expression NAN.) In some
implementations, external code might be able to detect a difference
between various Not-a-Number values, but such behaviour is
implementation-dependent; to ECMAScript code, all NaN values are
indistinguishable from each other.

There are two other special values, called POSITIVE INFINITY and
NEGATIVE INFINITY. For brevity, these values are also referred to for
expository purposes by the symbols +∞ and −∞, respectively. (Note that
these two infinite Number values are produced by the program expressions
+INFINITY (or simply INFINITY) and -INFINITY.)

The other 18437736874454810624 (that is, 2^64^−2^53^) values are called
the finite numbers. Half of these are positive numbers and half are
negative numbers; for every finite positive Number value there is a
corresponding negative value having the same magnitude.

Note that there is both a POSITIVE ZERO and a NEGATIVE ZERO. For
brevity, these values are also referred to for expository purposes by
the symbols +0 and −0, respectively. (Note that these two different zero
Number values are produced by the program expressions +0 (or simply 0)
and -0.)

The 18437736874454810622 (that is, 2^64^−2^53^−2) finite nonzero values
are of two kinds:

18428729675200069632 (that is, 2^64^−2^54^) of them are normalised,
having the form

  s × m × 2^e^

where s is +1 or −1, m is a positive integer less than 2^53^ but not
less than 2^52^, and e is an integer ranging from −1074 to 971,
inclusive.

The remaining 9007199254740990 (that is, 2^53^−2) values are
denormalised, having the form

  s × m × 2^e^

where s is +1 or −1, m is a positive integer less than 2^52^, and
e is −1074.

Note that all the positive and negative integers whose magnitude is no
greater than 2^53^ are representable in the Number type (indeed, the
integer 0 has two representations, +0 and -0).

A finite number has an _odd significand_ if it is nonzero and the
integer m used to express it (in one of the two forms shown above) is
odd. Otherwise, it has an _even significand_.

In this specification, the phrase “the Number value for x” where x
represents an exact nonzero real mathematical quantity (which might even
be an irrational number such as π) means a Number value chosen in the
following manner. Consider the set of all finite values of the Number
type, with −0 removed and with two additional values added to it that
are not representable in the Number type, namely 2^1024^ (which is +1 ×
2^53^ × 2^971^) and −2^1024^ (which is −1 × 2^53^ × 2^971^). Choose the
member of this set that is closest in value to x. If two values of the
set are equally close, then the one with an even significand is chosen;
for this purpose, the two extra values 2^1024^ and −2^1024^ are
considered to have even significands. Finally, if 2^1024^ was chosen,
replace it with +∞; if −2^1024^ was chosen, replace it with −∞; if +0
was chosen, replace it with −0 if and only if x is less than zero; any
other chosen value is used unchanged. The result is the Number value for
x. (This procedure corresponds exactly to the behaviour of the IEEE
754 “round to nearest” mode.)

Some ECMAScript operators deal only with integers in the range −2^31^
through 2^31^−1, inclusive, or in the range 0 through 2^32^−1,
inclusive. These operators accept any value of the Number type but first
convert each such value to one of 2^32^ integer values. See the
descriptions of the ToInt32 and ToUint32 operators in 9.5 and 9.6,
respectively.

The Object Type

An Object is logically a collection of properties. Each property is
either a data property, or an accessor property:

-   A _data property_ associates a key value with an ECMAScript language
    value and a set of Boolean attributes.

-   A _accessor property_ associates a key value with one or two
    accessor functions, and a set of Boolean attributes. The accessor
    functions are used to store or retrieve an ECMAScript language value
    that is associated with the property.

Properties are identified using key values. A key value is either an
ECMAScript String value or an Exotic Symbol object.

-   Property keys are used to access properties and their values.

There are two kinds of access for properties: get and set,
corresponding to value retrieval and assignment, respectively. The
properties accessible via get and set access includes both _own
properties_ that are a direct part of an object and inherited
properties which are provided by another associated object via a
property inheritance relationship. Inherited properties may be either
own or inherited properties of the associated object.

All objects are logically collections of properties, but there are
multiple forms of objects that differ in their semantics for accessing
and manipulating their properties. Ordinary objects are the most
common form of objects and have the default object semantics. An _exotic
object_ is any form of object whose property semantics differ in any way
from the default semantics.

Property Attributes

Attributes are used in this specification to define and explain the
state of Object properties. A data property associates a key value with
the attributes listed in Table 5.

Table 5 — Attributes of a Data Property

  _ATTRIBUTE NAME_   _VALUE DOMAIN_                 DESCRIPTION
  ------------------ ------------------------------ ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  [[Value]]          Any ECMAScript language type   The value retrieved by a get access of the property.
  [[Writable]]       Boolean                        If FALSE, attempts by ECMAScript code to change the property’s [[Value]] attribute using [[Set]] will not succeed.
  [[Enumerable]]     Boolean                        If TRUE, the property will be enumerated by a for-in enumeration (see 12.6.4). Otherwise, the property is said to be non-enumerable.
  [[Configurable]]   Boolean                        If FALSE, attempts to delete the property, change the property to be an accessor property, or change its attributes (other than [[Value]], or changing [[Writable]] to FALSE) will fail.

An accessor property associates a key value with the attributes listed
in Table 6.

Table 6 — Attributes of an Accessor Property

  _ATTRIBUTE NAME_   _VALUE DOMAIN_          DESCRIPTION
  ------------------ ----------------------- --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  [[Get]]            Object or Undefined   If the value is an Object it must be a function Object. The function’s [[Call]] internal method (8.6.2) is called with an empty arguments list to retrieve the property value each time a get access of the property is performed.
  [[Set]]            Object or Undefined   If the value is an Object it must be a function Object. The function’s [[Call]] internal method (8.6.2) is called with an arguments list containing the assigned value as its sole argument each time a set access of the property is performed. The effect of a property's [[Set]] internal method may, but is not required to, have an effect on the value returned by subsequent calls to the property's [[Get]] internal method.
  [[Enumerable]]     Boolean                 If TRUE, the property is to be enumerated by a for-in enumeration (see 12.6.4). Otherwise, the property is said to be non-enumerable.
  [[Configurable]]   Boolean                 If FALSE, attempts to delete the property, change the property to be a data property, or change its attributes will fail.

If the initial values of a property’s attributes are not explicitly
specified by this specification, the default value defined in Table 7 is
used.

Table 7 — Default Attribute Values

  ATTRIBUTE NAME     DEFAULT VALUE
  ------------------ ---------------
  [[Value]]          UNDEFINED
  [[Get]]            UNDEFINED
  [[Set]]            UNDEFINED
  [[Writable]]       FALSE
  [[Enumerable]]     FALSE
  [[Configurable]]   FALSE

Object Internal Methods and Internal Data Properties

The actual semantics of ECMAScript objects are specified via algorithms
called _internal methods_. Each object in an ECMAScript engine is
associated with a set of internal methods that defines its runtime
behaviour. These internal methods are not part of the ECMAScript
language. They are defined by this specification purely for expository
purposes. However, each object within an implementation of ECMAScript
must behave as specified by the internal methods associated with it. The
exact manner in which this is accomplished is determined by the
implementation.

Internal methods are identified within this specification using names
enclosed in double square brackets [[ ]]. Internal method names are
polymorphic. This means that different ECMAScript object values may
perform different algorithms when a common internal method name is
invoked upon them. If, at runtime, the implementation of an algorithm
attempts to use an internal method of an object that the object does not
support, a TYPEERROR exception is thrown.

Internal data properties correspond to internal state that is associated
with objects and used by various ECMAScript specification algorithms.
Depending upon the specific internal data property such state may
consist of values of any ECMAScript language type or of specific ECMA
specification type values. Unless explicitly specified otherwise,
internal data properties are allocated as part of the process of
creating an ECMAScript object and may not be dynamically added to
ECMAScript objects. Unless specified otherwise, the initial value of an
internal data property is the value UNDEFINED.

Table 8 summarises the _essential internal_ methods used by this
specification that are applicable to all ECMAScript objects. Every
object must have algorithms for all of the essential internal methods.
However, all objects do not necessarily use the same algorithms for
those methods.

The “Signature” column of Table 8 and other similar tables describes the
invocation pattern for each internal method. The invocation pattern
always includes a parenthesised list of descriptive parameter names. If
a parameter name is the same as an ECMAScript type name then the name
describes the required type of the parameter value. If an internal
method explicitly returns a value, its parameter list is followed by the
symbol “→” and the type name of the returned value. The type names used
in signatures refer to the types defined in Clause 8 augmented by the
following additional names. “any” means the value may be any
ECMAScript language type. An internal method implicitly returns a
Completion Record as described in 8.8. In addition to its parameters, an
internal method always has access to the object upon which it is invoked
as a method.

Table 8 — Essential Internal Methods

  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  _INTERNAL METHOD_       SIGNATURE                                            DESCRIPTION
  ----------------------- ------------------------------------------------------ -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  [[GetInheritance]]      ()→Object or Null                                    Determine the object that provides inherited properties for this object. A NULL value indicates that there are no inherited properties.

  [[SetInheritance]]      (Object or Null)→Boolean                           Associate with an object another object that provides inherited properties. Passing NULL indicates that there are no inherited properties. Returns TRUE indicating that the operation was completed successfully or FALSE indicating that the operation was not successful.

  [[IsExtensible]]        ( )→Boolean                                          Determine whether it is permitted to add additional properties to an object.

  [[PreventExtensions]]   ( )→Boolean                                          Control whether new properties may be added to an object. Returns TRUE indicating that the operation was completed successfully or FALSE indicating that the operation was not successful.

  [[HasOwnProperty]]      (propertyKey) → Boolean                            Returns a Boolean value indicating whether the object already has an own property whose key is propertyKey.

  [[GetOwnProperty]]      (propertyKey) →                                      Returns a Property Descriptor for the own property of this object whose key is propertyKey, or UNDEFINED if no such property exists.
                                                                                 
                          Undefined or Property Descriptor                       

  [[HasProperty]]         (propertyKey) → Boolean                            Returns a Boolean value indicating whether the object already has either an own or inherited property whose key is propertyKey.

  [[Get]]                 (propertyKey, Receiver) _→ any_                    Retrive the value of an object’s property using the propertyKey parameter. If any ECMAScript code must be executed to retrieve the property value, Receiver is used as the THIS value when evaluating the code.

  [[Set]]                 (propertyKey_,_value, Receiver) _→ Boolean_        Try to set the value of an object’s property indentified by propertyKey to value. If any ECMAScript code must be executed to set the property value, Receiver is used as the THIS value when evaluating the code. Returns TRUE indicating that the property value was set or FALSE indicating that it could not be set.

  [[Invoke]]              (propertyKey, a List of any, Receiver) _→ any_   Retrieve the value of an object’s property using the propertyKey parameter. If the retrieved property value is a function, [[Call]] it using the List as the arguments list and Receiver as the THIS value. A TYPEERROR is thrown if a function is not retrieved.

  [[Delete]]              (propertyKey) → Boolean                            Removes the own property indentified by the propertyKey parameter from the object. Return FALSE if the property was not deleted and is still present. Return TRUE if the property was deleted or was not present.

  [[DefineOwnProperty]]   (_propertyKey, PropertyDescriptor_) → Boolean        Creates or alters the named own property to have the state described by a Property Descriptor. Returns TRUE indicating that the property was successfully created/updated or FALSE indicating that the property could not be created or updated.

  [[Enumerate]]           ()→Object                                            Returns an iterator object over the string values of the keys of the enumerable properties of the object.

                                                                                 

  [[OwnPropertyKeys]]     ()→Object                                            Returns an Iterator object that produces all of the own property keys for the object.

                                                                                 

                                                                                 

                                                                                 

                                                                                 
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Table 9 summarises additional essential internal methods that are
supported by objects that may be called as functions.

Table 9 — Additional Essential Internal Methods of Function Objects

  _INTERNAL METHOD_   SIGNATURE                          DESCRIPTION
  ------------------- ------------------------------------ ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  [[Call]]            (any, a List of any) → any   Executes code associated with the object. Invoked via a function call expression. The arguments to the internal method are a THIS value and a list containing the arguments passed to the function by a call expression. Objects that implement this internal method are callable.
  [[Construct]]       (a List of any) → Object         Creates an object. Invoked via the NEW operator. The arguments to the internal method are the arguments passed to the NEW operator. Objects that implement this internal method are called constructors. A Function object is not necessarily a constructor and such non-constructor Function objects do not have a [[Construct]] internal method.

Invariants of the Essential Internal Methods

Current this section is just a bunch of material merged together from
the ES5 spec. and from the wiki Proxy pages. It need to be completely
reworked.

The intent is that it lists all invariants of the Essential Internal
Methods. This includes both invariants that are enforced for Proxy
objects and other invariants that may not be enfored.

Definitions:

-   The target of an internal method is the object the internal method
    is called upon.

-   A _sealed property_ is a non-configurable own property of a target.

-   A _frozen property_ is a non-configurable non-writable own property
    of a target.

-   A new property is a property that does not exist on a non-extensible
    target.

-   Two property descriptors desc1 and desc2 for a property key
    value are incompatible if:

    1.  Descl is produced by calling [[GetOwnPropertyDescriptor]] of
        target with key, and

    2.  Calling [[DefineOwnProperty]] of target with arguments key
        and desc2 would throw a TypeError exception.

Exotic objects may define additional constraints upon their [[Set]]
internal method behaviour. If possible, exotic objects should not allow
[[Set]] operations in situations where this definition of [[CanPut]]
returns FALSE.

[[GetInheritance]]

Every [[Prototype]] chain must have finite length (that is, starting
from any object, recursively accessing the [[Prototype]] internal data
property must eventually lead to a NULL value).

getOwnPropertyDescriptor

Non-configurability invariant: cannot return incompatible descriptors
for sealed properties 

Non-extensibility invariant: must return UNDEFINED for new properties

Invariant checks:

if trap returns UNDEFINED, check if the property is configurable

 if property exists on target, check if the returned descriptor is
compatible

if returned descriptor is non-configurable, check if the property exists
on the target and is also non-configurable

defineProperty

Non-configurability invariant: cannot succeed (return true) for
incompatible changes to sealed properties 

Non-extensibility invariant: must reject (return FALSE) for new
properties

Invariant checks:

on success, if property exists on target, check if existing descriptor
is compatible with argument descriptor

on success, if argument descriptor is non-configurable, check if the
property exists on the target and is also non-configurable

getOwnPropertyNames

_Non-configurability invariant: must report all sealed properties_

Non-extensibility invariant: must not list new property names 

Invariant checks:

check whether all sealed target properties are present in the trap
result

If the target is non-extensible, check that no new properties are listed
in the trap result

deleteProperty

Non-configurability invariant: cannot succeed (return true) for sealed
properties

Invariant checks:

on success, check if the target property is configurable

getPrototypeOf

Invariant check: check whether the target’s prototype and the trap
result are identical (according to the egal operator)

freeze | seal | preventExtensions

Invariant checks:

on success, check if isFrozen(target), isSealed(target) or
!isExtensible(target)

isFrozen | isSealed | isExtensible

Invariant check: check whether the boolean trap result is equal to
isFrozen(target), isSealed(target) or isExtensible(target)

hasOwn

Non-configurability invariant: cannot return FALSE for sealed properties

Non-extensibility invariant: must return FALSE for new properties 

Invariant checks:

if FALSE is returned, check if the target property is configurable

if FALSE is returned, the property does not exist on target, and the
target is non-extensible, throw a TypeError

has

Non-configurability invariant: cannot return FALSE for sealed properties

Invariant checks:

if FALSE is returned, check if the target property is configurable

get

Non-configurability invariant: cannot return inconsistent values for
frozen data properties, and must return UNDEFINED for sealed accessors
with an UNDEFINED getter 

Invariant checks:

if property exists on target as a data property, check whether the
target property’s value and the trap result are identical (according to
the egal operator)

if property exists on target as an accessor, and the accessor’s get
attribute is UNDEFINED, check whether the trap result is also UNDEFINED.

set

Non-configurability invariant: cannot succeed (return true) for frozen
data properties or sealed accessors with an UNDEFINED setter 

Invariant checks:

on success, if property exists on target as a data property, check
whether the target property’s value and the update value are identical
(according to the egal operator)

on success, if property exists on target as an accessor, check whether
the accessor’s set attribute is not UNDEFINED

keys

Non-configurability invariant: must report all enumerable sealed
properties

Non-extensibility invariant: must not list new property names

Invariant checks:

Check whether all enumerable sealed target properties are listed in the
trap result

If the target is non-extensible, check that no new properties are listed
in the trap result

enumerate

Non-configurability invariant: must report all enumerable sealed
properties

Invariant checks:

Check whether all enumerable sealed target properties are listed in the
trap result

  -- -- --
        
        
        
        
        
        
        
        
        
        
        
        
        
        
  -- -- --

~~NOTE This specification defines no ECMAScript language operators or
built-in functions that permit a program to modify an object’s~~
~~[[Prototype]] internal properties or to change the value of
[[Extensible]] from FALSE to TRUE. Implementation specific extensions
that modify~~ ~~[[Prototype]] or [[Extensible]] must not violate the
invariants defined in the preceding paragraph.~~

Unless otherwise specified, the standard ECMAScript objects are ordinary
objects and behave as described in 8.3. Some standard objects are exotic
objects and have behaviour defined in 8.4.

Exotic objects may implement internal methods in any manner unless
specified otherwise; for example, one possibility is that [[Get]] and
[[Set]] for a particular exotic object indeed fetch and store property
values but [[HasOwnProperty]] always generates FALSE. However, if any
specified manipulation of an exotic object's internal properties is not
supported by an implementation, that manipulation must throw a TYPEERROR
exception when attempted.

The [[GetOwnProperty]] internal method of all objects must conform to
the following invariants for each property of the object:

-   If a property is described as a data property and it may return
    different values over time, then either or both of the [[Writable]]
    and [[Configurable]] attributes must be TRUE even if no mechanism to
    change the value is exposed via the other internal methods.

-   If a property is described as a data property and its [[Writable]]
    and [[Configurable]] are both FALSE, then the SameValue (according
    to 9.12) must be returned for the [[Value]] attribute of the
    property on all calls to [[GetOwnProperty]].

-   If the attributes other than [[Writable]] may change over time or if
    the property might disappear, then the [[Configurable]] attribute
    must be TRUE.

-   If the [[Writable]] attribute may change from FALSE to TRUE, then
    the [[Configurable]] attribute must be TRUE.

-   If the result of calling an object’s [[IsExtensible]] internal
    method has been observed by ECMAScript code to be FALSE, then if a
    call to [[GetOwnProperty]] describes a property as non-existent all
    subsequent calls must also describe that property as non-existent.

The [[DefineOwnProperty]] internal method of all objects must not permit
the addition of a new property to an object if the [[Extensible]]
internal method of that object has been observed by ECMAScript code to
be FALSE.

If the result of calling the [[IsExtensible]] internal method of an
object has been observed by ECMAScript code to be FALSE then it must not
subsequently become TRUE.

Well-Known Symbols and Intrinsics

Well-known symbols are built-in Symbol exotic objects (‎8.4.4) that are
explicitly referenced by algorithms of this specification. They are
typically used as the keys of properties whose values serve as extension
points of a specification algorithm. Unless otherwise specified,
well-known symbols objects are shared by all Code Realms (10.3).

Within this specification a well-known symbol is referred to by using a
notation of the form @@name, where “name” is one of the values listed in
Table 10.

Table 10--Well-known Symbols

  ------------------------ ------------------------------------------------------------------------------------------------------------------------------------------------------------------
  SPECIFICATION NAME   _VALUE AND PURPOSE_
  @@create                 A method used to allocate an object. Called from the [[Construct]] internal method.
  @@hasInstance            A method that determines if a constructor object recognises an object as one of the constructor’s instances. Called by the semantics of the INSTANCEOF operator.
  @@isRegExp               A Boolean value that if true indicates that an object may be used as a regular expression.
  @@iterator               A method that returns the default iterator for an object. Called by the semantics of the for-of statement.
  @@ToPrimitive            A method that converts an object to a corresponding primitive value. Called by the ToPrimitive abstract operation.
  @@toStringTag            A string value that is used in the creation of the default string description of an object. Called by the built-in method Object.prototype.toString.
  @@unscopables            An Array of strings values that are property names that are excluded from the with environment bindings of the associated objects.
  ------------------------ ------------------------------------------------------------------------------------------------------------------------------------------------------------------

Well-known intrinsics are built-in objects that are explicitly
referenced by the algorithms of this specification and which usually
have Realm specific identities. Unless otherwise specified each
intrinsic object actually corresponds to a set of similar objects, one
per Realm.

Within this specification a reference such as %name% means the intrinsic
object, associated with the current Realm, corresponding to the name.
Determination of the current Realm and its intrinsics is described in
10.4. The well-known intrinsics are listed in Table 11.

Table 11 — Well-known Intrinsic Objects

  --------------------------- ------------------------------------------------------------------------------------------------------
  _INTRINSIC NAME_            _ECMASCRIPT LANGUAGE ASSOCIATION_

  %Object%                    The initial value of the global object property named "OBJECT".

  %ObjectPrototype%           The initial value of the "PROTOTYPE" data property of the intrinsic %Object%.

  %ObjProto_toString%         The initial value of the "TOSTRING" data property of the intrinsic %ObjectPrototype%.

  %Function%                  The initial value of the global object property named "FUNCTION".

  %FunctionPrototype%         The initial value of the "PROTOTYPE" data property of the intrinsic %Function%.

  %Array%                     The initial value of the global object property named "ARRAY".

  %ArrayPrototype%            The initial value of the "PROTOTYPE" data property of the intrinsic %Array%.

  %ArrayIteratorPrototype%    The prototype object used for
                              Iterator objects created by the CreateArrayIterator abstract operation.

  %String%                    The initial value of the global object property named "String".

  %StringPrototype%           The initial value of the "PROTOTYPE" data property of the intrinsic %String%.

  %Boolean%                   The initial value of the global object property named "BOOLEAN".

  %BooleanPrototype%          The initial value of the "PROTOTYPE" data property of the intrinsic %Boolean%.

  %Number%                    The initial value of the global object property named "NUMBER".

  %NumberPrototype%           The initial value of the "PROTOTYPE" data property of the intrinsic %Number%.

  %Date%                      The initial value of the global object property named "DATE".

  %DatePrototype%             The initial value of the "PROTOTYPE" data property of the intrinsic %Date%.

  %RegExp%                    The initial value of the global object property named "REGEXP".

  %RegExpPrototype%           The initial value of the "PROTOTYPE" data property of the intrinsic %RegExp%.

  %Map%                       The initial value of the global object property named "MAP".

  %MapPrototype%              The initial value of the "PROTOTYPE" data property of the intrinsic %Map%.

  %MapIteratorPrototype%      The prototype object used for
                              Iterator objects created by the CreateMapIterator abstract operation

  %WeakMap%                   The initial value of the global object property named "WEAKMAP".

  %WeakMapPrototype%          The initial value of the "PROTOTYPE" data property of the intrinsic %WeakMap%.

  %Set%                       The initial value of the global object property named "SET".

  %SetPrototype%              The initial value of the "PROTOTYPE" data property of the intrinsic %Set%.

  %WeakSet%                   The initial value of the global object property named "WEAKSET".

  %WeakSetPrototype%          The initial value of the "PROTOTYPE" data property of the intrinsic %WeakWeakSet%.

  %SetIteratorPrototype%      The prototype object used for
                              Iterator objects created by the CreateSetIterator abstract operation

                              

  %GeneratorFunction%         The initial value of the name "GeneratorFunction" exported from the built-in module "std:iteration".

  %Generator%                 The initial value of the name "Generator" exported from the built-in module "std:iteration"

  %GeneratorPrototype%        The initial value of the PROTOTYPE property of the %Generator% intrinsic

  %Error%                     

  %EvalError%                 

  %RangeError%                

  %ReferenceError%            

  %SyntaxError%               

  %TypeError%                 

  %URIError%                  

                              

  %ErrorPrototype%            

  %EvalErrorPrototype%        

  %RangeErrorPrototype%       

  %ReferenceErrorPrototype%   

  %SyntaxErrorPrototype%      

  %TypeErrorPrototype%        

  %URIErrorPrototype%         

  %ArrayBuffer%               

  %ArrayBufferPrototype%      The initial value of the "PROTOTYPE" data property of the intrinsic %ArrayBuffer%.

  %TypedArray%                

  %TypedArrayPrototype%       The initial value of the "PROTOTYPE" data property of the intrinsic %TypedArray%.

  %Int8Array%                 

  %Int8ArrayPrototype%        

  %DataView%                  

  %DataViewPrototype%         

  %ThrowTypeError%            A function object that unconditionally throws a new instance of %TypeError%.

  ???                         
  --------------------------- ------------------------------------------------------------------------------------------------------


 ECMAScript Specification Types

A specification type corresponds to meta-values that are used within
algorithms to describe the semantics of ECMAScript language constructs
and ECMAScript language types. The specification types are Reference,
List, Completion, Property Descriptor, Lexical Environment, Environment
Record, and Data Block. Specification type values are specification
artefacts that do not necessarily correspond to any specific entity
within an ECMAScript implementation. Specification type values may be
used to describe intermediate results of ECMAScript expression
evaluation but such values cannot be stored as properties of objects or
values of ECMAScript language variables.

Data Blocks

_THIS SECTION IS A PLACEHOLDER FOR DESCRIBING THE DATA BLOCK INTERNAL
TYPE. THE FOLLOWING MATERIAL IS VERBATIUM FROM THE BINARY DATA ES WIKI
PROPOSAL. THE MATERIAL HAS NOT YET BEEN REVIEWED OR INTEGRATED WITH THE
REST OF THIS SPEC._

This spec introduces a new, spec-internal block datatype, intuitively
representing a contiguously allocated block of binary data. Blocks are
not ECMAScript language values and appear only in the program store (aka
heap).

A block is one of:

-   a number-block

-   an array-block[t, n]

-   a struct-block[t1, ..., tn]

A number-block is one of:

-   an unsigned-integer; i.e., one of uint8, uint16, uint32, or uint64

-   a signed-integer; i.e., one of int8, int16, int32, or int64

-   a floating-point; i.e., one of float32 or float64

A uintk is an integer in the range [0, 2k). An intk is an integer in the
range [-2k-1, 2k-1). A floatk is a floating-point number representable
as a k-bit IEE754 value.

An array-block[t, n] is an ordered sequence of n blocks of homogeneous
block type t. Each element of the array is stored at in independently
addressable location in the program store, and multiple Data objects may
contain references to the element.

A struct-block[t1, ..., tn] is an ordered sequence of n blocks of
heterogeneous types t1 to tn, respectively. Each field of the struct is
stored at in independently addressable location in the program store,
and multiple Data objects may contain references to the field.

The spec also introduces a datatype of Data objects, which are
ECMAScript objects that encapsulate references to block data in the
program store. Every Data object has the following properties:

[[Class]] = “Data”

[[Value]] : reference[block] – a reference to a block in the program
store

[[DataType]] : reference[Type] – a reference to a Type object describing
this object’s data block

The List and Record Specification Type

The List type is used to explain the evaluation of argument lists (see
11.2.4) in NEW expressions, in function calls, and in other algorithms
where a simple list of values is needed. Values of the List type are
simply ordered sequences of values. These sequences may be of any
length.

The Record type is used to describe data aggregations within the
algorithms of this specification. A Record type value consists of one or
more named fields. The value of each field is either an ECMAScript value
or an abstract value represented by a name associated with the Record
type. Field names are always enclosed in double brackets, for example
[[value]]

For notational convenience within this specification, an object
literal-like syntax can be used to express a Record value. For example,
{[[field1]]: 42, [[field2]]: FALSE, [[field3]]: EMPTY} defines a Record
value that has three fields each of which is initialised to a specific
value. Field name order is not significant. Any fields that are not
explicitly listed are considered to be absent.

In specification text and algorithms, dot notation may be used to refer
to a specific field of a Record value. For example, if R is the record
shown in the previous paragraph then R.[[field2]] is shorthand for “the
field of R named [[field2]]”.

Schema for commonly used Record field combinations may be named, and
that name may be used as a prefix to a literal Record value to identify
the specific kind of aggregations that is being described. For example:
Property Descriptor {[[Value]]: 42, [[Writable]]: FALSE,
[[Configurable]]: TRUE}.

The Completion Record Specification Type

The Completion type is a Record used to explain the runtime propagation
of values and control flow such as the behaviour of statements (BREAK,
CONTINUE, RETURN and THROW) that perform nonlocal transfers of control.

Values of the Completion type are Record values whole fields are defined
as by Table 12.

Table 12 — Completion Record Fields

  -------------- -------------------------------------------------- --------------------------------------------------
  _FIELD NAME_   VALUE                                            MEANING
  [[type]]       One of NORMAL, BREAK, CONTINUE, RETURN, or THROW   The type of completion that occurred.
  [[value]]      any ECMAScript language value or EMPTY             The value that was produced.
  [[target]]     any ECMAScript identifier or EMPTY                 The target label for directed control transfers.
  -------------- -------------------------------------------------- --------------------------------------------------

The term “abrupt completion” refers to any completion with a [[type]]
value other than NORMAL.

NormalCompletion

The abstract operation NormalCompletion with a single argument, such
as:

1.  Return NormalCompletion(argument).

Is a short hand that is defined as follows:

1.  Return Completion {[[type]]: normal, [[value]]: argument,
    [[target]]:empty}.

Implicit Completion Values

The algorithms of this specification often implicitly return Completion
Records whose [[type]] is NORMAL. Unless it is otherwise obvious from
the context, an algorithm statement that returns a value that is not a
Completion Record, such as:

Generally means the same thing as:

1.  Return NormalCompletion("INFINITY").

A “return” statement without a value in an algorithm step means the same
thing as:

1.  Return NormalCompletion(UNDEFINED).

Similarly, any reference to a Completion Record value that is in a
context that does not explicitly require a complete Completion Record
value is equivalent to an explicit reference to the [[value]] field of
the Completion Record value unless the Completion Record is an abrupt
completion.

1.  2.  3.  

1.  

1.  

Throw an Exception

Algorithms steps that say to throw an exception, such as

1.  Throw a TYPEERROR exception.

Mean the same things as:

1.  Return Completion {[[type]]: throw, [[value]]: a newly created
    TYPEERROR object, [[target]]:empty}.

ReturnIfAbrupt

Algorithms steps that say

1.  ReturnIfAbrupt(argument).

mean the same things as:

1.  If argument is an abrupt completion, then return argument.

2.  Else if argument is a Completion Record, then let argument be
    argument.[[value]].

The Reference Specification Type

NOTE The Reference type is used to explain the behaviour of such
operators as DELETE, TYPEOF, the assignment operators, the SUPER keyword
and other language features. For example, the left-hand operand of an
assignment is expected to produce a reference.

A REFERENCE is a resolved name or property binding. A Reference consists
of three components, the base value, the _referenced name_ and the
Boolean valued _strict reference_ flag. The base value is either
UNDEFINED, an Object, a Boolean, a String, a Number, or an environment
record (10.2.1). A base value of UNDEFINED indicates that the
Reference could not be resolved to a binding. The _referenced name_ is a
String or Symbol.

A Super Reference is a Reference that is used to represents a name
binding that was expressed using the super keyword. A Super Reference
has an additional thisValue component and its base value will never
be an environment record.

The following abstract operations are used in this specification to
access the components of references:

-   GetBase(V). Returns the base value component of the reference V.

-   GetReferencedName(V). Returns the _referenced name_ component of the
    reference V.

-   -   IsStrictReference(V). Returns the _strict reference_ flag
    component of the reference V.

-   HasPrimitiveBase(V). Returns TRUE if the base value is a Boolean,
    String, or Number.

-   IsPropertyReference(V). Returns TRUE if either the base value is
    an object or HasPrimitiveBase(V) is TRUE; otherwise returns FALSE.

-   IsUnresolvableReference(V). Returns TRUE if the base value is
    UNDEFINED and FALSE otherwise.

-   IsSuperReference(V). Returns TRUE if this reference has a
    thisValue component.

The following abstract operations are used in this specification to
operate on references:

GetValue (V)

NOTE The object that may be created in step 5.a.ii is not accessible
outside of the above abstract operation and the ordinary object [[Get]]
internal method. An implementation might choose to avoid the actual
creation of the object.

PutValue (V, W)

1.  ReturnIfAbrupt(V).

2.  ReturnIfAbrupt(W).

3.  4.  5.  If Type(V) is not Reference, throw a REFERENCEERROR
    exception.

6.  Let base be the result of calling GetBase(V).

7.  If IsUnresolvableReference(V), then

    a.  If IsStrictReference(V) is TRUE, then

        i.  Throw REFERENCEERROR exception.

    b.  Let globalObj be the result of the abstract operation
        GetGlobalObject.

    c.  Return the result of calling
        Put(globalObj_,GetReferencedName(_V), W, FALSE).

8.  Else if IsPropertyReference(V), then

    a.  If HasPrimitiveBase(V) is TRUE, then

        i.  Assert: In this case, base will never be NULL or
            UNDEFINED.

        ii. Set base to ToObject(base).

    b.  c.  Let succeeded be the

    d.  result of calling the [[Set]] internal method of base passing
        GetReferencedName(V), W, and GetThisValue(V) as arguments.

    e.  ReturnIfAbrupt(succeeded).

    f.  If succeeded is FALSE and IsStrictReference(V) is TRUE, then
        throw a TYPEERROR exception.

    g.  Return.

9.  Else base must be a reference whose base is an environment record.
    So,

    a.  Return the result of calling the SetMutableBinding (10.2.1)
        concrete method of base, passing GetReferencedName(V), W,
        and IsStrictReference(V) as arguments.

10. Return.

NOTE The object that may be created in step 6.a.ii is not accessible
outside of the above algorithm and the ordinary object [[Set]] internal
method. An implementation might choose to avoid the actual creation of
that object.

GetThisValue (V)

1.  ReturnIfAbrupt(V).

2.  If Type(V) is not Reference, return V.

3.  If IsUnresolvableReference(V), throw a REFERENCEERROR exception.

4.  If IsSuperReference(V), then

    a.  Return the value of the thisValue component of the reference
        V.

5.  Return GetBase(V).


The Property Descriptor Specification Type

The Property Descriptor type is used to explain the manipulation and
reification of Object property attributes. Values of the Property
Descriptor type are Records composed of named fields where each field’s
name is an attribute name and its value is a corresponding attribute
value as specified in 8.1.6.1. In addition, any field may be present or
absent.

Property Descriptor values may be further classified as data property
descriptors and accessor property descriptors based upon the existence
or use of certain fields. A data property descriptor is one that
includes any fields named either [[Value]] or [[Writable]]. An accessor
property descriptor is one that includes any fields named either [[Get]]
or [[Set]]. Any property descriptor may have fields named [[Enumerable]]
and [[Configurable]]. A Property Descriptor value may not be both a data
property descriptor and an accessor property descriptor; however, it may
be neither. A generic property descriptor is a Property Descriptor value
that is neither a data property descriptor nor an accessor property
descriptor. A fully populated property descriptor is one that is either
an accessor property descriptor or a data property descriptor and that
has all of the fields that correspond to the property attributes defined
in either 8.1.6.1 Table 5 or Table 6.

A Property Descriptor may be derived from an ECMAScript object that has
properties that directly correspond to the fields of a Property
Descriptor. Such a derived Property Descriptor has an additional field
named [[Origin]] whose value is the object from which the Property
Descriptor was derived.

The following abstract operations are used in this specification to
operate upon Property Descriptor values:

IsAccessorDescriptor ( Desc )

When the abstract operation IsAccessorDescriptor is called with property
descriptor Desc, the following steps are taken:

1.  If Desc is UNDEFINED, then return FALSE.

2.  If both Desc.[[Get]] and Desc.[[Set]] are absent, then return
    FALSE.

3.  Return TRUE.

IsDataDescriptor ( Desc )

When the abstract operation IsDataDescriptor is called with property
descriptor Desc, the following steps are taken:

IsGenericDescriptor ( Desc )

When the abstract operation IsGenericDescriptor is called with property
descriptor Desc, the following steps are taken:

FromPropertyDescriptor ( Desc )

When the abstract operation FromPropertyDescriptor is called with
property descriptor Desc, the following steps are taken:

The following algorithm assumes that Desc is a fully populated
Property Descriptor, such as that returned from [[GetOwnProperty]] (see
8.12.1).

ToPropertyDescriptor ( Obj )

When the abstract operation ToPropertyDescriptor is called with object
Obj, the following steps are taken:

CompletePropertyDescriptor ( Desc, LikeDesc )

When the abstract operation CompletePropertyDescriptor is called with
Property Descriptor Desc, the following steps are taken:

1.  Assert: LikeDesc is either a Property Descriptor or UNDEFINED.

2.  ReturnIfAbrupt(Desc).

3.  Assert: Desc is a Property Descriptor

4.  If LikeDesc is UNDEFINED, then set LikeDesc to Record{[[Value]]:
    UNDEFINED, [[Writable]]: FALSE, [[Get]]: UNDEFINED, [[Set]]:
    UNDEFINED, [[Enumerable]]: FALSE, [[Configurable]]: FALSE}.

5.  If either IsGenericDescriptor(Desc) or IsDataDescriptor(Desc) is
    TRUE, then

    a.  If Desc does not have a [[Value]] field, then set
        Desc.[[Value]] to LikeDesc.[[Value]].

    b.  If Desc does not have a [[Writable]] field, then set
        Desc.[[Writable]] to LikeDesc.[[Writable]].

6.  Else,

    a.  If Desc does not have a [[Get]] field, then set Desc.[[Get]]
        to LikeDesc.[[Get]].

    b.  If Desc does not have a [[Set]] field, then set Desc.[[Set]]
        to LikeDesc.[[Set]].

7.  If Desc does not have a [[Enumerable]] field, then set
    Desc.[[Enumerable]] to LikeDesc.[[Enumerable]].

8.  If Desc does not have a [[Configurable]] field, then set
    Desc.[[Configurable]] to LikeDesc.[[Configurable]].

9.  Return Desc.

The Lexical Environment and Environment Record Specification Types

The Lexical Environment and Environment Record types are used to explain
the behaviour of name resolution in nested functions and blocks. These
types and the operations upon them are defined in Clause 10.


Ordinary Object Internal Methods and Internal Data Properties


Sections 8.3-8.5 will eventually be subsectons of a new toplevel section
that follow the current section 10

All ordinary objects have an internal data property called
[[Prototype]]. The value of this property is either NULL or an object
and is used for implementing inheritance. Data properties of the
[[Prototype]] object are inherited (are visible as properties of the
child object) for the purposes of get access, but not for set access.
Accessor properties are inherited for both get access and set access.

Every ordinary ECMAScript object has a Boolean-valued [[Extensible]]
internal data property that controls whether or not properties may be
added to the object. If the value of the [[Extensible]] internal data
property is FALSE then additional properties may not be added to the
object. In addition, if [[Extensible]] is FALSE the value of
[[Prototype]] internal data properties of the object may not be
modified. Once the value of an object’s [[Extensible]] internal data
property has been set to FALSE it may not be subsequently changed to
TRUE.

In the following algorithm descriptions, assume O is an ordinary
ECMAScript object, P is a property key value, V is any ECMAScript
language value, and Desc is a Property Description record.

[[GetInheritance]] ( )

When the [[GetInheritance]] internal method of O is called the
following steps are taken:

1.  Return the value of the [[Prototype]] internal data property of O.

[[SetInheritance]] (V)

When the [[SetInheritance]] internal method of O is called with
argument V the following steps are taken:

1.  Assert: Either Type(V) is Object or Type(V) is Null.

2.  Let extensible be the value of the [[Extensible]] internal data
    property of O.

3.  Let current be the value of the [[Prototype]] internal data
    property of O.

4.  If SameValue(V, current), then return TRUE.

5.  If extensible is FALSE, then return FALSE.

6.  If V is not NULL, then

    a.  Let p be V.

    b.  Repeat, while p is not NULL

        i.  If SameValue(p, O) is TRUE, then return FALSE.

        ii. Let nextp be the result of calling the [[GetInheritance]]
            internal method of p with no arguments.

        iii. ReturnIfAbrupt(nextp).

        iv. Let p be nextp.

7.  Set the value of the [[Prototype]] internal data property of O to
    V.

8.  Return TRUE.

[[IsExtensible]] ( )

When the [[IsExtensible]] internal method of O is called the following
steps are taken:

1.  a.  

2.  Return the value of the [[Extensible]] internal data property of
    O.

3.  

[[PreventExtensions]] ( )

When the [[PreventExtensions]] internal method of O is called the
following steps are taken:

1.  2.  Set the value of the [[Extensible]] internal data property of
    O to FALSE.

3.  Return TRUE.

 [[HasOwnProperty]] (P)

When the [[HasOwnProperty]] internal method of O is called with
property key P, the following steps are taken:

1.  Assert: IsPropertyKey(P) is TRUE.

2.  If O does not have an own property with key P, return FALSE

3.  Return TRUE.

 [[GetOwnProperty]] (P)

When the [[GetOwnProperty]] internal method of O is called with
property key P, the following steps are taken:

OrdinaryGetOwnProperty (O, P)

When the abstract operation OrdinaryGetOwnProperty is called with Object
O and with property key P, the following steps are taken:

1.  Assert: IsPropertyKey(P) is TRUE.

2.  3.  If O does not have an own property with key P, return
    UNDEFINED.

4.  Let D be a newly created Property Descriptor with no fields.

5.  Let X be O’s own property whose key is P.

6.  If X is a data property, then

    a.  Set D.[[Value]] to the value of X’s [[Value]] attribute.

    b.  Set D.[[Writable]] to the value of X’s [[Writable]]
        attribute

7.  Else X is an accessor property, so

    a.  Set D.[[Get]] to the value of X’s [[Get]] attribute.

    b.  Set D.[[Set]] to the value of X’s [[Set]] attribute.

8.  Set D.[[Enumerable]] to the value of X’s [[Enumerable]]
    attribute.

9.  Set D.[[Configurable]] to the value of X’s [[Configurable]]
    attribute.

10. Return D.

[[DefineOwnProperty]] (P, Desc)

When the [[DefineOwnProperty]] internal method of O is called with
property key P and property descriptor Desc, the following steps are
taken:

1.  Return the result of OrdinaryDefineOwnProperty with arguments O,
    P, and Desc.

OrdinaryDefineOwnProperty (O, P, Desc)

When the abstract operation OrdinaryDefineOwnProperty is called with
Object O, property key P, and property descriptor Desc the
following steps are taken:

1.  Let current be the result of calling OrdinaryGetOwnProperty with
    arguments O and P.

2.  Let extensible be the value of the [[Extensible]] internal data
    property of O.

3.  Return the result of ValidateAndApplyPropertyDescriptor with
    arguments O, P, extensible, Desc, and current.

IsCompatiblePropertyDescriptor (Extensible, Desc, Current)

When the abstract operation IsCompatiblePropertyDescriptor is called
with Boolean value Extensible, and property descriptors Desc, and
Current the following steps are taken:

1.  Return the result of ValidateAndApplyPropertyDescriptor with
    arguments UNDEFINED, UNDEFINED, Extensible, Desc, and Current.

ValidateAndApplyPropertyDescriptor (O, P, extensible, Desc, current)

When the abstract operation ValidateAndApplyPropertyDescriptor is called
with Object O, property key P, Boolean value extensible, and
property descriptors Desc, and current the following steps are
taken:

This algorithm contains steps that test various fields of the Property
Descriptor Desc for specific values. The fields that are tested in
this manner need not actually exist in Desc. If a field is absent then
its value is considered to be FALSE.

NOTE If UNDEFINED is passed as the O argument only validation is
performed and no object updates are preformed.

1.  Assert: If O is not UNDEFINED then P is a valid property key.

2.  If current is UNDEFINED, then

    a.  If extensible is FALSE, then return FALSE.

    b.  Assert: extensible is TRUE.

    c.  If IsGenericDescriptor(Desc) or IsDataDescriptor(Desc) is
        TRUE, then

        i.  If O is not UNDEFINED, then create an own data property
            named P of object O whose [[Value]], [[Writable]],
            [[Enumerable]] and [[Configurable]] attribute values are
            described by Desc. If the value of an attribute field of
            Desc is absent, the attribute of the newly created
            property is set to its default value.

    d.  Else Desc must be an accessor Property Descriptor,

        i.  If O is not UNDEFINED, then create an own accessor
            property named P of object O whose [[Get]], [[Set]],
            [[Enumerable]] and [[Configurable]] attribute values are
            described by Desc. If the value of an attribute field of
            Desc is absent, the attribute of the newly created
            property is set to its default value.

    e.  Return TRUE.

3.  Return TRUE, if every field in Desc is absent.

4.  Return TRUE, if every field in Desc also occurs in current and
    the value of every field in Desc is the same value as the
    corresponding field in current when compared using the SameValue
    algorithm (9.12).

5.  If the [[Configurable]] field of current is FALSE then

    a.  Return FALSE, if the [[Configurable]] field of Desc is TRUE.

    b.  Return FALSE, if the [[Enumerable]] field of Desc is present
        and the [[Enumerable]] fields of current and Desc are the
        Boolean negation of each other.

6.  If IsGenericDescriptor(Desc) is TRUE, then no further validation
    is required.

7.  Else if IsDataDescriptor(current) and IsDataDescriptor(Desc)
    have different results, then

    a.  Return FALSE, if the [[Configurable]] field of current is
        FALSE.

    b.  If IsDataDescriptor(current) is TRUE, then

        i.  If O is not UNDEFINED, then convert the property named P
            of object O from a data property to an accessor property.
            Preserve the existing values of the converted property’s
            [[Configurable]] and [[Enumerable]] attributes and set the
            rest of the property’s attributes to their default values.

    c.  Else,

        i.  If O is not UNDEFINED, then convert the property named P
            of object O from an accessor property to a data property.
            Preserve the existing values of the converted property’s
            [[Configurable]] and [[Enumerable]] attributes and set the
            rest of the property’s attributes to their default values.

8.  Else if IsDataDescriptor(current) and IsDataDescriptor(Desc) are
    both TRUE, then

    a.  If the [[Configurable]] field of current is FALSE, then

        i.  Return FALSE, if the [[Writable]] field of current is
            FALSE and the [[Writable]] field of Desc is TRUE.

        ii. If the [[Writable]] field of current is FALSE, then

            1.  Return FALSE, if the [[Value]] field of Desc is
                present and SameValue(Desc.[[Value]],
                current.[[Value]]) is FALSE.

    b.  else the [[Configurable]] field of current is TRUE, so any
        change is acceptable.

9.  Else IsAccessorDescriptor(current) and
    IsAccessorDescriptor(Desc) are both TRUE,

    a.  If the [[Configurable]] field of current is FALSE, then

        i.  Return FALSE, if the [[Set]] field of Desc is present and
            SameValue(Desc.[[Set]], current.[[Set]]) is FALSE.

        ii. Return FALSE, if the [[Get]] field of Desc is present and
            SameValue(Desc.[[Get]], current.[[Get]]) is FALSE.

10. If O is not UNDEFINED, then

    a.  For each attribute field of Desc that is present, set the
        correspondingly named attribute of the property named P of
        object O to the value of the field.

11. Return TRUE.

NOTE Step 8.b allows any field of Desc to be different from the
corresponding field of current if current’s [[Configurable]] field is
TRUE. This even permits changing the [[Value]] of a property whose
[[Writable]] attribute is FALSE. This is allowed because a TRUE
[[Configurable]] attribute would permit an equivalent sequence of calls
where [[Writable]] is first set to TRUE, a new [[Value]] is set, and
then [[Writable]] is set to FALSE.

 [[HasProperty]](P)

When the [[HasProperty]] internal method of O is called with property
key P, the following steps are taken:

1.  Assert: IsPropertyKey(P) is TRUE.

2.  Let hasOwn be the result of calling the [[HasOwnProperty]]
    internal method of O with argument P.

3.  ReturnIfAbrupt(hasOwn).

4.  If hasOwn is FALSE, then

    a.  Let parent be the result of calling the [[GetInheritance]]
        internal method of O.

    b.  ReturnIfAbrupt(parent).

    c.  If parent is not NULL, then

        i.  Return the result of calling the [[HasProperty]] internal
            method of parent with argument P.

5.  Return hasOwn.

[[Get]] (P, Receiver)

When the [[Get]] internal method of O is called with property key P
and ECMAScript language value Receiver the following steps are taken:

1.  Assert: IsPropertyKey(P) is TRUE.

2.  Let desc be the result of calling the [[GetOwnProperty]] internal
    method of O with argument P.

3.  ReturnIfAbrupt(desc).

4.  If desc is UNDEFINED, then

    a.  Let parent be the result of calling the [[GetInheritance]]
        internal method of O.

    b.  ReturnIfAbrupt(parent).

    c.  If parent is NULL, then return UNDEFINED.

    d.  Return the result of calling the [[Get]] internal method of
        parent with arguments P and Receiver.

5.  If IsDataDescriptor(desc) is TRUE, return desc.[[Value]].

6.  Otherwise, IsAccessorDescriptor(desc) must be TRUE so, let
    getter be desc.[[Get]].

7.  If getter is UNDEFINED, return UNDEFINED.

8.  Return the result of calling the [[Call]] internal method of
    getter with Receiver as the thisArgument and an empty List as
    argumentsList.

[[Set]] ( P, V, Receiver)

When the [[Set]] internal method of O is called with property key P,
value V, and ECMAScript language value Receiver, the following steps
are taken:

1.  Assert: IsPropertyKey(P) is TRUE.

2.  a.  b.  

3.  Let ownDesc be the result of calling the [[GetOwnProperty]]
    internal method of O with argument P.

4.  ReturnIfAbrupt(ownDesc).

5.  If ownDesc is UNDEFINED, then

    a.  Let parent be the result of calling the [[GetInheritance]]
        internal method of O.

    b.  ReturnIfAbrupt(parent).

    c.  If parent is not NULL, then

        i.  Return the result of calling the [[Set]] internal method of
            parent with arguments P, V, and Receiver.

    d.  Else,

        i.  Let ownDesc be the Property Descriptor {[[Value]]:
            UNDEFINED, [[Writable]]: TRUE, [[Enumerable]]: TRUE,
            [[Configurable]]: TRUE}.

        ii. 

    e.  i.  

6.  If IsDataDescriptor(ownDesc) is TRUE, then

    a.  If ownDesc.[[Writable]] is FALSE, return FALSE.

    b.  If Type(Receiver) is not Object, return FALSE.

    c.  Let existingDescriptor be the result of calling the
        [[GetOwnProperty]] internal method of Receiver with argument
        P.

    d.  ReturnIfAbrupt(existingDescriptor).

    e.  If existingDescriptor is not UNDEFINED, then

        i.  Let valueDesc be the Property Descriptor {[[Value]]: V}.

        ii. Return the result of calling the [[DefineOwnProperty]]
            internal method of Receiver with arguments P and
            valueDesc.

    f.  Else Receiver does not currently have a property P,

        i.  ii. Return the result of performing
            CreateOwnDataProperty(Receiver, P, V).

7.  8.  If IsAccessorDescriptor(ownDesc) is TRUE, then

    a.  Let setter be ownDesc.[[Set]].

    b.  If setter is UNDEFINED, return FALSE.

9.  a.  Let setterResult be the result of calling the [[Call]]
        internal method of setter providing Receiver as
        thisArgument and a new List containing V as argumentsList.

    b.  ReturnIfAbrupt(setterResult).

    c.  Return TRUE.

[[Invoke]] (P, ArgumentsList, Receiver)

When the [[Invoke]] internal method of O is called with property key
P, List ArgumentsList, and ECMAScript language value Receiver the
following steps are taken:

1.  Assert: IsPropertyKey(P) is TRUE.

2.  Assert: ArgumentsList is a List.

3.  Let method be the result of calling the [[Get]] internal method of
    O with arguments P, and Receiver.

4.  ReturnIfAbrupt(method).

5.  If Type(method) is not Object, throw a TYPEERROR exception.

6.  If IsCallable(method) is FALSE, throw a TYPEERROR exception.

7.  Return the result of calling the [[Call]] internal method of
    method with Receiver as the thisArgument and ArgumentsList
    as argumentsList.

1.  2.  a.  b.  

3.  4.  a.  b.  c.  

5.  6.  a.  b.  c.  

7.  

    a.  b.  

[[Delete]] (P)

When the [[Delete]] internal method of O is called with property key
P the following steps are taken:

1.  

1.  2.  3.  

1.  

1.  2.  3.  a.  b.  

    c.  i.  

    d.  i.  

    e.  

4.  5.  6.  a.  b.  

7.  8.  a.  b.  i.  

    c.  i.  

9.  a.  i.  ii. 1.  

    b.  

10. a.  i.  ii. 

11. a.  

12. 

1.  

1.  2.  3.  a.  

4.  a.  

5.  

    a.  

    b.  

    c.  

6.  

7.  

[[Enumerate]] ()

When the [[Enumerate]] internal method of O is called the following
steps are taken:

1.  Return an Iterator object (reference xxxx) whose next method
    iterates over all the String valued keys of enumerable property keys
    of O. The mechanics and order of enumerating the properties is not
    specified but must conform to the rules specified below.

Enumerated properties do not include properties whose property key is a
Symbol. Properties of the object being enumerated may be deleted during
enumeration. If a property that has not yet been visited during
enumeration is deleted, then it will not be visited. If new properties
are added to the object being enumerated during enumeration, the newly
added properties are not guaranteed to be visited in the active
enumeration. A property name must not be visited more than once in any
enumeration.

Enumerating the properties of an object includes enumerating properties
of its prototype, and the prototype of the prototype, and so on,
recursively; but a property of a prototype is not enumerated if it is
“shadowed” because some previous object in the prototype chain has a
property with the same name. The values of [[Enumerable]] attributes are
not considered when determining if a property of a prototype object is
shadowed by a previous object on the prototype chain.

The following is an informative algorithm that conforms to these rules

1.  Let obj be O.

2.  Let proto be the result of calling the [[GetInheritance]] internal
    method of O with no arguments.

3.  ReturnIfAbrupt(proto).

4.  If proto is the value NULL, then

    a.  Let propList be a new empty List.

5.  Else

    a.  Let propList be the result of calling the [[Enumerate]]
        internal method of proto.

6.  ReturnIfAbrupt(propList).

7.  For each name that is the property key of an own property of O

    a.  If Type(name) is String, then

        i.  Let desc be the result of calling OrdinaryGetOwnProperty
            with arguments O and name.

        ii. If name is an element of propList, then remove name as
            an element of propList.

        iii. If desc.[[Enumerable]] is TRUE, then add name as an
            element of propList.

8.  Order the elements of propList in an implementation defined order.

9.  Return propList.

1.  

2.  

[[OwnPropertyKeys]] ( )

When the [[OwnPropertyKeys]] internal method of O is called the
following steps are taken:

1.  Let keys be a new empty List.

2.  3.  For each own property key P of O

    a.  b.  Add P as the last element of keys.

4.  Return MakeListIterator(keys).

1.  

1.  

1.  

1.  

ObjectCreate(proto, internalDataList) Abstract Operation

The abstract operation ObjectCreate with argument proto (an object or
null) is used to specify the runtime creation of new ordinary objects.
The optional argument internalDataList is a List of the names of
internal data property names that should be defined as part of the
object. If the list is not provided, an empty List is used. If no
arguments are provided %ObjectPrototype% is used as the value of
proto. This abstract operation performs the following steps:

Ordinary Function Objects

Ordinary function objects encapsulate parameterised ECMAScript code
closed over a lexical environment and support the dynamic evaluation of
that code. An ordinary function object is an ordinary object and has the
same internal data properties and (except as noted below) the same
internal methods as other ordinary objects.

Ordinary function objects have the additional internal data properties
listed in Table 13.

Ordinary function objects provide alternative definitions for the
[[Get]] and [[GetOwnProperty]] internal methods. These alternatives
prevent the value of strict mode function from being revealed as the
value of a function object property named "CALLER". These alternative
definitions exist sole to preclude a non-standard legacy feature of some
ECMAScript implementations from revealing information about strict mode
callers. If an implementation does not provide such a feature, it need
not implement these alternative internal methods for ordinary function
objects.

Table 13 -- Internal Data Properties of Ordinary Function Objects

  _INTERNAL DATA PROPERTY_   TYPE                      DESCRIPTION
  -------------------------- --------------------------- --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  [[Scope]]                  Lexical Environment         The Lexical Environment that the function was closed over. Is used as the outer environment when evaluating the code of the function.
  [[FormalParameters]]       Parse Node                  The root parse node of the source code that defines the function’s formal parameter list.
  [[FunctionKind]]           String                      Either "NORMAL" or "GENERATOR".
  [[Code]]                   Parse Node                  The root parse node of the source code that defines the function’s body.
  [[Realm]]                  Realm Record                The Code Realm in which the function was created and which provides any intrinsic objects that are accessed when evaluating the function.
  [[ThisMode]]               (lexical, strict, global)   Defines how THIS references are interpreted within the formal parameters and code body of the function. LEXICAL means that THIS refers to the THIS value of a lexically enclosing function. STRICT means that the THIS value is used exactly as provided by an invocation of the function. GLOBAL means that a this value of UNDEFINED is interpreted as a reference to the global object.
  [[Strict]]                 Boolean                     TRUE if this is a strict mode function, FALSE this is not a strict mode function.
  [[HomeObject]]             Object                      If the function uses SUPER, this is the object whose [[GetInheritance]] provides the object where super property lookups begin. Not present for functions that don’t reference SUPER.
  [[MethodName]]             String or Symbol            If the function uses SUPER, this is the property keys that is used for unqualified references to SUPER. Not present for functions that don’t reference SUPER.

Ordinary function objects all have the [[Call]], [[Get]] and
[[GetOwnProperty]] internal methods defined here. Ordinary functions
that are also constructors in addition have the [[Construct]] internal
method.

[[Call]] ( thisArgument, argumentsList) 

The [[Call]] internal method for an ordinary Function object F is
called with parameters thisArgument and argumentsList, a List of
ECMAScript language values. The following steps are taken:

1.  If F’s [[Code]] internal data property has the value UNDEFINED,
    then throw a TYPEERROR exception.

2.  Let callerContext be the running execution context.

3.  If, callerContext is not already suspended, then Suspend
    callerContext.

4.  Let calleeContext be a new ECMAScript Code execution context.

5.  Let calleeRealm be the value of F’s [[Realm]] internal data
    property.

6.  Set calleeContext’s Realm to calleeRealm.

7.  Let thisMode be the value of F’s [[ThisMode]] internal data
    property.

8.  If thisMode is lexical, then

    a.  Let localEnv be the result of calling
        NewDeclarativeEnvironment passing the value of the [[Scope]]
        internal data property of F as the argument.

9.  Else,

    a.  If thisMode is strict, set thisValue to thisArgument.

    b.  Else

        i.  if thisArgument is NULL or UNDEFINED, then

            1.  Set thisValue to calleeRealm.[[globalThis]].

        ii. Else if Type(thisArgument) is not Object, set the
            thisValue to ToObject(thisArgument).

        iii. Else set the thisValue to thisArgument.

    c.  Let localEnv be the result of calling NewFunctionEnvironment
        passing F and thisValue as the arguments.

10. Set the LexicalEnvironment of calleeContext to localEnv.

11. Set the VariableEnvironment of calleeContext to localEnv.

12. Push calleeContext onto the execution context stack;
    calleeContext is now the running execution context.

13. Let status be the result of performing Function Declaration
    Instantiation using the function F, argumentsList , and
    localEnv as described in 10.5.3.

14. If status is an abrupt completion, then

    a.  Remove calleeContext from the execution context stack and
        restore callerContext as the running execution context.

    b.  Return status.

15. Let result be the result of EvaluateBody of the production that is
    the value of F's [[Code]] internal data property passing F as
    the argument.

16. Remove calleeContext from the execution context stack and restore
    callerContext as the running execution context.

17. 18. Return result.

NOTE 1 Most ordinary functions use a Function Environment Record as
their LexicalEnvironment. Ordinary functions that are arrow functions
use a Declarative Environment Record as their LexicalEnvironment.

NOTE 2 When calleeContext is removed from the execution context stack
it must not be destroyed because it may have been suspended and retained
by a generator object for later resumption.

[[Construct]] ( argumentsList)

The [[Construct]] internal method for an ordinary Function object F is
called with a single parameter argumentsList which is a possibly empty
List of ECMAScript language values. The following steps are taken:

1.  Return the result of OrdinaryConstruct(F, argumentsList).

OrdinaryConstruct (F, argumentsList)

When the abstract operation OrdinaryConstruct is called with Object F
and List argumentsList the following steps are taken:

[[Get]] (P, Receiver)

When the [[Get]] internal method of ordinary function object F is
called with property key P and ECMAScript language value Receiver
the following steps are taken:

If an implementation does not provide such a built-in CALLER method for
FUNCTION.PROTOTYPE then it must not use this definition. Instead the
ordinary object [[Get]] internal method is used.

[[GetOwnProperty]] (P)

When the [[GetOwnProperty]] internal method of ordinary function object
F is called with property key P, the following steps are taken:

1.  Let v be the result of calling the default ordinary object
    [[GetOwnProperty]] internal method (8.3.6) on F passing P as the
    argument.

2.  ReturnIfAbrupt(v).

3.  If IsDataDescriptor(v) is TRUE, then

    a.  If P is "CALLER" and v.[[Value]] is a strict mode Function
        object, then

        i.  Set v.[[Value]] to NULL.

4.  Return v.

If an implementation does not provide such a built-in CALLER method for
FUNCTION.PROTOTYPE then it must not use this definition. Instead the
ordinary object [[GetOwnProperty]] internal method is used.

FunctionAllocate Abstract Operation

The abstract operation FunctionAllocate requires the one argument,
functionPrototype and accepts one optional argument, functionKind.
FunctionAllocate performs the following steps:

FunctionInitialise Abstract Operation

The abstract operation FunctionInitialise requires the arguments: a
function object F, kind which is one of (Normal, Method, Arrow), an
parameter list production specified by ParameterList, a body
production specified by Body, a Lexical Environment specified by
Scope, a Boolean flag Strict, and optionally, an object homeObject
and a property key methodName. FunctionInitialise performs the
following steps:

1.  Let len be the ExpectedArgumentCount of ParameterList.

2.  Let status be the result of DefinePropertyOrThrow(F, "LENGTH",
    Property Descriptor {[[Value]]: len, [[Writable]]: FALSE,
    [[Enumerable]]: FALSE, [[Configurable]]: TRUE}).

3.  If Strict is TRUE, then

    a.  Let status be the result of the
        AddRestrictedFunctionProperties abstract operation with argument
        F.

    b.  ReturnIfAbrupt(status).

4.  5.  Set the [[Scope]] internal data property of F to the value of
    Scope.

6.  Set the [[FormalParameters]] internal property of F to
    ParameterList .

7.  Set the [[Code]] internal data property of F to Body.

8.  If the homeObject argument was provided, set the [[HomeObject]]
    internal data property of F to homeObject.

9.  If the methodName argument was provided, set the [[MethodName]]
    internal data property of F to methodName.

10. Set the [[Strict]] internal data property of F to Strict.

11. If kind is Arrow, then set the [[ThisMode]] internal data property
    of F to lexical.

12. Else if Strict is TRUE, then set the [[ThisMode]] internal data
    property of F to strict.

13. Else set the [[ThisMode]] internal data property of F to global.

14. 15. 16. a.  

17. Return F.

FunctionCreate Abstract Operation

The abstract operation FunctionCreate requires the arguments: kind
which is one of (Normal, Method, Arrow), an parameter list production
specified by ParameterList, a body production specified by Body, a
Lexical Environment specified by Scope, a Boolean flag Strict, and
optionally, an object functionPrototype, an object homeObject and a
property key methodName. FunctionCreate performs the following steps:

1.  If the functionPrototype argument was not passed, then

    a.  Let functionPrototype be the intrinsic object
        %FunctionPrototype%.

2.  Let F be the result of performing FunctionAllocate with argument
    functionPrototype.

3.  Return the result of performing FunctionInitialise with passing F,
    kind, ParameterList, Body, Scope, and Strict. Also pass
    homeObject and methodName if they are present.

GeneratorFunctionCreate Abstract Operation

The abstract operation GeneratorFunctionCreate requires the arguments:
kind which is one of (Normal, Method, Arrow), an parameter list
production specified by ParameterList, a body production specified by
Body, a Lexical Environment specified by Scope, a Boolean flag
Strict, and optionally, an object functionPrototype, an object
homeObject and a property key methodName. GeneratorFunctionCreate
performs the following steps:

1.  If the functionPrototype argument was not passed, then

    a.  Let functionPrototype be the intrinsic object %Generator%.

2.  Let F be the result of performing FunctionAllocate with arguments
    functionPrototype and "GENERATOR".

3.  Return the result of performing FunctionInitialise with passing F,
    kind, ParameterList, Body, Scope, and Strict. Also pass
    homeObject and methodName if they are present.

AddRestrictedFunctionProperties Abstract Operation

The abstract operation is called with a function object F as its
argument. It performs the following steps:

1.  Let thrower be the %ThrowTypeError% intrinsic function Object.

2.  Let status be the result of DefinePropertyOrThrow(F, "CALLER",
    PropertyDescriptor {[[Get]]: thrower, [[Set]]: thrower,
    [[Enumerable]]: FALSE, [[Configurable]]: FALSE}).

3.  ReturnIfAbrupt(status).

4.  Return the result of DefinePropertyOrThrow(F , "ARGUMENTS",
    PropertyDescriptor {[[Get]]: thrower, [[Set]]: thrower,
    [[Enumerable]]: FALSE, [[Configurable]]: FALSE}).

The %ThrowTypeError% object is a unique function object that is defined
once for each Realm as follows:

1.  Assert: %FunctionPrototype% for the current Realm has already been
    initialized.

2.  Let functionPrototype be the intrinsic object %FunctionPrototype%.

3.  Let scope be the Global Environment.

4.  Let formalParameters be the syntactic production:
    FormalParameters : [empty].

5.  Let body be the syntactic production: FunctionBody :
    ThrowTypeError.

6.  Let F be the result of performing FunctionAllocate with argument
    functionPrototype.

7.  Let %ThrowTypeError% be F.

8.  Perform the abstract operation FunctionInitialise with arguments
    F, Normal, formalParameters, _body, scope_, and TRUE.

9.  Call the [[PreventExtensions]] internal method of F.

10. 

MakeConstructor Abstract Operation

The abstract operation MakeConstructor requires a Function argument F
and optionally, a Boolean writablePrototype and an object prototype.
If prototype is provided it is assumed to already contain, if needed,
a "CONSTRUCTOR" property whose value is F. This operation converts F
into a constructor by performing the following steps:

1.  Assert: F is a ordinary function object, that has not already had
    MakeConstrutor applied to it. It is extensible and dooes not have a
    "CONSTRUCTOR" or a "PROTOTYPE" own property.

2.  Let installNeeded be FALSE.

3.  If the prototype argument was not provided, then

3.  If the writablePrototype argument was not provided, then

    a.  Let writablePrototype be TRUE.

4.  Set F’s essential internal method [[Construct]] to the definition
    specified in ‎8.3.16.2.

5.  If installNeeded, then

    a.  Call the [[DefineOwnProperty]] internal method of prototype
        with arguments "CONSTRUCTOR" and Property Descriptor {[[Value]]:
        F, [[Writable]]: writablePrototype, [[Enumerable]]: FALSE,
        [[Configurable]]: writablePrototype }.

6.  Call the [[DefineOwnProperty]] internal method of F with arguments
    "PROTOTYPE" and Property Descriptor {[[Value]]: prototype ,
    [[Writable]]: writablePrototype , [[Enumerable]]: FALSE,
    [[Configurable]]: FALSE}.

7.  Return.


Built-in Exotic Object Internal Methods and Data Fields

This specification defines several kinds of built-in exotic objects.
These objects generally behave similar to ordinary objects except for a
few specific situations. The following exotic objects use the ordinary
object internal methods except where it is explicitly specified
otherwise below:

Bound Function Exotic Objects

A _bound function_ is an exotic object that wrappers another function
object. A bound function is callable (it has a [[Call]] internal method
and may have a [[Construct]] internal method). Calling a bound function
generally results in a call of its wrappered function.

Bound function objects do not have the internal data properties of
ordinary function objects defined in Table 13. Instead they have the
internal data properties defined in Table 14.

Table 14 -- Internal Data Properties of Exotic Bound Function Objects

  _INTERNAL DATA PROPERTY_   TYPE            DESCRIPTION
  -------------------------- ----------------- -------------------------------------------------------------------------------------------------------------
  [[BoundTargetFunction]]    Callable Object   The wrappered function object.
  [[BoundThis]]              Any               The value that is always passed as the THIS value when calling the wrappered function.
  [[BoundArguments]]         List of Any       A list of values that whose elements are used as the first arguments to any call to the wrappered function.

Unlike ordinary function objects, bound function objects do not use
alternative definitions of the [[Get]] and [[GetOwnPropety]] internal
methods. Bound function objects provide all of the essential internal
methods as specified in 8.3. However, they use the following definitions
for the essential internal methods of function objects.

[[Call]]

When the [[Call]] internal method of an exotic bound function object,
F, which was created using the bind function is called with parameters
thisArgument and argumentsList, a List of ECMAScript language
values, the following steps are taken:

[[Construct]]

When the [[Construct]] internal method of an exotic bound function
object, F that was created using the bind function is called with a
list of arguments ExtraArgs, the following steps are taken:

BoundFunctionCreate Abstract Operation

The abstract operation BoundFunctionCreate with arguments
targetFunction, boundThis and boundArgs is used to specify the
creation of new Bound Function exotic objects. It performs the following
steps:

1.  Let proto be the intrinsic %FunctionPrototype%.

2.  Let obj be a newly created ECMAScript object.

3.  Set obj’s essential internal methods to the default ordinary
    object definitions specified in 8.3.

4.  Set the [[Call]] internal method of obj as described in 8.4.1.1.

5.  If targetFunction has a [[Construct]] internal method, then

    a.  Set the [[Construct]] internal method of obj as described in
        8.4.1.2.

6.  Set the [[Prototype]] internal data property of obj to proto.

7.  Set the [[Extensible]] internal data property of obj to TRUE.

8.  Set the [[BoundTargetFunction]] internal data property of obj to
    targetFunction.

9.  Set the [[BoundThis]] internal data property of obj to the value
    of boundThis.

10. Set the [[BoundArguments]] internal data property of obj to
    boundArgs.

11. 12. Return obj.

Array Exotic Objects

An _Array object_ is an exotic object that gives special treatment to a
certain class of property names. A property name P (in the form of a
String value) is an _array index_ if and only if ToString(ToUint32(P))
is equal to P and ToUint32(P) is not equal to 2^32^−1. A property
whose property name is an array index is also called an element. Every
Array object has a LENGTH property whose value is always a nonnegative
integer less than 2^32^. The value of the LENGTH property is numerically
greater than the name of every property whose name is an array index;
whenever a property of an Array object is created or changed, other
properties are adjusted as necessary to maintain this invariant.
Specifically, whenever a property is added whose name is an array index,
the LENGTH property is changed, if necessary, to be one more than the
numeric value of that array index; and whenever the LENGTH property is
changed, every property whose name is an array index whose value is not
smaller than the new length is automatically deleted. This constraint
applies only to own properties of an Array object and is unaffected by
LENGTH or array index properties that may be inherited from its
prototypes.

Exotic Array objects have the same internal data properties as ordinary
objects. They also have an [[ArrayInitialisationState]] internal data
property.

Exotic Array objects always have a non-configurable property named
"LENGTH".

Exotic Array objects provide an alternative definition for the
[[DefineOwnProperty]] internal method. Except for that internal methods,
exotic Array objects provide all of the other essential internal methods
as specified in 8.3.

1.  2.  3.  4.  a.  b.  c.  i.  

    d.  i.  ii. 

5.  a.  b.  i.  ii. 1.  

        iii. 1.  

    c.  i.  ii. 

6.  a.  b.  c.  d.  e.  

[[DefineOwnProperty]] ( P, Desc)

When the [[DefineOwnProperty]] internal method of an exotic Array object
A is called with property key P, and Property Descriptor Desc the
following steps are taken:

ArrayCreate Abstract Operation

The abstract operation ArrayCreate with argument length (a positive
integer or UNDEFINED) and optional argument proto is used to specify
the creation of new exotic Array objects. It performs the following
steps:

1.  If the proto argument was not passed, then let proto be the
    intrinsic object %ArrayPrototype%.

2.  Let A be a newly created Array exotic object.

3.  Set A’s essential internal methods to the default ordinary object
    definitions specified in 8.3.

4.  5.  Set the [[DefineOwnProperty]] internal method of A as
    specified in 8.4.2.1.

6.  Set the [[Prototype]] internal data property of A to proto.

7.  8.  Set the [[Extensible]] internal data property of A to TRUE.

9.  If length is not UNDEFINED, then

    a.  Set the [[ArrayInitialisationState]] internal data property of
        A to TRUE.

10. Else

    a.  Set the [[ArrayInitialisationState]] internal data property of
        A to FALSE.

    b.  Let length be 0.

11. Call OrdinaryDefineOwnProperty with arguments A, "LENGTH" and
    Property Descriptor {[[Value]]: length, [[Writable]]: TRUE,
    [[Enumerable]]: FALSE, [[Configurable]]: FALSE}.

12. Return A.

ArraySetLength Abstract Operation

When the abstract operation ArraySetLength is called with an exotic
Array object A, and Property Descriptor Desc the following steps are
taken:

1.  2.  3.  If the [[Value]] field of Desc is absent, then

    a.  Return the result of calling OrdinaryDefineOwnProperty passing
        A, "LENGTH", and Desc as arguments.

4.  Let newLenDesc be a copy of Desc.

5.  Let newLen be ToUint32(Desc.[[Value]]).

6.  If newLen is not equal to ToNumber( Desc.[[Value]]), throw a
    RANGEERROR exception.

7.  Set newLenDesc.[[Value]] to newLen.

8.  Let oldLenDesc be the result of calling the [[GetOwnProperty]]
    internal method of A passing "LENGTH" as the argument. The result
    will never be UNDEFINED or an accessor descriptor because Array
    objects are created with a length data property that cannot be
    deleted or reconfigured.

9.  Let oldLen be oldLenDesc.[[Value]].

10. If newLen ≥oldLen, then

    a.  Return the result of calling OrdinaryDefineOwnProperty passing
        A, "LENGTH", and newLenDesc as arguments.

11. If oldLenDesc.[[Writable]] is FALSE, then return FALSE.

12. If newLenDesc.[[Writable]] is absent or has the value TRUE, let
    newWritable be TRUE.

13. Else,

    a.  Need to defer setting the [[Writable]] attribute to FALSE in
        case any elements cannot be deleted.

    b.  Let newWritable be FALSE.

    c.  Set newLenDesc.[[Writable]] to TRUE.

14. Let succeeded be the result of calling OrdinaryDefineOwnProperty
    passing A, "LENGTH", and newLenDesc as arguments.

15. ReturnIfAbrupt(succeeded).

16. If succeeded is FALSE, return FALSE.

17. While newLen < oldLen repeat,

    a.  Set oldLen to oldLen – 1.

    b.  Let deleteSucceeded be the result of calling the [[Delete]]
        internal method of A passing ToString(oldLen).

    c.  ReturnIfAbrupt(succeeded).

    d.  If deleteSucceeded is FALSE, then

        i.  Set newLenDesc.[[Value]] to oldLen+1.

        ii. If newWritable is FALSE, set newLenDesc.[[Writable]] to
            FALSE.

        iii. Let succeeded be the result of calling
            OrdinaryDefineOwnProperty passing A, "LENGTH", and
            newLenDesc as arguments.

        iv. ReturnIfAbrupt(succeeded).

        v.  Return FALSE.

18. If newWritable is FALSE, then

    a.  Call OrdinaryDefineOwnProperty passing A, "LENGTH", and
        Property Descriptor{[[Writable]]: FALSE} as arguments. This call
        will always return TRUE.

19. Return TRUE.

String Exotic Objects

A String object is an exotic object that encapsulates a String value
and exposes virtual integer indexed data properties corresponding to the
individual code unit elements of the string value. Exotic String objects
always have a data property named "LENGTH" whose value is the number of
code unit elements in the encapsulated String value. Both the code unit
data properties and the "LENGTH" property are non-writable and
non-configurable.

Exotic String objects have the same internal data properties as ordinary
objects. They also have a [[StringData]] internal data property.

Exotic String objects provide alternative definitions for the following
internal methods. All of the other exotic String object essential
internal methods that are not defined below are as specified in 8.3.

[[HasOwnProperty]] (P)

When the [[HasOwnProperty]] internal method of exotic String object O
is called with property key P, the following steps are taken:

1.  Assert: IsPropertyKey(P) is TRUE.

2.  Let has be the result of calling the ordinary object
    [[HasOwnProperty]] internal method (8.3.5) on O with argument P.

3.  ReturnIfAbrupt(has).

4.  If has is TRUE, then return TRUE.

5.  If Type(P) is not String, then return FALSE.

6.  Let index be ToInteger(P).

7.  Assert: index is not an abrupt completion.

8.  Let absIntIndex be ToString(abs(index)).

9.  10. If SameValue(absIntIndex, P) is FALSE return FALSE.

11. Let str be the String value of the [[StringData]] internal
    property of O, if the value of [[StringData]] is undefined the
    empty string is used as its value.

12. Let len be the number of elements in str.

13. If len ≤ index, return FALSE.

14. Return TRUE.

[[GetOwnProperty]] ( P )

When the [[GetOwnProperty]] internal method of an exotic String object
S is called with property key P the following steps are taken:

[[DefineOwnProperty]] ( P, Desc)

When the [[DefineOwnProperty]] internal method of an exotic String
object O is called with property key P, and Property Descriptor
Desc the following steps are taken:

1.  Let current be the result of calling the [[GetOwnProperty]]
    internal method of O with argument P.

2.  Let extensible be the value of the [[Extensible]] internal data
    property of O.

3.  Return the result of ValidateAndApplyPropertyDescriptor with
    arguments O, P, extensible, Desc, and current.

NOTE This algorithm differs from the ordinary object
OrdinaryDefineOwnProperty abstract operation algorithm only in
invocation of [[GetOwnProperty]] in step 1.

[[Enumerate]] ()

When the [[Enumerate]] internal method of an exotic String object O is
called the following steps are taken:

[[OwnPropertyKeys]] ( )

When the [[OwnPropertyKeys]] internal method of an exotic String object
O is called the following steps are taken:

StringCreate Abstract Operation

The abstract operation StringCreate with argument prototype is used to
specify the creation of new exotic String objects. It performs the
following steps:

1.  Let A be a newly created String exotic object.

2.  Set A’s essential internal methods to the default ordinary object
    definitions specified in 8.3.

3.  Set the [[HasOwnProperty]] internal method of A as specified in
    8.4.3.1.

4.  Set the [[GetOwnProperty]] internal method of A as specified in
    8.4.3.2.

5.  Set the [[DefineOwnProperty]] internal method of A as specified in
    8.4.3.3.

6.  Set the [[Enumerate]] internal method of A as specified in
    8.4.3.4.

7.  Set the [[OwnPropertyKeys]] internal method of A as specified in
    8.4.3.5.

8.  Set the [[Prototype]] internal data property of A to prototype.

9.  Set the [[Extensible]] internal data property of A to TRUE.

10. Return A.

Symbol Exotic Objects

A _Symbol object_ is an exotic object that may be used as a property
key. Symbol exotic objects are always immutable and never observably
reference any other object.

Exotic Symbol objects provide alternative definitions for all of the
essential internal methods.

 [[GetInheritance]] ( )

When the [[GetInheritance]] internal method of an exotic Symbol object
O is called the following steps are taken:

1.  Return NULL.

 [[SetInheritance]] (V)

When the [[SetInheritance]] internal method of an exotic Symbol object
O is called with argument V the following steps are taken:

1.  Assert: Either Type(V) is Object or Type(V) is Null.

2.  Return FALSE.

 [[IsExtensible]] ( )

When the [[IsExtensible]] internal method of an exotic Symbol object O
is called the following steps are taken:

1.  Return FALSE.

 [[PreventExtensions]] ( )

When the [[PreventExtensions]] internal method of an exotic Symbol
object O is called the following steps are taken:

1.  Return TRUE.

 [[HasOwnProperty]] (P)

When the [[HasOwnProperty]] internal method of an exotic Symbol object
O is called with property key P, the following steps are taken:

1.  Return FALSE.

 [[GetOwnProperty]] (P)

When the [[GetOwnProperty]] internal method of an exotic Symbol object
O is called with property key P, the following steps are taken:

1.  Return UNDEFINED.

 [[DefineOwnProperty]] (P, Desc)

When the [[DefineOwnProperty]] internal method of an exotic Symbol
object O is called with property key P and property descriptor
Desc, the following steps are taken:

1.  Return FALSE.

 [[HasProperty]] (P)

When the [[HasProperty]] internal method of an exotic Symbol object O
is called with property key P, the following steps are taken:

1.  Return FALSE.

 [[Get]] (P, Receiver)

When the [[Get]] internal method of an exotic Symbol object O is
called with property key P and ECMAScript language value Receiver
the following steps are taken:

1.  Assert: IsPropertyKey(P) is TRUE.

2.  Return UNDEFINED.

 [[Set]] ( P, V, Receiver)

When the [[Set]] internal method of an exotic Symbol object O is
called with property key P, value V, and ECMAScript language value
Receiver, the following steps are taken:

1.  Return FALSE.

[[Invoke]] (P, ArgumentsList, Receiver)

When the [[Invoke]] internal method of an exotic Symbol object O is
called with property key P, List ArgumentsList, and ECMAScript
language value Receiver the following steps are taken:

1.  Throw a TYPEERROR exception..

 [[Delete]] (P)

When the [[Delete]] internal method of an exotic Symbol object O is
called with property key P the following steps are taken:

1.  Assert: IsPropertyKey(P) is TRUE.

2.  Return TRUE.

 [[Enumerate]] ()

When the [[Enumerate]] internal method of an exotic Symbol object O is
called the following steps are taken:

1.  Return the result of CreateEmptyIterator().

 [[OwnPropertyKeys]] ( )

When the [[OwnPropertyKeys]] internal method of an exotic Symbol object
O is called the following steps are taken:

1.  Return the result of CreateEmptyIterator().

1.  

1.  2.  

1.  2.  

1.  2.  

1.  

1.  

1.  

1.  

1.  2.  a.  b.  

    c.  

3.  

1.  

1.  2.  

1.  

1.  

1.  

1.  

1.  

1.  

1.  

1.  

Exotic Arguments Objects

An arguments object is an exotic object whose array index properties
map to the formal parameters bindings of an invocation of a non-strict
function.

Exotic arguments objects have the same internal data properties as
ordinary objects. They also have a [[ParameterMap]] internal data.

Exotic arguments objects provide alternative definitions for the
following internal methods. All of the other exotic arguments object
essential internal methods that are not defined below are as specified
in 8.3.

Integer Indexed Exotic Objects

An _Integer Indexed object_ is an exotic object that performs special
handling of integer property keys.

Integer Indexed exotic objects have the same internal data properties as
ordinary objects additionally [[ViewedArrayBuffer]], [[ArrayLength]],
[[ByteOffset]], and [[TypedArrayName]] internal data properties.

Integer Indexed Exotic objects provide alternative definitions for the
following internal methods. All of the other Integer Indexed exotic
object essential internal methods that are not defined below are as
specified in 8.3.

[[HasOwnProperty]] (P)

When the [[HasOwnProperty]] internal method of an Integer Indexed exotic
object O is called with property key P, the following steps are
taken:

[[GetOwnProperty]] ( P )

When the [[GetOwnProperty]] internal method of an Integer Indexed exotic
object O is called with property key P the following steps are
taken:

1.  Assert: IsPropertyKey(P) is TRUE.

2.  Assert: O is an Object that has a [[ViewedArrayBuffer]] internal
    data.

3.  If Type(P) is String, then

    a.  Let intIndex be ToInteger(P).

    b.  Assert: intIndex is not an abrupt completion.

    c.  If SameValue(ToString(intIndex), P) is TRUE, then

        i.  Let value be the result of IntegerIndexedElementGet (O,
            intIndex).

        ii. ReturnIfAbrupt(value).

        iii. If value is UNDEFINED, then return UNDEFINED.

        iv. Let writable be TRUE if the integer indexed properties of
            O are writable and FALSE if they are not.

        v.  Return a Property Descriptor { [[Value]]: value,
            [[Enumerable]]: TRUE, [[Writable]]: writable,
            [[Configurable]]: FALSE }.

4.  Return the result of OrdinaryGetOwnProperty(O, P).

[[DefineOwnProperty]] ( P, Desc)

When the [[DefineOwnProperty]] internal method of an Integer Indexed
exotic object O is called with property key P, and Property
Descriptor Desc the following steps are taken:

1.  Assert: IsPropertyKey(P) is TRUE.

2.  Assert: O is an Object that has a [[ViewedArrayBuffer]] internal
    data.

3.  If Type(P) is String, then

    a.  Let intIndex be ToInteger(P).

    b.  Assert: intIndex is not an abrupt completion.

    c.  If SameValue(ToString(intIndex), P) is TRUE, then

        i.  If intIndex < 0, then return FALSE.

        ii. Let length be the value of O’s [[ArrayLength]] internal
            data property.

        iii. If length is UNDEFINED, then throw a TYPEERROR exception.

        iv. If intIndex ≥ length, then return FALSE.

        v.  If IsAccessorDescriptor(Desc) is TRUE, then return FALSE.

        vi. If Desc has a [[Configurable]] field and if
            Desc.[[Configurable]] is TRUE, then return FALSE.

        vii. If Desc has an [[Enumerable]] field and if
            Desc.[[Enumerable]] is FALSE, then return FALSE.

        viii. Let writable be TRUE if the integer indexed properties
            of O are writable and FALSE if they are not.

        ix. Let makeReadOnly be FALSE.

        x.  If Desc has a [[Writable]] field, then

            1.  If Desc.[[Writable]] is TRUE and writable is FALSE,
                then return FALSE.

            2.  If Desc.[[Writable]] is FALSE and writable is TRUE,
                then let makeReadOnly be TRUE.

        xi. If Desc has an [[Value]] field, then

            1.  Let value be Desc.[[Value]].

            2.  If writable is FALSE, then

                a.  Let oldValue be the result of
                      IntegerIndexedElementGet (O, intIndex).

                b.  ReturnIfAbrupt(oldValue).

                c.  If oldValue is UNDEFINED, then return FALSE.

                d.  If SameValue( value, oldValue) is FALSE, then
                      return FALSE.

            3.  Else

                a.  Let status be the result of
                      IntegerIndexedElementSet (O, intIndex,
                      value).

                b.  ReturnIfAbrupt(status).

        xii. If makeReadOnly is TRUE, then mark the integer indexed
            properties of O as non-writable.

        xiii. Return TRUE.

4.  Return the result of OrdinaryGetOwnProperty(O, P).

 [[Get]] (P, Receiver)

When the [[Get]] internal method of an Integer Indexed exotic object O
is called with property key P and ECMAScript language value Receiver
the following steps are taken:

 [[Set]] ( P, V, Receiver)

When the [[Set]] internal method of an Integer Indexed exotic object O
is called with property key P, value V, and ECMAScript language
value Receiver, the following steps are taken:

1.  Assert: IsPropertyKey(P) is TRUE.

2.  If Type(P) is String and if SameValue(O, Receiver) is TRUE,
    then

3.  Return the result of calling the default ordinary object [[Set]]
    internal method (8.3.7) on O passing P, V, and Receiver as
    arguments.

[[Enumerate]] ()

[[OwnPropertyKeys]] ()

IntegerIndexedObjectCreate Abstract Operation

The abstract operation IntegerIndexedObjectCreate with argument
prototype is used to specify the creation of new Integer Indexed
exotic objects. It performs the following steps:

1.  Let A be a newly created ECMAScript object.

2.  Set A’s essential internal methods to the default ordinary object
    definitions specified in 8.3.

3.  Set the [[HasOwnProperty]] internal method of A as specified in
    ‎8.4.6.1.

4.  Set the [[GetOwnProperty]] internal method of A as specified in
    ‎8.4.6.2.

5.  Set the [[DefineOwnProperty]] internal method of A as specified in
    ‎8.4.6.3.

6.  Set the [[Get]] internal method of A as specified in ‎8.4.6.4.

7.  Set the [[Set]] internal method of A as specified in ‎8.4.6.5.

8.  Set the [[Enumerate]] internal method of A as specified in
    ‎8.4.6.6.

9.  Set the [[OwnPropertyKeys]] internal method of A as specified in
    ‎8.4.6.7.

10. Set the [[Prototype]] internal data property of A to prototype.

11. Set the [[Extensible]] internal data property of A to TRUE.

12. Return A.

IntegerIndexedElementGet ( O, index ) Abstract Operation

1.  Assert: Type(index) is Number and index is an integer.

2.  Assert: O is an Object that has [[ViewedArrayBuffer]],
    [[ArrayLength]], [[ByteOffset]], and [[TypedArrayName]] internal
    data properties.

3.  Let buffer be the value of O’s [[ViewedArrayBuffer]] internal
    data property.

4.  If buffer is UNDEFINED, then throw a TYPEERROR exception.

5.  Let length be the value of O’s [[ArrayLength]] internal data
    property.

6.  If index < 0 or index ≥ length, then return UNDEFINED.

7.  Let offset be the value of O’s [[ByteOffset]] internal data
    property.

8.  Let arrayTypeName be the string value O’s [[TypedArrayName]]
    internal data property.

9.  Let elementSize be the Number value of the Element Size value
    specified in Table 36 for arrayTypeName.

10. Let indexedPosition = (index × elementSize) + offset.

11. Let elementType be the string value of the Element Type value in
    Table 36 for arrayTypeName.

12. Return the result of GetValueFromBuffer(buffer, indexedPosition,
    elementType).

IntegerIndexedElementSet ( O, index, value ) Abstract Operation

1.  Assert: Type(index) is Number and index is an integer.

2.  Assert: O is an Object that has [[ViewedArrayBuffer]],
    [[ArrayLength]], [[ByteOffset]], and [[TypedArrayName]] internal
    data properties.

3.  4.  5.  6.  Let buffer be the value of O’s [[ViewedArrayBuffer]]
    internal data property.

7.  If buffer is UNDEFINED, then throw a TYPEERROR exception.

8.  Let length be the value of O’s [[ArrayLength]] internal data
    property.

9.  Let numValue be ToNumber(value).

10. ReturnIfAbrupt(numValue).

11. If index < 0 or index ≥ length, then return FALSE.

12. Let offset be the value of O’s [[ByteOffset]] internal data
    property.

13. Let arrayTypeName be the string value O’s [[TypedArrayName]]
    internal data property.

14. Let elementSize be the Number value of the Element Size value
    specified in Table 36 for arrayTypeName.

15. Let indexedPosition = (index × elementSize) + offset.

16. Let elementType be the string value of the Element Type value in
    Table 36 for arrayTypeName.

17. Let status be the result of SetValueInBuffer(buffer,
    indexedPosition, elementType, numValue).

18. ReturnIfAbrupt(status).

19. Return TRUE.

Built-in Function Objects

The function objects specified in Clause 15 may be implemented as either
ordinary function objects whose behaviour is provided using ECMAScript
code or as implementation provided exotic function objects whose
behaviour is provided in some other manner. In either case, the effect
of calling such functions must be that specified for each one in Clause
15.

If an implementation provided exotic object is used, the object must
have the ordinary object behaviour specified in ‎8.3 except for [[Get]]
and [[GetOwnProperty]] which must be as specified in ‎8.3.16. All such
exotic function objects also have [[Prototype]] and [[Extensible]]
internal data.

[[Call]] and [[Construct]]

CreateBuiltinFunction Abstract Operation

The abstract operation CreateBuiltinFunction takes a single argument,
steps, that is a list of algorithm steps. It returns a bult-in
function object created by following steps:

1.  Let func be a new built-in function object, in the current Realm,
    that when called performs the action described by steps.

2.  Return func.


Proxy Object Internal Methods and Internal Data Properties

A proxy object is an exotic object whose essential internal methods are
partially implemented using ECMAScript code. Every proxy objects has an
internal data property called [[ProxyHandler]]. The value of
[[ProxyHandler]] is always an object, called the proxy’s _handler
object_. Methods of a handler object may be used to augment the
implementation for one or more of the proxy object’s internal methods.
Every proxy object also has an internal data property called
[[ProxyTarget]] whose value is either an object or the NULL value. This
object is called the proxy’s _target object_.

When a handler method is called to provide the implementation of a proxy
object internal method, the handler method is passed the proxy’s target
object as a parameter. A proxy’s handler object does not necessarily
have a method corresponding to every essential internal method. Invoking
an internal method on the proxy results in the invocation of the
corresponding internal method on the proxy’s target object if the
handler object does not have a method corresponding to the internal
trap.

The [[ProxyHandler]] and [[ProxyTarget]] internal data properties of a
proxy object are always initialised when the object is created and
typically may not be modified. Some proxy objects are created in a
manner that permits them to be subsequently revoked. When a proxy is
revoked, its [[ProxyHander]] internal data property is set to a special
revoked proxy handler object and its [[ProxyTarget]] internal data
property is set to NULL.

Because proxy permit arbitrary ECMAScript code to be used to in the
implementation of internal methods, it is possible to define a proxy
object whose handler methods violates the invariants defined in 8.1.6.2.
Some of the internal method invariants defined in 8.1.6.2 are essential
integrity invariants. These invariants are explicitly enforced by the
proxy internal methods specified in this section. An ECMAScript
implementation must be robust in the presence of all possible invariant
violations.

In the following algorithm descriptions, assume O is an ECMAScript
proxy object, P is a property key value, V is any ECMAScript
language value, Desc is a Property Description record, and B is a
Boolean flag.

[[GetInheritance]] ( )

When the [[GetInheritance]] internal method of an exotic Proxy object
O is called the following steps are taken:

1.  Let handler be the value of the [[ProxyHandler]] internal data
    property of O.

2.  Let target be the value of the [[ProxyTarget]] internal data
    property of O.

3.  Let trap be the result of GetMethod(handler, "GETPROTOTYPEOF").

4.  ReturnIfAbrupt(trap).

5.  If trap is UNDEFINED, then

    a.  Return the result of calling the [[GetInheritance]] internal
        method of target.

6.  Let handlerProto be the result of calling the [[Call]] internal
    method of trap with handler as the THIS value and a new List
    containing target.

7.  ReturnIfAbrupt(handlerProto).

8.  Let targetProto be the result of calling the [[GetInheritance]]
    internal method of target.

9.  ReturnIfAbrupt(targetProto).

10. If SameValue(handlerProto, targetProto) is FALSE, then throw a
    TYPEERROR exception.

11. Return handlerProto.

NOTE [[GetInheritance]] for proxy objects enforces the following
invariant:

-   [[GetInheritance]] applied to the proxy object must return the same
      value as [[GetInheritance] applied to the proxy object’s target
      object.

 [[SetInheritance]] (V)

When the [[SetInheritance]] internal method of an exotic Proxy object
O is called with argument V the following steps are taken:

1.  Assert: Either Type(V) is Object or Type(V) is Null.

2.  Let handler be the value of the [[ProxyHandler]] internal data
    property of O.

3.  Let target be the value of the [[ProxyTarget]] internal data
    property of O.

4.  Let trap be the result of GetMethod(handler, "SETPROTOTYPEOF").

5.  ReturnIfAbrupt(trap).

6.  If trap is UNDEFINED, then

    a.  Return the result of calling the [[SetInheritance]] internal
        method of target with argument V.

7.  Let trapResult be the result of calling the [[Call]] internal
    method of trap with handler as the THIS value and a new List
    containing target and V.

8.  ReturnIfAbrupt(trapResult).

9.  Let trapResult be ToBoolean(trapResult).

10. Let extensibleTarget be the result of IsExtensible(target).

11. ReturnIfAbrupt(extensibleTarget).

12. 13. If extensibleTarget is TRUE, then return trapResult.

14. 15. 16. a.  

17. 18. 19. Let targetProto be the result of calling the
    [[GetInheritance]] internal method of target.

20. ReturnIfAbrupt(targetProto).

21. If trapResult is TRUE and SameValue(V, targetProto) is FALSE,
    then throw a TYPEERROR exception.

22. Return trapResult.

NOTE [[SetInheritance]] for proxy objects enforces the following
invariant:

-   If the target object is not extensible, the argument value must be
      the same as the result of [[GetInheritance]] applied to target
      object.

[[IsExtensible]] ( )

When the [[IsExtensible]] internal method of an exotic Proxy object O
is called the following steps are taken:

1.  Let handler be the value of the [[ProxyHandler]] internal data
    property of O.

2.  Let target be the value of the [[ProxyTarget]] internal data
    property of O.

3.  4.  5.  6.  Let trap be the result of GetMethod(handler,
    "ISEXTENSIBLE").

7.  ReturnIfAbrupt(trap).

8.  If trap is UNDEFINED, then

    a.  Return the result of calling the [[IsExtensible]] internal
        method of target.

9.  Let trapResult be the result of calling the [[Call]] internal
    method of trap with handler as the THIS value and a new List
    containing target.

10. ReturnIfAbrupt(trapResult).

11. Let booleanTrapResult be ToBoolean(trapResult).

12. Let targetResult be the result of calling the [[IsExtensible]]
    internal method of target.

13. ReturnIfAbrupt(targetResult).

14. If SameValue(booleanTrapResult, targetResult) is FALSE, then
    throw a TYPEERROR exception.

15. Return booleanTrapResult.

NOTE [[IsExtensible]] for proxy objects enforces the following
invariant:

-   [[IsExtensible]] applied to the proxy object must return the same
      value as [[IsExtensible]] applied to the proxy object’s target
      object with the same argument.

[[PreventExtensions]] ( )

When the [[PreventExtensions]] internal method of an exotic Proxy object
O is called the following steps are taken:

1.  Let handler be the value of the [[ProxyHandler]] internal data
    property of O.

2.  Let target be the value of the [[ProxyTarget]] internal data
    property of O.

3.  Let trap be the result of GetMethod(handler,
    "PREVENTEXTENSIONS").

4.  ReturnIfAbrupt(trap).

5.  If trap is UNDEFINED, then

    a.  Return the result of calling the [[PreventExtensions]] internal
        method of target.

6.  Let trapResult be the result of calling the [[Call]] internal
    method of trap with handler as the THIS value and a new List
    containing target.

7.  8.  9.  10. 11. a.  

12. 13. 14. Let booleanTrapResult be ToBoolean(trapResult)

15. 16. ReturnIfAbrupt(booleanTrapResult).

17. Let targetIsExtensible be the result of calling the
    [[IsExtensible]] internal method of target.

18. ReturnIfAbrupt(targetIsExtensible).

19. If booleanTrapResult is TRUE and targetIsExtensible is TRUE,
    then throw a TYPEERROR exception.

20. Return targetIsExtensible .

NOTE [[PreventExtensions]] for proxy objects enforces the following
invariant:

-   [[PreventExtensions]] applied to the proxy object only returns TRUE
    if [[IsExtensible]] applied to the proxy object’s target object is
    FALSE.

[[HasOwnProperty]] (P)

When the [[HasOwnProperty]] internal method of an exotic Proxy object
O is called with property key P, the following steps are taken:

1.  Assert: IsPropertyKey(P) is TRUE.

2.  Let handler be the value of the [[ProxyHandler]] internal data
    property of O.

3.  Let target be the value of the [[ProxyTarget]] internal data
    property of O.

4.  Let trap be the result of GetMethod(handler, "HASOWN").

5.  ReturnIfAbrupt(trap).

6.  If trap is UNDEFINED, then

    a.  Return the result of calling the [[HasOwnProperty]] internal
        method of target with argument P.

7.  Let trapResult be the result of calling the [[Call]] internal
    method of trap with handler as the THIS value and a new List
    containing target and P.

8.  ReturnIfAbrupt(trapResult).

9.  Let success be ToBoolean(trapResult).

10. If success is FALSE, then

    a.  Let targetDesc be the result of calling the [[GetOwnProperty]]
        internal method of target with argument P.

    b.  ReturnIfAbrupt(targetDesc).

    c.  If targetDesc is not UNDEFINED, then

        i.  If targetDesc.[[Configurable]] is FALSE, then throw a
            TYPEERROR exception.

        ii. Let extensibleTarget be the result of calling the
            [[IsExtensible]] internal method of target.

        iii. ReturnIfAbrupt(extensibleTarget).

        iv. If ToBoolean(extensibleTarget) is FALSE, then throw a
            TYPEERROR exception.

11. Else success is TRUE,

    a.  b.  Let extensibleTarget be the result of
        IsExtensible(target).

    c.  ReturnIfAbrupt(extensibleTarget).

    d.  If ToBoolean(extensibleTarget) is TRUE, then return success.

    e.  Let targetDesc be the result of calling the [[GetOwnProperty]]
        internal method of target with argument P.

    f.  ReturnIfAbrupt(targetDesc).

    g.  If targetDesc is UNDEFINED, then throw a TYPEERROR exception.

12. Return success.

NOTE [[HasOwnProperty]] for proxy objects enforces the following
invariants:

-   A property cannot be reported as non-existent, if it exists as a
      non-configurable own property of the target object.

-   A property cannot be reported as non-existent, if it exists as a own
      property of the target object and the target object is not
      extensible.

-   A property cannot be reported as existent, if it does not exists as
      a own property of the target object and the target object is not
      extensible.

[[GetOwnProperty]] (P)

When the [[GetOwnProperty]] internal method of an exotic Proxy object
O is called with property key P, the following steps are taken:

1.  Assert: IsPropertyKey(P) is TRUE.

2.  Let handler be the value of the [[ProxyHandler]] internal data
    property of O.

3.  Let target be the value of the [[ProxyTarget]] internal data
    property of O.

4.  Let trap be the result of GetMethod(handler,
    "GETOWNPROPERTYDESCRIPTOR").

5.  ReturnIfAbrupt(trap).

6.  If trap is UNDEFINED, then

    a.  Return the result of calling the [[GetOwnProperty]] internal
        method of target with argument P.

7.  Let trapResultObj be the result of calling the [[Call]] internal
    method of trap with handler as the THIS value and a new List
    containing target and P.

8.  ReturnIfAbrupt(trapResultObj).

9.  If Type(trapResultObj) is neither Object or Undefined, then throw
    a TYPEERROR exception.

10. Let targetDesc be the result of calling the [[GetOwnProperty]]
    internal method of target with argument P.

11. ReturnIfAbrupt(targetDesc).

12. If trapResultObj is UNDEFINED, then

    a.  If targetDesc is UNDEFINED, then return UNDEFINED.

    b.  If targetDesc.[[Configurable]] is FALSE, then throw a
        TYPEERROR exception.

    c.  Let extensibleTarget be the result of IsExtensible(target).

    d.  ReturnIfAbrupt(extensibleTarget).

    e.  If ToBoolean(extensibleTarget) is FALSE, then throw a
        TYPEERROR exception.

    f.  Return UNDEFINED.

13. Let extensibleTarget be the result of IsExtensible(target).

14. ReturnIfAbrupt(extensibleTarget).

15. Set extensibleTarget to ToBoolean(extensibleTarget),

16. Let resultDesc be ToPropertyDescriptor(trapResultObj).

17. ReturnIfAbrupt(resultDesc).

18. Call CompletePropertyDescriptor(_resultDesc, targetDesc_).

19. Let valid be the result of IsCompatiblePropertyDescriptor
    (extensibleTarget, resultDesc, targetDesc).

20. If valid is FALSE, then throw a TYPEERROR exception.

21. If resultDesc.[[Configurable]] is FALSE, then

    a.  If targetDesc is UNDEFINED or targetDesc.[[Configurable]] is
        TRUE, then

        i.  Throw a TYPEERROR exception.

22. Return resultDesc.

NOTE [[GetOwnProperty]] for proxy objects enforces the following
invariants:

-   The result of [[GetOwnProperty]] must be either an Object or
      UNDEFINED.

-   A property cannot be reported as non-existent, if it exists as a
      non-configurable own property of the target object.

-   A property cannot be reported as non-existent, if it exists as a own
      property of the target object and the target object is not
      extensible.

-   A property cannot be reported as existent, if it does not exists as
      a own property of the target object and the target object is not
      extensible.

-   A property cannot be reported as non-configurable, if it does not
      exists as a own property of the target object or if it exists as a
      configurable own property of the target object.

-   The result of [[GetOwnProperty]] can be applied to the target object
      using [[DefineOwnPropery]] and will not throw an exception.

[[DefineOwnProperty]] (P, Desc)

When the [[DefineOwnProperty]] internal method of an exotic Proxy object
O is called with property key P and property descriptor Desc, the
following steps are taken:

1.  Assert: IsPropertyKey(P) is TRUE.

2.  Let handler be the value of the [[ProxyHandler]] internal data
    property of O.

3.  Let target be the value of the [[ProxyTarget]] internal data
    property of O.

4.  Let trap be the result of GetMethod(handler, "DEFINEPROPERTY").

5.  ReturnIfAbrupt(trap).

6.  If trap is UNDEFINED, then

    a.  Return the result of calling the [[DefineOwnProperty]] internal
        method of target with arguments P and Desc.

7.  Let descObj be FromPropertyDescriptor(Desc).

8.  NOTE If Desc was originally generated from an object using
    ToPropertyDescriptor, then descObj will be that original object.

9.  Let trapResult be the result of calling the [[Call]] internal
    method of trap with handler as the THIS value and a new List
    containing target, P, and descObj.

10. ReturnIfAbrupt(trapResult).

11. If ToBoolean(trapResult) is FALSE, then return FALSE.

12. Let targetDesc be the result of calling the [[GetOwnProperty]]
    internal method of target with argument P.

13. ReturnIfAbrupt(targetDesc).

14. Let extensibleTarget be the result of IsExtensible(target).

15. ReturnIfAbrupt(extensibleTarget).

16. Set extensibleTarget to ToBoolean(extensibleTarget),

17. If Desc has a [[Configurable]] field and if
    Desc.[[Configurable]] is FALSE, then

    a.  Let settingConfigFalse be TRUE.

18. Else let settingConfigFalse be FALSE.

19. If targetDesc is UNDEFINED, then

    a.  If extensibleTarget is FALSE, then throw a TYPEERROR
        exception.

    b.  If settingConfigFalse is TRUE, then throw a TYPEERROR
        exception.

20. Else targetDesc is not UNDEFINED,

    a.  If IsCompatiblePropertyDescriptor(extensibleTarget, Desc ,
        targetDesc) is FALSE, then throw a TYPEERROR exception.

    b.  If settingConfigFalse is TRUE and
        targetDesc.[[Configurable]] is TRUE, then throw a TYPEERROR
        exception.

21. Return TRUE.

NOTE [[DefineOwnProperty]] for proxy objects enforces the following
invariants:

-   A property cannot be added, if the target object is not extensible.

-   A property cannot be added as or modified to be non-configurable, if
      it does not exists as a non-configurable own property of the
      target object.

-   A property may not be non-configurable, if is corresponding
      configurable property of the target object exists.

-   If a property has a corresponding target object property then apply
      the property descriptor of the property to the target object using
      [[DefineOwnPropery]] will not throw an exception.

[[HasProperty]] (P)

When the [[HasProperty]] internal method of an exotic Proxy object O
is called with property key P, the following steps are taken:

1.  Assert: IsPropertyKey(P) is TRUE.

2.  Let handler be the value of the [[ProxyHandler]] internal data
    property of O.

3.  Let target be the value of the [[ProxyTarget]] internal data
    property of O.

4.  Let trap be the result of GetMethod(handler, "HAS").

5.  ReturnIfAbrupt(trap).

6.  If trap is UNDEFINED, then

    a.  Return the result of calling the [[HasProperty]] internal method
        of target with argument P.

7.  Let trapResult be the result of calling the [[Call]] internal
    method of trap with handler as the THIS value and a new List
    containing target and P.

8.  ReturnIfAbrupt(trapResult).

9.  Let success be ToBoolean(trapResult).

10. If success is FALSE, then

    a.  Let targetDesc be the result of calling the [[GetOwnProperty]]
        internal method of target with argument P.

    b.  ReturnIfAbrupt(targetDesc).

    c.  If targetDesc is not UNDEFINED, then

        i.  If targetDesc.[[Configurable]] is FALSE, then throw a
            TYPEERROR exception.

        ii. Let extensibleTarget be the result of
            IsExtensible(target).

        iii. ReturnIfAbrupt(extensibleTarget).

        iv. If ToBoolean(extensibleTarget) is FALSE, then throw a
            TYPEERROR exception.

11. Return success.

NOTE [[HasProperty]] for proxy objects enforces the following
invariants:

-   A property cannot be reported as non-existent, if it exists as a
      non-configurable own property of the target object.

-   A property cannot be reported as non-existent, if it exists as a own
      property of the target object and the target object is not
      extensible.

[[Get]] (P, Receiver)

When the [[Get]] internal method of an exotic Proxy object O is called
with property key P and ECMAScript language value Receiver the
following steps are taken:

1.  Assert: IsPropertyKey(P) is TRUE.

2.  Let handler be the value of the [[ProxyHandler]] internal data
    property of O.

3.  Let target be the value of the [[ProxyTarget]] internal data
    property of O.

4.  Let trap be the result of GetMethod(handler, "GET").

5.  ReturnIfAbrupt(trap).

6.  If trap is UNDEFINED, then

    a.  Return the result of calling the [[Get]] internal method of
        target with arguments P and Receiver.

7.  Let trapResult be the result of calling the [[Call]] internal
    method of trap with handler as the THIS value and a new List
    containing target, P, and Receiver.

8.  ReturnIfAbrupt(trapResult).

9.  Let targetDesc be the result of calling the [[GetOwnProperty]]
    internal method of target with argument P.

10. ReturnIfAbrupt(targetDesc).

11. If targetDesc is not UNDEFINED, then

    a.  If IsDataDescriptor(targetDesc) and
        targetDesc.[[Configurable]] is FALSE and
        targetDesc.[[Writable]] is FALSE, then

        i.  If SameValue(trapResult, targetDesc.[[Value]]) is FALSE,
            then throw a TYPEERROR exception.

    b.  If IsAccessorDescriptor(targetDesc) and
        targetDesc.[[Configurable]] is FALSE and targetDesc.[[Get]]
        is UNDEFINED, then

        i.  If trapResult is not UNDEFINED, then throw a TYPEERROR
            exception.

12. Return trapResult.

NOTE [[Get]] for proxy objects enforces the following invariants:

-   The value reported for a property must be the same as the value of
      the corresponding target object property if the target object
      property is a non-writable, non-configurable data property.

-   The value reported for a property must be UNDEFINED if the
      corresponding corresponding target object property is
      non-configurable accessor property that has UNDEFINED as its
      [[Get]] attribute.

[[Set]] ( P, V, Receiver)

When the [[Set]] internal method of an exotic Proxy object O is called
with property key P, value V, and ECMAScript language value
Receiver, the following steps are taken:

1.  Assert: IsPropertyKey(P) is TRUE.

2.  Let handler be the value of the [[ProxyHandler]] internal data
    property of O.

3.  Let target be the value of the [[ProxyTarget]] internal data
    property of O.

4.  Let trap be the result of GetMethod(handler, "SET").

5.  ReturnIfAbrupt(trap).

6.  If trap is UNDEFINED, then

    a.  Return the result of calling the [[Set]] internal method of
        target with arguments P, V, and Receiver.

7.  Let trapResult be the result of calling the [[Call]] internal
    method of trap with handler as the THIS value and a new List
    containing target, P, V, and Receiver.

8.  ReturnIfAbrupt(trapResult).

9.  If ToBoolean(trapResult) is FALSE, then return FALSE.

10. Let targetDesc be the result of calling the [[GetOwnProperty]]
    internal method of target with argument P.

11. ReturnIfAbrupt(targetDesc).

12. If targetDesc is not UNDEFINED, then

    a.  If IsDataDescriptor(targetDesc) and
        targetDesc.[[Configurable]] is FALSE and
        targetDesc.[[Writable]] is FALSE, then

        i.  If SameValue(V, targetDesc.[[Value]]) is FALSE, then
            throw a TYPEERROR exception.

    b.  If IsAccessorDescriptor(targetDesc) and
        targetDesc.[[Configurable]] is FALSE, then

        i.  If targetDesc.[[Set]] is UNDEFINED, then throw a TYPEERROR
            exception.

13. Return TRUE.

NOTE [[Set]] for proxy objects enforces the following invariants:

-   Cannnot change the value of a property to be different from the
      value of the corresponding target object property if the
      corresponding target object property is a non-writable,
      non-configurable data property.

-   Cannot set the value of a property if the corresponding
      corresponding target object property is a non-configurable
      accessor property that has UNDEFINED as its [[Set]] attribute.

[[Invoke]] (P, ArgumentsList, Receiver)

When the [[Invoke]] internal method of an exotic Proxy object O is
called with property key P, List ArgumentsList, and ECMAScript
language value Receiver the following steps are taken:

1.  Assert: IsPropertyKey(P) is TRUE..

2.  Let handler be the value of the [[ProxyHandler]] internal data
    property of O.

3.  Let target be the value of the [[ProxyTarget]] internal data
    property of O.

4.  Let trap be the result of GetMethod(handler, "INVOKE").

5.  ReturnIfAbrupt(trap).

6.  If trap is UNDEFINED, then

    a.  Return the result of calling the [[Invoke]] internal method of
        target with arguments P, ArgumentsList, and Receiver.

7.  Let argArray be the result of
    CreateArrayFromList(ArgumentsList).

8.  Return the result of calling the [[Call]] internal method of trap
    with handler as the THIS value and a new List containing target,
    P, argArray, and Receiver.

NOTE There are no invariants enforced for [[Invoke]].

[[Delete]] (P)

When the [[Delete]] internal method of an exotic Proxy object O is
called with property name P the following steps are taken:

1.  Assert: IsPropertyKey(P) is TRUE.

2.  Let handler be the value of the [[ProxyHandler]] internal data
    property of O.

3.  Let target be the value of the [[ProxyTarget]] internal data
    property of O.

4.  Let trap be the result of GetMethod(handler, "DELETEPROPERTY").

5.  ReturnIfAbrupt(trap).

6.  If trap is UNDEFINED, then

    a.  Return the result of calling the [[Delete]] internal method of
        target with argument P.

7.  Let trapResult be the result of calling the [[Call]] internal
    method of trap with handler as the THIS value and a new List
    containing target and P.

8.  ReturnIfAbrupt(trapResult).

9.  If ToBoolean(trapResult) is FALSE, then return FALSE.

10. Let targetDesc be the result of calling the [[GetOwnProperty]]
    internal method of target with argument P.

11. ReturnIfAbrupt(targetDesc).

12. If targetDesc is UNDEFINED, then return TRUE.

13. If targetDesc.[[Configurable]] is FALSE, then throw a TYPEERROR
    exception.

14. Return TRUE.

NOTE [[Delete]] for proxy objects enforces the following invariant:

-   A property cannot be deleted, if it exists as a non-configurable own
      property of the target object.

1.  2.  3.  4.  5.  6.  a.  

7.  8.  

9.  10. 11. 12. 13. 14. 15. 16. 

17. 

    a.  b.  

18. a.  

    b.  

19. 

-   -   -   

-   

[[Enumerate]] ()

When the [[Enumerate]] internal method of an exotic Proxy object O is
called the following steps are taken:

1.  Let handler be the value of the [[ProxyHandler]] internal data
    property of O.

2.  Let target be the value of the [[ProxyTarget]] internal data
    property of O.

3.  Let trap be the result of GetMethod(handler, "ENUMERATE").

4.  ReturnIfAbrupt(trap).

5.  If trap is UNDEFINED, then

    a.  Return the result of calling the [[Enumerate]] internal method
        of target.

6.  Let trapResult be the result of calling the [[Call]] internal
    method of trap with handler as the THIS value and a new List
    containing target.

7.  ReturnIfAbrupt(trapResult).

8.  If Type(trapResult) is not Object, then throw a TYPEERROR
    exception.

TODO: we may need to add a lot of additional invariant checking here
according to the wiki spec. But maybe it really isn’t necessary. Tomvc
response: I think it may be possible to waive the extra invariant checks
for [[Enumerate]]. It's not a crucial primitive. My reasoning is that
[[Enumerate]] deals with both own and inherited properties, and we don't
really enforce any invariants on inherited properties. So I guess it's
ok if the invariants for [[Enumerate]] are weakened.

Do note that this is a bit inconsistent with the way we treat internal
methods like [[HasProperty]], [[GetP]] and [[SetP]]: these also deal
with own and inherited properties, but still enforce invariants on own
properties.

1.  Return trapResult.

NOTE [[Enumerate]] for proxy objects enforces the following invariants:

-   The result of [[Enumerate]] must be an Object.

1.  2.  3.  4.  5.  a.  

6.  7.  8.  9.  10. 

-   

[[OwnPropertyKeys]] ( )

When the [[OwnPropertyKeys]] internal method of an exotic Proxy object
O is called the following steps are taken:

1.  Let handler be the value of the [[ProxyHandler]] internal data
    property of O.

2.  Let target be the value of the [[ProxyTarget]] internal data
    property of O.

3.  Let trap be the result of GetMethod(handler, "OWNKEYS").

4.  ReturnIfAbrupt(trap).

5.  If trap is UNDEFINED, then

    a.  Return the result of calling the [[OwnPropertyKeys]] internal
        method of target.

6.  Let trapResult be the result of calling the [[Call]] internal
    method of trap with handler as the THIS value and a new List
    containing target.

7.  ReturnIfAbrupt(trapResult).

8.  If Type(trapResult) is not Object, then throw a TYPEERROR
    exception.

9.  TODO: we may need to add a lot of additional invariant checking here
    according to the wiki spec. But maybe it really isn’t necessary

10. Return trapResult.

NOTE [[OwnPropertyKeys]] for proxy objects enforces the following
invariants:

-   The result of [[OwnPropertyKeys]] must be an Object.

1.  

1.  

1.  

1.  

[[Call]] (thisArgument, argumentsList) 

The [[Call]] internal method of an exotic Proxy object O is called
with parameters thisArgument and argumentsList, a List of ECMAScript
language values. The following steps are taken:

1.  Let handler be the value of the [[ProxyHandler]] internal data
    property of O.

2.  Let target be the value of the [[ProxyTarget]] internal data
    property of O.

3.  Let trap be the result of GetMethod(handler, "APPLY").

4.  ReturnIfAbrupt(trap).

5.  If trap is UNDEFINED, then

    a.  Return the result of calling the [[Call]] internal method of
        target with arguments thisArgument and argumentsList.

6.  Let argArray be the result of
    CreateArrayFromList(argumentsList).

7.  Return the result of calling the [[Call]] internal method of trap
    with handler as the THIS value and a new List containing target,
    thisArgument, and argArray.

NOTE An Proxy exotic object only has a [[Call]] internal method if the
initial value of its [[ProxyTarget]] internal data property is an object
that has a [[Call]] internal method.

[[Construct]] Internal Method

The [[Construct]] internal method of an exotic Proxy object O is
called with a single parameter argumentsList which is a possibly empty
List of ECMAScript language values. The following steps are taken:

1.  Let handler be the value of the [[ProxyHandler]] internal data
    property of O.

2.  Let target be the value of the [[ProxyTarget]] internal data
    property of O.

3.  Let trap be the result of GetMethod(handler, "CONSTRUCT").

4.  ReturnIfAbrupt(trap).

5.  If trap is UNDEFINED, then

    a.  Return the result of calling the [[Construct]] internal method
        of target with argument argumentsList.

6.  Let argArray be the result of
    CreateArrayFromList(argumentsList).

7.  Let newObj be the result of calling trap with handler as the
    THIS value and a new List containing target and argArray.

8.  ReturnIfAbrupt(newObj).

9.  If Type(newObj) is not Object, then throw a TYPEERROR exception.

10. Return newObj.

NOTE 1 An Proxy exotic object only has a [[Construct]] internal method
if the initial value of its [[ProxyTarget]] internal data property is an
object that has a [[Construct]] internal method.

NOTE 2 [[Construct]]] for proxy objects enforces the following
invariants:

-   The result of [[Construct]] must be an Object.

-   



ABSTRACT OPERATIONS 


These operations are not a part of the ECMAScript language; they are
defined here to solely to aid the specification of the semantics of the
ECMAScript language. Other, more specialized abstract operations are
defined throughout this specification.


Type Conversion and Testing

The ECMAScript language implicitly performs automatic type conversion as
needed. To clarify the semantics of certain constructs it is useful to
define a set of conversion abstract operations. The conversion abstract
operations are polymorphic; they can accept a value of any ECMAScript
language type or of a Completion Record value. But no other
specification types are used with these operations.

ToPrimitive

The abstract operation ToPrimitive takes an input argument and an
optional argument PreferredType. The abstract operation ToPrimitive
converts its input argument to a non-Object type. If an object is
capable of converting to more than one primitive type, it may use the
optional hint PreferredType to favour that type. Conversion occurs
according to Table 15:

Table 15 — ToPrimitive Conversions

  ------------------- --------------------------------------------------------------------------------------------------------------------------------------------------------------
  _INPUT TYPE_        RESULT
  Completion Record   If argument is an abrupt completion, return argument. Otherwise return ToPrimitive(argument.[[value]]) also passing the optional hint PreferredType.
  Undefined           Return argument (no conversion).
  Null                Return argument (no conversion).
  Boolean             Return argument (no conversion).
  Number              Return argument (no conversion).
  String              Return argument (no conversion).
  Object              Perform the steps following this table.
  ------------------- --------------------------------------------------------------------------------------------------------------------------------------------------------------

When the InputType is Object, the following steps are taken:

1.  If PreferredType was not passed, let hint be "DEFAULT".

2.  Else if PreferredType is hint String, let hint be "STRING".

3.  Else PreferredType is hint Number, let hint be "NUMBER".

4.  Let exoticToPrim be the result of Get(argument, @@ToPrimitive).

5.  ReturnIfAbrupt(exoticToPrim).

6.  If exoticToPrim is not UNDEFINED, then

    a.  If IsCallable(exoticToPrim) is FALSE, then throw a TYPEERROR
        exception.

    b.  Let result be the result of calling the [[Call]] internal
        method of exoticToPrim, with argument as thisArgument and
        a List containing hint as argumentsList.

    c.  ReturnIfAbrupt(result).

    d.  If result is an ECMAScript language value and Type(result)
        is not Object, then return result.

    e.  Else, throw a TYPEERROR exception.

7.  If hint is "DEFAULT" then, let hint be "NUMBER".

8.  Return the result of OrdinaryToPrimitive(argument,hint).

When the OrdinaryToPrimitive is called with arguments O and hint,
the following steps are taken:

1.  Assert: Type(O) is Object

2.  Assert: Type(hint) is String and its value is either "STRING" or
    "NUMBER".

3.  If hint is "STRING", then

    a.  Let tryFirst be "TOSTRING".

    b.  Let trySecond be "VALUEOF".

4.  Else,

    a.  Let tryFirst be "VALUEOF".

    b.  Let trySecond be "TOSTRING".

5.  Let first be the result of Get(O, tryFirst).

6.  ReturnIfAbrupt(first).

7.  If IsCallable(first) is TRUE then,

    a.  Let result be the result of calling the [[Call]] internal
        method of first, with O as thisArgument and an empty List
        as argumentsList.

    b.  ReturnIfAbrupt(result).

    c.  If result is an ECMAScript language value and Type(result)
        is not Object, then return result.

    d.  

8.  Let second be the result of Get(O, trySecond).

9.  ReturnIfAbrupt(second).

10. If IsCallable(second) is TRUE then,

    a.  Let result be the result of calling the [[Call]] internal
        method of second, with O as thisArgument and an empty List
        as argumentsList.

    b.  ReturnIfAbrupt(result).

    c.  If result is an ECMAScript language value and Type(result)
        is not Object, then return result.

11. Throw a TYPEERROR exception.

NOTE When ToPrimitive is called with no hint, then it generally behaves
as if the hint were Number. However, objects may over-ride this
behaviour by defining a @@ToPrimitive method. Of the objects defined in
this specification only Date objects (see 15.9.6) over-ride the default
ToPrimitive behaviour. Date objects treat no hint as if the hint were
String.

ToBoolean

The abstract operation ToBoolean converts its argument to a value of
type Boolean according to Table 16:

Table 16 — ToBoolean Conversions

  ------------------- --------------------------------------------------------------------------------------------------------------
  _ARGUMENT TYPE_     RESULT
  Completion Record   If argument is an abrupt completion, return the argument. Otherwise return ToBoolean(argument.[[value]])
  Undefined           Return FALSE
  Null                Return FALSE
  Boolean             Return the input argument (no conversion).
  Number              Return FALSE if the argument is +0, −0, or NAN; otherwise return TRUE.
  String              Return FALSE if the argument is the empty String (its length is zero); otherwise return TRUE.
  Object              Return TRUE
  ------------------- --------------------------------------------------------------------------------------------------------------

ToNumber

The abstract operation ToNumber converts its argument to a value of
type Number according to Table 17:

Table 17 — ToNumber Conversions

  ------------------- -----------------------------------------------------------------------------------------------------------
  _ARGUMENT TYPE_     RESULT

  Completion Record   If argument is an abrupt completion, return argument. Otherwise return ToNumber(argument.[[value]])

  Undefined           Return NAN

  Null                Return +0

  Boolean             Return 1 if argument is TRUE. Return +0 if argument is FALSE.

  Number              Return argument (no conversion).

  String              See grammar and note below.

  Object              Apply the following steps:
                      
                      Let primValue be ToPrimitive(argument, hint Number).
                      
                      Return ToNumber(primValue).
  ------------------- -----------------------------------------------------------------------------------------------------------

ToNumber Applied to the String Type

ToNumber applied to Strings applies the following grammar to the input
String. If the grammar cannot interpret the String as an expansion of
StringNumericLiteral, then the result of ToNumber is NAN.

Syntax

StringNumericLiteral :::

StrWhiteSpace~opt~
StrWhiteSpace~opt~ StrNumericLiteral StrWhiteSpace~opt~

StrWhiteSpace :::

StrWhiteSpaceChar StrWhiteSpace~opt~

StrWhiteSpaceChar :::

WhiteSpace
LineTerminator

StrNumericLiteral :::

StrDecimalLiteral
HexIntegerLiteral

StrDecimalLiteral :::

StrUnsignedDecimalLiteral
+ StrUnsignedDecimalLiteral
- StrUnsignedDecimalLiteral

StrUnsignedDecimalLiteral :::

INFINITY
 DecimalDigits . DecimalDigits~opt~ ExponentPart~opt~
. DecimalDigits ExponentPart~opt~
DecimalDigits ExponentPart~opt~

DecimalDigits :::

DecimalDigit
DecimalDigits DecimalDigit

DecimalDigit ::: ONE OF

0 1 2 3 4 5 6 7 8 9

ExponentPart :::

ExponentIndicator SignedInteger

ExponentIndicator ::: ONE OF

E E

SignedInteger :::

DecimalDigits
+ DecimalDigits
- DecimalDigits

HexIntegerLiteral :::

0X HexDigit
0X HexDigit
HexIntegerLiteral HexDigit

HexDigit ::: ONE OF

0 1 2 3 4 5 6 7 8 9 A B C D E F A B C D E F

NOTE Some differences should be noted between the syntax of a
StringNumericLiteral and a NumericLiteral (see 7.8.3):

-   A StringNumericLiteral may be preceded and/or followed by white
    space and/or line terminators.

-   A StringNumericLiteral that is decimal may have any number of
    leading 0 digits.

-   A StringNumericLiteral that is decimal may be preceded by + or -
    to indicate its sign.

-   A StringNumericLiteral that is empty or contains only white space
    is converted to +0.

-   INFINITY AND –INFINITY are recognised as a StringNumericLiteral
    but not as a NumericLiteral.

RUNTIME SEMANTICS

The conversion of a String to a Number value is similar overall to the
determination of the Number value for a numeric literal (see 7.8.3), but
some of the details are different, so the process for converting a
String numeric literal to a value of Number type is given here in full.
This value is determined in two steps: first, a mathematical value (MV)
is derived from the String numeric literal; second, this mathematical
value is rounded as described below.

-   The MV of StringNumericLiteral ::: [empty] is 0.

-   The MV of StringNumericLiteral ::: StrWhiteSpace is 0.

-   The MV of StringNumericLiteral ::: StrWhiteSpace~opt~
      StrNumericLiteral StrWhiteSpace~opt~ is the MV of
      StrNumericLiteral, no matter whether white space is present or
      not.

-   The MV of StrNumericLiteral ::: StrDecimalLiteral is the MV of
      StrDecimalLiteral.

-   The MV of StrNumericLiteral ::: HexIntegerLiteral is the MV of
      HexIntegerLiteral.

-   The MV of StrDecimalLiteral ::: StrUnsignedDecimalLiteral is the
      MV of StrUnsignedDecimalLiteral.

-   The MV of StrDecimalLiteral ::: + StrUnsignedDecimalLiteral is
      the MV of StrUnsignedDecimalLiteral.

-   The MV of StrDecimalLiteral ::: - StrUnsignedDecimalLiteral is
      the negative of the MV of StrUnsignedDecimalLiteral. (Note that
      if the MV of StrUnsignedDecimalLiteral is 0, the negative of
      this MV is also 0. The rounding rule described below handles the
      conversion of this signless mathematical zero to a floating-point
      +0 or −0 as appropriate.)

-   The MV of StrUnsignedDecimalLiteral::: INFINITY is 10^10000^ (a
      value so large that it will round to +∞).

-   The MV of StrUnsignedDecimalLiteral::: DecimalDigits. is the MV
      of DecimalDigits.

-   The MV of StrUnsignedDecimalLiteral::: DecimalDigits .
      DecimalDigits is the MV of the first DecimalDigits plus (the
      MV of the second DecimalDigits times 10^−n^), where n is the
      number of characters in the second DecimalDigits.

-   The MV of StrUnsignedDecimalLiteral::: DecimalDigits.
      ExponentPart is the MV of DecimalDigits times 10^e^, where
      e is the MV of ExponentPart.

-   The MV of StrUnsignedDecimalLiteral::: DecimalDigits.
      _DecimalDigits ExponentPart_ is (the MV of the first
      DecimalDigits plus (the MV of the second DecimalDigits times
      10^−n^)) times 10^e^, where n is the number of characters in
      the second DecimalDigits and e is the MV of ExponentPart.

-   The MV of StrUnsignedDecimalLiteral:::. DecimalDigits is the MV
      of DecimalDigits times 10^−n^, where n is the number of
      characters in DecimalDigits.

-   The MV of StrUnsignedDecimalLiteral:::. _DecimalDigits
      ExponentPart_ is the MV of DecimalDigits times 10^e_−_n^,
      where n is the number of characters in DecimalDigits and e
      is the MV of ExponentPart.

-   The MV of StrUnsignedDecimalLiteral::: DecimalDigits is the MV
      of DecimalDigits.

-   The MV of StrUnsignedDecimalLiteral::: DecimalDigits
      ExponentPart is the MV of DecimalDigits times 10^e^, where
      e is the MV of ExponentPart.

-   The MV of DecimalDigits ::: DecimalDigit is the MV of
      DecimalDigit.

-   The MV of DecimalDigits ::: DecimalDigits DecimalDigit is (the
      MV of DecimalDigits times 10) plus the MV of DecimalDigit.

-   The MV of ExponentPart ::: _ExponentIndicator SignedInteger_ is
      the MV of SignedInteger.

-   The MV of SignedInteger ::: DecimalDigits is the MV of
      DecimalDigits.

-   The MV of SignedInteger ::: + DecimalDigits is the MV of
      DecimalDigits.

-   The MV of SignedInteger ::: - DecimalDigits is the negative of
      the MV of DecimalDigits.

-   The MV of DecimalDigit ::: 0 or of HexDigit ::: 0 is 0.

-   The MV of DecimalDigit ::: 1 or of HexDigit ::: 1 is 1.

-   The MV of DecimalDigit ::: 2 or of HexDigit ::: 2 is 2.

-   The MV of DecimalDigit ::: 3 or of HexDigit ::: 3 is 3.

-   The MV of DecimalDigit ::: 4 or of HexDigit ::: 4 is 4.

-   The MV of DecimalDigit ::: 5 or of HexDigit ::: 5 is 5.

-   The MV of DecimalDigit ::: 6 or of HexDigit ::: 6 is 6.

-   The MV of DecimalDigit ::: 7 or of HexDigit ::: 7 is 7.

-   The MV of DecimalDigit ::: 8 or of HexDigit ::: 8 is 8.

-   The MV of DecimalDigit ::: 9 or of HexDigit ::: 9 is 9.

-   The MV of HexDigit ::: A or of HexDigit ::: A is 10.

-   The MV of HexDigit ::: B or of HexDigit ::: B is 11.

-   The MV of HexDigit ::: C or of HexDigit ::: C is 12.

-   The MV of HexDigit ::: D or of HexDigit ::: D is 13.

-   The MV of HexDigit ::: E or of HexDigit ::: E is 14.

-   The MV of HexDigit ::: F or of HexDigit ::: F is 15.

-   The MV of HexIntegerLiteral ::: 0X HexDigit is the MV of
      HexDigit.

-   The MV of HexIntegerLiteral ::: 0X HexDigit is the MV of
      HexDigit.

-   The MV of HexIntegerLiteral ::: HexIntegerLiteral HexDigit is
      (the MV of HexIntegerLiteral times 16) plus the MV of
      HexDigit.

Once the exact MV for a String numeric literal has been determined, it
is then rounded to a value of the Number type. If the MV is 0, then the
rounded value is +0 unless the first non white space character in the
String numeric literal is ‘-’, in which case the rounded value is −0.
Otherwise, the rounded value must be the Number value for the MV (in the
sense defined in 8.5), unless the literal includes a
StrUnsignedDecimalLiteral and the literal has more than 20 significant
digits, in which case the Number value may be either the Number value
for the MV of a literal produced by replacing each significant digit
after the 20th with a 0 digit or the Number value for the MV of a
literal produced by replacing each significant digit after the 20th with
a 0 digit and then incrementing the literal at the 20th digit position.
A digit is significant if it is not part of an ExponentPart and

-   it is not 0; or

-   there is a nonzero digit to its left and there is a nonzero digit,
    not in the ExponentPart, to its right.

ToInteger

The abstract operation ToInteger converts its argument to an integral
numeric value. This abstract operation functions as follows:

ToInt32: (Signed 32 Bit Integer)

The abstract operation ToInt32 converts its argument to one of 2^32^
integer values in the range −2^31^ through 2^31^−1, inclusive. This
abstract operation functions as follows:

1.  Let number be the result of calling ToNumber on the input
    argument.

2.  ReturnIfAbrupt(number).

3.  If number is NAN, +0, −0, +∞, or −∞, return +0.

4.  Let int be sign(number) × floor(abs(number)).

5.  Let int32bit be int modulo 2^32^.

6.  If int32bit ≥ 2^31^, return int32bit − 2^32^, otherwise return
    int32bit.

NOTE Given the above definition of ToInt32:

-   The ToInt32 abstract operation is idempotent: if applied to a result
      that it produced, the second application leaves that value
      unchanged.

-   ToInt32(ToUint32(x)) is equal to ToInt32(x) for all values of
      x. (It is to preserve this latter property that +∞ and −∞ are
      mapped to +0.)

-   ToInt32 maps −0 to +0.

ToUint32: (Unsigned 32 Bit Integer)

The abstract operation ToUint32 converts its argument to one of 2^32^
integer values in the range 0 through 2^32^−1, inclusive. This abstract
operation functions as follows:

NOTE Given the above definition of ToUint32:

-   Step 6 is the only difference between ToUint32 and ToInt32.

-   The ToUint32 abstract operation is idempotent: if applied to a
      result that it produced, the second application leaves that value
      unchanged.

-   ToUint32(ToInt32(x)) is equal to ToUint32(x) for all values of
      x. (It is to preserve this latter property that +∞ and −∞ are
      mapped to +0.)

-   ToUint32 maps −0 to +0.

ToUint16: (Unsigned 16 Bit Integer)

The abstract operation ToUint16 converts its argument to one of 2^16^
integer values in the range 0 through 2^16^−1, inclusive. This abstract
operation functions as follows:

NOTE Given the above definition of ToUint16:

-   The substitution of 2^16^ for 2^32^ in step 4 is the only difference
      between ToUint32 and ToUint16.

-   ToUint16 maps −0 to +0.

ToString

The abstract operation ToString converts its argument to a value of
type String according to Table 18:

Table 18 — ToString Conversions

  ------------------- -----------------------------------------------------------------------------------------------------------
  _ARGUMENT TYPE_     RESULT

  Completion Record   If argument is an abrupt completion, return argument. Otherwise return ToString(argument.[[value]])

  Undefined           "UNDEFINED"

  Null                "NULL"

  Boolean             If argument is TRUE, then return "TRUE".
                      
                      If argument is FALSE, then return "FALSE".

  Number              See 9.8.1.

  String              Return argument (no conversion)

  Object              Apply the following steps:
                      
                      1. Let primValue be ToPrimitive(argument, hint String).
                      
                      2. Return ToString(primValue).
  ------------------- -----------------------------------------------------------------------------------------------------------

ToString Applied to the Number Type

The abstract operation ToString converts a Number m to String format
as follows:

1.  If m is NAN, return the String "NAN".

2.  If m is +0 or −0, return the String "0".

3.  If m is less than zero, return the String concatenation of the
    String "-" and ToString(−m).

4.  If m is +∞, return the String "INFINITY".

5.  Otherwise, let n, k, and s be integers such that k ≥ 1,
    10^k−1^ ≤ s < 10^k^, the Number value for s × 10^n−k^ is
    m, and k is as small as possible. Note that k is the number of
    digits in the decimal representation of s, that s is not
    divisible by 10, and that the least significant digit of s is not
    necessarily uniquely determined by these criteria.

6.  If k ≤ n ≤ 21, return the String consisting of the k digits of
    the decimal representation of s (in order, with no leading
    zeroes), followed by n−k occurrences of the character ‘0’.

7.  If 0 < n ≤ 21, return the String consisting of the most
    significant n digits of the decimal representation of s,
    followed by a decimal point ‘.’, followed by the remaining k−n
    digits of the decimal representation of s.

8.  If −6 < n ≤ 0, return the String consisting of the character ‘0’,
    followed by a decimal point ‘.’, followed by −n occurrences of the
    character ‘0’, followed by the k digits of the decimal
    representation of s.

9.  Otherwise, if k = 1, return the String consisting of the single
    digit of s, followed by lowercase character ‘E’, followed by a
    plus sign ‘+’ or minus sign ‘−’ according to whether n−1 is
    positive or negative, followed by the decimal representation of the
    integer abs(n−1) (with no leading zeroes).

10. Return the String consisting of the most significant digit of the
    decimal representation of s, followed by a decimal point ‘.’,
    followed by the remaining k−1 digits of the decimal representation
    of s, followed by the lowercase character ‘E’, followed by a plus
    sign ‘+’ or minus sign ‘−’ according to whether n−1 is positive or
    negative, followed by the decimal representation of the integer
    abs(n−1) (with no leading zeroes).

NOTE 1 The following observations may be useful as guidelines for
implementations, but are not part of the normative requirements of this
Standard:

-   If x is any Number value other than −0, then ToNumber(ToString(x))
      is exactly the same Number value as x.

-   The least significant digit of s is not always uniquely determined
      by the requirements listed in step 5.

NOTE 2 For implementations that provide more accurate conversions than
required by the rules above, it is recommended that the following
alternative version of step 5 be used as a guideline:

  Otherwise, let n, k, and s be integers such that k ≥ 1,
  10^k−1^ ≤ s < 10^k^, the Number value for s × 10^n_−_k^ is
  m, and k is as small as possible. If there are multiple
  possibilities for s, choose the value of s for which s ×
  10^n_−_k^ is closest in value to m. If there are two such possible
  values of s, choose the one that is even. Note that k is the
  number of digits in the decimal representation of s and that s is
  not divisible by 10.

NOTE 3 Implementers of ECMAScript may find useful the paper and code
written by David M. Gay for binary-to-decimal conversion of
floating-point numbers:

  Gay, David M. Correctly Rounded Binary-Decimal and Decimal-Binary
  Conversions. Numerical Analysis, Manuscript 90-10. AT&T Bell
  Laboratories (Murray Hill, New Jersey). November 30, 1990. Available
  as
  http://cm.bell-labs.com/cm/cs/doc/90/4-10.ps.gz. Associated code
  available as
  http://netlib.sandia.gov/fp/dtoa.c and as
  http://netlib.sandia.gov/fp/g_fmt.c and may also be found at the
  various NETLIB mirror sites.

ToObject

The abstract operation ToObject converts its argument to a value of
type Object according to Table 19:

Table 19 — ToObject Conversions

  ------------------- ------------------------------------------------------------------------------------------------------------------------------------------------------------
  _ARGUMENT TYPE_     RESULT
  Completion Record   If argument is an abrupt completion, return argument. Otherwise return ToObject(argument.[[value]])
  Undefined           Throw a TYPEERROR exception.
  Null                Throw a TYPEERROR exception.
  Boolean             Return a new Boolean object whose [[BooleanData]] internal data property is set to the value of argument. See 15.6 for a description of Boolean objects.
  Number              Return a new Number object whose [[NumberData]] internal data property is set to the value of argument. See 15.7 for a description of Number objects.
  String              Return a new String object whose [[StringData]] internal data property is set to the value of argument. See 15.5 for a description of String objects.
  Object              Return argument (no conversion).
  ------------------- ------------------------------------------------------------------------------------------------------------------------------------------------------------

ToPropertyKey 

The abstract operation ToPropertyKey converts its argument to a value
that can be used as a property key by performing the following steps:

1.  ReturnIfAbrupt(argument).

2.  If argument is an exotic Symbol Object, then

    a.  b.  Return argument.

3.  Return ToString(argument).

ToLength 

The abstract operation ToLength converts its argument to an integer
suitable for use as the length of an array-like object. It performs the
following steps:

1.  Let len be ToInteger(argument).

2.  ReturnIfAbrupt(len).

3.  If len ≤ 0, then return 0.

4.  Return min(len, 2^53^-1).


Testing and Comparison Operations

CheckObjectCoercible

The abstract operation CheckObjectCoercible throws an error if its
argument is a value that cannot be converted to an Object using
ToObject. It is defined by Table 20:

Table 20 — CheckObjectCoercible Results

  _ARGUMENT TYPE_     RESULT
  ------------------- -----------------------------------------------------------------------------------------------------------------------
  Completion Record   If argument is an abrupt completion, return argument. Otherwise return CheckObjectCoercible(argument.[[value]])
  Undefined           Throw a TYPEERROR exception.
  Null                Throw a TYPEERROR exception.
  Boolean             Return argument
  Number              Return argument
  String              Return argument
  Object              Return argument

IsCallable

The abstract operation IsCallable determines if its argument, which
must be an ECMAScript language value or a Completion Record, is a
callable function Object according to Table 21:

Table 21 — IsCallable Results

  ------------------- -------------------------------------------------------------------------------------------------------------
  _ARGUMENT TYPE_     RESULT
  Completion Record   If argument is an abrupt completion, return argument. Otherwise return IsCallable(argument.[[value]])
  Undefined           Return FALSE.
  Null                Return FALSE.
  Boolean             Return FALSE.
  Number              Return FALSE.
  String              Return FALSE.
  Object              If argument has a [[Call]] internal method, then return TRUE, otherwise return FALSE.
  ------------------- -------------------------------------------------------------------------------------------------------------

SameValue(x, y)

The internal comparison abstract operation SameValue(x, y), where
x and y are ECMAScript language values, produces TRUE or FALSE. Such
a comparison is performed as follows:

SameValueZero(x, y)

The internal comparison abstract operation SameValueZero(x, y),
where x and y are ECMAScript language values, produces TRUE or
FALSE. Such a comparison is performed as follows:

1.  ReturnIfAbrupt(x).

2.  ReturnIfAbrupt(y).

3.  If Type(x) is different from Type(y), return FALSE.

4.  If Type(x) is Undefined, return TRUE.

5.  If Type(x) is Null, return TRUE.

6.  If Type(x) is Number, then

    a.  If x is NaN and y is NaN, return TRUE.

    b.  If x is +0 and y is -0, return TRUE.

    c.  If x is -0 and y is +0, return TRUE.

    d.  If x is the same Number value as y, return TRUE.

    e.  Return FALSE.

7.  If Type(x) is String, then

    a.  If x and y are exactly the same sequence of code units (same
        length and same code units in corresponding positions) return
        TRUE; otherwise, return FALSE.

8.  If Type(x) is Boolean, then

    a.  If x and y are both TRUE or both FALSE, then return TRUE;
        otherwise, return FALSE.

9.  Return TRUE if x and y are the same Object value. Otherwise,
    return FALSE.

NOTE SameValueZero differs from SameValue only in its treatment of +0
and -0.

IsConstructor

The abstract operation IsConstructor determines if its argument, which
must be an ECMAScript language value or a Completion Record, is a
function object with a [[Construct]] internal method.

1.  ReturnIfAbrupt(argument).

2.  If Type(argument) is not Object, return FALSE.

3.  If argument has a [[Construct]] internal method, return TRUE.

4.  Return FALSE.

IsPropertyKey

The abstract operation IsPropertyKey determines if its argument, which
must be an ECMAScript language value or a Completion Record, is a value
that may be used as a property key.

1.  ReturnIfAbrupt(argument).

2.  If Type(argument) is String, return TRUE.

3.  If Type(argument) is Object and argument is an exotic Symbol
    object, return TRUE.

4.  Return FALSE.

IsExtensible (O)

The abstract operation IsExtensible is used to determine whether
additional properties can be added to the object that is O. A Boolean
value is returned. This abstract operation performs the following steps:

1.  Assert: Type(O) is Object.

2.  Return the result of calling the [[IsExtensible]] internal method of
    O.

3.  4.  


 Operations on Objects

Get (O, P)

The abstract operation Get is used to retrieve the value of a specific
property of an object. The operation is called with arguments O and
P where O is the object and P is the property key. This abstract
operation performs the following steps:

1.  Assert: Type(O) is Object.

2.  Assert: IsPropertyKey(P) is TRUE.

3.  Return the result of calling the [[Get]] internal method of O
    passing P and O as the arguments.

Put (O, P, V, Throw)

The abstract operation Put is used to set the value of a specific
property of an object. The operation is called with arguments O, P,
V, and Throw where O is the object, P is the property key, V
is the new value for the property and Throw is a Boolean flag. This
abstract operation performs the following steps:

1.  Assert: Type(O) is Object.

2.  Assert: IsPropertyKey(P) is TRUE.

3.  Assert: Type(Throw) is Boolean.

4.  Let success be the result of calling the [[Set]] internal method
    of O passing P, V, and O as the arguments.

5.  ReturnIfAbrupt(success).

6.  If success is FALSE and Throw is TRUE, then throw a TYPEERROR
    exception.

7.  Return success.

CreateOwnDataProperty (O, P, V)

The abstract operation CreateOwnDataProperty is used to create a new own
property of an object. The operation is called with arguments O, P,
and V where O is the object, P is the property key, and V is the
value for the property. This abstract operation performs the following
steps:

1.  Assert: Type(O) is Object.

2.  Assert: IsPropertyKey(P) is TRUE.

3.  Assert: O does not have an own property whose key is P.

4.  5.  6.  7.  Let newDesc be the Property Descriptor {[[Value]]:
    V, [[Writable]]: TRUE, [[Enumerable]]: TRUE, [[Configurable]]:
    TRUE}.

8.  Return the result of calling the [[DefineOwnProperty]] internal
    method of O passing P and newDesc as arguments.

NOTE This abstract operation creates a property whose attributes are set
to the same defaults used for properties created by the ECMAScript
language assignment operator.

DefinePropertyOrThrow (O, P, desc)

The abstract operation DefinePropertyOrThrow is used to call the
[[DefineOwnProperlty]] internal method of an object in a manner that
will throw a TYPEERROR exception if the requested property update cannot
be performed. The operation is called with arguments O, P, and
desc where O is the object, P is the property key, and desc is
the Property Descriptor for the property. This abstract operation
perform, the following steps:

1.  Assert: Type(O) is Object.

2.  Assert: IsPropertyKey(P) is TRUE.

3.  Let success be the result of calling the [[DefineOwnProperty]]
    internal method of O passing P and desc as arguments.

4.  ReturnIfAbrupt(success).

5.  If success is FALSE, then throw a TYPEERROR exception.

6.  Return success.

DeletePropertyOrThrow (O, P)

The abstract operation DeletePropertyOrThrow is used to remove a
specific own property of an object. It throws an exception if the
property is not configurable. The operation is called with arguments O
and P where O is the object and P is the property key. This
abstract operation performs the following steps:

1.  Assert: Type(O) is Object.

2.  Assert: IsPropertyKey(P) is TRUE.

3.  Let success be the result of calling the [[Delete]] internal
    method of O passing P as the argument.

4.  ReturnIfAbrupt(success).

5.  If success is FALSE, then throw a TYPEERROR exception.

6.  Return success.

HasProperty (O, P)

The abstract operation HasProperty is used to determine whether an
object has a property with the specified property key. The property may
be either an own or inherited. A Boolean value is returned. The
operation is called with arguments O and P where O is the object
and P is the property key. This abstract operation performs the
following steps:

1.  Assert: Type(O) is Object.

2.  Assert: IsPropertyKey(P) is TRUE.

3.  4.  a.  b.  c.  d.  e.  f.  

5.  Return the result of calling the [[HasProperty]] internal method of
    O with argument P.

GetMethod (O, P)

The abstract operation GetMethod is used to get the value of a specific
property of an object when the value of the property is expected to be a
function. The operation is called with arguments O and P where O
is the object, P is the property key. This abstract operation performs
the following steps:

1.  Assert: Type(O) is Object.

2.  Assert: IsPropertyKey(P) is TRUE.

3.  Let func be the result of calling the [[Get]] internal method of
    O passing P and O as the arguments.

4.  ReturnIfAbrupt(func).

5.  If func is UNDEFINED, then return UNDEFINED.

6.  If IsCallable(func) is FALSE, then throw a TYPEERROR exception.

7.  Return func.

Invoke(O,P, [args])

The abstract operation Invoke is used to call a method property of an
object. The operation is called with arguments O, P , and optionally
args where O serves as both the lookup point for the property and
the THIS value of the call, P is the property key, and args is the
list of arguments values passed to the method. If args is not present,
an empty List is used as its value. This abstract operation performs the
following steps:

1.  Assert: P is a valid property key.

2.  If args was not passed, then let args be a new empty List.

3.  If Type(O) is Object then,

    a.  Let base be O.

4.  Else,

    a.  Let base be ToObject(O).

5.  ReturnIfAbrupt(base).

6.  7.  8.  9.  Return the result of calling the [[Invoke]] internal
    method of base passing arguments P, args, and O.

SetIntegrityLevel (O, level)

The abstract operation SetIntegrityLevel is used to fix the set of own
properties of an object. This abstract operation performs the following
steps:

1.  Assert: Type(O) is Object.

2.  3.  Assert: level is either "SEALED" or "FROZEN".

4.  Let keys be the result of calling the [[OwnPropertyKeys]] internal
    method of O.

5.  ReturnIfAbrupt(keys).

6.  Let pendingException be UNDEFINED.

7.  If level is "SEALED", then

    a.  Repeat for each element k of keys,

        i.  Let status be the result of DefinePropertyOrThrow(O,
            k, PropertyDescriptor{ [[Configurable]]: FALSE}).

        ii. If status is an abrupt completion, then

            1.  If pendingException is UNDEFINED, then set
                pendingException to status.

8.  Else level is "FROZEN",

    a.  Repeat for each element k of keys,

        i.  Let status be the result of calling the [[GetOwnProperty]]
            internal method of O with k.

        ii. If status is an abrupt completion, then

            1.  If pendingException is UNDEFINED, then set
                pendingException to status.

        iii. Else,

            1.  Let currentDesc be status.[[value]].

            2.  If currentDesc is not UNDEFINED, then

                a.  If IsAccessorDescriptor(currentDesc) is TRUE, then

                    i.  Let desc be
                        PropertyDescriptor{[[Configurable]]: FALSE}.

                b.  Else,

                    i.  Let desc be PropertyDescriptor {
                        [[Configurable]]: FALSE, [[Writable]]: FALSE }.

                c.  Let status be the result of
                    DefinePropertyOrThrow(O, k, desc).

                d.  If status is an abrupt completion, then

                    i.  If pendingException is UNDEFINED, then set
                        pendingException to status.

9.  If pendingException is not UNDEFINED, then return
    pendingException.

10. Return the result of calling the [[PreventExtensions]] internal
    method of O.

TestIntegrityLevel (O, level)

The abstract operation TestIntegrityLevel is used to determine if the
set of own properties of an object are fixed. This abstract operation
performs the following steps:

1.  Assert: Type(O) is Object.

2.  Assert: level is either "SEALED" or "FROZEN".

3.  4.  Let status be the result of IsExtensible(O).

5.  ReturnIfAbrupt(status).

6.  If status is TRUE, then return FALSE

7.  NOTE If the object is extensible, none of its properties are
    examined.

8.  Let keys be the result of calling the [[OwnPropertyKeys]] internal
    method of O.

9.  ReturnIfAbrupt(keys).

10. Let pendingException be UNDEFINED.

11. 12. Let configurable be FALSE.

13. Let writable be FALSE.

14. Repeat for each element k of keys,

    a.  Let status be the result of calling the [[GetOwnProperty]]
        internal method of O with k.

    b.  If status is an abrupt completion, then

        i.  If pendingException is UNDEFINED, then set
            pendingException to status.

        ii. Let configurable be TRUE.

    c.  Else,

        i.  Let currentDesc be status.[[value]].

        ii. If currentDesc is not UNDEFINED, then

            1.  Set configurable to configurable logically ored with
                currentDesc.[[Configurable]].

            2.  If IsDataDescriptor(currentDesc) is TRUE, then

                a.  Set writable to writable logically ored with
                    currentDesc.[[Writable]].

15. If pendingException is not UNDEFINED, then return
    pendingException.

16. If level is "FROZEN" and writable is TRUE, then return FALSE.

17. If configurable is TRUE, then return FALSE.

18. Return TRUE.

CreateArrayFromList (elements)

The abstract operation CreateArrayFromList is used to create an Array
object whose elements are provided by an internal List. This abstract
operation performs the following steps:

1.  Assert: elements is a List whose elements are all ECMAScript
    language values.

2.  Let array be the result of the abstract operation ArrayCreate with
    argument 0.

3.  Let n be 0.

4.  For each element e of elements

    a.  Let status be the result of CreateOwnDataProperty(array,
        ToString(n), e).

    b.  Assert: status is TRUE.

    c.  Increment n by 1.

5.  Return array.

CreateListFromArrayLike (obj)

The abstract operation CreateListFromArrayLike is used to create a List
value whose elements are provided by the indexed properties of an
Array-like Object. This abstract operation performs the following steps:

OrdinaryHasInstance (C, O)

The abstract operation OrdinaryHasInstance implements the default
algorithm for determining if an object O inherits from the instance
object inheritance path provided by constructor C. This abstract
operation performs the following steps:

GetPrototypeFromConstructor ( constructor, intrinsicDefaultProto )

The abstract operation GetPrototypeFromConstructor determines the
[[Prototype]] value that should be used to create an object
corresponding to a specific constructor. The value is retrieved from the
constructor’s PROTOTYPE property, if it exists. Otherwise the supplied
default is used for [[Prototype]]. This abstract operation performs the
following steps:

1.  Assert: intrinsicDefaultProto is a string value that is this
    specification’s name of an intrinsic object. The corresponding
    object must be an intrinsic that is intended to be used as the
    [[Prototype]] value of an object.

2.  If IsConstructor (constructor) is FALSE, then throw a TYPEERROR
    exception.

3.  Let proto be the result of Get(constructor, "PROTOTYPE").

4.  ReturnIfAbrupt(proto).

5.  If Type(proto) is not Object, then

    a.  If constructor has a [[Realm]] internal data property, let
        realm be constructor’s [[Realm]].

    b.  Else,

        i.  Let ctx be the running execution context.

        ii. Let realm be ctx’s Realm.

    c.  Let proto be realm’s intrinsic object named
        intrinsicDefaultProto.

6.  Return proto.

NOTE If constructor does not supply a [[Prototype]] value, the default
value that is used is obtained from the Code Realm of the constructor
function rather than from the running execution context. This accounts
for the possibility that a built-in @@create method from a different
Code Realm might be installed on constructor.

OrdinaryCreateFromConstructor ( constructor, intrinsicDefaultProto, internalDataList )

The abstract operation OrdinaryCreateFromConstructor creates an ordinary
object whose [[Prototype]] value is retrieved from a constructor’s
PROTOTYPE property, if it exists. Otherwise the supplied default is used
for [[Prototype]]. The optional internalDataList is a List of the
names of internal data property names that should be defined as part of
the object. If the list is not provided, an empty List is used. This
abstract operation performs the following steps:

1.  Assert: intrinsicDefaultProto is a string value that is this
    specification’s name of an intrinsic object. The corresponding
    object must be an intrinsic that is intended to be used as the
    [[Prototype]] value of an object.

2.  3.  4.  5.  a.  b.  i.  ii. 

    c.  

6.  Let proto be the result of
    GetPrototypeFromConstructor(constructor, intrinsicDefaultProto).

7.  ReturnIfAbrupt(proto).

8.  Return the result of the abstract operation ObjectCreate(proto,
    internalDataList).



EXECUTABLE CODE AND EXECUTION CONTEXTS


Types of Executable Code

There are four types of ECMAScript executable code:

-   _Global code_ is source text that is treated as an ECMAScript
      Script. The global code of a particular Script does not
      include any source text that is parsed as part of a
      FunctionBody, GeneratorBody, ConciseBody, ClassBody, or
      ModuleBody.

-   _Eval code_ is the source text supplied to the built-in EVAL
      function. More precisely, if the parameter to the built-in EVAL
      function is a String, it is treated as an ECMAScript Script. The
      eval code for a particular invocation of EVAL is the global code
      portion of that Script.

-   _Function code_ is source text that is parsed to supply the value of
      the [[Code]] internal data property (see 8.3.15) of function and
      generator objects. The _function code_ of a particular function or
      generator does not include any source text that is parsed as the
      function code of a nested FunctionBody, GeneratorBody,
      ConciseBody, or ClassBody.

-   -   _Module code_ is source text that is parse code that is provided
      as a ModuleBody. It is the code that is directly evaluated when
      a module is initialised. The module code of a particular module
      does not include any source text that is parsed as part of a
      nested FunctionBody, GeneratorBody, ConciseBody,
      ClassBody, or ModuleBody.

NOTE Function code is generally provided as the bodies of Function
Definitions (13.1), Arrow Function Definitions (13.2), Method
Definitions (13.3) and Generator Definitions (13.4). Function code is
also derived from the last argument to the Function constructor (15.3).

Strict Mode Code

An ECMAScript Script syntactic unit may be processed using either
unrestricted or strict mode syntax and semantics. When processed using
strict mode the four types of ECMAScript code are referred to as module
code, strict global code, strict eval code, and strict function code.
Code is interpreted as strict mode code in the following situations:

-   Global code is strict global code if it begins with a Directive
      Prologue that contains a Use Strict Directive (see 14.1).

-   Module code is always strict code.

-   A ClassDeclaration or a ClassExpression is always strict code.

-   Eval code is strict eval code if it begins with a Directive Prologue
      that contains a Use Strict Directive or if the call to eval is a
      direct call (see 15.1.2.1.1) to the eval function that is
      contained in strict mode code.

-   Function code that is part of a FunctionDeclaration,
      FunctionExpression, or accessor PropertyDefinition is strict
      function code if its FunctionDeclaration, FunctionExpression,
      or PropertyDefinition is contained in strict mode code or if the
      function code begins with a Directive Prologue that contains a Use
      Strict Directive.

-   Function code that is supplied as the last argument to the built-in
      Function constructor is strict function code if the last argument
      is a String that when processed as a FunctionBody begins with a
      Directive Prologue that contains a Use Strict Directive.

-   

-   -   -   -   -   

Non-ECMAScript Functions

An ECMAScript implementation may support the evaluation of function
objects whose evaluative behaviour is expressed in some implementation
defined form of executable code other than via ECMAScript code. Whether
a function object is an ECMAScript code function or a non-ECMAScript
function is not semantically observable from the perspective of an
ECMAScript code function that calls or is called by such a
non-ECMAScript function.


Lexical Environments

A _Lexical Environment_ is a specification type used to define the
association of Identifiers to specific variables and functions based
upon the lexical nesting structure of ECMAScript code. A Lexical
Environment consists of an Environment Record and a possibly null
reference to an outer Lexical Environment. Usually a Lexical
Environment is associated with some specific syntactic structure of
ECMAScript code such as a FunctionDeclaration, a BlockStatement, or
a Catch clause of a TryStatement and a new Lexical Environment is
created each time such code is evaluated.

An _Environment Record_ records the identifier bindings that are created
within the scope of its associated Lexical Environment.

The outer environment reference is used to model the logical nesting of
Lexical Environment values. The outer reference of a (inner) Lexical
Environment is a reference to the Lexical Environment that logically
surrounds the inner Lexical Environment. An outer Lexical Environment
may, of course, have its own outer Lexical Environment. A Lexical
Environment may serve as the outer environment for multiple inner
Lexical Environments. For example, if a FunctionDeclaration contains
two nested FunctionDeclarations then the Lexical Environments of each
of the nested functions will have as their outer Lexical Environment the
Lexical Environment of the current evaluation of the surrounding
function.

A _global environment_ is a Lexical Environment which does not have an
outer environment. The global environment’s outer environment reference
is NULL. A global environment’s environment record may be prepopulated
with identifier bindings and includes an associated _global object_
whose properties provide some of the global environment’s identifier
bindings. This global object is the value of a global environment’s THIS
binding. As ECMAScript code is executed, additional properties may be
added to the global object and the initial properties may be modified.

A method environment is a Lexical Environment that corresponds to the
invocation of an ECMAScript function object that establishes a new THIS
binding. A method environment also captures the state necessary to
support SUPER method invocations.

Lexical Environments and Environment Record values are purely
specification mechanisms and need not correspond to any specific
artefact of an ECMAScript implementation. It is impossible for an
ECMAScript program to directly access or manipulate such values.

Environment Records

There are two primary kinds of Environment Record values used in this
specification: _declarative environment records_ and _object environment
records_. Declarative environment records are used to define the effect
of ECMAScript language syntactic elements such as
FunctionDeclarations, VariableDeclarations, and Catch clauses that
directly associate identifier bindings with ECMAScript language values.
Object environment records are used to define the effect of ECMAScript
elements such as WithStatement that associate identifier bindings with
the properties of some object. Global Environment Records and Function
Environment Records are specializations that are used for specifically
for Script global declarations and for top-level declarations within
functions.

For specification purposes Environment Record values can be thought of
as existing in a simple object-oriented hierarchy where Environment
Record is an abstract class with three concrete subclasses, declarative
environment record, object environment record, and global environment
record. Function environment records are a subclass of declarative
environment record. The abstract class includes the abstract
specification methods defined in Table 22. These abstract methods have
distinct concrete algorithms for each of the concrete subclasses.

Table 22 — Abstract Methods of Environment Records

  METHOD                     PURPOSE
  ---------------------------- --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  HasBinding(N)                Determine if an environment record has a binding for an identifier. Return TRUE if it does and FALSE if it does not. The String value N is the text of the identifier.
  CreateMutableBinding(N, D)   Create a new but uninitialised mutable binding in an environment record. The String value N is the text of the bound name. If the optional Boolean argument D is TRUE the binding is may be subsequently deleted.
  CreateImmutableBinding(N)    Create a new but uninitialised immutable binding in an environment record. The String value N is the text of the bound name.
  InitialiseBinding(N,V)       Set the value of an already existing but uninitialised binding in an environment record. The String value N is the text of the bound name. V is the value for the binding and is a value of any ECMAScript language type.
  SetMutableBinding(N,V, S)    Set the value of an already existing mutable binding in an environment record. The String value N is the text of the bound name. V is the value for the binding and may be a value of any ECMAScript language type. S is a Boolean flag. If S is TRUE and the binding cannot be set throw a TYPEERROR exception. S is used to identify strict mode references.
  GetBindingValue(N,S)         Returns the value of an already existing binding from an environment record. The String value N is the text of the bound name. S is used to identify strict mode references. If S is TRUE and the binding does not exist or is uninitialised throw a REFERENCEERROR exception.
  DeleteBinding(N)             Delete a binding from an environment record. The String value N is the text of the bound name If a binding for N exists, remove the binding and return TRUE. If the binding exists but cannot be removed return FALSE. If the binding does not exist return TRUE.
                               
  HasThisBinding()             Determine if an environment record establishes a THIS binding. Return TRUE if it does and FALSE if it does not.
  HasSuperBinding()            Determine if an environment record establishes a SUPER method binding. Return TRUE if it does and FALSE if it does not.
  WithBaseObject ()            If this environment record is associated with a WITH statement, return the with object. Otherwise, return UNDEFINED.

Declarative Environment Records

Each declarative environment record is associated with an ECMAScript
program scope containing variable, constant, let, class, module, import,
and/or function declarations. A declarative environment record binds the
set of identifiers defined by the declarations contained within its
scope.

The behaviour of the concrete specification methods for Declarative
Environment Records is defined by the following algorithms.

HasBinding(N)

The concrete environment record method HasBinding for declarative
environment records simply determines if the argument identifier is one
of the identifiers bound by the record:

CreateMutableBinding (N, D)

The concrete Environment Record method CreateMutableBinding for
declarative environment records creates a new mutable binding for the
name N that is uninitialised. A binding must not already exist in this
Environment Record for N. If Boolean argument D is provided and has
the value TRUE the new binding is marked as being subject to deletion.

1.  Let envRec be the declarative environment record for which the
    method was invoked.

2.  Assert: envRec does not already have a binding for N.

3.  Create a mutable binding in envRec for N and record that it is
    uninitialised. If D is TRUE record that the newly created binding
    may be deleted by a subsequent DeleteBinding call.

4.  Return NormalCompletion(empty).

CreateImmutableBinding (N)

The concrete Environment Record method CreateImmutableBinding for
declarative environment records creates a new immutable binding for the
name N that is uninitialised. A binding must not already exist in this
environment record for N.

InitialiseBinding (N,V)

The concrete Environment Record method InitialiseBinding for declarative
environment records is used to set the bound value of the current
binding of the identifier whose name is the value of the argument N to
the value of argument V. An uninitialised binding for N must already
exist.

1.  Let envRec be the declarative environment record for which the
    method was invoked.

2.  Assert: envRec must have an uninitialised binding for N.

3.  Set the bound value for N in envRec to V.

4.  Record that the binding for N in envRec has been initialised.

SetMutableBinding (N,V,S)

The concrete Environment Record method SetMutableBinding for declarative
environment records attempts to change the bound value of the current
binding of the identifier whose name is the value of the argument N to
the value of argument V. A binding for N must already exist. If the
binding is an immutable binding, a TYPEERROR is thrown if S is TRUE.

GetBindingValue(N,S)

The concrete Environment Record method GetBindingValue for declarative
environment records simply returns the value of its bound identifier
whose name is the value of the argument N. The binding must already
exist. If S is TRUE and the binding is an uninitialised immutable
binding throw a REFERENCEERROR exception.

DeleteBinding (N)

The concrete Environment Record method DeleteBinding for declarative
environment records can only delete bindings that have been explicitly
designated as being subject to deletion.

1.  Let envRec be the declarative environment record for which the
    method was invoked.

2.  If envRec does not have a binding for the name that is the value
    of N, return TRUE.

3.  If the binding for N in envRec cannot be deleted, return FALSE.

4.  Remove the binding for N from envRec.

5.  Return TRUE.

HasThisBinding () 

Regular Declarative Environment Records do not provide a THIS binding.

1.  Return FALSE.

HasSuperBinding ()

Regular Declarative Environment Records do not provide a SUPER binding.

1.  Return FALSE.

 WithBaseObject()

Declarative Environment Records always return UNDEFINED as their
WithBaseObject.

Object Environment Records

Each object environment record is associated with an object called its
_binding object_. An object environment record binds the set of string
identifier names that directly correspond to the property names of its
binding object. Property keys that are not strings in the form of an
IdentifierName are not included in the set of bound identifiers. Both
own and inherited properties are included in the set regardless of the
setting of their [[Enumerable]] attribute. Because properties can be
dynamically added and deleted from objects, the set of identifiers bound
by an object environment record may potentially change as a side-effect
of any operation that adds or deletes properties. Any bindings that are
created as a result of such a side-effect are considered to be a mutable
binding even if the Writable attribute of the corresponding property has
the value FALSE. Immutable bindings do not exist for object environment
records.

Object environment records also have a possibly empty List of strings
called unscopables. The strings in this List are exclude from the
environment records set of bound names, regardless of whether or not
they exist as property keys of its binding object.

Object environment records created for WITH statements (‎12.10) can
provide their binding object as an implicit this value for use in
function calls. The capability is controlled by a withEnvironment
Boolean value that is associated with each object environment record. By
default, the value of withEnvironment is FALSE for any object
environment record.

The behaviour of the concrete specification methods for Object
Environment Records is defined by the following algorithms.

HasBinding(N)

The concrete Environment Record method HasBinding for object environment
records determines if its associated binding object has a property whose
name is the value of the argument N:

CreateMutableBinding (N, D)

The concrete Environment Record method CreateMutableBinding for object
environment records creates in an environment record’s associated
binding object a property whose name is the String value and initialises
it to the value UNDEFINED. If Boolean argument D is provided and has
the value TRUE the new property’s [[Configurable]] attribute is set to
TRUE, otherwise it is set to FALSE.

1.  Let envRec be the object environment record for which the method
    was invoked.

2.  Let bindings be the binding object for envRec.

3.  4.  If D is TRUE then let configValue be TRUE otherwise let
    configValue be FALSE.

5.  Return the result of DefinePropertyOrThrow(bindings, N, Property
    Descriptor {[[Value]]:UNDEFINED, [[Writable]]: TRUE, [[Enumerable]]:
    TRUE , [[Configurable]]: configValue}).

NOTE Normally envRec will not have a binding for N but if it does,
the semantics of DefinePropertyOrThrow may result in an existing binding
being replaced or shadowed or cause an abrupt completion to be returned.

CreateImmutableBinding (N)

The concrete Environment Record method CreateImmutableBinding is never
used within this specification in association with Object environment
records.

InitialiseBinding (N,V)

The concrete Environment Record method InitialiseBinding for object
environment records is used to set the bound value of the current
binding of the identifier whose name is the value of the argument N to
the value of argument V. An uninitialised binding for N must already
exist.

1.  Let envRec be the object environment record for which the method
    was invoked.

2.  Assert: envRec must have an uninitialised binding for N.

3.  Record that the binding for N in envRec has been initialised.

4.  Return the result of calling the SetMutableBinding concrete method
    of envRec with N, V, and FALSE as arguments.

SetMutableBinding (N,V,S)

The concrete Environment Record method SetMutableBinding for object
environment records attempts to set the value of the environment
record’s associated binding object’s property whose name is the value of
the argument N to the value of argument V. A property named N
normally already exists but if it does not or is not currently writable,
error handling is determined by the value of the Boolean argument S.

1.  Let envRec be the object environment record for which the method
    was invoked.

2.  Let bindings be the binding object for envRec.

3.  Return the result of Put(bindings, N, V, and S).

GetBindingValue(N,S)

The concrete Environment Record method GetBindingValue for object
environment records returns the value of its associated binding object’s
property whose name is the String value of the argument identifier N.
The property should already exist but if it does not the result depends
upon the value of the S argument:

DeleteBinding (N)

The concrete Environment Record method DeleteBinding for object
environment records can only delete bindings that correspond to
properties of the environment object whose [[Configurable]] attribute
have the value TRUE.

HasThisBinding ()

Regular Object Environment Records do not provide a THIS binding.

1.  Return FALSE.

HasSuperBinding ()

Regular Object Environment Records do not provide a SUPER binding.

1.  Return FALSE.

 WithBaseObject()

Object Environment Records return UNDEFINED as their WithBaseObject
unless their withEnvironment flag is TRUE.

Function Environment Records

A function environment record is a declarative environment record that
is used to represent the outer most scope of a function that provides a
THIS binding. In addition to its identifier bindings, a function
environment record contains the THIS value used within its scope. If
such a function references SUPER, its function environment record also
contains the state that is used to perform SUPER method invocations from
within the function.

Function environment records store their THIS binding as the value of
their thisValue. If the associated function references SUPER, the
environment record stores in HomeObject the object that the function
is bound to as a method and in MethodName the property key used for
unqualified super invocations from within the function. The default
value for HomeObject and MethodName is UNDEFINED.

Methods environment records support all of Declarative Environment
Record methods listed in Table 22 and share the same specifications for
all of those methods except for HasThisBinding and HasSuperBinding. In
addition, declarative environment records support the methods listed in
Table 23:

Table 23 — Additional Methods of Function Environment Records

  METHOD           PURPOSE
  ------------------ --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  GetThisBinding()   Return the value of this environment record’s THIS binding.
  GetSuperBase()     Return the object that is the base for SUPER property accesses bound in this environment record. The object is derived from this environment record’s HomeObject binding. If the value is Empty, return UNDEFINED.
  GetMethodName()    Return the value of this environment record’s MethodName binding.

The behaviour of the additional concrete specification methods for
Function Environment Records is defined by the following algorithms:

HasThisBinding ()

Function Environment Records always provide a THIS binding.

1.  Return TRUE.

HasSuperBinding ()

1.  If this environment record’s HomeObject has the value Empty, then
    return FALSE. Otherwise, return TRUE.

GetThisBinding ()

1.  Return the value of this environment record’s thisValue.

GetSuperBase ()

1.  Let home be the value of this environment record’s HomeObject.

2.  If home has the value Empty, then return UNDEFINED.

3.  Assert Type(home) is Object.

4.  Return the result of calling home’s [[GetInheritance]] internal
    method.

GetMethodName ()

1.  Return the value of this environment record’s MethodName.

Global Environment Records

A global environment record is used to represent the outer most scope
that is shared by all of the ECMAScript Script elements that are
processed in a common Realm (10.3). A global environment provides the
bindings for built-in globals (15.1), properties of the global object,
and for all declarations that are not function code and that occur
within Script productions.

A global environment record is logically a single record but it is
specified as a composite encapsulating an object environment record and
a declarative environment record. The object environment record has as
its base object the global object of the associated Realm. This global
object is also the value of the global environment record’s thisValue.
The object environment record component of a global environment record
contains the bindings for all built-in globals (15.1) and all bindings
introduced by a FunctionDeclaration or VariableStatement contained
in global code. The bindings for all other ECMAScript declarations in
global code are contained in the declarative environment record
component of the global environment record.

Properties may be created directly on a global object. Hence, the object
environment record component of a global environment record may contain
both bindings created explicitly by FunctionDeclaration or
VariableStatement declarations and binding created implicitly as
properties of the global object. In order to identify which bindings
were explicitly created using declarations, a global environment record
maintains a list of the names bound using its CreateGlobalVarBindings
and CreateGlobalFunctionBindings concrete methods.

Global environment records have the additional state components listed
in Table 24 and the additional methods listed in Table 25.

Table 24 -- Components of Global Environment Records

  COMPONENT              PURPOSE
  ------------------------ ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ObjectEnvironment        A Object Environment Record whose base object is the global object. Contains global built-in bindings as well as bindings for FunctionDeclaration or VariableStatement declarations in global code for the associated Realm.
  DeclarativeEnvironment   A Declarative Environment Record that contains bindings for all declarations in global for the associated Realm code except for FunctionDeclaration and VariableStatement declarations.
  VarNames                 A List containing the string names bound by FunctionDeclaration or VariableStatement declarations in global code for the associated Realm.

Table 25 — Additional Methods of Global Environment Records

  METHOD                               PURPOSE
  -------------------------------------- ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  GetThisBinding()                       Return the value of this environment record’s THIS binding.
  HasVarDeclaration (N)                  Determines if the argument identifier has a binding in this environment record that was created using a VariableStatement or a FunctionDeclaration.
  HasLexicalDeclaration (N)              Determines if the argument identifier has a binding in this environment record that was created using a lexical declaration such as a LexicalDeclaration or a ClassDeclaration.
  CanDeclareGlobalVar (N)                Determines if a corresponding CreateGlobalVarBinding call would succeed if called for the same argument N.
  CanDeclareGlobalFunction (N)           Determines if a corresponding CreateGlobalFunctionBinding call would succeed if called for the same argument N.
  CreateGlobalVarBinding(N, D)           Used to create global VAR bindings in the ObjectEnvironmentComponent of the environment record. The binding will be a mutable binding. The corresponding global object property will have attribute values approate for a VAR. The String value N is the text of the bound name. V is the initial value of the binding If the optional Boolean argument D is TRUE the binding is may be subsequently deleted. This is logically equivalent to CreateMutableBinding but it allows var declarations to receive special treatment.
  CreateGlobalFunctionBinding(N, V, D)   Used to create and initialise global FUNCTION bindings in the ObjectEnvironmentComponent of the environment record. The binding will be a mutable binding. The corresponding global object property will have attribute values approate for a FUNCTION.The String value N is the text of the bound name. If the optional Boolean argument D is TRUE the binding is may be subsequently deleted. This is logically equivalent to CreateMutableBinding followed by a SetMutableBinding but it allows function declarations to receive special treatment.
                                         

The behaviour of the concrete specification methods for Global
Environment Records is defined by the following algorithms.

HasBinding(N)

The concrete environment record method HasBinding for global environment
records simply determines if the argument identifier is one of the
identifiers bound by the record:

1.  Let envRec be the global environment record for which the method
    was invoked.

2.  Let DclRec be envRec’s DeclarativeEnvironment.

3.  If the result of calling DclRec’s HasBinding concrete method with
    argument N is TRUE, return TRUE.

4.  Let ObjRec be envRec’s ObjectEnvironment.

5.  Return the result of calling ObjRec’s HasBinding concrete method
    with argument N.

CreateMutableBinding (N, D)

The concrete environment record method CreateMutableBinding for global
environment records creates a new mutable binding for the name N that
is uninitialised. The binding is created in the associated
DeclarativeEnvironment. A binding for N must not already exist in the
DeclarativeEnvironment. If Boolean argument D is provided and has the
value TRUE the new binding is marked as being subject to deletion.

1.  Let envRec be the global environment record for which the method
    was invoked.

2.  Let DclRec be envRec’s DeclarativeEnvironment.

3.  Assert: DclRec does not already have a binding for N.

4.  5.  Return the result of calling the CreateMutableBinding concrete
    method of DclRec with arguments N and D.

CreateImmutableBinding (N)

The concrete Environment Record method CreateImmutableBinding for global
environment records creates a new immutable binding for the name N
that is uninitialised. A binding must not already exist in this
environment record for N.

1.  Let envRec be the global environment record for which the method
    was invoked.

2.  Let DclRec be envRec’s DeclarativeEnvironment.

3.  Assert: DclRec does not already have a binding for N.

4.  Return the result of calling the CreateImmutableBinding concrete
    method of DclRec with argument N.

InitialiseBinding (N,V)

The concrete Environment Record method InitialiseBinding for global
environment records is used to set the bound value of the current
binding of the identifier whose name is the value of the argument N to
the value of argument V. An uninitialised binding for N must already
exist.

1.  Let envRec be the global environment record for which the method
    was invoked.

2.  Let DclRec be envRec’s DeclarativeEnvironment.

3.  If the result of calling DclRec’s HasBinding concrete method with
    argument N is TRUE, then

    a.  Return the result of calling DclRec’s InitialiseBinding
        concrete method with arguments N and V.

4.  Assert: If the binding exists it must be in the object environment
    record.

5.  Let ObjRec be envRec’s ObjectEnvironment.

6.  a.  

7.  Return the result of calling ObjRec’s InitialiseBinding concrete
    method with arguments N and V.

SetMutableBinding (N,V,S)

The concrete Environment Record method SetMutableBinding for global
environment records attempts to change the bound value of the current
binding of the identifier whose name is the value of the argument N to
the value of argument V. If the binding is an immutable binding, a
TYPEERROR is thrown if S is TRUE. A property named N normally already
exists but if it does not or is not currently writable, error handling
is determined by the value of the Boolean argument S.

1.  Let envRec be the declarative environment record for which the
    method was invoked.

2.  Let DclRec be envRec’s DeclarativeEnvironment.

3.  If the result of calling DclRec’s HasBinding concrete method with
    argument N is TRUE, then

    a.  Return the result of calling the SetMutableBinding concrete
        method of DclRec with arguments N, V, and S.

4.  Let ObjRec be envRec’s ObjectEnvironment.

5.  Return the result of calling the SetMutableBinding concrete method
    of ObjRec with arguments N, V, and S.

GetBindingValue(N,S)

The concrete Environment Record method GetBindingValue for global
environment records simply returns the value of its bound identifier
whose name is the value of the argument N. If S is TRUE and the
binding is an uninitialised binding throw a REFERENCEERROR exception. A
property named N normally already exists but if it does not or is not
currently writable, error handling is determined by the value of the
Boolean argument S.

1.  Let envRec be the declarative environment record for which the
    method was invoked.

2.  Let DclRec be envRec’s DeclarativeEnvironment.

3.  If the result of calling DclRec’s HasBinding concrete method with
    argument N is TRUE, then

    a.  Return the result of calling the GetBindingValue concrete method
        of DclRec with arguments N, and S.

4.  Let ObjRec be envRec’s ObjectEnvironment.

5.  Return the result of calling the GetBindingValue concrete method of
    ObjRec with arguments N, and S.

DeleteBinding (N)

The concrete Environment Record method DeleteBinding for global
environment records can only delete bindings that have been explicitly
designated as being subject to deletion.

1.  Let envRec be the declarative environment record for which the
    method was invoked.

2.  Let DclRec be envRec’s DeclarativeEnvironment.

3.  If the result of calling DclRec’s HasBinding concrete method with
    argument N is TRUE, then

    a.  Return the result of calling the DeleteBinding concrete method
        of DclRec with argument N.

4.  Let ObjRec be envRec’s ObjectEnvironment.

5.  If the result of calling ObjRec’s HasBinding concrete method with
    argument N is TRUE, then

    a.  Let status be the result of calling the DeleteBinding concrete
        method of ObjRec with argument N.

    b.  ReturnIfAbrupt(status).

    c.  If status is TRUE, then

        i.  Let varNames be envRec’s VarNames List.

        ii. If N is an element of varNames, then remove that element
            from the varNames.

    d.  Return status.

6.  Return TRUE.

HasThisBinding ()

Global Environment Records always provide a THIS binding whose value is
the associated global object.

1.  Return TRUE.

HasSuperBinding ()

1.  Return FALSE.

 WithBaseObject()

Global Environment Records always return UNDEFINED as their
WithBaseObject.

1.  Return UNDEFINED.

GetThisBinding ()

1.  Let envRec be the global environment record for which the method
    was invoked.

2.  Let ObjRec be envRec’s ObjectEnvironment.

3.  Let bindings be the binding object for ObjRec.

4.  Return bindings.

HasVarDeclaration (N)

The concrete environment record method HasVarDeclaration for global
environment records determines if the argument identifier has a binding
in this record that was created using a VariableStatement or a
FunctionDeclaration:

1.  Let envRec be the global environment record for which the method
    was invoked.

2.  Let varDeclaredNames be envRec’s VarNames List.

3.  If varDeclaredNames contains the value of N, return TRUE.

4.  Return FALSE.

HasLexicalDeclaration (N)

The concrete environment record method HasLexicalDeclaration for global
environment records determines if the argument identifier has a binding
in this record that was created using a lexical declaration such as a
LexicalDeclaration or a ClassDeclaration:

1.  Let envRec be the global environment record for which the method
    was invoked.

2.  Let DclRec be envRec’s DeclarativeEnvironment.

3.  Return the result of calling DclRec’s HasBinding concrete method
    with argument N.

 CanDeclareGlobalVar (N)

The concrete environment record method CanDeclareGlobalVar for global
environment records determines if a corresponding CreateGlobalVarBinding
call would succeed if called for the same argument N. Redundent var
declarations and var declarations for pre-existing global object
properties are allowed.

1.  Let envRec be the global environment record for which the method
    was invoked.

2.  Let ObjRec be envRec’s ObjectEnvironment.

3.  If the result of calling ObjRec’s HasBinding concrete method with
    argument N is TRUE, return TRUE.

4.  Let bindings be the binding object for ObjRec.

5.  Let extensible be the result of IsExtensible(bindings).

6.  7.  Return extensible.

 CanDeclareGlobalFunction (N)

The concrete environment record method CanDeclareGlobalFunction for
global environment records determines if a corresponding
CreateGlobalFunctionBinding call would succeed if called for the same
argument N.

1.  Let envRec be the global environment record for which the method
    was invoked.

2.  Let ObjRec be envRec’s ObjectEnvironment.

3.  Let globalObject be the binding object for ObjRec.

4.  Let extensible be the result of IsExtensible(globalObject).

5.  ReturnIfAbrupt(extensible).

6.  If the result of calling ObjRec’s HasBinding concrete method with
    argument N is FALSE, then return extensible.

7.  Let existingProp be the result of calling the [[GetOwnProperty]]
    internal method of globalObject with argument N.

8.  If existingProp is UNDEFINED, then return extensible.

9.  If existingProp.[[Configurable]] is TRUE, then return TRUE.

10. If IsDataDescriptor(existingProp) is TRUE and existingProp has
    attribute values {[[Writable]]: TRUE, [[Enumerable]]: TRUE}, then
    return TRUE.

11. Return FALSE.

 CreateGlobalVarBinding (N, D)

The concrete Environment Record method CreateGlobalVarBinding for global
environment records creates a mutable binding in the associated object
environment record and records the bound name in the associated VarNames
List. If a binding already exists, it is reused.

1.  Let envRec be the declarative environment record for which the
    method was invoked.

2.  Let ObjRec be envRec’s ObjectEnvironment.

3.  4.  If the result of calling ObjRec’s HasBinding concrete method
    with argument N is FALSE, then

    a.  Let status be the result of calling the CreateMutableBinding
        concrete method of ObjRec with arguments N and D.

    b.  ReturnIfAbrupt(status).

5.  Let varDeclaredNames be envRec’s VarNames List.

6.  If varDeclaredNames does not contain the value of N, then

    a.  Append N to varDeclaredNames.

7.  Return NormalCompletion(empty).

CreateGlobalFunctionBinding (N, V, D)

The concrete Environment Record method CreateGlobalFunctionBinding for
global environment records creates a mutable binding in the associated
object environment record and records the bound name in the associated
VarNames List. If a binding already exists, it is replaced.

1.  Let envRec be the declarative environment record for which the
    method was invoked.

2.  Let ObjRec be envRec’s ObjectEnvironment.

3.  4.  Let globalObject be the binding object for ObjRec.

5.  Let existingProp be the result of calling the [[GetOwnProperty]]
    internal method of globalObject with argument N.

6.  If existingProp is UNDEFINED or existingProp.[[Configurable]] is
    TRUE, then

    a.  Let desc be Property Descriptor {[[Value]]:V, [[Writable]]:
        TRUE, [[Enumerable]]: TRUE , [[Configurable]]: D}.

7.  Else,

    a.  Let desc be Property Descriptor {[[Value]]:V }.

8.  Let status be the result of DefinePropertyOrThrow(globalObject,
    N, desc).

9.  ReturnIfAbrupt(status).

10. Let varDeclaredNames be envRec’s VarNames List.

11. If varDeclaredNames does not contain the value of N, then

    a.  Append N to varDeclaredNames.

12. Return NormalCompletion(empty).

NOTE Global function declarations are always represented as own
properties of the global object. If possible, an existing own property
is reconfigured to have a standard set of attribute values.

Lexical Environment Operations

The following abstract operations are used in this specification to
operate upon lexical environments:

GetIdentifierReference (lex, name, strict)

The abstract operation GetIdentifierReference is called with a Lexical
Environment lex, a String name, and a Boolean flag strict. The
value of lex may be NULL. When called, the following steps are
performed:

1.  If lex is the value NULL, then

    a.  Return a value of type Reference whose base value is UNDEFINED,
        whose referenced name is name, and whose strict reference flag
        is strict.

2.  Let envRec be lex’s environment record.

3.  Let exists be the result of calling the HasBinding(N) concrete
    method of envRec passing name as the argument N.

4.  If exists is TRUE, then

    a.  Return a value of type Reference whose base value is envRec,
        whose referenced name is name, and whose strict reference flag
        is strict.

5.  Else

    a.  Let outer be the value of lex’s outer environment reference.

    b.  Return the result of calling GetIdentifierReference passing
        outer, name, and strict as arguments.

NewDeclarativeEnvironment (E)

When the abstract operation NewDeclarativeEnvironment is called with
either a Lexical Environment or NULL as argument E the following steps
are performed:

NewObjectEnvironment (O, E)

When the abstract operation NewObjectEnvironment is called with an
Object O and a Lexical Environment E (or NULL) as arguments, the
following steps are performed:

NewFunctionEnvironment (F, T)

When the abstract operation NewFunctionEnvironment is called with an
ECMAScript function Object F and an ECMAScript value T as arguments,
the following steps are performed:

1.  Assert: The value of F’s [[ThisMode]] internal data property is
    not lexical.

2.  Let env be a new Lexical Environment.

3.  Let envRec be a new Function environment record containing
    containing no bindings.

4.  Set envRec’s thisValue to T.

5.  If F has a [[HomeObject]] internal data property, then

    a.  Set envRec’s HomeObject to the value of F’s [[HomeObject]]
        internal data property.

    b.  Set envRec’s MethodName to the value of F’s [[MethodName]]
        internal data property.

6.  Else,

    a.  b.  Set envRec’s HomeObject to Empty.

7.  Set env’s environment record to be envRec.

8.  Set the outer lexical environment reference of env to the value of
    F’s [[Scope]] internal data property.

9.  Return env.


Code Realms

Before it is evaluated, all ECMAScript code must be associated with a
Realm. Conceptually, a realm consists of a set of intrinsic objects,
an ECMAScript global environment, all of the ECMAScript code that is
loaded within the scope of that global environment, a Loader object that
can associate new ECMAScript code with the realm, and other associated
state and resources.

A Realm is specified as a Record with the fields specified in Table 26:

Table 26 — Realm Record Fields

  ---------------- ---------------------------------------------------------------------------- ------------------------------------------------------------------------
  _FIELD NAME_     VALUE                                                                      MEANING
  [[intrinsics]]   A record whose field names are intrinsic keys and whose values are objects   These are the intrinsic values used by code associated with this Realm
  [[globalThis]]   An ECMAScript object                                                         The global object for this Realm
  [[globalEnv]]    A ECMAScript environment                                                     The global environment for this Realm
  [[loader]]       any ECMAScript identifier or EMPTY                                           The Loader object that can associate ECMAScript code with this Realm
  ---------------- ---------------------------------------------------------------------------- ------------------------------------------------------------------------

The intrinsic objects associated with a code Realm include the
well-known intrinsics listed in Table 11 and additional intrinsics
specified by Table 27.

Table 27 — Additional Intrinsic Objects with Realm Specific Bindings

  ------------------ -----------------------------------
  _INTRINSIC NAME_   _ECMASCRIPT LANGUAGE ASSOCIATION_
  ???                ???
  ???                ???
                     
                     
                     
                     
                     
                     
                     
                     
                     
                     
                     
                     
                     
                     
                     
                     
  ------------------ -----------------------------------


Execution Contexts

An _execution context_ is a specification device that is used to track
the runtime evaluation of code by an ECMAScript implementation. At any
point in time, there is at most one execution context that is actually
executing code. This is known as the running execution context. A
stack is used to track execution contexts. The running execution context
is always the top element of this stack. A new execution context is
created whenever control is transferred from the executable code
associated with the currently running execution context to executable
code that is not associated with that execution context. The newly
created execution context is pushed onto the stack and becomes the
running execution context.

An execution context contains whatever implementation specific state is
necessary to track the execution progress of its associated code. Each
execution context has the state components listed in Table 28.

Table 28 —State Components for All Execution Contexts

  COMPONENT             PURPOSE
  ----------------------- -----------------------------------------------------------------------------------------------------------------
  code evaluation state   Any state needed to perform, suspend, and resume evaluation of the code associated with this execution context.
                          
  Realm                   The Realm from which associated code accesses ECMAScript resources.
                          
                          
                          

Evaluation of code by the running execution context may be suspended at
various points defined within this specification. Once the running
execution context has been suspended a different execution context may
become the running execution context and commence evaluating its code.
At some latter time a suspended execution context may again become the
running execution context and continue evaluating its code at the point
where it had previously been suspended. Transition of the running
execution context status among execution contexts usually occurs in
stack-like last-in/first-out manner. However, some ECMAScript features
require non-LIFO transitions of the running execution context.

The value is the Realm component of the running execution context is
also called the _current Realm_.

Execution contexts for ECMAScript code have the additional state
components listed in Table 29.

Table 29 —Additional State Components for ECMAScript Code Execution
Contexts

  COMPONENT           PURPOSE
  --------------------- -------------------------------------------------------------------------------------------------------------------------------------------
  LexicalEnvironment    Identifies the Lexical Environment used to resolve identifier references made by code within this execution context.
  VariableEnvironment   Identifies the Lexical Environment whose environment record holds bindings created by VariableStatements within this execution context.

The LexicalEnvironment and VariableEnvironment components of an
execution context are always Lexical Environments. When an execution
context is created its LexicalEnvironment and VariableEnvironment
components initially have the same value. The value of the
VariableEnvironment component never changes while the value of the
LexicalEnvironment component may change during execution of code within
an execution context.

Execution contexts representing the evaluation of generator objects have
the additional state components listed in Table 30.

Table 30 -- Additional State Components for Generator Execution Contexts

  COMPONENT   PURPOSE
  ------------- ----------------------------------------------------------------
  Generator     The GeneratorObject that this execution context is evaluating.

In most situations only the running execution context (the top of the
execution context stack) is directly manipulated by algorithms within
this specification. Hence when the terms “LexicalEnvironment”, and
“VariableEnvironment” are used without qualification they are in
reference to those components of the running execution context.

An execution context is purely a specification mechanism and need not
correspond to any particular artefact of an ECMAScript implementation.
It is impossible for an ECMAScript program to directly access or observe
an execution context.

Identifier Resolution

Identifier resolution is the process of determining the binding of an
IdentifierName using the LexicalEnvironment of the running execution
context. During execution of ECMAScript code, Identifier Resolution is
performed using the following algorithm:

The result of evaluating an identifier is always a value of type
Reference with its referenced name component equal to the
IdentifierName String.

GetThisEnvironment

The abstract operation GetThisEnvironment finds the lexical environment
that currently supplies the binding of the keyword THIS.
GetThisEnvironment performs the following steps:

1.  Let lex be the running execution context’s LexicalEnvironment.

2.  Repeat

    a.  Let envRec be lex’s environment record.

    b.  Let exists be the result of calling the HasThisBinding
        concrete method of envRec.

    c.  If exists is TRUE, then return envRec.

    d.  Let outer be the value of lex’s outer environment reference.

    e.  Let lex be outer.

NOTE The loop in step 2 will always terminate because the llst of
environments always ends with the global environment which has a THIS
binding.

ThisResolution

The abstract operation ThisResolution is the process of determining the
binding of the keyword THIS using the LexicalEnvironment of the running
execution context. ThisResolution performs the following steps:

1.  Let env be the result of performing the GetThisEnvironment
    abstract operation.

2.  Return the result of calling the GetThisBinding concrete method of
    env.

GetGlobalObject

The abstract operation GetGlobalObject returns the global object used by
the currently running execution context. GetGlobalObject performs the
following steps:

1.  Let ctx be the running execution context.

2.  Let currentRealm be ctx’s Realm.

3.  Return currentRealm.[[globalThis]].


Declaration Binding Instantiation

Global Declaration Instantiation

NOTE When an execution context is established for evaluating scripts,
declarations are instantiated in the current global environment. Each
global binding declarated in the code is instantiated.

Global Declaration Instantiation is performed as follows using arguments
script, env, and deletableBindings. script is the ScriptBody
that for which the execution context is being established. env is the
global environment record in which bindings are to be created.
deletableBindings is TRUE if the bindings that are created should be
deletable.

NOTE Early errors specified in 14.1 prevent name conflicts between
function/var declarations and let/const/class/module declarations as
well as redeclaration of let/const/class/module bindings for declaration
contained within a single Script. However, such conflicts and
redeclarations that span more than one Script are detected as runtime
errors during Global Declaration Instantiation. If any such errors are
detected, no bindings are instantiated for the script.

Unlike explicit var or function declarations, properties that are
directly created on the global object result in global bindings that may
be shadowed by let, const, class, and module declarations.

Module Declaration Instantiation

Function Declaration Instantiation

This version reflects the concensus as of the Sept. 2012 TC39 meeting.
However, it now appears that the binding semantics of formal parameters
is like to change again.

NOTE When an execution context is established for evaluating function
code a new Declarative Environment Record is created and bindings for
each formal parameter, and each function level variable, constant, or
function declarated in the function are instantiated in the environment
record. Formal parameters and functions are initialised as part of this
process. All other bindings are initialised during execution of the
function code.

Function Declaration Instantiation is performed as follows using
arguments func, argumentsList, and env. func is the function
object that for which the execution context is being established. env
is the declarative environment record in which bindings are to be
created.

1.  Let code be the value of the [[Code]] internal data property of
    func.

2.  Let strict be the value of the [[Strict]] internal data property
    of func.

3.  Let formals be the value of the [[FormalParameters]] internal data
    property of func.

4.  Let parameterNames be the BoundNames of formals.

5.  Let varDeclarations be the VarScopedDeclarations of code.

6.  Let functionsToInitialise be an empty List.

7.  If the value of the [[ThisMode]] internal data property of func is
    lexical, then

    a.  Let argumentsObjectNeeded be FALSE.

8.  Else, let argumentsObjectNeeded be TRUE.

9.  For each d in varDeclarations, in reverse list order do

    a.  If d is a FunctionDeclaration then

        i.  NOTE If there are multiple FunctionDeclarations for the
            same name, the last declaration is used.

        ii. Let fn be the sole element of the BoundNames of d.

        iii. If fn is "ARGUMENTS", then let argumentsObjectNeeded be
            FALSE.

        iv. Let alreadyDeclared be the result of calling env’s
            HasBinding concrete method passing fn as the argument.

        v.  If alreadyDeclared is FALSE, then

            1.  Let status be the result of calling env’s
                CreateMutableBinding concrete method passing fn as the
                argument.

            2.  Assert: status is never an abrupt completion.

            3.  Append d to functionsToInitialise.

10. For each String paramName in parameterNames, do

    a.  Let alreadyDeclared be the result of calling env’s
        HasBinding concrete method passing paramName as the argument.

    b.  NOTE Duplicate parameter names can only occur in non-strict
        functions. Parameter names that are the same as function
        declaration names do not get initialised to UNDEFINED.

    c.  If alreadyDeclared is FALSE, then

        i.  If paramName is "ARGUMENTS", then let
            argumentsObjectNeeded be FALSE.

        ii. Let status be the result of calling env’s
            CreateMutableBinding concrete method passing paramName as
            the argument.

        iii. Assert: status is never an abrupt completion

        iv. v.  Call env’s InitialiseBinding concrete method passing
            paramName, and UNDEFINED as the arguments.

11. NOTE If there is a function declaration or formal parameter with the
    name "ARGUMENTS" then an argument object is not created.

12. If argumentsObjectNeeded is TRUE, then

    a.  If strict is TRUE, then

        i.  Call env’s CreateImmutableBinding concrete method passing
            the String "ARGUMENTS" as the argument.

    b.  Else,

        i.  Let status be the result of calling env’s
            CreateMutableBinding concrete method passing the String
            "ARGUMENTS" as the argument.

        ii. Assert: status is never an abrupt completion.

13. Let varNames be the VarDeclaredNames of code.

14. For each String varName in varNames, in list order do

    a.  Let alreadyDeclared be the result of calling env’s
        HasBinding concrete method passing varName as the argument.

    b.  NOTE A VarDeclaredNames is only instantiated and initialied here
        if it is not also the name of a formal parameter or a
        FunctionDeclarations.

    c.  If alreadyDeclared is FALSE, then

        i.  Let status be the result of calling env’s
            CreateMutableBinding concrete method passing varName as
            the argument.

        ii. Assert: status is never an abrupt completion.

15. Let lexDeclarations be the LexicalDeclarations of code.

16. For each element d in lexDeclarations do

    a.  NOTE A lexically declared name cannot be the same as a function
        declaration, formal parameter, or a var name. Lexically
        declarated names are only instantiated here but not initialised.

    b.  For each element dn of the BoundNames of d do

        i.  If IsConstantDeclaration of d is TRUE, then

            1.  Call env’s CreateImmutableBinding concrete method
                passing dn as the argument.

        ii. Else,

            1.  Let status be the result of calling env’s
                CreateMutableBinding concrete method passing dn and
                FALSE as the arguments.

            2.  Assert: status is never an abrupt completion.

    c.  If d is a GeneratorDeclaration production, then

        i.  Append d to functionsToInitialise.

17. For each production f in functionsToInitialise, do

    a.  Let fn be the sole element of the BoundNames of f.

    b.  Let fo be the result of performing InstantiateFunctionObject
        for f with argument env.

    c.  Let status be the result of calling env’s SetMutableBinding
        concrete method passing fn, fo, and FALSE as the arguments.

    d.  Assert: status is never an abrupt completion.

18. NOTE Function declaration are initialised prior to parameter
    initialisation so that default value expressions may reference them.
    "ARGUMENTS" is not initialised until after parameter initialization.

19. Let ao be the result of InstantiateArgumentsObject with argument
    argumentsList.

20. 21. a.  b.  

22. a.  b.  c.  d.  

23. 24. 25. a.  i.  ii. 1.  a.  

            2.  a.  

26. 27. NOTE If argumentsObjectNeeded is FALSE then the value of ao
    is not directly observable to ECMAScript code and need not actually
    exist. In that case, its use in the above steps is strictly as a
    device for specifying formal parameter initialisation semantics.

28. Let formalStatus be the result of performing Binding
    Initialisation for formals with ao and UNDEFINED as arguments.

29. ReturnIfAbrupt(formalStatus).

30. 31. If argumentsObjectNeeded is TRUE, then

    a.  If strict is TRUE, then

        i.  Perform the abstract operation CompleteStrictArgumentsObject
            with argument ao.

        ii. 

    b.  Else,

        i.  Perform the abstract operation CompleteMappedArgumentsObject
            with arguments _ao, func_, formals, and env.

        ii. 

    c.  Call env’s InitialiseBinding concrete method passing
        "ARGUMENTS" and ao as arguments.

32. 33. a.  b.  c.  i.  ii. 

34. 35. a.  b.  c.  i.  ii. iii. 

36. Return NormalCompletion(empty).

Block Declaration Instantiation

NOTE When a Block or CaseBlock production is evaluated a new
Declarative Environment Record is created and bindings for each block
scoped variable, constant, or function declarated in the block are
instantiated in the environment record.

Block Declaration Instantiation is performed as follows using arguments
code and env. code is the grammar production corresponding to the
body of the block. env is the declarative environment record in which
bindings are to be created.

1.  2.  Let declarations be the LexicalDeclarations of code.

3.  Let functionsToInitialise be an empty List.

4.  For each element d in declarations do

    a.  For each element dn of the BoundNames of d do

        i.  If IsConstantDeclaration of d is TRUE, then

            1.  Call env’s CreateImmutableBinding concrete method
                  passing dn as the argument.

        ii. Else,

            1.  Let status be the result of calling env’s
                  CreateMutableBinding concrete method passing dn and
                  FALSE as the arguments.

            2.  Assert: status is never an abrupt completion.

    b.  If d is a GeneratorDeclaration production or a
        FunctionDeclaration production, then

        i.  Append d to functionsToInitialise.

5.  For each production f in functionsToInitialise, in list order do

    a.  Let fn be the sole element of the BoundNames of f.

    b.  Let fo be the result of performing InstantiateFunctionObject
        for f with argument env.

    c.  d.  Call env’s InitialiseBinding concrete method passing fn,
        and fo as the arguments.

    e.  

Eval Declaration Instantiation


Arguments Object

When function code is evaluated, an arguments object is created unless
(as specified in 10.5) the identifier ARGUMENTS occurs as an
Identifier in the function’s FormalParameters or occurs as the
BindingIdentifier of a FunctionDeclaration contained in the
outermost StatementList of the function code.

The abstract operation InstantiateArgumentsObject called with an
argument args performs the following steps:

The abstract operation CompleteStrictArgumentsObject is called with
argument obj which must have been previously created by the abstract
operation InstantiateArgumentsObject. The following steps are performed:

1.  2.  3.  4.  a.  b.  c.  

5.  6.  Perform the AddRestrictedFunctionProperties abstract operation
    with argument obj.

7.  8.  9.  Return.

The abstract operation CompleteMappedArgumentsObject is called with
object obj, object func, grammar production formals, and
environment record env. obj must have been previously created by the
abstract operation InstantiateArgumentsObject.The following steps are
performed:

1.  Let len be the result of Get(obj, "LENGTH").

2.  3.  4.  5.  Let mappedNames be an empty List.

6.  Let numberOfNonRestFormals be NumberOfParameters of formals.

7.  Let map be the result of the abstract operation ObjectCreate with
    the intrinsic object %ObjectPrototype% as its argument.

8.  Let indx = len - 1.

9.  Repeat while indx ≥ 0,

    a.  b.  c.  If indx is less than the numberOfNonRestFormals,
        then

        i.  Let param be getParameter of formals with argument
            indx.

        ii. If param is a BindingIdentifier, then

            1.  Let name be the sole element of BoundNames of param.

            2.  If name is not an element of mappedNames, then

                a.  Add name as an element of the list mappedNames.

                b.  Let g be the result of calling the MakeArgGetter
                    abstract operation with arguments name and env.

                c.  Let p be the result of calling the MakeArgSetter
                    abstract operation with arguments name and env.

                d.  Call the [[DefineOwnProperty]] internal method of
                    map passing ToString(indx) and the Property
                    Descriptor {[[Set]]: p, [[Get]]: g,
                    [[Configurable]]: TRUE} as arguments.

    d.  Let indx = indx - 1

10. If mappedNames is not empty, then

    a.  Set the [[ParameterMap]] internal data property of obj to
        map.

    b.  Set the [[Get]], [[GetOwnProperty]], [[DefineOwnProperty]], and
        [[Delete]] internal methods of obj to the definitions provided
        below.

11. Call the [[DefineOwnProperty]] internal method on obj passing
    "CALLEE" and the Property Descriptor {[[Value]]: func,
    [[Writable]]: TRUE, [[Enumerable]]: FALSE, [[Configurable]]: TRUE}
    as arguments.

12. Return obj

The abstract operation MakeArgGetter called with String name and
environment record env creates a function object that when executed
returns the value bound for name in env. It performs the following
steps:

1.  Let bodyText be the result of concatenating the Strings "RETURN ",
    name, and ";".

2.  Let body be the result of parsing bodyText using FunctionBody
    as the goal symbol.

3.  Let parameters be a FormalParameters : [empty] production.

4.  Return the result of calling the abstract operation FunctionCreate
    using Normal as the kind, parameters as FormalParameterList,
    body for FunctionBody, env as Scope, and TRUE for Strict.

The abstract operation MakeArgSetter called with String name and
environment record env creates a function object that when executed
sets the value bound for name in env. It performs the following
steps:

The [[Get]] internal method of an arguments object for a non-strict mode
function with formal parameters when called with a property name P
performs the following steps:

The [[GetOwnProperty]] internal method of an arguments object for a
non-strict mode function with formal parameters when called with a
property name P performs the following steps:

The [[DefineOwnProperty]] internal method of an arguments object for a
non-strict mode function with formal parameters when called with a
property name P and Property Descriptor Desc performs the following
steps:

1.  Let map be the value of the [[ParameterMap]] internal data
    property of the arguments object.

2.  Let isMapped be the result of calling the [[GetOwnProperty]]
    internal method of map passing P as the argument.

3.  Let allowed be the result of calling the default
    [[DefineOwnProperty]] internal method (8.3.9) on the arguments
    object passing P and Desc as the arguments.

4.  ReturnIfAbrupt(allowed).

5.  If allowed is FALSE, then

6.  return FALSE.

7.  If the value of isMapped is not UNDEFINED, then

    a.  If IsAccessorDescriptor(Desc) is TRUE, then

        i.  Call the [[Delete]] internal method of map passing P as
            the argument.

    b.  Else

        i.  If Desc.[[Value]] is present, then

            1.  2.  Let putStatus be the result of Put(map, P,
                Desc.[[Value]], FALSE).

            3.  Assert: putStatus is TRUE because formal parameters
                mapped by argument objects are always writable.

        ii. If Desc.[[Writable]] is present and its value is FALSE,
            then

            1.  Call the [[Delete]] internal method of map passing P
                as the argument.

8.  Return TRUE.

The [[Delete]] internal method of an arguments object for a non-strict
mode function with formal parameters when called with a property key P
performs the following steps:

1.  Let map be the value of the [[ParameterMap]] internal data
    property of the arguments object.

2.  Let isMapped be the result of calling the [[GetOwnProperty]]
    internal method of map passing P as the argument.

3.  Let result be the result of calling the default [[Delete]]
    internal method for ordinary objects (8.3.10) on the arguments
    object passing P as the argument.

4.  If result is TRUE and the value of isMapped is not UNDEFINED,
    then

    a.  Call the [[Delete]] internal method of map passing P as the
        argument.

5.  Return result.

NOTE 1 For non-strict mode functions the integer indexed data properties
of an arguments object whose numeric name values are less than the
number of formal parameters of the corresponding function object
initially share their values with the corresponding argument bindings in
the function’s execution context. This means that changing the property
changes the corresponding value of the argument binding and vice-versa.
This correspondence is broken if such a property is deleted and then
redefined or if the property is changed into an accessor property. For
strict mode functions, the values of the arguments object’s properties
are simply a copy of the arguments passed to the function and there is
no dynamic linkage between the property values and the formal parameter
values.

NOTE 2 The ParameterMap object and its property values are used as a
device for specifying the arguments object correspondence to argument
bindings. The ParameterMap object and the objects that are the values of
its properties are not directly accessible from ECMAScript code. An
ECMAScript implementation does not need to actually create or use such
objects to implement the specified semantics.

NOTE 3 Arguments objects for strict mode functions define
non-configurable accessor properties named "CALLER" and "CALLEE" which
throw a TYPEERROR exception on access. The "CALLEE" property has a more
specific meaning for non-strict mode functions and a "CALLER" property
has historically been provided as an implementation-defined extension by
some ECMAScript implementations. The strict mode definition of these
properties exists to ensure that neither of them is defined in any other
manner by conforming ECMAScript implementations.



EXPRESSIONS


Primary Expressions

Syntax

PrimaryExpression :

THIS
Identifier
Literal
ArrayInitialiser
ObjectLiteral
FunctionExpression
ClassExpression
GeneratorExpression
GeneratorComprehension
RegularExpressionLiteral
TemplateLiteral
CoverParenthesisedExpressionAndArrowParameterList

CoverParenthesisedExpressionAndArrowParameterList :

( Expression )
( )
( ... Identifier )
( Expression , ... Identifier)

Supplemental Syntax

When processing the production PrimaryExpression :
CoverParenthesisedExpressionAndArrowParameterList the following
grammar is used to refine the interpretation of
CoverParenthesisedExpressionAndArrowParameterList.

ParenthesisedExpression :

( Expression )

STATIC SEMANTICS

-   -   

STATIC SEMANTICS: COVEREDPARENTHESISEDEXPRESSION

CoverParenthesisedExpressionAndArrowParameterList : ( Expression )

1.  Return the result of parsing the lexical token stream matched by
    CoverParenthesisedExpressionAndArrowParameterList using
    ParenthesisedExpression as the goal symbol.

STATIC SEMANTICS: ISVALIDSIMPLEASSIGNMENTTARGET

PrimaryExpression :

THIS
Literal
ArrayInitialiser
ObjectLiteral
FunctionExpression
ClassExpression
GeneratorExpression
GeneratorComprehension
RegularExpressionLiteral
TemplateLiteral

1.  Return FALSE.

PrimaryExpression : Identifier

1.  If this PrimaryExpression is contained in strict code and
    StringValue of Identifier is "EVAL" or "ARGUMENTS", then return
    FALSE.

2.  Return TRUE.

PrimaryExpression :
CoverParenthesisedExpressionAndArrowParameterList

1.  Let expr be CoveredParenthesisedExpression of
    CoverParenthesisedExpressionAndArrowParameterList.

2.  Return IsValidSimpleAssignmentTarget of expr.

The this Keyword

RUNTIME SEMANTICS: EVALUATION

PrimaryExpression : THIS

1.  2.  Return the result of calling the ThisResolution abstract
    operation.

Identifier Reference

RUNTIME SEMANTICS: EVALUATION

PrimaryExpression : Identifier

1.  Let ref be the result of performing Identifier Resolution as
    specified in 10.4.1 using the IdentifierName corresponding to
    Identifier.

2.  Return ref.

NOTE: The result of evaluating an Identifier is always a value of type
Reference.

Literals 

Syntax

Literal :

NullLiteral
ValueLiteral

ValueLiteral :

BooleanLiteral
NumericLiteral
StringLiteral

RUNTIME SEMANTICS

RUNTIME SEMANTICS: EVALUATION

Literal : NullLiteral

1.  Return NULL.

ValueLiteral : BooleanLiteral

1.  Return FALSE if BooleanLiteral is the token BooleanLiteral ::
    FALSE

2.  Return TRUE if BooleanLiteral is the token BooleanLiteral ::
    TRUE

ValueLiteral : NumericLiteral

1.  Return the number whose value is MV of NumericLiteral as defined
    in 7.8.3.

ValueLiteral : StringLiteral

1.  Return the string whose elements are the SV of StringLiteral as
    defined in 7.8.4.

Array Initialiser

Syntax

ArrayInitialiser :

ArrayLiteral
ArrayComprehension

Array Literal

NOTE An ArrayLiteral is an expression describing the initialisation of
an Array object, using a list, of zero or more expressions each of which
represents an array element, enclosed in square brackets. The elements
need not be literals; they are evaluated each time the array initialiser
is evaluated.

Array elements may be elided at the beginning, middle or end of the
element list. Whenever a comma in the element list is not preceded by an
AssignmentExpression (i.e., a comma at the beginning or after another
comma), the missing array element contributes to the length of the Array
and increases the index of subsequent elements. Elided array elements
are not defined. If an element is elided at the end of an array, that
element does not contribute to the length of the Array.

Syntax

ArrayLiteral :

[ Elision~opt~ ]
[ ElementList ]
[ ElementList , Elision~opt~ ]

ElementList :

Elision~opt~ AssignmentExpression
Elision~opt~ SpreadElement
ElementList , Elision~opt~ AssignmentExpression
ElementList , Elision~opt~ SpreadElement

Elision :

,
Elision ,

SpreadElement :

... AssignmentExpression

STATIC SEMANTICS

-   -   

STATIC SEMANTICS: ELISION WIDTH

1.  

Elision : ,

1.  Return the numeric value 1.

Elision : Elision ,

1.  Let preceding be the Elision Width of Elision.

2.  Return preceding+1.

RUNTIME SEMANTICS

RUNTIME SEMANTICS: ARRAY ACCUMULATION

  With parameters array and nextIndex.

ElementList : Elision~opt~ AssignmentExpression

1.  Let padding be the Elision Width of Elision; if Elision is not
    present, use the numeric value zero.

2.  Let initResult be the result of evaluating AssignmentExpression.

3.  Let initValue be GetValue(initResult).

4.  ReturnIfAbrupt(initValue).

5.  Let created be the result of calling the [[DefineOwnProperty]]
    internal method of array with arguments
    ToString(ToUint32(nextIndex+padding)) and the Property Descriptor
    { [[Value]]: initValue, [[Writable]]: TRUE, [[Enumerable]]: TRUE,
    [[Configurable]]: TRUE}.

6.  Assert: created is TRUE.

7.  Return nextIndex+padding+1.

ElementList : Elision~opt~ SpreadElement

1.  Let padding be the Elision Width of Elision; if Elision is not
    present, use the numeric value zero.

2.  Return the result of performing Array Accumulation for
    SpreadElement with arguments array and nextIndex_+_padding.

ElementList : ElementList , Elision~opt~ AssignmentExpression

1.  Let postIndex be the result of performing Array Accumulation for
    ElementList with arguments array and nextIndex.

2.  ReturnIfAbrupt(postIndex).

3.  Let padding be the Elision Width of Elision; if Elision is not
    present, use the numeric value zero.

4.  Let initResult be the result of evaluating AssignmentExpression.

5.  Let initValue be GetValue(initResult).

6.  ReturnIfAbrupt(initValue).

7.  Let created be the result of calling the [[DefineOwnProperty]]
    internal method of array with arguments
    ToString(ToUint32(postIndex_+_padding)) and the Property
    Descriptor { [[Value]]: initValue, [[Writable]]: TRUE,
    [[Enumerable]]: TRUE, [[Configurable]]: TRUE}.

8.  Assert: created is TRUE.

9.  Return postIndex_+_padding+1.

ElementList : ElementList , Elision~opt~ SpreadElement

1.  Let postIndex be the result of performing Array Accumulation for
    ElementList with arguments array and nextIndex.

2.  ReturnIfAbrupt(postIndex).

3.  Let padding be the Elision Width of Elision; if Elision is not
    present, use the numeric value zero.

4.  Return the result of performing Array Accumulation for
    SpreadElement with arguments array and postIndex_+_padding.

SpreadElement : ... AssignmentExpression

1.  Let spreadRef be the result of evaluating AssignmentExpression.

2.  Let spreadValue be GetValue(spreadRef).

3.  Let spreadObj be ToObject(spreadValue).

4.  ReturnIfAbrupt(spreadObj).

5.  Let lenVal be the result of calling Get(spreadObj, "LENGTH").

6.  Let spreadLen be ToUint32(lenVal).

7.  ReturnIfAbrupt(spreadLen).

8.  Let n=0;

9.  Repeat, while n < spreadLen

    a.  Let exists be the result of HasProperty(spreadObj,
          ToString(n)).

    b.  ReturnIfAbrupt(exists).

    c.  If exists is TRUE then,

        i.  Let v be the result of calling the [[Get]] internal method
              of spreadObj passing ToString(n) as the argument.

        ii. ReturnIfAbrupt(v).

        iii. Let created be the result of calling the
              [[DefineOwnProperty]] internal method of array with
              arguments ToString(ToUint32(nextIndex)) and Property
              Descriptor {[[Value]]: v, [[Writable]]: TRUE,
              [[Enumerable]]: TRUE, [[Configurable]]: TRUE}.

        iv. Assert: created is TRUE.

    d.  Let n = n+1.

    e.  Let nextIndex = nextIndex +1.

10. Return nextIndex.

NOTE [[DefineOwnProperty]] is used to ensure that own properties are
defined for the array even if the standard built-in Array prototype
object has been modified in a manner that would preclude the creation of
new own properties using [[Set]].

RUNTIME SEMANTICS: EVALUATION

ArrayLiteral : [ Elision~opt~ ]

1.  Let array be the result of the abstract operation ArrayCreate with
    argument 0.

2.  Let pad be the Elision Width of Elision; if Elision is not
    present, use the numeric value zero.

3.  Call Put(array, "LENGTH", pad, FALSE).

4.  Return array.

ArrayLiteral : [ ElementList ]

1.  Let array be the result of the abstract operation ArrayCreate with
    argument 0.

2.  Let len be the result of performing Array Accumulation for
    ElementList with arguments array and 0.

3.  ReturnIfAbrupt(len).

4.  Call Put(array, "LENGTH", len, FALSE).

5.  Return array.

ArrayLiteral : [ ElementList , Elision~opt~ ]

1.  Let array be the result of the abstract operation ArrayCreate with
    argument 0.

2.  3.  Let len be the result of performing Array Accumulation for
    ElementList with arguments array and 0.

4.  ReturnIfAbrupt(len).

5.  Let padding be the Elision Width of Elision; if Elision is not
    present, use the numeric value zero.

6.  7.  Call Put(array, "LENGTH", ToUint32(padding_+_len), FALSE).

8.  Return array.

Array Comprehension

Syntax

ArrayComprehension :

[Comprehension ]

Comprehension :

ComprehensionFor ComprehensionQualifierTail

ComprehensionQualifierTail :

AssignmentExpression
ComprehensionQualifier ComprehensionQualifierTail

ComprehensionQualifier :

ComprehensionFor
ComprehensionIf

ComprehensionFor :

FOR ( ForBinding OF AssignmentExpression )

ComprehensionIf :

IF ( AssignmentExpression )

ForBinding :

BindingIdentifier
BindingPattern

STATIC SEMANTICS

STATIC SEMANTICS: EARLY ERRORS

ComprehensionFor : FOR (ForBinding OF AssignmentExpression )

-   It is a Syntax Error if the BoundNames of ForBinding contains any
    duplicate entries.

1.  

1.  

RUNTIME SEMANTICS

RUNTIME SEMANTICS: BINDING INITIALISATION

  With arguments value and environment.

NOTE UNDEFINED is passed for environment to indicate that a PutValue
operation should be used to assign the initialisation value. This is the
case for VAR statements formal parameter lists of non-strict functions.
In those cases a lexical binding is hosted and preinitialised prior to
evaluation of its initialiser.

ForBinding : BindingPattern

1.  Let obj be ToObject(value).

2.  ReturnIfAbrupt(obj).

3.  Return the result of performing Binding Initialisation for
    BindingPattern passing obj and environment as the arguments.

RUNTIME SEMANTICS: COMPREHENSIONEVALUATION

  With argument accumulator.

NOTE UNDEFINED is passed for accumulator to indicate that a
comprehension component is being evaluated as part of a generator
comprehension. Otherwise, the value of accumulator is the array object
into the elements of an array comprehension are to be accumulated.

Comprehension : _ComprehensionFor ComprehensionQualifierTail_

1.  Return the result of performing QualifierEvaluation for
    ComprehensionFor with arguments ComprehensionQualifierTail and
    accumulator.

ComprehensionQualifierTail: _ComprehensionQualifier
ComprehensionQualifierTail_

1.  Return the result of performing QualifierEvaluation for
    ComprehensionQualifier with arguments ComprehensionQualifierTail
    and accumulator.

ComprehensionQualifierTail: AssignmentExpression

1.  Let valueRef be the result of evaluating AssignmentExpression.

2.  Let value be GetValue(valueRef).

3.  ReturnIfAbrupt(value).

4.  If accumulator is not UNDEFINED, then

    a.  Assert: this is part of an array comprehension.

    b.  Assert: accumulator is an exotic array object so access to its
        LENGTH property should never fail.

    c.  Let len be the result of Get(accumulator, "LENGTH").

    d.  If len≥2^32^-1, then throw a RANGEERROR exception.

    e.  Let putStatus be the result of Put(accumulator,
        ToString(len), value, TRUE).

    f.  ReturnIfAbrupt(putStatus).

    g.  Increase len by 1.

    h.  Let putStatus be the result of Put(accumulator, "LENGTH",
        len, TRUE).

    i.  ReturnIfAbrupt(putStatus).

    j.  Return NormalCompletion(UNDEFINED).

5.  Assert: accumulator is UNDEFINED, so this is part of a generator
    comprehension.

6.  Let yieldStatus be the result of
    GeneratorYield(CreateItrResultObject(value, FALSE)).

7.  ReturnIfAbrupt(yieldStatus).

8.  Return NormalCompletion(UNDEFINED).

RUNTIME SEMANTICS: QUALIFIEREVALUATION

  With arguments tail and accumulator.

NOTE UNDEFINED is passed for accumulator to indicate that a
comprehension component is being evaluated as part of a generator
comprehension. Otherwise, the value of accumulator is the array object
into the elements of an array comprehension are to be accumulated.

ComprehensionFor : FOR (ForBinding OF AssignmentExpression )

1.  Let exprRef be the result of evaluating AssignmentExpression.

2.  Let exprValue be GetValue(exprRef).

3.  Let obj be ToObject(exprValue).

4.  ReturnIfAbrupt(obj).

5.  Let iterator be the result of performing Invoke with arguments
    obj, @@iterator, and an empty List.

6.  Let keys be ToObject(iterator).

7.  ReturnIfAbrupt(keys).

8.  Let oldEnv be the running execution context’s LexicalEnvironment.

9.  10. Repeat

    a.  Let nextResult be the result of IteratorNext(keys).

    b.  ReturnIfAbrupt(nextResult).

    c.  d.  Let done be IteratorComplete(nextResult).

    e.  ReturnIfAbrupt(done).

    f.  If done is TRUE, then return TRUE.

    g.  Let nextValue be IteratorValue(nextResult);

    h.  ReturnIfAbrupt(nextValue).

    i.  Let forEnv be the result of calling NewDeclarativeEnvironment
        passing oldEnv as the argument.

    j.  For each element name of the BoundNames of ForBinding do

        i.  Call forEnv’s CreateMutableBinding concrete method with
            argument name.

        ii. Assert: The above call to CreateMutableBinding will never an
            return an abrupt completion.

    k.  Let status be the result of performing Binding Initialisation
        for ForBinding passing nextValue and forEnv as the
        arguments.

    l.  ReturnIfAbrupt(status).

    m.  Set the running execution context’s LexicalEnvironment to
        forEnv.

    n.  Let continue be the result of performing
        ComprehensionEvaluation for tail with argument accumulator.

    o.  Set the running execution context’s LexicalEnvironment to
        oldEnv.

    p.  ReturnIfAbrupt(continue).

ComprehensionIf : IF ( AssignmentExpression )

1.  Let valueRef be the result of evaluating AssignmentExpression.

2.  Let value be GetValue(valueRef).

3.  Let boolValue be ToBoolean(value).

4.  ReturnIfAbrupt(boolValue).

5.  If boolValue is TRUE, then

    a.  Return the result of performing ComprehensionEvaluation for
        tail with argument accumulator.

6.  Else,

    a.  Return NormalCompletion(UNDEFINED).

1.  

1.  

RUNTIME SEMANTICS: EVALUATION

ArrayComprehension : [ Comprehension ]

1.  Let array be the result of the abstract operation ArrayCreate with
    argument 0.

2.  Let status be the result of performing ComprehensionEvaluation for
    Comprehension with argument array.

3.  ReturnIfAbrupt(status).

4.  Return array.

Object Initialiser

NOTE 1 An object initialiser is an expression describing the
initialisation of an Object, written in a form resembling a literal. It
is a list of zero or more pairs of property names and associated values,
enclosed in curly braces. The values need not be literals; they are
evaluated each time the object initialiser is evaluated.

Syntax

ObjectLiteral :

{ }
{ PropertyDefinitionList }
{ PropertyDefinitionList , }

PropertyDefinitionList :

PropertyDefinition
PropertyDefinitionList , PropertyDefinition

PropertyDefinition :

IdentifierName
CoverInitialisedName
PropertyName : AssignmentExpression
MethodDefinition

PropertyName :

LiteralPropertyName
ComputedPropertyName

LiteralPropertyName :

IdentifierName
StringLiteral
NumericLiteral

ComputedPropertyName :

[ AssignmentExpression ]

CoverInitialisedName :

IdentifierName Initialiser

Initialiser :

= AssignmentExpression

NOTE 2 MethodDefinition is defined in 13.3.

NOTE 3 In certain contexts, ObjectLiteral is used as a cover grammar
for a more restricted secondary grammar. The CoverInitialisedName
production is necessary to fully cover these secondary grammars.
However, use of this production results in an early Syntax Error in
normal contexts where an actual ObjectLiteral is expected.

STATIC SEMANTICS

STATIC SEMANTICS: EARLY ERRORS

In addition to describing an actual object initialiser the
ObjectLiteral productions are also used as a cover grammar for
ObjectAssignmentPattern (11.13.1). When ObjectLiteral appears in a
context where ObjectAssignmentPattern is required, the following Early
Error rules are NOT applied.

ObjectLiteral : { PropertyDefinitionList }

and

ObjectLiteral : { PropertyDefinitionList , }

-   It is a Syntax Error if PropertyNameList of PropertyDefinitionList
    contains any duplicate entries, unless one of the following
    conditions are true for each duplicate entry:

    1.  The source code corresponding to PropertyDefinitionList is not
        strict code and all occurrences in the list of the duplicated
        entry were obtained from productions of the form
        PropertyDefinition : PropertyName : AssignmentExpression.

    2.  The duplicated entry occurs exactly twice in the list and one
        occurrence was obtained from a GET accessor MethodDefinition
        and the other occurrence was obtained from a SET accessor
        MethodDefinition.

PropertyDefinition : MethodDefinition

-   It is a Syntax Error if ReferencesSuper of MethodDefinition is
    TRUE.

PropertyDefinition : IdentifierName

-   It is a Syntax Error if IdentifierName is a ReservedWord.

PropertyDefinition : CoverInitialisedName

-   Always throw a Syntax Error if this production is present

NOTE This production exists so that ObjectLiteral can serve as a cover
grammar for ObjectAssignmentPattern (11.13.1). It cannot occur in an
actual object initialiser.

-   -   -   -   -   -   -   -   -   -   -   -   -   -   

-   -   

-   -   -   -   -   -   

1.  

1.  

STATIC SEMANTICS: CONTAINS

  With parameter symbol.

PropertyDefinition : MethodDefinition

1.  If symbol is MethodDefinition, return TRUE.

2.  Return FALSE.

NOTE Static semantic rules that depend upon substructure generally do
not look into function definitions.

LiteralPropertyName : IdentifierName

1.  If symbol is a ReservedWord, return FALSE.

2.  If symbol is an Identifier and StringValue of symbol is the
    same value as the StringValue of IdentifierName, return TRUE;

3.  Return FALSE.

STATIC SEMANTICS: ISCOMPUTEDPROPERTYNAME

PropertyName : LiteralPropertyName

1.  Return FALSE.

PropertyName : ComputedPropertyName

1.  Return TRUE.

STATIC SEMANTICS: ISVALIDSIMPLEASSIGNMENTTARGET

PrimaryExpression : Literal

1.  Return FALSE.

1.  

1.  

1.  

1.  

1.  2.  

1.  2.  a.  

3.  

STATIC SEMANTICS: PROPNAME

PropertyDefinition : IdentifierName

1.  Return StringValue of IdentifierName.

PropertyDefinition : PropertyName : AssignmentExpression

1.  Return PropName of PropertyName.

Literal

1.  

1.  

1.  

1.  

1.  

1.  

PropertyName : StringLiteral

1.  Return a String value whose characters are the SV of the
    StringLiteral.

LiteralPropertyName : NumericLiteral

1.  Let nbr be the result of forming the value of the
    NumericLiteral.

2.  Return ToString(nbr).

ComputedPropertyName : [ AssignmentExpression ]

1.  Return empty.

STATIC SEMANTICS: PROPERTYNAMELIST

PropertyDefinitionList : PropertyDefinition

1.  If PropName of PropertyDefinition is empty, return a new empty
    List.

2.  Return a new List containing PropName of PropertyDefinition.

PropertyDefinitionList : PropertyDefinitionList ,
PropertyDefinition

1.  Let list be PropertyNameList of PropertyDefinitionList.

2.  If PropName of PropertyDefinition is empty, return list.

3.  Append PropName of PropertyDefinition to the end of list.

4.  Return list.

RUNTIME SEMANTICS

RUNTIME SEMANTICS: EVALUATION

ObjectLiteral : { }

1.  Return the result of the abstract operation ObjectCreate with the
    intrinsic object %ObjectPrototype% as its argument.

ObjectLiteral :

  { PropertyDefinitionList }_
  _{ PropertyDefinitionList , }

1.  Let obj be the result of the abstract operation ObjectCreate with
    the intrinsic object %ObjectPrototype% as its argument.

2.  Let status be the result of performing Property Definition
    Evaluation of PropertyDefinitionList with argument obj.

3.  ReturnIfAbrupt(status).

4.  Return obj.

PropertyDefinition : IdentifierName

1.  Return StringValue of IdentifierName.

PropertyDefinition : PropertyName : AssignmentExpression

1.  Return the result of evaluating PropertyName.

LiteralPropertyName: IdentifierName

1.  Return StringValue of IdentifierName.

LiteralPropertyName : StringLiteral

1.  Return a String value whose characters are the SV of the
    StringLiteral.

LiteralPropertyName : NumericLiteral

1.  Let nbr be the result of forming the value of the
    NumericLiteral.

2.  Return ToString(nbr).

ComputedPropertyName : [ AssignmentExpression ]

1.  Let exprValue be the result of evaluating AssignmentExpression.

2.  Let propName be GetValue(exprValue).

3.  ReturnIfAbrupt(propName).

4.  a.  

5.  Return ToPropertyKey(propName).

RUNTIME SEMANTICS: PROPERTY DEFINITION EVALUATION

  With parameter object and optional parameter functionPrototype.

1.  2.  3.  4.  

PropertyDefinitionList : PropertyDefinitionList ,
PropertyDefinition

PropertyDefinition : IdentifierName

1.  Let propName be StringValue of IdentifierName.

2.  Let exprValue be the result of performing Identifier Resolution as
    specified in 10.3.1 using IdentifierName.

3.  Let propValue be GetValue(exprValue).

4.  ReturnIfAbrupt(propValue).

5.  Let desc be the Property Descriptor{[[Value]]: propValue,
    [[Writable]]: TRUE, [[Enumerable]]: TRUE, [[Configurable]]: TRUE}

6.  Return the result of DefinePropertyOrThrow(object, propName,
    desc).

7.  

PropertyDefinition : PropertyName : AssignmentExpression

1.  Let propKey be the result of evaluating PropertyName.

2.  ReturnIfAbrupt(propKey).

3.  If the source code corresponding to PropertyDefinition is strict
    code and if isComputedPropertyName(propKey) is TRUE, then

    a.  Let duplicateKey be the result of calling the
        [[HasOwnProperty]] internal method of object with argument
        propKey.

    b.  ReturnIfAbrupt(duplicateKey).

    c.  If duplicateKey is TRUE, then throw a TYPEERROR exception.

4.  Let exprValue be the result of evaluating AssignmentExpression.

5.  Let propValue be GetValue(exprValue).

6.  ReturnIfAbrupt(propValue).

7.  Let desc be the Property Descriptor{[[Value]]: propValue,
    [[Writable]]: TRUE, [[Enumerable]]: TRUE, [[Configurable]]: TRUE}

8.  Return the result of DefinePropertyOrThrow(object, propKey,
    desc).

NOTE An alternative semantics for this production is given in B.3.1.

Function Defining Expressions

See 13.1 for PrimaryExpression : FunctionExpression.

See 13.4 for PrimaryExpression : GeneratorExpression.

See 13.5 for PrimaryExpression : ClassExpression.

Generator Comprehensions

Syntax

GeneratorComprehension :

( Comprehension )

Static Semantics

STATIC SEMANTICS: EARLY ERRORS

GeneratorComprehension : ( Comprehension )

-   It is a Syntax Error if Comprehension Contains YieldExpression
    is TRUE.

Runtime Semantics

RUNTIME SEMANTICS: EVALUATION

GeneratorComprehension : ( Comprehension )

1.  If GeneratorComprehension is contained in strict mode code, then
    let strict be TRUE; otherwise let strict be FALSE.

2.  Let scope be the LexicalEnvironment of the running execution
    context.

3.  Let parameters be the production: FormalParameters : [empty].

4.  Using Comprehension from the production that is being evaluated,
    let body be the supplemental syntactic grammar production:
    GeneratorBody : Comprehension.

5.  Let closure be the result of performing the
    GeneratorFunctionCreate abstract operation with arguments Arrow,
    parameters, _body, scope_, and strict.

6.  Let prototype be the result of the abstract operation ObjectCreate
    with the intrinsic object %GeneratorPrototype% as its argument.

7.  Perform the abstract operation MakeConstructor with arguments
    closure, TRUE, and prototype.

8.  Let iterator be the result of calling the [[Call]] internal method
    of closure with UNDEFINED as thisArgument and a empty List as
    argumentsList.

9.  Return iterator.

NOTE The GeneratorFunction object created in step 5 is not observable
from ECMAScript code so an implementation may choose to avoid its
allocation and initialization. In that case use other semantically
equivalent means must be used to allocate and initialise the iterator
object in step 8. In either case, the prototype object created in step
6 must be created because it is potentially observable as the value of
the iterator object’s [[Prototype]] internal data property.

Regular Expression Literals

Syntax

See 7.8.4.

STATIC SEMANTICS

STATIC SEMANTICS: EARLY ERRORS

PrimaryExpression : RegularExpressionLiteral

-   It is a Syntax Error if BodyText of RegularExpressionLiteral
    cannot be recognised using the goal symbol Pattern of the
    ECMAScript RegExp grammar specified in 15.10.

-   It is a Syntax Error if FlagText of RegularExpressionLiteral
    contains any character other than "G", "I", "M", "U", or "Y", or if
    it contains the same character more than once.

RUNTIME SEMANTICS

RUNTIME SEMANTICS: EVALUATION

PrimaryExpression : RegularExpressionLiteral

1.  A regular expression literal evaluates to a value of the Object type
    that is an instance of the standard built-in constructor RegExp.
    This value is determined in two steps: first, the characters
    comprising the regular expression's RegularExpressionBody and
    RegularExpressionFlags production expansions are collected
    uninterpreted into two Strings Pattern and Flags, respectively. Then
    each time the literal is evaluated, a new object is created as if by
    the expression NEW REGEXP(Pattern, Flags) where RegExp is the
    standard built-in constructor with that name. The newly constructed
    object becomes the value of the RegularExpressionLiteral.

Template Literals 

Syntax

TemplateLiteral :

NoSubstitutionTemplate
TemplateHead Expression [Lexical goal InputElementTemplateTail]
TemplateSpans

TemplateSpans :

TemplateTail
TemplateMiddleList [Lexical goal InputElementTemplateTail] TemplateTail

TemplateMiddleList :

TemplateMiddle Expression
TemplateMiddleList [Lexical goal InputElementTemplateTail]
TemplateMiddle Expression

STATIC SEMANTICS

STATIC SEMANTICS: TEMPLATESTRINGS

  With parameter raw.

TemplateLiteral : NoSubstitutionTemplate

1.  If raw is FALSE, then

    a.  Let string be the TV of NoSubstitutionTemplate.

2.  Else,

    a.  Let string be the TRV of NoSubstitutionTemplate.

3.  Return a List containing the single element, string.

TemplateLiteral : _TemplateHead Expression_ [Lexical goal
InputElementTemplateTail] TemplateSpans

1.  If raw is FALSE, then

    a.  Let head be the TV of TemplateHead.

    b.  

2.  Else,

    a.  Let head be the TRV of TemplateHead.

3.  Let tail be TemplateStrings of TemplateSpans with argument
    raw.

4.  Return a List containing head followed by the element, in order of
    tail.

TemplateSpans : TemplateTail

1.  If raw is FALSE, then

    a.  Let tail be the TV of TemplateTail.

2.  Else,

    a.  Let tail be the TRV of TemplateTail.

3.  Return a List containing the single element, tail.

TemplateSpans : TemplateMiddleList [Lexical goal
InputElementTemplateTail] TemplateTail

1.  Let middle be TemplateStrings of TemplateMiddleList with
    argument raw.

2.  If raw is FALSE, then

3.  a.  Let tail be the TV of TemplateTail.

4.  Else,

    a.  b.  Let tail be the TRV of TemplateTail.

5.  6.  Return a List containing the elements, in order, of middle
    followed by tail.

TemplateMiddleList : _TemplateMiddle Expression_

1.  If raw is FALSE, then

    a.  Let string be the TV of TemplateMiddle.

2.  Else,

    a.  Let string be the TRV of TemplateMiddle.

3.  Return a List containing the single element, string.

TemplateMiddleList : TemplateMiddleList [Lexical goal
InputElementTemplateTail] _TemplateMiddle Expression_

1.  Let front be TemplateStrings of TemplateMiddleList with argument
    raw.

2.  If raw is FALSE, then

    a.  Let last be the TV of TemplateMiddle.

3.  Else,

    a.  Let last be the TRV of TemplateMiddle.

4.  Append last as the last element of the List front.

5.  Return front.

RUNTIME SEMANTICS

RUNTIME SEMANTICS: ARGUMENTLISTEVALUATION

TemplateLiteral : NoSubstitutionTemplate

1.  Let siteObj be the result of the abstract operation
    GetTemplateCallSite passing this TemplateLiteral production as the
    argument.

2.  Return a List containing the one element which is siteObj.

1.  2.  3.  4.  

TemplateLiteral : _TemplateHead Expression_ [Lexical goal
InputElementTemplateTail] TemplateSpans

1.  Let siteObj be the result of the abstract operation
    GetTemplateCallSite passing this TemplateLiteral production as the
    argument.

2.  Let firstSub be the result of evaluating Expression.

3.  ReturnIfAbrupt(firstSub).

4.  Let restSub be SubstitutionEvaluation of TemplateSpans.

5.  ReturnIfAbrupt(restSub).

6.  Assert, restSub is a List.

7.  Return a List whose first element is siteObj, whose second
    elements is firstSub, and whose subsequent elements are the
    elements of restSub, in order. restSub may contain no elements.

RUNTIME SEMANTICS: GETTEMPLATECALLSITE ABSTRACT OPERATION

The abstract operation GetTemplateCallSite is called with a grammar
production, templateLiteral, as an argument. It performs the following
steps:

1.  If a call site object for the source code corresponding to
    templateLiteral has already been created by a previous call to
    this abstract operation, then

    a.  Return that call site object.

2.  Let cookedStrings be TemplateStrings of templateLiteral with
    argument FALSE.

3.  Let rawStrings be TemplateStrings of templateLiteral with
    argument TRUE.

4.  Let count be the number of elements in the List cookedStrings.

5.  Let siteObj be the result of the abstract operation ArrayCreate
    with argument count.

6.  Let rawObj be the result of the abstract operation ArrayCreate
    with argument count.

7.  Let index be 0.

8.  Repeat while index < count

    a.  Let prop be ToString(index).

    b.  Let cookedValue be the string value at 0-based position
        index of the List cookedStrings.

    c.  Call the [[DefineOwnProperty]] internal method of siteObj with
        arguments prop and Property Descriptor {[[Value]]:
        cookedValue, [[Enumerable]]: TRUE, [[Writable]]: FALSE,
        [[Configurable]]: FALSE}.

    d.  Let rawValue be the string value at 0-based position index
        of the List rawStrings.

    e.  Call the [[DefineOwnProperty]] internal method of rawObj with
        arguments prop and Property Descriptor {[[Value]]: rawValue,
        [[Enumerable]]: TRUE, [[Writable]]: FALSE, [[Configurable]]:
        FALSE}.

    f.  Let index be index+1.

9.  Perform SetIntegrityLevel(rawObj, "FROZEN").

10. Call the [[DefineOwnProperty]] internal method of siteObj with
    arguments "RAW" and Property Descriptor {[[Value]]: rawObj,
    [[Writable]]: FALSE, [[Enumerable]]: FALSE, [[Configurable]]:
    FALSE}.

11. Perform SetIntegrityLevel(siteObj, "FROZEN").

12. Remember an association between the source code corresponding to
    templateLiteral and siteObj such that siteObj can be retrieve
    in subsequent calls to this abstract operation.

13. Return siteObj.

NOTE 1 The creation of a call site object cannot result in an abrupt
completion.

NOTE 2 Each TemplateLiteral in the program code is associated with a
unique Template call site object that is used in the evaluation of
tagged Templates (11.2.6). The same call site object is used each time a
specific tagged Template is evaluated. Whether call site objects are
created lazily upon first evaluation of the TemplateLiteral or eagerly
prior to first evaluation is an implementation choice that is not
observable to ECMAScript code.

RUNTIME SEMANTICS: SUBSTITUTIONEVALUATION

TemplateSpans : TemplateTail

1.  Return an empty List.

TemplateSpans : TemplateMiddleList [Lexical goal
InputElementTemplateTail] TemplateTail

1.  Return the result of SubstitutionEvaluation of TemplateMiddleList.

TemplateMiddleList : _TemplateMiddle Expression_

1.  Let sub be the result of evaluating Expression.

2.  ReturnIfAbrupt(sub).

3.  Return a List containing only sub.

TemplateMiddleList : TemplateMiddleList [Lexical goal
InputElementTemplateTail] _TemplateMiddle Expression_

1.  Let preceeding be the result of SubstitutionEvaluation of
    TemplateMiddleList .

2.  ReturnIfAbrupt(preceeding).

3.  Let next be the result of evaluating Expression.

4.  ReturnIfAbrupt(next).

5.  Append next as the last element of the List preceeding.

6.  Return preceeding.

RUNTIME SEMANTICS: EVALUATION

TemplateLiteral : NoSubstitutionTemplate

1.  Return the string value whose elements are the TV of
    NoSubstitutionTemplate as defined in 7.8.5.

TemplateLiteral : TemplateHead Expression [Lexical goal
InputElementTemplateTail] TemplateSpans

1.  Let head be the TV of TemplateHead as defined in 7.8.5.

2.  Let sub be the result of evaluating Expression.

3.  Let middle be ToString(sub).

4.  ReturnIfAbrupt(middle).

5.  Let tail be the result of evaluating TemplateSpans .

6.  ReturnIfAbrupt(tail).

7.  8.  Return the string value whose elements are the code units of
    head followed by the code units of tail.

TemplateSpans : TemplateTail

1.  Let tail be the TV of TemplateTail as defined in 7.8.5.

2.  Return the string whose elements are the code units of tail.

TemplateSpans : TemplateMiddleList [Lexical goal
InputElementTemplateTail] TemplateTail

1.  2.  3.  4.  5.  

1.  Let head be the result of evaluating TemplateMiddleList.

2.  ReturnIfAbrupt(head).

3.  Let tail be the TV of TemplateTail as defined in 7.8.5.

4.  Return the string whose elements are the elements of head followed
    by the elements of tail.

TemplateMiddleList : _TemplateMiddle Expression_

1.  Let head be the TV of TemplateMiddle as defined in 7.8.5.

2.  Let sub be the result of evaluating Expression.

3.  Let middle be ToString(sub).

4.  ReturnIfAbrupt(middle).

5.  Return the sequence of characters consisting of the code units of
    head followed by the elements of middle.

TemplateMiddleList : TemplateMiddleList [Lexical goal
InputElementTemplateTail] _TemplateMiddle Expression_

1.  Let rest be the result of evaluating TemplateMiddleList .

2.  ReturnIfAbrupt(rest).

3.  Let middle be the TV of TemplateMiddle as defined in 7.8.5.

4.  Let sub be the result of evaluating Expression.

5.  Let last be ToString(sub).

6.  ReturnIfAbrupt(last).

7.  Return the sequence of characters consisting of the elements of
    rest followed by the code units of middle followed by the
    elements of last.

The Grouping Operator

STATIC SEMANTICS: EARLY ERRORS

PrimaryExpression : _CoverParenthesisedExpressionAndArrowParameterList
_

-   It is a Syntax Error if the lexical token sequence matched by
    CoverParenthesisedExpressionAndArrowParameterList cannot be parsed
    with no tokens left over using ParenthesisedExpression as the goal
    symbol.

-   All Early Errors rules for ParenthesisedExpression and its derived
    productions also apply to the CoveredParenthesisedExpression of
    CoverParenthesisedExpressionAndArrowParameterList.

STATIC SEMANTICS: ISVALIDSIMPLEASSIGNMENTTARGET

PrimaryExpression :
CoverParenthesisedExpressionAndArrowParameterList

1.  Let expr be CoveredParenthesisedExpression of
    CoverParenthesisedExpressionAndArrowParameterList.

2.  Return IsValidSimpleAssignmentTarget of expr.

ParenthesisedExpression : ( Expression )

1.  Return IsValidSimpleAssignmentTarget of Expression.

RUNTIME SEMANTICS: EVALUATION

PrimaryExpression :
CoverParenthesisedExpressionAndArrowParameterList

1.  Let expr be CoveredParenthesisedExpression of
    CoverParenthesisedExpressionAndArrowParameterList.

2.  Return the result of evaluating expr.

ParenthesisedExpression : ( Expression )

1.  Return the result of evaluating Expression. This may be of type
    Reference.

NOTE This algorithm does not apply GetValue to the result of evaluating
Expression. The principal motivation for this is so that operators
such as DELETE and TYPEOF may be applied to parenthesised expressions.


Left-Hand-Side Expressions

Syntax

MemberExpression :

[Lexical goal InputElementRegExp] PrimaryExpression
MemberExpression [ Expression ]
MemberExpression . IdentifierName
MemberExpression TemplateLiteral
SUPER [ Expression ]
SUPER . IdentifierName
NEW SUPER Arguments~opt~
NEW MemberExpression Arguments

NewExpression :

MemberExpression
NEW NewExpression

CallExpression :

MemberExpression Arguments
SUPER Arguments
CallExpression Arguments
CallExpression [ Expression ]
CallExpression . IdentifierName
CallExpression TemplateLiteral

Arguments :

( )
( ArgumentList )

ArgumentList :

AssignmentExpression
... AssignmentExpression
ArgumentList , AssignmentExpression
ArgumentList , ... AssignmentExpression

LeftHandSideExpression :

NewExpression
CallExpression

STATIC SEMANTICS

STATIC SEMANTICS: CONTAINS

  With parameter symbol.

MemberExpression : MemberExpression . IdentifierName

1.  If MemberExpression Contains symbol is TRUE, return TRUE.

2.  If symbol is a ReservedWord, return FALSE.

3.  If symbol is an Identifier and StringValue of symbol is the
    same value as the StringValue of IdentifierName, return TRUE;

4.  Return FALSE.

MemberExpression : SUPER . IdentifierName

1.  If symbol is the ReservedWord SUPER, return TRUE.

2.  If symbol is a ReservedWord, return FALSE.

3.  If symbol is an Identifier and StringValue of symbol is the
    same value as the StringValue of IdentifierName, return TRUE;

4.  Return FALSE.

CallExpression : CallExpression . IdentifierName

1.  If CallExpression Contains symbol is TRUE, return TRUE.

2.  If symbol is a ReservedWord, return FALSE.

3.  If symbol is an Identifier and StringValue of symbol is the
    same value as the StringValue of IdentifierName, return TRUE;

4.  Return FALSE.

MemberExpression : NEW SUPER

1.  If symbol is the ReservedWord SUPER, return TRUE.

2.  If symbol is the ReservedWord NEW, return TRUE.

3.  Return FALSE.

MemberExpression : NEW SUPER Arguments

1.  If symbol is the ReservedWord SUPER, return TRUE.

2.  If symbol is the ReservedWord NEW, return TRUE.

3.  Return the result of Arguments Contains symbol.

1.  a.  

2.  3.  

1.  

STATIC SEMANTICS: ISVALIDSIMPLEASSIGNMENTTARGET

CallExpression :

CallExpression [ Expression ]
CallExpression . IdentifierName

MemberExpression :

MemberExpression [ Expression ]
MemberExpression . IdentifierName
SUPER [ Expression ]
SUPER . IdentifierName

1.  Return TRUE.

CallExpression :

MemberExpression Arguments
SUPER Arguments
CallExpression Arguments
CallExpression TemplateLiteral

NewExpression : NEW NewExpression

MemberExpression :

NEW SUPER Arguments~opt~
NEW MemberExpression Arguments

1.  Return FALSE.

Property Accessors

Properties are accessed by name, using either the dot notation:

MemberExpression . IdentifierName
CallExpression . IdentifierName

or the bracket notation:

MemberExpression [ Expression ]
CallExpression [ Expression ]

The dot notation is explained by the following syntactic conversion:

MemberExpression . IdentifierName

is identical in its behaviour to

MemberExpression [ <identifier-name-string> ]

and similarly

CallExpression . IdentifierName

is identical in its behaviour to

CallExpression [ <identifier-name-string> ]

where <identifier-name-string> is a string literal containing the same
sequence of characters after processing of Unicode escape sequences as
the IdentifierName.

RUNTIME SEMANTICS: EVALUATION

MemberExpression : MemberExpression [ Expression ]

1.  Let baseReference be the result of evaluating MemberExpression.

2.  Let baseValue be GetValue(baseReference).

3.  ReturnIfAbrupt(baseValue).

4.  Let propertyNameReference be the result of evaluating
    Expression.

5.  Let propertyNameValue be GetValue(propertyNameReference).

6.  ReturnIfAbrupt(propertyNameValue).

7.  Let bv be CheckObjectCoercible(baseValue).

8.  ReturnIfAbrupt(bv).

9.  Let propertyNameString be ToString(propertyNameValue).

10. If the code matched by the syntactic production that is being
    evaluated is strict mode code, let strict be TRUE, else let
    strict be FALSE.

11. Return a value of type Reference whose base value is bv and whose
    referenced name is propertyNameString, and whose strict reference
    flag is strict.

CallExpression : CallExpression [ Expression ]

Is evaluated in exactly the same manner as MemberExpression :
MemberExpression [ Expression ] except that the contained
CallExpression is evaluated in step 1.

The new Operator

RUNTIME SEMANTICS: EVALUATION

NewExpression : NEW NewExpression

1.  Let ref be the result of evaluating NewExpression.

2.  Let constructor be GetValue(ref).

3.  ReturnIfAbrupt(constructor).

4.  If IsConstructor(constructor) is FALSE, throw a TYPEERROR
    exception.

5.  6.  Return the result of calling the [[Construct]] internal method
    on constructor with an empty List as the argument.

MemberExpression : NEW MemberExpression Arguments

1.  Let ref be the result of evaluating MemberExpression.

2.  Let constructor be GetValue(ref).

3.  ReturnIfAbrupt(constructor).

4.  Let argList be the result of evaluating Arguments, producing an
    internal List of argument values (11.2.4).

5.  ReturnIfAbrupt(argList).

6.  If IsConstructor (constructor) is FALSE, throw a TYPEERROR
    exception.

7.  8.  Return the result of calling the [[Construct]] internal method
    on constructor, passing argList as the argument.

Function Calls

RUNTIME SEMANTICS: EVALUATION

CallExpression : MemberExpression Arguments

1.  Let ref be the result of evaluating MemberExpression.

2.  If this CallExpression is in a tail position (13.6) then let
    tailCall be TRUE, otherwise let tailCall be FALSE.

3.  Return the result of the abstract operation EvaluateCall with
    arguments ref, Arguments, and tailCall.

CallExpression : CallExpression Arguments

1.  Let ref be the result of evaluating CallExpression.

2.  If this CallExpression is in a tail position (13.6) then let
    tailCall be TRUE, otherwise let tailCall be FALSE.

3.  Return the result of the abstract operation EvaluateCall with
    arguments ref, Arguments, and tailCall.

RUNTIME SEMANTICS: EVALUATECALL ABSTRACT OPERATION

The abstract operation EvaluateCall takes as arguments a value ref,
and a syntactic grammar production arguments, and a Boolean argument
tailPosition. It performs the following steps:

1.  If Type(ref) is Reference, then

    a.  If IsPropertyReference(ref) is TRUE, then

        i.  Return the result of the abstract operation
            EvaluateMethodCall with arguments ref, arguments, and
            tailPosition.

    b.  Else, the base of ref is an Environment Record

        i.  Let thisValue be the result of calling the WithBaseObject
            concrete method of GetBase(ref).

        ii. If thisValue is not UNDEFINED, then

            1.  Let newRef be a value of type Reference whose base
                value is thisValue and whose referenced name is
                GetReferencedName(ref), and whose strict reference
                flag is IsStrictReference(ref).

            2.  Return the result of the abstract operation
                EvaluateMethodCall with arguments newRef, arguments,
                and tailPosition.

2.  Else Type(ref) is not Reference,

    a.  Let thisValue be UNDEFINED.

3.  Assert: This is a direct function call rather than a method call.

4.  5.  Let func be GetValue(ref).

6.  ReturnIfAbrupt(func).

7.  Let argList be the result of performing ArgumentListEvaluation of
    arguments.

8.  ReturnIfAbrupt(argList).

9.  If Type(func) is not Object, throw a TYPEERROR exception.

10. If IsCallable(func) is FALSE, throw a TYPEERROR exception.

11. a.  i.  

    b.  i.  

12. a.  

13. If tailPosition is TRUE, then perform the PrepareForTailCall
    abstract operation.

    a.  b.  c.  d.  e.  

14. Let result be the result of calling the [[Call]] internal method
    on func, passing thisValue as the thisArgument and argList
    as the argumentsList.

15. Assert: If tailPosition is TRUE, the above call will not return
    here, but instead evaluation will continue with the resumption of
    leafCallerContext as the running execution context.

16. Assert: If result is not an abrupt completion then Type(result)
    is an ECMAScript language type

17. Return result.

RUNTIME SEMANTICS: EVALUATEMETHODCALL ABSTRACT OPERATION

The abstract operation EvaluateMethodCall takes as arguments a value
ref, and a syntactic grammar production arguments, and a Boolean
argument tailPosition. It performs the following steps:

1.  Assert: Type(ref) is Reference and IsPropertyReference(ref) is
    TRUE

2.  3.  Let base be the result of calling GetBase(ref).

4.  If HasPrimitiveBase(ref) is TRUE, then

    a.  Assert: In this case, base will never be NULL or UNDEFINED.

    b.  Let base be ToObject(base).

5.  Let argList be the result of performing ArgumentListEvaluation of
    arguments.

6.  ReturnIfAbrupt(argList).

7.  8.  Let thisValue be GetThisValue(ref).

9.  Let key be GetReferencedName(ref).

10. If tailPosition is TRUE, then perform the PrepareForTailCall
    abstract operation.

11. Let result be the result of calling the [[Invoke]] internal method
    on base, passing key, argList, and thisValue.

12. Assert: If tailPosition is TRUE, the above [[Invoke]] will not
    return here, but instead evaluation will continue with the
    resumption of leafCallerContext as the running execution context.

13. Assert: If result is not an abrupt completion then Type(result)
    is an ECMAScript language type

14. Return result.

The super Keyword

STATIC SEMANTICS

STATIC SEMANTICS: EARLY ERRORS

MemberExpression :

SUPER [ Expression ]
SUPER . IdentifierName
NEW SUPER Arguments~opt~

-   -   

-   

CallExpression : SUPER Arguments

-   It is a Syntax Error if the source code parsed with this production
    is global code that is not eval code.

-   It is a Syntax Error if the source code parsed with this production
    is eval code and the source code is not being processed by a direct
    call to eval that is contained in function code.

-   

RUNTIME SEMANTICS: EVALUATION

MemberExpression : SUPER [ Expression ]

1.  2.  3.  4.  5.  6.  7.  Let propertyNameReference be the result of
    evaluating Expression.

8.  Let propertyNameValue be GetValue(propertyNameReference).

9.  10. Let propertyKey be ToPropertyKey(propertyNameValue).

11. If the code matched by the syntactic production that is being
    evaluated is strict mode code, let strict be TRUE, else let
    strict be FALSE.

12. Return the result of MakeSuperReference(propertyKey, strict).

MemberExpression : SUPER . IdentifierName

1.  2.  3.  4.  5.  6.  Let propertyKey be StringValue of
    IdentifierName.

7.  If the code matched by the syntactic production that is being
    evaluated is strict mode code, let strict be TRUE, else let
    strict be FALSE.

8.  Return the result of MakeSuperReference(propertyKey, strict).

MemberExpression : NEW SUPER Arguments~opt~

1.  If the code matched by the syntactic production that is being
    evaluated is strict mode code, let strict be TRUE, else let
    strict be FALSE.

2.  Let ref be the result of MakeSuperReference(UNDEFINED, strict).

3.  Let constructor be GetValue(ref).

4.  ReturnIfAbrupt(constructor).

5.  If Arguments is present, then

    a.  Let argList be the result of evaluating Arguments, producing
        an internal List of argument values (11.2.4).

    b.  ReturnIfAbrupt(argList).

6.  Else,

    a.  Let argList be a new empty List.

7.  If IsConstructor (constructor) is FALSE, throw a TYPEERROR
    exception.

8.  9.  Return the result of calling the [[Construct]] internal method
    on constructor, passing argList as the argument.

CallExpression : SUPER Arguments

1.  2.  3.  4.  5.  6.  7.  If the code matched by the syntactic
    production that is being evaluated is strict mode code, let strict
    be TRUE, else let strict be FALSE.

8.  Let ref be the result of MakeSuperReference(UNDEFINED, strict).

9.  ReturnIfAbrupt(ref).

10. If this CallExpression is in a tail position (13.7) then let
    tailCall be TRUE, otherwise let tailCall be FALSE.

11. Return the result of the abstract operation EvaluateMethodCall with
    arguments ref, Arguments, and tailCall.

RUNTIME SEMANTICS: ABSTRACT OPERATION MAKESUPERREFERENCE(PROPERTYKEY,
STRICT)

1.  Let env be the result of performing the GetThisEnvironment
    abstract operation.

2.  If the result of calling the HasSuperBinding concrete method of
    env is FALSE, then throw a REFERENCEERROR exception.

3.  Let actualThis be the result of calling the GetThisBinding
    concrete method of env.

4.  Let baseValue be the result of calling the GetSuperBase concrete
    method of env.

5.  Let bv be CheckObjectCoercible(baseValue).

6.  ReturnIfAbrupt(bv).

7.  If propertyKey is UNDEFINED, then

    a.  Let propertyKey be the result of calling the GetMethodName
        concrete method of env.

8.  Return a value of type Reference that is a Super Reference whose
    base value is bv, whose referenced name is propertyKey, whose
    thisValue is actualThis, and whose strict reference flag is
    strict.

Argument Lists

The evaluation of an argument list produces a List of values (see 8.7).

Runtime Semantics

RUNTIME SEMANTICS: ARGUMENTLISTEVALUATION

Arguments : ( )

1.  Return an empty List.

1.  

ArgumentList : AssignmentExpression

1.  Let ref be the result of evaluating AssignmentExpression.

2.  Let arg be GetValue(ref).

3.  ReturnIfAbrupt(arg).

4.  Return a List whose sole item is arg.

ArgumentList : ... AssignmentExpression

1.  Let list be an empty List.

2.  Let spreadRef be the result of evaluating AssignmentExpression.

3.  Let spreadValue be GetValue(spreadRef).

4.  Let spreadObj be ToObject(spreadValue).

5.  ReturnIfAbrupt(spreadObj).

6.  Let lenVal be the result of calling Get(spreadObj, "LENGTH").

7.  Let spreadLen be ToUint32(lenVal).

8.  ReturnIfAbrupt(spreadLen).

9.  Let n = 0.

10. Repeat, while n < spreadLen

    a.  Let nextArg be the result of calling Get(spreadObj,
          ToString(n)).

    b.  ReturnIfAbrupt(nextArg).

    c.  Append nextArg as the last element of list.

    d.  Let n = n+1.

11. Return list.

ArgumentList : ArgumentList , AssignmentExpression

1.  Let precedingArgs be the result of evaluating ArgumentList.

2.  ReturnIfAbrupt(precedingArgs).

3.  Let ref be the result of evaluating AssignmentExpression.

4.  Let arg be GetValue(ref).

5.  ReturnIfAbrupt(arg).

6.  Return a List whose length is one greater than the length of
    precedingArgs and whose items are the items of precedingArgs, in
    order, followed at the end by arg which is the last item of the
    new list.

ArgumentList : ArgumentList , ... AssignmentExpression

1.  Let precedingArgs be an empty List.

2.  Let spreadRef be the result of evaluating AssignmentExpression.

3.  Let spreadValue be GetValue(spreadRef).

4.  Let spreadObj be ToObject(spreadValue).

5.  ReturnIfAbrupt(spreadObj).

6.  Let lenVal be the result of calling Get(spreadObj, "LENGTH").

7.  Let spreadLen be ToUint32(lenVal).

8.  ReturnIfAbrupt(spreadLen).

9.  Let n = 0.

10. Repeat, while n < spreadLen

    a.  Let nextArg be the result of calling Get(spreadObj,
          ToString(n)).

    b.  ReturnIfAbrupt(nextArg).

    c.  Append nextArg as the last element of precedingArgs.

    d.  Let n = n+1.

11. Return precedingArgs.

Tagged Templates

Runtime Semantics

RUNTIME SEMANTICS: EVALUATION

MemberExpression : _MemberExpression TemplateLiteral_

1.  Let tagRef be the result of evaluating MemberExpression.

2.  If this MemberExpression is in a tail position (13.7) then let
    tailCall be TRUE, otherwise let tailCall be FALSE.

3.  Return the result of the abstract operation EvaluateCall with
    arguments tagRef, TemplateLiteral, and tailCall.

CallExpression : _CallExpression TemplateLiteral_

1.  Let tagRef be the result of evaluating CallExpression.

2.  If this CallExpression is in a tail position (13.7) then let
    tailCall be TRUE, otherwise let tailCall be FALSE.

3.  Return the result of the abstract operation EvaluateCall with
    arguments tagRef, TemplateLiteral, and tailCall.


Postfix Expressions

Syntax

PostfixExpression :

LeftHandSideExpression
LeftHandSideExpression [no LineTerminator here] ++
LeftHandSideExpression [no LineTerminator here] --

STATIC SEMANTICS

STATIC SEMANTICS: EARLY ERRORS

-   -   

PostfixExpression :

LeftHandSideExpression [no LineTerminator here] ++
LeftHandSideExpression [no LineTerminator here] --

-   It is an early Reference Error if IsValidSimpleAssignmentTarget of
    LeftHandSideExpression is FALSE.

-   -   -   

STATIC SEMANTICS: ISVALIDSIMPLEASSIGNMENTTARGET

PostfixExpression :

LeftHandSideExpression [no LineTerminator here] ++
LeftHandSideExpression [no LineTerminator here] --

1.  Return FALSE.

Postfix Increment Operator

RUNTIME SEMANTICS: EVALUATION

PostfixExpression : LeftHandSideExpression [no LineTerminator
here] ++

1.  Let lhs be the result of evaluating LeftHandSideExpression.

2.  

-   -   -   -   

1.  Let oldValue be ToNumber(GetValue(lhs)).

2.  ReturnIfAbrupt(oldValue).

3.  Let newValue be the result of adding the value 1 to oldValue,
    using the same rules as for the + operator (see 11.6.3).

4.  Let status be PutValue(lhs, newValue).

5.  ReturnIfAbrupt(status).

6.  Return oldValue.

Postfix Decrement Operator

RUNTIME SEMANTICS: EVALUATION

PostfixExpression : LeftHandSideExpression [no LineTerminator
here] --

1.  Let lhs be the result of evaluating LeftHandSideExpression.

2.  

-   -   -   -   

1.  Let oldValue be ToNumber(GetValue(lhs)).

2.  Let newValue be the result of subtracting the value 1 from
    oldValue, using the same rules as for the - operator (11.6.3).

3.  Let status be PutValue(lhs, newValue).

4.  ReturnIfAbrupt(status).

5.  Return oldValue.


Unary Operators

Syntax

UnaryExpression :

PostfixExpression
DELETE UnaryExpression
VOID UnaryExpression
TYPEOF UnaryExpression
++ UnaryExpression
-- UnaryExpression
+ UnaryExpression
- UnaryExpression
~ UnaryExpression
! UnaryExpression

STATIC SEMANTICS

STATIC SEMANTICS: EARLY ERRORS

-   -   -   -   -   

UnaryExpression :

++ UnaryExpression
-- UnaryExpression

-   It is an early Reference Error if IsValidSimpleAssignmentTarget of
    UnaryExpression is FALSE.

STATIC SEMANTICS: ISVALIDSIMPLEASSIGNMENTTARGET

UnaryExpression :

DELETE UnaryExpression
VOID UnaryExpression
TYPEOF UnaryExpression
++ UnaryExpression
-- UnaryExpression
+ UnaryExpression
- UnaryExpression
~ UnaryExpression
! UnaryExpression

1.  Return FALSE.

The delete Operator

STATIC SEMANTICS: EARLY ERRORS

UnaryExpression : DELETE UnaryExpression

-   It is a Syntax Error if the UnaryExpression is contained in strict
    code and the derived UnaryExpression is PrimaryExpression :
    Identifier.

-   It is a Syntax Error if the derived UnaryExpression is
     PrimaryExpression :
    _CoverParenthesisedExpressionAndArrowParameterList
    _and derives a production that, if used in place of
    UnaryExpression, would produce a Syntax Error according to these
    rules. This rule is recursively applied.

  NOTE The last rule means that expressions such as
   DELETE (((FOO)))
  produce early errors because of recursive application of the first
  rule.

RUNTIME SEMANTICS: EVALUATION

UnaryExpression : DELETE UnaryExpression

1.  Let ref be the result of evaluating UnaryExpression.

2.  ReturnIfAbrupt(ref).

3.  If Type(ref) is not Reference, return TRUE.

4.  If IsUnresolvableReference(ref) is TRUE, then,

    a.  If IsStrictReference(ref) is TRUE, then throw a SYNTAXERROR
        exception.

    b.  Return TRUE.

5.  If IsPropertyReference(ref) is TRUE, then

    a.  If IsSuperReference(ref), then throw a REFERENCEERROR
        exception.

    b.  Let deleteStatus be the result of calling the [[Delete]]
        internal method on ToObject(GetBase(ref)), providing
        GetReferencedName(ref) as the argument.

    c.  ReturnIfAbrupt(deleteStatus).

    d.  If deleteStatus is FALSE and IsStrictReference(ref) is TRUE,
        then throw a TYPEERROR exception.

    e.  Return deleteStatus.

6.  Else ref is a Reference to an Environment Record binding,

    a.  b.  Let bindings be GetBase(ref).

    c.  Return the result of calling the DeleteBinding concrete method
        of bindings, providing GetReferencedName(ref) as the
        argument.

NOTE When a DELETE operator occurs within strict mode code, a
SYNTAXERROR exception is thrown if its UnaryExpression is a direct
reference to a variable, function argument, or function name. In
addition, if a DELETE operator occurs within strict mode code and the
property to be deleted has the attribute { [[Configurable]]: FALSE }, a
TYPEERROR exception is thrown.

The void Operator

RUNTIME SEMANTICS: EVALUATION

UnaryExpression : VOID UnaryExpression

1.  Let expr be the result of evaluating UnaryExpression.

2.  Let status be GetValue(expr).

3.  ReturnIfAbrupt(status).

4.  5.  Return UNDEFINED.

NOTE GetValue must be called even though its value is not used because
it may have observable side-effects.

The typeof Operator

RUNTIME SEMANTICS: EVALUATION

UnaryExpression : TYPEOF UnaryExpression

1.  Let val be the result of evaluating UnaryExpression.

2.  If Type(val) is Reference, then

    a.  If IsUnresolvableReference(val) is TRUE, return "UNDEFINED".

    b.  Let val be GetValue(val).

3.  ReturnIfAbrupt(val).

4.  Return a String determined by Type(val) according to Table 31 .

Table 31 — typeof Operator Results

  ---------------------------------------------------------------------------- ---------------------------------------------------------------------------------------------
  _TYPE OF val_                                                                RESULT
  Undefined                                                                    "UNDEFINED"
  Null                                                                         "OBJECT"
  Boolean                                                                      "BOOLEAN"
  Number                                                                       "NUMBER"
  String                                                                       "STRING"
  Object (ordinary and does not implement [[Call]])                            "OBJECT"
  Object (is a Symbol exotic object)                                           "SYMBOL"
  Object (standard exotic other than Symbol and does not implement [[Call]])   "OBJECT"
  Object (implements [[Call]])                                                 "FUNCTION"
  Object (non-standard exotic and does not implement [[Call]])                 Implementation-defined. May not be "UNDEFINED", "BOOLEAN", "NUMBER", "SYMBOL", or "STRING".
  ---------------------------------------------------------------------------- ---------------------------------------------------------------------------------------------

NOTE Implementations are discouraged from defining new TYPEOF result
values for non-standard exotic objects. If possible "OBJECT"should be
used for such objects.

Prefix Increment Operator

RUNTIME SEMANTICS: EVALUATION

UnaryExpression : ++ UnaryExpression

1.  Let expr be the result of evaluating UnaryExpression.

2.  

-   -   -   -   

1.  Let oldValue be ToNumber(GetValue(expr)).

2.  ReturnIfAbrupt(oldValue).

3.  Let newValue be the result of adding the value 1 to oldValue,
    using the same rules as for the + operator (see 11.6.3).

4.  Let status be PutValue(expr, newValue).

5.  ReturnIfAbrupt(status).

6.  Return newValue.

Prefix Decrement Operator

RUNTIME SEMANTICS: EVALUATION

UnaryExpression : -- UnaryExpression

1.  Let expr be the result of evaluating UnaryExpression.

2.  

-   -   -   -   

1.  Let oldValue be ToNumber(GetValue(expr)).

2.  ReturnIfAbrupt(oldValue).

3.  Let newValue be the result of subtracting the value 1 from
    oldValue, using the same rules as for the - operator (see 11.6.3).

4.  Let status be PutValue(expr, newValue).

5.  ReturnIfAbrupt(status).

6.  Return newValue.

Unary + Operator

NOTE The unary + operator converts its operand to Number type.

RUNTIME SEMANTICS: EVALUATION

UnaryExpression : + UnaryExpression

1.  Let expr be the result of evaluating UnaryExpression.

2.  Return ToNumber(GetValue(expr)).

Unary - Operator

NOTE The unary - operator converts its operand to Number type and then
negates it. Negating +0 produces −0, and negating −0 produces +0.

RUNTIME SEMANTICS: EVALUATION

UnaryExpression : - UnaryExpression

1.  Let expr be the result of evaluating UnaryExpression.

2.  Let oldValue be ToNumber(GetValue(expr)).

3.  ReturnIfAbrupt(oldValue).

4.  If oldValue is NAN, return NAN.

5.  Return the result of negating oldValue; that is, compute a Number
    with the same magnitude but opposite sign.

Bitwise NOT Operator ( ~ )

RUNTIME SEMANTICS: EVALUATION

UnaryExpression : ~ UnaryExpression

1.  Let expr be the result of evaluating UnaryExpression.

2.  Let oldValue be ToInt32(GetValue(expr)).

3.  ReturnIfAbrupt(oldValue).

4.  Return the result of applying bitwise complement to oldValue. The
    result is a signed 32-bit integer.

Logical NOT Operator ( ! )

RUNTIME SEMANTICS: EVALUATION

UnaryExpression : ! UnaryExpression

1.  Let expr be the result of evaluating UnaryExpression.

2.  Let oldValue be ToBoolean(GetValue(expr)).

3.  ReturnIfAbrupt(oldValue).

4.  If oldValue is TRUE, return FALSE.

5.  Return TRUE.


Multiplicative Operators

Syntax

MultiplicativeExpression :

UnaryExpression
MultiplicativeExpression * UnaryExpression
MultiplicativeExpression / UnaryExpression
MultiplicativeExpression % UnaryExpression

STATIC SEMANTICS: ISVALIDSIMPLEASSIGNMENTTARGET

MultiplicativeExpression :

MultiplicativeExpression * UnaryExpression
MultiplicativeExpression / UnaryExpression
MultiplicativeExpression % UnaryExpression

1.  Return FALSE.

RUNTIME SEMANTICS: EVALUATION

The production MultiplicativeExpression : _MultiplicativeExpression @
UnaryExpression_, where @ stands for one of the operators in the above
definitions, is evaluated as follows:

1.  Let left be the result of evaluating MultiplicativeExpression.

2.  Let leftValue be GetValue(left).

3.  ReturnIfAbrupt(leftValue).

4.  Let right be the result of evaluating UnaryExpression.

5.  Let rightValue be GetValue(right).

6.  Let lnum be ToNumber(leftValue).

7.  ReturnIfAbrupt(lnum).

8.  Let rnum be ToNumber(rightValue).

9.  ReturnIfAbrupt(rnum).

10. Return the result of applying the specified operation (*, /, or %)
    to lnum and rnum. See the Notes below 11.5.1, 11.5.2, 11.5.3.

Applying the * Operator

The * operator performs multiplication, producing the product of its
operands. Multiplication is commutative. Multiplication is not always
associative in ECMAScript, because of finite precision.

The result of a floating-point multiplication is governed by the rules
of IEEE 754 binary double-precision arithmetic:

-   If either operand is NAN, the result is NAN.

-   The sign of the result is positive if both operands have the same
      sign, negative if the operands have different signs.

-   Multiplication of an infinity by a zero results in NAN.

-   Multiplication of an infinity by an infinity results in an infinity.
      The sign is determined by the rule already stated above.

-   Multiplication of an infinity by a finite nonzero value results in a
      signed infinity. The sign is determined by the rule already stated
      above.

-   In the remaining cases, where neither an infinity or NaN is
      involved, the product is computed and rounded to the nearest
      representable value using IEEE 754 round-to-nearest mode. If the
      magnitude is too large to represent, the result is then an
      infinity of appropriate sign. If the magnitude is too small to
      represent, the result is then a zero of appropriate sign. The
      ECMAScript language requires support of gradual underflow as
      defined by IEEE 754.

Applying the / Operator

The / operator performs division, producing the quotient of its
operands. The left operand is the dividend and the right operand is the
divisor. ECMAScript does not perform integer division. The operands and
result of all division operations are double-precision floating-point
numbers. The result of division is determined by the specification of
IEEE 754 arithmetic:

-   If either operand is NAN, the result is NAN.

-   The sign of the result is positive if both operands have the same
      sign, negative if the operands have different signs.

-   Division of an infinity by an infinity results in NAN.

-   Division of an infinity by a zero results in an infinity. The sign
      is determined by the rule already stated above.

-   Division of an infinity by a nonzero finite value results in a
      signed infinity. The sign is determined by the rule already stated
      above.

-   Division of a finite value by an infinity results in zero. The sign
      is determined by the rule already stated above.

-   Division of a zero by a zero results in NAN; division of zero by any
      other finite value results in zero, with the sign determined by
      the rule already stated above.

-   Division of a nonzero finite value by a zero results in a signed
      infinity. The sign is determined by the rule already stated above.

-   In the remaining cases, where neither an infinity, nor a zero, nor
      NAN is involved, the quotient is computed and rounded to the
      nearest representable value using IEEE 754 round-to-nearest mode.
      If the magnitude is too large to represent, the operation
      overflows; the result is then an infinity of appropriate sign. If
      the magnitude is too small to represent, the operation underflows
      and the result is a zero of the appropriate sign. The ECMAScript
      language requires support of gradual underflow as defined by IEEE
      754.

Applying the % Operator

The % operator yields the remainder of its operands from an implied
division; the left operand is the dividend and the right operand is the
divisor.

NOTE In C and C++, the remainder operator accepts only integral
operands; in ECMAScript, it also accepts floating-point operands.

The result of a floating-point remainder operation as computed by the %
operator is not the same as the “remainder” operation defined by IEEE
754. The IEEE 754 “remainder” operation computes the remainder from a
rounding division, not a truncating division, and so its behaviour is
not analogous to that of the usual integer remainder operator. Instead
the ECMAScript language defines % on floating-point operations to behave
in a manner analogous to that of the Java integer remainder operator;
this may be compared with the C library function fmod.

The result of an ECMAScript floating-point remainder operation is
determined by the rules of IEEE arithmetic:

-   If either operand is NAN, the result is NAN.

    -   The sign of the result equals the sign of the dividend.

    -   If the dividend is an infinity, or the divisor is a zero, or
          both, the result is NAN.

    -   If the dividend is finite and the divisor is an infinity, the
          result equals the dividend.

    -   If the dividend is a zero and the divisor is nonzero and finite,
          the result is the same as the dividend.

    -   In the remaining cases, where neither an infinity, nor a zero,
          nor NAN is involved, the floating-point remainder r from a
          dividend n and a divisor d is defined by the mathematical
          relation r = n − (d × q) where q is an integer that is
          negative only if n/d is negative and positive only if n/d is
          positive, and whose magnitude is as large as possible without
          exceeding the magnitude of the true mathematical quotient of n
          and d. r is computed and rounded to the nearest representable
          value using IEEE 754 round-to-nearest mode.


Additive Operators

Syntax

AdditiveExpression :

MultiplicativeExpression
AdditiveExpression + MultiplicativeExpression
AdditiveExpression - MultiplicativeExpression

STATIC SEMANTICS: ISVALIDSIMPLEASSIGNMENTTARGET

AdditiveExpression :

AdditiveExpression + MultiplicativeExpression
AdditiveExpression - MultiplicativeExpression

1.  Return FALSE.

The Addition operator ( + )

NOTE The addition operator either performs string concatenation or
numeric addition.

RUNTIME SEMANTICS: EVALUATION

AdditiveExpression : AdditiveExpression + MultiplicativeExpression

NOTE 1 No hint is provided in the calls to ToPrimitive in steps 7 and 9.
All standard ECMAScript objects except Date objects handle the absence
of a hint as if the hint Number were given; Date objects handle the
absence of a hint as if the hint String were given. Exotic objects may
handle the absence of a hint in some other manner.

NOTE 2 Step 11 differs from step 5 of the Abstract Relational Comparison
algorithm (11.8.1), by using the logical-or operation instead of the
logical-and operation.

The Subtraction Operator ( - )

RUNTIME SEMANTICS: EVALUATION

AdditiveExpression : AdditiveExpression - MultiplicativeExpression

Applying the Additive Operators to Numbers

The + operator performs addition when applied to two operands of numeric
type, producing the sum of the operands. The - operator performs
subtraction, producing the difference of two numeric operands.

Addition is a commutative operation, but not always associative.

The result of an addition is determined using the rules of IEEE 754
binary double-precision arithmetic:

-   If either operand is NAN, the result is NAN.

-   The sum of two infinities of opposite sign is NAN.

-   The sum of two infinities of the same sign is the infinity of that
      sign.

-   The sum of an infinity and a finite value is equal to the infinite
      operand.

-   The sum of two negative zeroes is −0. The sum of two positive
      zeroes, or of two zeroes of opposite sign, is +0.

-   The sum of a zero and a nonzero finite value is equal to the nonzero
      operand.

-   The sum of two nonzero finite values of the same magnitude and
      opposite sign is +0.

-   In the remaining cases, where neither an infinity, nor a zero, nor
      NaN is involved, and the operands have the same sign or have
      different magnitudes, the sum is computed and rounded to the
      nearest representable value using IEEE 754 round-to-nearest mode.
      If the magnitude is too large to represent, the operation
      overflows and the result is then an infinity of appropriate sign.
      The ECMAScript language requires support of gradual underflow as
      defined by IEEE 754.

The - operator performs subtraction when applied to two operands of
numeric type, producing the difference of its operands; the left operand
is the minuend and the right operand is the subtrahend. Given numeric
operands a and b, it is always the case that a–b produces the same
result as _a +(–b)_.


Bitwise Shift Operators

Syntax

ShiftExpression :

AdditiveExpression
ShiftExpression << AdditiveExpression
ShiftExpression >> AdditiveExpression
ShiftExpression >>> AdditiveExpression

STATIC SEMANTICS: ISVALIDSIMPLEASSIGNMENTTARGET

ShiftExpression :

ShiftExpression << AdditiveExpression
ShiftExpression >> AdditiveExpression
ShiftExpression >>> AdditiveExpression

1.  Return FALSE.

The Left Shift Operator ( << )

NOTE Performs a bitwise left shift operation on the left operand by the
amount specified by the right operand.

RUNTIME SEMANTICS: EVALUATION

ShiftExpression : ShiftExpression << AdditiveExpression

The Signed Right Shift Operator ( >> )

NOTE Performs a sign-filling bitwise right shift operation on the left
operand by the amount specified by the right operand.

RUNTIME SEMANTICS: EVALUATION

ShiftExpression : ShiftExpression >> AdditiveExpression

The Unsigned Right Shift Operator ( >>> )

NOTE Performs a zero-filling bitwise right shift operation on the left
operand by the amount specified by the right operand.

RUNTIME SEMANTICS: EVALUATION

ShiftExpression : ShiftExpression >>> AdditiveExpression


Relational Operators

NOTE The result of evaluating a relational operator is always of type
Boolean, reflecting whether the relationship named by the operator holds
between its two operands.

Syntax

RelationalExpression :

ShiftExpression
RelationalExpression < ShiftExpression
RelationalExpression > ShiftExpression
RelationalExpression <= ShiftExpression
RelationalExpression >= ShiftExpression
RelationalExpression INSTANCEOF ShiftExpression
RelationalExpression IN ShiftExpression

STATIC SEMANTICS: ISVALIDSIMPLEASSIGNMENTTARGET

RelationalExpression :

RelationalExpression < ShiftExpression
RelationalExpression > ShiftExpression
RelationalExpression <= ShiftExpression
RelationalExpression >= ShiftExpression
RelationalExpression INSTANCEOF ShiftExpression
RelationalExpression IN ShiftExpression

1.  Return FALSE.

Runtime Semantics

RUNTIME SEMANTICS: ABSTRACT RELATIONAL COMPARISON

The comparison x < y, where x and y are values, produces TRUE,
FALSE, or UNDEFINED (which indicates that at least one operand is NAN).
In addition to x and y the algorithm takes a Boolean flag named
LeftFirst as a parameter. The flag is used to control the order in
which operations with potentially visible side-effects are performed
upon x and y. It is necessary because ECMAScript specifies left to
right evaluation of expressions. The default value of LeftFirst is
TRUE and indicates that the x parameter corresponds to an expression
that occurs to the left of the y parameter’s corresponding expression.
If LeftFirst is FALSE, the reverse is the case and operations must be
performed upon y before x. Such a comparison is performed as
follows:

NOTE 1 Step 5 differs from step 11 in the algorithm for the addition
operator + (11.6.1) in using and instead of or.

NOTE 2 The comparison of Strings uses a simple lexicographic ordering on
sequences of code unit values. There is no attempt to use the more
complex, semantically oriented definitions of character or string
equality and collating order defined in the Unicode specification.
Therefore String values that are canonically equal according to the
Unicode standard could test as unequal. In effect this algorithm assumes
that both Strings are already in normalised form. Also, note that for
strings containing supplementary characters, lexicographic ordering on
sequences of UTF-16 code unit values differs from that on sequences of
code point values.

RUNTIME SEMANTICS: EVALUATION

RelationalExpression : RelationalExpression < ShiftExpression

RelationalExpression : RelationalExpression > ShiftExpression

RelationalExpression : RelationalExpression <= ShiftExpression

RelationalExpression : RelationalExpression >= ShiftExpression

RelationalExpression : RelationalExpression INSTANCEOF
ShiftExpression

The abstract operation instanceofOperator(O, C) implements the
generic algorithm for determining if an object O inherits from the
inheritance path defined by constructor C. This abstract operation
performs the following steps:

1.  If Type(C) is not Object, throw a TYPEERROR exception.

2.  Let instOfHandler be the result of GetMethod(C,@@hasInstance).

3.  ReturnIfAbrupt(instOfHandler).

4.  If instOfHandler is not UNDEFINED, then

    a.  Let result be the result of calling the [[Call]] internal
        method of instOfHandler passing C as thisArgument and a
        new List containing O as argumentsList.

    b.  Return ToBoolean(result).

5.  If IsCallable(C) is FALSE, then throw a TYPEERROR exception.

6.  Return the result of OrdinaryHasInstance(C, O).

NOTE Steps 5 and 6 provide compatibility with previous editions of
ECMAScript that did not use a @@hasInstance method to define the
INSTANCEOF operator semantics. If a function object does not define or
inherit @@hasInstance it uses the default INSTANCEOF semantics.

RelationalExpression : RelationalExpression IN ShiftExpression


Equality Operators

NOTE The result of evaluating an equality operator is always of type
Boolean, reflecting whether the relationship named by the operator holds
between its two operands.

Syntax

EqualityExpression :

RelationalExpression
EqualityExpression == RelationalExpression
EqualityExpression != RelationalExpression
EqualityExpression === RelationalExpression
EqualityExpression !== RelationalExpression

STATIC SEMANTICS: ISVALIDSIMPLEASSIGNMENTTARGET

EqualityExpression :

EqualityExpression == RelationalExpression
EqualityExpression != RelationalExpression
EqualityExpression === RelationalExpression
EqualityExpression !== RelationalExpression

1.  Return FALSE.

Runtime Semantics

RUNTIME SEMANTICS: ABSTRACT EQUALITY COMPARISON

The comparison x == y, where x and y are values, produces TRUE
or FALSE. Such a comparison is performed as follows:

NOTE 1 Given the above definition of equality:

-   String comparison can be forced by: "" + A == "" + B.

-   Numeric comparison can be forced by: +A == +B.

-   Boolean comparison can be forced by: !A == !B.

NOTE 2 The equality operators maintain the following invariants:

-   A != B is equivalent to !(A == B).

-   A == B is equivalent to B == A, except in the order of evaluation of
      A and B.

NOTE 3 The equality operator is not always transitive. For example,
there might be two distinct String objects, each representing the same
String value; each String object would be considered equal to the String
value by the == operator, but the two String objects would not be equal
to each other. For Example:

-   NEW STRING("A") == "A" and "A" == NEW STRING("A")are both TRUE.

-   NEW STRING("A") == NEW STRING("A") is FALSE.

NOTE 4 Comparison of Strings uses a simple equality test on sequences of
code unit values. There is no attempt to use the more complex,
semantically oriented definitions of character or string equality and
collating order defined in the Unicode specification. Therefore Strings
values that are canonically equal according to the Unicode standard
could test as unequal. In effect this algorithm assumes that both
Strings are already in normalised form.

RUNTIME SEMANTICS: STRICT EQUALITY COMPARISON

The comparison x === y, where x and y are values, produces TRUE
or FALSE. Such a comparison is performed as follows:

NOTE This algorithm differs from the SameValue Algorithm (9.12) in its
treatment of signed zeroes and NaNs.

RUNTIME SEMANTICS: EVALUATION

EqualityExpression : EqualityExpression == RelationalExpression

EqualityExpression : EqualityExpression != RelationalExpression

EqualityExpression : EqualityExpression === RelationalExpression

EqualityExpression : EqualityExpression !== RelationalExpression

1.  2.  3.  4.  5.  6.  7.  

1.  2.  3.  4.  5.  6.  7.  8.  


Binary Bitwise Operators

Syntax

BitwiseANDExpression :

EqualityExpression
BitwiseANDExpression & EqualityExpression

BitwiseXORExpression :

BitwiseANDExpression
BitwiseXORExpression ^ BitwiseANDExpression

BitwiseORExpression :

BitwiseXORExpression
BitwiseORExpression | BitwiseXORExpression

STATIC SEMANTICS: ISVALIDSIMPLEASSIGNMENTTARGET

BitwiseANDExpression : BitwiseANDExpression & EqualityExpression

BitwiseXORExpression : BitwiseXORExpression ^ BitwiseANDExpression

BitwiseORExpression : BitwiseORExpression | BitwiseXORExpression

1.  Return FALSE.

RUNTIME SEMANTICS: EVALUATION

The production A : _A @ B_, where @ is one of the bitwise operators in
the productions above, is evaluated as follows:


Binary Logical Operators

Syntax

LogicalANDExpression :

BitwiseORExpression
LogicalANDExpression && BitwiseORExpression

LogicalORExpression :

LogicalANDExpression
LogicalORExpression || LogicalANDExpression

NOTE The value produced by a && or || operator is not necessarily of
type Boolean. The value produced will always be the value of one of the
two operand expressions.

STATIC SEMANTICS: ISVALIDSIMPLEASSIGNMENTTARGET

LogicalANDExpression : LogicalANDExpression && BitwiseORExpression

LogicalORExpression : LogicalORExpression || LogicalANDExpression

1.  Return FALSE.

RUNTIME SEMANTICS: EVALUATION

LogicalANDExpression : LogicalANDExpression && BitwiseORExpression

LogicalORExpression : LogicalORExpression || LogicalANDExpression


Conditional Operator ( ? : )

Syntax

ConditionalExpression :

LogicalORExpression
LogicalORExpression ? AssignmentExpression : AssignmentExpression

NOTE The grammar for a ConditionalExpression in ECMAScript is a little
bit different from that in C and Java, which each allow the second
subexpression to be an Expression but restrict the third expression to
be a ConditionalExpression. The motivation for this difference in
ECMAScript is to allow an assignment expression to be governed by either
arm of a conditional and to eliminate the confusing and fairly useless
case of a comma expression as the centre expression.

STATIC SEMANTICS: ISVALIDSIMPLEASSIGNMENTTARGET

ConditionalExpression : LogicalORExpression ? AssignmentExpression :
AssignmentExpression

1.  Return FALSE.

RUNTIME SEMANTICS: EVALUATION

ConditionalExpression : LogicalORExpression ? AssignmentExpression
: AssignmentExpression


Assignment Operators

Syntax

AssignmentExpression :

ConditionalExpression
YieldExpression
ArrowFunction
LeftHandSideExpression = AssignmentExpression
LeftHandSideExpression AssignmentOperator AssignmentExpression

AssignmentOperator : ONE OF

  ---- ---- ---- ---- ---- ----- ----- ------ ---- ---- ----
  *=   /=   %=   +=   -=   <<=   >>=   >>>=   &=   ^=   |=
  ---- ---- ---- ---- ---- ----- ----- ------ ---- ---- ----

Static Semantics

STATIC SEMANTICS: EARLY ERRORS

-   -   

-   -   -   -   -   -   

AssignmentExpression : LeftHandSideExpression = AssignmentExpression

-   It is a Syntax Error if LeftHandSideExpression is either an
    ObjectLiteral or an ArrayLiteral and if the lexical token
    sequence matched by LeftHandSideExpression cannot be parsed with
    no tokens left over using AssignmentPattern as the goal symbol.

-   If LeftHandSideExpression is either an ObjectLiteral or an
    ArrayLiteral and if the lexical token sequence matched by
    LeftHandSideExpression can be parsed with no tokens left over
    using AssignmentPattern as the goal symbol then the following
    rules are not applied. Instead, the Early Error rules for
    AssignmentPattern are used.

-   It is a Syntax Error if LeftHandSideExpression is an Identifier
    that can be statically determined to always resolve to a declarative
    environment record binding and the resolved binding is an immutable
    binding.

-   It is an early Reference Error if LeftHandSideExpression is
    neither an ObjectLiteral nor an ArrayLiteral and
    IsValidSimpleAssignmentTarget of LeftHandSideExpression is FALSE.

-   

AssignmentExpression : LeftHandSideExpression AssignmentOperator
AssignmentExpression

-   It is a Syntax Error if the LeftHandSideExpression is an
    Identifier that can be statically determined to always resolve to
    a declarative environment record binding and the resolved binding is
    an immutable binding.

-   It is an early Reference Error if IsValidSimpleAssignmentTarget of
    LeftHandSideExpression is FALSE.

STATIC SEMANTICS: ISVALIDSIMPLEASSIGNMENTTARGET

AssignmentExpression :

YieldExpression
ArrowFunction
LeftHandSideExpression = AssignmentExpression
LeftHandSideExpression AssignmentOperator AssignmentExpression

1.  Return FALSE.

Runtime Semantics

RUNTIME SEMANTICS: EVALUATION

AssignmentExpression : LeftHandSideExpression =
AssignmentExpression

AssignmentExpression : _LeftHandSideExpression AssignmentOperator
AssignmentExpression_

-   -   -   -   

NOTE When an assignment occurs within strict mode code, it is an runtime
error if lref in step 1.e of the first algorithm or step 9 of the
second algorithm it is an unresolvable reference. If it is, a
REFERENCEERROR exception is thrown. The LeftHandSide also may not be a
reference to a data property with the attribute value
{[[Writable]]:FALSE}, to an accessor property with the attribute value
{[[Set]]:UNDEFINED}, nor to a non-existent property of an object for
which the IsExtensible predicate returns the value FALSE. In these cases
a TYPEERROR exception is thrown.

Destructuring Assignment

Supplemental Syntax

In certain circumstances when processing the production
AssignmentExpression : LeftHandSideExpression =
AssignmentExpression the following grammar is used to refine the
interpretation of LeftHandSideExpression.

AssignmentPattern :

ObjectAssignmentPattern
ArrayAssignmentPattern

ObjectAssignmentPattern :

{ }
{ AssignmentPropertyList }
{ AssignmentPropertyList , }

ArrayAssignmentPattern :

[ Elision~opt~ AssignmentRestElement~opt~ ]
[ AssignmentElementList ]
[ AssignmentElementList , Elision~opt~ AssignmentRestElement~opt~ ]

AssignmentPropertyList :

AssignmentProperty
AssignmentPropertyList , AssignmentProperty

AssignmentElementList :

Elision~opt~ AssignmentElement
AssignmentElementList , Elision~opt~ AssignmentElement

AssignmentProperty :

Identifier Initialiser~opt~
PropertyName : AssignmentElement

AssignmentElement :

DestructuringAssignmentTarget Initialiser~opt~

AssignmentRestElement :

... DestructuringAssignmentTarget

DestructuringAssignmentTarget :

LeftHandSideExpression

Static Semantics

STATIC SEMANTICS: EARLY ERRORS

AssignmentProperty : Identifier Initialiser~opt~

-   It is a Syntax Error if Identifier is the Identifier EVAL or the
    Identifier ARGUMENTS.

-   -   It is a Syntax Error if Identifier does not statically resolve
    to a declarative environment record binding or if the resolved
    binding is an immutable binding.

AssignmentRestElement : ... DestructuringAssignmentTarget

-   It is a Syntax Error if IsValidSimpleAssignmentTarget of
    DestructuringAssignmentTarget is FALSE.

DestructuringAssignmentTarget : LeftHandSideExpression

-   It is a Syntax Error if LeftHandSideExpression is either an
    ObjectLiteral or an ArrayLiteral and if the lexical token
    sequence matched by LeftHandSideExpression cannot be parsed with
    no tokens left over using AssignmentPattern as the goal symbol.

-   It is a Syntax Error if LeftHandSideExpression is neither an
    ObjectLiteral nor an ArrayLiteral and
    IsValidSimpleAssignmentTarget of LeftHandSideExpression is FALSE.

-   It is a Syntax Error if LeftHandSideExpression is an Identifier
    that can be statically determined to always resolve to a declarative
    environment record binding and the resolved binding is an immutable
    binding.

-   It is a Syntax Error if LeftHandSideExpression is the Identifier
    EVAL or the Identifier ARGUMENTS.

-   -   -   -   -   It is a Syntax Error if LeftHandSideExpression is
    CoverParenthesisedExpressionAndArrowParameterList : ( Expression
    )
    and Expression derives a production that would produce a Syntax
    Error according to these rules if that production is substituted for
    LeftHandSideExpression. This rule is recursively applied.

  NOTE The last rule means that the other rules are applied even if
  multiple levels of nested parenthesises surround Expression.

Runtime Semantics

RUNTIME SEMANTICS: DESTRUCTURING ASSIGNMENT EVALUATION

  with parameter obj

1.  2.  

1.  2.  

ObjectAssignmentPattern : { }

and

ArrayAssignmentPattern :

[]
[Elision]

1.  Return NormalCompletion(empty).

1.  2.  

1.  2.  

AssignmentPropertyList : AssignmentPropertyList ,
AssignmentProperty

  Let status be

1.  the result of performing Destructuring Assignment Evaluation for
    AssignmentPropertyList using obj as the argument.

2.  ReturnIfAbrupt(status).

3.  Return the result of performing Destructuring Assignment Evaluation
    for AssignmentProperty using obj as the argument.

AssignmentProperty : Identifier Initialiser~opt~

1.  Let P be StringValue of Identifier.

2.  3.  4.  5.  Let v be the result of calling Get(obj, P).

6.  ReturnIfAbrupt(v).

7.  8.  If Initialiser~opt~ is present and v is UNDEFINED, then

    a.  Let defaultValue be the result of evaluating Initialiser.

    b.  Let v be ToObject(GetValue(defaultValue)).

        i.  

9.  ReturnIfAbrupt(v).

10. Let lref be the result of performing Identifier Resolution(10.3.1)
    with the IdentifierName corresponding to Identifier.

11. Return PutValue(lref_,_v).

12. 

-   -   -   -   -   -   

AssignmentProperty : PropertyName : AssignmentElement

1.  Let name be the result of evaluating PropertyName.

2.  ReturnIfAbrupt(name).

3.  Return the result of performing Keyed Destructuring Assignment
    Evaluation of AssignmentElement with obj and name as the
    arguments.

4.  5.  6.  a.  b.  c.  d.  e.  

7.  8.  9.  

ArrayAssignmentPattern : [ Elision~opt~ AssignmentRestElement ]

1.  Let skip be the Elision Width of Elision; if Elision is not
    present, use the numeric value zero.

2.  Return the result of performing Indexed Destructuring Assignment
    Evaluation of AssignmentRestElement with obj and skip as the
    arguments.

3.  

ArrayAssignmentPattern : [ AssignmentElementList ]

1.  Return the result of performing Indexed Destructuring Assignment
    Evaluation of AssignmentElementList using obj and 0 as the
    arguments.

2.  

ArrayAssignmentPattern : [ AssignmentElementList , Elision~opt~
AssignmentRestElement~opt~ ]

1.  2.  Let lastIndex be the result of performing Indexed
    Destructuring Assignment Evaluation of AssignmentElementList using
    obj and 0 as the arguments.

3.  ReturnIfAbrupt(lastIndex).

4.  Let skip be the Elision Width of Elision; if Elision is not
    present, use the numeric value zero.

5.  If AssignmentRestElement is present, then return the result of
    performing Indexed Destructuring Assignment Evaluation of
    AssignmentRestElement with obj and lastIndex_+_skip as the
    arguments.

6.  7.  Return lastIndex.

RUNTIME SEMANTICS: INDEXED DESTRUCTURING ASSIGNMENT EVALUATION

  with parameters obj and index

AssignmentElementList : Elision~opt~ _AssignmentElement _

1.  Let skip be the Elision Width of Elision; if Elision is not
    present, use the numeric value zero.

2.  Let name be ToString(index_+_skip).

3.  Let status be the result of performing Keyed Destructuring
    Assignment Evaluation of AssignmentElement with obj and name
    as the arguments.

4.  ReturnIfAbrupt(status).

5.  Return index_+_skip+1.

6.  

AssignmentElementList : AssignmentElementList , Elision~opt~
_AssignmentElement _

1.  Let listNext be the result of performing Indexed Destructuring
    Assignment Evaluation of AssignmentElementList using obj as the
    obj parameter and index as the index parameter

2.  Let skip be the Elision Width of Elision; if Elision is not
    present, use the numeric value zero.

3.  ReturnIfAbrupt(listNext).

4.  Let name be ToString(listNext_+_skip).

5.  Let status be the result of performing Keyed Destructuring
    Assignment Evaluation of AssignmentElement with obj and name
    as the arguments.

6.  ReturnIfAbrupt(status).

7.  Return listNext_+_skip+1.

8.  

1.  2.  3.  4.  5.  6.  a.  b.  i.  

7.  8.  9.  10. a.  b.  c.  d.  e.  

11. 12. 13. 

AssignmentRestElement : ... DestructuringAssignmentTarget

1.  Let lref be the result of evaluating
    DestructuringAssignmentTarget.

2.  ReturnIfAbrupt(lref).

3.  Let lenVal be the result of Get(obj, "LENGTH").

4.  Let len be ToUint32(lenVal).

5.  ReturnIfAbrupt(len).

6.  Let A be the result of the abstract operation ArrayCreate with
    argument 0.

7.  Let n=0;

8.  Repeat, while index < len

    a.  Let P be ToString(index).

    b.  Let exists be the result of HasProperty(obj, P).

    c.  ReturnIfAbrupt(exists).

    d.  If exists is TRUE, then

        i.  Let v be the result of Get(obj, ToString(index)).

        ii. ReturnIfAbrupt(len).

        iii. Call the [[DefineOwnProperty]] internal method of A with
              arguments ToString(n) and Property Descriptor
              {[[Value]]: v, [[Writable]]: TRUE, [[Enumerable]]: TRUE,
              [[Configurable]]: TRUE}.

    e.  Let n = n+1.

    f.  Let index = index+1.

9.  Return PutValue(lref_,_A).

10. 

RUNTIME SEMANTICS: KEYED DESTRUCTURING ASSIGNMENT EVALUATION

  with parameters obj and propertyName

AssignmentElement : DestructuringAssignmentTarget Initialiser~opt~

1.  Let exists be the result of HasPropety(obj, propertyName).

2.  ReturnIfAbrupt(exists).

3.  If exists is FALSE, then

    a.  If Initialiser~opt~ is not present, then throw a TYPEERROR
        exception.

    b.  Else, let v be UNDEFINED.

4.  Else,

    a.  Let v be the result of Get(obj, propertyName).

    b.  ReturnIfAbrupt(v).

5.  If Initialiser~opt~ is present and v is UNDEFINED, then

    a.  Let defaultValue be the result of evaluating Initialiser.

    b.  Let v be GetValue(defaultValue)

    c.  ReturnIfAbrupt(v).

6.  If DestructuringAssignmentTarget is an ObjectLiteral or an
    ArrayLiteral then

    a.  Let AssignmentPattern be the parse of the source code
        corresponding to DestructuringAssignmentTarget using
        AssignmentPattern as the goal symbol

    b.  c.  d.  If Type(v) is not Object, then throw a TYPEERROR
        exception.

    e.  Return the result of performing Destructuring Assignment
        Evaluation of AssignmentPattern with v as the argument.

7.  8.  Let lref be the result of evaluating
    DestructuringAssignmentTarget.

9.  Return PutValue(lref_,_v).


Comma Operator ( , )

Syntax

Expression :

AssignmentExpression
Expression , AssignmentExpression

STATIC SEMANTICS: ISVALIDSIMPLEASSIGNMENTTARGET

Expression : Expression , AssignmentExpression

1.  Return FALSE.

RUNTIME SEMANTICS: EVALUATION

Expression : Expression , AssignmentExpression

NOTE GetValue must be called even though its value is not used because
it may have observable side-effects.



STATEMENTS AND DECLARATIONS


Syntax

Statement :

BlockStatement
VariableStatement
EmptyStatement
ExpressionStatement
IfStatement
BreakableStatement
ContinueStatement
BreakStatement
ReturnStatement
WithStatement
LabelledStatement
ThrowStatement
TryStatement
DebuggerStatement

Declaration :

FunctionDeclaration
GeneratorDeclaration
ClassDeclaration
LexicalDeclaration

BreakableStatement :

IterationStatement
SwitchStatement

STATIC SEMANTICS

1.  

STATIC SEMANTICS: VARDECLAREDNAMES

Statement :

EmptyStatement
ExpressionStatement
ContinueStatement
BreakStatement
ReturnStatement
ThrowStatement
DebuggerStatement

1.  Return a new empty List.

RUNTIME SEMANTICS

RUNTIME SEMANTICS: LABELLED EVALUATION

  With argument labelSet.

BreakableStatement : IterationStatement

1.  Let stmtResult be the result of performing Labelled Evaluation of
    IterationStatement with argument labelSet.

2.  If stmtResult.[[type]] is break and stmtResult.[[target]] is
    empty, then

    a.  If stmtResult.[[value]] is empty, then let stmtResult be
        NormalCompletion(UNDEFINED).

    b.  Else, let stmtResult be
        NormalCompletion(stmtResult.[[value]])

3.  Return stmtResult.

BreakableStatement : SwitchStatement

1.  Let stmtResult be the result of evaluating SwitchStatement.

2.  If stmtResult.[[type]] is break and stmtResult.[[target]] is
    empty, then

    a.  If stmtResult.[[value]] is empty, then let stmtResult be
        NormalCompletion(UNDEFINED).

    b.  Else, let stmtResult be
        NormalCompletion(stmtResult.[[value]])

3.  Return stmtResult.

NOTE A BreakableStatement is one that can be exited via an unlabelled
BreakStatement.

RUNTIME SEMANTICS: EVALUATION

1.  

1.  

BreakableStatement :

IterationStatement
SwitchStatement

1.  Let newLabelSet be a new empty List.

2.  Return the result of performing Labelled Evaluation of this
    BreakableStatement with argument newLabelSet.


Block

Syntax

BlockStatement :

Block

Block :

{ StatementList~opt~ }

StatementList :

StatementListItem
StatementList StatementListItem

StatementListItem :

Statement
Declaration

Static Semantics

STATIC SEMANTICS: EARLY ERRORS

Block : { StatementList }

-   -   It is a Syntax Error if the LexicallyDeclaredNames of
    StatementList contains any duplicate entries.

-   It is a Syntax Error if any element of the LexicallyDeclaredNames of
    StatementList also occurs in the VarDeclaredNames of
    StatementList.

STATIC SEMANTICS: LEXICALDECLARATIONS

1.  

StatementList : _StatementList StatementListItem_

1.  Let declarations be LexicalDeclarations of StatementList.

2.  Append to declarations the elements of the LexicalDeclarations of
    StatementListItem.

3.  Return declarations.

StatementListItem : Statement

1.  Return a new empty List.

StatementListItem : Declaration

1.  Return a new List containing Declaration.

1.  

1.  

STATIC SEMANTICS: LEXICALLYDECLAREDNAMES

Block : { }

1.  Return a new empty List.

1.  

1.  

StatementList : _StatementList StatementListItem_

1.  Let names be LexicallyDeclaredNames of StatementList.

2.  Append to names the elements of the LexicallyDeclaredNames of
    StatementListItem.

3.  Return names.

StatementListItem : Statement

1.  Return a new empty List.

StatementListItem : Declaration

1.  Return the BoundNames of Declaration.

STATIC SEMANTICS: TOPLEVELLEXICALLYDECLAREDNAMES

StatementList : _StatementList StatementListItem_

1.  Let names be TopLevelLexicallyDeclaredNames of StatementList.

2.  Append to names the elements of the TopLevelLexicallyDeclaredNames
    of StatementListItem.

3.  Return names.

StatementListItem : Statement

1.  Return a new empty List.

StatementListItem : Declaration

1.  If Declaration is Declaration : FunctionDeclaration, then
    return a new empty List.

2.  Return the BoundNames of Declaration.

NOTE At the top level of a function, or script, function declarations
are treated like var declarations rather than like lexical declarations.

STATIC SEMANTICS: TOPLEVELLEXICALLYSCOPEDDECLARATIONS

StatementList : _StatementList StatementListItem_

1.  Let declarations be TopLevelLexicallyScopedDeclarations of
    StatementList.

2.  Append to declarations the elements of the
    TopLevelLexicallyScopedDeclarations of StatementListItem.

3.  Return declarations.

StatementListItem : Statement

1.  Return a new empty List.

StatementListItem : Declaration

1.  If Declaration is Declaration : FunctionDeclaration, then
    return a new empty List.

2.  Return a new List containing Declaration.

STATIC SEMANTICS: TOPLEVELVARDECLAREDNAMES

StatementList : _StatementList StatementListItem_

1.  Let names be TopLevelVarDeclaredNames of StatementList.

2.  Append to names the elements of the TopLevelVarDeclaredNames of
    StatementListItem.

3.  Return names.

StatementListItem : Declaration

1.  If Declaration is Declaration : FunctionDeclaration, then
    return the LexicallyDeclaredNames of Declaration.

2.  Return a new empty List.

StatementListItem : Statement

1.  Return VarDeclaredNames of Statement.

NOTE At the top level of a function or script, inner function
declarations are treated like var declarations.

STATIC SEMANTICS: TOPLEVELVARSCOPEDDECLARATIONS

StatementList : _StatementList StatementListItem_

1.  Let declarations be TopLevelVarScopedDeclarations of
    StatementList.

2.  Append to declarations the elements of the
    TopLevelVarScopedDeclarations of StatementListItem.

3.  Return declarations.

StatementListItem : Statement

1.  If Statement is Statement : VariableStatement, then return a
    new List containing VariableStatement.

2.  Return a new empty List.

StatementListItem : Declaration

1.  If Declaration is Declaration : FunctionDeclaration, then
    return a new List containing Declaration.

2.  Return a new empty List.

STATIC SEMANTICS: VARDECLAREDNAMES

1.  

Block : { }

1.  Return a new empty List.

1.  

1.  

StatementList : _StatementList StatementListItem_

1.  Let names be VarDeclaredNames of StatementList.

2.  Append to names the elements of the VarDeclaredNames of
    StatementListItem.

3.  Return names.

1.  

StatementListItem : Declaration

1.  Return a new empty List.

Runtime Semantics

RUNTIME SEMANTICS: EVALUATION

1.  

Block : { }

1.  Return NormalCompletion(UNDEFINED).

-   -   -   

1.  

1.  

Block : { StatementList }

1.  Let oldEnv be the running execution context’s LexicalEnvironment.

2.  Let blockEnv be the result of calling NewDeclarativeEnvironment
    passing oldEnv as the argument.

3.  Perform Block Declaration Instantiation using StatementList and
    blockEnv.

4.  Set the running execution context’s LexicalEnvironment to
    blockEnv.

5.  Let blockValue be the result of evaluating StatementList.

6.  Set the running execution context’s LexicalEnvironment to oldEnv.

7.  If blockValue.[[type]] is normal and blockValue.[[value]] is
    empty, then

    a.  Return NormalCompletion(UNDEFINED).

8.  Return blockValue.

NOTE No matter how control leaves the Block the LexicalEnvironment is
always restored to its former state.

1.  

1.  

1.  

1.  2.  3.  

1.  2.  3.  

1.  2.  3.  

StatementList : _StatementList StatementListItem_

NOTE Steps 5 and 6 of the above algorithm ensure that the value of a
StatementList is the value of the last value producing Statement in
the StatementList. For example, the following calls to the EVAL
function all return the value 1:

  EVAL("1;;;;;")

  EVAL("1;{}")

  EVAL("1;VAR A;")


Declarations and the Variable Statement

Let and Const Declarations

NOTE A LET and CONST declarations define variables that are scoped to
the running execution context’s LexicalEnvironment. The variables are
created when their containing Lexical Environment is instantiated but
may not be accessed in any way until the variable’s LexicalBinding is
evaluated. A variable defined by a LexicalBinding with an
Initialiser is assigned the value of its Initialiser’s
AssignmentExpression when the LexicalBinding is evaluated, not when
the variable is created. If a LexicalBinding in a LET declaration does
not have an Initialiser the variable is assigned the value UNDEFINED
when the LexicalBinding is evaluated.

Syntax

LexicalDeclaration :

LetOrConst BindingList ;

LetOrConst :

LET
CONST

BindingList :

LexicalBinding
BindingList , LexicalBinding

LexicalBinding :

BindingIdentifier Initialiser~opt
~BindingPattern Initialiser

BindingIdentifier :

Identifier

 Static Semantics

STATIC SEMANTICS: EARLY ERRORS

LexicalBinding : BindingIdentifier

-   It is a Syntax Error if IsConstantDeclaration of the
    LexicalDeclaration containing this production is TRUE.

-   

BindingIdentifier : Identifier

-   It is a Syntax Error if the BindingIdentifier is contained in
    strict code and if the Identifier is EVAL or ARGUMENTS.

STATIC SEMANTICS: BOUNDNAMES

LexicalDeclaration : _LetOrConst BindingList_ ;

1.  Return the BoundNames of BindingList.

1.  

BindingList : BindingList , LexicalBinding

1.  Let names be the BoundNames of BindingList.

2.  Append to names the elements of the BoundNames of
    LexicalBinding.

3.  Return names.

LexicalBinding : _BindingIdentifier Initialiser_~opt~

1.  Return the BoundNames of BindingIdentifier.

LexicalBinding : _BindingPattern Initialiser_

1.  Return the BoundNames of BindingPattern.

BindingIdentifier : Identifier

1.  Return a new List containing the StringValue of Identifier.

STATIC SEMANTICS: ISCONSTANTDECLARATION

LexicalDeclaration : _LetOrConst BindingList_ ;

1.  Return IsConstantDeclaration of LetOrConst.

LetOrConst : LET

1.  Return FALSE.

LetOrConst : CONST

1.  Return TRUE.

Runtime Semantics

RUNTIME SEMANTICS: BINDING INITIALISATION

  With arguments value and environment.

NOTE UNDEFINED is passed for environment to indicate that a PutValue
operation should be used to assign the initialisation value. This is the
case for VAR statements formal parameter lists of non-strict functions.
In those cases a lexical binding is hosted and preinitialised prior to
evaluation of its initialiser.

BindingIdentifier : Identifier

1.  

1.  If environment is not UNDEFINED, then

    a.  Let name be StringValue of Identifier.

    b.  Let env be the environment record component of environment.

    c.  Call the InitialiseBinding concrete method of env passing
        name and value as the arguments.

    d.  Return NormalCompletion(UNDEFINED).

2.  Else

    a.  Let lhs be the result of evaluating Identifier as described
        in 11.1.2.

    b.  Return PutValue(lhs, value).

RUNTIME SEMANTICS: EVALUATION

LexicalDeclaration : _LetOrConst BindingList_ ;

1.  Let next be the result of evaluating BindingList.

2.  ReturnIfAbrupt(next).

3.  Return NormalCompletion(empty).

1.  

BindingList : BindingList , LexicalBinding

1.  Let next be the result of evaluating BindingList.

2.  ReturnIfAbrupt(next).

3.  Return the result of evaluating LexicalBinding.

LexicalBinding : _BindingIdentifier _

1.  Let env be the running execution context’s LexicalEnvironment.

2.  Return the result of performing Binding Initialisation for
    BindingIdentifier passing UNDEFINED and env as the arguments.

NOTE A static semantics rule ensures that this form of LexicalBinding
never occurs in a CONST declaration.

LexicalBinding : _BindingIdentifier Initialiser_

1.  Let rhs be the result of evaluating Initialiser.

2.  Let value be GetValue(rhs).

3.  ReturnIfAbrupt(value).

4.  Let env be the running execution context’s LexicalEnvironment.

5.  Return the result of performing Binding Initialisation for
    BindingIdentifier passing value and env as the arguments.

LexicalBinding : _BindingPattern Initialiser_

1.  Let rhs be the result of evaluating Initialiser.

2.  Let value be GetValue(rhs).

3.  ReturnIfAbrupt(value).

4.  If Type(value) is not Object, then throw a TYPEERROR exception.

5.  Let env be the running execution context’s LexicalEnvironment.

6.  Return the result of performing Binding Initialisation for
    BindingPattern using value and env as the arguments.

Variable Statement

NOTE A VAR statement declares variables that are scoped to the running
execution context’s VariableEnvironment. Var variables are created when
their containing Lexical Environment is instantiated and are initialised
to UNDEFINED when created. Within the scope of any VariableEnvironemnt a
common Identifier may appear in more than one VariableDeclaration
but those declarations collective define only one variable. A variable
defined by a VariableDeclaration with an Initialiser is assigned the
value of its Initialiser’s AssignmentExpression when the
VariableDeclaration is executed, not when the variable is created.

Syntax

VariableStatement :

VAR VariableDeclarationList ;

VariableDeclarationList :

VariableDeclaration
VariableDeclarationList , VariableDeclaration

VariableDeclaration :

BindingIdentifier Initialiser~opt
~BindingPattern Initialiser

Static Semantics

-   

STATIC SEMANTICS: BOUNDNAMES

1.  

1.  

VariableDeclarationList : VariableDeclarationList ,
VariableDeclaration

1.  Let names be BoundNames of VariableDeclarationList.

2.  Append to names the elements of BoundNames of
    VariableDeclaration.

3.  Return names.

VariableDeclaration : _BindingIdentifier Initialiser_~opt~

1.  Return the BoundNames of BindingIdentifier.

VariableDeclaration : _BindingPattern Initialiser_

1.  Return the BoundNames of BindingPattern.

Runtime Semantics

RUNTIME SEMANTICS: BINDING INITIALISATION

  With arguments value and environment.

NOTE UNDEFINED is passed for environment to indicate that a PutValue
operation should be used to assign the initialisation value. This is the
case for VAR statements formal parameter lists of non-strict functions.
In those cases a lexical binding is hosted and preinitialised prior to
evaluation of its initialiser.

VariableDeclaration : BindingIdentifier

1.  Return the result of performing Binding Initialisation for
    BindingIdentifier passing value and UNDEFINED as the arguments.

VariableDeclaration : _BindingIdentifier Initialiser_

1.  Return the result of performing Binding Initialisation for
    BindingIdentifier passing value and UNDEFINED as the arguments.

VariableDeclaration : _BindingPattern Initialiser_

1.  Return the result of performing Binding Initialisation for
    BindingPattern passing value and UNDEFINED as the arguments.

RUNTIME SEMANTICS: EVALUATION

VariableStatement : VAR VariableDeclarationList ;

1.  Let next be the result of evaluating VariableDeclarationList.

2.  ReturnIfAbrupt(next).

3.  Return NormalCompletion( empty).

1.  

1.  

1.  2.  3.  

VariableDeclarationList : VariableDeclarationList ,
VariableDeclaration

1.  Let next be the result of evaluating VariableDeclarationList.

2.  ReturnIfAbrupt(next).

3.  Return the result of evaluating VariableDeclaration.

1.  

VariableDeclaration : BindingIdentifier

1.  Return NormalCompletion(empty).

VariableDeclaration : _BindingIdentifier Initialiser_

1.  Let rhs be the result of evaluating Initialiser.

2.  Let value be GetValue(rhs).

3.  ReturnIfAbrupt(value).

4.  Return the result of performing Binding Initialisation for
    BindingIdentifier passing value and UNDEFINED as the arguments.

NOTE If a VariableDeclaration is nested within a with statement and
the Identifier in the VariableDeclaration is the same as a property
name of the binding object of the with statement’s object environment
record, then step 3 will assign value to the property instead of to the
VariableEnvironment binding of the Identifier.

-   

1.  

VariableDeclaration : _BindingPattern Initialiser_

1.  Let rhs be the result of evaluating Initialiser.

2.  Let rval be GetValue(rhs).

3.  ReturnIfAbrupt(rval).

4.  If Type(rval) is not Object, then throw a TYPEERROR exception.

5.  Return the result of performing Binding Initialisation for
    BindingPattern passing rval and UNDEFINED as arguments.

Destructuring Binding Patterns

Syntax

BindingPattern :

ObjectBindingPattern
ArrayBindingPattern

ObjectBindingPattern :

{ }
{ BindingPropertyList }
{ BindingPropertyList , }

ArrayBindingPattern :

[ Elision~opt~ BindingRestElement~opt~ ]
[ BindingElementList ]
[ BindingElementList , Elision~opt~ BindingRestElement~opt~ ]

BindingPropertyList :

BindingProperty
BindingPropertyList , BindingProperty

BindingElementList :

Elision~opt~ BindingElement
BindingElementList , Elision~opt~ BindingElement

BindingProperty :

SingleNameBinding ~
~ PropertyName : BindingElement

BindingElement :

SingleNameBinding
BindingPattern Initialiser~opt~

SingleNameBinding :

BindingIdentifier Initialiser~opt~

BindingRestElement :

... BindingIdentifier

Static Semantics

STATIC SEMANTICS: EARLY ERRORS

BindingPattern : ObjectBindingPattern

-   It is a Syntax Error if the BoundNames of ObjectBindingPattern
    contains the string “EVAL” or the string “ARGUMENTS”.

BindingPattern : ArrayBindingPattern

-   It is a Syntax Error if the BoundNames of ArrayBindingPattern
    contains the string “EVAL” or the string “ARGUMENTS”.

STATIC SEMANTICS: BOUNDNAMES

1.  2.  

1.  

1.  2.  3.  4.  5.  

1.  

1.  

1.  

ObjectBindingPattern : { }

1.  Return an empty List.

1.  

ArrayBindingPattern : [ Elision~opt~ ]

1.  Return an empty List.

ArrayBindingPattern : [ Elision~opt~ BindingRestElement ]

1.  Return the BoundNames of BindingRestElement.

1.  

ArrayBindingPattern : [ BindingElementList , Elision~opt~ ]

1.  Return the BoundNames of BindingElementList.

ArrayBindingPattern : [ BindingElementList , Elision~opt~
BindingRestElement ]

1.  Let names be BoundNames of BindingElementList.

2.  Append to names the elements of BoundNames of
    BindingRestElement.

3.  Return names.

1.  

BindingPropertyList : BindingPropertyList , BindingProperty

1.  Let names be BoundNames of BindingPropertyList.

2.  Append to names the elements of BoundNames of BindingProperty.

3.  Return names.

BindingElementList : Elision~opt~ BindingElement

1.  Return BoundNames of BindingElement.

BindingElementList : BindingElementList , Elision~opt~
BindingElement

1.  Let names be BoundNames of BindingElementList.

2.  Append to names the elements of BoundNames of BindingElement.

3.  Return names.

1.  

BindingProperty : PropertyName : _BindingElement _

1.  Return the BoundNames of BindingElement.

SingleNameBinding : _BindingIdentifier Initialiser_~opt~

1.  Return the BoundNames of BindingIdentifier.

1.  

BindingElement : _BindingPattern Initialiser_~opt~

1.  Return the BoundNames of BindingPattern.

1.  

STATIC SEMANTICS: HASINITIALISER

1.  

BindingElement : _BindingPattern _

1.  Return FALSE.

BindingElement : _BindingPattern Initialiser_

1.  Return TRUE.

SingleNameBinding : _BindingIdentifier _

1.  Return FALSE.

SingleNameBinding : _BindingIdentifier Initialiser_

1.  Return TRUE.

Runtime Semantics

RUNTIME SEMANTICS: BINDING INITIALISATION

  With parameters value and environment.

NOTE When UNDEFINED is passed for environment it indicates that a
PutValue operation should be used to assign the initialisation value.
This is the case for formal parameter lists of non-strict functions. In
that case the formal parameter bindings are preinitialised in order to
deal with the possibility of multiple parameters with the same name.

BindingPattern : ObjectBindingPattern

1.  Assert: Type(value) is Object

    a.  

2.  3.  Return the result of performing Binding Initialisation for
    ObjectBindingPattern using value and environment as arguments.

1.  

BindingPattern : ArrayBindingPattern

1.  Assert: Type(value) is Object

    a.  b.  c.  

2.  a.  b.  

3.  Return the result of performing Indexed Binding Initialisation for
    ArrayBindingPattern using value, 0, and environment as
    arguments.

1.  

ObjectBindingPattern : { }

1.  Return NormalCompletion(empty).

1.  

1.  a.  

2.  3.  

1.  

1.  

1.  

1.  2.  a.  

3.  4.  

1.  

1.  a.  

2.  3.  4.  

1.  2.  3.  

1.  a.  

2.  3.  4.  5.  

1.  

1.  

1.  2.  3.  

BindingPropertyList : BindingPropertyList , BindingProperty

1.  Let status be the result of performing Binding Initialisation for
    BindingPropertyList using value and environment as arguments.

2.  ReturnIfAbrupt(status).

3.  Return the result of performing Binding Initialisation for
    BindingProperty using value and environment as arguments.

BindingProperty : SingleNameBinding

1.  Let name be the string that is the only element of BoundNames of
    SingleNameBinding.

2.  Return the result of performing Keyed Binding Initialisation for
    SingleNameBinding using value, environment, and name as the
    arguments.

BindingProperty : PropertyName : _BindingElement _

1.  Let P be the result of evaluating PropertyName

2.  ReturnIfAbrupt(P).

3.  Return the result of performing Keyed Binding Initialisation for
    BindingElement using value, environment, and P as arguments.

RUNTIME SEMANTICS: INDEXED BINDING INITIALISATION

  With parameters array, nextIndex, and environment.

NOTE When UNDEFINED is passed for environment it indicates that a
PutValue operation should be used to assign the initialisation value.
This is the case for formal parameter lists of non-strict functions. In
that case the formal parameter bindings are preinitialised in order to
deal with the possibility of multiple parameters with the same name.

ArrayBindingPattern : [ Elision~opt~ ]

1.  Return NormalCompletion(empty).

ArrayBindingPattern: [ Elision~opt~ BindingRestElement ]

1.  Let nextIndex be the Elision Width of Elision; if Elision is
    not present, use the numeric value zero.

2.  Return the result of performing Indexed Binding Initialisation for
    BindingRestElement using _array, nextIndex_, and environment as
    arguments.

ArrayBindingPattern: [ BindingElementList ]

1.  Return the result of performing Indexed Binding Initialisation for
    BindingElementList using array, nextIndex, and environment
    as arguments.

ArrayBindingPattern: [ BindingElementList , Elision~opt~]

1.  Return the result of performing Indexed Binding Initialisation for
    BindingElementList using array, nextIndex, and environment
    as arguments.

ArrayBindingPattern: [ BindingElementList , Elision~opt~
BindingRestElement ]

1.  Let next be the result of performing Indexed Binding
    Initialisation for BindingElementList using _array , nextIndex_,
    and environment as arguments.

2.  ReturnIfAbrupt(next).

3.  Let skip be the Elision Width of Elision; if Elision is not
    present, use the numeric value zero.

4.  Return the result of performing Indexed Binding Initialisation for
    BindingRestElement using array, next_+_skip , and
    environment as arguments.

1.  

BindingElementList : Elision~opt~ BindingElement

1.  Let skip be the Elision Width of Elision; if Elision is not
    present, use the numeric value zero.

2.  Let status be the result of performing Indexed Binding
    Initialisation for BindingElement using array,
    nextIndex_+_skip , and environment as arguments.

3.  ReturnIfAbrupt(status).

4.  Return nextIndex +skip+1.

1.  2.  3.  

BindingElementList : BindingElementList , Elision~opt~
_BindingElement _

1.  Let listNext be the result of performing Indexed Binding
    Initialisation for BindingElementList using _array, nextIndex_,
    and environment as arguments.

2.  ReturnIfAbrupt(listNext).

3.  Let skip be the Elision Width of Elision; if Elision is not
    present, use the numeric value zero.

4.  Let status be the result of performing Indexed Binding
    Initialisation for BindingElement using array, listNext_+_skip
    , and environment as arguments.

5.  ReturnIfAbrupt(status).

6.  Return listNext +skip+1.

7.  

1.  

1.  2.  3.  

1.  2.  

1.  

1.  2.  3.  a.  

4.  a.  i.  

    b.  i.  

5.  

1.  

1.  2.  a.  

3.  a.  i.  

    b.  i.  

4.  

1.  

BindingElement : SingleNameBinding

1.  a.  

2.  3.  Return the result of performing Keyed Binding Initialisation for
    SingleNameBinding using array, environment, and
    ToString(nextIndex) as the arguments.

1.  

BindingElement : _BindingPattern Initialiser_~opt~

1.  Let P be ToString(nextIndex).

2.  Let exists be the result of HasPropety(obj, P).

3.  ReturnIfAbrupt(exists).

4.  If exists is FALSE, then

    a.  If Initialiser~opt~ is not present, then throw a TYPEERROR
          exception.

    b.  Else, let v be UNDEFINED.

5.  Else,

    a.  b.  c.  d.  e.  f.  g.  h.  i.  Let v be the result of
          Get(array, P).

    j.  ReturnIfAbrupt(v).

6.  7.  If Initialiser~opt~ is present and v is UNDEFINED, then

    a.  Let defaultValue be the result of evaluating Initialiser.

    b.  Let v be GetValue(defaultValue).

    c.  d.  e.  f.  ReturnIfAbrupt(v).

1.  If Type(v) is not Object, then throw a TYPEERROR exception.

1.  Return the result of performing Binding Initialisation for
    BindingPattern passing v and environment as arguments.

BindingRestElement : ... BindingIdentifier

1.  Let A be the result of the abstract operation ArrayCreate with
    argument 0.

2.  Let lenVal be the result of Get(array, "LENGTH").

3.  Let arrayLength be ToLength(lenVal).

4.  ReturnIfAbrupt(arrayLength).

5.  Let n=0.

6.  Let index = nextIndex.

7.  Repeat, while index < arrayLength

    a.  Let P be ToString(index).

    b.  Let exists be the result of HasProperty(array, P).

    c.  ReturnIfAbrupt(exists).

    d.  If exists is TRUE, then

        i.  Let v be the result of Get(array, P).

        ii. ReturnIfAbrupt(v).

        iii. Call the [[DefineOwnProperty]] internal method of A with
              arguments ToString(n) and Property Descriptor
              {[[Value]]: v, [[Writable]]: TRUE, [[Enumerable]]: TRUE,
              [[Configurable]]: TRUE}.

    e.  Let n = n+1.

    f.  Let index = index+1.

8.  Return the result of performing Binding Initialisation for
    BindingIdentifier using A and environment as arguments.

RUNTIME SEMANTICS: KEYED BINDING INITIALISATION

  With parameters obj, environment, and propertyName.

NOTE When UNDEFINED is passed for environment it indicates that a
PutValue operation should be used to assign the initialisation value.
This is the case for formal parameter lists of non-strict functions. In
that case the formal parameter bindings are preinitialised in order to
deal with the possibility of multiple parameters with the same name.

1.  

BindingElement : BindingPattern Initialiser~opt~

1.  Let exists be the result of HasPropety(obj, propertyName).

2.  ReturnIfAbrupt(exists).

3.  If exists is FALSE, then

    a.  If Initialiser~opt~ is not present, then throw a TYPEERROR
        exception.

    b.  Else, let v be UNDEFINED.

4.  Else,

1.  2.  3.  a.  Let v be the result of Get(obj, propertyName).

    b.  ReturnIfAbrupt(v).

1.  2.  If Initialiser~opt~ is present and v is UNDEFINED, then

    a.  Let defaultValue be the result of evaluating Initialiser.

    b.  Let v be GetValue(defaultValue).

    c.  d.  e.  ReturnIfAbrupt(v).

3.  If Type(v) is not Object, then throw a TYPEERROR exception.

4.  Return the result of performing Binding Initialisation for
    BindingPattern passing v and environment as arguments.

SingleNameBinding : _BindingIdentifier Initialiser_~opt~

1.  Let exists be the result of HasPropety(obj, propertyName).

2.  ReturnIfAbrupt(exists).

3.  If exists is FALSE, then

    a.  If Initialiser~opt~ is not present, then throw a TYPEERROR
        exception.

    b.  Else, let v be UNDEFINED.

4.  Else,

    a.  b.  c.  d.  Let v be the result of Get(obj, propertyName).

    e.  ReturnIfAbrupt(v).

5.  6.  If Initialiser~opt~ is present and v is UNDEFINED, then

    a.  Let defaultValue be the result of evaluating Initialiser.

    b.  Let v be GetValue(defaultValue).

    c.  d.  e.  ReturnIfAbrupt(v).

7.  Return the result of performing Binding Initialisation for
    BindingIdentifier passing v and environment as arguments.


Empty Statement

Syntax

EmptyStatement :

;

Runtime Semantics

RUNTIME SEMANTICS: EVALUATION

EmptyStatement : ;

1.  Return NormalCompletion(empty).


Expression Statement

Syntax

ExpressionStatement :

[lookahead ∉ {{, FUNCTION, CLASS }] Expression ;

NOTE An ExpressionStatement cannot start with an opening curly brace
because that might make it ambiguous with a Block. Also, an
ExpressionStatement cannot start with the FUNCTION or CLASS keywords
because that would make it ambiguous with a FunctionDeclaration, a
GeneratorDeclaration, or a ClassDeclaration.

Runtime Semantics

RUNTIME SEMANTICS: EVALUATION

ExpressionStatement : [lookahead ∉ {{, FUNCTION, CLASS }]
Expression;


The if Statement

Syntax

IfStatement :

IF ( Expression ) Statement ELSE Statement
IF ( Expression ) Statement

Each ELSE for which the choice of associated IF is ambiguous shall be
associated with the nearest possible IF that would otherwise have no
corresponding ELSE.

STATIC SEMANTICS: VARDECLAREDNAMES

IfStatement : IF ( Expression ) Statement ELSE Statement

1.  Let names be VarDeclaredNames of the first Statement.

2.  Append to names the elements of the VarDeclaredNames of the second
    Statement.

3.  Return names.

IfStatement : IF ( Expression ) _Statement _

1.  Return the VarDeclaredNames of Statement.

Runtime Semantics

RUNTIME SEMANTICS: EVALUATION

IfStatement : IF ( Expression ) Statement ELSE Statement

1.  

IfStatement : IF ( Expression ) Statement


Iteration Statements

Syntax

IterationStatement :

DO Statement WHILE ( Expression ) ; ~opt~
WHILE ( Expression ) Statement
FOR (Expression~opt~; Expression~opt~ ; Expression~opt~ ) Statement
FOR ( VAR VariableDeclarationList; Expression~opt~ ; Expression~opt~ )
Statement
FOR ( LexicalDeclaration; Expression~opt~ ; Expression~opt~ ) Statement
FOR ( LeftHandSideExpression IN Expression ) Statement
FOR ( VAR ForBinding IN Expression ) Statement
FOR ( ForDeclaration IN Expression ) Statement
FOR ( LeftHandSideExpression OF AssignmentExpression ) Statement
FOR ( VAR ForBinding OF AssignmentExpression ) Statement
FOR ( ForDeclaration OF AssignmentExpression ) Statement

ForDeclaration :

LetOrConst ForBinding

NOTE 1 ForBinding is defined in 11.1.4.2.

NOTE 2 A semicolon is not required after a DO-WHILE statement.

RUNTIME SEMANTICS

RUNTIME SEMANTICS: LOOPCONTINUES ABSTRACT OPERATION

The abstract operation LoopContinues with arguments completion and
labelSet is defined by the following step:

NOTE Within the Statement part of an IterationStatement a
ContinueStatement may be used to begin a new iteration.

The do-while Statement

STATIC SEMANTICS: VARDECLAREDNAMES

IterationStatement : DO Statement WHILE ( Expression ); ~opt~

1.  Return the VarDeclaredNames of Statement.

Runtime Semantics

RUNTIME SEMANTICS: LABELLED EVALUATION

  With argument labelSet.

IterationStatement : DO Statement WHILE ( Expression ); ~opt~

1.  Let V = UNDEFINED.

2.  3.  Repeat

    a.  Let stmt be the result of evaluating Statement.

    b.  If stmt.[[value]] is not empty, let V = stmt_.[[value]]_.

    c.  i.  

    d.  If stmt is an abrupt completion and LoopContinues
        (stmt_,_labelSet) is FALSE, return stmt.

    e.  Let exprRef be the result of evaluating Expression.

    f.  Let exprValue be ToBoolean(GetValue(exprRef)).

    g.  If exprValue is FALSE, Return NormalCompletion(V).

    h.  Else if exprValue is not TRUE, then

        i.  Assert: exprValue is an abrupt completion.

        ii. If LoopContinues (exprValue_,_labelSet) is FALSE, return
              exprValue.

The while Statement

STATIC SEMANTICS: VARDECLAREDNAMES

IterationStatement : WHILE ( Expression ) Statement

1.  Return the VarDeclaredNames of Statement.

Runtime Semantics

RUNTIME SEMANTICS: LABELLED EVALUATION

  With argument labelSet.

IterationStatement : WHILE ( Expression ) Statement

The for Statement

Static Semantics

STATIC SEMANTICS: VARDECLAREDNAMES

IterationStatement : FOR (Expression~opt~ ; Expression~opt~ ;
Expression~opt~) Statement

1.  Return the VarDeclaredNames of Statement.

IterationStatement : FOR ( VAR VariableDeclarationList ;
Expression~opt~ ; Expression~opt~ ) Statement

1.  Let names be BoundNames of VariableDeclarationList.

2.  Append to names the elements of the VarDeclaredNames of
    Statement.

3.  Return names.

IterationStatement : FOR (LexicalDeclaration; Expression~opt~ ;
Expression~opt~) Statement

1.  Return the VarDeclaredNames of Statement.

Runtime Semantics

RUNTIME SEMANTICS: LABELLED EVALUATION

  With argument labelSet.

IterationStatement : FOR (Expression~opt~ ; Expression~opt~ ;
Expression~opt~) Statement

1.  2.  a.  i.  ii. iii. iv. 

    b.  c.  d.  e.  f.  g.  i.  ii. iii. 

IterationStatement : FOR ( VAR VariableDeclarationList ;
Expression~opt~ ; Expression~opt~ ) Statement

IterationStatement : FOR ( LexicalDeclaration ; Expression~opt~ ;
Expression~opt~ ) Statement

1.  Let oldEnv be the running execution context’s LexicalEnvironment.

2.  Let loopEnv be the result of calling NewDeclarativeEnvironment
    passing oldEnv as the argument.

3.  Let isConst be the result of performing IsConstantDeclaration of
    LexicalDeclaration.

4.  For each element dn of the BoundNames of LexicalDeclaration do

    a.  If isConst is TRUE, then

        i.  Call loopEnv’s CreateImmutableBinding concrete method
            passing dn as the argument.

    b.  Else,

        i.  Call loopEnv’s CreateMutableBinding concrete method
            passing dn and FALSE as the arguments.

        ii. Assert: The above call to CreateMutableBinding will never an
            return an abrupt completion.

5.  Set the running execution context’s LexicalEnvironment to loopEnv.

6.  Let forDcl be the result of evaluating LexicalDeclaration.

7.  If LoopContinues(forDcl_,_labelSet) is FALSE, then

    a.  Set the running execution context’s LexicalEnvironment to
        oldEnv.

    b.  Return forDcl.

8.  Let bodyResult be the result of performing For Body Evaluation
    with the first Expression as the testExpr argument, the second
    Expression as the incrementExpr argument, Statement as the
    stmt argument, and with labelSet.

9.  Set the running execution context’s LexicalEnvironment to oldEnv.

10. Return bodyResult.

RUNTIME SEMANTICS: FOR BODY EVALUATION ABSTRACT OPERATION

The abstract operation For Body Evaluation with arguments testExpr,
incrementExpr, stmt, and labelSet is performed as follows:

1.  Let V = UNDEFINED.

2.  Repeat

    a.  If testExpr is not [empty], then

        i.  Let testExprRef be the result of evaluating testExpr.

        ii. Let testExprValue be ToBoolean(GetValue(testExprRef))

        iii. If testExprValue is FALSE, return NormalCompletion(V).

        iv. Else if LoopContinues (testExprValue_,_labelSet) is FALSE,
            return testExprValue.

    b.  Let result be the result of evaluating stmt.

    c.  If result.[[value]] is not empty, let V =
        result.[[value]].

    d.  If LoopContinues (result_,_labelSet) is FALSE, return
        result.

    e.  If incrementExpr is not [empty], then

        i.  Let incExprRef be the result of evaluating
            incrementExpr.

        ii. Let incExprValue be GetValue(incExprRef).

        iii. If LoopContinues(incExprValue_,_labelSet) is FALSE,
            return incExprValue.

The for-in and for-of Statements

Static Semantics

STATIC SEMANTICS: EARLY ERRORS

IterationStatement :

  FOR (LeftHandSideExpression IN Expression ) Statement

  FOR (LeftHandSideExpression OF AssignmentExpression ) Statement

-   It is a Syntax Error if LeftHandSideExpression is either an
    ObjectLiteral or an ArrayLiteral and if the lexical token
    sequence matched by LeftHandSideExpression cannot be parsed with
    no tokens left over using AssignmentPattern as the goal symbol.

-   If LeftHandSideExpression is either an ObjectLiteral or an
    ArrayLiteral and if the lexical token sequence matched by
    LeftHandSideExpression can be parsed with no tokens left over
    using AssignmentPattern as the goal symbol then the following
    rules are not applied. Instead, the Early Error rules for
    AssignmentPattern are used.

-   It is a Syntax Error if LeftHandSideExpression is an Identifier
    that can be statically determined to always resolve to a declarative
    environment record binding and the resolved binding is an immutable
    binding.

-   It is a Syntax Error if LeftHandSideExpression is neither an
    ObjectLiteral nor an ArrayLiteral and
    IsValidSimpleAssignmentTarget of LeftHandSideExpression is FALSE.

-   -   -   It is a Syntax Error if the LeftHandSideExpression is
    CoverParenthesisedExpressionAndArrowParameterList : ( Expression
    )
    and Expression derives a production that would produce a Syntax
    Error according to these rules if that production is substituted for
    LeftHandSideExpression. This rule is recursively applied.

  NOTE The last rule means that the other rules are applied even if
  multiple levels of nested parenthesises surround Expression.

-   -   

IterationStatement :

  FOR (ForDeclaration IN Expression ) Statement

  FOR (ForDeclaration OF AssignmentExpression ) Statement

-   It is a Syntax Error if any element of the BoundNames of
    ForDeclaration also occurs in the VarDeclaredNames of Statement.

STATIC SEMANTICS: BOUNDNAMES

1.  

1.  

ForDeclaration : _LetOrConst ForBinding _

1.  Return the BoundNames of ForBinding.

1.  

1.  

STATIC SEMANTICS: VARDECLAREDNAMES

IterationStatement : FOR ( LeftHandSideExpression IN Expression )
Statement

1.  Return the VarDeclaredNames of Statement.

IterationStatement : FOR ( VAR ForBinding IN Expression )
Statement

1.  Let names be the BoundNames of ForBinding.

2.  Append to names the elements of the VarDeclaredNames of
    Statement.

3.  Return names

IterationStatement : FOR ( ForDeclaration IN Expression )
Statement

1.  Return the VarDeclaredNames of Statement.

IterationStatement : FOR ( LeftHandSideExpression OF
AssignmentExpression ) Statement

1.  Return the VarDeclaredNames of Statement.

IterationStatement : FOR ( VAR ForBinding OF AssignmentExpression
) Statement

1.  Let names be the BoundNames of ForBinding.

2.  Append to names the elements of the VarDeclaredNames of
    Statement.

3.  Return names

IterationStatement : FOR ( ForDeclaration OF AssignmentExpression
) Statement

1.  Return the VarDeclaredNames of Statement.

Runtime Semantics

RUNTIME SEMANTICS: BINDING INSTANTIATION

  With arguments value and environment.

ForDeclaration : _LetOrConst ForBinding _

1.  For each element name of the BoundNames of ForBinding do

    a.  If IsConstantDeclaration of LetOrConst is FALSE, then

        i.  Call environment’s CreateMutableBinding concrete method
            with argument name.

        ii. Assert: The above call to CreateMutableBinding will never an
            return an abrupt completion.

    b.  Else,

        i.  Call environment’s CreateImmutableBinding concrete method
            with argument name.

2.  Return the result of performing Binding Initialisation for
    ForBinding passing value and environment as the arguments.

1.  

1.  

1.  

1.  

RUNTIME SEMANTICS: LABELLED EVALUATION

  With argument labelSet.

IterationStatement : FOR ( LeftHandSideExpression IN Expression )
Statement

1.  Let keyResult be the result of performing For In/Of Expression
    Evaluation with Expression, enumerate, and labelSet.

2.  ReturnIfAbrupt(keyResult).

3.  Return the result of performing For In/Of Body Evaluation with
    LeftHandSideExpression, Statement, keyResult, assignment, and
    labelSet.

IterationStatement : FOR ( VAR ForBinding IN Expression )
Statement

IterationStatement : FOR (ForDeclaration IN Expression )
Statement

1.  Let keyResult be the result of performing For In/Of Expression
    Evaluation with Expression, enumerate, and labelSet.

2.  ReturnIfAbrupt(keyResult).

3.  Return the result of performing For In/Of Body Evaluation with
    ForDeclaration, Statement, keyResult, lexicalBinding, and
    labelSet.

IterationStatement : FOR ( LeftHandSideExpression OF
AssignmentExpression ) Statement

1.  Let keyResult be the result of performing For In/Of Expression
    Evaluation with AssignmentExpression, iterate, and labelSet.

2.  ReturnIfAbrupt(keyResult).

3.  Return the result of performing For In/Of Body Evaluation with
    LeftHandSideExpression, Statement, keyResult, assignment, and
    labelSet.

IterationStatement : FOR ( VAR ForBinding OF AssignmentExpression
) Statement

1.  Let keyResult be the result of performing For In/Of Expression
    Evaluation with AssignmentExpression, iterate, and labelSet.

2.  ReturnIfAbrupt(keyResult).

3.  Return the result of performing For In/Of Body Evaluation with
    ForBinding, Statement, keyResult, varBinding, and labelSet.

IterationStatement : FOR (ForDeclaration OF AssignmentExpression )
Statement

1.  Let keyResult be the result of performing For In/Of Expression
    Evaluation with AssignmentExpression, iterate, and labelSet.

2.  ReturnIfAbrupt(keyResult).

3.  Return the result of performing For In/Of Body Evaluation with
    ForDeclaration, Statement, keyResult, lexicalBinding, and
    labelSet.

RUNTIME SEMANTICS: FOR IN/OF EXPRESSION EVALUATION ABSTRACT OPERATION

The abstract operation For In/Of Expression Evaluation is called with
arguments expr, iterationKind, and labelSet. The value of
iterationKind is either ENUMERATE or ITERATE.

1.  Let exprRef be the result of evaluating the production that is
    expr.

2.  Let exprValue be GetValue(exprRef).

3.  If exprValue is an abrupt completion,

    a.  If LoopContinues(exprValue_,_labelSet) is FALSE, then return
        exprValue.

    b.  Else, return Completion {[[type]]: break, [[value]]: empty,
        [[target]]: empty}.

4.  If exprValue.[[value]] is NULL or UNDEFINED, return Completion
    {[[type]]: break, [[value]]: empty, [[target]]: empty}.

5.  Let obj be ToObject(exprValue).

6.  If iterationKind is enumerate, then

    a.  Let keys be the result of calling the [[Enumerate]] internal
        method of obj with no arguments.

7.  Else,

    a.  Assert iterationKind is iterate.

    b.  Let iterator be the result of performing Invoke with arguments
        obj, @@iterator and an empty List.

    c.  Let keys be ToObject(iterator).

    d.  

8.  If keys is an abrupt completion, then

    a.  If LoopContinues(exprValue_,_labelSet) is FALSE, then return
        exprValue.

    b.  Assert: keys.[[type]] is continue

    c.  Return Completion {[[type]]: break, [[value]]: empty,
        [[target]]: empty}.

9.  Return keys.

RUNTIME SEMANTICS: FOR IN/OF BODY EVALUATION ABSTRACT OPERATION

The abstract operation For In/Of Body Evaluation is called with
arguments lhs, stmt, keys, lhsKind, and labelSet. The value of
lhsKind is either ASSIGNMENT, VARBINDING or LEXICALBINDING.

1.  Let oldEnv be the running execution context’s LexicalEnvironment.

2.  3.  Let V = UNDEFINED .

4.  Repeat

    a.  Let nextResult be the result of IteratorNext(keys).

    b.  ReturnIfAbrupt(nextResult).

    c.  d.  Let done be IteratorComplete(nextResult).

    e.  ReturnIfAbrupt(done).

    f.  If done is TRUE, then return NormalCompletion(V).

    g.  Let nextValue be the result of IteratorValue(nextResult).

    h.  ReturnIfAbrupt(nextValue).

    i.  j.  k.  l.  m.  n.  If lhsKind is assignment, then

        i.  Assert: lhs is a LeftHandSideExpression.

        ii. If lhs is neither an ObjectLiteral nor an ArrayLiteral
            then

            1.  2.  Let lhsRef be the result of evaluating lhs ( it
                may be evaluated repeatedly).

            3.  Let status be the result of performing
                PutValue(lhsRef, nextValue).

        iii. Else

            1.  Let AssignmentPattern be the parse of the source code
                corresponding to lhs using AssignmentPattern as the
                goal symbol.

            2.  Let rval be ToObject(nextValue).

            3.  If rval is an abrupt completion, then let status be
                rval.

            4.  Else, let status be the result of performing
                Destructuring Assignment Evaluation of
                AssignmentPattern using rval as the argument.

    o.  Else if lhsKind is varBinding, then

        i.  Assert: lhs is a ForBinding.

        ii. Let status be the result of performing Binding
            Initialisation for lhs passing nextValue and UNDEFINED
            as the arguments.

    p.  Else,

        i.  Assert lhsKind is lexicalBinding.

        ii. Assert: lhs is a ForDeclaration.

        iii. Let iterationEnv be the result of calling
            NewDeclarativeEnvironment passing oldEnv as the argument.

        iv. Perform Binding Instantiation for lhs passing nextValue
            and iterationEnv as arguments.

        v.  Let status be NormalCompletion(empty)

        vi. Set the running execution context’s LexicalEnvironment to
            iterationEnv.

    q.  If status.[[type]] is normal, then

        i.  Let status be the result of evaluating stmt.

        ii. If status.[[type]] is normal and status.[[value]] is not
            empty, then

            1.  Let V = status.[[value]].

    r.  Set the running execution context’s LexicalEnvironment to
        oldEnv.

    s.  If status is an abrupt completion and
        LoopContinues(status_,_labelSet) is FALSE, then return
        status.

        1.  2.  a.  


The continue Statement

Syntax

ContinueStatement :

CONTINUE ;
CONTINUE [no LineTerminator here] Identifier;

Static Semantics

STATIC SEMANTICS: EARLY ERRORS

ContinueStatement : CONTINUE ;

-   It is a Syntax Error if this production is not nested, directly or
      indirectly (but not crossing function boundaries), within an
      IterationStatement.

ContinueStatement : CONTINUE [no LineTerminator here] Identifier;

-   It is a Syntax Error if Identifier does not appear in the
      CurrentLabelSet of an enclosing (but not crossing function
      boundaries) IterationStatement.

Runtime Semantics

RUNTIME SEMANTICS: EVALUATION

ContinueStatement : CONTINUE ;

ContinueStatement : CONTINUE [no LineTerminator here] Identifier;

1.  Return Completion {[[type]]: continue, [[value]]: empty, [[target]]:
    Identifier}.


The break Statement

Syntax

BreakStatement :

BREAK ;
BREAK [no LineTerminator here] Identifier ;

Static Semantics

STATIC SEMANTICS: EARLY ERRORS

BreakStatement : BREAK ;

-   It is a Syntax Error if this production is not nested, directly or
      indirectly (but not crossing function boundaries), within an
      IterationStatement or a SwitchStatement.

BreakStatement : BREAK [no LineTerminator here] Identifier;

-   It is a Syntax Error if Identifier does not appear in the
      CurrentLabelSet of an enclosing (but not crossing function
      boundaries) Statement.

Runtime Semantics

RUNTIME SEMANTICS: EVALUATION

BreakStatement : BREAK ;

BreakStatement : BREAK [no LineTerminator here] Identifier;


The return Statement

Syntax

ReturnStatement :

RETURN ;
RETURN [no LineTerminator here] Expression ;

NOTE A RETURN statement causes a function to cease execution and return
a value to the caller. If Expression is omitted, the return value is
UNDEFINED. Otherwise, the return value is the value of Expression.

Static Semantics

STATIC SEMANTICS: EARLY ERRORS

-   -   It is a Syntax Error if a RETURN statement is not within a
    FunctionBody or a GeneratorBody.

Runtime Semantics

RUNTIME SEMANTICS: EVALUATION

ReturnStatement : RETURN ;

ReturnStatement : RETURN [no LineTerminator here] Expression;

1.  Let exprRef be the result of evaluating Expression.

2.  Let exprValue be GetValue(exprRef).

3.  ReturnIfAbrupt(exprValue).

4.  Return Completion {[[type]]: return, [[value]]: exprValue,
    [[target]]: empty}.


The with Statement

Syntax

WithStatement :

WITH ( Expression ) Statement

NOTE The WITH statement adds an object environment record for a computed
object to the lexical environment of the running execution context. It
then executes a statement using this augmented lexical environment.
Finally, it restores the original lexical environment.

Static Semantics

STATIC SEMANTICS: EARLY ERRORS

WithStatement : WITH ( Expression ) Statement

-   It is a Syntax Error if the code that matches this production is
    contained in strict code.

STATIC SEMANTICS: VARDECLAREDNAMES

WithStatement : WITH ( Expression ) Statement

1.  Return the VarDeclaredNames of Statement.

Runtime Semantics

RUNTIME SEMANTICS: EVALUATION

WithStatement : WITH ( Expression ) Statement

NOTE No matter how control leaves the embedded Statement, whether
normally or by some form of abrupt completion or exception, the
LexicalEnvironment is always restored to its former state.


The switch Statement

Syntax

SwitchStatement :

SWITCH ( Expression ) CaseBlock

CaseBlock :

{ CaseClauses~opt~ }
{ CaseClauses~opt~ DefaultClause CaseClauses~opt~ }

CaseClauses :

CaseClause
CaseClauses CaseClause

CaseClause :

CASE Expression : StatementList~opt~

DefaultClause :

DEFAULT : StatementList~opt~

Static Semantics

STATIC SEMANTICS: EARLY ERRORS

CaseBlock : { CaseClauses }

-   It is a Syntax Error if the LexicallyDeclaredNames of CaseClauses
    contains any duplicate entries.

-   It is a Syntax Error if any element of the LexicallyDeclaredNames of
    CaseClauses also occurs in the VarDeclaredNames of CaseClauses.

-   

STATIC SEMANTICS: LEXICALDECLARATIONS

CaseBlock : { }

1.  Return a new empty List.

1.  

CaseBlock : { CaseClauses~opt~ _DefaultClause CaseClauses_~opt~ }

1.  If the first CaseClauses is present, let declarations be the
    LexicalDeclarations of the first CaseClauses.

2.  Else let declarations be a new empty List.

3.  Append to declarations the elements of the LexicalDeclarations of
    the DefaultClause.

4.  If the second CaseClauses is not present, return declarations.

5.  Else return the result of appending to declarations the elements
    of the LexicalDeclarations of the second CaseClauses.

1.  

CaseClauses : _CaseClauses CaseClause_

1.  Let declarations be LexicalDeclarations of CaseClauses.

2.  Append to declarations the elements of the LexicalDeclarations of
    CaseClause.

3.  Return declarations.

CaseClause : CASE Expression : StatementList~opt~

1.  If the StatementList is present, return the LexicalDeclarations of
    StatementList.

2.  Else return a new empty List.

DefaultClause : DEFAULT : StatementList~opt~

1.  If the StatementList is present, return the LexicalDeclarations of
    StatementList.

2.  Else return a new empty List.

STATIC SEMANTICS: LEXICALLYDECLAREDNAMES

CaseBlock : { }

1.  Return a new empty List.

1.  

CaseBlock : { CaseClauses~opt~ _DefaultClause CaseClauses_~opt~ }

1.  If the first CaseClauses is present, let names be the
    LexicallyDeclaredNames of the first CaseClauses.

2.  Else let names be a new empty List.

3.  Append to names the elements of the LexicallyDeclaredNames of the
    DefaultClause.

4.  If the second CaseClauses is not present, return names.

5.  Else return the result of appending to names the elements of the
    LexicallyDeclaredNames of the second CaseClauses.

1.  

CaseClauses : _CaseClauses CaseClause_

1.  Let names be LexicallyDeclaredNames of CaseClauses.

2.  Append to names the elements of the LexicallyDeclaredNames of
    CaseClause.

3.  Return names.

CaseClause : CASE Expression : StatementList~opt~

1.  If the StatementList is present, return the LexicallyDeclaredNames
    of StatementList.

2.  Else return a new empty List.

DefaultClause : DEFAULT : StatementList~opt~

1.  If the StatementList is present, return the LexicallyDeclaredNames
    of StatementList.

2.  Else return a new empty List.

STATIC SEMANTICS: VARDECLAREDNAMES

SwitchStatement : SWITCH ( Expression ) CaseBlock

1.  Return the VarDeclaredNames of CaseBlock.

CaseBlock : { }

1.  Return a new empty List.

1.  

CaseBlock : { CaseClauses~opt~ _DefaultClause CaseClauses_~opt~ }

1.  If the first CaseClauses is present, let names be the
    VarDeclaredNames of the first CaseClauses.

2.  Else let names be a new empty List.

3.  Append to names the elements of the VarDeclaredNames of the
    DefaultClause.

4.  If the second CaseClauses is not present, return names.

5.  Else return the result of appending to names the elements of the
    VarDeclaredNames of the second CaseClauses.

1.  

CaseClauses : _CaseClauses CaseClause_

1.  Let names be VarDeclaredNames of CaseClauses.

2.  Append to names the elements of the VarDeclaredNames of
    CaseClause.

3.  Return names.

CaseClause : CASE Expression : StatementList~opt~

1.  If the StatementList is present, return the VarDeclaredNames of
    StatementList.

2.  Else return a new empty List.

DefaultClause : DEFAULT : StatementList~opt~

1.  If the StatementList is present, return the VarDeclaredNames of
    StatementList.

2.  Else return a new empty List.

Runtime Semantics

RUNTIME SEMANTICS: CASE BLOCK EVALUATION

1.  2.  3.  4.  5.  6.  7.  8.  

  With argument input.

CaseBlock : { CaseClauses~opt~ }

1.  Let V = UNDEFINED.

2.  Let A be the list of CaseClause items in source text order.

3.  Let searching be TRUE.

4.  Repeat, while searching is TRUE

    a.  Let C be the next CaseClause in A. If there is no such
        CaseClause, return NormalCompletion(V).

    b.  Let clauseSelector be the result of Case Selector Evaluation
        of C.

    c.  ReturnIfAbrupt(clauseSelector).

    d.  Let matched be the result of performing Strict Equality
        Comparison input === clauseSelector.

    e.  If matched is TRUE, then

        i.  Set searching to FALSE.

        ii. If C has a StatementList, then

            1.  Evaluate C’s StatementList and let V be the
                result.

            2.  ReturnIfAbrupt(V).

            3.  

5.  Repeat

    a.  Let C be the next CaseClause in A. If there is no such
        CaseClause, return NormalCompletion(V).

    b.  If C has a StatementList, then

        i.  Evaluate C’s StatementList and let R be the result.

        ii. If R.[[value]] is not empty, then let V = R.[[value]].

        iii. If R is an abrupt completion, then return Completion
            {[[type]]: R.[[type]], [[value]]: V, [[target]]:
            R.[[target]]}.

CaseBlock : { CaseClauses~opt~ _DefaultClause CaseClauses_~opt~ }

1.  Let V = UNDEFINED.

2.  Let A be the list of CaseClause items in the first
    CaseClauses, in source text order.

3.  4.  Let found be FALSE.

5.  Repeat letting C be in order each CaseClause in A

    a.  If found is FALSE, then

        i.  Let clauseSelector be the result of Case Selector
            Evaluation of C.

        ii. If clauseSelector is an abrupt completion, then

            1.  If clauseSelector.[[value]] is empty, then return
                Completion {[[type]]: clauseSelector.[[type]],
                [[value]]: UNDEFINED, [[target]]:
                clauseSelector.[[target]]}.

            2.  Else, return clauseSelector.

        iii. Let found be the result of performing Strict Equality
            Comparison input === clauseSelector.

        iv. 

    b.  If found is TRUE, then

        i.  ii. Evaluate CaseClause C and let R be the result.

        iii. If R.[[value]] is not empty, then let V =
            R.[[value]].

        iv. If R is an abrupt completion, then return Completion
            {[[type]]: R.[[type]], [[value]]: V, [[target]]:
            R.[[target]]}.

6.  Let foundInB be FALSE.

7.  If found is FALSE, then

    a.  Let B be a new List containing the CaseClause items in the
        second CaseClauses, in source text order.

    b.  Repeat, letting C be in order each CaseClause in B

        i.  If foundInB is FALSE, then

            1.  2.  Let clauseSelector be the result of Case Selector
                Evaluation of C.

            3.  If clauseSelector is an abrupt completion, then

                a.  If clauseSelector.[[value]] is empty, then return
                    Completion {[[type]]: clauseSelector.[[type]],
                    [[value]]: UNDEFINED, [[target]]:
                    clauseSelector.[[target]]}.

                b.  Else, return clauseSelector.

            2.  Let foundInB be the result of performing Strict
                Equality Comparison input === clauseSelector.

            3.  4.  

        i.  If foundInB is TRUE, then

6.  If foundInB is TRUE, then return NormalCompletion(V).

7.  8.  Evaluate DefaultClause and let R be the result.

9.  If R.[[value]] is not empty, then let V = R.[[value]].

10. If R is an abrupt completion, then return Completion {[[type]]:
    R.[[type]], [[value]]: V, [[target]]: R.[[target]]}.

11. Let B be a new List containing the CaseClause items in the
    second CaseClauses, in source text order.

12. Repeat, letting C be in order each CaseClause in B (NOTE this
    is another complete iteration of the second CaseClauses)

13. a.  b.  Evaluate CaseClause C and let R be the resul

    c.  d.  If R.[[value]] is not empty, then let V = R.[[value]].

    e.  If R is an abrupt completion, then return Completion
        {[[type]]: R.[[type]], [[value]]: V, [[target]]:
        R.[[target]]}.

14. Return NormalCompletion(V).

RUNTIME SEMANTICS: CASE SELECTOR EVALUATION

CaseClause : CASE Expression : StatementList~opt~

NOTE Case Selector Evaluation does not execute the associated
StatementList. It simply evaluates the Expression and returns the
value, which the CaseBlock algorithm uses to determine which
StatementList to start executing.

RUNTIME SEMANTICS: EVALUATION

SwitchStatement : SWITCH ( Expression ) CaseBlock

1.  Let exprRef be the result of evaluating Expression.

2.  Let switchValue be GetValue(exprRef).

3.  ReturnIfAbrupt(switchValue).

4.  Let oldEnv be the running execution context’s LexicalEnvironment.

5.  Let blockEnv be the result of calling NewDeclarativeEnvironment
    passing oldEnv as the argument.

6.  Perform Block Declaration Instantiation using CaseBlock and
    blockEnv.

7.  Let R be the result of performing Case Block Evaluation of
    CaseBlock with argument switchValue.

8.  Set the running execution context’s LexicalEnvironment to oldEnv.

9.  10. Return R.

NOTE No matter how control leaves the SwitchStatement the
LexicalEnvironment is always restored to its former state.

CaseClause : CASE Expression :

1.  Return NormalCompletion(empty).

CaseClause : CASE Expression : StatementList

1.  Return the result of evaluating StatementList.

DefaultClause : DEFAULT:

1.  Return NormalCompletion(empty).

DefaultClause : DEFAULT: StatementList

1.  Return the result of evaluating StatementList.


Labelled Statements

Syntax

LabelledStatement :

Identifier : Statement

NOTE A Statement may be prefixed by a label. Labelled statements are
only used in conjunction with labelled BREAK and CONTINUE statements.
ECMAScript has no GOTO statement. A Statement can be part of a
LabelledStatement, which itself can be part of a LabelledStatement,
and so on. The labels introduced this way are collectively referred to
as the “current label set” when describing the semantics of individual
statements. A LabelledStatement has no semantic meaning other than the
introduction of a label to a _label set_. The label set of an
IterationStatement or a SwitchStatement initially contains the
single element EMPTY. The label set of any other statement is initially
empty.

Static Semantics

STATIC SEMANTICS: EARLY ERRORS

-   It is a Syntax Error if a LabelledStatement is enclosed by a
    LabelledStatement with the same Identifier as the enclosed
    LabelledStatement. This does not apply to a LabelledStatement
    appearing within the body of a FunctionDeclaration and a
    LabelledStatement that encloses, directly or indirectly the
    FunctionDeclaration .

STATIC SEMANTICS: VARDECLAREDNAMES

LabelledStatement : Identifier : Statement

1.  Return the VarDeclaredNames of Statement.

Runtime Semantics

RUNTIME SEMANTICS: LABELLED EVALUATION

  With argument labelSet.

LabelledStatement : Identifier : Statement

1.  Let label be the StringValue of Identifier.

2.  Let newLabelSet be a new List containing label and the elements
    of labelSet.

3.  If Statement is either LabelledStatement or
    BreakableStatement, then

    a.  Let stmtResult be the result of performing Labelled Evaluation
        of Statement with argument newLabelSet.

4.  Else,

    a.  Let stmtResult be the result of evaluating Statement.

5.  If stmtResult.[[type]] is BREAK and stmtResult.[[target]] is the
    same value as label, then

    a.  Let result be NormalCompletion(stmtResult.[[value]]).

6.  Else,

    a.  Let result be stmtResult.

7.  Return result.

RUNTIME SEMANTICS: EVALUATION

LabelledStatement : Identifier : Statement

1.  Let newLabelSet be a new empty List.

2.  Return the result of performing Labelled Evaluation of this
    LabelledStatement with argument newLabelSet.


The throw Statement

Syntax

ThrowStatement :

THROW [no LineTerminator here] Expression ;

RUNTIME SEMANTICS: EVALUATION

The production ThrowStatement : THROW [no LineTerminator here]
Expression ; is evaluated as follows:


The try Statement

Syntax

TryStatement :

TRY Block Catch~
~TRY Block Finally~
~TRY Block Catch Finally

Catch :

CATCH ( CatchParameter ) Block

Finally :

FINALLY Block

CatchParameter :

BindingIdentifier~
~BindingPattern

NOTE The TRY statement encloses a block of code in which an exceptional
condition can occur, such as a runtime error or a THROW statement. The
CATCH clause provides the exception-handling code. When a catch clause
catches an exception, its CatchParameter is bound to that exception.

Static Semantics

STATIC SEMANTICS: EARLY ERRORS

Catch : CATCH ( CatchParameter ) Block

-   It is a Syntax Error if any element of the BoundNames of
    CatchParameter also occurs in the LexicallyDeclaredNames of
    Block.

-   It is a Syntax Error if any element of the BoundNames of
    CatchParameter also occurs in the VarDeclaredNames of Block.

1.  

1.  

STATIC SEMANTICS: VARDECLAREDNAMES

TryStatement : TRY Block Catch

1.  Let names be VarDeclaredNames of Block.

2.  Append to names the elements of the VarDeclaredNames of Catch.

3.  Return names.

TryStatement : TRY Block Finally

1.  Let names be VarDeclaredNames of Block.

2.  Append to names the elements of the VarDeclaredNames of Finally.

3.  Return names.

TryStatement : TRY Block Catch Finally

1.  Let names be VarDeclaredNames of Block.

2.  Append to names the elements of the VarDeclaredNames of Catch.

3.  Append to names the elements of the VarDeclaredNames of Finally.

4.  Return names.

Catch : CATCH ( CatchParameter ) Block

1.  Return the VarDeclaredNames of Block.

Runtime Semantics

RUNTIME SEMANTICS: BINDING INITIALISATION

  With arguments value and environment.

NOTE UNDEFINED is passed for environment to indicate that a PutValue
operation should be used to assign the initialisation value. This is the
case for VAR statements formal parameter lists of non-strict functions.
In those cases a lexical binding is hosted and preinitialised prior to
evaluation of its initialiser.

1.  

CatchParameter: BindingPattern

1.  Let exceptionObj be ToObject(value).

2.  ReturnIfAbrupt(exceptionObj).

3.  Return the result of performing Binding Initialisation for
    BindingPattern passing exceptionObj and environment as the
    arguments.

RUNTIME SEMANTICS: CATCH CLAUSE EVALUATION

with parameter thrownValue

Catch : CATCH ( CatchParameter ) Block

1.  Let oldEnv be the running execution context’s LexicalEnvironment.

2.  Let catchEnv be the result of calling NewDeclarativeEnvironment
    passing oldEnv as the argument.

3.  For each element argName of the BoundNames of CatchParameter, do

    a.  Call the CreateMutableBinding concrete method of catchEnv
        passing argName as the argument.

    b.  Assert: The above call to CreateMutableBinding will never an
        return an abrupt completion.

4.  Let status be the result of performing Binding Initialisation for
    CatchParameter passing thrownValue and catchEnv as arguments.

5.  ReturnIfAbrupt(status).

6.  Set the running execution context’s LexicalEnvironment to
    catchEnv.

7.  Let B be the result of evaluating Block.

8.  Set the running execution context’s LexicalEnvironment to oldEnv.

9.  Return B.

NOTE No matter how control leaves the Block the LexicalEnvironment is
always restored to its former state.

RUNTIME SEMANTICS: EVALUATION

TryStatement : TRY Block Catch

TryStatement : TRY Block Finally

TryStatement : TRY Block Catch Finally

1.  Let B be the result of evaluating Block.

2.  If B.[[type]] is throw, then

    a.  Let C be the result of performing Catch Clause Evaluation of
        Catch with parameter B.value.

3.  Else B.[[type]] is not throw,

    a.  Let C be B.

4.  Let F be the result of evaluating Finally.

5.  If F.[[type]] is normal, return C.

6.  Return F.


The debugger statement

Syntax

DebuggerStatement :

DEBUGGER ;

RUNTIME SEMANTICS: EVALUATION

NOTE Evaluating the DebuggerStatement production may allow an
implementation to cause a breakpoint when run under a debugger. If a
debugger is not present or active this statement has no observable
effect.

The production DebuggerStatement : DEBUGGER ; is evaluated as follows:



FUNCTIONS AND GENERATORS


Function Definitions

Syntax

FunctionDeclaration :

FUNCTION BindingIdentifier ( FormalParameters ) { FunctionBody }

FunctionExpression :

FUNCTION BindingIdentifier~opt~ ( FormalParameters ) { FunctionBody }

StrictFormalParameters :

FormalParameters

FormalParameters :

[empty]
FormalParameterList

FormalParameterList :

FunctionRestParameter
FormalsList
FormalsList, FunctionRestParameter

FormalsList :

FormalParameter
FormalsList , FormalParameter

FunctionRestParameter :

... BindingIdentifier

FormalParameter :

BindingElement

FunctionBody :

FunctionStatementList

FunctionStatementList :

StatementList~opt~

Supplemental Syntax

The following productions are used as an aid in specifying the semantics
of certain ECMAScript language features. They are not used when parsing
ECMAScript source code.

FunctionBody :

ThrowTypeError

ThrowTypeError :

[empty]

Static Semantics

STATIC SEMANTICS: EARLY ERRORS

FunctionDeclaration : FUNCTION BindingIdentifier (
FormalParameters ) { FunctionBody }
and
FunctionExpression : FUNCTION BindingIdentifier~opt~ (
FormalParameters ) { FunctionBody }

-   It is a Syntax Error if FunctionBody Contains YieldExpression is
    TRUE.

-   If the source code matching this production is strict code, the
    Early Error rules for StrictFormalParameters : FormalParameters
    are applied.

  It is a Syntax Error if IsSimpleParameterList of FormalParameters is
  FALSE and any element of the BoundNames of FormalParameters also
  occurs in the VarDeclaredNames of FunctionBody.

-   -   -   -   It is a Syntax Error if any element of the BoundNames of
    FormalParameters also occurs in the LexicallyDeclaredNames of
    FunctionBody.

-   

NOTE The LexicallyDeclaredNames of a FunctionBody does not include
identifiers bound using var or function declarations. Simple parameter
lists bind identifiers as VarDeclaredNames. Parameter lists that contain
destructuring patterns, default value initialisers, or a rest parameter
bind identifiers as LexicallyDeclaredNames.

StrictFormalParameters : _FormalParameters _

-   It is a Syntax Error if BoundNames of FormalParameters contains
    any duplicate elements.

-   It is a Syntax Error if BoundNames of FormalParameters contains
    either ″EVAL″ or ″ARGUMENTS″.

FormalParameters : _FormalParameterList _

-   It is a Syntax Error if FormalParameters Contains
    YieldExpression is TRUE.

-   It is a Syntax Error if IsSimpleParameterList of
    FormalParameterList is FALSE and BoundNames of
    FormalParameterList contains any duplicate elements.

-   It is a Syntax Error if IsSimpleParameterList of
    FormalParameterList is FALSE and BoundNames of
    FormalParameterList contains either ″EVAL″ or ″ARGUMENTS″.

-   It is a Syntax Error if the source code matching this production is
    strict code and BoundNames of FormalParameterList contains any
    duplicate elements.

NOTE Multiple occurrences of the same Identifier in a
FormalParamterList is only allowed for non-strict functions and
generator functions that have simple parameter lists.

FunctionStatementList : _StatementList _

-   It is a Syntax Error if the LexicallyDeclaredNames of
    StatementList contains any duplicate entries.

-   It is a Syntax Error if any element of the LexicallyDeclaredNames of
    StatementList also occurs in the VarDeclaredNames of
    StatementList.

-   -   -   -   -   -   -   

-   -   

FormalParameter : BindingElement

-   It is a Syntax Error if BindingElement Contains YieldExpression.

STATIC SEMANTICS: BOUNDNAMES

FunctionDeclaration : FUNCTION BindingIdentifier (
FormalParameters ) { FunctionBody }

1.  Return the BoundNames of BindingIdentifier.

FormalParameters : [empty]

1.  Return an empty List.

1.  

1.  

FormalParameterList : FormalsList , FunctionRestParameter

1.  Let names be BoundNames of FormalsList.

2.  Append to names the BoundNames of FunctionRestParameter.

3.  Return names.

FormalsList : _FormalsList ,_ FormalParameter

1.  Let names be BoundNames of FormalsList.

2.  Append to names the elements of BoundNames of FormalParameter.

3.  Return names.

1.  

1.  

STATIC SEMANTICS: CONTAINS

  With parameter symbol.

FunctionDeclaration : FUNCTION BindingIdentifier (
FormalParameters ) { FunctionBody }

1.  Return FALSE.

FunctionExpression : FUNCTION BindingIdentifier~opt~ (
FormalParameters ) { FunctionBody }

1.  Return FALSE.

NOTE Static semantic rules that depend upon substructure generally do
not look into function definitions.

STATIC SEMANTICS: EXPECTEDARGUMENTCOUNT

FormalParameters : [empty]

1.  Return 0.

FormalParameterList :

FunctionRestParameter

1.  Return 0.

FormalParameterList :

FormalsList , FunctionRestParameter

1.  Return the ExpectedArgumentCount of FormalsList.

NOTE The ExpectedArgumentCount of a FormalParameterList is the number
of FormalParameters to the left of either the rest parameter or the
first FormalParameter with an Initialiser. A FormalParameter without
an initialiser is allowed after the first parameter with an initialiser
but such parameters are considered to be optional with UNDEFINED as
their default value.

FormalsList : FormalParameter

1.  If HasInitialiser of FormalParameter is FALSE return 0

2.  Return 1.

FormalsList : FormalsList, FormalParameter

1.  Let count be the ExpectedArgumentCount of FormalsList.

2.  If HasInitialiser of FormalsList is TRUE or HasInitialiser of
    FormalParameter is TRUE, then return count.

3.  Return count+1.

STATIC SEMANTICS: HASINITIALISER

1.  

FormalsList : _FormalsList ,_ FormalParameter

1.  If HasInitialiser of FormalsList is TRUE, then return TRUE.

2.  Return HasInitialiser of FormalParameter.

1.  

STATIC SEMANTICS: ISCONSTANTDECLARATION

FunctionDeclaration : FUNCTION BindingIdentifier (
FormalParameters ) { FunctionBody }

1.  Return FALSE.

STATIC SEMANTICS: ISSIMPLEPARAMETERLIST

FormalParameters : [empty]

1.  Return TRUE.

FormalParameterList : FunctionRestParameter

1.  Return FALSE.

FormalParameterList : FormalsList , FunctionRestParameter

1.  Return FALSE.

FormalsList : _FormalsList ,_ FormalParameter

1.  If IsSimpleParameterList of FormalsList is FALSE, return FALSE.

2.  Return IsSimpleParameterList of FormalParameter.

FormalParameter : BindingElement

1.  If HasInitialiser of BindingElement is TRUE, return FALSE.

2.  If FormalParameter Contains BindingPattern is TRUE, return
    FALSE.

3.  Return TRUE.

STATIC SEMANTICS: ISSTRICT

FunctionStatementList : StatementList~opt~

1.  If this FunctionStatementList is contained in strict code or if
    StatementList is strict code, then return TRUE. Otherwise, return
    FALSE.

2.  

STATIC SEMANTICS: LEXICALLYDECLAREDNAMES

FunctionDeclaration : FUNCTION BindingIdentifier (
FormalParameters ) { FunctionBody }

1.  Return the BoundNames of BindingIdentifier.

FunctionStatementList : [empty]

1.  Return an empty List.

FunctionStatementList : StatementList

1.  Return TopLevelLexicallyDeclaredNames of StatementList.

1.  

STATIC SEMANTICS: VARDECLAREDNAMES

FunctionDeclaration : FUNCTION BindingIdentifier (
FormalParameters ) { FunctionBody }

1.  Return an empty List.

FunctionBody : [empty]

1.  Return an empty List.

FunctionBody : StatementList

1.  Return TopLevelVarDeclaredNames of StatementList.

Runtime Semantics

RUNTIME SEMANTICS: BINDING INITIALISATION

  With parameters value and environment.

NOTE When UNDEFINED is passed for environment it indicates that a
PutValue operation should be used to assign the initialisation value.
This is the case for formal parameter lists of non-strict functions. In
that case the formal parameter bindings are preinitialised in order to
deal with the possibility of multiple parameters with the same name.

FormalParameters : [empty]

1.  Return NormalCompletion(empty).

FormalParameterList : FunctionRestParameter

1.  Return the result of performing Indexed Binding Initialisation for
    FunctionRestParameter using value, 0, and environment as the
    arguments

2.  .

FormalParameterList : FormalsList

1.  2.  3.  Return the result of performing Indexed Binding
    Initialisation for FormalsList using value, 0, and environment
    as the arguments.

4.  

FormalParameterList : FormalsList , FunctionRestParameter

1.  Let restIndex be the result of performing Indexed Binding
    Initialisation for FormalsList using value, 0, and environment
    as the arguments.

2.  ReturnIfAbrupt(restIndex).

3.  Return the result of performing Indexed Binding Initialisation for
    FunctionRestParameter using value, restIndex, and
    environment as the arguments.

RUNTIME SEMANTICS: EVALUATEBODY

  With parameter functionObject.

FunctionBody : FunctionStatementList~opt~

FunctionBody : ThrowTypeError

1.  Throw a TYPEERROR exception.

1.  

RUNTIME SEMANTICS: INDEXED BINDING INITIALISATION

  With parameters array, nextIndex, and environment.

FormalsList : FormalParameter

1.  Let status be the result of performing Indexed Binding
    Initialisation for FormalParameter using array, nextIndex, and
    environment as the arguments.

2.  ReturnIfAbrupt(status).

3.  Return nextIndex + 1.

FormalsList : FormalsList , FormalParameter

1.  Let lastIndex be the result of performing Indexed Binding
    Initialisation for FormalsList using array, nextIndex, and
    environment as the arguments.

2.  ReturnIfAbrupt(lastIndex).

3.  Let status be the result of performing Indexed Binding
    Initialisation for FormalParameter using array, lastIndex, and
    environment as the arguments.

4.  ReturnIfAbrupt(status).

5.  Return lastIndex + 1.

FunctionRestParameter : ... BindingIdentifier

1.  Assert: array is a well formed arguments object and hence it has a
    valid integer valued "LENGTH" property.

2.  Let status be the result of Get(array, "LENGTH").

3.  Let argumentsLength be status.[[value]].

4.  Let A be the result of the abstract operation ArrayCreate with
    argument 0.

5.  Let n=0;

6.  Repeat, while nextIndex < argumentsLength

    a.  Let P be ToString(nextIndex).

    b.  Assert: array is a well formed arguments object, hence it must
          have a property P.

    c.  Let v be the result of Get(array, P).

    d.  Call the [[DefineOwnProperty]] internal method of A with
          arguments ToString(n) and Property Descriptor {[[Value]]:
          v.[[value]], [[Writable]]: TRUE, [[Enumerable]]: TRUE,
          [[Configurable]]: TRUE}.

    e.  Let n = n+1.

    f.  Let nextIndex = nextIndex +1.

7.  Return the result of performing Binding Initialisation for
    BindingIdentifier using A and environment as arguments.

1.  

RUNTIME SEMANTICS: INSTANTIATEFUNCTIONOBJECT

  With parameter scope.

FunctionDeclaration : FUNCTION BindingIdentifier (
FormalParameters ) { FunctionBody }

1.  If the FunctionDeclaration is contained in strict code or if its
    FunctionBody is strict code, then let strict be TRUE. Otherwise
    let strict be FALSE.

2.  3.  Let F be the result of performing the FunctionCreate abstract
    operation with arguments Normal, FormalParameters, _FunctionBody,
    scope_, and strict.

4.  Perform the abstract operation MakeConstructor with argument F.

5.  Return F.

RUNTIME SEMANTICS: EVALUATION

FunctionDeclaration : FUNCTION BindingIdentifier (
FormalParameters ) { FunctionBody }

1.  Return NormalCompletion(empty)

FunctionExpression : FUNCTION ( FormalParameters ) { FunctionBody
}

1.  If the FunctionExpression is contained in strict code or if its
    FunctionBody is strict code, then let strict be TRUE. Otherwise
    let strict be FALSE.

2.  Let scope be the LexicalEnvironment of the running execution
    context.

3.  Let closure be the result of performing the FunctionCreate
    abstract operation with arguments Normal, FormalParameters,
    _FunctionBody, scope_, and strict.

4.  Perform the abstract operation MakeConstructor with argument
    closure.

5.  Return closure.

FunctionExpression : FUNCTION BindingIdentifier ( FormalParameters
) { FunctionBody }

NOTE 1 The BindingIdentifier in a FunctionExpression can be
referenced from inside the FunctionExpression's FunctionBody to
allow the function to call itself recursively. However, unlike in a
FunctionDeclaration, the BindingIdentifier in a FunctionExpression
cannot be referenced from and does not affect the scope enclosing the
FunctionExpression.

NOTE 2 A PROTOTYPE property is automatically created for every function
defined using a FunctionDeclaration or FunctionExpression, to allow
for the possibility that the function will be used as a constructor.


Arrow Function Definitions

Syntax

ArrowFunction :

ArrowParameters => ConciseBody

ArrowParameters :

BindingIdentifier
CoverParenthesisedExpressionAndArrowParameterList

ConciseBody :

[lookahead ∉ { { }] AssignmentExpression
{ FunctionBody }

Supplemental Syntax

When processing the production ArrowParameters :
CoverParenthesisedExpressionAndArrowParameterList the following
grammar is used to refine the interpretation of
CoverParenthesisedExpressionAndArrowParameterList.

ArrowFormalParameters :

( StrictFormalParameters )

Static Semantics

STATIC SEMANTICS: EARLY ERRORS

ArrowFunction : ArrowParameters => ConciseBody

-   It is a Syntax Error if any element of the BoundNames of
    ArrowParameters also occurs in the VarDeclaredNames of
    ConciseBody.

-   -   -   -   -   It is a Syntax Error if any element of the
    BoundNames of ArrowParameters also occurs in the
    LexicallyDeclaredNames of ConciseBody.

-   

ArrowParameters : BindingIdentifier

-   It is a Syntax Error if the StringValue of the sole element of the
    BoundNames of BindingIdentifier is EVAL or ARGUMENTS.

-   

ArrowParameters : CoverParenthesisedExpressionAndArrowParameterList

-   It is a Syntax Error if the lexical token sequence matched by
    CoverParenthesisedExpressionAndArrowParameterList cannot be parsed
    with no tokens left over using ArrowFormalParameters as the goal
    symbol.

-   It is a Syntax Error if any early errors are present for
    CoveredFormalsList of
    CoverParenthesisedExpressionAndArrowParameterList.

-   

ConciseBody : [lookahead ∉ { { }] AssignmentExpression

-   It is a Syntax Error if AssignmentExpression Contains
    YieldExpression.

STATIC SEMANTICS: BOUNDNAMES

ArrowParameters : CoverParenthesisedExpressionAndArrowParameterList

1.  Let formals be CoveredFormalsList of
    CoverParenthesisedExpressionAndArrowParameterList.

2.  Return the BoundNames of formals.

1.  

1.  

1.  

1.  

1.  

1.  2.  3.  

1.  

STATIC SEMANTICS: CONTAINS

  With parameter symbol.

ArrowFunction : _ArrowParameters =>_ ConciseBody

1.  If symbol is neither SUPER or THIS, then return FALSE.

2.  If ArrowParameters Contains symbol is TRUE, return TRUE;

3.  Return ConciseBody Contains symbol .

NOTE Normally, Contains does not look inside most function forms
However, Contains is used to detect THIS and SUPER usage within an
ArrowFunction.

ArrowParameters : CoverParenthesisedExpressionAndArrowParameterList

1.  Let formals be CoveredFormalsList of
    CoverParenthesisedExpressionAndArrowParameterList.

2.  Return formals Contains symbol.

STATIC SEMANTICS: COVEREDFORMALSLIST

ArrowParameters : BindingIdentifier

1.  Return BindingIdentifier.

CoverParenthesisedExpressionAndArrowParameterList :

( Expression )
( )
( ... Identifier )
( Expression , ... Identifier)

1.  Return the result of parsing the lexical token stream matched by
    CoverParenthesisedExpressionAndArrowParameterList using
    ArrowFormalParameters as the goal symbol.

STATIC SEMANTICS: EXPECTEDARGUMENTCOUNT

ArrowParameters : BindingIdentifier

1.  Return 1.

1.  

1.  

ArrowParameters : CoverParenthesisedExpressionAndArrowParameterList

1.  Let formals be CoveredFormalsList of
    CoverParenthesisedExpressionAndArrowParameterList.

2.  Return the ExpectedArgumentCount of formals.

STATIC SEMANTICS: ISSIMPLEPARAMETERLIST

ArrowParameters : BindingIdentifier

1.  Return TRUE.

ArrowParameters : CoverParenthesisedExpressionAndArrowParameterList

1.  Let formals be CoveredFormalsList of
    CoverParenthesisedExpressionAndArrowParameterList.

2.  Return the IsSimpleParameterList of formals.

STATIC SEMANTICS: LEXICALLYDECLAREDNAMES

ConciseBody : [lookahead ∉ { { }] AssignmentExpression

1.  Return an empty List.

Runtime Semantics

RUNTIME SEMANTICS: BINDING INITIALISATION

  With parameters value and environment.

NOTE When UNDEFINED is passed for environment it indicates that a
PutValue operation should be used to assign the initialisation value.
This is the case for formal parameter lists of non-strict functions. In
that case the formal parameter bindings are preinitialised in order to
deal with the possibility of multiple parameters with the same name.

ArrowParameters : BindingIdentifier

1.  Return the result of performing Binding Initialisation for
    BindingIdentifier using value and environment as the
    arguments.

ArrowParameters : CoverParenthesisedExpressionAndArrowParameterList

1.  Let formals be CoveredFormalsList of
    CoverParenthesisedExpressionAndArrowParameterList.

2.  Return the result of performing Binding Initialisation of formals
    with arguments value and environment.

RUNTIME SEMANTICS: EVALUATEBODY

  With parameter functionObject.

ConciseBody : [lookahead ∉ { { }] AssignmentExpression

1.  The code of this ConciseBody is strict mode code if it is
    contained in strict mode code or if any of the conditions in 10.1.1
    apply If the code of this ConciseBody is strict mode code,
    AssignmentExpression is evaluated in the following steps as strict
    mode code. Otherwise, AssignmentExpression is evaluated in the
    following steps as non-strict mode code.

2.  Let exprRef be the result of evaluating AssignmentExpression.

3.  Let exprValue be GetValue(exprRef).

4.  If exprValue.[[type]] is return then return
    NormalCompletion(exprValue.[[value]]).

5.  ReturnIfAbrupt(exprValue).

6.  Return NormalCompletion(exprValue).

NOTE In the absence of extensions to this specification, the test is
step 4 will never be TRUE.

1.  

1.  

1.  

1.  

1.  2.  3.  

RUNTIME SEMANTICS: EVALUATION

ArrowFunction : ArrowParameters => ConciseBody

1.  Let strict be TRUE.

2.  Let scope be the LexicalEnvironment of the running execution
    context.

3.  Let parameters be CoveredFormalsList of ArrowParameters.

4.  Let closure be the result of performing the FunctionCreate
    abstract operation with arguments Arrow, parameters, _ConciseBody,
    scope_, and strict.

5.  Return closure.

NOTE Even though an ArrowFunction may contain references to SUPER, the
FunctionCreate call in step 3 is not passed the optional homeObject
and methodName parameters. An ArrowFunction that references SUPER is
always contained within a non-ArrowFunction and the necessary state to
implement SUPER is accessible via the scope that is captured by the
function object of the ArrowFunction.

1.  

2.  3.  4.  5.  6.  


Method Definitions

Syntax

MethodDefinition :

PropertyName ( StrictFormalParameters ) { FunctionBody }
GeneratorMethod
GET PropertyName ( ) { FunctionBody }
SET PropertyName ( PropertySetParameterList ) { FunctionBody }

PropertySetParameterList :

BindingIdentifier
BindingPattern

NOTE The single element of a PropertySetParameterList may not have a
default value Initialiser because set accessor are always called with
an implicitly provided argument.

Static Semantics

STATIC SEMANTICS: EARLY ERRORS

-   -   -   -   -   -   -   

MethodDefinition : PropertyName ( StrictFormalParameters ) {
FunctionBody }

-   It is a Syntax Error if any element of the BoundNames of
    StrictFormalParameters also occurs in the VarDeclaredNames of
    FunctionBody.

-   It is a Syntax Error if any element of the BoundNames of
    StrictFormalParameters also occurs in the LexicallyDeclaredNames
    of FunctionBody.

-   -   -   

MethodDefinition : SET PropertyName ( PropertySetParameterList ) {
FunctionBody }

-   It is a Syntax Error if IsSimpleParameterList of
    PropertySetParameterList is FALSE and any element of the
    BoundNames of PropertySetParameterList also occurs in the
    VarDeclaredNames of FunctionBody.

-   It is a Syntax Error if IsSimpleParameterList of
    PropertySetParameterList is FALSE and BoundNames of
    PropertySetParameterList contains any duplicate elements.

-   It is a Syntax Error if IsSimpleParameterList of
    PropertySetParameterList is FALSE and BoundNames of
    PropertySetParameterList contains either ″EVAL″ or ″ARGUMENTS″.

-   It is a Syntax Error if BoundNames of PropertySetParameterList
    contains any duplicate elements.

-   It is a Syntax Error if any element of the BoundNames of
    PropertySetParameterList also occurs in the LexicallyDeclaredNames
    of FunctionBody.

-   It is a Syntax Error if PropertySetParameterList Contains
    YieldExpression.

-   

-   

1.  

1.  

STATIC SEMANTICS: EXPECTEDARGUMENTCOUNT

PropertySetParameterList : _BindingIdentifier _

1.  Return 1.

PropertySetParameterList : _BindingPattern _

1.  Return 1.

STATIC SEMANTICS: ISSIMPLEPARAMETERLIST

PropertySetParameterList : BindingIdentifier

1.  Return TRUE.

PropertySetParameterList : _BindingPattern _

1.  Return FALSE.

STATIC SEMANTICS: PROPNAME

MethodDefinition :

PropertyName ( FormalParameters ) { FunctionBody }
GET PropertyName ( ) { FunctionBody }
SET PropertyName ( PropertySetParameterList ) { FunctionBody }

1.  Return PropName of PropertyName.

1.  

1.  

1.  

STATIC SEMANTICS: REFERENCESSUPER

MethodDefinition :

PropertyName ( FormalParameters ) { FunctionBody }

1.  If FormalParameters Contains SUPER is TRUE, then return TRUE.

2.  Return FunctionBody Contains SUPER.

MethodDefinition : GET PropertyName ( ) { FunctionBody }

1.  Return FunctionBody Contains SUPER.

MethodDefinition : SET PropertyName ( PropertySetParameterList ) {
FunctionBody }

1.  If PropertySetParameterList Contains SUPER is TRUE, then return
    TRUE.

2.  Return FunctionBody Contains SUPER.

STATIC SEMANTICS: SPECIALMETHOD

MethodDefinition : PropertyName (StrictFormalParameters ) {
FunctionBody }

1.  Return FALSE.

MethodDefinition :

GeneratorMethod
GET PropertyName ( ) { FunctionBody }
SET PropertyName ( PropertySetParameterList ) { FunctionBody }

1.  Return TRUE.

Runtime Semantics

RUNTIME SEMANTICS: PROPERTY DEFINITION EVALUATION

  With parameter object and optional parameter functionPrototype.

MethodDefinition : PropertyName (StrictFormalParameters ) {
FunctionBody }

1.  Let propKey be the result of evaluating PropertyName.

2.  ReturnIfAbrupt(propKey).

3.  Let strict be IsStrict of FunctionBody.

4.  Let scope be the running execution context’s LexicalEnvironment.

5.  If isComputedPropertyName(propKey) is TRUE, then

    a.  Let duplicateKey be the result of calling the
        [[HasOwnProperty]] internal method of object with argument
        propKey.

    b.  ReturnIfAbrupt(duplicateKey).

    c.  If duplicateKey is TRUE, then throw a TYPEERROR exception.

6.  7.  8.  If ReferencesSuper of MethodDefinition is TRUE, then

    a.  Let closure be the result of performing the FunctionCreate
        abstract operation with arguments Method,
        StrictFormalParameters, _FunctionBody, scope_, and strict
        and with object as the homeObject optional argument and
        propKey as the methodName optional argument. If
        functionPrototype was passed as a parameter then also pass its
        value as the functionPrototype optional argument of
        FunctionCreate.

9.  Else

    a.  Let closure be the result of performing the FunctionCreate
        abstract operation with arguments Method,
        StrictFormalParameters, _FunctionBody, scope_, and strict.
        If functionPrototype was passed as a parameter then also pass
        its value as the functionPrototype optional argument of
        FunctionCreate.

10. Let desc be the Property Descriptor{[[Value]]: closure,
    [[Writable]]: TRUE, [[Enumerable]]: TRUE, [[Configurable]]: TRUE}.

11. Let status be the result of DefinePropertyOrThrow(object,
    propKey, desc).

12. ReturnIfAbrupt(status).

13. NormalCompletion(closure).

MethodDefinition : GeneratorMethod

See 13.4.

1.  2.  3.  4.  5.  6.  a.  

7.  a.  

8.  9.  10. 11. 12. 

MethodDefinition : GET PropertyName ( ) { FunctionBody }

1.  Let propKey be the result of evaluating PropertyName.

2.  ReturnIfAbrupt(propKey).

3.  Let strict be IsStrict of FunctionBody.

4.  Let scope be the running execution context’s LexicalEnvironment.

5.  Let formalParameterList be the production FormalParameters :
    [empty]

6.  If isComputedPropertyName(propKey) is TRUE, then

    a.  Let duplicateKey be the result of calling the
        [[HasOwnProperty]] internal method of object with argument
        propKey.

    b.  ReturnIfAbrupt(duplicateKey).

    c.  If duplicateKey is TRUE, then throw a TYPEERROR exception.

7.  8.  If ReferencesSuper of MethodDefinition is TRUE, then

    a.  Let closure be the result of performing the FunctionCreate
        abstract operation with arguments Method, formalParameterList,
        _FunctionBody, scope_, and strict and with object as the
        homeObject optional argument and propKey as the methodName
        optional argument.

9.  Else

    a.  Let closure be the result of performing the FunctionCreate
        abstract operation with arguments Method, formalParameterList,
        _FunctionBody, scope_, and strict.

10. 11. 12. Let desc be the Property Descriptor {[[Get]]: closure,
    [[Enumerable]]: TRUE, [[Configurable]]: TRUE}

13. Let status be the result of DefinePropertyOrThrow(object,
    propKey, desc).

14. ReturnIfAbrupt(status).

15. Return NormalCompletion(closure).

MethodDefinition : SET PropertyName ( PropertySetParameterList ) {
FunctionBody }

1.  Let propKey be the result of evaluating PropertyName.

2.  ReturnIfAbrupt(propKey).

3.  Let strict be IsStrict of FunctionBody.

4.  Let scope be the running execution context’s LexicalEnvironment.

5.  If isComputedPropertyName(propKey) is TRUE, then

    a.  Let duplicateKey be the result of calling the
        [[HasOwnProperty]] internal method of object with argument
        propKey.

    b.  ReturnIfAbrupt(duplicateKey).

    c.  If duplicateKey is TRUE, then throw a TYPEERROR exception.

6.  7.  8.  If ReferencesSuper of MethodDefinition is TRUE, then

    a.  Let closure be the result of performing the FunctionCreate
        abstract operation with arguments Method,
        PropertySetParameterList, _FunctionBody, scope_, and strict
        and with object as the homeObject optional argument and
        propKey as the methodName optional argument.

9.  Else

    a.  Let closure be the result of performing the FunctionCreate
        abstract operation with arguments Method,
        PropertySetParameterList, _FunctionBody, scope_, and strict.

10. 11. 12. Let desc be the Property Descriptor {[[Set]]: closure,
    [[Enumerable]]: TRUE, [[Configurable]]: TRUE}

13. Let status be the result of DefinePropertyOrThrow(object,
    propKey, desc).

14. ReturnIfAbrupt(status).

15. Return NormalCompletion(closure).


Generator Function Definitions

Syntax

GeneratorMethod :

* PropertyName (StrictFormalParameters) { FunctionBody }

GeneratorDeclaration :

FUNCTION * BindingIdentifier ( FormalParameters ) { FunctionBody }

GeneratorExpression :

FUNCTION * BindingIdentifier~opt~ ( FormalParameters ) { FunctionBody }

YieldExpression :

YIELD YieldDelegator~opt~ [Lexical goal InputElementRegExp]
AssignmentExpression

YieldDelegator :

*

Supplemental Syntax

The following productions are used as an aid in specifying the semantics
of certain ECMAScript language features. They are not used when parsing
ECMAScript source code.

GeneratorBody :

FunctionBody
Comprehension

Static Semantics

STATIC SEMANTICS: EARLY ERRORS

-   -   

GeneratorMethod : * PropertyName (StrictFormalParameters ) {
FunctionBody }

-   It is a Syntax Error if any element of the BoundNames of
    StrictFormalParameters also occurs in the VarDeclaredNames of
    FunctionBody.

-   It is a Syntax Error if any element of the BoundNames of
    StrictFormalParameters also occurs in the LexicallyDeclaredNames
    of FunctionBody.

GeneratorDeclaration : FUNCTION * BindingIdentifier (
FormalParameters ) { FunctionBody }
and
GeneratorExpression : FUNCTION * BindingIdentifier~opt~ (
FormalParameters ) { FunctionBody }

-   If the source code matching this production is strict code, the
    Early Error rules for StrictFormalParameters : FormalParameters
    are applied.

-   It is a Syntax Error if IsSimpleParameterList of FormalParameters
    is FALSE and any element of the BoundNames of FormalParameters
    also occurs in the VarDeclaredNames of FunctionBody.

-   It is a Syntax Error if any element of the BoundNames of
    FormalParameters also occurs in the LexicallyDeclaredNames of
    FunctionBody.

-   

STATIC SEMANTICS: BOUNDNAMES

GeneratorDeclaration : FUNCTION * BindingIdentifier (
FormalParameters ) { FunctionBody }

1.  Return the BoundNames of BindingIdentifier.

STATIC SEMANTICS: CONTAINS

  With parameter symbol.

GeneratorDeclaration : FUNCTION * BindingIdentifier (
FormalParameters) { FunctionBody }

1.  Return FALSE.

GeneratorExpression : FUNCTION * BindingIdentifier~opt~ (
FormalParameters ) { FunctionBody }

1.  Return FALSE.

NOTE Static semantic rules that depend upon substructure generally do
not look into function definitions.

STATIC SEMANTICS: ISCONSTANTDECLARATION

GeneratorDeclaration : FUNCTION * BindingIdentifier (
FormalParameters ) { FunctionBody }

1.  Return FALSE.

STATIC SEMANTICS: LEXICALLYDECLAREDNAMES

GeneratorDeclaration : FUNCTION * BindingIdentifier (
FormalParameters ) { FunctionBody }

1.  Return the BoundNames of BindingIdentifier.

STATIC SEMANTICS: PROPNAME

GeneratorMethod : * PropertyName ( FormalParameters ) {
FunctionBody }

1.  Return PropName of PropertyName.

STATIC SEMANTICS: REFERENCESSUPER

GeneratorMethod : * PropertyName ( FormalParameters ) { FunctionBody }

1.  If FormalParameters Contains SUPER is TRUE, then return TRUE.

2.  Return FunctionBody Contains SUPER.

STATIC SEMANTICS: VARDECLAREDNAMES

GeneratorDeclaration : FUNCTION * BindingIdentifier (
FormalParameters ) { FunctionBody }

1.  Return an empty List.

Runtime Semantics

NOTE: Abstract operations relating to generator objects are defined in
‎15.19.4.3.

RUNTIME SEMANTICS: EVALUATEBODY

  With parameter functionObject.

GeneratorBody : FunctionBody

1.  Assert: A Function Environment Record containing a this binding has
    already been activated as the current environment.

2.  Let env be the result of the GetThisEnvironment abstract
    operation.

3.  Let G be the result of calling the GetThisBinding concrete method
    of env.

4.  If Type(G) is not Object or if Type(G) is Object and G does
    not have a [[GeneratorState]] internal data property or if Type(G)
    is Object and G has a [[GeneratorState]] internal data property
    and the value of G’s [[GeneratorState]] internal data property is
    not UNDEFINED, then

    a.  Let newG be the result of calling
        OrdinaryCreateFromConstructor(functionObject,
        "%GENERATORPROTOTYPE%", ( [[GeneratorState]],
        [[GeneratorContext]]) ).

    b.  ReturnIfAbrupt(newG).

    c.  Let G be newG.

5.  Return the result of GeneratorStart(G, FunctionBody).

GeneratorBody : _Comprehension _

1.  Let G be the result of ObjectCreate("%GENERATORPROTOTYPE%", (
    [[GeneratorState]], [[GeneratorContext]]) ).

2.  ReturnIfAbrupt(G).

3.  Assert: the value of G’s [[GeneratorState]] internal data property
    is UNDEFINED..

4.  Let startStatus be the result of GeneratorStart(G,
    Comprehension).

5.  ReturnIfAbrupt(startStatus).

6.  Return G.

RUNTIME SEMANTICS: INSTANTIATEFUNCTIONOBJECT

  With parameter scope.

GeneratorDeclaration : FUNCTION * BindingIdentifier (
FormalParameters) { FunctionBody }

1.  If the GeneratorDeclaration is contained in strict code or if its
    FunctionBody is strict code, then let strict be TRUE. Otherwise
    let strict be FALSE.

2.  Using FunctionBody from the production that is being evaluated,
    let body be the supplemental syntactic grammar production:
    GeneratorBody : FunctionBody.

3.  Let F be the result of performing the GeneratorFunctionCreate
    abstract operation with arguments Normal, FormalParameters, _body,
    scope_, and strict.

4.  Let prototype be the result of the abstract operation ObjectCreate
    with the intrinsic object %GeneratorPrototype% as its argument.

5.  Perform the abstract operation MakeConstructor with arguments F,
    TRUE, and prototype.

6.  Return F.

RUNTIME SEMANTICS: PROPERTY DEFINITION EVALUATION

  With parameter object and optional parameter functionPrototype.

GeneratorMethod : * PropertyName ( StrictFormalParameters ) {
FunctionBody }

1.  Let propKey be the result of evaluating PropertyName.

2.  ReturnIfAbrupt(propKey).

3.  Let strict be IsStrict of FunctionBody.

4.  Let scope be the running execution context’s LexicalEnvironment.

5.  If isComputedPropertyName(propKey) is TRUE, then

    a.  Let duplicateKey be the result of calling the
        [[HasOwnProperty]] internal method of object with argument
        propKey.

    b.  ReturnIfAbrupt(duplicateKey).

    c.  If duplicateKey is TRUE, then throw a TYPEERROR exception.

6.  Using FunctionBody from the production that is being evaluated,
    let body be the supplemental syntactic grammar production:
    GeneratorBody : FunctionBody.

7.  If ReferencesSuper of GeneratorMethod is TRUE, then

    a.  Let closure be the result of performing the
        GeneratorFunctionCreate abstract operation with arguments
        Method, StrictFormalParameters, _body, scope_, and strict
        and with object as the homeObject optional argument and
        propKey as the methodName optional argument.

8.  Else

    a.  Let closure be the result of performing the
        GeneratorFunctionCreate abstract operation with arguments
        Method, StrictFormalParameters, _body, scope_, and strict.

9.  Let prototype be the result of the abstract operation ObjectCreate
    with the intrinsic object %GeneratorPrototype% as its argument.

10. Perform the abstract operation MakeConstructor with arguments
    closure, TRUE, and prototype.

11. Let desc be the Property Descriptor{[[Value]]: closure,
    [[Writable]]: TRUE, [[Enumerable]]: TRUE, [[Configurable]]: TRUE}.

12. Let status be the result of DefinePropertyOrThrow(object,
    propKey, desc).

13. ReturnIfAbrupt(status).

14. Return NormalCompletion(closure).

RUNTIME SEMANTICS: EVALUATION

GeneratorDeclaration : FUNCTION * BindingIdentifier (
FormalParameters ) { FunctionBody }

1.  Return NormalCompletion(empty)

GeneratorExpression : FUNCTION * ( FormalParameters ) {
FunctionBody }

1.  If the GeneratorExpression is contained in strict code or if its
    FunctionBody is strict code, then let strict be TRUE. Otherwise
    let strict be FALSE.

2.  Using FunctionBody from the production that is being evaluated,
    let body be the supplemental syntactic grammar production:
    GeneratorBody : FunctionBody.

3.  Let scope be the LexicalEnvironment of the running execution
    context.

4.  Let closure be the result of performing the
    GeneratorFunctionCreate abstract operation with arguments Normal,
    FormalParameters, _body, scope_, and strict.

5.  Let prototype be the result of the abstract operation ObjectCreate
    with the intrinsic object %GeneratorPrototype% as its argument.

6.  Perform the abstract operation MakeConstructor with arguments
    closure, TRUE, and prototype.

7.  Return closure.

GeneratorExpression : FUNCTION * BindingIdentifier (
FormalParameters) { FunctionBody }

1.  If the GeneratorExpression is contained in strict code or if its
    FunctionBody is strict code, then let strict be TRUE. Otherwise
    let strict be FALSE.

2.  Using FunctionBody from the production that is being evaluated,
    let body be the supplemental syntactic grammar production:
    GeneratorBody : FunctionBody.

3.  Let funcEnv be the result of calling NewDeclarativeEnvironment
    passing the running execution context’s Lexical Environment as the
    argument

4.  Let envRec be funcEnv’s environment record.

5.  Let name be StringValue of BindingIdentifier.

6.  Call the CreateImmutableBinding concrete method of envRec passing
    name as the argument.

7.  Let closure be the result of performing the
    GeneratorFunctionCreate abstract operation with arguments Normal,
    FormalParameters, _body, funcEnv_, and strict.

8.  Let prototype be the result of the abstract operation ObjectCreate
    with the intrinsic object %GeneratorPrototype% as its argument.

9.  Perform the abstract operation MakeConstructor with arguments
    closure, TRUE, and prototype.

10. Call the InitialiseBinding concrete method of envRec passing
    name and closure as the arguments.

11. Return NormalCompletion(closure).

NOTE 1 The BindingIdentifier in a GeneratorExpression can be
referenced from inside the GeneratorExpression's FunctionBody to
allow the generator code to call itself recursively. However, unlike in
a GeneratorDeclaration, the BindingIdentifier in a
GeneratorExpression cannot be referenced from and does not affect the
scope enclosing the GeneratorExpression.

YieldExpression : YIELD YieldDelegator~opt~ _AssignmentExpression _

1.  Let exprRef be the result of evaluating AssignmentExpression.

2.  Let value be GetValue(exprRef).

3.  ReturnIfAbrupt(value).

4.  If YieldDelegator is present, then

    a.  b.  Let iterator be the result of GetIterator(value).

    c.  ReturnIfAbrupt(iterator_)_.

    d.  e.  Let received be UNDEFINED.

    f.  Repeat

        i.  Let innerResult be the result of IteratorNext(iterator,
            received).

        ii. ReturnIfAbrupt(innerResult).

        iii. iv. Let done be IteratorComplete(innerResult).

        v.  ReturnIfAbrupt(done).

        vi. If done is TRUE, then

            1.  Let innerValue be the result of IteratorValue
                (innerResult).

            2.  Return innerValue.

        vii. Let yieldCompletion be the result of
            GeneratorYield(innerResult).

        viii. Let received be yieldCompletion.[[value]].

        ix. If yieldCompletion.[[type]] is throw, then

            1.  If HasProperty(iterator, "THROW") is TRUE, then

                a.  Let innerResult be the result of
                    Invoke(iterator, "THROW", (received)).

                b.  ReturnIfAbrupt(innerResult).

            2.  Return yieldCompletion.

5.  Return the result of GeneratorYield(CreateItrResultObject(value,
    FALSE)).


Class Definitions

Syntax

ClassDeclaration :

CLASS BindingIdentifier ClassTail

ClassExpression :

CLASS BindingIdentifier~opt~ ClassTail

ClassTail :

ClassHeritage~opt~ { ClassBody~opt~ }

ClassHeritage :

EXTENDS AssignmentExpression

ClassBody :

ClassElementList

ClassElementList :

ClassElement
ClassElementList ClassElement

ClassElement :

MethodDefinition
STATIC MethodDefinition
;

NOTE A ClassBody is always strict code.

Static Semantics

STATIC SEMANTICS: EARLY ERRORS

-   

ClassBody : ClassElementList

-   It is a Syntax Error if PrototypePropertyNameList of
    ClassElementList contains any duplicate entries, unless the
    following condition is true for each duplicate entry: The duplicated
    entry occurs exactly twice in the list and one occurrence was
    obtained from a GET accessor MethodDefinition and the other
    occurrence was obtained from a SET accessor MethodDefinition.

-   It is a Syntax Error if StaticPropertyNameList of ClassElementList
    contains any duplicate entries, unless the following condition is
    true for each duplicate entry: The duplicated entry occurs exactly
    twice in the list and one occurrence was obtained from a GET
    accessor MethodDefinition and the other occurrence was obtained
    from a SET accessor MethodDefinition.

-   

ClassElement : MethodDefinition

-   It is a Syntax Error if PropName of MethodDefinition is
    ″CONSTRUCTOR″ and SpecialMethod of MethodDefinition is TRUE.

ClassElement : STATIC MethodDefinition

-   It is a Syntax Error if PropName of MethodDefinition is
    ″PROTOTYPE″.

STATIC SEMANTICS: BOUNDNAMES

ClassDeclaration: CLASS BindingIdentifier ClassTail

1.  Return the BoundNames of BindingIdentifier.

STATIC SEMANTICS: CONSTRUCTORMETHOD

ClassElementList : ClassElement

1.  If ClassElement is the production ClassElement : ; then, return
    empty.

2.  If IsStatic of ClassElement is TRUE, return empty.

3.  If PropName of ClassElement is not ″CONSTRUCTOR″, return empty.

4.  Return ClassElement.

ClassElementList : ClassElementList ClassElement

1.  Let head be ConstructorMethod of ClassElementList.

2.  If head is not empty, return head.

3.  If ClassElement is the production ClassElement : ; then, return
    empty.

4.  If IsStatic of ClassElement is TRUE, return empty.

5.  If PropName of ClassElement is not ″CONSTRUCTOR″, return empty.

6.  Return ClassElement.

1.  2.  a.  

3.  

NOTE Early Error rules ensure that there is only one method definition
named ″CONSTRUCTOR″ and that it isn’t an accessor property or generator
definition.

STATIC SEMANTICS: CONTAINS

  With parameter symbol.

ClassTail : ClassHeritage~opt~ { ClassBody }

1.  If symbol is ClassBody, return TRUE.

2.  If ClassHeritage is not present, return FALSE.

3.  If symbol is ClassHeritage, return TRUE.

4.  Return the result of Contains for ClassHeritage with argument
    symbol.

NOTE Static semantic rules that depend upon substructure generally do
not look into class bodies.

STATIC SEMANTICS: ISCONSTANTDECLARATION

ClassDeclaration: CLASS BindingIdentifier ClassTail

1.  Return FALSE.

STATIC SEMANTICS: ISSTATIC

ClassElement : MethodDefinition

1.  Return FALSE.

ClassElement : STATIC MethodDefinition

1.  Return TRUE.

ClassElement : ;

1.  Return FALSE.

STATIC SEMANTICS: LEXICALLYDECLAREDNAMES

ClassDeclaration: CLASS BindingIdentifier ClassTail

1.  Return the BoundNames of BindingIdentifier.

STATIC SEMANTICS: PROTOTYPEMETHODDEFINITIONS

ClassElementList : ClassElement

1.  If ClassElement is the production ClassElement : ; then, return
    a new empty List.

2.  If IsStatic of ClassElement is TRUE, return a new empty List.

3.  If PropName of ClassElement is ″CONSTRUCTOR″, return a new empty
    List.

4.  5.  6.  Return a List containing ClassElement.

ClassElementList : ClassElementList ClassElement

1.  Let list be PrototypeMethodDefinitions of ClassElementList.

2.  If ClassElement is the production ClassElement : ; then, return
    list.

3.  If IsStatic of ClassElement is TRUE, return list.

4.  If PropName of ClassElement is ″CONSTRUCTOR″, return list.

5.  6.  Append ClassElement to the end of list.

7.  Return list.

STATIC SEMANTICS: PROTOTYPEPROPERTYNAMELIST

ClassElementList : ClassElement

1.  If PropName of ClassElement is empty, return a new empty List.

2.  If IsStatic of ClassElement is TRUE, return a new empty List.

3.  Return a List containing PropName of ClassElement.

ClassElementList : ClassElementList ClassElement

1.  Let list be PrototypePropertyNameList of ClassElementList.

2.  If PropName of ClassElement is empty, return list.

3.  If IsStatic of ClassElement is TRUE, return list.

4.  Append PropName of ClassElement to the end of list.

5.  Return list.

STATIC SEMANTICS: PROPNAME

ClassElement : ;

1.  Return empty.

STATIC SEMANTICS: STATICPROPERTYNAMELIST

ClassElementList : ClassElement

1.  If PropName of ClassElement is empty, return a new empty List.

2.  If IsStatic of ClassElement is FALSE, return a new empty List.

3.  Return a List containing PropName of ClassElement.

ClassElementList : ClassElementList ClassElement

1.  Let list be StaticPropertyNameList of ClassElementList.

2.  If PropName of ClassElement is empty, return list.

3.  If IsStatic of ClassElement is FALSE, return list.

4.  Append PropName of ClassElement to the end of list.

5.  Return list.

STATIC SEMANTICS: STATICMETHODDEFINITIONS

ClassElementList : ClassElement

1.  If ClassElement is the production ClassElement : ; then, return
    a new empty List.

2.  3.  If IsStatic of ClassElement is FALSE, return a new empty List.

4.  Return a List containing ClassElement.

ClassElementList : ClassElementList ClassElement

1.  Let list be StaticMethodDefinitions of ClassElementList.

2.  If ClassElement is the production ClassElement : ; then, return
    list.

3.  4.  If IsStatic of ClassElement is FALSE, return list.

5.  Append ClassElement to the end of list.

6.  Return list.

STATIC SEMANTICS: VARDECLAREDNAMES

ClassDeclaration: CLASS BindingIdentifier ClassTail

1.  Return an empty List.

Runtime Semantics

RUNTIME SEMANTICS: CLASSDEFINITIONEVALUATION

  With parameter className.

ClassTail : ClassHeritage~opt~ { ClassBody }

1.  If ClassHeritage~opt~ is not present, then

    a.  let protoParent be the intrinsic object %ObjectPrototype%.

    b.  Let constructorParent be the intrinsic object
        %FunctionPrototype%.

2.  Else

    a.  Let superclass be the result of evaluating ClassHeritage.

    b.  ReturnIfAbrupt(superclass).

    c.  If superclass is NULL, then

        i.  Let protoParent be NULL.

        ii. Let constructorParent be the intrinsic object
            %FunctionPrototype%.

    d.  e.  Else if IsConstructor(superclass) is FALSE, then

    f.  throw a TYPEERROR exception.

        i.  

    g.  Else

        i.  Let protoParent be the result of Get(superclass,
            "PROTOTYPE").

        ii. ReturnIfAbrupt(protoParent).

        iii. If Type(protoParent) is neither Object or Null, throw a
            TYPEERROR exception.

        iv. Let constructorParent be superclass.

3.  Let proto be the result of the abstract operation ObjectCreate
    with argument protoParent.

4.  5.  Let lex be the LexicalEnvironment of the running execution
    context.

6.  If className is not UNDEFINED, then

    a.  Let scope be the result of calling NewDeclarativeEnvironment
        passing lex as the argument

    b.  Let envRec be scope’s environment record.

    c.  Call the CreateImmutableBinding concrete method of envRec
        passing className as the argument.

    d.  Set the running execution context’s LexicalEnvironment to
        scope.

7.  Let constructor be ConstructorMethod of ClassBody.

8.  If constructor is empty, then

    a.  If ClassHeritage~opt~ is present, then

        i.  Let constructor be the result of parsing the String
            "CONSTRUCTOR(... ARGS){SUPER (...ARGS);}" using the
            syntactic grammar with the goal symbol MethodDefinition.

    b.  Else,

        i.  Let constructor be the result of parsing the String
            "CONSTRUCTOR( ){ }" using the syntactic grammar with the
            goal symbol MethodDefinition.

9.  Let strict be TRUE.

10. Let F be the result of performing Property Definition Evaluation
    for constructor with argument proto and constructorParent as
    the optional functionPrototype argument.

11. Perform the abstract operation MakeConstructor with argument F and
    FALSE as the optional writablePrototype argument and proto as
    the optional prototype argument.

12. If className is not UNDEFINED, then

    a.  Call the InitialiseBinding concrete method of envRec passing
        className and F as the arguments.

13. Let desc be the Property Descriptor{[[Enumerable]]: FALSE,
    [[Writable]]: TRUE, [[Configurable]]: TRUE}.

14. Call the [[DefineOwnProperty]] internal method of proto with
    arguments "CONSTRUCTOR" and desc

15. Let protoMethods be PrototypeMethodDefinitions of ClassBody.

16. For each MethodDefinition m in order from protoMethods

    a.  Perform Property Definition Evaluation for m with argument
        proto.

17. Let staticMethods be StaticMethodDefinitions of ClassBody.

18. For each MethodDefinition s in order from staticMethods

    a.  Perform Property Definition Evaluation for s with argument
        F.

19. Set the running execution context’s LexicalEnvironment to lex.

20. Return F.

RUNTIME SEMANTICS: EVALUATION

ClassDeclaration: CLASS BindingIdentifier ClassTail

1.  2.  Let value be the result of ClassDefinitionEvaluation of
    ClassTail with argument UNDEFINED.

3.  ReturnIfAbrupt(value).

4.  Let env be the running execution context’s LexicalEnvironment.

5.  Let status be the result of performing Binding Initialisation for
    BindingIdentifier passing value and env as the arguments.

6.  ReturnIfAbrupt(status).

7.  Return NormalCompletion(empty).

NOTE The argument to ClassDefinitionEvaluation controls whether or not
the class that is defined with a BindingIdentifier has a local binding
to the identifier. Only a ClassExpression gets a local name binding of
its name. A ClassDeclaration never has such a binding. This maintains
the parallel with FunctionExpression and FunctionDeclaration.

ClassExpression: CLASS BindingIdentifier~opt~ ClassTail

1.  If BindingIdentifier~opt~ is not present, then let className be
    UNDEFINED.

2.  Else, let className be StringValue of BindingIdentifier.

3.  Let value be the result of ClassDefinitionEvaluation of
    ClassTail with argument className.

4.  ReturnIfAbrupt(value).

5.  Return NormalCompletion(value).


1.  2.  

3.  a.  

4.  5.  

6.  

7.  a.  b.  c.  d.  

6.  

1.  

7.  

1.  2.  3.  4.  5.  

6.  7.  

    a.  

8.  a.  b.  

        i.  ii. iii. 

    c.  

9.  10. 11. 12. 13. a.  b.  

14. 

15. 16. 17. 18. 19. 20. 21. 

1.  2.  3.  4.  5.  6.  7.  8.  9.  10. 11. 

1.  2.  

3.  4.  


Tail Position Calls

The wiki proposal has a preliminary attempt at defining tail position.
See http://wiki.ecmascript.org/doku.php?id=harmony:proper_tail_calls.

This material still needs to be reviewed and updated for incorporation
here.

Runtime Semantics

RUNTIME SEMANTICS: PREPAREFORTAILCALL

The abstract operation PrepareForTailCall performs the following steps:

1.  Let leafContext be the running execution context.

2.  Suspend leafContext.

3.  Pop leafContext from the execution context context stack. The
    execution context now on the top of the stack becomes the running
    execution context, however it remains in its suspended state.

4.  Assert: leafContext has no further use. It will never be activated
    as the running execution context.

A tail position call must either release any transient internal
resources associated with the currently executing function execution
context before invoking the target function or reuse those resources in
support of the target function.

NOTE 1 For example, a tail position call should only grow an
implementation’s activication record stack by the amount that the size
of the target function’s activation record exceeds the size of the
calling function’s activation record. If the target function’s
activation record is smaller, then the total size of the stack should
decrease.



SCRIPTS AND MODULES


Script

Syntax

Script :

ScriptBody~opt~

ScriptBody :

OuterStatementList

OuterStatementList :

OuterItem
OuterStatementList OuterItem

OuterItem :

ModuleDeclaration
ImportDeclaration
StatementListItem

Static Semantics

STATIC SEMANTICS: EARLY ERRORS

ScriptBody : OuterStatementList

-   It is a Syntax Error if the LexicallyDeclaredNames of
    OuterStatementList contains any duplicate entries.

-   It is a Syntax Error if any element of the LexicallyDeclaredNames of
    OuterStatementList also occurs in the VarDeclaredNames of
    OuterStatementList.

-   It is a Syntax Error if OuterStatementList Contains
    ReturnStatement.

-   It is a Syntax Error if OuterStatementList Contains SUPER.

-   It is a Syntax Error if OuterStatementList Contains
    YieldExpression.

NOTE Additional error conditions relating to conflicting or duplicate
declarations are checked during module linking prior to evaluation of a
Script. If any such errors are detected the Script is not evaluated.

STATIC SEMANTICS: ISSTRICT

ScriptBody : OuterStatementList

1.  If this ScriptBody is contained in strict code or if
    OuterStatementList is strict code, then return TRUE. Otherwise,
    return FALSE.

STATIC SEMANTICS: LEXICALLYDECLAREDNAMES

OuterStatementList : _OuterStatementList OuterItem_

1.  Let names be LexicallyDeclaredNames of OuterStatementList.

2.  Append to names the elements of the LexicallyDeclaredNames of
    OuterItem.

3.  Return names.

OuterItem : ModuleDeclaration

1.  Return the BoundNames of ModuleDeclaration.

OuterItem : ImportDeclaration

1.  Return the BoundNames of ImportDeclaration.

OuterItem : StatementListItem

1.  Return TopLevelLexicallyDeclaredNames of StatementListItem.

NOTE At the top level of a Script, function declarations are treated
like var declarations rather than like lexical declarations.

STATIC SEMANTICS: LEXICALLYSCOPEDDECLARATIONS

OuterStatementList : _OuterStatementList OuterItem_

1.  Let declarations be LexicallyScopedDeclarations of
    OuterStatementList.

2.  Append to declarations the elements of the
    LexicallyScopedDeclarations of OuterItem.

3.  Return declarations.

OuterItem : ModuleDeclaration

1.  Return a new List containing ModuleDeclaration.

OuterItem : ImportDeclaration

1.  Return a new List containing ImportDeclaration.

OuterItem : StatementListItem

1.  Return TopLevelLexicallyScopedDeclarations of StatementListItem.

STATIC SEMANTICS: VARDECLAREDNAMES

OuterStatementList : _OuterStatementList OuterItem_

1.  Let names be VarDeclaredNames of OuterStatementList.

2.  Append to names the elements of the VarDeclaredNames of
    OuterItem.

3.  Return names.

OuterItem : ModuleDeclaration

1.  Return an empty List.

OuterItem : ImportDeclaration

1.  Return an empty List.

OuterItem : StatementListItem

1.  Return TopLevelVarDeclaredNames of StatementListItem.

STATIC SEMANTICS: VARSCOPEDDECLARATIONS

OuterStatementList : _OuterStatementList OuterItem_

1.  Let declarations be VarScopedDeclarations of OuterStatementList.

2.  Append to declarations the elements of the VarScopedDeclarations
    of OuterItem.

3.  Return declarations.

OuterItem : ModuleDeclaration

1.  Return a new empty List.

OuterItem : ImportDeclaration

1.  Return a new empty List.

OuterItem : StatementListItem

1.  Return the TopLevelVarScopedDeclarations of StatementListItem.

Runtime Semantics

RUNTIME SEMANTICS: SCRIPT EVALUATION

  With argument realm and deletableBindings.

Script : ScriptBody~opt~

NOTE The processes for initiating the evaluation of a Script and for
dealing with the result of such an evaluation are defined by an
ECMAScript implementation and not by this specification.

RUNTIME SEMANTICS: EVALUATION

OuterStatementList : OuterStatementList OuterItem

1.  Let sl be the result of evaluating OuterStatementList.

2.  ReturnIfAbrupt(sl).

3.  Let s be the result of evaluating OuterItem.

4.  If s.[[type]] is throw, return s.

5.  If s.[[value]] is empty, let V = sl.[[value]], otherwise let
    V = s.[[value]].

6.  Return Completion {[[type]]: s.[[type]], [[value]]: V,
    [[target]]: s.[[target]]}.

NOTE See the 12.1 NOTE regarding evaluation of StatementList :
_StatementList StatementListItem._


Directive Prologues and the Use Strict Directive

A Directive Prologue is the longest sequence of ExpressionStatement
productions occurring as the initial StatementListItem productions of
a ScriptBody or FunctionBody and where each ExpressionStatement in
the sequence consists entirely of a StringLiteral token followed by a
semicolon. The semicolon may appear explicitly or may be inserted by
automatic semicolon insertion. A Directive Prologue may be an empty
sequence.

A Use Strict Directive is an ExpressionStatement in a Directive
Prologue whose StringLiteral is either the exact character sequences
"USE STRICT" or 'USE STRICT'. A Use Strict Directive may not contain an
EscapeSequence or LineContinuation.

A Directive Prologue may contain more than one Use Strict Directive.
However, an implementation may issue a warning if this occurs.

NOTE The ExpressionStatement productions of a Directive Prologue are
evaluated normally during evaluation of the containing production.
Implementations may define implementation specific meanings for
ExpressionStatement productions which are not a Use Strict Directive
and which occur in a Directive Prologue. If an appropriate notification
mechanism exists, an implementation should issue a warning if it
encounters in a Directive Prologue an ExpressionStatement that is not
a Use Strict Directive or which does not have a meaning defined by the
implementation.


Modules



STANDARD BUILT-IN ECMASCRIPT OBJECTS


There are certain built-in objects available whenever an ECMAScript
program begins execution. One, the global object, is part of the lexical
environment of the executing program. Others are accessible as initial
properties of the global object.

Unless specified otherwise, a built-in object that is callable as a
function is a Build-in Function object with the characteristics
described in 8.4.7. Unless specified otherwise, the [[Extensible]]
internal data property of a built-in object initially has the value
TRUE.

Many built-in objects are functions: they can be invoked with arguments.
Some of them furthermore are constructors: they are functions intended
for use with the NEW operator. For each built-in function, this
specification describes the arguments required by that function and
properties of the Function object. For each built-in constructor, this
specification furthermore describes properties of the prototype object
of that constructor and properties of specific object instances returned
by a NEW expression that invokes that constructor.

Unless otherwise specified in the description of a particular function,
if a function or constructor described in this clause is given fewer
arguments than the function is specified to require, the function or
constructor shall behave exactly as if it had been given sufficient
additional arguments, each such argument being the UNDEFINED value.

Unless otherwise specified in the description of a particular function,
if a function or constructor described in this clause is given more
arguments than the function is specified to allow, the extra arguments
are evaluated by the call and then ignored by the function. However, an
implementation may define implementation specific behaviour relating to
such arguments as long as the behaviour is not the throwing of a
TYPEERROR exception that is predicated simply on the presence of an
extra argument.

NOTE Implementations that add additional capabilities to the set of
built-in functions are encouraged to do so by adding new functions
rather than adding new parameters to existing functions.

Unless otherwise specified very built-in function and every built-in
constructor has the Function prototype object, which is the initial
value of the expression FUNCTION.PROTOTYPE (15.3.3), as the value of its
[[Prototype]] internal data property.

Unless otherwise specified every built-in prototype object has the
Object prototype object, which is the initial value of the expression
OBJECT.PROTOTYPE (15.2.4), as the value of its [[Prototype]] internal
data property, except the Object prototype object itself.

None of the built-in functions described in this clause that are not
constructors shall implement the [[Construct]] internal method unless
otherwise specified in the description of a particular function. The
behaviour specified in this clause for each built-in function is the
specification of the [[Call]] internal method behaviour for that
function with the [[Call]] thisArgument providing the THIS value and
the [[Call]] argumentsList providing the named parameters for each
built-in function. When a built-in constructor is called as part of a
NEW expression the argumentsList parameter of the invoked
[[Construct]] internal method provides the values for the built-in
constructor’s named parameters. None of the built-in functions described
in this clause shall have a PROTOTYPE property unless otherwise
specified in the description of a particular function.

This clause generally describes distinct behaviours for when a
constructor is “called as a function” and for when it is “called as part
of a NEW expression”. The “called as a function” behaviour corresponds
to the invocation of the constructor’s [[Call]] internal method and the
“called as part of a new expression” behaviour corresponds to the
invocation of the constructor’s [[Construct]] internal method.

Every built-in Function object, F, described in this clause—whether as
a constructor, an ordinary function, or both—has the properties that are
defined by performing the following step when the function object is
created:

1. Perform the AddRestrictedFunctionProperties (13.6.3) abstract
operation with argument F.

Every built-in Function object described in this clause—whether as a
constructor, an ordinary function, or both—has a LENGTH property whose
value is an integer. Unless otherwise specified, this value is equal to
the largest number of named arguments shown in the subclause headings
for the function description, including optional parameters.

NOTE For example, the Function object that is the initial value of the
slice property of the String prototype object is described under the
subclause heading “String.prototype.slice (start, end)” which shows the
two named arguments start and end; therefore the value of the length
property of that Function object is 2.

In every case, the LENGTH property of a built-in Function object
described in this clause has the attributes { [[Writable]]: FALSE,
[[Enumerable]]: FALSE, [[Configurable]]: TRUE }.

Every other data property described in this clause has the attributes {
[[Writable]]: TRUE, [[Enumerable]]: FALSE, [[Configurable]]: TRUE }
unless otherwise specified.

Every accessor property described in this clause has the attributes
{[[Enumerable]]: FALSE, [[Configurable]]: TRUE } unless otherwise
specified. If only a get accessor function is described, the set
accessor function is the default value, UNDEFINED. If only a set
accessor is function is described the get accessor is the default value,
UNDEFINED.


The Global Object

The unique _global object_ is created before control enters any
execution context.

Unless otherwise specified, the standard built-in properties of the
global object have attributes {[[Writable]]: TRUE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE}.

The global object does not have a [[Construct]] internal method; it is
not possible to use the global object as a constructor with the NEW
operator.

The global object does not have a [[Call]] internal method; it is not
possible to invoke the global object as a function.

The value of the [[Prototype]] internal data property of the global
object is implementation-dependent.

In addition to the properties defined in this specification the global
object may have additional host defined properties. This may include a
property whose value is the global object itself; for example, in the
HTML document object model the WINDOW property of the global object is
the global object itself.

Value Properties of the Global Object

NaN

The value of NAN is NAN (see 8.5). This property has the attributes {
[[Writable]]: FALSE, [[Enumerable]]: FALSE, [[Configurable]]: FALSE }.

Infinity

The value of INFINITY is +∞ (see 8.5). This property has the attributes
{ [[Writable]]: FALSE, [[Enumerable]]: FALSE, [[Configurable]]: FALSE }.

undefined

The value of UNDEFINED is UNDEFINED (see 8.1). This property has the
attributes { [[Writable]]: FALSE, [[Enumerable]]: FALSE,
[[Configurable]]: FALSE }.

Function Properties of the Global Object

eval (x)

When the EVAL function is called with one argument x, the following
steps are taken:

1.  If Type(x) is not String, return x.

2.  Let script be the ECMAScript code that is the result of parsing
    x, interpreted as UTF-16 encoded Unicode text as described in
    8.4, for the goal symbol Script. If the parse fails or any early
    errors are detected, throw a SYNTAXERROR exception (but see also
    clause 16).

3.  If script Contains ScriptBody is FALSE, return UNDEFINED.

4.  Let strictScript be IsStrict of script.

5.  If this is a direct call to eval (15.1.2.1.1), let direct be TRUE,
    otherwise let direct be FALSE.

6.  If direct is TRUE and the code that made the direct call to eval
    is strict code, then let strictCaller be TRUE. Otherwise, let
    strictCaller be FALSE.

7.  Let ctx be the running execution context. If direct is TRUE
    ctx will be the execution context that performed the direct eval.
    If direct is FALSE ctx will be the execution context for the
    invocation of the eval function.

8.  Let evalRealm be ctx’s Realm.

9.  If direct is FALSE and strictScript is FALSE, then

    a.  Return the result of Script Evaluation for script with
        arguments evalRealm and TRUE.

10. If direct is TRUE, strictScript is FALSE, strictCaller is
    FALSE, and ctx’s LexicalEnvironment is the same as
    evalRealm.[[globalEnv]], then

    a.  Return the result of Script Evaluation for script with
        arguments evalRealm and TRUE.

11. If direct is TRUE, then

    a.  If the code that made the direct call to eval is function code
        and ValidInFunction of script is FALSE, then throw a
        SYNTAXERROR exception.

    b.  If the code that made the direct call to eval is module code and
        ValidInModule of script is FALSE, then throw a SYNTAXERROR
        exception.

12. 13. a.  

14. If direct is TRUE, then

    a.  b.  Let lexEnv be ctx’s LexicalEnvironment.

    c.  Let varEnv be ctx’s VariableEnvironment.

15. Else,

    a.  Let lexEnv be evalRealm.[[globalEnv]].

    b.  Let varEnv be evalRealm.[[globalEnv]].

16. If strictScript is TRUE or if direct is TRUE and strictCaller
    is TRUE , then

    a.  Let strictVarEnv be the result of calling
        NewDeclarativeEnvironment passing lexEnv as the argument.

    b.  Let lexEnv be strictVarEnv.

    c.  let varEnv be strictVarEnv.

    d.  

17. Let status be the result of performing Eval Declaration
    Instantiation as described in 10.5.5 with script, varEnv, and
    lexEnv.

18. ReturnIfAbrupt(status).

19. Let evalCxt be a new ECMAScript code execution context.

20. Set the evalCxt’s Realm to evalRealm.

21. Set the evalCxt’s VariableEnvironment to varEnv.

22. Set the evalCxt’s LexicalEnvironment to lexEnv.

23. If there is a currently running execution context, suspend it.

24. Push evalCxt on to the execution context stack; evalCxt is now
    the running execution context.

25. Let result be the result of evaluating script.

26. Suspend evalCxt and remove it from the execution context stack.

27. Resume the context that is now on the top of the execution context
    stack as the running execution context.

28. 29. 30. 31. Return result.

NOTE The eval code cannot instantiate variable or function bindings in
the variable environment of the calling context that invoked the eval if
either the code of the calling context or the eval code is strict code.
Instead such bindings are instantiated in a new VariableEnvironment that
is only accessible to the eval code.

Direct Call to Eval

A direct call to the eval function is one that is expressed as a
CallExpression that meets all of the following conditions:

-   The Reference that is the result of evaluating the
    MemberExpression in the CallExpression has an environment record
    as its base value and its reference name is "EVAL".

-   If the base value of the Reference has TRUE as its withEnvironment
    value, then its binding object is an object that uses the ordinary
    definition of the [[Invoke]] internal method (‎8.3.11)

-   The result of calling the abstract operation GetValue with that
    Reference as the argument is the standard built-in function defined
    in ‎15.1.2.1.

parseInt (string , radix)

The PARSEINT function produces an integer value dictated by
interpretation of the contents of the string argument according to the
specified radix. Leading white space in string is ignored. If
radix is UNDEFINED or 0, it is assumed to be 10 except when the number
begins with the character pairs 0X or 0X, in which case a radix of 16 is
assumed. If radix is 16, the number may also optionally begin with the
character pairs 0X or 0X.

When the PARSEINT function is called, the following steps are taken:

NOTE PARSEINT may interpret only a leading portion of string as an
integer value; it ignores any characters that cannot be interpreted as
part of the notation of an integer, and no indication is given that any
such characters were ignored.

parseFloat (string)

The PARSEFLOAT function produces a Number value dictated by
interpretation of the contents of the string argument as a decimal
literal.

When the PARSEFLOAT function is called, the following steps are taken:

1.  Let inputString be ToString(string).

2.  ReturnIfAbrupt(inputString).

3.  Let trimmedString be a substring of inputString consisting of
    the leftmost character that is not a StrWhiteSpaceChar and all
    characters to the right of that character. (In other words, remove
    leading white space.) If inputString does not contain any such
    characters, let trimmedString be the empty string.

4.  If neither trimmedString nor any prefix of trimmedString
    satisfies the syntax of a StrDecimalLiteral (see 9.3.1), return
    NAN.

5.  Let numberString be the longest prefix of trimmedString, which
    might be trimmedString itself, that satisfies the syntax of a
    StrDecimalLiteral.

6.  Return the Number value for the MV of numberString.

NOTE PARSEFLOAT may interpret only a leading portion of string as a
Number value; it ignores any characters that cannot be interpreted as
part of the notation of an decimal literal, and no indication is given
that any such characters were ignored.

isNaN (number)

Returns TRUE if the argument coerces to NAN, and otherwise returns
FALSE.

1.  Let num be ToNumber(number).

2.  ReturnIfAbrupt(num).

3.  If num is NAN, return TRUE.

4.  Otherwise, return FALSE.

NOTE A reliable way for ECMAScript code to test if a value X is a NAN is
an expression of the form X !== X. The result will be TRUE if and only
if X is a NAN.

isFinite (number)

Returns FALSE if the argument coerces to NAN, +∞, or −∞, and otherwise
returns TRUE.

URI Handling Function Properties

Uniform Resource Identifiers, or URIs, are Strings that identify
resources (e.g. web pages or files) and transport protocols by which to
access them (e.g. HTTP or FTP) on the Internet. The ECMAScript language
itself does not provide any support for using URIs except for functions
that encode and decode URIs as described in 15.1.3.1, 15.1.3.2, 15.1.3.3
and 15.1.3.4.

NOTE Many implementations of ECMAScript provide additional functions and
methods that manipulate web pages; these functions are beyond the scope
of this standard.

A URI is composed of a sequence of components separated by component
separators. The general form is:

Scheme : First / Second ; Third ? Fourth

where the italicised names represent components and “:”, “/”, “;” and
“?” are reserved characters used as separators. The ENCODEURI and
DECODEURI functions are intended to work with complete URIs; they assume
that any reserved characters in the URI are intended to have special
meaning and so are not encoded. The ENCODEURICOMPONENT and
DECODEURICOMPONENT functions are intended to work with the individual
component parts of a URI; they assume that any reserved characters
represent text and so must be encoded so that they are not interpreted
as reserved characters when the component is part of a complete URI.

The following lexical grammar specifies the form of encoded URIs.

Syntax

uri :::

uriCharacters~opt~

uriCharacters :::

uriCharacter uriCharacters~opt~

uriCharacter :::

uriReserved
uriUnescaped
uriEscaped

uriReserved ::: ONE OF

; / ? : @ & = + $ ,

uriUnescaped :::

uriAlpha
DecimalDigit
uriMark

uriEscaped :::

% HexDigit HexDigit

uriAlpha ::: ONE OF

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

uriMark ::: ONE OF

- _ . ! ~ * ' ( )

NOTE The above syntax is based upon RFC 2396 and does not reflect
changes introduced by the more recent RFC 3986.

RUNTIME SEMANTICS

When a character to be included in a URI is not listed above or is not
intended to have the special meaning sometimes given to the reserved
characters, that character must be encoded. The character is transformed
into its UTF-8 encoding, with surrogate pairs first converted from
UTF-16 to the corresponding code point value. (Note that for code units
in the range [0,127] this results in a single octet with the same
value.) The resulting sequence of octets is then transformed into a
String with each octet represented by an escape sequence of the form
“%xx”.

RUNTIME SEMANTICS: ENCODE ABSTRACT OPERATION

The encoding and escaping process is described by the abstract operation
Encode taking two String arguments string and unescapedSet.

RUNTIME SEMANTICS: DECODE ABSTRACT OPERATION

The unescaping and decoding process is described by the abstract
operation Decode taking two String arguments string and reservedSet.

NOTE This syntax of Uniform Resource Identifiers is based upon RFC 2396
and does not reflect the more recent RFC 3986 which replaces RFC 2396. A
formal description and implementation of UTF-8 is given in RFC 3629.

In UTF-8, characters are encoded using sequences of 1 to 6 octets. The
only octet of a "sequence" of one has the higher-order bit set to 0, the
remaining 7 bits being used to encode the character value. In a sequence
of n octets, n>1, the initial octet has the n higher-order bits set to
1, followed by a bit set to 0. The remaining bits of that octet contain
bits from the value of the character to be encoded. The following octets
all have the higher-order bit set to 1 and the following bit set to 0,
leaving 6 bits in each to contain bits from the character to be encoded.
The possible UTF-8 encodings of ECMAScript characters are specified in
Table 32.

Table 32 — UTF-8 Encodings

  ------------------- --------------------- --------------- --------------- --------------- ---------------
  _CODE UNIT VALUE_   REPRESENTATION      _1^ST^ OCTET_   _2^ND^ OCTET_   _3^RD^ OCTET_   _4^TH^ OCTET_

  0X0000 - 0X007F     00000000 0zzzzzzz   0zzzzzzz                                      

  0X0080 - 0X07FF     00000_yyy yyzzzzzz_   110yyyyy      10zzzzzz                      

  0X0800 - 0XD7FF     _xxxxyyyy yyzzzzzz_   1110xxxx      10yyyyyy      10zzzzzz      

  0XD800 - 0XDBFF     110110_vv vvwwwwxx_   11110uuu      10uuwwww      10xxyyyy      10zzzzzz
                                                                                            
  _followed by_       _followed by_                                                         
                                                                                            
  0XDC00 – 0XDFFF     110111_yy yyzzzzzz_                                                   

  0XD800 - 0XDBFF     causes URIERROR                                                     
                                                                                            
  _not followed by_                                                                         
                                                                                            
  0XDC00 – 0XDFFF                                                                           

  0XDC00 – 0XDFFF     causes URIERROR                                                     

  0XE000 - 0XFFFF     _xxxxyyyy yyzzzzzz_   1110xxxx      10yyyyyy      10zzzzzz      
  ------------------- --------------------- --------------- --------------- --------------- ---------------

Where

uuuuu = vvvv + 1

to account for the addition of 0x10000 as in Surrogates, section 3.7, of
the Unicode Standard.

The range of code unit values 0xD800-0xDFFF is used to encode surrogate
pairs; the above transformation combines a UTF-16 surrogate pair into a
UTF-32 representation and encodes the resulting 21-bit value in UTF-8.
Decoding reconstructs the surrogate pair.

RFC 3629 prohibits the decoding of invalid UTF-8 octet sequences. For
example, the invalid sequence C0 80 must not decode into the character
U+0000. Implementations of the Decode algorithm are required to throw a
URIERROR when encountering such invalid sequences.

decodeURI (encodedURI)

The DECODEURI function computes a new version of a URI in which each
escape sequence and UTF-8 encoding of the sort that might be introduced
by the ENCODEURI function is replaced with the character that it
represents. Escape sequences that could not have been introduced by
ENCODEURI are not replaced.

When the DECODEURI function is called with one argument encodedURI,
the following steps are taken:

1.  Let uriString be ToString(encodedURI).

2.  ReturnIfAbrupt(uriString).

3.  Let reservedURISet be a String containing one instance of each
    character valid in uriReserved plus “#”.

4.  Return the result of calling Decode(uriString, reservedURISet)

NOTE The character “#” is not decoded from escape sequences even though
it is not a reserved URI character.

 decodeURIComponent (encodedURIComponent)

The DECODEURICOMPONENT function computes a new version of a URI in which
each escape sequence and UTF-8 encoding of the sort that might be
introduced by the ENCODEURICOMPONENT function is replaced with the
character that it represents.

When the DECODEURICOMPONENT function is called with one argument
encodedURIComponent, the following steps are taken:

1.  Let componentString be ToString(encodedURIComponent).

2.  ReturnIfAbrupt(componentString).

3.  Let reservedURIComponentSet be the empty String.

4.  Return the result of calling Decode(componentString,
    reservedURIComponentSet)

encodeURI (uri)

The ENCODEURI function computes a new version of a URI in which each
instance of certain characters is replaced by one, two, three, or four
escape sequences representing the UTF-8 encoding of the character.

When the ENCODEURI function is called with one argument uri, the
following steps are taken:

NOTE The character “#” is not encoded to an escape sequence even though
it is not a reserved or unescaped URI character.

encodeURIComponent (uriComponent)

The ENCODEURICOMPONENT function computes a new version of a URI in which
each instance of certain characters is replaced by one, two, three, or
four escape sequences representing the UTF-8 encoding of the character.

When the ENCODEURICOMPONENT function is called with one argument
uriComponent, the following steps are taken:

1.  Let componentString be ToString(uriComponent).

2.  ReturnIfAbrupt(componentString).

3.  Let unescapedURIComponentSet be a String containing one instance
    of each character valid in uriUnescaped.

4.  Return the result of calling Encode(componentString,
    unescapedURIComponentSet)

Constructor Properties of the Global Object

Object ( . . . )

See ‎15.2.1.

Function ( . . . )

See ‎15.3.1.

Array ( . . . )

See ‎15.4.1.

String ( . . . )

See ‎15.5.1.

Boolean ( . . . )

See ‎15.6.1.

Number ( . . . )

See ‎15.7.1.

Date ( . . . )

See ‎15.9.2.

RegExp ( . . . )

See ‎15.10.3.

Error ( . . . )

See ‎15.11.1.

EvalError ( . . . )

See ‎15.11.5.1.

RangeError ( . . . )

See ‎15.11.5.2.

ReferenceError ( . . . )

See ‎15.11.5.3.

SyntaxError ( . . . )

See ‎15.11.5.4.

TypeError ( . . . )

See ‎15.11.5.5.

URIError ( . . . )

See ‎15.11.5.6.

Map ( . . . )

See ‎15.14.

WeakMap ( . . . )

See ‎15.15.

Set ( . . . )

See ‎15.16.

WeakSet ( . . . )

See ‎15.17.

ArrayBuffer ( . . . )

See ‎‎15.13.5.2.

Int8Array ( . . . )

See ‎‎‎15.13.6.4.

UInt8Array ( . . . )

See ‎‎‎15.13.6.4.

UInt8ClampedArray ( . . . )

See ‎‎‎15.13.6.4.

Int16Array ( . . . )

See ‎‎‎15.13.6.4.

UInt16Array ( . . . )

See ‎‎‎15.13.6.4.

Int32Array ( . . . )

See ‎‎‎15.13.6.4.

UInt32Array ( . . . )

See ‎‎‎15.13.6.4.

Float32Array ( . . . )

See ‎‎‎15.13.6.4.

Float64Array ( . . . )

See ‎‎‎15.13.6.4.

DataView ( . . . )

See ‎‎‎15.13.7.2.

Other Properties of the Global Object

Math

See ‎15.8.

JSON

See ‎15.12.


Object Objects

The Object Constructor Called as a Function

When OBJECT is called as a function rather than as a constructor, it
performs a type conversion.

Object ( [ value ] )

When the OBJECT function is called with no arguments or with one
argument value, the following steps are taken:

The Object Constructor

When OBJECT is called as part of a NEW expression, it is a constructor
that may create an object.

new Object ( [ value ] )

When the OBJECT constructor is called with no arguments or with one
argument value, the following steps are taken:

1.  If value is supplied, then

    a.  If Type(value) is Object, then

    b.  return value.

        i.  

    c.  If Type(value) is String, return ToObject(value).

    d.  If Type(value) is Boolean, return ToObject(value).

    e.  If Type(value) is Number, return ToObject(value).

2.  Assert: The argument value was not supplied or its type was Null
    or Undefined.

3.  4.  5.  6.  7.  8.  Return the result of the abstract operation
    ObjectCreate with the intrinsic object %ObjectPrototype% as its
    argument.

Properties of the Object Constructor

The value of the [[Prototype]] internal data property of the Object
constructor is the standard built-in Function prototype object.

Besides the LENGTH property (whose value is 1), the Object constructor
has the following properties:

Object.prototype

The initial value of OBJECT.PROTOTYPE is the standard built-in Object
prototype object (15.2.4).

This property has the attributes {[[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Object.getPrototypeOf ( O )

When the GETPROTOTYPEOF function is called with argument O, the
following steps are taken:

1.  Let obj be ToObject(O).

2.  ReturnIfAbrupt(obj).

3.  4.  Return the result of calling the [[GetInheritance]] internal
    method of obj.

Object.getOwnPropertyDescriptor ( O, P ) 

When the GETOWNPROPERTYDESCRIPTOR function is called, the following
steps are taken:

Object.getOwnPropertyNames ( O )

When the GETOWNPROPERTYNAMES function is called, the following steps are
taken:

1.  Let obj be ToObject(O).

2.  ReturnIfAbrupt(obj).

3.  4.  Let keys be the result of calling the [[OwnPropertyKeys]]
    internal method of obj.

5.  ReturnIfAbrupt(keys).

6.  Let nameList be a new empty List.

7.  Let gotAllNames be FALSE.

8.  Repeat while gotAllNames is FALSE,

    a.  Let next be the result of IteratorNext(keys).

    b.  ReturnIfAbrupt(next).

    c.  d.  Let done be IteratorComplete(next).

    e.  ReturnIfAbrupt(done).

    f.  If done is TRUE, then let gotAllNames be TRUE.

    g.  Else,

        i.  ii. iii. iv. Let nextKey be IteratorValue(next).

        v.  ReturnIfAbrupt(nextKey).

        vi. If Type(nextKey) is String, then

            1.  Append nextKey as the last element of nameList.

9.  Return CreateArrayFromList(nameList).

1.  2.  3.  4.  5.  6.  a.  b.  c.  

7.  

Object.create ( O [, Properties] )

The CREATE function creates a new object with a specified prototype.
When the CREATE function is called, the following steps are taken:

Object.defineProperty ( O, P, Attributes )

The DEFINEPROPERTY function is used to add an own property and/or update
the attributes of an existing own property of an object. When the
DEFINEPROPERTY function is called, the following steps are taken:

Object.defineProperties ( O, Properties )

The DEFINEPROPERTIES function is used to add own properties and/or
update the attributes of existing own properties of an object. When the
DEFINEPROPERTIES function is called, the following steps are taken:

1.  Return the result of the abstract operation ObjectDefineProperties
    with arguments O and Properties.

RUNTIME SEMANTICS: OBJECTDEFINEPROPERTIES ABSTRACT OPERATION

The abstract operation ObjectDefineProperties with arguments O and
Properties performs the following steps:

If an implementation defines a specific order of enumeration for the
for-in statement, that same enumeration order must be used to order the
list elements in step 3 of this algorithm.

NOTE An exception in defining an individual property in step 7 does not
terminate the process of defining other properties. All valid property
definitions are processed.

Object.seal ( O )

When the SEAL function is called, the following steps are taken:

Object.freeze ( O )

When the FREEZE function is called, the following steps are taken:

Object.preventExtensions ( O )

When the PREVENTEXTENSIONS function is called, the following steps are
taken:

Object.isSealed ( O )

When the ISSEALED function is called with argument O, the following
steps are taken:

1.  If Type(O) is not Object, return TRUE.

2.  a.  b.  

3.  4.  5.  6.  Return TestIntegrityLevel(O, "SEALED").

Object.isFrozen ( O )

When the ISFROZEN function is called with argument O, the following
steps are taken:

1.  If Type(O) is not Object, return TRUE.

2.  a.  b.  c.  i.  

    d.  

3.  4.  5.  6.  Return TestIntegrityLevel(O, "FROZEN").

Object.isExtensible ( O )

When the ISEXTENSIBLE function is called with argument O, the
following steps are taken:

Object.keys ( O )

When the KEYS function is called with argument O, the following steps
are taken:

1.  Let obj be ToObject(O).

2.  ReturnIfAbrupt(obj).

3.  4.  Let keys be the result of calling the [[OwnPropertyKeys]]
    internal method of obj.

5.  ReturnIfAbrupt(keys).

6.  Let nameList be a new empty List.

7.  Let gotAllNames be FALSE.

8.  Repeat while gotAllNames is FALSE,

    a.  Let next be the result of IteratorNext(keys).

    b.  ReturnIfAbrupt(next).

    c.  d.  Let done be IteratorComplete(next).

    e.  ReturnIfAbrupt(done).

    f.  If done is TRUE, then let gotAllNames be TRUE.

    g.  Else,

        i.  Let nextKey be IteratorValue(next).

        ii. ReturnIfAbrupt(nextKey).

        iii. iv. v.  vi. If Type(nextKey) is String, then

            1.  Let desc be the result of calling the
                [[GetOwnProperty]] internal method of O with argument
                nextKey.

            2.  ReturnIfAbrupt(desc).

            3.  If desc is not UNDEFINED and desc.[[Enumerable]] is
                TRUE, then

                a.  Append nextKey as the last element of nameList.

9.  Return CreateArrayFromList(nameList).

If an implementation defines a specific order of enumeration for the
for-in statement, the same order must be used for the elements of the
array returned in step 7.

Object.getOwnPropertyKeys ( O )

When the GETOWNPROPERTYKEYS function is called with argument O, the
following steps are taken:

1.  Let obj be ToObject(O).

2.  ReturnIfAbrupt(obj).

3.  4.  Let keys be the result of calling the [[OwnPropertyKeys]]
    internal method of obj.

5.  Return keys.

TODO :

-   May need to say something about order of enumeration and post call
    property additions and deletions

Object.is ( value1, value2 )

When the IS function is called with arguments value1 and value2 the
following steps are taken:

1.  Return SameValue(value1, value2).

1.  2.  3.  4.  a.  b.  c.  

5.  

Object.assign ( target, source )

TODO :

-   Only enumerable own properties of source

-   Invoke [[Get]] on property list derived from source, for each
    property in list [[Put]] on target

-   private names are not copied

-   unique names are copied

-   super mechanism (rebind super)

-   Returns modified "target"

Object.mixin ( target, source )

Don’t have TC39 concensus on including this or its name. Hower, there
appears to be strong interest both within TC39 and on es-disuss and
reasonable use cases. “mixin” seems to be the favorate name from
es-discuss, although concerns have been raised that it might clash with
some existing libraries.

TODO :

-   All non-private properties of source

-   Uses [[GetOwnProperty]]/[[DefineOwnProperty]]

-   private symbols are not copied

-   non-symbols are copied

-   super mechanism (rebind super)

-   Returns modified "target"

Object.setPrototypeOf ( O, proto )

When the SETPROTOTYPEOF function is called with arguments O and proto,
the following steps are taken:

1.  Let O be CheckObjectCoercible(O_)_.

2.  ReturnIfAbrupt(O).

3.  4.  If Type(proto) is neither Object or Null, then throw a
    TYPEERROR exception.

5.  If Type(O) is not Object, then return O.

6.  Let status be the result of calling the [[SetInheritance]]
    internal method of O with argument proto.

7.  ReturnIfAbrupt(status).

8.  If status is FALSE, then throw a TYPEERROR exception.

9.  Return O.

Properties of the Object Prototype Object

The Object prototype object is an ordinary object.

The value of the [[Prototype]] internal data property of the Object
prototype object is NULL and the initial value of the [[Extensible]]
internal data property is TRUE.

Object.prototype.constructor

The initial value of OBJECT.PROTOTYPE.CONSTRUCTOR is the standard
built-in OBJECT constructor.

Object.prototype.toString ( )

When the TOSTRING method is called, the following steps are taken:

  -- --
     
     
     
     
     
     
     
     
     
     
     
  -- --

NOTE Historically, this function was occasionally used to access the
string value of the [[Class]] internal data property that was used in
previous editions of this specification as a nominal type tag for
various built-in objects. The above definition of TOSTRING preserves the
ability to use it as a reliable test for those specific kinds of
built-in objects but it does not provide a reliable type testing
mechanism for other kinds of built-in or program defined objects.

Object.prototype.toLocaleString ( )

When the TOLOCALESTRING method is called, the following steps are taken:

1.  Let O be the THIS value.

2.  3.  4.  5.  Return the result of Invoke(O, "TOSTRING").

NOTE 1 This function is provided to give all Objects a generic
TOLOCALESTRING interface, even though not all may use it. Currently,
ARRAY, NUMBER, and DATE provide their own locale-sensitive
TOLOCALESTRING methods.

NOTE 2 The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that implementations
do not use this parameter position for anything else.

Object.prototype.valueOf ( )

When the VALUEOF method is called, the following steps are taken:

Object.prototype.hasOwnProperty (V)

When the HASOWNPROPERTY method is called with argument V, the
following steps are taken:

NOTE The ordering of steps 1 and 3 is chosen to ensure that any
exception that would have been thrown by step 1 in previous editions of
this specification will continue to be thrown even if the THIS value is
UNDEFINED or NULL.

Object.prototype.isPrototypeOf (V)

When the ISPROTOTYPEOF method is called with argument V, the following
steps are taken:

1.  If V is not an object, return FALSE.

2.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

3.  ReturnIfAbrupt(O).

4.  Repeat

    a.  Let V be the result of calling the [[GetInheritance]] internal
        method of V with no arguments.

    b.  if V is NULL, return FALSE

    c.  If SameValue(O, V) is TRUE, then return TRUE.

NOTE The ordering of steps 1 and 2 is chosen to preserve the behaviour
specified by previous editions of this specification for the case where
V is not an object and the THIS value is UNDEFINED or null.

Object.prototype.propertyIsEnumerable (V)

When the PROPERTYISENUMERABLE method is called with argument V, the
following steps are taken:

1.  Let P be ToString(V).

2.  ReturnIfAbrupt(P).

3.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

4.  ReturnIfAbrupt(O).

5.  Let desc be the result of calling the [[GetOwnProperty]] internal
    method of O passing P as the argument.

6.  If desc is UNDEFINED, return FALSE.

7.  Return the value of desc.[[Enumerable]].

NOTE 1 This method does not consider objects in the prototype chain.

NOTE 2 The ordering of steps 1 and 2 is chosen to ensure that any
exception that would have been thrown by step 1 in previous editions of
this specification will continue to be thrown even if the THIS value is
UNDEFINED or NULL.

Properties of Object Instances

Object instances have no special properties beyond those inherited from
the Object prototype object.


Function Objects

The Function Constructor

The Function constructor is the %Function% intrinsic object and the
initial value of the FUNCTION property of the global object. When
FUNCTION is called as a function rather than as a constructor, it
creates and initialises a new Function object. Thus the function call
FUNCTION(…) is equivalent to the object creation expression NEW
FUNCTION(…) with the same arguments. However, if the THIS value value
passed in the call is an Object with an [[Code]] internal data property
whose value is UNDEFINED, it initialises the THIS value using the
argument values. This permits FUNCTION to be used both as factory method
and to perform constructor instance initialization.

FUNCTION may be subclassed and subclass constructors may perform a SUPER
invocation of the FUNCTION constructor to initialise subclass instances.
However, all syntactic forms for defining function objects create
instances of FUNCTION. There is no syntactic means to create instances
of FUNCTION subclasses except for the built-in Generator Function
subclass.

Function (p1, p2, … , pn, body)

The last argument specifies the body (executable code) of a function;
any preceding arguments specify formal parameters.

When the FUNCTION function is called with some arguments p1, p2, … ,
pn, body (where n might be 0, that is, there are no “p”
arguments, and where body might also not be provided), the following
steps are taken:

A PROTOTYPE property is automatically created for every function created
using the FUNCTION constructor, to provide for the possibility that the
function will be used as a constructor.

NOTE It is permissible but not necessary to have one argument for each
formal parameter to be specified. For example, all three of the
following expressions produce the same result:

  new Function("a", "b", "c", "return a+b+c")

  new Function("a, b, c", "return a+b+c")

  new Function("a,b", "c", "return a+b+c")

new Function ( ... argumentsList)

When FUNCTION is called as part of a NEW expression, it initialises the
newly created object.

1.  Let F be the FUNCTION function object on which the NEW operator
    was applied.

2.  Let argumentsList be the argumentsList argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of OrdinaryConstruct (F, argumentsList).

If FUNCTION is implemented as an ordinary function object, its
[[Construct]] internal method will perform the above steps.

Properties of the Function Constructor

The Function constructor is itself a built-in Function object. The value
of the [[Prototype]] internal data property of the Function constructor
is %FunctionPrototype%, the intrinsic Function prototype object
(15.3.3).

The value of the [[Extensible]] internal data property of the Function
constructor is TRUE.

The Function constructor has the following properties:

Function.prototype

The value of FUNCTION.PROTOTYPE is %FunctionPrototype%, the intrinsic
Function prototype object (15.3.3).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Function.length

This is a data property with a value of 1. This property has the
attributes { [[Writable]]: FALSE, [[Enumerable]]: FALSE,
[[Configurable]]: TRUE }.

Function[ @@create ] ( )

The @@create method of an object F performs the following steps:

1.  Let F be the THIS value.

2.  Let proto be the result of GetPrototypeFromConstructor(F,
    "%FUNCTIONPROTOTYPE%").

3.  ReturnIfAbrupt(proto).

4.  Let obj be the result of calling FunctionAllocate with argument
    proto.

5.  Return obj.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

NOTE The Function @@CREATE function is intentionally generic; it does
not require that its THIS value be the Function constructor object. It
can be transferred to other constructor functions for use as a @@CREATE
method. When used with other constructors, this function will create an
exotic function object whose [[Prototype]] value is obtained from the
associated constructor.

Properties of the Function Prototype Object

The Function prototype object is itself a Built-in Function object. When
invoked, it accepts any arguments and returns UNDEFINED.

NOTE The Function prototype object is specified to be a function object
to ensure compatability with ECMAScript code that was created prior to
the 6^th^ Edition of this specification.

The value of the [[Prototype]] internal data property of the Function
prototype object is the intrinsic object %ObjectPrototype% (15.2.4). The
initial value of the [[Extensible]] internal data property of the
Function prototype object is TRUE.

The function prototype object does not have a PROTOTYPE property.

The LENGTH property of the Function prototype object is 0.

Function.prototype.constructor

The initial value of FUNCTION.PROTOTYPE.CONSTRUCTOR is the intrinsic
object %Function%.

 Function.prototype.toString ( )

An implementation-dependent String source code representation of the
THIS object is returned. This representation has the syntax of a
FunctionDeclaration FunctionExpression, _GeneratorDeclaration,
GeneratorExpession, ClassDeclaration_, ClassExpression,
ArrowFunction, MethodDefinition, or GeneratorMethod depending upon
the actual characteristics of the object. In particular that the use and
placement of white space, line terminators, and semicolons within the
representation String is implementation-dependent.

If the object was defined using ECMAScript code and the returned string
representation is in the form of a FunctionDeclaration
FunctionExpression, _GeneratorDeclaration, GeneratorExpession,
ClassDeclaration_, ClassExpression, or ArrowFunction then the
representation must be such that if the string is evaluated, using EVAL
in a lexical context that is equivalent to the lexical context used to
create the original object, it will result in a new functionally
equivalent object. The returned source code must not mention freely any
variables that were not mentioned freely by the original function’s
source code, even if these “extra” names were originally in scope. If
the source code string does meet these criteria then it must be a string
for which EVAL will throw a SYNTAXERROR exception.

The TOSTRING function is not generic; it throws a TYPEERROR exception if
its THIS value is not a does not have a [[Call]] internal method.
Therefore, it cannot be transferred to other kinds of objects for use as
a method.

Function.prototype.apply (thisArg, argArray)

When the APPLY method is called on an object func with arguments
thisArg and argArray, the following steps are taken:

1.  If IsCallable(func) is FALSE, then throw a TYPEERROR exception.

2.  If argArray is NULL or UNDEFINED, then

    a.  Return the result of calling the [[Call]] internal method of
          func, providing thisArg as thisArgument and an empty
          List of arguments as argumentsList.

3.  4.  5.  6.  7.  Let argList be the result of
    CreateListFromArrayLike(argArray).

8.  ReturnIfAbrupt(argList ).

9.  10. a.  b.  c.  d.  e.  

11. Return the result of calling the [[Call]] internal method of func,
    providing thisArg as thisArgument and argList as
    argumentsList.

The LENGTH property of the APPLY method is 2.

NOTE The thisArg value is passed without modification as the THIS value.
This is a change from Edition 3, where a UNDEFINED or NULL thisArg is
replaced with the global object and ToObject is applied to all other
values and that result is passed as the THIS value.

Function.prototype.call (thisArg [ , arg1 [ , arg2, … ] ] )

When the CALL method is called on an object func with argument
thisArg and optional arguments arg1, arg2 etc, the following steps
are taken:

1.  If IsCallable(func) is FALSE, then throw a TYPEERROR exception.

2.  Let argList be an empty List.

3.  If this method was called with more than one argument then in left
    to right order starting with arg1 append each argument as the last
    element of argList

4.  Return the result of calling the [[Call]] internal method of func,
    providing thisArg as thisArgument and argList as
    argumentsList.

The LENGTH property of the CALL method is 1.

NOTE The thisArg value is passed without modification as the THIS value.
This is a change from Edition 3, where a UNDEFINED or NULL thisArg is
replaced with the global object and ToObject is applied to all other
values and that result is passed as the THIS value.

Function.prototype.bind (thisArg [, arg1 [, arg2, …]])

The bind method takes one or more arguments, thisArg and (optionally)
arg1, arg2, etc, and returns a new function object by performing the
following steps:

The LENGTH property of the BIND method is 1.

NOTE Function objects created using FUNCTION.PROTOTYPE.BIND are exotic
objects. They also do not have a PROTOTYPE property.

Function.prototype[ @@create ] ( )

The @@create method of an object F performs the following steps:

1.  Return the result of calling OrdinaryCreateFromConstructor(F,
    "%OBJECTPROTOTYPE%").

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

NOTE This is the default @@create method that is inherited by all
ordinary constructor functions that do not explicitly over-ride it.

Function.prototype[@@hasInstance] (V)

When the @@hasInstance method of an object F is called with value V,
the following steps are taken:

1.  Let F be the THIS value.

2.  Return the result of OrdinaryHasInstance(F, V).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

NOTE This is the default implementation of @@HASINSTANCE that most
functions inherit. @@HASINSTANCE is called by the INSTANCEOF operator to
deterimine whether a value is an instance of a specific constructor. An
expression such as

V INSTANCEOF F

evaluates as

F[@@HASINSTANCE](V)

A constructor function can control which objects are recoginze as its
instances by INSTANCEOF by exposing a different @@HASINSTANCE method on
the function.

This property is non-writable and non-configurable to prevent tampering
that could be used to globally expose the target function of a bound
function.

Function Instances

Every function instance is an ordinary function object and has the
internal data properties listed in Table 13.

Function instances that correspond to strict mode functions and function
instances created using the FUNCTION.PROTOTYPE.BIND METHOD (15.3.3.5)
have properties named CALLER and ARGUMENTS that throw a TYPEERROR
exception. An ECMAScript implementation must not associate any
implementation specific behaviour with accesses of these properties from
strict mode function code.

The Function instances have the following properties:

length

The value of the LENGTH property is an integer that indicates the
typical number of arguments expected by the function. However, the
language permits the function to be invoked with some other number of
arguments. The behaviour of a function when invoked on a number of
arguments other than the number specified by its LENGTH property depends
on the function. This property has the attributes { [[Writable]]: FALSE,
[[Enumerable]]: FALSE, [[Configurable]]: TRUE }.

prototype

Function instances that can be used used as a constructor have a
PROTOTYPE property. Whenever such a function instance is created another
ordinary object is also created and is the initial value of the
function’s PROTOTYPE property. Unless otherwise specified, the value of
the prototype property is used to initialise the [[Prototype]] internal
data property of a newly created ordinay object before the Function
object is invoked as a constructor for that newly created object.

This property has the attributes { [[Writable]]: TRUE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

NOTE Function objects created using FUNCTION.PROTOTYPE.BIND, or by
evaluating a MethodDefinition (that is not a GeneratorMethod) or an
ArrowFunction grammar production do not have a PROTOTYPE property.


Array Objects

1.  2.  3.  4.  5.  a.  b.  

6.  

Array objects are exotic objects that give special treatment to a
certain class of property names. See ‎8.4.2 for a definition of this
special treatment.

An Array object, O, is said to be sparse if the following algorithm
returns TRUE:

1.  Let len be the result of Get(O, "LENGTH").

2.  For each integer i in the range 0≤i_<ToUint32(_len)

    a.  Let elem be the result of calling the [[GetOwnProperty]]
        internal method of O with argument ToString(i).

    b.  If elem is UNDEFINED, return TRUE.

3.  Return FALSE.

The Array Constructor

The Array constructor is the %Array% intrinsic object and the initial
value of the ARRAY property of the global object. When ARRAY is called
as a function rather than as a constructor, it creates and initialises a
new Array object. Thus the function call ARRAY(…) is equivalent to the
object creation expression NEW ARRAY(…) with the same arguments.

However, if the THIS value value passed in the call is an Object with an
[[ArrayInitialisationState]] internal data property whose value is
UNDEFINED, it initialises the THIS value using the argument values. This
permits ARRAY to be used both as factory method and to perform
constructor instance initialization.

The ARRAY constructor is designed to be subclassable. It may be used as
the value of an EXTENDS clause of a class declaration. Subclass
constructors that intended to inherit the specified ARRAY behaviour must
include a SUPER call to the ARRAY constructor to initialise subclass
instances.

Array ( [ item1 [ , item2 [ , … ] ] ] )

This description applies if and only if the Array constructor is called
with no arguments or at least two arguments.

When the ARRAY function is called the following steps are taken:

1.  

Array (len)

This description applies if and only if the Array constructor is called
with exactly one argument.

1.  Let numberOfArgs be the number of arguments passed to this
    constructor call.

2.  Assert: numberOfArgs = 1.

3.  Let O be the THIS value.

4.  If Type(O) is Object and O has an [[ArrayInitialisationState]]
    internal data property and the value of [[ArrayInitialisationState]]
    is FALSE, then

    a.  Set the value of O’s [[ArrayInitialisationState]] internal
        data property to TRUE.

    b.  Let array be O.

5.  Else,

    a.  Let F be this function.

    b.  Let proto be the result of GetPrototypeFromConstructor(F,
        "%ARRAYPROTOTYPE%").

    c.  ReturnIfAbrupt(proto).

    d.  Let array be the result of ArrayCreate(0, proto).

6.  ReturnIfAbrupt(array).

7.  If Type(len) is not Number, then

    a.  b.  c.  Let defineStatus be the result of
        DefinePropertyOrThrow(array, "0", Property Descriptor
        {[[Value]]: len, [[Writable]]: TRUE, [[Enumerable]]: TRUE,
        [[Configurable]]: TRUE}).

    d.  ReturnIfAbrupt(defineStatus).

    e.  Let intLen be 1.

8.  Else,

    a.  Let intLen be ToUint32(len).

    b.  If intLen ≠ len, then throw a RANGEERROR exception.

9.  Let putStatus be the result of Put(array, "LENGTH", intLen,
    TRUE).

10. ReturnIfAbrupt(putStatus).

11. 12. Return array.

new Array ( ... argumentsList)

When ARRAY is called as part of a NEW expression, it initialises a newly
created object.

1.  Let F be the ARRAY function object on which the NEW operator was
    applied.

2.  Let argumentsList be the argumentsList argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of OrdinaryConstruct (F, argumentsList).

If ARRAY is implemented as an ordinary function object, its
[[Construct]] internal method will perform the above steps.

Properties of the Array Constructor

The value of the [[Prototype]] internal data property of the Array
constructor is the Function prototype object (‎15.3.3).

Besides the LENGTH property (whose value is 1), the Array constructor
has the following properties:

Array.prototype

The value of ARRAY.PROTOTYPE is %ArrayPrototype%, the intrinsic Array
prototype object (15.4.3).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Array.isArray ( arg )

The ISARRAY function takes one argument arg, and performs the
following:

1.  If Type(arg) is not Object, return FALSE.

2.  If arg is an exotic Array object, then return TRUE.

3.  Return FALSE.

Array.of ( ...items )

When the OF method is called with any number of arguments, the following
steps are taken:

1.  Let lenValue be the result of Get(items, "LENGTH").

2.  Let len be ToInteger(lenValue).

3.  Let C be the THIS value.

4.  If IsConstructor(C) is TRUE, then

    a.  Let newObj be the result of calling the [[Construct]] internal
        method of C with an argument list containing the single item
        len.

    b.  

5.  Else,

    a.  Let A be the result of the abstract operation ArrayCreate with
        argument len.

6.  ReturnIfAbrupt(A).

7.  Let k be 0.

8.  Repeat, while k < len

    a.  Let Pk be ToString(k).

    b.  Let kValue be the result of Get(items, Pk).

    c.  Let defineStatus be the result of
        DefinePropertyOrThrow(A_,_Pk, Property Descriptor {[[Value]]:
        kValue.[[value]], [[Writable]]: TRUE, [[Enumerable]]: TRUE,
        [[Configurable]]: TRUE}).

    d.  ReturnIfAbrupt(defineStatus).

    e.  Increase k by 1.

9.  Let putStatus be the result of Put(A, "LENGTH", len, TRUE).

10. ReturnIfAbrupt(putStatus).

11. Return A.

The LENGTH property of the OF method is 0.

NOTE 1 The items argument is assumed to be a well-formed rest argument
value.

NOTE 2 The OF function is an intentionally generic factory method; it
does not require that its THIS value be the Array constructor. Therefore
it can be transferred to or inherited by other constructors that may be
called with a single numeric argument.

Array.from ( arrayLike , mapfn=undefined, thisArg=undefined )

When the FROM method is called with argument arrayLike and optional
arguments mapfn and thisArg the following steps are taken:

1.  Let C be the THIS value.

2.  Let items be ToObject(arrayLike).

3.  ReturnIfAbrupt(items).

4.  If mapfn is UNDEFINED, then let mapping be FALSE.

5.  else

    a.  If IsCallable(mapfn) is FALSE, throw a TYPEERROR exception.

    b.  If thisArg was supplied, let T be thisArg; else let T be
        UNDEFINED.

    c.  Let mapping be TRUE

6.  Let usingIterator be the result of HasProperty(items,
    @@Iterator).

7.  ReturnIfAbrupt(usingIterator).

8.  If usingIterator is TRUE, then

    a.  Let iterator be the result of performing GetIterator(items).

    b.  ReturnIfAbrupt(iterator).

    c.  If IsConstructor(C) is TRUE, then

        i.  Let newObj be the result of calling the [[Construct]]
            internal method of C with an empty argument list.

        ii. 

    d.  Else,

        i.  Let A be the result of the abstract operation ArrayCreate
            with argument 0.

    e.  ReturnIfAbrupt(A).

    f.  g.  Let k be 0.

    h.  Repeat

        i.  Let Pk be ToString(k).

        ii. Let next be the result of IteratorNext(iterator).

        iii. ReturnIfAbrupt(next).

        iv. Let done be IteratorComplete(next).

        v.  ReturnIfAbrupt(done).

        vi. If done is TRUE, then

            1.  Let putStatus be the result of Put(A, "LENGTH", k,
                TRUE).

            2.  ReturnIfAbrupt(putStatus).

            3.  Return A.

        vii. Let nextValue be IteratorValue(next).

        viii. ReturnIfAbrupt(nextValue).

        ix. If mapping is TRUE, then

            1.  Let mappedValue be the result of calling the [[Call]]
                internal method of mapfn with T as thisArgument
                and a List containing nextValue as argumentsList.

            2.  ReturnIfAbrupt(mappedValue).

        x.  Else, let mappedValue be nextValue.

        xi. Let defineStatus be the result of
            DefinePropertyOrThrow(A, Pk, Property Descriptor
            {[[Value]]: mappedValue, [[Writable]]: TRUE,
            [[Enumerable]]: TRUE, [[Configurable]]: TRUE}).

        xii. ReturnIfAbrupt(defineStatus).

        xiii. Increase k by 1.

9.  Assert: items is not an Iterator so assume it is Array-like.

10. Let lenValue be the result of Get(items, "LENGTH").

11. Let len be ToInteger(lenValue).

12. ReturnIfAbrupt(len).

13. 14. If IsConstructor(C) is TRUE, then

    a.  Let newObj be the result of calling the [[Construct]] internal
        method of C with an argument list containing the single item
        len.

    b.  Let A be ToObject(newObj).

15. Else,

    a.  Let A be the result of the abstract operation ArrayCreate with
        argument len.

16. ReturnIfAbrupt(A).

17. Let k be 0.

18. Repeat, while k < len

    a.  Let Pk be ToString(k).

    b.  Let kPresent be the result of HasProperty(items, Pk).

    c.  ReturnIfAbrupt(kPresent).

    d.  If kPresent is TRUE, then

        i.  Let kValue be the result of Get(items, Pk).

        ii. ReturnIfAbrupt(kValue).

        iii. If mapping is TRUE, then

            1.  Let mappedValue be the result of calling the [[Call]]
                internal method of mapfn with T as thisArgument
                and a List containing kValue, k, and items as
                argumentsList.

            2.  ReturnIfAbrupt(mappedValue).

        iv. Else, let mappedValue be kValue.

        v.  Let defineStatus be the result of
            DefinePropertyOrThrow(A, Pk Property Descriptor
            {[[Value]]: mappedValue, [[Writable]]: TRUE,
            [[Enumerable]]: TRUE, [[Configurable]]: TRUE}).

        vi. ReturnIfAbrupt(defineStatus).

    e.  Increase k by 1.

19. Let putStatus be the result of Put(A, "LENGTH", len, TRUE).

20. ReturnIfAbrupt(putStatus).

21. Return A.

NOTE The FROM function is an intentionally generic factory method; it
does not require that its THIS value be the Array constructor. Therefore
it can be transferred to or inherited by any other constructors that may
be called with a single numeric argument.

Array[ @@create ] ( )

The @@create method of an object F performs the following steps:

1.  Let F be the THIS value.

2.  Let proto be the result of GetPrototypeFromConstructor(F,
    "%ARRAYPROTOTYPE%").

3.  ReturnIfAbrupt(proto).

4.  Let obj be the result of calling ArrayCreate with arguments
    UNDEFINED and proto.

5.  Return obj.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

NOTE 1 Passing UNDEFINED as the first argument to ArrayCreate causes the
[[ArrayInitialisationState]] internal data property of the array to be
initially assigned the value FALSE. This is a flag used to indicate that
the instance has not yet been initialised by the ARRAY constructor. This
flag value is never directly exposed to ECMAScript code; hence
implementation may choose to encode the flag in any unobservable manner.

NOTE 2 The Array @@CREATE function is intentionally generic; it does not
require that its THIS value be the Array constructor object. It can be
transferred to other constructor functions for use as a @@CREATE method.
When used with other constructors, this function will create an exotic
Array object whose [[Prototype]] value is obtained from the associated
constructor.

Properties of the Array Prototype Object

The value of the [[Prototype]] internal data property of the Array
prototype object is the intrinsic object %ObjectPrototype%.

The Array prototype object is itself an ordinary object. It is not an
Array instance and does not have a LENGTH property .

NOTE The Array prototype object does not have a VALUEOF property of its
own; however, it inherits the VALUEOF property from the standard
built-in Object prototype Object.

Array.prototype.constructor

The initial value of ARRAY.PROTOTYPE.CONSTRUCTOR is the standard
built-in ARRAY constructor.

Array.prototype.toString ( )

When the TOSTRING method is called, the following steps are taken:

1.  Let array be the result of calling ToObject on the THIS value.

2.  ReturnIfAbrupt(array).

3.  Let func be the result of Get(array, "JOIN").

4.  ReturnIfAbrupt(func).

5.  If IsCallable(func) is FALSE, then let func be the standard
    built-in method Object.prototype.toString (15.2.4.2).

6.  Return the result of calling the [[Call]] internal method of func
    providing array as thisArgument and an empty List as
    argumentsList.

NOTE The TOSTRING function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the TOSTRING
function can be applied successfully to an exotic object that is not an
Array is implementation-dependent.

Array.prototype.toLocaleString ( )

The elements of the array are converted to Strings using their
TOLOCALESTRING methods, and these Strings are then concatenated,
separated by occurrences of a separator String that has been derived in
an implementation-defined locale-specific way. The result of calling
this function is intended to be analogous to the result of TOSTRING,
except that the result of this function is intended to be
locale-specific.

The result is calculated as follows:

1.  Let array be the result of calling ToObject passing the THIS value
    as the argument.

2.  ReturnIfAbrupt(array).

3.  Let arrayLen be the result of Get(array, "LENGTH").

4.  Let len be ToLength(arrayLen).

5.  ReturnIfAbrupt(len).

6.  Let separator be the String value for the list-separator String
    appropriate for the host environment’s current locale (this is
    derived in an implementation-defined way).

7.  If len is zero, return the empty String.

8.  Let firstElement be the result of Get(array, "0").

9.  10. ReturnIfAbrupt(firstElement).

11. If firstElement is UNDEFINED or NULL, then

    a.  Let R be the empty String.

12. Else

    a.  b.  c.  d.  Let R be the result of Invoke(firstElement,
        "TOLOCALESTRING").

    e.  Let R be ToString(R).

    f.  ReturnIfAbrupt(R).

13. Let k be 1.

14. Repeat, while k < len

    a.  Let S be a String value produced by concatenating R and
        separator.

    b.  Let nextElement be the result of Get(array_,ToString(_k)).

    c.  ReturnIfAbrupt(nextElement).

    d.  If nextElement is UNDEFINED or NULL, then

        i.  Let R be the empty String.

    e.  Else

        i.  ii. Let R be the result of Invoke(nextElement,
            "TOLOCALESTRING").

        iii. Let R be ToString(R).

        iv. ReturnIfAbrupt(R).

        v.  vi. vii. 

    f.  Let R be a String value produced by concatenating S and R.

    g.  Increase k by 1.

15. Return R.

NOTE 1 The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that implementations
do not use this parameter position for anything else.

NOTE 2 The TOLOCALESTRING function is intentionally generic; it does not
require that its THIS value be an Array object. Therefore it can be
transferred to other kinds of objects for use as a method. Whether the
TOLOCALESTRING function can be applied successfully to an exotic object
that is not an Array is implementation-dependent.

Array.prototype.concat ( [ item1 [ , item2 [ , … ] ] ] )

When the CONCAT method is called with zero or more arguments item1,
item2, etc., it returns an array containing the array elements of the
object followed by the array elements of each argument in order.

The following steps are taken:

1.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(O).

3.  4.  Let A be UNDEFINED.

5.  If O is an exotic Array object, then

    a.  Let C be Get(O, "CONSTRUCTOR").

    b.  ReturnIfAbrupt(C).

    c.  If IsConstructor(C) is TRUE, then

        i.  Let A be the result of OrdinaryConstruct(C, (0)).

        ii. 

6.  If A is UNDEFINED, then

    a.  Let A be the result of the abstract operation ArrayCreate with
        argument 0.

7.  ReturnIfAbrupt(A).

8.  Let n be 0.

9.  10. 11. Let items be an internal List whose first element is O
    and whose subsequent elements are, in left to right order, the
    arguments that were passed to this function invocation.

12. Repeat, while items is not empty

    a.  Remove the first element from items and let E be the value
        of the element.

    b.  Let spreadable be the result of IsConcatSpreadable(E).

    c.  ReturnIfAbrupt(spreadable).

    d.  If spreadable is TRUE, then

        i.  Let k be 0.

        ii. Let lenVal be the result of Get(E, "LENGTH").

        iii. Let len be ToLength(lenVal).

        iv. ReturnIfAbrupt(len).

        v.  Repeat, while k < len

            1.  Let P be ToString(k).

            2.  Let exists be the result of HasProperty(E, P).

            3.  ReturnIfAbrupt(exists).

            4.  If exists is TRUE, then

                a.  Let subElement be the result of Get(E, P).

                b.  Call the [[DefineOwnProperty]] internal method of
                    A with arguments ToString(n) and Property
                    Descriptor {[[Value]]: subElement, [[Writable]]:
                    TRUE, [[Enumerable]]: TRUE, [[Configurable]]: TRUE}.

            5.  Increase n by 1.

            6.  Increase k by 1.

    e.  Else E is added as a single item rather than spread,

        i.  Call the [[DefineOwnProperty]] internal method of A with
            arguments ToString(n) and Property Descriptor {[[Value]]:
            E, [[Writable]]: TRUE, [[Enumerable]]: TRUE,
            [[Configurable]]: TRUE}.

        ii. Increase n by 1.

13. Let putStatus be the result of Put(A, "LENGTH", n, TRUE).

14. ReturnIfAbrupt(putStatus).

15. Return A.

The LENGTH property of the CONCAT method is 1.

NOTE 1 The explicit setting of the LENGTH property in step 9 is
necessary to ensure that its value is correct in situations where the
trailing elements of the result Array are not present.

NOTE 2 The CONCAT function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the CONCAT
function can be applied successfully to an exotic object that is not an
Array is implementation-dependent.

IsConcatSpreadable ( O ) Abstract Operation

The abstract operation IsConcatSpreadable with argument O performs the
following steps:

1.  ReturnIfAbrupt(O).

2.  If Type(O) is not Object, then throw a TYPEERROR exception.

3.  Let spreadable be Get(O, @@isConcatSpreadable).

4.  ReturnIfAbrupt(spreadable).

5.  If spreadable is not UNDEFINED, then return
    ToBoolean(spreadable).

6.  If O is an exotic Array object, then return TRUE.

7.  Return FALSE.

Array.prototype.join (separator)

The elements of the array are converted to Strings, and these Strings
are then concatenated, separated by occurrences of the separator. If
no separator is provided, a single comma is used as the separator.

The JOIN method takes one argument, separator, and performs the
following steps:

1.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(O).

3.  Let lenVal be the result of Get(O, "LENGTH").

4.  Let len be ToLength(lenVal).

5.  ReturnIfAbrupt(len).

6.  If separator is UNDEFINED, let separator be the single-character
    String ",".

7.  Let sep be ToString(separator).

8.  If len is zero, return the empty String.

9.  Let element0 be the result of Get(O, "0").

10. If element0 is UNDEFINED or NULL, let R be the empty String;
    otherwise, let R be ToString(element0).

11. ReturnIfAbrupt(R).

12. Let k be 1.

13. Repeat, while k < len

    a.  Let S be the String value produced by concatenating R and
        sep.

    b.  Let element be the result of Get(O, ToString(k)).

    c.  If element is UNDEFINED or NULL, then let next be the empty
        String; otherwise, let next be ToString(element).

    d.  ReturnIfAbrupt(next).

    e.  Let R be a String value produced by concatenating S and
        next.

    f.  Increase k by 1.

14. Return R.

The LENGTH property of the JOIN method is 1.

NOTE The JOIN function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore, it can be transferred
to other kinds of objects for use as a method. Whether the JOIN function
can be applied successfully to an exotic object that is not an Array is
implementation-dependent.

Array.prototype.pop ( )

The last element of the array is removed from the array and returned.

NOTE The POP function is intentionally generic; it does not require that
its THIS value be an Array object. Therefore it can be transferred to
other kinds of objects for use as a method. Whether the POP function can
be applied successfully to an exotic object that is not an Array is
implementation-dependent.

Array.prototype.push ( [ item1 [ , item2 [ , … ] ] ] )

The arguments are appended to the end of the array, in the order in
which they appear. The new length of the array is returned as the result
of the call.

When the PUSH method is called with zero or more arguments item1,
item2, etc., the following steps are taken:

The LENGTH property of the PUSH method is 1.

NOTE The PUSH function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the PUSH function
can be applied successfully to an exotic object that is not an Array is
implementation-dependent.

Array.prototype.reverse ( )

The elements of the array are rearranged so as to reverse their order.
The object is returned as the result of the call.

NOTE The REVERSE function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore, it can be transferred
to other kinds of objects for use as a method. Whether the REVERSE
function can be applied successfully to an exotic object that is not an
Array is implementation-dependent.

Array.prototype.shift ( )

The first element of the array is removed from the array and returned.

1.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(O).

3.  Let lenVal be the result of Get(O, "LENGTH").

4.  Let len be ToLength(lenVal).

5.  ReturnIfAbrupt(len).

6.  If len is zero, then

    a.  Let putStatus be the result of Put(O, "LENGTH", 0, TRUE).

    b.  ReturnIfAbrupt(putStatus).

    c.  Return UNDEFINED.

7.  Let first be the result of Get(O, "0").

8.  ReturnIfAbrupt(first).

9.  Let k be 1.

10. Repeat, while k < len

    a.  Let from be ToString(k).

    b.  Let to be ToString(k–1).

    c.  Let fromPresent be the result of HasProperty(O, from).

    d.  ReturnIfAbrupt(fromPresent).

    e.  If fromPresent is TRUE, then

        i.  Let fromVal be the result of Get(O, from).

        ii. ReturnIfAbrupt(fromVal).

        iii. Let putStatus be the result of Put(O, to, fromVal,
            TRUE).

        iv. ReturnIfAbrupt(putStatus).

    f.  Else fromPresent is FALSE,

        i.  Let deleteStatus be the result of
            DeletePropertyOrThrow(O, to).

        ii. ReturnIfAbrupt(deleteStatus).

    g.  Increase k by 1.

11. Let deleteStatus be the result of DeletePropertyOrThrow(O,
    ToString(len–1)).

12. ReturnIfAbrupt(deleteStatus).

13. Let putStatus be the result of Put(O, "LENGTH", len–1, TRUE).

14. ReturnIfAbrupt(putStatus).

15. Return first.

NOTE The SHIFT function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the SHIFT
function can be applied successfully to an exotic object that is not an
Array is implementation-dependent.

Array.prototype.slice (start, end)

The SLICE method takes two arguments, start and end, and returns an
array containing the elements of the array from element start up to,
but not including, element end (or through the end of the array if
end is UNDEFINED). If start is negative, it is treated as
length_+_start where length is the length of the array. If end is
negative, it is treated as length_+_end where length is the length
of the array. The following steps are taken:

The LENGTH property of the SLICE method is 2.

NOTE 1 The explicit setting of the LENGTH property of the result Array
in step 15 is necessary to ensure that its value is correct in
situations where the trailing elements of the result Array are not
present.

NOTE 2 The SLICE function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the SLICE
function can be applied successfully to an exotic object that is not an
Array is implementation-dependent.

Array.prototype.sort (comparefn)

The elements of this array are sorted. The sort is not necessarily
stable (that is, elements that compare equal do not necessarily remain
in their original order). If comparefn is not UNDEFINED, it should be
a function that accepts two arguments x and y and returns a negative
value if x < y, zero if x = y, or a positive value if x > y.

Let obj be the result of calling ToObject passing the THIS value as
the argument.

Let len be the result of applying Uint32 to the result of Get(obj,
"LENGTH").

If comparefn is not UNDEFINED and is not a consistent comparison
function for the elements of this array (see below), the behaviour of
SORT is implementation-defined.

Let proto be the result of calling the [[GetInheritance]] internal
method of obj. If proto is not NULL and there exists an integer j
such that all of the conditions below are satisfied then the behaviour
of SORT is implementation-defined:

-   obj is sparse (15.4)

-   0 ≤ j < len

-   The result of HasProperty(proto, ToString(j)) is TRUE.

The behaviour of SORT is also implementation defined if obj is sparse
and any of the following conditions are true:

-   The result of the predicate IsExtensible(obj) is FALSE.

-   Any array index property of obj whose name is a nonnegative
    integer less than len is a data property whose [[Configurable]]
    attribute is FALSE.

The behaviour of SORT is also implementation defined if any array index
property of obj whose name is a nonnegative integer less than len is
an accessor property or is a data property whose [[Writable]] attribute
is FALSE.

Otherwise, the following steps are taken.

The returned object must have the following two properties.

-   There must be some mathematical permutation π of the nonnegative
    integers less than len, such that for every nonnegative integer
    j less than len, if property old[j] existed, then new[π(j)]
    is exactly the same value as old[j],. But if property old[j] did
    not exist, then new[π(j)] does not exist.

-   Then for all nonnegative integers j and k, each less than len,
    if SortCompare(j_,_k) < 0 (see SortCompare below), then Π(j) <
    Π(k).

Here the notation old[j] is used to refer to the hypothetical result
of calling the [[Get]] internal method of obj with argument j before
this function is executed, and the notation new[j] to refer to the
hypothetical result of calling the [[Get]] internal method of obj with
argument j after this function has been executed.

A function comparefn is a consistent comparison function for a set of
values S if all of the requirements below are met for all values a,
b, and c (possibly the same value) in the set S: The notation
a_ <~CF~ _b means comparefn_(_a_,_b) < 0; a_ =~CF~ _b means
comparefn_(_a_,_b) = 0 (of either sign); and a_ >~CF~ _b means
comparefn_(_a_,_b) > 0.

-   Calling comparefn_(_a_,_b) always returns the same value v when
    given a specific pair of values a and b as its two arguments.
    Furthermore, Type(v) is Number, and v is not NaN. Note that this
    implies that exactly one of a_ <~CF~ _b, a_ =~CF~ _b, and
    a_ >~CF~ _b will be true for a given pair of a and b.

-   Calling comparefn_(_a_,_b) does not modify obj.

-   a_ =~CF~ _a (reflexivity)

-   If a_ =~CF~ _b, then b_ =~CF~ _a (symmetry)

-   If a_ =~CF~ _b and b_ =~CF~ _c, then a_ =~CF~ _c (transitivity
    of =~CF~)

-   If a_ <~CF~ _b and b_ <~CF~ _c, then a_ <~CF~ _c (transitivity
    of <~CF~)

-   If a_ >~CF~ _b and b_ >~CF~ _c, then a_ >~CF~ _c (transitivity
    of >~CF~)

NOTE The above conditions are necessary and sufficient to ensure that
comparefn divides the set S into equivalence classes and that these
equivalence classes are totally ordered.

RUNTIME SEMANTICS: SORTCOMPARE ABSTRACT OPERATION

When the SortCompare abstract operation is called with two arguments j
and k, the following steps are taken:

NOTE 1 Because non-existent property values always compare greater than
UNDEFINED property values, and UNDEFINED always compares greater than
any other value, UNDEFINED property values always sort to the end of the
result, followed by non-existent property values.

NOTE 2 The SORT function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore, it can be transferred
to other kinds of objects for use as a method. Whether the SORT function
can be applied successfully to an exotic object that is not an Array is
implementation-dependent.

Array.prototype.splice (start, deleteCount [ , item1 [ , item2 [ , … ] ] ] )

When the SPLICE method is called with two or more arguments start,
deleteCount and (optionally) item1, item2, etc., the deleteCount
elements of the array starting at integer index start are replaced by
the arguments item1, item2, etc. An Array object containing the
deleted elements (if any) is returned. The following steps are taken:

1.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(O).

3.  4.  Let lenVal be Get(O, "LENGTH")

5.  Let len be ToLength(lenVal).

6.  ReturnIfAbrupt(len).

7.  Let relativeStart be ToInteger(start).

8.  ReturnIfAbrupt(relativeStart).

9.  If relativeStart is negative, let actualStart be max((len +
    relativeStart),0); else let actualStart be min(relativeStart,
    len).

10. If deleteCount is not present, then

    a.  Let actualDeleteCount be len - actualStart

11. Else,

    a.  Let dc be ToInteger(deleteCount).

    b.  ReturnIfAbrupt(dc).

    c.  Let actualDeleteCount be min(max(dc,0), len –
        actualStart).

12. Let count be final – k.

13. Let A be UNDEFINED.

14. If O is an exotic Array object, then

    a.  Let C be the result of Get(O, "CONSTRUCTOR").

    b.  ReturnIfAbrupt(C).

    c.  If IsConstructor(C) is TRUE, then

        i.  Let A be the result of OrdinaryConstruct(C,
            (actualDeleteCount)).

15. If A is UNDEFINED, then

    a.  Let A be the result of the abstract operation ArrayCreate with
        argument actualDeleteCount.

16. ReturnIfAbrupt(A).

17. Let k be 0.

18. Repeat, while k < actualDeleteCount

    a.  Let from be ToString(actualStart_+_k).

    b.  Let fromPresent be the result of HasProperty(O, from).

    c.  ReturnIfAbrupt(fromPresent).

    d.  If fromPresent is TRUE, then

        i.  Let fromValue be the result of Get(O, from).

        ii. ReturnIfAbrupt(fromValue).

        iii. Call the [[DefineOwnProperty]] internal method of A with
            arguments ToString(k) and Property Descriptor {[[Value]]:
            fromValue, [[Writable]]: TRUE, [[Enumerable]]: TRUE,
            [[Configurable]]: TRUE}.

    e.  Increment k by 1.

19. Let putStatus be the result of Put(A, "LENGTH",
    actualDeleteCount, TRUE).

20. ReturnIfAbrupt(putStatus).

21. Let items be an internal List whose elements are, in left to right
    order, the portion of the actual argument list starting with
    item1. The list will be empty if no such items are present.

22. Let itemCount be the number of elements in items.

23. If itemCount < actualDeleteCount, then

    a.  Let k be actualStart.

    b.  Repeat, while k < (len – actualDeleteCount)

        i.  Let from be ToString(k_+_actualDeleteCount).

        ii. Let to be ToString(k_+_itemCount).

        iii. Let fromPresent be the result of HasProperty(O,
            from).

        iv. ReturnIfAbrupt(fromPresent).

        v.  If fromPresent is TRUE, then

            1.  Let fromValue be the result of Get(O, from).

            2.  ReturnIfAbrupt(fromValue).

            3.  Let putStatus be the result of Put(O, to,
                fromValue, TRUE).

            4.  ReturnIfAbrupt(putStatus).

        vi. Else fromPresent is FALSE,

            1.  Let deleteStatus be the result of
                DeletePropertyOrThrow(O, to).

            2.  ReturnIfAbrupt(deleteStatus).

        vii. Increase k by 1.

    c.  Let k be len.

    d.  Repeat, while k > (len – actualDeleteCount + itemCount)

        i.  Let deleteStatus be the result of
            DeletePropertyOrThrow(O, ToString(k–1)).

        ii. ReturnIfAbrupt(deleteStatus).

        iii. Decrease k by 1.

24. Else if itemCount > actualDeleteCount, then

    a.  Let k be (len – actualDeleteCount).

    b.  Repeat, while k > actualStart

        i.  Let from be ToString(k + actualDeleteCount – 1).

        ii. Let to be ToString(k + itemCount – 1)

        iii. Let fromPresent be the result of HasProperty(O,
            from).

        iv. ReturnIfAbrupt(fromPresent).

        v.  If fromPresent is TRUE, then

            1.  Let fromValue be the result of Get(O, from).

            2.  ReturnIfAbrupt(fromValue).

            3.  Let putStatus be the result of Put(O, to,
                fromValue, TRUE).

            4.  ReturnIfAbrupt(putStatus).

        vi. Else fromPresent is FALSE,

            1.  Let deleteStatus be the result of
                DeletePropertyOrThrow(O, to).

            2.  ReturnIfAbrupt(deleteStatus).

        vii. Decrease k by 1.

25. Let k be actualStart.

26. Repeat, while items is not empty

    a.  Remove the first element from items and let E be the value
        of that element.

    b.  Let putStatus be the result of Put(O, ToString(k), E,
        TRUE).

    c.  ReturnIfAbrupt(putStatus).

    d.  Increase k by 1.

27. Let putStatus be the result of Put(O, "LENGTH", len –
    actualDeleteCount + itemCount, TRUE).

28. ReturnIfAbrupt(putStatus).

29. Return A.

The LENGTH property of the SPLICE method is 2.

NOTE 1 The explicit setting of the LENGTH property of the result Array
in step 13 is necessary to ensure that its value is correct in
situations where its trailing elements are not present.

NOTE 2 The SPLICE function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the SPLICE
function can be applied successfully to an exotic object that is not an
Array is implementation-dependent.

Array.prototype.unshift ( [ item1 [ , item2 [ , … ] ] ] )

The arguments are prepended to the start of the array, such that their
order within the array is the same as the order in which they appear in
the argument list.

When the UNSHIFT method is called with zero or more arguments item1,
item2, etc., the following steps are taken:

The LENGTH property of the UNSHIFT method is 1.

NOTE The UNSHIFT function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the UNSHIFT
function can be applied successfully to an exotic object that is not an
Array is implementation-dependent.

Array.prototype.indexOf ( searchElement [ , fromIndex ] )

INDEXOF compares searchElement to the elements of the array, in
ascending order, using the Strict Equality Comparison algorithm
(11.9.1), and if found at one or more positions, returns the index of
the first such position; otherwise, -1 is returned.

The optional second argument fromIndex defaults to 0 (i.e. the whole
array is searched). If it is greater than or equal to the length of the
array, -1 is returned, i.e. the array will not be searched. If it is
negative, it is used as the offset from the end of the array to compute
fromIndex. If the computed index is less than 0, the whole array will
be searched.

When the INDEXOF method is called with one or two arguments, the
following steps are taken:

1.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(O).

3.  Let lenValue be the result of Get(O, "LENGTH")

4.  Let len be ToLength(lenValue).

5.  ReturnIfAbrupt(len).

6.  If len is 0, return -1.

7.  If argument fromIndex was passed let n be
    ToInteger(fromIndex); else let n be 0.

8.  ReturnIfAbrupt(n).

9.  If n ≥ len, return -1.

10. If n ≥ 0, then

    a.  Let k be n.

11. Else n<0,

    a.  Let k be len - abs(n).

    b.  If k < 0, then let k be 0.

12. Repeat, while k_<_len

    a.  Let kPresent be the result of HasProperty(O, ToString(k)).

    b.  ReturnIfAbrupt(kPresent).

    c.  If kPresent is TRUE, then

        i.  Let elementK be the result of Get(O, ToString(k)).

        ii. ReturnIfAbrupt(elementK).

        iii. Let same be the result of performing Strict Equality
            Comparison searchElement === elementK.

        iv. If same is TRUE, return k.

    d.  Increase k by 1.

13. Return -1.

The LENGTH property of the INDEXOF method is 1.

NOTE The INDEXOF function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the INDEXOF
function can be applied successfully to an exotic object that is not an
Array is implementation-dependent.

Array.prototype.lastIndexOf ( searchElement [ , fromIndex ] )

LASTINDEXOF compares searchElement to the elements of the array in
descending order using the Strict Equality Comparison algorithm
(11.9.1), and if found at one or more positions, returns the index of
the last such position; otherwise, -1 is returned.

The optional second argument fromIndex defaults to the array's length
minus one (i.e. the whole array is searched). If it is greater than or
equal to the length of the array, the whole array will be searched. If
it is negative, it is used as the offset from the end of the array to
compute fromIndex. If the computed index is less than 0, -1 is
returned.

When the LASTINDEXOF method is called with one or two arguments, the
following steps are taken:

The LENGTH property of the LASTINDEXOF method is 1.

NOTE The LASTINDEXOF function is intentionally generic; it does not
require that its THIS value be an Array object. Therefore it can be
transferred to other kinds of objects for use as a method. Whether the
LASTINDEXOF function can be applied successfully to an exotic object
that is not an Array is implementation-dependent.

Array.prototype.every ( callbackfn [ , thisArg ] )

callbackfn should be a function that accepts three arguments and
returns a value that is coercible to the Boolean value TRUE or FALSE.
EVERY calls callbackfn once for each element present in the array, in
ascending order, until it finds one where callbackfn returns FALSE. If
such an element is found, EVERY immediately returns FALSE. Otherwise, if
callbackfn returned TRUE for all elements, EVERY will return TRUE.
callbackfn is called only for elements of the array which actually
exist; it is not called for missing elements of the array.

If a thisArg parameter is provided, it will be used as the THIS value
for each invocation of callbackfn. If it is not provided, UNDEFINED is
used instead.

callbackfn is called with three arguments: the value of the element,
the index of the element, and the object being traversed.

EVERY does not directly mutate the object on which it is called but the
object may be mutated by the calls to callbackfn.

The range of elements processed by EVERY is set before the first call to
callbackfn. Elements which are appended to the array after the call to
EVERY begins will not be visited by callbackfn. If existing elements
of the array are changed, their value as passed to callbackfn will be
the value at the time EVERY visits them; elements that are deleted after
the call to EVERY begins and before being visited are not visited. EVERY
acts like the "for all" quantifier in mathematics. In particular, for an
empty array, it returns TRUE.

When the EVERY method is called with one or two arguments, the following
steps are taken:

The LENGTH property of the EVERY method is 1.

NOTE The EVERY function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the EVERY
function can be applied successfully to an exotic object that is not an
Array is implementation-dependent.

Array.prototype.some ( callbackfn [ , thisArg ] )

callbackfn should be a function that accepts three arguments and
returns a value that is coercible to the Boolean value TRUE or FALSE.
SOME calls callbackfn once for each element present in the array, in
ascending order, until it finds one where callbackfn returns TRUE. If
such an element is found, SOME immediately returns TRUE. Otherwise, SOME
returns FALSE. callbackfn is called only for elements of the array
which actually exist; it is not called for missing elements of the
array.

If a thisArg parameter is provided, it will be used as the THIS value
for each invocation of callbackfn. If it is not provided, UNDEFINED is
used instead.

callbackfn is called with three arguments: the value of the element,
the index of the element, and the object being traversed.

SOME does not directly mutate the object on which it is called but the
object may be mutated by the calls to callbackfn.

The range of elements processed by SOME is set before the first call to
callbackfn. Elements that are appended to the array after the call to
SOME begins will not be visited by callbackfn. If existing elements of
the array are changed, their value as passed to callbackfn will be the
value at the time that SOME visits them; elements that are deleted after
the call to SOME begins and before being visited are not visited. SOME
acts like the "exists" quantifier in mathematics. In particular, for an
empty array, it returns FALSE.

When the SOME method is called with one or two arguments, the following
steps are taken:

The LENGTH property of the SOME method is 1.

NOTE The SOME function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the SOME function
can be applied successfully to an exotic object that is not an Array is
implementation-dependent.

Array.prototype.forEach ( callbackfn [ , thisArg ] )

callbackfn should be a function that accepts three arguments. FOREACH
calls callbackfn once for each element present in the array, in
ascending order. callbackfn is called only for elements of the array
which actually exist; it is not called for missing elements of the
array.

If a thisArg parameter is provided, it will be used as the THIS value
for each invocation of callbackfn. If it is not provided, UNDEFINED is
used instead.

callbackfn is called with three arguments: the value of the element,
the index of the element, and the object being traversed.

FOREACH does not directly mutate the object on which it is called but
the object may be mutated by the calls to callbackfn.

The range of elements processed by FOREACH is set before the first call
to callbackfn. Elements which are appended to the array after the call
to FOREACH begins will not be visited by callbackfn. If existing
elements of the array are changed, their value as passed to callback
will be the value at the time FOREACH visits them; elements that are
deleted after the call to FOREACH begins and before being visited are
not visited.

When the FOREACH method is called with one or two arguments, the
following steps are taken:

1.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(O).

3.  Let lenValue be the result of Get(O, "LENGTH")

4.  Let len be ToLength(lenValue).

5.  ReturnIfAbrupt(len).

6.  If IsCallable(callbackfn) is FALSE, throw a TYPEERROR exception.

7.  If thisArg was supplied, let T be thisArg; else let T be
    UNDEFINED.

8.  Let k be 0.

9.  Repeat, while k < len

    a.  Let Pk be ToString(k).

    b.  Let kPresent be the result of HasProperty(O, Pk).

    c.  ReturnIfAbrupt(kPresent).

    d.  If kPresent is TRUE, then

        i.  Let kValue be the result of Get(O, Pk).

        ii. ReturnIfAbrupt(kValue).

        iii. Let funcResult be the result of calling the [[Call]]
            internal method of callbackfn with T as thisArgument
            and a List containing kValue, k, and O as
            argumentsList.

        iv. ReturnIfAbrupt(funcResult).

    e.  Increase k by 1.

10. Return UNDEFINED.

The LENGTH property of the FOREACH method is 1.

NOTE The FOREACH function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the FOREACH
function can be applied successfully to an exotic object that is not an
Array is implementation-dependent.

Array.prototype.map ( callbackfn [ , thisArg ] )

callbackfn should be a function that accepts three arguments. MAP
calls callbackfn once for each element in the array, in ascending
order, and constructs a new Array from the results. callbackfn is
called only for elements of the array which actually exist; it is not
called for missing elements of the array.

If a thisArg parameter is provided, it will be used as the THIS value
for each invocation of callbackfn. If it is not provided, UNDEFINED is
used instead.

callbackfn is called with three arguments: the value of the element,
the index of the element, and the object being traversed.

MAP does not directly mutate the object on which it is called but the
object may be mutated by the calls to callbackfn.

The range of elements processed by MAP is set before the first call to
callbackfn. Elements which are appended to the array after the call to
MAP begins will not be visited by callbackfn. If existing elements of
the array are changed, their value as passed to callbackfn will be the
value at the time MAP visits them; elements that are deleted after the
call to MAP begins and before being visited are not visited.

When the MAP method is called with one or two arguments, the following
steps are taken:

The LENGTH property of the MAP method is 1.

NOTE The MAP function is intentionally generic; it does not require that
its THIS value be an Array object. Therefore it can be transferred to
other kinds of objects for use as a method. Whether the MAP function can
be applied successfully to an exotic object that is not an Array is
implementation-dependent.

Array.prototype.filter ( callbackfn [ , thisArg ] )

callbackfn should be a function that accepts three arguments and
returns a value that is coercible to the Boolean value TRUE or FALSE.
FILTER calls callbackfn once for each element in the array, in
ascending order, and constructs a new array of all the values for which
callbackfn returns TRUE. callbackfn is called only for elements of
the array which actually exist; it is not called for missing elements of
the array.

If a thisArg parameter is provided, it will be used as the THIS value
for each invocation of callbackfn. If it is not provided, UNDEFINED is
used instead.

callbackfn is called with three arguments: the value of the element,
the index of the element, and the object being traversed.

FILTER does not directly mutate the object on which it is called but the
object may be mutated by the calls to callbackfn.

The range of elements processed by FILTER is set before the first call
to callbackfn. Elements which are appended to the array after the call
to FILTER begins will not be visited by callbackfn. If existing
elements of the array are changed their value as passed to callbackfn
will be the value at the time FILTER visits them; elements that are
deleted after the call to FILTER begins and before being visited are not
visited.

When the FILTER method is called with one or two arguments, the
following steps are taken:

1.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(O).

3.  Let lenValue be the result of Get(O, "LENGTH").

4.  Let len be ToLength(lenValue).

5.  ReturnIfAbrupt(len).

6.  If IsCallable(callbackfn) is FALSE, throw a TYPEERROR exception.

7.  If thisArg was supplied, let T be thisArg; else let T be
    UNDEFINED.

8.  9.  Let A be UNDEFINED.

10. If O is an exotic Array object, then

    a.  Let C be Get(O, "CONSTRUCTOR").

    b.  ReturnIfAbrupt(C).

    c.  If IsConstructor(C) is TRUE, then

        i.  Let newObj be the result of calling the [[Construct]]
            internal method of C with an argument list containing the
            single item 0.

11. If A is UNDEFINED, then

    a.  Let A be the result of the abstract operation ArrayCreate with
        argument 0.

12. ReturnIfAbrupt(A).

13. Let k be 0.

14. Let to be 0.

15. Repeat, while k < len

    a.  Let Pk be ToString(k).

    b.  Let kPresent be the result of HasProperty(O, Pk).

    c.  ReturnIfAbrupt(kPresent).

    d.  If kPresent is TRUE, then

        i.  Let kValue be the result of Get(O, Pk).

        ii. ReturnIfAbrupt(kValue).

        iii. Let selected be the result of calling the [[Call]]
            internal method of callbackfn with T as thisArgument
            and a List containing kValue, k, and O as
            argumentsList.

        iv. ReturnIfAbrupt(selected).

        v.  If ToBoolean(selected) is TRUE, then

            1.  Call the [[DefineOwnProperty]] internal method of A
                with arguments ToString(to) and Property Descriptor
                {[[Value]]: kValue, [[Writable]]: TRUE,
                [[Enumerable]]: TRUE, [[Configurable]]: TRUE}.

            2.  Increase to by 1.

    e.  Increase k by 1.

16. Return A.

The LENGTH property of the FILTER method is 1.

NOTE The FILTER function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the FILTER
function can be applied successfully to an exotic object that is not an
Array is implementation-dependent.

Array.prototype.reduce ( callbackfn [ , initialValue ] )

callbackfn should be a function that takes four arguments. REDUCE
calls the callback, as a function, once for each element present in the
array, in ascending order.

callbackfn is called with four arguments: the previousValue (or
value from the previous call to callbackfn), the currentValue (value
of the current element), the currentIndex, and the object being
traversed. The first time that callback is called, the previousValue
and currentValue can be one of two values. If an initialValue was
provided in the call to REDUCE, then previousValue will be equal to
initialValue and currentValue will be equal to the first value in
the array. If no initialValue was provided, then previousValue will
be equal to the first value in the array and currentValue will be
equal to the second. It is a TYPEERROR if the array contains no elements
and initialValue is not provided.

REDUCE does not directly mutate the object on which it is called but the
object may be mutated by the calls to callbackfn.

The range of elements processed by REDUCE is set before the first call
to callbackfn. Elements that are appended to the array after the call
to REDUCE begins will not be visited by callbackfn. If existing
elements of the array are changed, their value as passed to callbackfn
will be the value at the time REDUCE visits them; elements that are
deleted after the call to REDUCE begins and before being visited are not
visited.

When the REDUCE method is called with one or two arguments, the
following steps are taken:

1.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(O).

3.  Let lenValue be the result of Get(O, "LENGTH").

4.  Let len be ToLength(lenValue).

5.  ReturnIfAbrupt(len).

6.  If IsCallable(callbackfn) is FALSE, throw a TYPEERROR exception.

7.  If len is 0 and initialValue is not present, throw a TYPEERROR
    exception.

8.  Let k be 0.

9.  If initialValue is present, then

    a.  Set accumulator to initialValue.

10. Else initialValue is not present,

    a.  Let kPresent be FALSE.

    b.  Repeat, while kPresent is FALSE and k < len

        i.  Let Pk be ToString(k).

        ii. Let kPresent be the result of HasProperty(O, Pk).

        iii. ReturnIfAbrupt(kPresent).

        iv. If kPresent is TRUE, then

            1.  Let accumulator be the result of Get(O, Pk).

            2.  ReturnIfAbrupt(accumulator).

        v.  Increase k by 1.

    c.  If kPresent is FALSE, throw a TYPEERROR exception.

11. Repeat, while k < len

    a.  Let Pk be ToString(k).

    b.  Let kPresent be the result of HasProperty(O, Pk).

    c.  ReturnIfAbrupt(kPresent).

    d.  If kPresent is TRUE, then

        i.  Let kValue be the result of Get(O, Pk).

        ii. ReturnIfAbrupt(kValue).

        iii. Let accumulator be the result of calling the [[Call]]
            internal method of callbackfn with UNDEFINED as
            thisArgument and a List containing accumulator,
            kValue, k, and O as argumentsList.

        iv. ReturnIfAbrupt(accumulator).

    e.  Increase k by 1.

12. Return accumulator.

The LENGTH property of the REDUCE method is 1.

NOTE The REDUCE function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the REDUCE
function can be applied successfully to an exotic object that is not an
Array is implementation-dependent.

Array.prototype.reduceRight ( callbackfn [ , initialValue ] )

callbackfn should be a function that takes four arguments. REDUCERIGHT
calls the callback, as a function, once for each element present in the
array, in descending order.

callbackfn is called with four arguments: the previousValue (or
value from the previous call to callbackfn), the currentValue (value
of the current element), the currentIndex, and the object being
traversed. The first time the function is called, the previousValue
and currentValue can be one of two values. If an initialValue was
provided in the call to REDUCERIGHT, then previousValue will be equal
to initialValue and currentValue will be equal to the last value in
the array. If no initialValue was provided, then previousValue will
be equal to the last value in the array and currentValue will be equal
to the second-to-last value. It is a TYPEERROR if the array contains no
elements and initialValue is not provided.

REDUCERIGHT does not directly mutate the object on which it is called
but the object may be mutated by the calls to callbackfn.

The range of elements processed by REDUCERIGHT is set before the first
call to callbackfn. Elements that are appended to the array after the
call to REDUCERIGHT begins will not be visited by callbackfn. If
existing elements of the array are changed by callbackfn, their value
as passed to callbackfn will be the value at the time REDUCERIGHT
visits them; elements that are deleted after the call to REDUCERIGHT
begins and before being visited are not visited.

When the REDUCERIGHT method is called with one or two arguments, the
following steps are taken:

The LENGTH property of the REDUCERIGHT method is 1.

NOTE The REDUCERIGHT function is intentionally generic; it does not
require that its this value be an Array object. Therefore it can be
transferred to other kinds of objects for use as a method. Whether the
REDUCERIGHT function can be applied successfully to an exotic object
that is not an Array is implementation-dependent.

Array.prototype.find ( predicate , thisArg = undefined )

predicate should be a function that accepts three arguments and
returns a value that is coercible to the Boolean value TRUE or FALSE.
FIND calls predicate once for each element present in the array, in
ascending order, until it finds one where predicate returns TRUE. If
such an element is found, FIND immediately returns that element value.
Otherwise, FIND returns UNDEFINED. predicate is called only for
elements of the array which actually exist; it is not called for missing
elements of the array.

If a thisArg parameter is provided, it will be used as the THIS value
for each invocation of predicate. If it is not provided, UNDEFINED is
used instead.

predicate is called with three arguments: the value of the element,
the index of the element, and the object being traversed.

FIND does not directly mutate the object on which it is called but the
object may be mutated by the calls to predicate.

The range of elements processed by FIND is set before the first call to
callbackfn. Elements that are appended to the array after the call to
FIND begins will not be visited by callbackfn. If existing elements of
the array are changed, their value as passed to predicate will be the
value at the time that FIND visits them; elements that are deleted after
the call to FIND begins and before being visited are not visited.

When the FIND method is called with one or two arguments, the following
steps are taken:

1.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(O).

3.  Let lenValue be the result of Get(O, "LENGTH").

4.  Let len be ToLength(lenValue).

5.  ReturnIfAbrupt(len).

6.  If IsCallable(predicate) is FALSE, throw a TYPEERROR exception.

7.  If thisArg was supplied, let T be thisArg; else let T be
    UNDEFINED.

8.  Let k be 0.

9.  Repeat, while k < len

    a.  Let Pk be ToString(k).

    b.  Let kPresent be the result of HasProperty(O, Pk).

    c.  ReturnIfAbrupt(kPresent).

    d.  If kPresent is TRUE, then

        i.  Let kValue be the result of Get(O, Pk).

        ii. ReturnIfAbrupt(kValue).

        iii. Let testResult be the result of calling the [[Call]]
            internal method of predicate with T as thisArgument
            and a List containing kValue, k, and O as
            argumentsList.

        iv. ReturnIfAbrupt(testResult).

        v.  If ToBoolean(testResult) is TRUE, return kValue.

    e.  Increase k by 1.

10. Return UNDEFINED.

The LENGTH property of the FIND method is 1.

NOTE The FIND function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the FIND function
can be applied successfully to an exotic object that is not an Array is
implementation-dependent.

Array.prototype.findIndex ( predicate , thisArg = undefined )

predicate should be a function that accepts three arguments and
returns a value that is coercible to the Boolean value TRUE or FALSE.
FINDINDEX calls predicate once for each element present in the array,
in ascending order, until it finds one where predicate returns TRUE.
If such an element is found, FINDINDEX immediately returns the index of
that element value. Otherwise, FINDINDEX returns -1. predicate is
called only for elements of the array which actually exist; it is not
called for missing elements of the array.

If a thisArg parameter is provided, it will be used as the THIS value
for each invocation of predicate. If it is not provided, UNDEFINED is
used instead.

predicate is called with three arguments: the value of the element,
the index of the element, and the object being traversed.

FINDINDEX does not directly mutate the object on which it is called but
the object may be mutated by the calls to predicate.

The range of elements processed by FINDINDEX is set before the first
call to callbackfn. Elements that are appended to the array after the
call to FINDINDEX begins will not be visited by callbackfn. If
existing elements of the array are changed, their value as passed to
predicate will be the value at the time that FINDINDEX visits them;
elements that are deleted after the call to FINDINDEX begins and before
being visited are not visited.

When the FINDINDEX method is called with one or two arguments, the
following steps are taken:

1.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(O).

3.  Let lenValue be the result of Get(O, "LENGTH").

4.  Let len be ToLength(lenValue).

5.  ReturnIfAbrupt(len).

6.  If IsCallable(predicate) is FALSE, throw a TYPEERROR exception.

7.  If thisArg was supplied, let T be thisArg; else let T be
    UNDEFINED.

8.  Let k be 0.

9.  Repeat, while k < len

    a.  Let Pk be ToString(k).

    b.  Let kPresent be the result of HasProperty(O, Pk).

    c.  ReturnIfAbrupt(kPresent).

    d.  If kPresent is TRUE, then

        i.  Let kValue be the result of Get(O, Pk).

        ii. ReturnIfAbrupt(kValue).

        iii. Let testResult be the result of calling the [[Call]]
            internal method of predicate with T as thisArgument
            and a List containing kValue, k, and O as
            argumentsList.

        iv. ReturnIfAbrupt(testResult).

        v.  If ToBoolean(testResult) is TRUE, return k.

    e.  Increase k by 1.

10. Return -1.

The LENGTH property of the FINDINDEX method is 1.

NOTE The FINDINDEX function is intentionally generic; it does not
require that its THIS value be an Array object. Therefore it can be
transferred to other kinds of objects for use as a method. Whether the
FINDINDEX function can be applied successfully to an exotic object that
is not an Array is implementation-dependent.

Array.prototype.entries ( )

The following steps are taken:

1.  Let O be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(O).

3.  Return the result of calling the CreateArrayIterator abstract
    operation with arguments O and "KEY+VALUE".

Array.prototype.keys ( )

The following steps are taken:

1.  Let O be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(O).

3.  Return the result of calling the CreateArrayIterator abstract
    operation with arguments O and "KEY".

Array.prototype.values ( )

The following steps are taken:

1.  Let O be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(O).

3.  Return the result of calling the CreateArrayIterator abstract
    operation with arguments O and "VALUE".

Array.prototype [ @@iterator ] ( )

The initial value of the @@iterator property is the same function object
as the initial value of the ARRAY.PROTOTYPE.VALUES property.

Array.prototype [ @@unscopables ]

The initial value of the @@unscopables data property is an object
created by the following steps:

1.  Let blackList be the result of calling ArrayCreate(5,
    %ArrayPrototype%).

2.  Call CreateOwnDataProperty(blacklist, "0", "FIND").

3.  Call CreateOwnDataProperty(blacklist, "1", "FINDINDEX").

4.  Call CreateOwnDataProperty(blacklist, "2", "FILL").

5.  Call CreateOwnDataProperty(blacklist, "3", "COPYWITHIN").

6.  Call CreateOwnDataProperty(blacklist, "4", "ENTRIES").

7.  Call CreateOwnDataProperty(blacklist, "5", "KEYS").

8.  Call CreateOwnDataProperty(blacklist, "6", "VALUES").

9.  Return blackList.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

NOTE The elements of this array are property names that were not
included as standard properties of ARRAY.PROTOTYPE prior to the sixth
edition of this specification. These names are ignored for WITH
statement binding purposes in order to preserve the behaviour of
existing code that might use one of these names as a binding in an outer
scope that is shadowed by a WITH statement whose binding object is an
Array object.

Array.prototype.fill (value, start = 0, end = this.length)

The FILL method takes up to three arguments value, start and end.
The start and end arguments are optional with default values of 0
and the length of the THIS object. If start is negative, it is treated
as length_+_start where length is the length of the array. If end
is negative, it is treated as length_+_end. The following steps are
taken:

1.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(O).

3.  Let lenVal be the result of Get(O, "LENGTH").

4.  Let len be ToLength(lenVal).

5.  ReturnIfAbrupt(len).

6.  Let len be max(len, 0).

7.  Let relativeStart be ToInteger(start).

8.  ReturnIfAbrupt(relativeStart).

9.  If relativeStart is negative, let k be max((len +
    relativeStart),0); else let k be min(relativeStart, len).

10. If end is UNDEFINED, let relativeEnd be len; else let
    relativeEnd be ToInteger(end).

11. ReturnIfAbrupt(relativeEnd).

12. If relativeEnd is negative, let final be max((len +
    relativeEnd),0); else let final be min(relativeEnd, len).

13. Repeat, while k < final

    a.  Let Pk be ToString(k).

    b.  Let putStatus be the result of Put(O, Pk, value, TRUE).

    c.  ReturnIfAbrupt(putStatus).

    d.  Increase k by 1.

14. Return O.

The LENGTH property of the FILL method is 1.

NOTE 1 The FILL function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the FILL function
can be applied successfully to an exotic object that is not an Array is
implementation-dependent.

Array.prototype.copyWith (target, start, end = this.length)

The COPYWITH method takes up to three arguments target, start and
end. The end argument is optional with the length of the THIS object
as its default value. If taqrget is negative, it is treated as
length_+_target where length is the length of the array. If start
is negative, it is treated as length_+_start. If end is negative, it
is treated as length_+_end. The following steps are taken:

1.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(O).

3.  Let lenVal be the result of Get(O, "LENGTH").

4.  Let len be ToLength(lenVal).

5.  ReturnIfAbrupt(len).

6.  Let len be max(len, 0).

7.  Let relativeTarget be ToInteger(target).

8.  If relativeTarget is negative, let to be max((len +
    relativeStart),0); else let to be min(relativeStart, len).

9.  ReturnIfAbrupt(relativeTarget).

10. Let relativeStart be ToInteger(start).

11. ReturnIfAbrupt(relativeStart).

12. If relativeStart is negative, let from be max((len +
    relativeStart),0); else let from be min(relativeStart, len).

13. If end is UNDEFINED, let relativeEnd be len; else let
    relativeEnd be ToInteger(end).

14. ReturnIfAbrupt(relativeEnd).

15. If relativeEnd is negative, let final be max((len +
    relativeEnd),0); else let final be min(relativeEnd, len).

16. Let count be min(final_-_from, len_-_to).

17. If from_<_to and to<from+count

    a.  Let direction = -1.

    b.  Let from = from + count -1.

    c.  Let to = to + count -1.

18. Else,

    a.  Let direction = 1.

19. Repeat, while count > 0

    a.  Let fromKey be ToString(from).

    b.  Let toKey be ToString(to).

    c.  Let fromPresent be the result of HasProperty(O, fromKey).

    d.  ReturnIfAbrupt(fromPresent).

    e.  If fromPresent is TRUE, then

        i.  Let fromVal be the result of Get(O, fromKey).

        ii. ReturnIfAbrupt(fromVal).

        iii. Let putStatus be the result of Put(O, toKey,
            fromVal, TRUE).

        iv. ReturnIfAbrupt(putStatus).

    f.  Else fromPresent is FALSE,

        i.  Let deleteStatus be the result of
            DeletePropertyOrThrow(O, toKey).

        ii. ReturnIfAbrupt(deleteStatus).

    g.  Let from be from + direction.

    h.  Let to be to + direction.

    i.  Let count be count - 1.

20. Return O.

The LENGTH property of the FILL method is 2.

NOTE 1 The COPYWITH function is intentionally generic; it does not
require that its THIS value be an Array object. Therefore it can be
transferred to other kinds of objects for use as a method. Whether the
COPYWITH function can be applied successfully to an exotic object that
is not an Array is implementation-dependent.

Properties of Array Instances

Array instances are exotic Array objects and have the internal methods
specified for such objects. Array instances inherit properties from the
Array prototype object. Array instances also have an
[[ArrayInitialisationState]] internal data property.

Array instances have a LENGTH property, and a set of enumerable
properties with array index names.

length

The LENGTH property of this Array object is a data property whose value
is always numerically greater than the name of every deletable property
whose name is an array index.

The LENGTH property initially has the attributes { [[Writable]]: TRUE,
[[Enumerable]]: FALSE, [[Configurable]]: FALSE }.

NOTE Attempting to set the length property of an Array object to a value
that is numerically less than or equal to the largest numeric property
name of an existing array indexed non-deletable property of the array
will result in the length being set to a numeric value that is one
greater than that largest numeric property name. See 8.4.2.1.

Array Iterator Object Structure

An Array Iterator is an object, with the structure defined below, that
represents a specific iteration over some specific Array instance
object. There is not a named constructor for Array Iterator objects.
Instead, Array iterator objects are created by calling certain methods
of Array instance objects.

CreateArrayIterator Abstract Operation

Several methods of Array objects return Iterator objects. The abstract
operation CreateArrayIterator with arguments array and kind is used
to create such iterator objects. It performs the following steps:

1.  Let O be the result of calling ToObject(array).

2.  ReturnIfAbrupt(O).

3.  Let iterator be the result of
    ObjectCreate(%ArrayIteratorPrototype%, ([[IteratedObject]],
    [[ArrayIteratorNextIndex]], [[ArrayIterationKind]])).

4.  Set iterator’s [[IteratedObject]] internal data property to O.

5.  Set iterator’s [[ArrayIteratorNextIndex]] internal data property
    to 0.

6.  Set iterator’s [[ArrayIterationKind]] internal data property to
    kind.

7.  Return iterator.

The Array Iterator Prototype

All Array Iterator Objects inherit properties from a common Array
Iterator Prototype object. The [[Prototype]] internal data property of
the Array Iterator Prototype is the %ObjectPrototype% intrinsic object.
In addition, the Array Iterator Prototype has the following properties:

ArrayIterator.prototype.constructor

ArrayIterator.prototype.next( )

1.  Let O be the THIS value.

2.  If Type(O) is not Object, throw a TYPEERROR exception.

3.  If O does not have all of the internal properties of a Array
    Iterator Instance (15.4.5.1.2), throw a TYPEERROR exception.

4.  Let a be the value of the [[IteratedObject]] internal data
    property of O.

5.  Let index be the value of the [[ArrayIteratorNextIndex]] internal
    data property of O.

6.  Let itemKind be the value of the [[ArrayIterationKind]] internal
    data property of O.

7.  Let lenValue be the result of Get(a, "LENGTH").

8.  Let len be ToLength(lenValue).

9.  ReturnIfAbrupt(len).

10. If itemKind contains the substring "SPARSE", then

    a.  Let found be FALSE.

    b.  Repeat, while found is FALSE and index < len

        i.  Let elementKey be ToString(index).

        ii. Let found be the result of HasProperty(a, elementKey).

        iii. ReturnIfAbrupt(found).

        iv. If found is FALSE, then

            1.  Increase index by 1.

11. If index ≥ len, then

    a.  Set the value of the [[ArrayIteratorNextIndex]] internal data
        property of O to +∞.

    b.  Return CreateItrResultObject(UNDEFINED, TRUE).

    c.  

12. Set the value of the [[ArrayIteratorNextIndex]] internal data
    property of O to index+1.

13. If itemKind contains the substring "VALUE", then

    a.  Let elementKey be ToString(index).

    b.  Let elementValue be the result of Get(a, elementKey).

    c.  ReturnIfAbrupt(elementValue).

14. If itemKind contains the substring "KEY+VALUE", then

    a.  Let result be the result of the abstract operation ArrayCreate
        with argument 2.

    b.  Assert: result is a new, well-formed Array object so the
        following operations will never fail.

    c.  Call the [[DefineOwnProperty]] internal method of result with
        arguments "0" and Property Descriptor {[[Value]]: index,
        [[Writable]]: TRUE, [[Enumerable]]: TRUE, [[Configurable]]:
        TRUE}.

    d.  Call the [[DefineOwnProperty]] internal method of result with
        arguments "1" and Property Descriptor {[[Value]]:
        elementValue, [[Writable]]: TRUE, [[Enumerable]]: TRUE,
        [[Configurable]]: TRUE}.

    e.  Return CreateItrResultObject(result, FALSE).

15. Else If itemKind contains the substring "KEY" then, return
    CreateItrResultObject(index, FALSE).

16. Assert: itemKind contains the substring "VALUE",

17. Return CreateItrResultObject(elementValue, FALSE).

ArrayIterator.prototype.@@iterator ( )

The following steps are taken:

1.  Return the THIS value.

ArrayIterator.prototype.@@toStringTag

The initial value of the @@toStringTag property is the string value
"ARRAY ITERATOR".

Properties of Array Iterator Instances

Array Iterator instances inherit properties from the Array Iterator
prototype (the intrinsic, %ArrayIteratorPrototype%). Array Iterator
instances are initially created with the internal properties listed in
Table 33.

Table 33 — Internal Data Properties of Array Iterator Instances

  ----------------------------- --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  INTERNAL DATA PROPERTY NAME   DESCRIPTION
  [[IteratedObject]]            The object whose array elements are being iterated.
  [[ArrayIteratorNextIndex]]    The integer index of the next array index to be examined by this iteration.
  [[ArrayIterationKind]]        A string value that identifies what is to be returned for each element of the iteration. The possible values are: "KEY", "VALUE", "KEY+VALUE", "SPARSE:KEY", "SPARSE:VALUE", "SPARSE:KEY+VALUE".
  ----------------------------- --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


String Objects

The String Constructor 

The String constructor is the %String% intrinsic object and the initial
value of the STRING property of the global object. When STRING is called
as a function rather than as a constructor, it performs a type
conversion. However, if the THIS value value passed in the call is an
Object with an uninitialised [[StringData]] internal data property, it
initialises the THIS value using the argument value. This permits STRING
to be used both to perform type conversion and to perform constructor
instance initialization.

The STRING constructor is designed to be subclassable. It may be used as
the value of an EXTENDS clause of a class declaration. Subclass
constructors that intended to inherit the specified STRING behaviour
must include a SUPER call to the STRING constructor to initialise the
[[StringData]] state of subclass instances.

String ( [ value ] )

Returns a String value (not a String object) computed by
ToString(value). If value is not supplied, the empty String "" is
returned.

When STRING is called with argument value, the following steps are
taken:

1.  Let O be the THIS value.

2.  If no arguments were passed to this function invocation, then let
    s be "".

3.  Else, let s be ToString(value).

4.  ReturnIfAbrupt(s).

5.  If Type(O) is Object and O has a [[StringData]] internal data
    property and the value of [[StringData]] is UNDEFINED, then

    a.  Let length be the number of code unit elements in s.

    b.  Let status be the result of DefinePropertyOrThrow(O,
        "LENGTH", Property Descriptor{[[Value]]: length, [[Writable]]:
        FALSE, [[Enumerable]]: FALSE, [[Configurable]]: FALSE }).

    c.  ReturnIfAbrupt(status).

    d.  Set the value of O’s [[StringData]] internal data property to
        s.

    e.  Return O.

6.  Return s.

new String ( ... argumentsList )

STRING called as part of a new expression , it initialises a newly
created exotic String object:

1.  Let F be the STRING function object on which the NEW operator was
    applied.

2.  Let argumentsList be the argumentsList argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of OrdinaryConstruct (F, argumentsList).

If STRING is implemented as an ordinary function object, its
[[Construct]] internal method will perform the above steps.

Properties of the String Constructor

The value of the [[Prototype]] internal data property of the String
constructor is the standard built-in Function prototype object
(‎15.3.3).

Besides the LENGTH property (whose value is 1), the String constructor
has the following properties:

String.prototype

The initial value of STRING.PROTOTYPE is the standard built-in String
prototype object (15.5.4).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

String.fromCharCode ( ...codeUnits)

The STRING.FROMCHARCODE function may be called with a variable number of
arguments which form the rest parameter codeUnits. The following steps
are taken:

The LENGTH property of the FROMCHARCODE function is 1.

String.fromCodePoint ( ...codePoints)

The STRING.FROMCODEPOINT function may be called with a variable number
of arguments which form the rest parameter codePoints. The following
steps are taken:

1.  Assert: codePoints is a well-formed rest parameter object.

2.  Let length be the result of Get(codePoints, "LENGTH").

3.  Let elements be a new List.

4.  Let nextIndex be 0.

5.  Repeat while nextIndex < length

    a.  Let next be the result of Get(codePoints,
        ToString(nextIndex)).

    b.  Let nextCP be ToNumber(next).

    c.  ReturnIfAbrupt(nextCP).

    d.  If SameValue(nextCP, ToInteger(nextCP)) is FALSE,then throw
        a RANGEERROR exception.

    e.  If nextCP < 0 or nextCP > 0x10FFFF, then throw a RANGEERROR
        exception.

    f.  Append the elements of the UTF-16 Encoding (clause 6) of
        nextCP to the end of elements.

    g.  Let nextIndex be nextIndex + 1.

6.  Return the String value whose elements are, in order, the elements
    in the List elements. If length is 0, the empty string is
    returned.

The LENGTH property of the FROMCODEPOINT function is 0.

String.raw ( callSite, ...substitutions)

The STRING.RAW function may be called with a variable number of
arguments. The first argument is callSite and the remainder of the
arguments form the rest parameter substitutions. The following steps
are taken:

1.  Assert: substitutions is a well-formed rest parameter object.

2.  Let cooked be ToObject(callSite).

3.  ReturnIfAbrupt(cooked).

4.  Let rawValue be the result of Get(cooked, "RAW").

5.  Let raw be ToObject(rawValue).

6.  ReturnIfAbrupt(raw).

7.  Let len be the result of Get(raw, "LENGTH").

8.  Let literalSegments be ToLength(len).

9.  ReturnIfAbrupt(literalSegments).

10. If literalSegments ≤ 0, then return the empty string.

11. Let stringElements be a new List.

12. Let nextIndex be 0.

13. Repeat

    a.  Let nextKey be ToString(nextIndex).

    b.  Let next be the result of Get(raw, nextKey).

    c.  Let nextSeg be ToString(next).

    d.  ReturnIfAbrupt(nextSeg).

    e.  Append in order the code unit elements of nextSeg to the end
        of stringElements.

    f.  If nextIndex + 1 = literalSegments, then

        i.  Return the string value whose elements are, in order, the
            elements in the List stringElements. If length is 0, the
            empty string is returned.

    g.  Let next be the result of Get(substitutions, nextKey).

    h.  Let nextSub be ToString(next).

    i.  ReturnIfAbrupt(nextSub).

    j.  Append in order the code unit elements of nextSub to the end
        of stringElements.

    k.  Let nextIndex be nextIndex + 1.

The LENGTH property of the RAW function is 1.

NOTE String.raw is intended for use as a tag function of a Tagged
Template String (11.2.6). When called as such the first argument will be
a well formed template call site object and the rest parameter will
contain the substitution values.

String[ @@create ] ( )

The @@create method of an object F performs the following steps:

1.  Let F be the THIS value.

2.  Let proto be the result of GetPrototypeFromConstructor(F,
    "%STRINGPROTOTYPE%").

3.  ReturnIfAbrupt(proto).

4.  Let obj be the result of calling StringCreate (proto).

5.  Return obj.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

NOTE [[StringData]] is initially assigned the value UNDEFINED as a flag
to indicate that the instance has not yet been initialised by the String
constructor. This flag value is never directly exposed to ECMAScript
code; hence implementation may choose to encode the flag in some other
manner.

Properties of the String Prototype Object

The String prototype object is itself an ordinary object. It is not a
String instance and does not have a [[StringData]] internal data
property.

The value of the [[Prototype]] internal data property of the String
prototype object is the standard built-in Object prototype object
(15.2.4).

Unless explicitly stated otherwise, the methods of the String prototype
object defined below are not generic and the THIS value passed to them
must be either a String value or an object that has a [[StringData]]
internal data property that has been initialised to a String value.

The abstract operation thisStringValue(value) performs the following
steps:

1.  If Type(value) is String, return value.

2.  If Type(value) is Object and value has a [[StringData]] internal
    data property, then

    a.  Let s be the value of value’s [[StringData]] internal data
        property.

    b.  If s is not UNDEFINED, then return s.

3.  Throw a TYPEERROR exception.

The phrase “this String value” within the specification of a method
refers to the result returned by calling the abstract operation
thisStringValue with the THIS value of the method invocation passed as
the argument.

String.prototype.constructor

The initial value of STRING.PROTOTYPE.CONSTRUCTOR is the built-in STRING
constructor.

String.prototype.toString ( )

When the TOSTRING method is called, the following steps are taken:

NOTE For a String object, the TOSTRING method happens to return the same
thing as the VALUEOF method.

String.prototype.valueOf ( )

When the VALUEOF method is called, the following steps are taken:

1.  Let s be thisStringValue(THIS value).

2.  Return s.

String.prototype.charAt (pos)

NOTE Returns a single element String containing the code unit at element
position pos in the String value resulting from converting this object
to a String. If there is no element at that position, the result is the
empty String. The result is a String value, not a String object.

If pos is a value of Number type that is an integer, then the result
of X.CHARAT(pos) is equal to the result of X.SUBSTRING(pos,
pos+1).

When the CHARAT method is called with one argument pos, the following
steps are taken:

1.  Let O be CheckObjectCoercible(THIS value).

2.  Let S be ToString(O).

3.  ReturnIfAbrupt(S).

4.  Let position be ToInteger(pos).

5.  ReturnIfAbrupt(position).

6.  Let size be the number of elements in S.

7.  If position < 0 or position ≥ size, return the empty String.

8.  Return a String of length 1, containing one code unit from S,
    namely the code unit at position position, where the first
    (leftmost) code unit in S is considered to be at position 0, the
    next one at position 1, and so on.

NOTE The CHARAT function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

String.prototype.charCodeAt (pos)

NOTE Returns a Number (a nonnegative integer less than 2^16^) that is
the code unit value of the string element at position pos in the
String resulting from converting this object to a String. If there is no
element at that position, the result is NAN.

When the CHARCODEAT method is called with one argument pos, the
following steps are taken:

1.  Let O be CheckObjectCoercible(THIS value).

2.  Let S be ToString(O).

3.  ReturnIfAbrupt(S).

4.  Let position be ToInteger(pos).

5.  ReturnIfAbrupt(position).

6.  Let size be the number of elements in S.

7.  If position < 0 or position ≥ size, return NAN.

8.  Return a value of Number type, whose value is the code unit value of
    the element at position position in the String S, where the
    first (leftmost) element in S is considered to be at position 0,
    the next one at position 1, and so on.

NOTE The CHARCODEAT function is intentionally generic; it does not
require that its THIS value be a String object. Therefore it can be
transferred to other kinds of objects for use as a method.

String.prototype.concat ( ...args )

NOTE When the CONCAT method is called with zero or more arguments, it
returns a String consisting of the string elements of this object
(converted to a String) followed by the string elements of each of the
arguments converted to a String. The result is a String value, not a
String object.

The following steps are taken:

1.  Assert: args is a well-formed rest parameter object.

2.  Let O be CheckObjectCoercible(THIS value).

3.  Let S be ToString(O).

4.  ReturnIfAbrupt(S).

5.  Let args be an internal list that is a copy of the argument list
    passed to this function.

6.  Let R be S.

7.  Repeat, while args is not empty

    a.  Remove the first element from args and let next be the value
        of that element.

    b.  Let nextString be ToString(next)

    c.  ReturnIfAbrupt(nextString).

    d.  Let R be the String value consisting of the string elements in
        the previous value of R followed by the string elements of
        nextString.

8.  Return R.

The LENGTH property of the CONCAT method is 1.

NOTE The CONCAT function is intentionally generic; it does not require
that its THIS value be a String object. Therefore it can be transferred
to other kinds of objects for use as a method.

String.prototype.indexOf (searchString, position)

If searchString appears as a substring of the result of converting
this object to a String, at one or more positions that are greater than
or equal to position, then the index of the smallest such position is
returned; otherwise, 1 is returned. If position is UNDEFINED, 0 is
assumed, so as to search all of the String.

The INDEXOF method takes two arguments, searchString and position,
and performs the following steps:

The LENGTH property of the INDEXOF method is 1.

NOTE The INDEXOF function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

String.prototype.lastIndexOf (searchString, position)

If searchString appears as a substring of the result of converting
this object to a String at one or more positions that are smaller than
or equal to position, then the index of the greatest such position is
returned; otherwise, 1 is returned. If position is UNDEFINED, the
length of the String value is assumed, so as to search all of the
String.

The LASTINDEXOF method takes two arguments, searchString and
position, and performs the following steps:

The LENGTH property of the LASTINDEXOF method is 1.

NOTE The LASTINDEXOF function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

String.prototype.localeCompare (that)

When the LOCALECOMPARE method is called with one argument that, it
returns a Number other than NAN that represents the result of a
locale-sensitive String comparison of the THIS value (converted to a
String) with that (converted to a String). The two Strings are S and
That. The two Strings are compared in an implementation-defined
fashion. The result is intended to order String values in the sort order
specified by the system default locale, and will be negative, zero, or
positive, depending on whether S comes before That in the sort
order, the Strings are equal, or S comes after That in the sort
order, respectively.

Before perform the comparisons the following steps are performed to
prepare the Strings:

1.  Let O be CheckObjectCoercible(THIS value).

2.  Let S be ToString(O).

3.  ReturnIfAbrupt(S).

4.  Let That be ToString(that).

5.  ReturnIfAbrupt(That).

The LOCALECOMPARE method, if considered as a function of two arguments
THIS and that, is a consistent comparison function (as defined in
15.4.3.11) on the set of all Strings.

The actual return values are implementation-defined to permit
implementers to encode additional information in the value, but the
function is required to define a total ordering on all Strings and to
return 0 when comparing Strings that are considered canonically
equivalent by the Unicode standard.

If no language-sensitive comparison at all is available from the host
environment, this function may perform a bitwise comparison.

NOTE 1 The LOCALECOMPARE method itself is not directly suitable as an
argument to ARRAY.PROTOTYPE.SORT because the latter requires a function
of two arguments.

NOTE 2 This function is intended to rely on whatever language-sensitive
comparison functionality is available to the ECMAScript environment from
the host environment, and to compare according to the rules of the host
environment’s current locale. It is strongly recommended that this
function treat Strings that are canonically equivalent according to the
Unicode standard as identical (in other words, compare the Strings as if
they had both been converted to Normalised Form C or D first). It is
also recommended that this function not honour Unicode compatibility
equivalences or decompositions.

NOTE 3 The second parameter to this function is likely to be used in a
future version of this standard; it is recommended that implementations
do not use this parameter position for anything else.

NOTE 4 The LOCALECOMPARE function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

String.prototype.match (regexp)

When the MATCH method is called with argument regexp, the following
steps are taken:

NOTE The MATCH function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

String.prototype.replace (searchValue, replaceValue)

When the REPLACE method is called with arguments searchValue and
replaceValue the following steps are taken:

1.  Let O be CheckObjectCoercible(THIS value).

2.  Let string be ToString(O).

3.  ReturnIfAbrupt(string).

4.  If Type(searchValue) is Object and HasProperty(searchValue,
    @@isRegExp) is TRUE, then

    a.  b.  Return the result of Invoke(searchValue, "REPLACE",
        (string, replaceValue)).

    c.  

5.  6.  Let searchString be ToString(searchValue).

7.  ReturnIfAbrupt(searchString).

8.  Search string for the first occurrence of searchString and let
    pos be the index position within string of the first code unit
    of the matched substring and let matched be searchString. If no
    occurrences of searchString were found, return string.

9.  If IsCallable(replaceValue) is TRUE, then

    a.  Let replValue be the result of calling the [[Call]] internal
        method of replaceValue passing UNDEFINED as the THIS value and
        a List containing matched, pos, and string as the argument
        list.

    b.  Let replStr be ToString(replValue).

    c.  ReturnIfAbrupt(replStr).

10. Else,

    a.  Let captures be an empty List.

    b.  Let replStr be the result of the abstract operation
        GetReplaceSubstitution(matched, string, pos, captures).

11. Let tailPos be pos + the number of code units in matched.

12. Let newString be the String formed by concatenating the first
    pos code units of string, replStr, and the trailing substring
    of string starting at index tailPos. If pos is 0, the first
    element of the concatenation will be the empty String.

13. Return newString.

NOTE The REPLACE function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

RUNTIME SEMANTICS: GETREPLACESUBSTITUTION ABSTRACT OPERATION

The abstract operation GetReplaceSubstitution(matched, string,
position, captures) performs the following steps:

1.  Assert: Type(matched) is String.

2.  Let matchLength be the number of code units in matched.

3.  Assert: Type(string) is String.

4.  Let stringLength be the number of code units in string.

5.  Assert: position is a non-negative integer.

6.  Assert: position ≤ stringLength.

7.  Assert: captures is a possibly empty List of Strings.

8.  Let tailPos be position + matchLength.

9.  Let m be the number of elements in captures.

10. Let result be a String value derived from matched by replacing
    code unit elements in matched by replacement text as specified in
    Table 34. These $ replacements are done left-to-right, and, once
    such a replacement is performed, the new replacement text is not
    subject to further replacements.

11. 12. Return result.

Table 34 — Replacement Text Symbol Substitutions

  --------------------- ------------------------------------------------------------------------- --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  Code unit             Unicode Characters                                                        Replacement text

  0x0024, 0x0024        $$                                                                        $

  0x0024, 0x0026        $&                                                                        matched

  0x0024, 0x0060        $`                                                                        If position is 0, the replacement is the empty String. Otherwise the replacement is the substring of string that starts at index 0 and whose last code point is at index position -1.

  0x0024, 0x0027        $'                                                                        If tailPos ≥ stringLength, the replacement is the empty String. Otherwise the replacement is the substring of string that starts at index tailPos and continues to the end of string.

  0x0024, N where       $N where                                                                  The n^th^ element of captures, where n is a single digit in the range 1 to 9. If n_≤_m and the nth element of captures is UNDEFINED, use the empty String instead. If n_>_m, the result is implementation-defined.
  0x0031 ≤ N ≤ 0x0039   N is one of 1 2 3 4 5 6 7 8 9 and $N is not followed by a decimal digit   

  0x0024, N, N where    $NN where                                                                 The nn^th^ elemet of captures, where nn is a two-digit decimal number in the range 01 to 99. If nn_≤_m and the nn^th^ element of captures is UNDEFINED, use the empty String instead. If nn is 00 or nn_>_m, the result is implementation-defined.
  0x0030 ≤ N ≤ 0x0039   N is one of 0 1 2 3 4 5 6 7 8 9                                           

  0x0024                $ in any context that does not match on of the above.                     $
  --------------------- ------------------------------------------------------------------------- --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

String.prototype.search (regexp)

When the search method is called with argument regexp, the following
steps are taken:

NOTE The SEARCH function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

String.prototype.slice (start, end)

The SLICE method takes two arguments, start and end, and returns a
substring of the result of converting this object to a String, starting
from element position start and running to, but not including, element
position end (or through the end of the String if end is UNDEFINED).
If start is negative, it is treated as sourceLength_+_start where
sourceLength is the length of the String. If end is negative, it is
treated as sourceLength_+_end where sourceLength is the length of
the String. The result is a String value, not a String object. The
following steps are taken:

The LENGTH property of the SLICE method is 2.

NOTE The SLICE function is intentionally generic; it does not require
that its THIS value be a String object. Therefore it can be transferred
to other kinds of objects for use as a method.

String.prototype.split (separator, limit)

Returns an Array object into which substrings of the result of
converting this object to a String have been stored. The substrings are
determined by searching from left to right for occurrences of
separator; these occurrences are not part of any substring in the
returned array, but serve to divide up the String value. The value of
separator may be a String of any length or it may be a RegExp object.

The value of separator may be an empty String, an empty regular
expression, or a regular expression that can match an empty String. In
this case, separator does not match the empty substring at the
beginning or end of the input String, nor does it match the empty
substring at the end of the previous separator match. (For example, if
separator is the empty String, the String is split up into individual
code unit elements; the length of the result array equals the length of
the String, and each substring contains one code unit.) If separator
is a regular expression, only the first match at a given position of the
THIS String is considered, even if backtracking could yield a
non-empty-substring match at that position. (For example,
"AB".SPLIT(/A*?/) evaluates to the array ["A","B"], while
"AB".SPLIT(/A*/) evaluates to the array["","B"].)

If the THIS object is (or converts to) the empty String, the result
depends on whether separator can match the empty String. If it can,
the result array contains no elements. Otherwise, the result array
contains one element, which is the empty String.

If separator is a regular expression that contains capturing
parentheses, then each time separator is matched the results
(including any UNDEFINED results) of the capturing parentheses are
spliced into the output array. For example,

  "A<B>BOLD</B>AND<CODE>CODED</CODE>".SPLIT(/<(\/)?([^<>]+)>/)

evaluates to the array

  ["A", UNDEFINED, "B", "BOLD", "/", "B", "AND", UNDEFINED,
   "CODE", "CODED", "/", "CODE", ""]

If separator is UNDEFINED, then the result array contains just one
String, which is the THIS value (converted to a String). If limit is
not UNDEFINED, then the output array is truncated so that it contains no
more than limit elements.

When the SPLIT method is called, the following steps are taken:

RUNTIME SEMANTICS: SPLITMATCH ABSTRACT OPERATION

The abstract operation SplitMatch takes three parameters, a String S,
an integer q, and a String R, and performs the following in order to
return either FALSE or the end index of a match:

The LENGTH property of the SPLIT method is 2.

NOTE The SPLIT function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

String.prototype.substring (start, end)

The SUBSTRING method takes two arguments, start and end, and returns
a substring of the result of converting this object to a String,
starting from element position start and running to, but not
including, element position end of the String (or through the end of
the String is end is UNDEFINED). The result is a String value, not a
String object.

If either argument is NAN or negative, it is replaced with zero; if
either argument is larger than the length of the String, it is replaced
with the length of the String.

If start is larger than end, they are swapped.

The following steps are taken:

The LENGTH property of the SUBSTRING method is 2.

NOTE The SUBSTRING function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

String.prototype.toLowerCase ( )

This function interprets a string value as a sequence of code points, as
described in 8.4. The following steps are taken:

1.  Let O be CheckObjectCoercible(THIS value).

2.  Let S be ToString(O).

3.  ReturnIfAbrupt(S).

4.  Let cpList be a List containing in order the code points as defned
    in 8.4 of S, starting at the first element of S.

5.  For each code point c in cpList, if the Unicode Character
    Database provides a language insensitive lower case equivalent of
    c then replace c in cpList with that equivalent code point(s).

6.  Let cuList be a new List.

7.  For each code point c in cpList, in order, append to cuList
    the elements of the UTF-16 Encoding (clause 6) of c.

8.  Let L be a String whose elements are, in order, the elements of
    cuList .

9.  Return L.

The result must be derived according to the case mappings in the Unicode
character database (this explicitly includes not only the
UnicodeData.txt file, but also the SpecialCasings.txt file that
accompanies it).

NOTE 1 The case mapping of some code points may produce multiple code
points . In this case the result String may not be the same length as
the source String. Because both TOUPPERCASE and TOLOWERCASE have
context-sensitive behaviour, the functions are not symmetrical. In other
words, S.TOUPPERCASE().TOLOWERCASE() is not necessarily equal to
S.TOLOWERCASE().

NOTE 2 The TOLOWERCASE function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

String.prototype.toLocaleLowerCase ( )

This function interprets a string value as a sequence of code points, as
described in 8.4.

This function works exactly the same as TOLOWERCASE except that its
result is intended to yield the correct result for the host
environment’s current locale, rather than a locale-independent result.
There will only be a difference in the few cases (such as Turkish) where
the rules for that language conflict with the regular Unicode case
mappings.

NOTE 1 The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that implementations
do not use this parameter position for anything else.

NOTE 2 The TOLOCALELOWERCASE function is intentionally generic; it does
not require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

String.prototype.toUpperCase ( )

This function interprets a string value as a sequence of code points, as
described in 8.4.

This function behaves in exactly the same way as
STRING.PROTOTYPE.TOLOWERCASE, except that code points are mapped to
their uppercase equivalents as specified in the Unicode Character
Database.

NOTE The TOUPPERCASE function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

String.prototype.toLocaleUpperCase ( )

This function interprets a string value as a sequence of code points, as
described in 8.4.

This function works exactly the same as TOUPPERCASE except that its
result is intended to yield the correct result for the host
environment’s current locale, rather than a locale-independent result.
There will only be a difference in the few cases (such as Turkish) where
the rules for that language conflict with the regular Unicode case
mappings.

NOTE 1 The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that implementations
do not use this parameter position for anything else.

NOTE 2 The TOLOCALEUPPERCASE function is intentionally generic; it does
not require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

String.prototype.trim ( )

This function interprets a string value as a sequence of code points, as
described in 8.4.

The following steps are taken:

NOTE The TRIM function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

String.prototype.repeat (count)

The following steps are taken:

1.  Let O be CheckObjectCoercible(THIS value).

2.  Let S be ToString(O).

3.  ReturnIfAbrupt(S).

4.  Let n be the result of calling ToInteger(count).

5.  ReturnIfAbrupt(n).

6.  If n < 0, then throw a RANGEERROR exception.

7.  If n is +∞, then throw a RANGEERROR exception.

8.  Let T be a String value that is made from n copies of S
    appended together. If n is 0, T is the empty String.

9.  Return T.

NOTE 1 This method creates a String consisting of the string elements of
this object (converted to String) repeated count time.

NOTE 2 The REPEAT function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

String.prototype.startsWith (searchString [, position ] )

The following steps are taken:

1.  Let O be CheckObjectCoercible(THIS value).

2.  Let S be ToString(O).

3.  ReturnIfAbrupt(S).

4.  Let searchStr be ToString(searchString).

5.  ReturnIfAbrupt(searchStr).

6.  Let pos be ToInteger(position). (If position is UNDEFINED,
    this step produces the value 0).

7.  ReturnIfAbrupt(pos).

8.  Let len be the number of elements in S.

9.  Let start be min(max(pos, 0), len).

10. Let searchLength be the number of elements in searchStr.

11. If searchLength+start is greater than len, return FALSE.

12. If the searchLength sequence of elements of S starting at
    start is the same as the full element sequence of searchStr,
    return TRUE.

13. Otherwise, return FALSE.

The LENGTH property of the STARTSWITH method is 1.

NOTE 1 This method returns TRUE if the sequence of elements of
searchString converted to a String is the same as the corresponding
elements of this object (converted to a String) starting at position.
Otherwise returns FALSE.

NOTE 2 The STARTSWITH function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

String.prototype.endsWith (searchString [, endPosition] )

The following steps are taken:

1.  Let O be CheckObjectCoercible(THIS value).

2.  Let S be ToString(O).

3.  ReturnIfAbrupt(S).

4.  Let searchStr be ToString(searchString).

5.  ReturnIfAbrupt(searchStr).

6.  Let len be the number of elements in S.

7.  If endPosition is UNDEFINED, let pos be len, else let pos be
    ToInteger(endPosition).

8.  ReturnIfAbrupt(pos).

9.  Let end be min(max(pos, 0), len).

10. Let searchLength be the number of elements in searchStr.

11. Let start be end - searchLength.

12. If start is less than 0, return FALSE.

13. If the searchLength sequence of elements of S starting at
    start is the same as the full element sequence of searchStr,
    return TRUE.

14. Otherwise, return FALSE.

The LENGTH property of the ENDSWITH method is 1.

NOTE 1 Returns TRUE if the sequence of elements of searchString
converted to a String is the same as the corresponding elements of this
object (converted to a String) starting at endPosition – length(this).
Otherwise returns FALSE.

NOTE 2 The ENDSWITH function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

String.prototype.contains (searchString, position = 0 )

The CONTAINS method takes two arguments, searchString and position,
and performs the following steps:

1.  Let O be CheckObjectCoercible(THIS value).

2.  Let S be ToString(O).

3.  ReturnIfAbrupt(S).

4.  Let searchStr be ToString(searchString).

5.  ReturnIfAbrupt(searchStr).

6.  Let pos be ToInteger(position). (If position is UNDEFINED,
    this step produces the value 0).

7.  ReturnIfAbrupt(pos).

8.  Let len be the number of elements in S.

9.  Let start be min(max(pos, 0), len).

10. Let searchLen be the number of elements in searchStr.

11. If there exists any integer k not smaller than start such that
    k + searchLen is not greater than len, and for all nonnegative
    integers j less than searchLen, the character at position
    k_+_j of S is the same as the character at position j of
    searchStr, return TRUE; but if there is no such integer k,
    return FALSE.

The LENGTH property of the CONTAINS method is 1.

NOTE 1 If searchString appears as a substring of the result of
converting this object to a String, at one or more positions that are
greater than or equal to position, then return TRUE; otherwise,
returns FALSE. If position is UNDEFINED, 0 is assumed, so as to search
all of the String.

NOTE 2 The CONTAINS function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

String.prototype.codePointAt (pos)

NOTE Returns a Number (a nonnegative integer less than 1114112) that is
the UTF-16 encoded code point value starting at the string element at
position pos in the String resulting from converting this object to a
String. If there is no element at that position, the result is NAN. If a
valid UTF-16 surrogate pair does not begin at pos, the result is the
code unit at pos.

When the CODEPOINTAT method is called with one argument pos, the
following steps are taken:

1.  Let O be CheckObjectCoercible(THIS value).

2.  Let S be ToString(O).

3.  ReturnIfAbrupt(S).

4.  Let position be ToInteger(pos).

5.  ReturnIfAbrupt(position).

6.  Let size be the number of elements in S.

7.  If position < 0 or position ≥ size, return UNDEFINED.

8.  Let first be the code unit value of the element at index
    position in the String S.

9.  If first < 0xD800 or first > 0xDBFF or position+1 = size,
    then return first.

10. Let second be the code unit value of the element at index
    position+1 in the String S.

11. If second < 0xDC00 or second > 0xDFFF, then return first.

12. Return ((first – 0xD800) × 1024) + (second – 0xDC00) + 0x10000.

NOTE The CODEPOINTAT function is intentionally generic; it does not
require that its THIS value be a String object. Therefore it can be
transferred to other kinds of objects for use as a method.

String.prototype.normalize ( form = "NFC" )

When the NORMALIZE method is called with one argument form, the
following steps are taken:

1.  Let O be CheckObjectCoercible(THIS value).

2.  Let S be ToString(O).

3.  ReturnIfAbrupt(S).

4.  If form is not provided or UNDEFINED let form be "NFC".

5.  Let f be ToString(form).

6.  ReturnIfAbrupt(f).

7.  If f is not one of "NFC", "NFD", "NFKC", or "NFKD", then throw a
    RANGEERROR Exception.

8.  Let ns be the String value is the result of normalizing S into
    the normalization form named by f as specified in _UTR 15, Unicode
    Normalization Forms_.

9.  Return ns.

NOTE The NORMALIZE function is intentionally generic; it does not
require that its THIS value be a String object. Therefore it can be
transferred to other kinds of objects for use as a method.

Properties of String Instances

String instances are String exotic objects and have the internal methods
specified for such objects. String instances inherit properties from the
String prototype object. String instances also have a [[StringData]]
internal data property.

String instances have a LENGTH property, and a set of enumerable
properties with integer indexed names.

length

The number of elements in the String value represented by this String
object.

Once a String object is initialised, this property is unchanging. It has
the attributes { [[Writable]]: FALSE, [[Enumerable]]: FALSE,
[[Configurable]]: FALSE }.


Boolean Objects

The Boolean Constructor 

The Boolean constructor is the %Boolean% intrinsic object and the
initial value of the BOOLEAN property of the global object. When BOOLEAN
is called as a function rather than as a constructor, it performs a type
conversion. However, if the THIS value passed in the call is an Object
with an uninitialised [[BooleanData]] internal data property, it
initialises the THIS value using the argument value. This permits
BOOLEAN to be used both to perform type conversion and to perform
constructor instance initialization.

The BOOLEAN constructor is designed to be subclassable. It may be used
as the value of an EXTENDS clause of a class declaration. Subclass
constructors that intended to inherit the specified BOOLEAN behaviour
must include a SUPER call to the BOOLEAN constructor to initialise the
[[BooleanData]] state of subclass instances.

 Boolean (value)

When BOOLEAN is called with argument value, the following steps are
taken:

1.  Let O be the THIS value.

2.  Let b be ToBoolean(value).

3.  If Type(O) is Object and O has a [[BooleanData]] internal data
    property and the value of [[BooleanData]] is UNDEFINED, then

    a.  Set the value of O’s [[BooleanData]] internal data property to
        b.

    b.  Return O.

4.  Return b.

new Boolean (... argumentsList)

BOOLEAN called as part of a new expression , it initialises a newly
created object:

1.  Let F be the BOOLEAN function object on which the NEW operator was
    applied.

2.  Let argumentsList be the argumentsList argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of OrdinaryConstruct (F, argumentsList).

If BOOLEAN is implemented as an ordinary function object, its
[[Construct]] internal method will perform the above steps.

Properties of the Boolean Constructor

The value of the [[Prototype]] internal data property of the Boolean
constructor is the Function prototype object (‎15.3.3).

Besides the LENGTH property (whose value is 1), the Boolean constructor
has the following property:

Boolean.prototype

The initial value of BOOLEAN.PROTOTYPE is the Boolean prototype object
(15.6.4).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Boolean[ @@create ] ( )

The @@create method of an object F performs the following steps:

1.  Let F be the THIS value.

2.  Let obj be the result of calling
    OrdinaryCreateFromConstructor(F, "%BOOLEANPROTOTYPE%", (
    [[BooleanData]]) ).

3.  Return obj.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

NOTE [[BooleanData]] is initially assigned the value UNDEFINED as a flag
to indicate that the instance has not yet been initialised by the
Boolean constructor. This flag value is never directly exposed to
ECMAScript code; hence implementation may choose to encode the flag in
some other manner.

Properties of the Boolean Prototype Object

The Boolean prototype object is an ordinary object. It is not a Boolean
instance and does not have a [[BooleanData]] internal data property.

The value of the [[Prototype]] internal data property of the Boolean
prototype object is the standard built-in Object prototype object
(15.2.4).

The abstract operation thisBooleanValue(value) performs the following
steps:

1.  If Type(value) is Boolean, return value.

2.  If Type(value) is Object and value has a [[BooleanData]]
    internal data property, then

    a.  Let b be the value of value’s [[BooleanData]] internal data
        property.

    b.  If b is not UNDEFINED, then return b.

3.  Throw a TYPEERROR exception.

Boolean.prototype.constructor

The initial value of BOOLEAN.PROTOTYPE.CONSTRUCTOR is the built-in
BOOLEAN constructor.

Boolean.prototype.toString ( )

The following steps are taken:

Boolean.prototype.valueOf ( )

The following steps are taken:

Properties of Boolean Instances

Boolean instances are ordinary objects that inherit properties from the
Boolean prototype object. Boolean instances have a [[BooleanData]]
internal data property.

The [[BooleanData]] internal data property is the Boolean value
represented by this Boolean object.


Number Objects

The Number Constructor 

The Number constructor is the %Number% intrinsic object and the initial
value of the NUMBER property of the global object. When NUMBER is called
as a function rather than as a constructor, it performs a type
conversion. However, if the THIS value value passed in the call is an
Object with an uninitialised [[NumberData]] internal data property, it
initialises the THIS value using the argument value. This permits NUMBER
to be used both to perform type conversion and to perform constructor
instance initialization.

The NUMBER constructor is designed to be subclassable. It may be used as
the value of an EXTENDS clause of a class declaration. Subclass
constructors that intended to inherit the specified NUMBER behaviour
must include a SUPER call to the NUMBER constructor to initialise the
[[NumberData]] state of subclass instances.

Number ( [ value ] )

When NUMBER is called with argument number, the following steps are
taken:

1.  Let O be the THIS value.

2.  If no arguments were passed to this function invocation, then let
    n be +0.

3.  Else, let n be ToNumber(value).

4.  ReturnIfAbrupt(n).

5.  If Type(O) is Object and O has a [[NumberData]] internal data
    property and the value of [[NumberData]] is UNDEFINED, then

    a.  Set the value of O’s [[NumberData]] internal data property to
        n.

    b.  Return O.

6.  Return n.

new Number ( ...argumentsList)

NUMBER called as part of a new expression with argument list
argumentsListit performs the following steps:

1.  Let F be the NUMBER function object on which the NEW operator was
    applied.

2.  Let argumentsList be the argumentsList argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of OrdinaryConstruct (F, argumentsList).

If NUMBER is implemented as an ordinary function object, its
[[Construct]] internal method will perform the above steps.

Properties of the Number Constructor

The value of the [[Prototype]] internal data property of the Number
constructor is the Function prototype object (‎15.3.3).

Besides the LENGTH property (whose value is 1), the Number constructor
has the following properties:

Number.prototype

The initial value of NUMBER.PROTOTYPE is the Number prototype object
(‎15.7.3).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

 Number.MAX_VALUE

The value of NUMBER.MAX_VALUE is the largest positive finite value of
the Number type, which is approximately 1.7976931348623157 × 10^308^.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Number.MIN_VALUE

The value of NUMBER.MIN_VALUE is the smallest positive value of the
Number type, which is approximately 5 × 10^324^.

In the IEEE-764 double precision binary representation, the smallest
possible value is a denormalized number. If an implementation does not
support denormalized values, the value of NUMBER.MIN_VALUE must be the
smallest non-zero positive value that can actually be represented by the
implementation.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Number.NaN

The value of NUMBER.NAN is NAN.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Number.NEGATIVE_INFINITY

The value of Number.NEGATIVE_INFINITY is −∞.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Number.POSITIVE_INFINITY

The value of Number.POSITIVE_INFINITY is +∞.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Number.EPSILON

The value of Number.EPSILON is the difference between 1 and the smallest
value greater than 1 that is representable as a Number value, which is
approximately 2.2204460492503130808472633361816 x 10^-16^.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Number.MAXSAFEINTEGER

The value of Number.MAXSAFEINTEGER is 9007199254740991 (2^53^-1).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Number.parseInt (string, radix)

The value of the NUMBER.PARSEINT data property is the same built-in
function object that is the value of the PARSEINT property of the global
object defined in ‎15.1.2.2.

Number.parseFloat (string)

The value of the NUMBER.PARSEFLOAT data property is the same built-in
function object that is the value of the PARSEFLOAT property of the
global object defined in ‎15.1.2.3.

Number.isNaN (number)

When the NUMBER.ISNAN is called with one argument number, the
following steps are taken:

1.  If Type(number) is not Number, return FALSE.

2.  If number is NAN, return TRUE.

3.  Otherwise, return FALSE.

NOTE This function differs from the global isNaN function (‎15.1.2.4) is
that it does not convert its argument to a Number before determining
whether it is NaN.

Number.isFinite (number)

When the NUMBER.ISFINITE is called with one argument number, the
following steps are taken:

Number.isInteger (number)

When the NUMBER.ISINTEGER is called with one argument number, the
following steps are taken:

1.  If Type(number) is not Number, return FALSE.

2.  If number is NAN, +∞, or −∞, return FALSE.

3.  Let integer be ToInteger(number).

4.  If integer is not equal to number, return FALSE.

5.  Otherwise, return TRUE.

Number.isSafeInteger (number)

When the NUMBER.ISSAFEINTEGER is called with one argument number, the
following steps are taken:

1.  If Type(number) is not Number, return FALSE.

2.  If number is NAN, +∞, or −∞, return FALSE.

3.  Let integer be ToInteger(number).

4.  If integer is not equal to number, return FALSE.

5.  If abs(integer) ≤ 2^53^-1, then return TRUE.

6.  Otherwise, return FALSE.

1.  

Number[ @@create ] ( )

The @@create method of an object F performs the following steps:

1.  Let F be the THIS value.

2.  Let obj be the result of calling
    OrdinaryCreateFromConstructor(F, "%NUMBERPROTOTYPE%", (
    [[NumberData]])).

3.  Return obj.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

NOTE [[NumberData]] is initially assigned the value UNDEFINED as a flag
to indicate that the instance has not yet been initialised by the Number
constructor. This flag value is never directly exposed to ECMAScript
code; hence implementation may choose to encode the flag in some other
manner.

Properties of the Number Prototype Object

The Number prototype object is an ordinary object. It is not a Number
instance and does not have a [[NumberData]] internal data property.

The value of the [[Prototype]] internal data property of the Number
prototype object is the standard built-in Object prototype object
(15.2.4).

Unless explicitly stated otherwise, the methods of the Number prototype
object defined below are not generic and the THIS value passed to them
must be either a Number value or an object that has a [[NumberData]]
internal data property that has been initialised to a Number value.

The abstract operation thisNumberValue(value) performs the following
steps:

1.  If Type(value) is Number, return value.

2.  If Type(value) is Object and value has a [[NumberData]] internal
    data property, then

    a.  Let n be the value of value’s [[NumberData]] internal data
        property.

    b.  If n is not UNDEFINED, then return n.

3.  Throw a TYPEERROR exception.

The phrase “this Number value” within the specification of a method
refers to the result returned by calling the abstract operation
thisNumberValue with the THIS value of the method invocation passed as
the argument.

Number.prototype.constructor

The initial value of NUMBER.PROTOTYPE.CONSTRUCTOR is the built-in NUMBER
constructor.

 Number.prototype.toString ( [ radix ] )

The optional radix should be an integer value in the inclusive range 2
to 36. If radix not present or is UNDEFINED the Number 10 is used as
the value of radix. If ToInteger(radix) is the Number 10 then this
Number value is given as an argument to the ToString abstract operation;
the resulting String value is returned.

If ToInteger(radix) is not an integer between 2 and 36 inclusive throw
a RANGEERROR exception. If ToInteger(radix) is an integer from 2 to
36, but not 10, the result is a String representation of this Number
value using the specified radix. Letters A-Z are used for digits with
values 10 through 35. The precise algorithm is implementation-dependent
if the radix is not 10, however the algorithm should be a generalisation
of that specified in 9.1.8.1.

The TOSTRING function is not generic; it throws a TYPEERROR exception if
its THIS value is not a Number or a Number object. Therefore, it cannot
be transferred to other kinds of objects for use as a method.

Number.prototype.toLocaleString()

Produces a String value that represents this Number value formatted
according to the conventions of the host environment’s current locale.
This function is implementation-dependent, and it is permissible, but
not encouraged, for it to return the same thing as TOSTRING.

NOTE The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that implementations
do not use this parameter position for anything else.

Number.prototype.valueOf ( )

1.  Let x be thisNumberValue(THIS value).

2.  Return x.

Number.prototype.toFixed (fractionDigits)

Note TOFIXED returns a String containing this Number value represented
in decimal fixed-point notation with fractionDigits digits after the
decimal point. If fractionDigits is UNDEFINED, 0 is assumed.

The following steps are performed:

1.  Let x be thisNumberValue(THIS value).

2.  ReturnIfAbrupt(x).

3.  Let f be ToInteger(fractionDigits). (If fractionDigits is
    UNDEFINED, this step produces the value 0).

4.  ReturnIfAbrupt(f).

5.  If f < 0 or f > 20, throw a RANGEERROR exception.

6.  7.  8.  If x is NAN, return the String "NAN".

9.  Let s be the empty String.

10. If x < 0, then

    a.  Let s be "-".

    b.  Let x = –x.

11. If x ≥ 10^21^, then

    a.  Let m = ToString(x).

12. Else x < 10^21^,

    a.  Let n be an integer for which the exact mathematical value of
        n ÷ 10^f^ – x is as close to zero as possible. If there are
        two such n, pick the larger n.

    b.  If n = 0, let m be the String "0". Otherwise, let m be the
        String consisting of the digits of the decimal representation of
        n (in order, with no leading zeroes).

    c.  If f ≠ 0, then

        i.  Let k be the number of elements in m.

        ii. If k ≤ f, then

            1.  Let z be the String consisting of f_+1–_k
                occurrences of the code unit 0x0030.

            2.  Let m be the concatenation of Strings z and m.

            3.  Let k = f + 1.

        iii. Let a be the first k_–_f elements of m, and let b
            be the remaining f elements of m.

        iv. Let m be the concatenation of the three Strings a, ".",
            and b.

13. Return the concatenation of the Strings s and m.

The LENGTH property of the TOFIXED method is 1.

If the TOFIXED method is called with more than one argument, then the
behaviour is undefined (see clause 15).

An implementation is permitted to extend the behaviour of TOFIXED for
values of fractionDigits less than 0 or greater than 20. In this case
TOFIXED would not necessarily throw RANGEERROR for such values.

NOTE The output of TOFIXED may be more precise than TOSTRING for some
values because toString only prints enough significant digits to
distinguish the number from adjacent number values. For example,

(1000000000000000128).TOSTRING() returns "1000000000000000100",
while (1000000000000000128).TOFIXED(0) returns "1000000000000000128".

Number.prototype.toExponential (fractionDigits)

Return a String containing this Number value represented in decimal
exponential notation with one digit before the significand's decimal
point and fractionDigits digits after the significand's decimal point.
If fractionDigits is UNDEFINED, include as many significand digits as
necessary to uniquely specify the Number (just like in ToString except
that in this case the Number is always output in exponential notation).
Specifically, perform the following steps:

1.  Let x be thisNumberValue(THIS value).

2.  ReturnIfAbrupt(x).

3.  Let f be ToInteger(fractionDigits).

4.  Assert: f is 0, when fractionDigits is UNDEFINED.

5.  ReturnIfAbrupt(f).

6.  If x is NAN, return the String "NAN".

7.  Let s be the empty String.

8.  If x < 0, then

    a.  Let s be "-".

    b.  Let x = –x.

9.  If x = +∞, then

    a.  Return the concatenation of the Strings s and "INFINITY".

10. If f < 0 or f > 20, throw a RANGEERROR exception.

11. If x = 0, then

    a.  b.  Let m be the String consisting of f+1 occurrences of the
        code unit 0x0030.

    c.  Let e = 0.

12. Else x ≠ 0,

    a.  If fractionDigits is not UNDEFINED, then

        i.  Let e and n be integers such that 10^f^ ≤ n <
            10^f+1^ and for which the exact mathematical value of n
            × 10^e_–_f^ – x is as close to zero as possible. If
            there are two such sets of e and n, pick the e and n
            for which n × 10^e_–_f^ is larger.

    b.  Else fractionDigits is UNDEFINED,

        i.  Let e, n, and f be integers such that f ≥ 0, 10^f^
            ≤ n < 10^f+1^, the number value for n × 10^e_–_f^ is
            x, and f is as small as possible. Note that the decimal
            representation of n has f+1 digits, n is not divisible
            by 10, and the least significant digit of n is not
            necessarily uniquely determined by these criteria.

    c.  Let m be the String consisting of the digits of the decimal
        representation of n (in order, with no leading zeroes).

13. If f ≠ 0, then

    a.  Let a be the first element of m, and let b be the
        remaining f elements of m.

    b.  Let m be the concatenation of the three Strings a, ".", and
        b.

14. If e = 0, then

    a.  Let c = "+".

    b.  Let d = "0".

15. Else

    a.  If e > 0, then let c = "+".

    b.  Else e ≤ 0,

        i.  Let c = "-".

        ii. Let e = –e.

    c.  Let d be the String consisting of the digits of the decimal
        representation of e (in order, with no leading zeroes).

16. Let m be the concatenation of the four Strings m, "E", c, and
    d.

17. Return the concatenation of the Strings s and m.

The LENGTH property of the TOEXPONENTIAL method is 1.

If the TOEXPONENTIAL method is called with more than one argument, then
the behaviour is undefined (see clause 15).

An implementation is permitted to extend the behaviour of TOEXPONENTIAL
for values of fractionDigits less than 0 or greater than 20. In this
case TOEXPONENTIAL would not necessarily throw RANGEERROR for such
values.

NOTE For implementations that provide more accurate conversions than
required by the rules above, it is recommended that the following
alternative version of step 9.b.i be used as a guideline:

i.  Let e, n, and f be integers such that f ≥ 0, 10^f^ ≤ n <
    10^f+1^, the number value for n × 10^e_–_f^ is x, and f is as
    small as possible. If there are multiple possibilities for n,
    choose the value of n for which n × 10^e_–_f^ is closest in
    value to x. If there are two such possible values of n, choose
    the one that is even.

Number.prototype.toPrecision (precision)

Return a String containing this Number value represented either in
decimal exponential notation with one digit before the significand's
decimal point and precision–1 digits after the significand's decimal
point or in decimal fixed notation with precision significant digits.
If precision is UNDEFINED, call ToString (9.8.1) instead.
Specifically, perform the following steps:

The LENGTH property of the TOPRECISION method is 1.

If the TOPRECISION method is called with more than one argument, then
the behaviour is undefined (see clause 15).

An implementation is permitted to extend the behaviour of TOPRECISION
for values of precision less than 1 or greater than 21. In this case
TOPRECISION would not necessarily throw RANGEERROR for such values.

Number.prototype.clz ()

When NUMBER.PROTOTYPE.CLZ is called with one argument number, the
following steps are taken:

1.  Let x be thisNumberValue(THIS value).

2.  Let n be ToUint32(x).

3.  ReturnIfAbrupt(n).

4.  Let p be the number of leading zero bits in the 32-bit binary
    representation of n.

5.  Return p.

NOTE If n is 0, p will be 32. If the most significant bit of the
32-bit binary encoding of n is 1, p will be 0.

Properties of Number Instances

Number instances are ordinary objects that inherit properties from the
Number prototype object. Number instances also have a [[NumberData]]
internal data property.

The [[NumberData]] internal data property is the Number value
represented by this Number object.


The Math Object

The Math object is a single ordinary object.

The value of the [[Prototype]] internal data property of the Math object
is the standard built-in Object prototype object (15.2.4). The Math
object has a [[MathTag]] internal data property whose value is TRUE.

The Math is not a function object. It does not have a [[Construct]]
internal method; it is not possible to use the Math object as a
constructor with the NEW operator.

The Math object also does not have a [[Call]] internal method; it is not
possible to invoke the Math object as a function.

NOTE In this specification, the phrase “the Number value for x” has a
technical meaning defined in 8.5.

Value Properties of the Math Object

Math.E

The Number value for e, the base of the natural logarithms, which is
approximately 2.7182818284590452354.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

 Math.LN10

The Number value for the natural logarithm of 10, which is approximately
2.302585092994046.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Math.LN2

The Number value for the natural logarithm of 2, which is approximately
0.6931471805599453.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Math.LOG2E

The Number value for the base-2 logarithm of e, the base of the
natural logarithms; this value is approximately 1.4426950408889634.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

NOTE The value of MATH.LOG2E is approximately the reciprocal of the
value of MATH.LN2.

Math.LOG10E

The Number value for the base-10 logarithm of e, the base of the
natural logarithms; this value is approximately 0.4342944819032518.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

NOTE The value of MATH.LOG10E is approximately the reciprocal of the
value of MATH.LN10.

Math.PI

The Number value for π, the ratio of the circumference of a circle to
its diameter, which is approximately 3.1415926535897932.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Math.SQRT1_2

The Number value for the square root of ½, which is approximately
0.7071067811865476.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

NOTE The value of MATH.SQRT1_2 is approximately the reciprocal of the
value of MATH.SQRT2.

Math.SQRT2

The Number value for the square root of 2, which is approximately
1.4142135623730951.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Function Properties of the Math Object

Each of the following MATH object functions applies the ToNumber
abstract operation to each of its arguments (in left-to-right order if
there is more than one). If ToNumber returns an abrupt completion, that
completion record is immediately returned. Otherwise, the function
performs a computation on the resulting Number value(s).

In the function descriptions below, the symbols NaN, −0, +0, −∞ and +∞
refer to the Number values described in 8.5.

NOTE The behaviour of the functions ACOS, ACOSH, ASIN, ASINH, ATAN,
ATANH, ATAN2, CBRT, COS, COSH, EXP, HYPOT, LOG,LOG1P, LOG2, LOG10, POW,
SIN, SINH, SQRT, TAN, and TANH is not precisely specified here except to
require specific results for certain argument values that represent
boundary cases of interest. For other argument values, these functions
are intended to compute approximations to the results of familiar
mathematical functions, but some latitude is allowed in the choice of
approximation algorithms. The general intent is that an implementer
should be able to use the same mathematical library for ECMAScript on a
given hardware platform that is available to C programmers on that
platform.

Although the choice of algorithms is left to the implementation, it is
recommended (but not specified by this standard) that implementations
use the approximation algorithms for IEEE 754 arithmetic contained in
FDLIBM, the freely distributable mathematical library from Sun
Microsystems (http://www.netlib.org/fdlibm).

Math.abs (x)

Returns the absolute value of x; the result has the same magnitude as
x but has positive sign.

-   If x is NaN, the result is NaN.

-   If x is −0, the result is +0.

-   If x is −∞, the result is +∞.

Math.acos (x)

Returns an implementation-dependent approximation to the arc cosine of
x. The result is expressed in radians and ranges from +0 to +π.

-   If x is NaN, the result is NaN.

-   If x is greater than 1, the result is NaN.

-   If x is less than −1, the result is NaN.

-   If x is exactly 1, the result is +0.

Math.asin (x)

Returns an implementation-dependent approximation to the arc sine of
x. The result is expressed in radians and ranges from −π/2 to +π/2.

-   If x is NaN, the result is NaN.

-   If x is greater than 1, the result is NaN.

-   If x is less than –1, the result is NaN.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

Math.atan (x)

Returns an implementation-dependent approximation to the arc tangent of
x. The result is expressed in radians and ranges from −π/2 to +π/2.

-   If x is NaN, the result is NaN.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

-   If x is +∞, the result is an implementation-dependent
      approximation to +π/2.

-   If x is −∞, the result is an implementation-dependent
      approximation to −π/2.

Math.atan2 (y, x)

Returns an implementation-dependent approximation to the arc tangent of
the quotient y_/_x of the arguments y and x, where the signs of
y and x are used to determine the quadrant of the result. Note that
it is intentional and traditional for the two-argument arc tangent
function that the argument named y be first and the argument named x
be second. The result is expressed in radians and ranges from −π to +π.

-   If either x or y is NaN, the result is NaN.

-   If y>0 and x is +0, the result is an implementation-dependent
      approximation to +π/2.

-   If y>0 and x is −0, the result is an implementation-dependent
      approximation to +π/2.

-   If y is +0 and x>0, the result is +0.

-   If y is +0 and x is +0, the result is +0.

-   If y is +0 and x is −0, the result is an
      implementation-dependent approximation to +π.

-   If y is +0 and x<0, the result is an implementation-dependent
      approximation to +π.

-   If y is −0 and x>0, the result is −0.

-   If y is −0 and x is +0, the result is −0.

-   If y is −0 and x is −0, the result is an
      implementation-dependent approximation to −π.

-   If y is −0 and x<0, the result is an implementation-dependent
      approximation to −π.

-   If y<0 and x is +0, the result is an implementation-dependent
      approximation to −π/2.

-   If y<0 and x is −0, the result is an implementation-dependent
      approximation to −π/2.

-   If y>0 and y is finite and x is +∞, the result is +0.

-   If y>0 and y is finite and x is −∞, the result if an
      implementation-dependent approximation to +π.

-   If y<0 and y is finite and x is +∞, the result is −0.

-   If y<0 and y is finite and x is −∞, the result is an
      implementation-dependent approximation to −π.

-   If y is +∞ and x is finite, the result is an
      implementation-dependent approximation to +π/2.

-   If y is −∞ and x is finite, the result is an
      implementation-dependent approximation to −π/2.

-   If y is +∞ and x is +∞, the result is an
      implementation-dependent approximation to +π/4.

-   If y is +∞ and x is −∞, the result is an
      implementation-dependent approximation to +3π/4.

-   If y is −∞ and x is +∞, the result is an
      implementation-dependent approximation to −π/4.

-   If y is −∞ and x is −∞, the result is an
      implementation-dependent approximation to −3π/4.

Math.ceil (x)

Returns the smallest (closest to −∞) Number value that is not less than
x and is equal to a mathematical integer. If x is already an
integer, the result is x.

-   If x is NaN, the result is NaN.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

-   If x is +∞, the result is +∞.

-   If x is −∞, the result is −∞.

-   If x is less than 0 but greater than -1, the result is −0.

The value of MATH.CEIL(X) is the same as the value of -MATH.FLOOR(-X).

Math.cos (x)

Returns an implementation-dependent approximation to the cosine of x.
The argument is expressed in radians.

-   If x is NaN, the result is NaN.

-   If x is +0, the result is 1.

-   If x is −0, the result is 1.

-   If x is +∞, the result is NaN.

-   If x is −∞, the result is NaN.

Math.exp (x)

Returns an implementation-dependent approximation to the exponential
function of x (e raised to the power of x, where e is the base
of the natural logarithms).

-   If x is NaN, the result is NaN.

-   If x is +0, the result is 1.

-   If x is −0, the result is 1.

-   If x is +∞, the result is +∞.

-   If x is −∞, the result is +0.

Math.floor (x)

Returns the greatest (closest to +∞) Number value that is not greater
than x and is equal to a mathematical integer. If x is already an
integer, the result is x.

-   If x is NaN, the result is NaN.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

-   If x is +∞, the result is +∞.

-   If x is −∞, the result is −∞.

-   If x is greater than 0 but less than 1, the result is +0.

NOTE The value of MATH.FLOOR(X) is the same as the value of
-MATH.CEIL(-X).

Math.log (x)

-   Returns an implementation-dependent approximation to the natural
      logarithm of x.

-   If x is NaN, the result is NaN.

-   If x is less than 0, the result is NaN.

-   If x is +0 or −0, the result is −∞.

-   If x is 1, the result is +0.

-   If x is +∞, the result is +∞.

Math.max ( [ value1 [ , value2 [ , … ] ] ] )

Given zero or more arguments, calls ToNumber on each of the arguments
and returns the largest of the resulting values.

-   If no arguments are given, the result is −∞.

-   If any value is NaN, the result is NaN.

-   The comparison of values to determine the largest value is done
      using the Abstract Relational Comparison algorithm ( 11.8.1)
      except that +0 is considered to be larger than −0.

The LENGTH property of the MAX method is 2.

Math.min ( [ value1 [ , value2 [ , … ] ] ] )

Given zero or more arguments, calls ToNumber on each of the arguments
and returns the smallest of the resulting values.

-   If no arguments are given, the result is +∞.

-   If any value is NaN, the result is NaN.

-   The comparison of values to determine the smallest value is done
      using the Abstract Relational Comparison algorithm (11.8.1) except
      that +0 is considered to be larger than −0.

The LENGTH property of the MIN method is 2.

Math.pow (x, y)

Returns an implementation-dependent approximation to the result of
raising x to the power y.

-   If y is NaN, the result is NaN.

-   If y is +0, the result is 1, even if x is NaN.

-   If y is −0, the result is 1, even if x is NaN.

-   If x is NaN and y is nonzero, the result is NaN.

-   If abs(x)>1 and y is +∞, the result is +∞.

-   If abs(x)>1 and y is −∞, the result is +0.

-   If abs(x) is 1 and y is +∞, the result is NaN.

-   If abs(x) is 1 and y is −∞, the result is NaN.

-   If abs(x)<1 and y is +∞, the result is +0.

-   If abs(x)<1 and y is −∞, the result is +∞.

-   If x is +∞ and y>0, the result is +∞.

-   If x is +∞ and y<0, the result is +0.

-   If x is −∞ and y>0 and y is an odd integer, the result is −∞.

-   If x is −∞ and y>0 and y is not an odd integer, the result
      is +∞.

-   If x is −∞ and y<0 and y is an odd integer, the result is −0.

-   If x is −∞ and y<0 and y is not an odd integer, the result
      is +0.

-   If x is +0 and y>0, the result is +0.

-   If x is +0 and y<0, the result is +∞.

-   If x is −0 and y>0 and y is an odd integer, the result is −0.

-   If x is −0 and y>0 and y is not an odd integer, the result
      is +0.

-   If x is −0 and y<0 and y is an odd integer, the result is −∞.

-   If x is −0 and y<0 and y is not an odd integer, the result
      is +∞.

-   If x<0 and x is finite and y is finite and y is not an
      integer, the result is NaN.

Math.random ( )

Returns a Number value with positive sign, greater than or equal to 0
but less than 1, chosen randomly or pseudo randomly with approximately
uniform distribution over that range, using an implementation-dependent
algorithm or strategy. This function takes no arguments.

Math.round (x)

Returns the Number value that is closest to x and is equal to a
mathematical integer. If two integer Number values are equally close to
x, then the result is the Number value that is closer to +∞. If x is
already an integer, the result is x.

-   If x is NaN, the result is NaN.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

-   If x is +∞, the result is +∞.

-   If x is −∞, the result is −∞.

-   If x is greater than 0 but less than 0.5, the result is +0.

-   If x is less than 0 but greater than or equal to -0.5, the result
      is −0.

NOTE 1 MATH.ROUND(3.5) returns 4, but MATH.ROUND(–3.5) returns –3.

NOTE 2 The value of MATH.ROUND(X) is the same as the value of
MATH.FLOOR(X+0.5), except when X is −0 or is less than 0 but greater
than or equal to -0.5; for these cases MATH.ROUND(X) returns −0, but
MATH.FLOOR(X+0.5) returns +0.

Math.sin (x)

Returns an implementation-dependent approximation to the sine of x.
The argument is expressed in radians.

-   If x is NaN, the result is NaN.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

-   If x is +∞ or −∞, the result is NaN.

Math.sqrt (x)

Returns an implementation-dependent approximation to the square root of
x.

-   If x is NaN, the result is NaN.

-   If x is less than 0, the result is NaN.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

-   If x is +∞, the result is +∞.

Math.tan (x)

Returns an implementation-dependent approximation to the tangent of x.
The argument is expressed in radians.

-   If x is NaN, the result is NaN.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

-   If x is +∞ or −∞, the result is NaN.

Math.log10 (x)

Returns an implementation-dependent approximation to the base 10
logarithm of x.

-   If x is NaN, the result is NaN.

-   If x is less than 0, the result is NaN.

-   If x is +0, the result is −∞.

-   If x is −0, the result is −∞.

-   If x is 1, the result is +0.

-   If x is +∞, the result is +∞.

Math.log2 (x)

Returns an implementation-dependent approximation to the base 2
logarithm of x.

-   If x is NaN, the result is NaN.

-   If x is less than 0, the result is NaN.

-   If x is +0, the result is −∞.

-   If x is −0, the result is −∞.

-   If x is 1, the result is +0.

-   If x is +∞, the result is +∞.

Math.log1p (x)

Returns an implementation-dependent approximation to the natural
logarithm of 1 + x. The result is computed in a way that is accurate
even when the value of x is close to zero.

-   If x is NaN, the result is NaN.

-   If x is less than -1, the result is NaN.

-   If x is -1, the result is -∞.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

-   If x is +∞, the result is +∞.

Math.expm1 (x)

Returns an implementation-dependent approximation to subtracting 1 from
the exponential function of x (e raised to the power of x, where
e is the base of the natural logarithms). The result is computed in a
way that is accurate even when the value of x is close 0.

-   If x is NaN, the result is NaN.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

-   If x is +∞, the result is +∞.

-   If x is −∞, the result is -1.

Math.cosh(x)

Returns an implementation-dependent approximation to the hyperbolic
cosine of x.

-   If x is NaN, the result is NaN.

-   If x is +0, the result is 1.

-   If x is −0, the result is 1.

-   If x is +∞, the result is +∞.

-   If x is −∞, the result is +∞.

NOTE The value of cosh(x) is the same as _(exp(x) + exp(-x))/2_.

Math.sinh(x)

Returns an implementation-dependent approximation to the hyperbolic sine
of x.

-   If x is NaN, the result is NaN.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

-   If x is +∞, the result is +∞.

-   If x is −∞, the result is −∞.

NOTE The value of sinh(x) is the same as _(exp(x) - exp(-x))/2_.

Math.tanh(x)

Returns an implementation-dependent approximation to the hyperbolic
tangent of x.

-   If x is NaN, the result is NaN.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

-   If x is +∞, the result is +1.

-   If x is −∞, the result is -1.

NOTE The value of tanh(x) is the same as _(exp(x) - exp(-x))/(exp(x) +
exp(-x))_.

Math.acosh(x)

Returns an implementation-dependent approximation to the inverse
hyperbolic cosine of x.

-   If x is NaN, the result is NaN.

-   If x is less than 1, the result is NaN.

-   If x is 1, the result is +0.

-   If x is +∞, the result is +∞.

Math.asinh(x)

Returns an implementation-dependent approximation to the inverse
hyperbolic sine of x.

-   If x is NaN, the result is NaN.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

-   If x is +∞, the result is +∞.

-   If x is −∞, the result is −∞.

Math.atanh(x)

Returns an implementation-dependent approximation to the inverse
hyperbolic tangent of x.

-   If x is NaN, the result is NaN.

-   If x is less than −1, the result is NaN.

-   If x is greater than 1, the result is NaN.

-   If x is −1, the result is −∞.

-   If x is +1, the result is +∞.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

Math.hypot( value1 , value2, value3 = 0 )

Given two or three arguments, hypot returns an implementation-dependent
approximation of the square root of the sum of squares of up to three
arguments.

-   If any argument is +∞, the result is +∞.

-   If any argument is −∞, the result is +∞.

-   If no argument is +∞ or −∞, and any argument is NaN, the result is
      NaN.

-   -   If all arguments are either +0 or -0, the result is +0.

-   The implementation must avoid underlow.

-   The implementation must avoid overflow, where possible.

-   The implementation must minimise rounding errors.

The length property of the HYPOT function is 2.

-   -   -   -   -   

Math.trunc(x)

Returns the integral part of the number x, removing any fractional
digits. If x is already an integer, the result is x.

-   If x is NaN, the result is NaN.

-   If x is −0, the result is −0.

-   If x is +0, the result is +0.

-   If x is +∞, the result is +∞.

-   If x is −∞, the result is −∞.

-   If x is greater than 0 but less than 1, the result is +0.

-   If x is less than 0 but greater than −1, the result is −0.

Math.sign(x)No

Returns the sign of the x, indicating whether x is positive, negative or
zero.

-   If x is NaN, the result is NaN.

-   If x is −0, the result is −0.

-   If x is +0, the result is +0.

-   If x is negative and not −0, the result is −1.

-   If x is positive and not +0, the result is +1.

Math.cbrt(x)

Returns an implementation-dependent approximation to the cube root of
x.

-   If x is NaN, the result is NaN.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

-   If x is +∞, the result is +∞.

-   If x is −∞, the result is −∞.

Math.imul(x, y)

When the MATH.IMUL is called with arguments x and y the following
steps are taken:

1.  Let a be ToUint32(x).

2.  ReturnIfAbrupt(a).

3.  Let b be ToUint32(y).

4.  ReturnIfAbrupt(b).

5.  Let product be (a × b) x modulo modulo 2^32^.

6.  If product ≥ 2^31^, return product − 2^32^, otherwise return
    product.

Math.roundFloat32 (x )

When MATH.ROUNDFLOAT32 is called with argument x the following steps
are taken:

1.  If x is NaN, return NaN.

2.  If If x one of +0, −0, +∞, −∞, then return x.

3.  Let x32 be the result of converting x to a value in
    IEEE-868-2005 binary32 format using “Round to nearest, ties to even”
    rounding mode.

4.  Let x64 be the ECMAScript Number value corresponding to x32.

5.  Return x64.


Date Objects

Overview of Date Objects and Definitions of Abstract Operations

The following functions are abstract operations that operate on time
values (defined in 15.9.1.1). Note that, in every case, if any argument
to one of these functions is NAN, the result will be NAN.

Time Values and Time Range

A Date object contains a Number indicating a particular instant in time
to within a millisecond. Such a Number is called a _time value_. A time
value may also be NAN, indicating that the Date object does not
represent a specific instant of time.

Time is measured in ECMAScript in milliseconds since 01 January, 1970
UTC. In time values leap seconds are ignored. It is assumed that there
are exactly 86,400,000 milliseconds per day. ECMAScript Number values
can represent all integers from –9,007,199,254,740,992 to
9,007,199,254,740,992; this range suffices to measure times to
millisecond precision for any instant that is within approximately
285,616 years, either forward or backward, from 01 January, 1970 UTC.

The actual range of times supported by ECMAScript Date objects is
slightly smaller: exactly –100,000,000 days to 100,000,000 days measured
relative to midnight at the beginning of 01 January, 1970 UTC. This
gives a range of 8,640,000,000,000,000 milliseconds to either side of 01
January, 1970 UTC.

The exact moment of midnight at the beginning of 01 January, 1970 UTC is
represented by the value +0.

Day Number and Time within Day

A given time value t belongs to day number

  Day(t) = floor(t / msPerDay)

where the number of milliseconds per day is

  msPerDay = 86400000

The remainder is called the time within the day:

  TimeWithinDay(t) = t modulo msPerDay

Year Number

ECMAScript uses an extrapolated Gregorian system to map a day number to
a year number and to determine the month and date within that year. In
this system, leap years are precisely those which are (divisible by 4)
and ((not divisible by 100) or (divisible by 400)). The number of days
in year number y is therefore defined by

  DaysInYear(y) = 365 if (y modulo 4) ≠ 0
  = 366 if (y modulo 4) = 0 and (y modulo 100) ≠ 0
  = 365 if (y modulo 100) = 0 and (y modulo 400) ≠ 0
  = 366 if (y modulo 400) = 0

All non-leap years have 365 days with the usual number of days per month
and leap years have an extra day in February. The day number of the
first day of year y is given by:

  DayFromYear(y) = 365 × (y−1970) + floor((y−1969)/4) −
  floor((y−1901)/100) + floor((y−1601)/400)

The time value of the start of a year is:

  TimeFromYear(y) = msPerDay × DayFromYear(y)

A time value determines a year by:

  YearFromTime(t) = the largest integer y (closest to positive
  infinity) such that TimeFromYear(y) ≤ t

The leap-year function is 1 for a time within a leap year and otherwise
is zero:

  InLeapYear(t) = 0 if DaysInYear(YearFromTime(t)) = 365
  = 1 if DaysInYear(YearFromTime(t)) = 366

Month Number

Months are identified by an integer in the range 0 to 11, inclusive. The
mapping MonthFromTime(t) from a time value t to a month number is
defined by:

  MonthFromTime(t) = 0 if 0 ≤ DayWithinYear(t) < 31
   = 1 if 31 ≤ DayWithinYear (t) < 59+InLeapYear(t)
   = 2 if 59+InLeapYear(t) ≤ DayWithinYear (t) < 90+InLeapYear(t)
   = 3 if 90+InLeapYear(t) ≤ DayWithinYear (t) < 120+InLeapYear(t)
   = 4 if 120+InLeapYear(t) ≤ DayWithinYear (t) <
  151+InLeapYear(t)
   = 5 if 151+InLeapYear(t) ≤ DayWithinYear (t) <
  181+InLeapYear(t)
   = 6 if 181+InLeapYear(t) ≤ DayWithinYear (t) <
  212+InLeapYear(t)
   = 7 if 212+InLeapYear(t) ≤ DayWithinYear (t) <
  243+InLeapYear(t)
   = 8 if 243+InLeapYear(t) ≤ DayWithinYear (t) <
  273+InLeapYear(t)
   = 9 if 273+InLeapYear(t) ≤ DayWithinYear (t) <
  304+InLeapYear(t)
   = 10 if 304+InLeapYear(t) ≤ DayWithinYear (t) <
  334+InLeapYear(t)
   = 11 if 334+InLeapYear(t) ≤ DayWithinYear (t) <
  365+InLeapYear(t)

where

  DayWithinYear(t) = Day(t_)−DayFromYear(YearFromTime(_t))

A month value of 0 specifies January; 1 specifies February; 2 specifies
March; 3 specifies April; 4 specifies May; 5 specifies June; 6 specifies
July; 7 specifies August; 8 specifies September; 9 specifies October; 10
specifies November; and 11 specifies December. Note that
MonthFromTime(0) = 0, corresponding to Thursday, 01 January, 1970.

Date Number

A date number is identified by an integer in the range 1 through 31,
inclusive. The mapping DateFromTime(t) from a time value t to a
month number is defined by:

  DateFromTime(t) = DayWithinYear(t)+1 if MonthFromTime(t)=0
   = DayWithinYear(t)−30 if MonthFromTime(t)=1
   = DayWithinYear(t_)−58−InLeapYear(_t) if MonthFromTime(t)=2
   = DayWithinYear(t_)−89−InLeapYear(_t) if MonthFromTime(t)=3
   = DayWithinYear(t_)−119−InLeapYear(_t) if MonthFromTime(t)=4
   = DayWithinYear(t_)−150−InLeapYear(_t) if MonthFromTime(t)=5
   = DayWithinYear(t_)−180−InLeapYear(_t) if MonthFromTime(t)=6
   = DayWithinYear(t_)−211−InLeapYear(_t) if MonthFromTime(t)=7
   = DayWithinYear(t_)−242−InLeapYear(_t) if MonthFromTime(t)=8
   = DayWithinYear(t_)−272−InLeapYear(_t) if MonthFromTime(t)=9
   = DayWithinYear(t_)−303−InLeapYear(_t) if MonthFromTime(t)=10
   = DayWithinYear(t_)−333−InLeapYear(_t) if MonthFromTime(t)=11

Week Day

The weekday for a particular time value t is defined as

  WeekDay(t) = (Day(t) + 4) modulo 7

A weekday value of 0 specifies Sunday; 1 specifies Monday; 2 specifies
Tuesday; 3 specifies Wednesday; 4 specifies Thursday; 5 specifies
Friday; and 6 specifies Saturday. Note that WeekDay(0) = 4,
corresponding to Thursday, 01 January, 1970.

Local Time Zone Adjustment

An implementation of ECMAScript is expected to determine the local time
zone adjustment. The local time zone adjustment is a value LocalTZA
measured in milliseconds which when added to UTC represents the local
standard time. Daylight saving time is not reflected by LocalTZA.

NOTE It is recommended that implementations use the time zone
information of the IANA Time Zone Database.

Daylight Saving Time Adjustment

An implementation of ECMAScript is expected to make its best effort to
determine the local daylight saving time adjustment. An implementation
dependent algorithm using best available information on time zones to
determine the local daylight saving time adjustment
DaylightSavingTA(t), measured in milliseconds.

 Local Time

Conversion from UTC to local time is defined by

  LocalTime(t) = t + LocalTZA + DaylightSavingTA(t)

Conversion from local time to UTC is defined by

  UTC(t) = t – LocalTZA – DaylightSavingTA(t – LocalTZA)

Note that UTC(LocalTime(t)) is not necessarily always equal to t.

Hours, Minutes, Second, and Milliseconds

The following functions are useful in decomposing time values:

  HourFromTime(t) = floor(t / msPerHour) modulo HoursPerDay

  MinFromTime(t) = floor(t / msPerMinute) modulo MinutesPerHour

  SecFromTime(t) = floor(t / msPerSecond) modulo SecondsPerMinute

  msFromTime(t) = t modulo msPerSecond

where

  HoursPerDay = 24

  MinutesPerHour = 60

  SecondsPerMinute = 60

  msPerSecond = 1000

  msPerMinute = 60000 = msPerSecond × SecondsPerMinute

  msPerHour = 3600000 = msPerMinute × MinutesPerHour

MakeTime (hour, min, sec, ms)

The operator MakeTime calculates a number of milliseconds from its four
arguments, which must be ECMAScript Number values. This operator
functions as follows:

1.  If hour is not finite or min is not finite or sec is not
    finite or ms is not finite, return NAN.

2.  Let h be ToInteger(hour).

3.  Let m be ToInteger(min).

4.  Let s be ToInteger(sec).

5.  Let milli be ToInteger(ms).

6.  Let t be h * msPerHour + m * msPerMinute + s * msPerSecond +
    milli, performing the arithmetic according to IEEE 754 rules (that
    is, as if using the ECMAScript operators * and +).

7.  Return t.

MakeDay (year, month, date)

The operator MakeDay calculates a number of days from its three
arguments, which must be ECMAScript Number values. This operator
functions as follows:

MakeDate (day, time)

The operator MakeDate calculates a number of milliseconds from its two
arguments, which must be ECMAScript Number values. This operator
functions as follows:

TimeClip (time)

The operator TimeClip calculates a number of milliseconds from its
argument, which must be an ECMAScript Number value. This operator
functions as follows:

NOTE The point of step 3 is that an implementation is permitted a choice
of internal representations of time values, for example as a 64-bit
signed integer or as a 64-bit floating-point value. Depending on the
implementation, this internal representation may or may not distinguish
−0 and +0.

Date Time String Format

ECMAScript defines a string interchange format for date-times based upon
a simplification of the ISO 8601 Extended Format. The format is as
follows: YYYY-MM-DDTHH:MM:SS.SSSZ

Where the fields are as follows:

This format includes date-only forms:

YYYY
YYYY-MM
YYYY-MM-DD

It also includes “date-time” forms that consist of one of the above
date-only forms immediately followed by one of the following time forms
with an optional time zone offset appended:

THH:MM
THH:MM:SS
THH:MM:SS.SSS

All numbers must be base 10. If the MM or DD fields are absent “01” is
used as the value. If the HH, MM, or SS fields are absent “00” is used
as the value and the value of an absent SSS field is “000”. If the time
zone offset is absent, the date-time is interpreted as a local time.

Illegal values (out-of-bounds as well as syntax errors) in a format
string means that the format string is not a valid instance of this
format.

NOTE 1 As every day both starts and ends with midnight, the two
notations 00:00 and 24:00 are available to distinguish the two midnights
that can be associated with one date. This means that the following two
notations refer to exactly the same point in time: 1995-02-04T24:00 and
1995-02-05T00:00

NOTE 2 There exists no international standard that specifies
abbreviations for civil time zones like CET, EST, etc. and sometimes the
same abbreviation is even used for two very different time zones. For
this reason, ISO 8601 and this format specifies numeric representations
of date and time.

Extended years

ECMAScript requires the ability to specify 6 digit years (extended
years); approximately 285,426 years, either forward or backward, from 01
January, 1970 UTC. To represent years before 0 or after 9999, ISO 8601
permits the expansion of the year representation, but only by prior
agreement between the sender and the receiver. In the simplified
ECMAScript format such an expanded year representation shall have 2
extra year digits and is always prefixed with a + or – sign. The year 0
is considered positive and hence prefixed with a + sign.

NOTE Examples of extended years:

  -283457-03-21T15:00:59.008Z   283458 B.C.
  -000001-01-01T00:00:00Z          2 B.C.
  +000000-01-01T00:00:00Z         1 B.C.
  +000001-01-01T00:00:00Z         1 A.D.
  +001970-01-01T00:00:00Z         1970 A.D.
  +002009-12-15T00:00:00Z         2009 A.D.
  +287396-10-12T08:59:00.992Z 287396 A.D.

The Date Constructor 

The Date constructor is the %Date% intrinsic object and the initial
value of the DATE property of the global object. When DATE is called as
a function rather than as a constructor, it returns a String
representing the current time (UTC). However, if the THIS value value
passed in the call is an Object with an uninitialised [[DateValue]]
internal data property, DATE initialises the THIS object using the
argument value. This permits DATE to be used both as a function for
creating data strings and to perform constructor instance
initialization.

The DATE constructor is designed to be subclassable. It may be used as
the value of an EXTENDS clause of a class declaration. Subclass
constructors that intended to inherit the specified DATE behaviour must
include a SUPER call to the DATE constructor to initialise the
[[DateValue]] state of subclass instances.

Date (year, month [, date [, hours [, minutes [, seconds [, ms ] ] ] ] ] )

This description applies only if the Date constructor is called with at
least two arguments.

When the DATE function is called the following steps are taken:

 Date (value)

This description applies only if the Date constructor is called with
exactly one argument.

When the DATE function is called the following steps are taken:

1.  Let numberOfArgs be the number of arguments passed to this
    constructor call.

2.  Assert: numberOfArgs = 1.

3.  Let O be the THIS value.

4.  If Type(O) is Object and O has a [[DateValue]] internal data
    property and the value of [[DateValue]] is UNDEFINED, then

    a.  If Type(value) is Object and value has a [[DateValue]]
        internal data property, then

        i.  Let tv be thisTimeValue(value).

    b.  Else,

        i.  ii. iii. iv. v.  Let v be ToPrimitive(value).

        vi. If Type(v) is String, then

            1.  Let tv be the result of parsing v as a date, in
                exactly the same manner as for the PARSE method
                (15.9.4.2). If the parse resulted in an abrupt
                completion, tv is the Completion Record.

        vii. Else,

            1.  Let tv be ToNumber(v).

    c.  ReturnIfAbrupt(tv).

    d.  Set the [[DateValue]] internal data property of O to
        TimeClip(tv).

    e.  Return O.

5.  6.  Else,

    a.  Return the result computed as if by the expression (NEW
        DATE()).TOSTRING() where DATE is this function and TOSTRING is
        the standard built-in method DATE.PROTOTYPE.TOSTRING.

Date ( )

This description applies only if the Date constructor is called with no
arguments.

When the DATE function is called the following steps are taken:

1.  Let numberOfArgs be the number of arguments passed to this
      constructor call.

2.  Assert: numberOfArgs = 0.

3.  Let O be the THIS value.

4.  If Type(O) is Object and O has a [[DateValue]] internal data
      property and the value of [[DateValue]] is UNDEFINED, then

    a.  Set the [[DateValue]] internal data property of O to the time
          value (UTC) identifying the current time.

    b.  Return O.

5.  Else,

    a.  Return the result computed as if by the expression (NEW
          DATE()).TOSTRING() where DATE is this function and TOSTRING is
          the standard built-in method DATE.PROTOTYPE.TOSTRING.

new Date ( ... argumentsList)

DATE called as part of a new expression with argument list
argumentsList it performs the following steps:

1.  Let F be the DATE function object on which the NEW operator was
    applied.

2.  Let argumentsList be the argumentsList argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of OrdinaryConstruct (F, argumentsList).

If DATE is implemented as an ordinary function object, its [[Construct]]
internal method will perform the above steps.

Properties of the Date Constructor

The value of the [[Prototype]] internal data property of the Date
constructor is the Function prototype object (15.3.3).

Besides the LENGTH property (whose value is 7), the Date constructor has
the following properties:

Date.prototype

The initial value of DATE.PROTOTYPE is the built-in Date prototype
object (15.9.5).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Date.parse (string)

The PARSE function applies the ToString operator to its argument. If
ToString results in an abrupt completion the Completion Record is
immediately returned. Otherwise, PARSE interprets the resulting String
as a date and time; it returns a Number, the UTC time value
corresponding to the date and time. The String may be interpreted as a
local time, a UTC time, or a time in some other time zone, depending on
the contents of the String. The function first attempts to parse the
format of the String according to the rules called out in Date Time
String Format (15.9.1.15). If the String does not conform to that format
the function may fall back to any implementation-specific heuristics or
implementation-specific date formats. Unrecognisable Strings or dates
containing illegal element values in the format String shall cause
DATE.PARSE to return NAN.

If x is any Date object whose milliseconds amount is zero within a
particular implementation of ECMAScript, then all of the following
expressions should produce the same numeric value in that
implementation, if all the properties referenced have their initial
values:

  X.VALUEOF()

  DATE.PARSE(X.TOSTRING())

  DATE.PARSE(X.TOUTCSTRING())

  DATE.PARSE(X.TOISOSTRING())

However, the expression

  DATE.PARSE(X.TOLOCALESTRING())

is not required to produce the same Number value as the preceding three
expressions and, in general, the value produced by DATE.PARSE is
implementation-dependent when given any String value that does not
conform to the Date Time String Format (15.9.1.15) and that could not be
produced in that implementation by the TOSTRING or TOUTCSTRING method.

Date.UTC (year, month [, date [, hours [, minutes [, seconds [, ms ] ] ] ] ] )

When the UTC function is called with fewer than two arguments, the
behaviour is implementation-dependent. When the UTC function is called
with two to seven arguments, it computes the date from year, month
and (optionally) date, hours, minutes, seconds and ms. The
following steps are taken:

The LENGTH property of the UTC function is 7.

NOTE The UTC function differs from the Date constructor in two ways: it
returns a time value as a Number, rather than creating a Date object,
and it interprets the arguments in UTC rather than as local time.

Date.now ( )

The NOW function return a Number value that is the time value
designating the UTC date and time of the occurrence of the call to NOW.

Date[ @@create ] ( )

The @@create method of an object F performs the following steps:

1.  Let obj be the result of calling
    OrdinaryCreateFromConstructor(F, "%DATEPROTOTYPE%", (
    [[DateValue]])).

2.  ReturnIfAbrupt(obj).

3.  4.  5.  6.  Return obj.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

NOTE [[DateValue]] is initially assigned the value UNDEFINED as a flag
to indicate that the instance has not yet been initialised by the Date
constructor. This flag value is never directly exposed to ECMAScript
code; hence implementation may choose to encode the flag in some other
manner.

Properties of the Date Prototype Object

The Date prototype object is itself an ordinary object. It is not a Date
instance and does not have a [[DateValue]] internal data property.

The value of the [[Prototype]] internal data property of the Date
prototype object is the standard built-in Object prototype object
(15.2.4).

Unless explicitly defined otherwise, the methods of the Date prototype
object defined below are not generic and the THIS value passed to them
must be an object that has a [[DateValue]] internal data property that
has been initialised to a time value.

The abstract operation thisTimeValue(value) performs the following
steps:

1.  If Type(value) is Object and value has a [[DateValue]] internal
    data property, then

    a.  Let n be the Number that is the value of value’s
        [[NumberData]] internal data property.

    b.  If n is not UNDEFINED, then return n.

2.  Throw a TYPEERROR exception.

In following descriptions of functions that are properties of the Date
prototype object, the phrase “this Date object” refers to the object
that is the THIS value for the invocation of the function. The phrase
“this time value” within the specification of a method refers to the
result returned by calling the abstract operation thisTimeValue with the
THIS value of the method invocation passed as the argument.

Date.prototype.constructor

The initial value of DATE.PROTOTYPE.CONSTRUCTOR is the built-in DATE
constructor.

Date.prototype.toString ( )

This function returns a String value. If this time value is NaN, the
String value is "INVALID DATE", otherwise the contents of the String are
implementation-dependent, but are intended to represent the Date in the
current time zone in a convenient, human-readable form.

NOTE For any Date value d whose milliseconds amount is zero, the
result of Date.parse(d.toString()) is equal to d.valueOf(). See
15.9.4.2.

Date.prototype.toDateString ( )

This function returns a String value. The contents of the String are
implementation-dependent, but are intended to represent the “date”
portion of the Date in the current time zone in a convenient,
human-readable form.

Date.prototype.toTimeString ( )

This function returns a String value. The contents of the String are
implementation-dependent, but are intended to represent the “time”
portion of the Date in the current time zone in a convenient,
human-readable form.

Date.prototype.toLocaleString ( )

This function returns a String value. The contents of the String are
implementation-dependent, but are intended to represent the Date in the
current time zone in a convenient, human-readable form that corresponds
to the conventions of the host environment’s current locale.

NOTE The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that implementations
do not use this parameter position for anything else.

Date.prototype.toLocaleDateString ( )

This function returns a String value. The contents of the String are
implementation-dependent, but are intended to represent the “date”
portion of the Date in the current time zone in a convenient,
human-readable form that corresponds to the conventions of the host
environment’s current locale.

NOTE The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that implementations
do not use this parameter position for anything else.

Date.prototype.toLocaleTimeString ( )

This function returns a String value. The contents of the String are
implementation-dependent, but are intended to represent the “time”
portion of the Date in the current time zone in a convenient,
human-readable form that corresponds to the conventions of the host
environment’s current locale.

NOTE The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that implementations
do not use this parameter position for anything else.

Date.prototype.valueOf ( )

The VALUEOF function returns a Number, which is this time value.

Date.prototype.getTime ( )

Date.prototype.getFullYear ( )

Date.prototype.getUTCFullYear ( )

Date.prototype.getMonth ( )

Date.prototype.getUTCMonth ( )

1.  Let t be this time value.

2.  ReturnIfAbrupt(t).

3.  If t is NAN, return NAN.

4.  Return MonthFromTime(t).

Date.prototype.getDate ( )

1.  Let t be this time value.

2.  ReturnIfAbrupt(t).

3.  If t is NAN, return NAN.

4.  Return DateFromTime(LocalTime(t)).

Date.prototype.getUTCDate ( )

Date.prototype.getDay ( )

1.  Let t be this time value.

2.  ReturnIfAbrupt(t).

3.  If t is NAN, return NAN.

4.  Return WeekDay(LocalTime(t)).

Date.prototype.getUTCDay ( )

Date.prototype.getHours ( )

Date.prototype.getUTCHours ( )

Date.prototype.getMinutes ( )

1.  Let t be this time value.

2.  ReturnIfAbrupt(t).

3.  If t is NAN, return NAN.

4.  Return MinFromTime(LocalTime(t)).

Date.prototype.getUTCMinutes ( )

1.  Let t be this time value.

2.  ReturnIfAbrupt(t).

3.  If t is NAN, return NAN.

4.  Return MinFromTime(t).

Date.prototype.getSeconds ( )

Date.prototype.getUTCSeconds ( )

Date.prototype.getMilliseconds ( )

Date.prototype.getUTCMilliseconds ( )

1.  Let t be this time value.

2.  ReturnIfAbrupt(t).

3.  If t is NAN, return NAN.

4.  Return msFromTime(t).

Date.prototype.getTimezoneOffset ( )

Returns the difference between local time and UTC time in minutes.

Date.prototype.setTime (time)

Date.prototype.setMilliseconds (ms)

1.  Let t be the result of LocalTime(this time value).

2.  Let time be MakeTime(HourFromTime(t), MinFromTime(t),
    SecFromTime(t), ToNumber(ms)).

3.  Let u be TimeClip(UTC(MakeDate(Day(t), time))).

4.  Set the [[DateValue]] internal data property of this Date object to
    u.

5.  Return u.

Date.prototype.setUTCMilliseconds (ms)

Date.prototype.setSeconds (sec [, ms ] )

If ms is not specified, this behaves as if ms were specified with
the value GETMILLISECONDS().

The LENGTH property of the SETSECONDS method is 2.

Date.prototype.setUTCSeconds (sec [, ms ] )

If ms is not specified, this behaves as if ms were specified with
the value GETUTCMILLISECONDS().

1.  Let t be this time value.

2.  ReturnIfAbrupt(t).

3.  Let s be ToNumber(sec).

4.  If ms is not specified, then let milli be msFromTime(t);
    otherwise, let milli be ToNumber(ms).

5.  Let date be MakeDate(Day(t), MakeTime(HourFromTime(t),
    MinFromTime(t), s, milli)).

6.  Let v be TimeClip(date).

7.  Set the [[DateValue]] internal data property of this Date object to
    v.

8.  Return v.

The LENGTH property of the SETUTCSECONDS method is 2.

Date.prototype.setMinutes (min [, sec [, ms ] ] )

If sec is not specified, this behaves as if sec were specified with
the value GETSECONDS().

If ms is not specified, this behaves as if ms were specified with
the value GETMILLISECONDS().

The LENGTH property of the SETMINUTES method is 3.

Date.prototype.setUTCMinutes (min [, sec [, ms ] ] )

If sec is not specified, this behaves as if sec were specified with
the value GETUTCSECONDS().

If ms is not specified, this function behaves as if ms were
specified with the value return by GETUTCMILLISECONDS().

The LENGTH property of the SETUTCMINUTES method is 3.

Date.prototype.setHours (hour [, min [, sec [, ms ] ] ] )

If min is not specified, this behaves as if min were specified with
the value GETMINUTES().

If sec is not specified, this behaves as if sec were specified with
the value GETSECONDS().

If ms is not specified, this behaves as if ms were specified with
the value GETMILLISECONDS().

The LENGTH property of the SETHOURS method is 4.

Date.prototype.setUTCHours (hour [, min [, sec [, ms ] ] ] )

If min is not specified, this behaves as if min were specified with
the value GETUTCMINUTES().

If sec is not specified, this behaves as if sec were specified with
the value GETUTCSECONDS().

If ms is not specified, this behaves as if ms were specified with
the value GETUTCMILLISECONDS().

1.  Let t be this time value.

2.  ReturnIfAbrupt(t).

3.  Let h be ToNumber(hour).

4.  If min is not specified, then let m be MinFromTime(t);
    otherwise, let m be ToNumber(min).

5.  If sec is not specified, then let s be SecFromTime(t);
    otherwise, let s be ToNumber(sec).

6.  If ms is not specified, then let milli be msFromTime(t);
    otherwise, let milli be ToNumber(ms).

7.  Let newDate be MakeDate(Day(t), MakeTime(h, m, s,
    milli)).

8.  Let v be TimeClip(newDate).

9.  Set the [[DateValue]] internal data property of this Date object to
    v.

10. Return v.

The LENGTH property of the SETUTCHOURS method is 4.

Date.prototype.setDate (date)

Date.prototype.setUTCDate (date)

1.  Let t be this time value.

2.  ReturnIfAbrupt(t).

3.  Let dt be ToNumber(date).

4.  Let newDate be MakeDate(MakeDay(YearFromTime(t),
    MonthFromTime(t), dt), TimeWithinDay(t)).

5.  Let v be TimeClip(newDate).

6.  Set the [[DateValue]] internal data property of this Date object to
    v.

7.  Return v.

Date.prototype.setMonth (month [, date ] )

If date is not specified, this behaves as if date were specified
with the value GETDATE().

The LENGTH property of the SETMONTH method is 2.

Date.prototype.setUTCMonth (month [, date ] )

If date is not specified, this behaves as if date were specified
with the value GETUTCDATE().

1.  Let t be this time value.

2.  ReturnIfAbrupt(t).

3.  Let m be ToNumber(month).

4.  If date is not specified, then let dt be DateFromTime(t);
    otherwise, let dt be ToNumber(date).

5.  Let newDate be MakeDate(MakeDay(YearFromTime(t), m, dt),
    TimeWithinDay(t)).

6.  Let v be TimeClip(newDate).

7.  Set the [[DateValue]] internal data property of this Date object to
    v.

8.  Return v.

The LENGTH property of the SETUTCMONTH method is 2.

Date.prototype.setFullYear (year [, month [, date ] ] )

If month is not specified, this behaves as if month were specified
with the value GETMONTH().

If date is not specified, this behaves as if date were specified
with the value GETDATE().

The LENGTH property of the SETFULLYEAR method is 3.

Date.prototype.setUTCFullYear (year [, month [, date ] ] )

If month is not specified, this behaves as if month were specified
with the value GETUTCMONTH().

If date is not specified, this behaves as if date were specified
with the value GETUTCDATE().

The LENGTH property of the SETUTCFULLYEAR method is 3.

Date.prototype.toUTCString ( )

This function returns a String value. The contents of the String are
implementation-dependent, but are intended to represent this time value
in a convenient, human-readable form in UTC.

NOTE The intent is to produce a String representation of a date that is
more readable than the format specified in 15.9.1.15. It is not
essential that the chosen format be unambiguous or easily machine
parsable. If an implementation does not have a preferred human-readable
format it is recommended to use the format defined in 15.9.1.15 but with
a space rather than a “T” used to separate the date and time elements.

Date.prototype.toISOString ( )

This function returns a String value representing the instance in time
corresponding to this time value. The format of the String is the Date
Time string format defined in 15.9.1.15. All fields are present in the
String. The time zone is always UTC, denoted by the suffix Z. If this
time value is not a finite Number a RANGEERROR exception is thrown.

Date.prototype.toJSON ( key )

This function provides a String representation of a Date object for use
by JSON.STRINGIFY (15.12.3).

When the TOJSON method is called with argument key, the following
steps are taken:

1.  Let O be the result of calling ToObject, giving it the THIS value
    as its argument.

2.  Let tv be ToPrimitive(O, hint Number).

3.  If tv is a Number and is not finite, return NULL.

4.  Let toISO be the result of Get(O, "TOISOSTRING").

5.  ReturnIfAbrupt(toISO).

6.  If IsCallable(toISO) is FALSE, throw a TYPEERROR exception.

7.  Return the result of calling the [[Call]] internal method of toISO
    with O as thisArgument and an empty List as argumentsList.

NOTE 1 The argument is ignored.

NOTE 2 The TOJSON function is intentionally generic; it does not require
that its THIS value be a Date object. Therefore, it can be transferred
to other kinds of objects for use as a method. However, it does require
that any such object have a TOISOSTRING method. An object is free to use
the argument key to filter its stringification.

Date.prototype [ @@ToPrimitive ] ( hint ) 

This function is called by ECMAScript language operators to convert an
object to a primitive value. The allowed values for hint are
"DEFAULT", "NUMBER", and "STRING". Date objects, are unique among
built-in ECMAScript object in that they treat "DEFAULT" as being
equivalent to "STRING", All other built-in ECMAScript objects treat
"DEFAULT" as being equivalent to "NUMBER".

When the @@TOPRIMITIVE method is called with argument hint, the
following steps are taken:

1.  Let O be the THIS value.

2.  If Type(O) is not Object, then throw a TYPEERROR exception.

3.  If hint is the string value "STRING" or the string value "DEFAULT"
    , then

    a.  Let tryFirst be "STRING".

4.  Else if hint is the string value "NUMBER", then

    a.  Let tryFirst be "NUMBER".

5.  Else, throw a TYPEERROR exception.

6.  Return the result of OrdinaryToPrimitive(O_,_tryFirst).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Properties of Date Instances

Date instances are ordinary objects that inherit properties from the
Date prototype object. Date instances also have a [[DateValue]] internal
data property.

The [[DateValue]] internal data property is the time value represented
by this Date object.


RegExp (Regular Expression) Objects

A RegExp object contains a regular expression and the associated flags.

NOTE The form and functionality of regular expressions is modelled after
the regular expression facility in the Perl 5 programming language.

Patterns

The REGEXP constructor applies the following grammar to the input
pattern String. An error occurs if the grammar cannot interpret the
String as an expansion of Pattern.

Syntax

Pattern ::

Disjunction

Disjunction ::

Alternative
 Alternative | Disjunction

Alternative ::

[empty]
Alternative Term

Term ::

Assertion
Atom
Atom Quantifier

Assertion ::

^
$
\ B
\ B
( ? = Disjunction )
( ? ! Disjunction )

Quantifier ::

QuantifierPrefix
QuantifierPrefix ?

QuantifierPrefix ::

*
+
?
{ DecimalDigits }
{ DecimalDigits , }
{ DecimalDigits , DecimalDigits }

Atom ::

PatternCharacter
.
\ AtomEscape
CharacterClass
( Disjunction )
( ? : Disjunction )

PatternCharacter ::

SourceCharacter BUT NOT ONE OF
 ^ $ \ . * + ? ( ) [ ] { } |

AtomEscape ::

DecimalEscape
CharacterEscape
CharacterClassEscape

CharacterEscape ::

ControlEscape
C ControlLetter
HexEscapeSequence
UnicodeEscapeSequence
IdentityEscape

ControlEscape :: ONE OF

F N R T V

ControlLetter :: ONE OF

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

IdentityEscape ::

SourceCharacter BUT NOT IdentifierPart
<ZWJ>
<ZWNJ>

DecimalEscape ::

DecimalIntegerLiteral [lookahead ∉ DecimalDigit]

CharacterClassEscape :: ONE OF

D D S S W W

CharacterClass ::

[ [lookahead ∉ {^}] ClassRanges ]
[ ^ ClassRanges ]

ClassRanges ::

[empty]
NonemptyClassRanges

NonemptyClassRanges ::

ClassAtom
ClassAtom NonemptyClassRangesNoDash
ClassAtom - ClassAtom ClassRanges

NonemptyClassRangesNoDash ::

ClassAtom
ClassAtomNoDash NonemptyClassRangesNoDash
ClassAtomNoDash - ClassAtom ClassRanges

ClassAtom ::

-
ClassAtomNoDash

ClassAtomNoDash ::

SourceCharacter BUT NOT ONE OF \ OR ] OR -
\ ClassEscape

ClassEscape ::

DecimalEscape
B
CharacterEscape
CharacterClassEscape

Pattern Semantics

A regular expression pattern is converted into an internal procedure
using the process described below. An implementation is encouraged to
use more efficient algorithms than the ones listed below, as long as the
results are the same. The internal procedure is used as the value of a
RegExp object’s [[RegExpMatcher]] internal data property.

Notation

The descriptions below use the following variables:

-   Input is the String being matched by the regular expression
      pattern. The notation input_[_n] means the n^th^ character of
      input, where n can range between 0 (inclusive) and
      InputLength (exclusive).

-   InputLength is the number of characters in the Input String.

-   NcapturingParens is the total number of left capturing parentheses
      (i.e. the total number of times the Atom :: ( Disjunction )
      production is expanded) in the pattern. A left capturing
      parenthesis is any ( pattern character that is matched by the (
      terminal of the Atom :: ( Disjunction ) production.

-   IgnoreCase is TRUE if the RegExp object's [[OriginalFlags]]
      internal data property contains "I" and otherwise is FALSE.

-   Multiline is TRUE if the RegExp object’s [[OriginalFlags]]
      internal data property contains "M" and otherwise is FALSE.

Furthermore, the descriptions below use the following internal data
structures:

-   A CharSet is a mathematical set of characters.

-   A State is an ordered pair (endIndex, captures) where
      endIndex is an integer and captures is a List of
      NcapturingParens values. States are used to represent partial
      match states in the regular expression matching algorithms. The
      endIndex is one plus the index of the last input character
      matched so far by the pattern, while captures holds the results
      of capturing parentheses. The n^th^ element of captures is
      either a String that represents the value obtained by the n^th^
      set of capturing parentheses or UNDEFINED if the n^th^ set of
      capturing parentheses hasn’t been reached yet. Due to
      backtracking, many States may be in use at any time during the
      matching process.

-   A MatchResult is either a State or the special token FAILURE
      that indicates that the match failed.

-   A Continuation procedure is an internal closure (i.e. an internal
      procedure with some arguments already bound to values) that takes
      one State argument and returns a MatchResult result. If an
      internal closure references variables bound in the function that
      creates the closure, the closure uses the values that these
      variables had at the time the closure was created. The
      Continuation attempts to match the remaining portion (specified
      by the closure's already-bound arguments) of the pattern against
      the input String, starting at the intermediate state given by its
      State argument. If the match succeeds, the Continuation
      returns the final State that it reached; if the match fails, the
      Continuation returns FAILURE.

-   A Matcher procedure is an internal closure that takes two
      arguments -- a State and a Continuation -- and returns a
      MatchResult result. A Matcher attempts to match a middle
      subpattern (specified by the closure's already-bound arguments) of
      the pattern against the input String, starting at the intermediate
      state given by its State argument. The Continuation argument
      should be a closure that matches the rest of the pattern. After
      matching the subpattern of a pattern to obtain a new State, the
      Matcher then calls Continuation on that new State to test if
      the rest of the pattern can match as well. If it can, the
      Matcher returns the State returned by Continuation; if not,
      the Matcher may try different choices at its choice points,
      repeatedly calling Continuation until it either succeeds or all
      possibilities have been exhausted.

-   An AssertionTester procedure is an internal closure that takes a
      State argument and returns a Boolean result. The assertion
      tester tests a specific condition (specified by the closure's
      already-bound arguments) against the current place in the input
      String and returns TRUE if the condition matched or FALSE if not.

-   An EscapeValue is either a character or an integer. An
      EscapeValue is used to denote the interpretation of a
      DecimalEscape escape sequence: a character ch means that the
      escape sequence is interpreted as the character ch, while an
      integer n means that the escape sequence is interpreted as a
      backreference to the n^th^ set of capturing parentheses.

Pattern

The production Pattern :: Disjunction evaluates as follows:

1.  Let Input be the given String str. This variable will be used
      throughout the algorithms in 15.10.2.

2.  Let InputLength be the length of Input. This variable will be
      used throughout the algorithms in 15.10.2.

3.  Let c be a Continuation that always returns its State argument as
      a successful MatchResult.

4.  Let cap be a List of NcapturingParens UNDEFINED values, indexed
      1 through NcapturingParens.

5.  Let x be the State (index, cap).

6.  Call m_(_x, c) and return its result.

NOTE A Pattern evaluates ("compiles") to an internal procedure value.
REGEXP.PROTOTYPE.EXEC can then apply this procedure to a String and an
offset within the String to determine whether the pattern would match
starting at exactly that offset within the String, and, if it does
match, what the values of the capturing parentheses would be. The
algorithms in 15.10.2 are designed so that compiling a pattern may throw
a SYNTAXERROR exception; on the other hand, once the pattern is
successfully compiled, applying its result internal procedure to find a
match in a String cannot throw an exception (except for any host-defined
exceptions that can occur anywhere such as out-of-memory).

Disjunction

The production Disjunction :: Alternative evaluates by evaluating
Alternative to obtain a Matcher and returning that Matcher.

The production Disjunction :: Alternative | Disjunction evaluates
as follows:

NOTE The | regular expression operator separates two alternatives. The
pattern first tries to match the left Alternative (followed by the
sequel of the regular expression); if it fails, it tries to match the
right Disjunction (followed by the sequel of the regular expression).
If the left Alternative, the right Disjunction, and the sequel all
have choice points, all choices in the sequel are tried before moving on
to the next choice in the left Alternative. If choices in the left
Alternative are exhausted, the right Disjunction is tried instead of
the left Alternative. Any capturing parentheses inside a portion of
the pattern skipped by | produce UNDEFINED values instead of Strings.
Thus, for example,

  /a|ab/.exec("abc")

returns the result "A" and not "AB". Moreover,

  /((a)|(ab))((c)|(bc))/.exec("abc")

returns the array

  ["abc", "a", "a", undefined, "bc", undefined, "bc"]

and not

  ["abc", "ab", undefined, "ab", "c", "c", undefined]

Alternative

The production Alternative :: [empty] evaluates by returning a Matcher
that takes two arguments, a State x and a Continuation c, and
returns the result of calling c_(_x).

The production Alternative :: Alternative Term evaluates as
follows:

1.  Evaluate Alternative to obtain a Matcher m1.

2.  Evaluate Term to obtain a Matcher m2.

3.  Return an internal Matcher closure that takes two arguments, a State
    x and a Continuation c, and performs the following:

    1.  Create a Continuation d that takes a State argument y and
          returns the result of calling m2_(_y, c).

    2.  Call m1_(_x, d) and return its result.

NOTE Consecutive Terms try to simultaneously match consecutive
portions of the input String. If the left Alternative, the right
Term, and the sequel of the regular expression all have choice points,
all choices in the sequel are tried before moving on to the next choice
in the right Term, and all choices in the right Term are tried
before moving on to the next choice in the left Alternative.

Term

The production Term :: Assertion evaluates by returning an internal
Matcher closure that takes two arguments, a State x and a Continuation
c, and performs the following:

The production Term :: Atom evaluates by evaluating Atom to obtain
a Matcher and returning that Matcher.

The production Term :: Atom Quantifier evaluates as follows:

RUNTIME SEMANTICS: REPEATMATCHER ABSTRACT OPERATION

The abstract operation RepeatMatcher takes eight parameters, a Matcher
m, an integer min, an integer (or ∞) max, a Boolean greedy, a
State x, a Continuation c, an integer parenIndex, and an integer
parenCount, and performs the following:

NOTE 1 An Atom followed by a Quantifier is repeated the number of
times specified by the Quantifier. A Quantifier can be non-greedy,
in which case the Atom pattern is repeated as few times as possible
while still matching the sequel, or it can be greedy, in which case the
Atom pattern is repeated as many times as possible while still
matching the sequel. The Atom pattern is repeated rather than the
input String that it matches, so different repetitions of the Atom can
match different input substrings.

NOTE 2 If the Atom and the sequel of the regular expression all have
choice points, the Atom is first matched as many (or as few, if
non-greedy) times as possible. All choices in the sequel are tried
before moving on to the next choice in the last repetition of Atom.
All choices in the last (n^th^) repetition of Atom are tried before
moving on to the next choice in the next-to-last (n–1)^st^ repetition of
Atom; at which point it may turn out that more or fewer repetitions of
Atom are now possible; these are exhausted (again, starting with
either as few or as many as possible) before moving on to the next
choice in the (n-1)^st^ repetition of Atom and so on.

Compare

  /a[a-z]{2,4}/.exec("abcdefghi")

which returns "ABCDE" with

  /a[a-z]{2,4}?/.exec("abcdefghi")

which returns "ABC".

Consider also

  /(aa|aabaac|ba|b|c)*/.exec("aabaac")

which, by the choice point ordering above, returns the array

  ["aaba", "ba"]

and not any of:

  ["aabaac", "aabaac"]

  ["aabaac", "c"]

The above ordering of choice points can be used to write a regular
expression that calculates the greatest common divisor of two numbers
(represented in unary notation). The following example calculates the
gcd of 10 and 15:

  "aaaaaaaaaa,aaaaaaaaaaaaaaa".replace(/^(a+)\1*,\1+$/,"$1")

which returns the gcd in unary notation "AAAAA".

NOTE 3 Step 4 of the RepeatMatcher clears Atom's captures each time
Atom is repeated. We can see its behaviour in the regular expression

  /(z)((a+)?(b+)?(c))*/.exec("zaacbbbcac")

which returns the array

  ["zaacbbbcac", "z", "ac", "a", undefined, "c"]

and not

  ["zaacbbbcac", "z", "ac", "a", "bbb", "c"]

because each iteration of the outermost * clears all captured Strings
contained in the quantified Atom, which in this case includes capture
Strings numbered 2, 3, 4, and 5.

NOTE 4 Step 1 of the RepeatMatcher's d closure states that, once the
minimum number of repetitions has been satisfied, any more expansions of
Atom that match the empty String are not considered for further
repetitions. This prevents the regular expression engine from falling
into an infinite loop on patterns such as:

  /(a*)*/.exec("b")

or the slightly more complicated:

  /(a*)b\1+/.exec("baaaac")

which returns the array

  ["b", ""]

Assertion

The production Assertion :: ^ evaluates by returning an internal
AssertionTester closure that takes a State argument x and performs the
following:

The production Assertion :: $ evaluates by returning an internal
AssertionTester closure that takes a State argument x and performs the
following:

The production Assertion :: \ B evaluates by returning an internal
AssertionTester closure that takes a State argument x and performs the
following:

The production Assertion :: \ B evaluates by returning an internal
AssertionTester closure that takes a State argument x and performs the
following:

The production Assertion :: ( ? = Disjunction ) evaluates as
follows:

The production Assertion :: ( ? ! Disjunction ) evaluates as
follows:

1.  Evaluate Disjunction to obtain a Matcher m.

2.  Return an internal Matcher closure that takes two arguments, a State
    x and a Continuation c, and performs the following steps:

    1.  Let d be a Continuation that always returns its State argument
          as a successful MatchResult.

    2.  Call m_(_x, d) and let r be its result.

    3.  If r isn't FAILURE, return FAILURE.

    4.  Call c_(_x) and return its result.

RUNTIME SEMANTICS: ISWORDCHAR ABSTRACT OPERATION

The abstract operation IsWordChar takes an integer parameter e and
performs the following:

1.  If e is –1 or e is InputLength, return FALSE.

2.  Let c be the character Input_[_e].

3.  If c is one of the sixty-three characters below, return TRUE.

  --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
  a   b   c   d   e   f   g   h   i   j   k   l   m   n   o   p   q   r   s   t   u   v   w   x   y   z
  A   B   C   D   E   F   G   H   I   J   K   L   M   N   O   P   Q   R   S   T   U   V   W   X   Y   Z
  0   1   2   3   4   5   6   7   8   9   _                                                           
  --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---

1.  Return FALSE.

Quantifier

The production Quantifier :: QuantifierPrefix evaluates as follows:

The production Quantifier :: QuantifierPrefix ? evaluates as
follows:

The production QuantifierPrefix :: * evaluates by returning the two
results 0 and ∞.

The production QuantifierPrefix :: + evaluates by returning the two
results 1 and ∞.

The production QuantifierPrefix :: ? evaluates by returning the two
results 0 and 1.

The production QuantifierPrefix :: { DecimalDigits } evaluates as
follows:

The production QuantifierPrefix :: { DecimalDigits , } evaluates as
follows:

The production QuantifierPrefix :: { DecimalDigits , DecimalDigits
} evaluates as follows:

Atom

The production Atom :: PatternCharacter evaluates as follows:

The production Atom :: . evaluates as follows:

The production Atom :: \ AtomEscape evaluates by evaluating
AtomEscape to obtain a Matcher and returning that Matcher.

The production Atom :: CharacterClass evaluates as follows:

1.  Evaluate CharacterClass to obtain a CharSet A and a Boolean
    invert.

2.  Call CharacterSetMatcher(A, invert) and return its Matcher
    result.

The production Atom :: ( Disjunction ) evaluates as follows:

1.  Evaluate Disjunction to obtain a Matcher m.

2.  Let parenIndex be the number of left capturing parentheses in the
    entire regular expression that occur to the left of this production
    expansion's initial left parenthesis. This is the total number of
    times the Atom_ :: ( _Disjunction ) production is expanded prior
    to this production's Atom plus the total number of
    Atom_ :: ( _Disjunction ) productions enclosing this Atom.

3.  Return an internal Matcher closure that takes two arguments, a State
    x and a Continuation c, and performs the following steps:

    1.  Create an internal Continuation closure d that takes one State
          argument y and performs the following steps:

        1.  Let cap be a fresh copy of y's captures List.

        2.  Let xe be x's endIndex.

        3.  Let ye be y's endIndex.

        4.  Let s be a fresh String whose characters are the
              characters of Input at positions xe (inclusive)
              through ye (exclusive).

        5.  Set cap_[_parenIndex+1] to s.

        6.  Let z be the State (ye, cap).

        7.  Call c_(_z) and return its result.

    2.  Call m_(_x, d) and return its result.

The production Atom :: ( ? : Disjunction ) evaluates by evaluating
Disjunction to obtain a Matcher and returning that Matcher.

RUNTIME SEMANTICS: CHARACTERSETMATCHER ABSTRACT OPERATION

The abstract operation CharacterSetMatcher takes two arguments, a
CharSet A and a Boolean flag invert, and performs the following:

a.  If there does not exist a member a of set A such that
      Canonicalize(a) is cc, return FAILURE.

a.  If there exists a member a of set A such that Canonicalize(a)
      is cc, return FAILURE.

RUNTIME SEMANTICS: CANONICALIZE ABSTRACT OPERATION

The abstract operation Canonicalize takes a character parameter ch and
performs the following steps:

1.  If IgnoreCase is FALSE, return ch.

2.  Let u be ch converted to upper case as if by calling the
    standard built-in method STRING.PROTOTYPE.TOUPPERCASE on the
    one-character String ch.

3.  If u does not consist of a single character, return ch.

4.  Let cu be u's character.

5.  If ch's code unit value is greater than or equal to decimal 128
    and cu's code unit value is less than decimal 128, then return
    ch.

6.  Return cu.

NOTE 1 Parentheses of the form ( Disjunction ) serve both to group the
components of the Disjunction pattern together and to save the result
of the match. The result can be used either in a backreference (\
followed by a nonzero decimal number), referenced in a replace String,
or returned as part of an array from the regular expression matching
internal procedure. To inhibit the capturing behaviour of parentheses,
use the form (?: Disjunction ) instead.

NOTE 2 The form (?= Disjunction ) specifies a zero-width positive
lookahead. In order for it to succeed, the pattern inside Disjunction
must match at the current position, but the current position is not
advanced before matching the sequel. If Disjunction can match at the
current position in several ways, only the first one is tried. Unlike
other regular expression operators, there is no backtracking into a (?=
form (this unusual behaviour is inherited from Perl). This only matters
when the Disjunction contains capturing parentheses and the sequel of
the pattern contains backreferences to those captures.

For example,

  /(?=(a+))/.exec("baaabac")

matches the empty String immediately after the first B and therefore
returns the array:

  ["", "aaa"]

To illustrate the lack of backtracking into the lookahead, consider:

  /(?=(a+))a*b\1/.exec("baaabac")

This expression returns

  ["aba", "a"]

and not:

  ["aaaba", "a"]

NOTE 3 The form (?! Disjunction ) specifies a zero-width negative
lookahead. In order for it to succeed, the pattern inside Disjunction
must fail to match at the current position. The current position is not
advanced before matching the sequel. Disjunction can contain capturing
parentheses, but backreferences to them only make sense from within
Disjunction itself. Backreferences to these capturing parentheses from
elsewhere in the pattern always return UNDEFINED because the negative
lookahead must fail for the pattern to succeed. For example,

  /(.*?)a(?!(a+)b\2c)\2(.*)/.exec("baaabaac")

looks for an A not immediately followed by some positive number n of
A's, a B, another n A's (specified by the first \2) and a C. The second
\2 is outside the negative lookahead, so it matches against UNDEFINED
and therefore always succeeds. The whole expression returns the array:

  ["baaabaac", "ba", undefined, "abaac"]

In case-insignificant matches all characters are implicitly converted to
upper case immediately before they are compared. However, if converting
a character to upper case would expand that character into more than one
character (such as converting "SS" (\u00DF) into "SS"), then the
character is left as-is instead. The character is also left as-is if it
is not an ASCII character but converting it to upper case would make it
into an ASCII character. This prevents Unicode characters such as \u0131
and \u017F from matching regular expressions such as /[AZ]/I, which are
only intended to match ASCII letters. Furthermore, if these conversions
were allowed, then /[^\W]/I would match each of A, B, …, H, but not I or
S.

AtomEscape

The production AtomEscape :: DecimalEscape evaluates as follows:

The production AtomEscape :: CharacterEscape evaluates as follows:

1.  Evaluate CharacterEscape to obtain a character ch.

2.  Let A be a one-element CharSet containing the character ch.

3.  Call CharacterSetMatcher(A, FALSE) and return its Matcher result.

The production AtomEscape :: CharacterClassEscape evaluates as
follows:

1.  Evaluate CharacterClassEscape to obtain a CharSet A.

2.  Call CharacterSetMatcher(A, FALSE) and return its Matcher result.

NOTE An escape sequence of the form \ followed by a nonzero decimal
number n matches the result of the nth set of capturing parentheses
(see 15.10.2.11). It is an error if the regular expression has fewer
than n capturing parentheses. If the regular expression has n or
more capturing parentheses but the nth one is UNDEFINED because it has
not captured anything, then the backreference always succeeds.

CharacterEscape

The production CharacterEscape :: ControlEscape evaluates by
returning the character according to Table 35.

Table 35 — ControlEscape Character Values

  --------------- ----------- ---------------------- --------
  ControlEscape   Code Unit   Name                   Symbol
  T               \U0009      horizontal tab         <HT>
  N               \U000A      line feed (new line)   <LF>
  V               \U000B      vertical tab           <VT>
  F               \U000C      form feed              <FF>
  R               \U000D      carriage return        <CR>
  --------------- ----------- ---------------------- --------

The production CharacterEscape :: C ControlLetter evaluates as
follows:

1.  Let ch be the character represented by ControlLetter.

2.  Let i be ch's code unit value.

3.  Let j be the remainder of dividing i by 32.

4.  Return the character whose code unit value is j.

The production CharacterEscape :: HexEscapeSequence evaluates by
evaluating the CV of the HexEscapeSequence (see 7.8.6) and returning
its character result.

The production CharacterEscape :: UnicodeEscapeSequence evaluates by
evaluating the CV of the UnicodeEscapeSequence (see 7.8.6) and
returning its character result.

The production CharacterEscape :: IdentityEscape evaluates by
returning the character represented by IdentityEscape.

DecimalEscape

The production DecimalEscape :: DecimalIntegerLiteral [lookahead ∉
DecimalDigit] evaluates as follows:

The definition of “the MV of DecimalIntegerLiteral” is in 7.8.3.

NOTE If \ is followed by a decimal number n whose first digit is not
0, then the escape sequence is considered to be a backreference. It is
an error if n is greater than the total number of left capturing
parentheses in the entire regular expression. \0 represents the <NUL>
character and cannot be followed by a decimal digit.

CharacterClassEscape

The production CharacterClassEscape :: D evaluates by returning the
ten-element set of characters containing the characters 0 through 9
inclusive.

The production CharacterClassEscape :: D evaluates by returning the
set of all characters not included in the set returned by
CharacterClassEscape :: D.

The production CharacterClassEscape :: S evaluates by returning the
set of characters containing the characters that are on the right-hand
side of the WhiteSpace (7.2) or LineTerminator (7.3) productions.

The production CharacterClassEscape :: S evaluates by returning the
set of all characters not included in the set returned by
CharacterClassEscape :: S.

The production CharacterClassEscape :: W evaluates by returning the
set of characters containing the sixty-three characters:

  --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
  a   b   c   d   e   f   g   h   i   j   k   l   m   n   o   p   q   r   s   t   u   v   w   x   y   z
  A   B   C   D   E   F   G   H   I   J   K   L   M   N   O   P   Q   R   S   T   U   V   W   X   Y   Z
  0   1   2   3   4   5   6   7   8   9   _                                                           
  --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---

The production CharacterClassEscape :: W evaluates by returning the
set of all characters not included in the set returned by
CharacterClassEscape :: W.

CharacterClass

The production CharacterClass :: [ [lookahead ∉ {^}] ClassRanges ]
evaluates by evaluating ClassRanges to obtain a CharSet and returning
that CharSet and the Boolean FALSE.

The production CharacterClass :: [ ^ ClassRanges ] evaluates by
evaluating ClassRanges to obtain a CharSet and returning that CharSet
and the Boolean TRUE.

ClassRanges

The production ClassRanges :: [empty] evaluates by returning the empty
CharSet.

The production ClassRanges :: NonemptyClassRanges evaluates by
evaluating NonemptyClassRanges to obtain a CharSet and returning that
CharSet.

NonemptyClassRanges

The production NonemptyClassRanges :: ClassAtom evaluates by
evaluating ClassAtom to obtain a CharSet and returning that CharSet.

The production NonemptyClassRanges :: ClassAtom
NonemptyClassRangesNoDash evaluates as follows:

1.  Evaluate ClassAtom to obtain a CharSet A.

2.  Evaluate NonemptyClassRangesNoDash to obtain a CharSet B.

3.  Return the union of CharSets A and B.

The production NonemptyClassRanges :: ClassAtom - ClassAtom
ClassRanges evaluates as follows:

1.  Evaluate the first ClassAtom to obtain a CharSet A.

2.  Evaluate the second ClassAtom to obtain a CharSet B.

3.  Evaluate ClassRanges to obtain a CharSet C.

4.  Call CharacterRange(A, B) and let D be the resulting CharSet.

5.  Return the union of CharSets D and C.

RUNTIME SEMANTICS: CHARACTERRANGE ABSTRACT OPERATION

The abstract operation CharacterRange takes two CharSet parameters A
and B and performs the following:

NonemptyClassRangesNoDash

The production NonemptyClassRangesNoDash :: ClassAtom evaluates by
evaluating ClassAtom to obtain a CharSet and returning that CharSet.

The production NonemptyClassRangesNoDash :: ClassAtomNoDash
NonemptyClassRangesNoDash evaluates as follows:

The production NonemptyClassRangesNoDash :: ClassAtomNoDash -
ClassAtom ClassRanges evaluates as follows:

1.  Evaluate ClassAtomNoDash to obtain a CharSet A.

2.  Evaluate ClassAtom to obtain a CharSet B.

3.  Evaluate ClassRanges to obtain a CharSet C.

4.  Call CharacterRange(A, B) and let D be the resulting CharSet.

5.  Return the union of CharSets D and C.

NOTE 1 ClassRanges can expand into single ClassAtoms and/or ranges
of two ClassAtoms separated by dashes. In the latter case the
ClassRanges includes all characters between the first ClassAtom and
the second ClassAtom, inclusive; an error occurs if either ClassAtom
does not represent a single character (for example, if one is \W) or if
the first ClassAtom's code unit value is greater than the second
ClassAtom's code unit value.

NOTE 2 Even if the pattern ignores case, the case of the two ends of a
range is significant in determining which characters belong to the
range. Thus, for example, the pattern /[E-F]/I matches only the letters
E, F, E, and F, while the pattern /[E-F]/I matches all upper and
lower-case ASCII letters as well as the symbols [, \, ], ^, _, and `.

NOTE 3 A - character can be treated literally or it can denote a range.
It is treated literally if it is the first or last character of
ClassRanges, the beginning or end limit of a range specification, or
immediately follows a range specification.

ClassAtom

The production ClassAtom :: - evaluates by returning the CharSet
containing the one character -.

The production ClassAtom :: ClassAtomNoDash evaluates by evaluating
ClassAtomNoDash to obtain a CharSet and returning that CharSet.

ClassAtomNoDash

The production ClassAtomNoDash :: SourceCharacter BUT NOT ONE OF \
OR ] OR - evaluates by returning a one-element CharSet containing the
character represented by SourceCharacter.

The production ClassAtomNoDash :: \ ClassEscape evaluates by
evaluating ClassEscape to obtain a CharSet and returning that CharSet.

ClassEscape

The production ClassEscape :: DecimalEscape evaluates as follows:

The production ClassEscape :: B evaluates by returning the CharSet
containing the one character <BS> (Unicode value 0008).

The production ClassEscape :: CharacterEscape evaluates by
evaluating CharacterEscape to obtain a character and returning a
one-element CharSet containing that character.

The production ClassEscape :: CharacterClassEscape evaluates by
evaluating CharacterClassEscape to obtain a CharSet and returning that
CharSet.

NOTE A ClassAtom can use any of the escape sequences that are allowed
in the rest of the regular expression except for \B, \B, and
backreferences. Inside a CharacterClass, \B means the backspace
character, while \B and backreferences raise errors. Using a
backreference inside a ClassAtom causes an error.

The RegExp Constructor 

The RegExp constructor is the %RegExp% intrinsic object and the initial
value of the REGEXP property of the global object. When REGEXP is called
as a function rather than as a constructor, it creates and initialises a
new RegExp object. Thus the function call REGEXP(…) is equivalent to the
object creation expression NEW REGEXP(…) with the same arguments.
However, if the THIS value value passed in the call is an Object with an
[[RegExpMatcher]] internal data property whose value is UNDEFINED, it
initialises the THIS value using the argument values. This permits
REGEXP to be used both as factory method and to perform constructor
instance initialization.

The REGEXP constructor is designed to be subclassable. It may be used as
the value of an EXTENDS clause of a class declaration. Subclass
constructors that intended to inherit the specified REGEXP behaviour
must include a SUPER call to the REGEXP constructor to initialise
subclass instances.

RegExp(pattern, flags)

The following steps are taken:

NOTE If pattern is supplied using a StringLiteral, the usual escape
sequence substitutions are performed before the String is processed by
RegExp. If pattern must contain an escape sequence to be recognised by
RegExp, any backslash \ characters must be escaped within the
StringLiteral to prevent them being removed when the contents of the
StringLiteral are formed.

new RegExp(...argumentsList)

REGEXP called as part of a new expression with argument list
argumentsList it performs the following steps:

1.  Let F be the REGEXP function object on which the NEW operator was
    applied.

2.  Let argumentsList be the argumentsList argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of OrdinaryConstruct (F, argumentsList).

If REGEXP is implemented as an ordinary function object, its
[[Construct]] internal method will perform the above steps.

Abstract Operations for the RegExp Constructor

RUNTIME SEMANTICS: REGEXPALLOC ABSTRACT OPERATION

When the abstract operation RegExpAlloc with argument constructor is
called, the following steps are taken:

1.  Assert: constructor is an object that has a [[Construct]] internal
    method.

2.  Let obj be the result of calling
    OrdinaryCreateFromConstructor(constructor, "%REGEXPPROTOTYPE%", (
    [[RegExpMatcher]], [[OriginalSource]], [[OriginalFlags]])).

3.  Let status be the result of DefinePropertyOrThrow(obj,
    "LASTINDEX", PropertyDescriptor {[[Writable]]: TRUE,
    [[Enumberable]]: FALSE, [[Configurable]]: FALSE}).

4.  ReturnIfAbrupt(status).

5.  Return obj.

NOTE [[RegExpMatcher]] is initially assigned the value UNDEFINED as a
flag to indicate that the instance has not yet been initialised by the
REGEXP constructor. This flag value is never directly exposed to
ECMAScript code; hence implementation may choose to encode the flag in
some other manner.

RUNTIME SEMANTICS: REGEXPINITIALISE ABSTRACT OPERATION

When the abstract operation RegExpInitialise with arguments obj,
pattern, and flags is called, the following steps are taken:

1.  If pattern is UNDEFINED, then let P be the empty String.

2.  Else, let P be ToString(pattern).

3.  ReturnIfAbrupt(P).

4.  If flags is UNDEFINED, then let F be the empty String.

5.  Else, let F be ToString(flags).

6.  ReturnIfAbrupt(F).

7.  8.  If F contains any character other than "G", "I", "M", "U", or
    "Y" or if it contains the same character more than once, then throw
    a SYNTAXERROR exception.

9.  Parse P interpreted as UTF-16 encoded Unicode characters using the
    grammars in 15.10.1 for the goal symbol Pattern. Throw a
    SYNTAXERROR exception if P did not conform to the grammar or if
    all characters of P where not matched by the parse.

10. Set obj’s [[RegExpMatcher]] internal data property to the internal
    procedure obtained by evaluating ("compiling") the step 3’s parse of
    P and applying the semantics provided in 15.10.2.

11. Set the value of obj’s [[OriginalSource]] internal data property
    to P.

12. Set the value of obj’s [[OriginalFlags]] internal data property to
    F.

13. 14. Let putStatus be the result of Put(obj, "LASTINDEX", 0,
    TRUE).

15. ReturnIfAbrupt(putStatus).

16. Return obj.

RUNTIME SEMANTICS: REGEXPCREATE ABSTRACT OPERATION

When the abstract operation RegExpCreate with arguments P and F is
called, the following steps are taken:

1.  2.  Let obj be the result of calling the abstract operation
    RegExpAlloc with argument %RegExp%.

3.  ReturnIfAbrupt(obj).

4.  Return the result of the abstract operation RegExpInitialise with
    arguments obj, P, and F .

RUNTIME SEMANTICS: ESCAPEREGEXPPATTERN ABSTRACT OPERATION

When the abstract operation EscapeRegExpPattern with arguments P and
F is called, the following occurs:

Let S be a String in the form of a Pattern equivalent to P
interpreted as UTF-16 encoded Unicode characters, in which certain
characters are escaped as described below. S may or may not be
identical to P or pattern; however, the internal procedure that
would result from evaluating S as a Pattern must behave identically
to the internal procedure given by the constructed object's
[[RegExpMatcher]] internal data property. Separate calls to this
abstract operation using the same values for P and F must produce
identical results.

The characters / occurring in the pattern shall be escaped in S as
necessary to ensure that the String value formed by concatenating the
Strings "/", S, "/", and F can be parsed (in an appropriate lexical
context) as a RegularExpressionLiteral that behaves identically to the
constructed regular expression. For example, if P is "/", then S
could be "\/" or "\U002F", among other possibilities, but not "/",
because /// followed by F would be parsed as a SingleLineComment
rather than a RegularExpressionLiteral. If P is the empty String,
this specification can be met by letting S be "(?:)".

Return S.

1.  2.  3.  

Properties of the RegExp Constructor

The value of the [[Prototype]] internal data property of the RegExp
constructor is the standard built-in Function prototype object (15.3.3).

Besides the LENGTH property (whose value is 2), the RegExp constructor
has the following properties:

RegExp.prototype

The initial value of REGEXP.PROTOTYPE is the RegExp prototype object
(15.10.6).

This property shall have the attributes { [[Writable]]: FALSE,
[[Enumerable]]: FALSE, [[Configurable]]: FALSE }.

RegExp[ @@create ] ( )

The @@create method of an object F performs the following:

1.  Return the result of calling the abstract operation RegExpAlloc with
    argument F.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Properties of the RegExp Prototype Object

The RegExp prototype object is an ordinary object. It is not a RegExp
instance and does not have a [[RegExpMatcher]] internal data property or
any of the other internal data properties of RegExp instance objects.

The value of the [[Prototype]] internal data property of the RegExp
prototype object is the standard built-in Object prototype object
(15.2.4).

The RegExp prototype object does not have a VALUEOF property of its own;
however, it inherits the VALUEOF property from the Object prototype
object.

RegExp.prototype.constructor

The initial value of REGEXP.PROTOTYPE.CONSTRUCTOR is the standard
built-in REGEXP constructor.

RegExp.prototype.exec(string)

Performs a regular expression match of string against the regular
expression and returns an Array object containing the results of the
match, or NULL if string did not match.

The String ToString(string) is searched for an occurrence of the
regular expression pattern as follows:

1.  Let R be the THIS value.

2.  If Type(R) is not Object, then throw a TYPEERROR exception.

3.  If R does not have a [[RegExpMatcher]] internal data property,
    then throw a TYPEERROR exception.

4.  If the value of R’s [[RegExpMatcher]] internal data property is
    UNDEFINED, then throw a TYPEERROR exception.

5.  6.  7.  Let S be the value of ToString(string)

8.  ReturnIfAbrupt(S).

9.  Return the result of the RegExpExec abstract operation with
    arguments R and S.

RUNTIME SEMANTICS: REGEXPEXEC ABSTRACT OPERATION

The abstract operation RegExpExec with arguments R (an object) and S
(a string) performs the following steps:

1.  Assert: R is an initialised RegExp instance.

2.  3.  Let length be the length of S.

4.  Let lastIndex be the result of Get(R,"LASTINDEX").

5.  Let i be the value of ToInteger(lastIndex).

6.  ReturnIfAbrupt(i).

7.  Let global be the result of ToBoolean(Get(R, "GLOBAL")).

8.  ReturnIfAbrupt(global).

9.  If global is FALSE, then let i = 0.

10. Let matcher be the value of R’s [[RegExpMatcher]] internal data
    property.

11. Let matchSucceeded be FALSE.

12. Repeat, while matchSucceeded is FALSE

    a.  If i < 0 or i > length, then

        i.  Let putStatus be the result of Put(R, "LASTINDEX", 0,
            TRUE).

        ii. ReturnIfAbrupt(putStatus).

        iii. Return NULL.

    b.  Let r be the result of calling matcher with arguments S
        and i.

    c.  If r is FAILURE, then

        i.  Let i = i+1.

    d.  else

        i.  Assert: r is a State.

        ii. Set matchSucceeded to TRUE.

13. Let e be r's endIndex value.

14. If global is TRUE,

    a.  Let putStatus be the result of Put(R, "LASTINDEX", e,
        TRUE).

    b.  ReturnIfAbrupt(putStatus).

15. Let n be the length of r's captures List. (This is the same
    value as 15.10.2.1's NcapturingParens.)

16. Let A be the result of the abstract operation ArrayCreate with
    argument 0.

17. Let matchIndex be i.

18. Assert: The following [DefineOwnProperty]] calls will not result in
    an abrupt completion.

19. Call the [[DefineOwnProperty]] internal method of A with arguments
    "INDEX" and Property Descriptor {[[Value]]: matchIndex,
    [[Writable]]: TRUE, [[Enumerable]]: TRUE, [[Configurable]]: TRUE}.

20. Call the [[DefineOwnProperty]] internal method of A with arguments
    "INPUT" and Property Descriptor {[[Value]]: S, [[Writable]]: TRUE,
    [[Enumerable]]: TRUE, [[Configurable]]: TRUE}.

21. Call the [[DefineOwnProperty]] internal method of A with arguments
    "LENGTH" and Property Descriptor {[[Value]]: n + 1}.

22. Let matchedSubstr be the matched substring (i.e. the portion of
    S between offset i inclusive and offset e exclusive).

23. Call the [[DefineOwnProperty]] internal method of A with arguments
    "0" and Property Descriptor {[[Value]]: matchedSubstr,
    [[Writable]]: TRUE, [[Enumerable]]: TRUE, [[Configurable]]: TRUE}.

24. For each integer i such that i > 0 and i ≤ n

    a.  Let captureI be i^th^ element of r's captures List.

    b.  Call the [[DefineOwnProperty]] internal method of A with
        arguments ToString(i) and Property Descriptor {[[Value]]:
        captureI, [[Writable]]: TRUE, [[Enumerable]]: TRUE,
        [[Configurable]]: TRUE}.

25. Return A.

get RegExp.prototype.global 

REGEXP.PROTOTYPE.GLOBAL is an accessor property whose set accessor
function is UNDEFINED. Its get accessor function performs the following
steps:

1.  Let R be the THIS value.

2.  If Type(R) is not Object, then throw a TYPEERROR exception.

3.  If R does not have a [[OriginalFlags]] internal data property
    throw a TYPEERROR exception.

4.  Let flags be the value of R’s [[OriginalFlags]] internal data
    property.

5.  If flags is UNDEFINED, then throw a TYPEERROR exception.

6.  If flags contains the character "G", then return TRUE.

7.  Return FALSE.

get RegExp.prototype.ignoreCase 

REGEXP.PROTOTYPE.IGNORECASE is an accessor property whose set accessor
function is UNDEFINED. Its get accessor function performs the following
steps:

1.  Let R be the THIS value.

2.  If Type(R) is not Object, then throw a TYPEERROR exception.

3.  If R does not have a [[OriginalFlags]] internal data property
    throw a TYPEERROR exception.

4.  Let flags be the value of R’s [[OriginalFlags]] internal data
    property.

5.  If flags is UNDEFINED, then throw a TYPEERROR exception.

6.  If flags contains the character "I", then return TRUE.

7.  Return FALSE.

get RegExp.prototype.multiline 

REGEXP.PROTOTYPE.MULTILINE is an accessor property whose set accessor
function is UNDEFINED. Its get accessor function performs the following
steps:

1.  Let R be the THIS value.

2.  If Type(R) is not Object, then throw a TYPEERROR exception.

3.  If R does not have a [[OriginalFlags]] internal data property
    throw a TYPEERROR exception.

4.  Let flags be the value of R’s [[OriginalFlags]] internal data
    property.

5.  If flags is UNDEFINED, then throw a TYPEERROR exception.

6.  If flags contains the character "M", then return TRUE.

7.  Return FALSE.

get RegExp.prototype.source 

REGEXP.PROTOTYPE.SOURCE is an accessor property whose set accessor
function is UNDEFINED. Its get accessor function performs the following
steps:

1.  Let R be the THIS value.

2.  If Type(R) is not Object, then throw a TYPEERROR exception.

3.  If R does not have a [[OriginalSource]] internal data property
    throw a TYPEERROR exception.

4.  If R does not have a [[OriginalFlags]] internal data property
    throw a TYPEERROR exception.

5.  Let src be the value of R’s [[OriginalSource]] internal data
    property.

6.  Let flags be the value of R’s [[OriginalFlags]] internal data
    property.

7.  If either src or flags is UNDEFINED, then throw a TYPEERROR
    exception.

8.  Return the result of the abstract operation EscapeRegExpPattern with
    arguments src and flags.

get RegExp.prototype.sticky 

REGEXP.PROTOTYPE.STICKY is an accessor property whose set accessor
function is UNDEFINED. Its get accessor function performs the following
steps:

1.  Let R be the THIS value.

2.  If Type(R) is not Object, then throw a TYPEERROR exception.

3.  If R does not have a [[OriginalFlags]] internal data property
    throw a TYPEERROR exception.

4.  Let flags be the value of R’s [[OriginalFlags]] internal data
    property.

5.  If flags is UNDEFINED, then throw a TYPEERROR exception.

6.  If flags contains the character "Y", then return TRUE.

7.  Return FALSE.

RegExp.prototype.test(string)

The following steps are taken:

1.  Let R be the THIS value.

2.  If Type(R) is not Object, then throw a TYPEERROR exception.

3.  If R does not have a [[RegExpMatcher]] internal data property,
    then throw a TYPEERROR exception.

4.  If the value of R’s [[RegExpMatcher]] internal data property is
    UNDEFINED, then throw a TYPEERROR exception.

5.  6.  7.  Let S be the value of ToString(string)

8.  ReturnIfAbrupt(S).

9.  Let match be the result of the RegExpExec abstract operation with
    arguments R and S.

10. ReturnIfAbrupt(match).

11. If match is not NULL, then return TRUE; else return FALSE.

get RegExp.prototype.unicode 

REGEXP.PROTOTYPE.UNICODE is an accessor property whose set accessor
function is UNDEFINED. Its get accessor function performs the following
steps:

1.  Let R be the THIS value.

2.  If Type(R) is not Object, then throw a TYPEERROR exception.

3.  If R does not have a [[OriginalFlags]] internal data property
    throw a TYPEERROR exception.

4.  Let flags be the value of R’s [[OriginalFlags]] internal data
    property.

5.  If flags is UNDEFINED, then throw a TYPEERROR exception.

6.  If flags contains the character "U", then return TRUE.

7.  Return FALSE.

RegExp.prototype.toString()

1.  Let R be the THIS value.

2.  If Type(R) is not Object, then throw a TYPEERROR exception.

3.  If R does not have a [[RegExpMatcher]] internal data property,
    then throw a TYPEERROR exception.

4.  If the value of R’s [[RegExpMatcher]] internal data property is
    UNDEFINED, then throw a TYPEERROR exception.

5.  Let pattern be the result of ToString(Get(R, "SOURCE")).

6.  ReturnIfAbrupt(pattern).

7.  Let result be the String value formed by concatenating "/",
    pattern, and "/".

8.  Let global be the result of ToBoolean(Get(R, "GLOBAL")).

9.  ReturnIfAbrupt(global).

10. If global is TRUE, then append "G" as the last character of
    result.

11. Let ignoreCase be the result of ToBoolean(Get(R, "IGNORECASE")).

12. ReturnIfAbrupt(ignoreCase).

13. If ignoreCase is TRUE, then append "I" as the last character of
    result.

14. Let multiline be the result of ToBoolean(Get(R, "MULTILINE")).

15. ReturnIfAbrupt(multiline).

16. If multiline is TRUE, then append "M" as the last character of
    result.

17. Let unicode be the result of ToBoolean(Get(R, "UNICODE")).

18. ReturnIfAbrupt(unicode).

19. If unicode is TRUE, then append "U" as the last character of
    result.

20. Let sticky be the result of ToBoolean(Get(R, "STICKY")).

21. ReturnIfAbrupt(sticky).

22. If sticky is TRUE, then append "Y" as the last character of
    result.

23. Return result.

NOTE The returned String has the form of a RegularExpressionLiteral
that evaluates to another RegExp object with the same behaviour as this
object.

RegExp.prototype.match (string)

When the MATCH method is called with argument string, the following
steps are taken:

1.  Let rx be the THIS value.

2.  If Type(rx) is not Object, then throw a TYPEERROR exception.

3.  If rx does not have a [[RegExpMatcher]] internal data property,
    then throw a TYPEERROR exception.

4.  If the value of rx’s [[RegExpMatcher]] internal data property is
    UNDEFINED, then throw a TYPEERROR exception.

5.  Let S be the value of ToString(string)

6.  ReturnIfAbrupt(S).

7.  Let global be the result of ToBoolean(Get(rx, "GLOBAL")).

8.  ReturnIfAbrupt(global).

9.  If global is not TRUE, then

    a.  Return the result of calling the abstract operation RegExpExec
        (see 15.10.6.2) with arguments rx and S.

10. Else global is TRUE,

    a.  Let putStatus be the result of Put(rx, "LASTINDEX", 0,
        TRUE).

    b.  ReturnIfAbrupt(putStatus).

    c.  Let A be the result of the abstract operation ArrayCreate with
        argument 0.

    d.  Let previousLastIndex be 0.

    e.  Let n be 0.

    f.  Let lastMatch be TRUE.

    g.  Repeat, while lastMatch is TRUE

        i.  Let result be the result of the abstract operation
            RegExpExec with arguments rx and S.

        ii. ReturnIfAbrupt(result).

        iii. If result is NULL, then set lastMatch to FALSE.

        iv. Else result is not NULL,

            1.  Let thisIndex be the result of ToInteger(Get(rx,
                "LASTINDEX")).

            2.  ReturnIfAbrupt(thisIndex).

            3.  If thisIndex = previousLastIndex then

                a.  Let putStatus be the result of Put(rx,
                    "LASTINDEX", thisIndex+1, TRUE).

                b.  ReturnIfAbrupt(putStatus).

                c.  Set previousLastIndex to thisIndex+1.

            4.  Else,

                a.  Set previousLastIndex to thisIndex.

            5.  Let matchStr be the result of Get(result, "0").

            6.  Let defineStatus be the result of
                DefinePropertyOrThrow(A, ToString(n), Property
                Descriptor {[[Value]]: matchStr, [[Writable]]: TRUE,
                [[Enumerable]]: TRUE, [[configurable]]: TRUE}).

            7.  ReturnIfAbrupt(defineStatus).

            8.  Increment n.

    h.  If n = 0, then return NULL.

    i.  Return A.

RegExp.prototype.replace (S, replaceValue)

When the REPLACE method is called with arguments S and replaceValue
the following steps are taken:

TODO: need tol finish this and have it make use of
GETREPLACESUBSTITUTION operation in 15.5.4.11

1.  Let rx be the THIS value.

2.  If Type(rx) is not Object, then throw a TYPEERROR exception.

3.  If rx does not have a [[RegExpMatcher]] internal data property,
    then throw a TYPEERROR exception.

4.  If the value of rx’s [[RegExpMatcher]] internal data property is
    UNDEFINED, then throw a TYPEERROR exception.

5.  Let string be ToString(S).

6.  ReturnIfAbrupt(string).

7.  If searchValue.global is FALSE, then search string for the first
    match of the regular expression searchValue. If
    searchValue.global is TRUE, then search string for all matches
    of the regular expression searchValue. Do the search in the same
    manner as in REGEXP.PROTOTYPE.MATCH, including the update of
    searchValue.LASTINDEX. Let m be the number of left capturing
    parentheses in searchValue (using NcapturingParens as specified
    in 15.10.2.1).

8.  If replaceValue is a function, then

    a.  For each matched substring, call the function with the following
        m + 3 arguments. Argument 1 is the substring that matched. If
        searchValue is a regular expression, the next m arguments
        are all of the captures in the MatchResult (see 15.10.2.1).
        Argument m + 2 is the offset within string where the match
        occurred, and argument m + 3 is string. The result is a
        String value derived from the original input by replacing each
        matched substring with the corresponding return value of the
        function call, converted to a String if need be.

9.  Else,

Let newstring denote the result of converting replaceValue to a
String. The result is a String value derived from the original input
String by replacing each matched substring with a String derived from
newstring by replacing elements in newstring by replacement text as
specified in

a.  Table 34. These $ replacements are done left-to-right, and, once
      such a replacement is performed, the new replacement text is not
      subject to further replacements. For example,
      "$1,$2".REPLACE(/(\$(\D))/G, "$$1-$1$2") returns "$1-$11,$1-$22".
      A $ in newstring that does not match any of the forms below is
      left as is.

RegExp.prototype.search (S)

When the search method is called with argument S, the following steps
are taken:

1.  Let rx be the THIS value.

2.  If Type(rx) is not Object, then throw a TYPEERROR exception.

3.  If rx does not have a [[RegExpMatcher]] internal data property,
    then throw a TYPEERROR exception.

4.  If the value of rx’s [[RegExpMatcher]] internal data property is
    UNDEFINED, then throw a TYPEERROR exception.

5.  Let string be ToString(S).

6.  ReturnIfAbrupt(string).

7.  Search the value string from its beginning for an occurrence of
    the regular expression pattern rx. Let result be a Number
    indicating the offset within string where the pattern matched, or
    –1 if there was no match. If an abrupt completion occurs during the
    search, result is that Completion Record. The LASTINDEX and GLOBAL
    properties of regexp are ignored when performing the search. The
    LASTINDEX property of regexp is left unchanged.

8.  Return result.

RegExp.prototype.split (string, limit)

Returns an Array object into which substrings of the result of
converting string to a String have been stored. The substrings are
determined by searching from left to right for matches of the THIS value
regular expression; these occurrences are not part of any substring in
the returned array, but serve to divide up the String value.

The THIS value may be an empty regular expression or a regular
expression that can match an empty String. In this case, regular
expression does not match the empty substring at the beginning or end of
the input String, nor does it match the empty substring at the end of
the previous separator match. (For example, if the regular expression
matches the empty String, the String is split up into individual code
unit elements; the length of the result array equals the length of the
String, and each substring contains one code unit.) Only the first match
at a given position of the THIS String is considered, even if
backtracking could yield a non-empty-substring match at that position.
(For example, /A*?/.SPLIT("AB") evaluates to the array ["A","B"], while
/A*/.SPLIT("AB") evaluates to the array["","B"].)

If the string is (or converts to) the empty String, the result depends
on whether the regular expression can match the empty String. If it can,
the result array contains no elements. Otherwise, the result array
contains one element, which is the empty String.

If the regular expression that contains capturing parentheses, then each
time separator is matched the results (including any UNDEFINED
results) of the capturing parentheses are spliced into the output array.
For example,

  /<(\/)?([^<>]+)>/.SPLIT("A<B>BOLD</B>AND<CODE>CODED</CODE>")

evaluates to the array

  ["A", UNDEFINED, "B", "BOLD", "/", "B", "AND", UNDEFINED,
   "CODE", "CODED", "/", "CODE", ""]

If limit is not UNDEFINED, then the output array is truncated so that
it contains no more than limit elements.

When the SPLIT method is called, the following steps are taken:

1.  Let rx be the THIS value.

2.  If Type(rx) is not Object, then throw a TYPEERROR exception.

3.  If rx does not have a [[RegExpMatcher]] internal data property,
    then throw a TYPEERROR exception.

4.  If the value of rx’s [[RegExpMatcher]] internal data property is
    UNDEFINED, then throw a TYPEERROR exception.

5.  Let matcher be the value of rx’s [[RegExpMatcher]] internal data
    property.

6.  Let S be ToString(string).

7.  ReturnIfAbrupt(S).

8.  Let A be the result of the abstract operation ArrayCreate with
    argument 0.

9.  ReturnIfAbrupt(A).

10. Let lengthA be 0.

11. If limit is UNDEFINED, let lim = 2^32^–1; else let lim =
    ToLength(limit).

12. Let s be the number of elements in S.

13. Let p = 0.

14. If lim = 0, return A.

15. If s = 0, then

    a.  Let z be the result of calling the matcher with arguments
        S and 0.

    b.  ReturnIfAbrupt(z).

    c.  If z is not FAILURE, return A.

    d.  Let status be the result of calling the [[DefineOwnProperty]]
        internal method of A with arguments "0" and Property
        Descriptor {[[Value]]: S, [[Writable]]: TRUE, [[Enumerable]]:
        TRUE, [[Configurable]]: TRUE}.

    e.  Assert: status is not an abrupt completion.

    f.  Return A.

16. Let q = p.

17. Repeat, while q ≠ s

    a.  Let z be the result of calling the matcher with arguments
        S and q

    b.  ReturnIfAbrupt(z).

    c.  If z is FAILURE, then let q = q+1.

    d.  Else z is not FAILURE,

        i.  z must be a State. Let e be z's endIndex and let
            cap be z's captures List.

        ii. If e = p, then let q = q+1.

        iii. Else e ≠ p,

            1.  Let T be a String value equal to the substring of S
                consisting of the elements at positions p (inclusive)
                through q (exclusive).

            2.  Let status be the result of calling the
                [[DefineOwnProperty]] internal method of A with
                arguments ToString(lengthA) and Property Descriptor
                {[[Value]]: T, [[Writable]]: TRUE, [[Enumerable]]:
                TRUE, [[Configurable]]: TRUE}.

            3.  Assert: status is not an abrupt completion.

            4.  Increment lengthA by 1.

            5.  If lengthA = lim, return A.

            6.  Let p = e.

            7.  Let i = 0.

            8.  Repeat, while i is not equal to the number of elements
                in cap.

                a.  Let i = i+1.

                b.  Let status be the result of calling the
                    [[DefineOwnProperty]] internal method of A with
                    arguments ToString(lengthA) and Property
                    Descriptor {[[Value]]: cap_[_i], [[Writable]]:
                    TRUE, [[Enumerable]]: TRUE, [[Configurable]]: TRUE}.

                c.  Assert: status is not an abrupt completion.

                d.  Increment lengthA by 1.

                e.  If lengthA = lim, return A.

            9.  Let q = p.

18. Let T be a String value equal to the substring of S consisting
    of the elements at positions p (inclusive) through s
    (exclusive).

19. Let status be the result of calling the [[DefineOwnProperty]]
    internal method of A with arguments ToString(lengthA) and
    Property Descriptor {[[Value]]: T, [[Writable]]: TRUE,
    [[Enumerable]]: TRUE, [[Configurable]]: TRUE}.

20. Assert: status is not an abrupt completion.

21. Return A.

The LENGTH property of the SPLIT method is 2.

NOTE 1 The SPLIT method ignores the value of the GLOBAL property of this
RegExp object.

RegExp.prototype.@@isRegExp 

The initial value of the @@isRegExp property is TRUE.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Properties of RegExp Instances

RegExp instances are ordinary objects that inherit properties from the
RegExp prototype object. RegExp instances have internal data properties
[[RegExpMatcher]], [[OriginalSource]], and [[OriginalFlags]].

The value of the [[RegExpMatcher]] internal data property is an
implementation dependent representation of the Pattern of the RegExp
object.

NOTE Prior to the 6^th^ Edition, REGEXP instances were specified as
having the own data properties SOURCE, GLOBAL, IGNORECASE, and
MULTILINE. Those properties are now specified as accessor properties of
RegExp.prototype.

RegExp instances also have the following properties.

lastIndex

The value of the LASTINDEX property specifies the String position at
which to start the next match. It is coerced to an integer when used
(see 15.10.6.2). This property shall have the attributes { [[Writable]]:
TRUE, [[Enumerable]]: FALSE, [[Configurable]]: FALSE }.

NOTE Unlike the other standard built-in properties of RegExp instances,
LASTINDEX is writable.


Error Objects

Instances of Error objects are thrown as exceptions when runtime errors
occur. The Error objects may also serve as base objects for user-defined
exception classes.

The Error Constructor 

The Error constructor is the %Error% intrinsic object and the initial
value of the ERROR property of the global object. When ERROR is called
as a function rather than as a constructor, it creates and initialises a
new Error object. Thus the function call ERROR(…) is equivalent to the
object creation expression NEW ERROR(…) with the same arguments.
However, if the THIS value value passed in the call is an Object with an
uninitialised [[ErrorData]] internal data property, it initialises the
THIS value using the argument value rather than creating a new object.
This permits ERROR to be used both as factory method and to perform
constructor instance initialization.

The ERROR constructor is designed to be subclassable. It may be used as
the value of an EXTENDS clause of a class declaration. Subclass
constructors that intended to inherit the specified ERROR behaviour
should include a SUPER call to the ERROR constructor to initialise
subclass instances.

Error (message)

When the ERROR function is called with argument message the following
steps are taken:

1.  Let func be this ERROR function object.

2.  Let O be the THIS value.

3.  If Type(O) is not Object or Type(O) is Object and O does not
    have an [[ErrorData]] internal data property or Type(O) is Object
    and O has an [[ErrorData]] internal data property and the value of
    [[ErrorData]] is not UNDEFINED, then

    a.  Let O be the result of calling
        OrdinaryCreateFromConstructor(func, "%ERRORPROTOTYPE%",
        ( [[ErrorData]]) ).

    b.  ReturnIfAbrupt(O).

4.  Assert: Type(O) is Object.

5.  Set the value of O’s [[ErrorData]] internal data property to any
    value other than UNDEFINED.

6.  7.  If message is not UNDEFINED, then

    a.  Let msg be ToString(message).

    b.  ReturnIfAbrupt(msg).

    c.  d.  Let msgDesc be the Property Descriptor {[[Value]]: msg,
        [[Writable]]: TRUE, [[Enumerable]]: FALSE, [[Configurable]]:
        TRUE}.

    e.  Let status be the result of DefinePropertyOrThrow(O,
        "MESSAGE", msgDesc).

    f.  ReturnIfAbrupt(status).

    g.  

8.  Return O.

new Error(... argumentsList)

When ERROR called as part of a new expression with argument list
argumentsList it performs the following steps:

1.  Let F be the ERROR function object on which the NEW operator was
    applied.

2.  Let argumentsList be the argumentsList argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of OrdinaryConstruct (F, argumentsList).

If ERROR is implemented as an ordinary function object, its
[[Construct]] internal method will perform the above steps.

Properties of the Error Constructor

The value of the [[Prototype]] internal data property of the Error
constructor is the Function prototype object (15.3.3).

Besides the internal properties and the LENGTH property (whose value is
1), the Error constructor has the following property:

Error.prototype

The initial value of ERROR.PROTOTYPE is the Error prototype object
(15.11.4).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Error[ @@create ] ( )

The @@create method of an object F performs the following steps:

1.  Let F be the THIS value.

2.  Let obj be the result of calling
    OrdinaryCreateFromConstructor(F, "%ERRORPROTOTYPE%", (
    [[ErrorData]]) ).

3.  Return obj.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

NOTE [[ErrorData]] is initially assigned the value UNDEFINED as a flag
to indicate that the instance has not yet been initialised by the Error
constructor. This flag value is never directly exposed to ECMAScript
code; hence implementation may choose to encode the flag in some other
manner.

Properties of the Error Prototype Object

The Error prototype object is an ordinary object. It is not an Error
instance and does not have an [[ErrorData] internal data property.

The value of the [[Prototype]] internal data property of the Error
prototype object is the standard built-in Object prototype object
(15.2.4).

Error.prototype.constructor

The initial value of ERROR.PROTOTYPE.CONSTRUCTOR is the built-in ERROR
constructor.

Error.prototype.name

The initial value of ERROR.PROTOTYPE.NAME is "ERROR".

Error.prototype.message

The initial value of ERROR.PROTOTYPE.MESSAGE is the empty String.

Error.prototype.toString ( )

The following steps are taken:

Properties of Error Instances

Error instances are ordinary objects that inherit properties from the
Error prototype object and have a [[ErrorData]] internal data property
whose initial value is UNDEFINED. The only specified uses of
[[ErrorData]] is to flag whether or not an Error instance has been
initialised by the Error constructor and to identify them as Error
objects within OBJECT.PROTOTYPE.TOSTRING.

Native Error Types Used in This Standard

A new instance of one of the NativeError objects below is thrown when
a runtime error is detected. All of these objects share the same
structure, as described in 15.11.7.

EvalError

This exception is not currently used within this specification. This
object remains for compatibility with previous editions of this
specification.

RangeError

Indicates a value that is not in the set or range of allowable values.
See 15.4.2.2, 15.4.5.1, 15.7.4.2, 15.7.4.5, 15.7.4.6, 15.7.4.7, and
15.9.5.43.

ReferenceError

Indicate that an invalid reference value has been detected. See 8.9.1,
8.9.2, 10.2.1, 10.2.1.1.4, 10.2.1.2.4, and 11.13.1.

SyntaxError

Indicates that a parsing error has occurred. See 11.1.5, 11.3.1, 11.3.2,
11.4.1, 11.4.4, 11.4.5, 11.13.1, 11.13.2, 12.2.1, 12.10.1, 12.14.1,
13.1, 15.1.2.1, 15.3.2.1, 15.10.2.2, 15.10.2.5, 15.10.2.9, 15.10.2.15,
15.10.2.19, 15.10.4.1, and 15.12.2.

TypeError

Indicates the actual type of an operand is different than the expected
type. See 8.6.2, 8.9.2, 8.10.5, 8.12.5, 8.12.7, 8.12.8, 8.12.9, 9.9,
9.10, 10.2.1, 10.2.1.1.3, 10.6, 11.2.2, 11.2.3, 11.4.1, 11.8.6, 11.8.7,
11.3.1, 13.2, 13.2.3, 15, 15.2.3.2, 15.2.3.3, 15.2.3.4, 15.2.3.5,
15.2.3.6, 15.2.3.7, 15.2.3.8, 15.2.3.9, 15.2.3.10, 15.2.3.11, 15.2.3.12,
15.2.3.13, 15.2.3.14, 15.2.4.3, 15.3.3.2, 15.3.3.3, 15.3.3.4, 15.3.3.5,
15.3.3.5.2, 15.3.3.5.3, 15.3.4, 15.3.4.3, 15.3.4.4, 15.4.3.3, 15.4.3.11,
15.4.3.16, 15.4.3.17, 15.4.3.18, 15.4.3.19, 15.4.3.20, 15.4.3.21,
15.4.3.22, 15.4.5.1, 15.5.4.2, 15.5.4.3, 15.6.4.2, 15.6.4.3, 15.7.4,
15.7.4.2, 15.7.4.4, 15.9.5, 15.9.5.44, 15.10.4.1, 15.10.6, 15.11.4.4 and
15.12.3.

URIError

Indicates that one of the global URI handling functions was used in a
way that is incompatible with its definition. See 15.1.3.

NativeError Object Structure

When an ECMAScript implementation detects a runtime error, it throws an
new instance of one of the NativeError objects defined in ‎15.11.5.
Each of these objects has the structure described below, differing only
in the name used as the constructor name instead of NativeError, in
the NAME property of the prototype object, and in the
implementation-defined MESSAGE property of the prototype object.

For each error object, references to NativeError in the definition
should be replaced with the appropriate error object name from 15.11.6.

NativeError Constructors 

When a NativeError constructor is called as a function rather than as
a constructor, it creates and initialises a new object. A call of the
object as a function is equivalent to calling it as a constructor with
the same arguments. However, if the THIS value value passed in the call
is an Object with an uninitialised [[ErrorData]] internal data property,
it initialises the THIS value using the argument value. This permits a
NativeError to be used both as factory method and to perform
constructor instance initialization.

The NativeError constructor is designed to be subclassable. It may be
used as the value of an EXTENDS clause of a class declaration. Subclass
constructors that intended to inherit the specified NativeError
behaviour should include a SUPER call to the NativeError constructor
to initialise subclass instances.

NativeError (message)

When a NativeError function is called with argument message the
following steps are taken:

1.  Let func be this NativeError function object.

2.  Let O be the THIS value.

3.  If Type(O) is not Object or Type(O) is Object and O does not
    have an [[ErrorData]] internal data property or Type(O) is Object
    and O has an [[ErrorData]] internal data property and the value of
    [[ErrorData]] is not UNDEFINED, then

    a.  Let O be the result of calling
        OrdinaryCreateFromConstructor(func,
        "%NATIVEERRORPROTOTYPE%", ( [[ErrorData]]) ).

    b.  ReturnIfAbrupt(O).

4.  Assert: Type(O) is Object.

5.  Set the value of O’s [[ErrorData]] internal data property to any
    value other than UNDEFINED.

6.  7.  If message is not UNDEFINED, then

    a.  Let msg be ToString(message).

    b.  c.  d.  Let msgDesc be the Property Descriptor {[[Value]]:
        msg, [[Writable]]: TRUE, [[Enumerable]]: FALSE,
        [[Configurable]]: TRUE}.

    e.  Let status be the result of DefinePropertyOrThrow(O,
        "MESSAGE", msgDesc).

    f.  ReturnIfAbrupt(status).

    g.  

8.  Return O.

The actual value of the string passed in step 3.a is either
"%EVALERRORPROTOTYPE%", "%RANGEERRORPROTOTYPE%",
"%REFERENCEERRORPROTOTYPE%", "%SYNTAXERRORPROTOTYPE%",
"%TYPEERRORPROTOTYPE%", or "%URIERRORPROTOTYPE%" corresponding to which
NativeError constructor is being defined.

new NativeError (... argumentsList )

When a NativeError constructor is called as part of a new expression
with argument list argumentsList it performs the following steps:

1.  Let F be this NativeError function object on which the NEW
    operator was applied.

2.  Let argumentsList be the argumentsList argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of OrdinaryConstruct (F, argumentsList).

If a NativeError constructor is implemented as an ordinary function
object, its [[Construct]] internal method will perform the above steps.

Properties of the NativeError Constructors

The value of the [[Prototype]] internal data property of a NativeError
constructor is the Error constructor object (15.11.1).

Besides the LENGTH property (whose value is 1), each NativeError
constructor has the following property:

NativeError.prototype

The initial value of NATIVEERROR.PROTOTYPE is a NativeError
prototype object (15.11.7.4). Each NativeError constructor has a
separate prototype object.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

NativeError [ @@create ] ( )

The @@create method of an object F performs the following steps:

1.  Let F be the THIS value.

2.  Let obj be the result of calling
    OrdinaryCreateFromConstructor(F, NativeErrorPrototype, (
    [[ErrorData]]) ).

3.  Return obj.

The actual value passed as NativeErrorPrototype in step 2 is either
"%EVALERRORPROTOTYPE%", "%RANGEERRORPROTOTYPE%",
"%REFERENCEERRORPROTOTYPE%", "%SYNTAXERRORPROTOTYPE%",
"%TYPEERRORPROTOTYPE%", or "%URIERRORPROTOTYPE%" corresponding to which
NativeError constructor is being defined.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

NOTE [[ErrorData]] is initially assigned the value UNDEFINED as a flag
to indicate that the instance has not yet been initialised by the
Boolean constructor. This flag value is never directly exposed to
ECMAScript code; hence implementation may choose to encode the flag in
some other manner.

Properties of the NativeError Prototype Objects

Each NativeError prototype object is an ordinary object. It is not an
Error instance and does not have an [[ErrorData] internal data property.

The value of the [[Prototype]] internal data property of each
NativeError prototype object is the standard built-in Error prototype
object (15.11.4).

NativeError.prototype.constructor

The initial value of the CONSTRUCTOR property of the prototype for a
given NativeError constructor is the NativeError constructor
function itself (15.11.7).

 NativeError.prototype.name

The initial value of the NAME property of the prototype for a given
NativeError constructor is a string consisting of the name of the
constructor (the name used instead of NativeError).

 NativeError.prototype.message

The initial value of the MESSAGE property of the prototype for a given
NativeError constructor is the empty String.

Properties of NativeError Instances

NativeError instances are ordinary objects that inherit properties
from their NativeError prototype object and have a [[ErrorData]]
internal data property whose initial value is UNDEFINED. The only
specified use of [[ErrorData]] is to flag whether or not an Error or
NativeError instance has been initialised by its constructor.


The JSON Object

The JSON object is a single ordinary object that contains two functions,
PARSE and STRINGIFY, that are used to parse and construct JSON texts.
The JSON Data Interchange Format is described in RFC 4627
<http://www.ietf.org/rfc/rfc4627.txt>. The JSON interchange format used
in this specification is exactly that described by RFC 4627 with two
exceptions:

-   The top level JSONText production of the ECMAScript JSON grammar
    may consist of any JSONValue rather than being restricted to being
    a JSONObject or a JSONArray as specified by RFC 4627.

-   Conforming implementations of JSON.PARSE and JSON.STRINGIFY must
    support the exact interchange format described in this specification
    without any deletions or extensions to the format. This differs from
    RFC 4627 which permits a JSON parser to accept non-JSON forms and
    extensions.

The value of the [[Prototype]] internal data property of the JSON object
is the standard built-in Object prototype object (15.2.4). The JSON
object has a [[JSONTag]] internal data property whose value is TRUE .
The value of the [[Extensible]] internal data property of the JSON
object is set to TRUE.

The JSON object does not have a [[Construct]] internal method; it is not
possible to use the JSON object as a constructor with the NEW operator.

The JSON object does not have a [[Call]] internal method; it is not
possible to invoke the JSON object as a function.

The JSON Grammar 

JSON.stringify produces a String that conforms to the following JSON
grammar. JSON.parse accepts a String that conforms to the JSON grammar.

The JSON Lexical Grammar

JSON is similar to ECMAScript source text in that it consists of a
sequence of Unicode characters conforming to the rules of
SourceCharacter. The JSON Lexical Grammar defines the tokens that make
up a JSON text similar to the manner that the ECMAScript lexical grammar
defines the tokens of an ECMAScript source text. The JSON Lexical
grammar only recognises the white space character specified by the
production JSONWhiteSpace. The JSON lexical grammar shares some
productions with the ECMAScript lexical grammar. All nonterminal symbols
of the grammar that do not begin with the characters “JSON” are defined
by productions of the ECMAScript lexical grammar.

Syntax

JSONWhiteSpace ::

<TAB>
<CR>
<LF>
<SP>

JSONString ::

" JSONStringCharacters~opt~ "

JSONStringCharacters ::

JSONStringCharacter JSONStringCharacters~opt~

JSONStringCharacter ::

SourceCharacter BUT NOT ONE OF " OR \ OR U+0000 THROUGH U+001F

\ JSONEscapeSequence

JSONEscapeSequence ::

JSONEscapeCharacter

U HexDigit HexDigit HexDigit HexDigit

JSONEscapeCharacter :: ONE OF

" / \ B F N R T

JSONNumber ::

-~opt~ DecimalIntegerLiteral JSONFraction~opt~ ExponentPart~opt~

JSONFraction ::

. DecimalDigits

JSONNullLiteral ::

NullLiteral

JSONBooleanLiteral ::

BooleanLiteral

The JSON Syntactic Grammar

The JSON Syntactic Grammar defines a valid JSON text in terms of tokens
defined by the JSON lexical grammar. The goal symbol of the grammar is
JSONText.

Syntax

JSONText :

JSONValue

JSONValue :

JSONNullLiteral
JSONBooleanLiteral
JSONObject
JSONArray
JSONString
JSONNumber

JSONObject :

{ }
{ JSONMemberList }

JSONMember :

JSONString : JSONValue

JSONMemberList :

JSONMember
JSONMemberList , JSONMember

JSONArray :

[ ]
[ JSONElementList ]

JSONElementList :

JSONValue
JSONElementList , JSONValue

JSON.parse ( text [ , reviver ] )

The PARSE function parses a JSON text (a JSON-formatted String) and
produces an ECMAScript value. The JSON format is a restricted form of
ECMAScript literal. JSON objects are realized as ECMAScript objects.
JSON arrays are realized as ECMAScript arrays. JSON strings, numbers,
booleans, and null are realized as ECMAScript Strings, Numbers,
Booleans, and NULL. JSON uses a more limited set of white space
characters than WhiteSpace and allows Unicode code points U+2028 and
U+2029 to directly appear in JSONString literals without using an
escape sequence. The process of parsing is similar to 11.1.4 and 11.1.5
as constrained by the JSON grammar.

The optional reviver parameter is a function that takes two
parameters, (key and value). It can filter and transform the
results. It is called with each of the key_/_value pairs produced by
the parse, and its return value is used instead of the original value.
If it returns what it received, the structure is not modified. If it
returns UNDEFINED then the property is deleted from the result.

1.  Let JText be ToString(text).

2.  ReturnIfAbrupt(JText).

3.  Parse JText interpreted as UTF-16 encoded Unicode characters using
    the grammars in 15.12.1. Throw a SYNTAXERROR exception if JText
    did not conform to the JSON grammar for the goal symbol JSONText.

4.  Let scriptText be the result of concatenating "(", JText, and
    ");".

5.  Let completion be the result of parsing and evaluating
    scriptText as if it was the source text of an ECMAScript Script
    but using JSONString in place of StringLiteral. Note that since
    JText conforms to the JSON grammar this result will be either a
    primitive value or an object that is defined by either an
    ArrayLiteral or an ObjectLiteral.

6.  Let unfiltered be completion.[[value]].

7.  If IsCallable(reviver) is TRUE, then

    a.  Let root be the result of the abstract operation ObjectCreate
        with the intrinsic object %ObjectPrototype% as its argument.

    b.  Call CreateOwnDataProperty(root, the empty String,
        unfiltered).

    c.  Return the result of calling the abstract operation Walk,
        passing root and the empty String. The abstract operation Walk
        is described below.

8.  Else

    a.  Return unfiltered.

RUNTIME SEMANTICS: WALK ABSTRACT OPERATION

The abstract operation Walk is a recursive abstract operation that takes
two parameters: a holder object and the String name of a property in
that object. Walk uses the value of reviver that was originally passed
to the above parse function.

1.  Let val be the result of Get(holder, name).

2.  ReturnIfAbrupt(val).

3.  If val is an object, then

    a.  If val is an exotic Array object then

        i.  Set I to 0.

        ii. Let len be the result of Get(val, "LENGTH").

        iii. Assert: len is not an abrupt completion and its value is
            a positive integer.

        iv. Repeat while I < len,

            1.  Let newElement be the result of calling the abstract
                operation Walk, passing val and ToString(I).

            2.  If newElement is UNDEFINED, then

                a.  Let status be the result of calling the [[Delete]]
                    internal method of val with ToString(I) as the
                    argument.

            3.  Else

                a.  Let status be the result of calling the
                    [[DefineOwnProperty]] internal method of val with
                    arguments ToString(I) and Property Descriptor
                    {[[Value]]: newElement, [[Writable]]: TRUE,
                    [[Enumerable]]: TRUE, [[Configurable]]: TRUE}.

                b.  NOTE This algorithm intentionally does not throw an
                    exception if status is FALSE.

            4.  ReturnIfAbrupt(status).

            5.  Add 1 to I.

    b.  Else

        i.  Let keys be an internal List of String values consisting
            of the names of all the own properties of val whose
            [[Enumerable]] attribute is TRUE. The ordering of the
            Strings is the same as that used by the OBJECT.KEYS standard
            built-in function.

        ii. For each String P in keys do,

            1.  Let newElement be the result of calling the abstract
                operation Walk, passing val and P.

            2.  If newElement is UNDEFINED, then

                a.  Let status be the result of calling the [[Delete]]
                    internal method of val with P as the argument.

            3.  Else

                a.  Let status be the result of calling the
                    [[DefineOwnProperty]] internal method of val with
                    arguments P and Property Descriptor {[[Value]]:
                    newElement, [[Writable]]: TRUE, [[Enumerable]]:
                    TRUE, [[Configurable]]: TRUE}.

                b.  NOTE This algorithm intentionally does not throw an
                    exception if status is FALSE.

            4.  ReturnIfAbrupt(status).

4.  Return the result of calling the [[Call]] internal method of
    reviver passing holder as thisArgument and with a List
    containing name and val as argumentsList.

It is not permitted for a conforming implementation of JSON.PARSE to
extend the JSON grammars. If an implementation wishes to support a
modified or extended JSON interchange format it must do so by defining a
different parse function.

NOTE In the case where there are duplicate name Strings within an
object, lexically preceding values for the same key shall be
overwritten.

JSON.stringify ( value [ , replacer [ , space ] ] )

The STRINGIFY function returns a String in UTF-16 encoded JSON format
representing an ECMAScript value. It can take three parameters. The
value parameter is an ECMAScript value, which is usually an object or
array, although it can also be a String, Boolean, Number or NULL. The
optional replacer parameter is either a function that alters the way
objects and arrays are stringified, or an array of Strings and Numbers
that acts as a white list for selecting the object properties that will
be stringified. The optional space parameter is a String or Number
that allows the result to have white space injected into it to improve
human readability.

These are the steps in stringifying an object:

1.  Let stack be an empty List.

2.  Let indent be the empty String.

3.  Let PropertyList and ReplacerFunction be UNDEFINED.

4.  If Type(replacer) is Object, then

    a.  If IsCallable(replacer) is TRUE, then

        i.  Let ReplacerFunction be replacer.

    b.  Else if replacer is an exotic Array object, then

        i.  Let PropertyList be an empty internal List

        ii. For each value v of a property of replacer that has an
            array index property name. The properties are enumerated in
            the ascending array index order of their names.

            1.  Let item be UNDEFINED.

            2.  If Type(v) is String then let item be v.

            3.  Else if Type(v) is Number then let item be
                ToString(v).

            4.  Else if Type(v) is Object then,

                a.  If v has a [[StringData]] or [[NumberData]]
                    internal data property, then let item be
                    ToString(v).

            5.  If item is not UNDEFINED and item is not currently
                an element of PropertyList then,

                a.  Append item to the end of PropertyList.

5.  If Type(space) is Object then,

    a.  If space has a [[NumberData]] internal data property then,

        i.  Let space be ToNumber(space).

    b.  Else if space has a [[StringData]] internal data property
        then,

        i.  Let space be ToString(space).

6.  If Type(space) is Number

    a.  Let space be min(10, ToInteger(space)).

    b.  Set gap to a String containing space occurrences of code
        unit 0x0020 (the Unicode space character). This will be the
        empty String if space is less than 1.

7.  Else if Type(space) is String

    a.  If the number of elements in space is 10 or less, set gap to
        space otherwise set gap to a String consisting of the first
        10 elements of space.

8.  Else

    a.  Set gap to the empty String.

9.  Let wrapper be the result of the abstract operation ObjectCreate
    with the intrinsic object %ObjectPrototype% as its argument.

10. Call CreateOwnDataProperty(wrapper, the empty String, value).

11. Return the result of calling the abstract operation Str with the
    empty String and wrapper.

RUNTIME SEMANTICS: STR ABSTRACT OPERATION

The abstract operation Str_(_key, holder) has access to
ReplacerFunction from the invocation of the STRINGIFY method. Its
algorithm is as follows:

1.  Let value be the result of Get(holder, key).

2.  ReturnIfAbrupt(value).

3.  If Type(value) is Object, then

    a.  Let toJSON be the result of Get(value, "TOJSON").

    b.  If IsCallable(toJSON) is TRUE

        i.  Let value be the result of calling the [[Call]] internal
            method of toJSON passing value as thisArgument and a
            List containing key as argumentsList.

        ii. ReturnIfAbrupt(value).

4.  If ReplacerFunction is not UNDEFINED, then

    a.  Let value be the result of calling the [[Call]] internal
        method of ReplacerFunction passing holder as the THIS value
        and with an argument list consisting of key and value.

    b.  ReturnIfAbrupt(value).

5.  If Type(value) is Object then,

    a.  If value has an [[NumberData]] internal data property then,

        i.  Let value be ToNumber(value).

    b.  Else if value has an [[StringData]] internal data property
        then,

        i.  Let value be ToString(value).

    c.  Else if value has an [[BooleanData]] internal data property
        then,

        i.  Let value be the value of the [[BooleanData]] internal
            data property of value.

6.  If value is NULL then return "NULL".

7.  If value is TRUE then return "TRUE".

8.  If value is FALSE then return "FALSE".

9.  If Type(value) is String, then return the result of calling the
    abstract operation Quote with argument value.

10. If Type(value) is Number

    a.  If value is finite then return ToString(value).

    b.  Else, return "NULL".

11. If Type(value) is Object, and IsCallable(value) is FALSE

    a.  If value is an exotic Array object then

        i.  Return the result of calling the abstract operation JA with
            argument value.

    b.  Else, return the result of calling the abstract operation JO
        with argument value.

12. Return UNDEFINED.

RUNTIME SEMANTICS: QUOTE ABSTRACT OPERATION

The abstract operation Quote(value) wraps a String value in double
quotes and escapes characters within it.

1.  Let product be code unit 0x0022 (the Unicode double quote
    character).

2.  For each code unit C in value

    a.  If C is 0x0022 or 0x005C (the Unicode reverse solidus
        character)

        i.  Let product be the concatenation of product and code
            unit 0x005C.

        ii. Let product be the concatenation of product and C.

    b.  Else if C is backspace, formfeed, newline, carriage return, or
        tab

        i.  Let product be the concatenation of product and code
            unit 0x005C (the Unicode backslash character).

        ii. Let abbrev be the string value corresponding to the value
            of C as follows:

  backspace "B"

  formfeed "F"

  newline "N"

  carriage return "R"

  tab "T"

i.  Let product be the concatenation of product and abbrev.

a.  Else if C has a code unit value less than 0x0020 (the Unicode
    space character)

    i.  Let product be the concatenation of product and code unit
        0x005C (the Unicode backslash character).

    ii. Let product be the concatenation of product and "U".

    iii. Let hex be the string result of converting the numeric code
        unit value of C to a String of four hexadecimal digits.
        Alphabetic hexadecimal digits are presented as lowercase
        characters.

    iv. Let product be the concatenation of product and hex.

b.  Else

    i.  Let product be the concatenation of product and C.

1.  Let product be the concatenation of product and code unit 0x0022
    (the Unicode double quote character).

2.  Return product.

RUNTIME SEMANTICS: JO ABSTRACT OPERATION

The abstract operation JO(value) serializes an object. It has access
to the stack, indent, gap, and PropertyList of the invocation of
the stringify method.

RUNTIME SEMANTICS: JA ABSTRACT OPERATION

The abstract operation JA(value) serializes an array. It has access to
the stack, indent, and gap of the invocation of the stringify
method. The representation of arrays includes only the elements between
zero and ARRAY.LENGTH – 1 inclusive. Properties whose keys are not array
indexes are excluded from the stringification. An array is stringified
as an open left bracket, elements separated by comma, and a closing
right bracket.

NOTE 1 JSON structures are allowed to be nested to any depth, but they
must be acyclic. If value is or contains a cyclic structure, then the
stringify function must throw a TYPEERROR exception. This is an example
of a value that cannot be stringified:

  a = [];

  a[0] = a;

  my_text = JSON.stringify(a); // This must throw a TypeError.

NOTE 2 Symbolic primitive values are rendered as follows:

-   The NULL value is rendered in JSON text as the String NULL.

-   The UNDEFINED value is not rendered.

-   The TRUE value is rendered in JSON text as the String TRUE.

-   The FALSE value is rendered in JSON text as the String FALSE.

NOTE 3 String values are wrapped in double quotes. The characters " and
\ are escaped with \ prefixes. Control characters are replaced with
escape sequences \UHHHH, or with the shorter forms, \B (backspace), \F
(formfeed), \N (newline), \R (carriage return), \T (tab).

NOTE 4 Finite numbers are stringified as if by calling
ToString(number). NAN and Infinity regardless of sign are represented
as the String NULL.

NOTE 5 Values that do not have a JSON representation (such as UNDEFINED
and functions) do not produce a String. Instead they produce the
UNDEFINED value. In arrays these values are represented as the String
NULL. In objects an unrepresentable value causes the property to be
excluded from stringification.

NOTE 6 An object is rendered as an opening left brace followed by zero
or more properties, separated with commas, closed with a right brace. A
property is a quoted String representing the key or property name, a
colon, and then the stringified property value. An array is rendered as
an opening left bracket followed by zero or more values, separated with
commas, closed with a right bracket.


Binary Data Objects

The BinaryData Module

The BinaryData.Type Object

BinaryData.ScalarType Type Instance Objects

The BinaryData.ArrayType Object

The BinaryData.StructType Object

ArrayBuffer Objects

Abstract Operations For ArrayBuffer Objects

AllocateArrayBuffer(constructor)

The abstract operation AllocateArrayBuffer with argument constructor
is used to create an uninitialised ArrayBuffer object. It performs the
following steps:

1.  2.  Let obj be the result of calling
    OrdinaryCreateFromConstructor(constructor,
    "%ARRAYBUFFERPROTOTYPE%", ( [[ArrayBufferData]],
    [[ArrayBufferByteLength]]) ).

3.  ReturnIfAbrupt(obj).

4.  5.  Set the [[ArrayBufferByteLength]] internal data property of
    obj to 0.

6.  7.  8.  Return obj.

SetArrayBufferData(arrayBuffer, bytes)

The abstract operation SetArrayBufferData with arguments arrayBuffer
and bytes is used to initialise the storage block encapsulated by an
ArrayBuffer object. It performs the following steps:

1.  Assert: arrayBuffer has an [[ArrayBufferData]] internal data
    property.

2.  Assert: bytes is positive integer.

3.  Let block be the result of CreateByteArrayBlock(bytes).

4.  ReturnIfAbrupt(block).

5.  Set arrayBuffer’s [[ArrayBufferData]] to block.

6.  Set arrayBuffer’s [[ArrayBufferByteLength]] internal data property
    to bytes.

7.  Return arrayBuffer.

CloneArrayBuffer(srcBuffer, srcByteOffset, srcType,cloneElementType, srcLength).

The abstract operation 15.13.5.1.3 CloneArrayBuffer takes four
parameters, an ArrayBuffer srcBuffer, an integer srcByteOffset, a
String srcType, a String cloneElementType, and integer srcLength.
It creates a new ArrayBufer containing the binary cloneElementType
representation for srcLength elements convert from the corresponding
srcType elements start at srcByteOffset within srcBuffer.This
operation performs the follow steps:

TODO: Write the algorithm

GetValueFromBuffer (arrayBuffer, byteIndex, type, isLittleEndian)

The abstract operation GetValueFromBuffer takes four parameters, an
ArrayBuffer arrayBuffer, an integer byteIndex, a String type, and
optionally a Boolean isLittleEndian. If isLittleEndian is not
present, its default value is UNDEFINED. This operation performs the
follow steps:

1.  Assert: There are sufficient bytes in arrayBuffer starting at
    byteIndex to represent a value of valueType.

2.  Assert: byteIndex is a positive integer.

3.  Let block be arrayBuffer’s [[ArrayBufferData]] internal data
    property.

4.  If block is UNDEFINED or NULL, then throw a TYPEERROR exception.

5.  Let elementSize be the Number value of the Element Size value
    specified in Table 36 for valueType.

6.  Let rawValue be the elementSize bytes starting at byteIndex of
    block.

7.  If isLittleEndian is UNDEFINED, set isLittleEndian to either
    TRUE or FALSE. The choice is implementation dependent and should be
    the alternative that is most efficient for the implementation. An
    implementation must use the same value each time this step is
    executed and the same value must be used for the corresponding step
    in the SetValueInBuffer abstraction operation.

8.  If isLittleEndian is FALSE, reverse the order of the bytes of
    rawValue.

9.  If type is “Float32” , then

    a.  rawValue is interpreted as a little-endian bit string encoding
        of an IEEE 754-208 binary32 value.

    b.  If rawValue is an IEEE 754-208 binary32 NaN value, return the
        NAN Number value.

    c.  Return the Number value that is encoded by rawValue.

10. If type is “Float64” , then

    a.  rawValue is interpreted as a little-endian bit string encoding
        of an IEEE 754-208 binary64 value.

    b.  If rawValue is an IEEE 754-208 binary64 NaN value, return the
        NAN Number value.

    c.  Return the Number value that is encoded by rawValue.

11. If the first character of type is "U", then

    a.  Let intValue be the positive integer that is the result of
        interpreting rawValue as an unsigned little-endian binary
        number.

12. Else

    a.  Let intValue be the signed integer that is the result of
        interpreting rawValue as a little-endian binary 2’s complement
        number of bit length elementSize × 8.

13. Return intValue.

SetValueInBuffer (arrayBuffer, byteIndex, type, value, isLittleEndian)

The abstract operation SetValueInBuffer takes five parameters, an
ArrayBuffer arrayBuffer, an integer byteIndex, a String type, a
Number value, and optionally a Boolean isLittleEndian. If
isLittleEndian is not present, its default value is UNDEFINED. This
operation performs the follow steps:

1.  Assert: There are sufficient bytes in arrayBuffer starting at
    byteIndex to represent a value of valueType.

2.  Assert: byteIndex is a positive integer.

3.  Let block be arrayBuffer’s [[ArrayBufferData]] internal data
    property.

4.  If block is UNDEFINED or NULL, then throw a TYPEERROR exception.

5.  Let elementSize be the Number value of the Element Size value
    specified in Table 36 on the row with Element Type is type.

6.  Let rawValue be the elementSize bytes starting at byteIndex of
    arrayBuffer.

7.  If isLittleEndian is UNDEFINED, set isLittleEndian to either
    TRUE or FALSE. The choice is implementation dependent and should be
    the alternative that is most efficient for the implementation. An
    implementation must use the same value each time this step is
    executed and the same value must be used for the corresponding step
    in the GetValueFromBuffer abstraction operation.

8.  9.  If type is “Float32” , then

    a.  Set rawValue to the 4 bytes that are the result of converting
        value to IEEE-868-2005 binary32 format using “Round to
        nearest, ties to even” rounding mode. If isLittleEndian is
        FALSE, the bytes are arranged in big endian order. Otherwise,
        the bytes are arranged in little endian order. If value is
        NAN, rawValue is may be set of any implementation choosen
        non-signaling NaN encoding.

10. Else, if type is “Float64” , then

    a.  Set rawValue to the 8 bytes that are the IEEE-868-2005
        binary64 format encoding of value. If isLittleEndian is
        FALSE, the bytes are arranged in big endian order. Otherwise,
        the bytes are arranged in little endian order. If value is
        NAN, rawValue is may be set to any implementation choosen
        non-signaling NaN encoding.

11. Else,

    a.  Let n be the Size Element value in Table 36 for the row
        containing the value of type as its Element Type entry.

    b.  Let convOp be the abstract operation named in the Conversion
        Operation column in Table 36 for the row containing the value of
        type as its Element Type entry.

    c.  Let intValue be the result of calling convOp with value as
        its argument .

    d.  If intValue ≥ 0, then

        i.  Let rawBytes be the n-byte binary encoding of
            intValue. If isLittleEndian is FALSE, the bytes are
            arranged in big endian order. Otherwise, the bytes are
            arranged in little endian order.

    e.  Else,

        i.  Let rawBytes be the n-byte binary 2’s complement
            encoding of intValue. If isLittleEndian is FALSE, the
            bytes are arranged in big endian order. Otherwise, the bytes
            are arranged in little endian order.

12. Store the individual bytes of rawBytes in order starting at
    position byteIndex of block.

13. Return NormalCompletion (UNDEFINED).

The ArrayBuffer Constructor

The ArrayBuffer constructor is the %ArrayBuffer% intrinsic object and
the initial value of the ARRAYBUFFER property of the global object. When
ARRAYBUFFER is called as a function rather than as a constructor, its
THIS value must be an Object with an [[ArrayBufferData]] internal data
property whose value is UNDEFINED. The ArrayBuffer constructor
initialises the THIS value using the argument values.

The ARRAYBUFFER constructor is designed to be subclassable. It may be
used as the value of an EXTENDS clause of a class declaration. Subclass
constructors that intended to inherit the specified ARRAYBUFFER
behaviour must include a SUPER call to the ARRAYBUFFER constructor to
initialise subclass instances.

ArrayBuffer(length)

ArrayBuffer called as function with argument length performs the
following steps:

1.  Let O be the THIS value.

2.  If Type(O) is not Object or if O does not have an
    [[ArrayBufferData]] internal data property or if the value of O’s
    [[ArrayBufferData]] internal data property is not UNDEFINED, then

3.  4.  a.  Throw a TYPEERROR exception.

    b.  c.  

5.  6.  Let numberLength be ToNumber(length).

7.  Let byteLength be ToInteger(numberLength).

8.  ReturnIfAbrupt(byteLength).

9.  If numberLength ≠ byteLength or byteLength < 0, then throw a
    RANGEERROR exception.

10. Return the result of SetArrayBufferData(O, byteLength).

new ArrayBuffer( ... argumentsList)

ArrayBuffer called as part of a new expression performs the following
steps:

1.  Let F be the ArrayBuffer function object on which the NEW operator
    was applied.

2.  Let argumentsList be the argumentsList argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of OrdinaryConstruct(F, argumentsList).

If ArrayBuffer is implemented as an ordinary function object, its
[[Construct]] internal method will perform the above steps.

Properties of the ArrayBuffer Constructor

The value of the [[Prototype]] internal data property of the ArrayBuffer
constructor is the Function prototype object (‎15.3.3).

Besides its LENGTH property (whose value is 1), the ArrayBuffer
constructor has the following properties:

ArrayBuffer.prototype

The initial value of ArrayBuffer.prototype is the ArrayBuffer prototype
object (‎15.13.5.4).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

ArrayBuffer.isView ( arg )

The isView function takes one argument arg, and performs the following
steps are taken:

1.  If Type(arg) is not Object, return FALSE.

2.  3.  If arg has a [[ViewedArrayBuffer]] internal data property,
    then return TRUE.

4.  If arg has a [[ViewedDataArrayBuffer]] internal data property,
    then return TRUE.

5.  Return FALSE.

 ArrayBuffer[ @@create ] ( )

The @@create method of a ArrayBuffer function object F performs the
following steps:

1.  Let F be the THIS value.

2.  3.  Return the result of calling AllocateArrayBuffer(F).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Properties of the ArrayBuffer Prototype Object

The value of the [[Prototype]] internal data property of the ArrayBuffer
prototype object is the standard built-in Object prototype object
(15.2.4). The ArrayBuffer prototype object is an ordinary object. It
does not have a [[ArrayBufferData]] or [[ArrayBufferByteLength]]
internal data property.

ArrayBuffer.prototype.constructor

The initial value of ArrayBuffer.prototype.constructor is the standard
built-in ArrayBuffer constructor.

 get ArrayBuffer.prototype.byteLength 

ARRAYBUFFER.PROTOTYPE.BYTELENGTH is an accessor property whose set
accessor function is UNDEFINED. Its get accessor function performs the
following steps:

1.  Let O be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(O).

3.  If O does not have a [[ArrayBufferData]] internal data property
    throw a TYPEERROR exception.

4.  If the value of O’s [[ArrayBufferData]] internal data property is
    UNDEFINED or NULL, then throw a TYPEERROR exception.

5.  Let length be the value of O’s [[ArrayBufferByteLength]]
    internal data property.

6.  Return length.

ArrayBuffer.prototype.slice ( start , end)

The following steps are taken:

1.  Let O be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(O).

3.  If O does not have a [[ArrayBufferData]] internal data property
    throw a TYPEERROR exception.

4.  If the value of O’s [[ArrayBufferData]] internal data property is
    UNDEFINED or NULL, then throw a TYPEERROR exception.

5.  Let len be the value of O’s [[ArrayBufferByteLength]] internal
    data property.

6.  Let relativeStart be ToInteger(start).

7.  ReturnIfAbrupt(relativeStart).

8.  If relativeStart is negative, let first be max((len +
    relativeStart),0); else let first be min(relativeStart,
    len).

9.  If end is UNDEFINED, let relativeEnd be len; else let
    relativeEnd be ToInteger(end).

10. ReturnIfAbrupt(relativeEnd).

11. If relativeEnd is negative, let final be max((len +
    relativeEnd),0); else let final be min(relativeEnd, len).

12. Let newLen be max(final_-_first,0).

13. Let ctor be the result of GetMethod(O, "CONSTRUCTOR").

14. ReturnIfAbrupt(ctor).

15. If IsConstructor(ctor) is FALSE, then throw a TYPEERROR exception.

16. Let new be the result of calling the [[Construct]] internal method
    of ctor with a new List containing the single element newLen.

17. ReturnIfAbrupt(new).

18. If new does not have a [[ArrayBufferData]] internal data property
    throw a TYPEERROR exception.

19. If the value of new’s [[ArrayBufferData]] internal data property
    is UNDEFINED, then throw a TYPEERROR exception.

20. Let fromBuf be the value of O’s [[ArrayBufferData]] internal
    data property.

21. Let toBuf be the value of new’s [[ArrayBufferData]] internal
    data property.

22. Let status be the result of CopyBlockElements(fromBuf, first,
    toBuf, 0, newLen).

23. ReturnIfAbrupt(status).

24. Return new.

ArrayBuffer.prototype [ @@toStringTag ]

The initial value of the @@toStringTag property is the string value
"ARRAYBUFFER".

Properties of the ArrayBuffer Instances

ArrayBuffer instances inherit properties from the ArrayBuffer prototype
object. ArrayBuffer instances each have a [[ArrayBufferData]] internal
data property and a [[ArrayBufferByteLength]] internal data property.

ArrayBuffer instances whose [[ArrayBufferData]] is NULL are considered
to be neutered and all operators to access or modify data contained in
the ArrayBuffer instance will fail.

TypedArray Objects 

TypedArray objects present an array-like view of an underlying binary data buffer. Each element of a _TypedArray instance has the same underlying binary scalar data type. There_ is a distinct TypedArray constructor for each of tbe nine supported element types. 

For each constructor in Table 36 is a distinct TypedArray constructor
object with a corresponding prototype object and instances.

Table 36 – The TypedArray Constructors

  ------------------------------------------------------------------------------------------------------------------------------
  Constructor Name    Element   Element Size   Conversion Operation   Description                            Equivalent C Type
                      Type                                                                                   
  ------------------- --------- -------------- ---------------------- -------------------------------------- -------------------
  Int8Array           Int8      1              ToInt8                 8-bit 2’s complement signed integer    signed char

  Uint8Array          Uint8     1              ToUint8                8-bit unsigned integer                 unsigned char

  Uint8ClampedArray   Uint8C    1              ToUint8Clamp           8-bit unsigned integer (clamped)       unsigned char

  Int16Array          Int16     2              ToInt16                16-bit 2’s complement signed integer   Short

  Uint16Array         Uint16    2              ToUint16               16-bit unsigned integer                unsigned short

  Int32Array          Int32     4              ToInt32                32-bit 2’s complement signed integer   Int

  Uint32Array         Uint32    4              ToUint32               32-bit unsigned integer                unsigned int

  Float32Array        Float32   4                                     32-bit IEEE floating point             Float

  Float64Array        Float64   8                                     64-bit IEEE floating point             Double
  ------------------------------------------------------------------------------------------------------------------------------

In the definitions below, references to TypedArray should be replaced
with the appropriate constructor name from the above table. The phrase
“the element size in bytes” refers to the value in the Element Size
column of the table in the row corresponding to the constructor. The
phrase “element Type” refers to the value in the Element Type column for
that row.

The %TypedArray% Intrinsic Object

The %TypedArray% intrinsic object is a constructor-like function object
that all of the TypedArray constructor object inherit from.
%TypedArray% and its corresponding prototype object provide common
properties that are inherited by all TypeArray constructors and their
instances. The %TypedArray% intrinsic does not have a global name or
appear as a property of the global object.

However, if the THIS value value passed in the call is an Object with an
[[ViewedArrayBuffer]] internal data property whose value is UNDEFINED,
it initializes the THIS value using the argument values. This permits
super invocation of the TYPEDARRAY constructors by TYPEDARRAY
subclasses.

The %TypedArray% intrinsic function object is designed to act as the
superclass of the various TypedArray constructors. Those constructors
use %TypedArray% to initialize their instances by invoking %TypedArray%
as if by making a SUPER call. The %TypedArray% intrinsic function is not
designed to be directly called in any other way. If %TypedArray% is
directly called or called as part of a NEW expression an exception is
thrown.

The actual behaviour of a SUPER call of %TypedArray% depends upon the
number and kind of arguments that are passed to it.

%TypedArray% ( length )

This description applies if and only when %TypedArray% function is
called and the Type of the first argument is not Object.

%TypedArray% called with argument length performs the following steps:

1.  Assert: Type(length) is not Object.

2.  3.  Let O be the THIS value.

4.  5.  If Type(O) is not Object or if O does not have an
    [[ViewedArrayBuffer]] internal data property or if the value of
    O’s [[ViewedArrayBuffer]] internal data property is not UNDEFINED,
    then

    a.  Throw a TYPEERROR exception.

6.  If O does not have an [[TypedArrayName]] internal data property,
    then throw a TYPEERROR exception.

    a.  b.  

7.  Let constructorName be the string value O’s [[TypedArrayName]]
    internal data property.

8.  Let elementType be the string value of the Element Type value in
    Table 36 for constructorName.

9.  10. Let numberLength be ToNumber(length).

11. Let elementLength be ToInteger(numberLength).

12. ReturnIfAbrupt(elementLength).

13. If numberLength ≠ elementLength or elementLength < 0, then
    throw a RANGEERROR exception.

14. Let data be the result of calling
    AllocateArrayBuffer(%ArrayBuffer%).

15. ReturnIfAbrupt(data).

16. Let elementSize be the Size Element value in Table 36 for
    constructorName.

17. Let byteLength be elementSize × elementLength.

18. Let status be the result of SetArrayBufferData(data,
    byteLength).

19. ReturnIfAbrupt(status).

20. Set O’s [[ViewedArrayBuffer]] to data.

21. 22. Set O’s [[ByteLength]] internal data property to byteLength.

23. Set O’s [[ByteOffset]] internal data property to 0.

24. Set O’s [[ArrayLength]] internal data property to elementLength.

25. Return O.

%TypedArray% ( typedArray )

This description applies if and only if the %TypedArray% function is
called with at least one argument and the Type of the first argument is
Object and that object has a [[ViewedArrayBuffer]] internal data
property.

%TypedArray%called with argument typedArray performs the following
steps:

1.  Assert: Type(typedArray) is Object and typedArray has a
    [[ViewedArrayBuffer]] internal data property.

2.  Let srcArray be typedArray.

3.  4.  Let O be the THIS value.

5.  If Type(O) is not Object or if O does not have an
    [[ViewedArrayBuffer]] internal data property, then

6.  throw a TYPEERROR exception.

7.  If the value of O’s [[ViewedArrayBuffer]] internal data property
    is not UNDEFINED, then throw a TYPEERROR exception.

8.  If O does not have an [[TypedArrayName]] internal data property,
    then throw a TYPEERROR exception.

9.  If the value of srcArray’s [[ViewedArrayBuffer]] internal data
    property is UNDEFINED, then throw a TYPEERROR exception.

10. Let constructorName be the string value O’s [[TypedArrayName]]
    internal data property.

11. Let elementType be the string value of the Element Type value in
    Table 36 for constructorName.

12. 13. a.  b.  c.  

14. 15. Let elementLength be the value of srcArray’s [[ArrayLength]]
    internal data property.

16. Let srcName be the string value srcArray’s [[TypedArrayName]]
    internal data property.

17. Let srcType be the string value of the Element Type value in Table
    36 for srcName.

18. Let srcData be the value of srcArray’s [[ViewedArrayBuffer]]
    internal data property.

19. Let srcByteOffset be the value of srcArray’s [[ByteOffset]]
    internal data property.

20. Let data be the result of calling CloneArrayBuffer(srcData,
    srcByteOffset, srcType,elementType, elementLength).

21. ReturnIfAbrupt(data).

22. Let elementSize be the Size Element value in Table 36 for
    constructorName.

23. Let byteLength be elementSize × elementLength.

24. 25. 26. 27. Set O’s [[ViewedArrayBuffer]] to data.

28. 29. Set O’s [[ByteLength]] internal data property to byteLength.

30. Set O’s [[ByteOffset]] internal data property to 0.

31. Set O’s [[ArrayLength]] internal data property to elementLength.

32. Return O.

%TypedArray% ( array )

This description applies if and only if the %TypedArray% function is
called with at least one argument and the Type of first argument is
Object and that object does not have either a [[ViewedArrayBuffer]] or a
[[ArrayBufferData]] internal data property.

%TypedArray% called with argument array performs the following steps:

1.  Assert: Type(array) is Object and array does not have either a
    [[ViewedArrayBuffer]] or a [[ArrayBufferData]] internal data
    property.

2.  Let O be the THIS value.

3.  4.  Let srcArray be array.

5.  If Type(O) is not Object or if O does not have an
    [[ViewedArrayBuffer]] internal data property, then

6.  throw a TYPEERROR exception.

7.  If the value of O’s [[ViewedArrayBuffer]] internal data property
    is not UNDEFINED, then throw a TYPEERROR exception.

8.  If O does not have an [[TypedArrayName]] internal data property,
    then throw a TYPEERROR exception.

9.  Let constructorName be the string value O’s [[TypedArrayName]]
    internal data property.

10. Let elementType be the string value of the Element Type value in
    Table 36 for constructorName.

11. 12. a.  b.  c.  

13. 14. Let arrayLength be the result of Get(srcArray, "LENGTH").

15. 16. Let elementLength be ToLength(arrayLength ).

17. ReturnIfAbrupt(elementLength).

18. If elementLength < 0, then throw a RANGEERROR exception.

19. Let data be the result of calling
    AllocateArrayBuffer(%ArrayBuffer%).

20. ReturnIfAbrupt(data).

21. Let elementSize be the Size Element value in Table 36 for
    constructorName.

22. Let byteLength be elementSize × elementLength.

23. Let status be the result of SetArrayBufferData(data,
    byteLength)

24. ReturnIfAbrupt(status).

25. Let k be 0.

26. Repeat, while k < elementLength

    a.  Let Pk be ToString(k).

    b.  Let kValue be the result of Get(srcArray, Pk).

    c.  Let kNumber be ToNumber(kValue).

    d.  ReturnIfAbrupt(kNumber).

    e.  Perform SetValueInBuffer(data, k _× elementSize_,
        elementType, kNumber).

    f.  Increase k by 1.

27. 28. Set O’s [[ViewedArrayBuffer]] to data.

29. 30. Set O’s [[ByteLength]] internal data property to byteLength.

31. Set O’s [[ByteOffset]] internal data property to 0.

32. Set O’s [[ArrayLength]] internal data property to elementLength.

33. Return O.

%TypedArray% ( buffer, byteOffset=0, length=undefined )

This description applies if and only if the %TypedArray% function is
called with at least one argument and the Type of the first argument is
Object and that object has a [[ArrayBufferData]] internal data property.

%TypedArray% called with arguments buffer, byteOffset, and length
performs the following steps:

1.  Assert: Type(buffer) is Object and buffer has a
    [[ArrayBufferData]] internal data property.

2.  Let O be the THIS value.

3.  If the value of buffer’s [[ArrayBufferData]] internal data
    property is UNDEFINED, then throw a TYPEERROR exception.

4.  5.  6.  7.  If Type(O) is not Object or if O does not have an
    [[ViewedArrayBuffer]] internal data property, then

8.  throw a TYPEERROR exception.

9.  If the value of O’s [[ViewedArrayBuffer]] internal data property
    is not UNDEFINED, then throw a TYPEERROR exception.

10. If O does not have an [[TypedArrayName]] internal data property,
    then throw a TYPEERROR exception.

11. Let constructorName be the string value O’s [[TypedArrayName]]
    internal data property.

12. Let elementType be the string value of the Element Type value in
    Table 36 for constructorName.

13. Let elementSize be the Number value of the Element Size value in
    Table 36 for constructorName.

14. 15. Let offset be ToInteger(byteOffset).

16. ReturnIfAbrupt(offset).

17. If offset < 0, then throw a RANGEERROR exception.

18. If offset modulo elementSize ≠ 0, then throw a RANGEERROR
    exception.

19. Let bufferByteLength be the value of buffer’s
    [[ArrayBufferByteLength]] internal data property.

20. If offset + elementSize ≥ bufferByteLength, then throw a
    RANGEERROR exception.

21. If length is UNDEFINED, then

    a.  If bufferByteLength modulo elementSize ≠ 0, then throw a
        RANGEERROR exception.

    b.  Let newByteLength be bufferByteLength – offset.

22. Else,

    a.  b.  Let newLength be ToLength(length).

    c.  ReturnIfAbrupt(newLength).

    d.  If newLength < 0, then throw a RANGEERROR exception.

    e.  Let newByteLength be newLength × elementSize.

    f.  If offset_+_newByteLength > bufferByteLength, then throw a
        RANGEERROR exception.

23. If the value of O’s [[ViewedArrayBuffer]] internal data property
    is not UNDEFINED, then throw a TYPEERROR exception.

24. Set O’s [[ViewedArrayBuffer]] to buffer.

25. 26. Set O’s [[ByteLength]] internal data property to
    newByteLength.

27. Set O’s [[ByteOffset]] internal data property to offset.

28. Set O’s [[ArrayLength]] internal data property to newByteLength
    _/ elementSize_ .

29. Return O.

%TypedArray% ( binary data stuff )

TODO: this is a place holder assuming that we may need to construct
TypedArrays from binary data objects.

%TypedArray% ( all other argument combinations )

If the %TypedArray% function is called with arguments that do not match
any of the preceeding argument descriptions a TYPEERROR exception is
thrown.

1.  2.  3.  

1.  a.  b.  c.  d.  e.  f.  g.  

2.  a.  b.  c.  d.  i.  ii. iii. iv. v.  vi. vii. viii. ix. x.  xi. 

    e.  i.  ii. iii. iv. v.  vi. vii. 1.  2.  3.  4.  

        viii. ix. 

Properties of the %TypedArray% Intrinsic Object

The %TypedArray% intrinsic object is a built-in function object. The
value of the [[Prototype]] internal data property of %TypedArray% is the
Function prototype object (‎15.3.3).

The %TypedArray% intrinsic object does not have a
[[TypedArrayConstructor]] internal data property.

Besides a LENGTH property (whose value is 3), %TypedArray% has the
following properties:

%TypedArray%.prototype

The initial value of %TypedArray%.prototype is the %TypedArrayPrototype%
intrinsic object (‎15.13.6.3).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

%TypedArray%.of ( ...items )

When the OF method is called with any number of arguments, the following
steps are taken:

1.  Let lenValue be the result of Get(items, "LENGTH").

2.  Let len be ToInteger(lenValue).

3.  Let C be the THIS value.

4.  If IsConstructor(C) is TRUE, then

    a.  Let newObj be the result of OrdinaryConstruct(C, (len)).

    b.  

5.  Else,

    a.  Throw a TYPEERROR exception.

6.  ReturnIfAbrupt(newObj).

7.  Let k be 0.

8.  Repeat, while k < len

    a.  Let Pk be ToString(k).

    b.  Let kValue be the result of Get(items, Pk).

    c.  Let defineStatus be the result of Put(newObj_,_Pk,
        kValue.[[value]], TRUE).

    d.  ReturnIfAbrupt(defineStatus).

    e.  Increase k by 1.

9.  Return newObj.

The LENGTH property of the OF method is 0.

NOTE 1 The items argument is assumed to be a well-formed rest argument
value.

NOTE 2 The OF function is an intentionally generic factory method; it
does not require that its THIS value be a TypedArray constructor.
Therefore it can be transferred to or inherited by other constructors
that may be called with a single numeric argument. However, it does
assume that constructor creates and initializes a length property that
is initialized to its argument value.

%TypedArray%.from ( source , mapfn=undefined, thisArg=undefined )

When the FROM method is called with argument source, and optional
arguments mapfn and thisArg, the following steps are taken:

1.  Let C be the THIS value.

2.  If IsConstructor(C) is FALSE, then throw a TYPEERROR exception.

3.  Let items be ToObject(source).

4.  ReturnIfAbrupt(items).

5.  If mapfn is UNDEFINED, then let mapping be FALSE.

6.  else

    a.  If IsCallable(mapfn) is FALSE, throw a TYPEERROR exception.

    b.  If thisArg was supplied, let T be thisArg; else let T be
        UNDEFINED.

    c.  Let mapping be TRUE

7.  Let usingIterator be the result of HasProperty(items,
    @@Iterator).

8.  ReturnIfAbrupt(usingIterator).

9.  If usingIterator is TRUE, then

    a.  Let iterator be the result of performing GetIterator(items).

    b.  ReturnIfAbrupt(iterator).

    c.  Let values be a new empty List.

    d.  Let done be FALSE.

    e.  Repeat, while done is FALSE

        i.  Let next be the result of IteratorNext(iterator).

        ii. ReturnIfAbrupt(next).

        iii. Let done be IteratorComplete(next).

        iv. ReturnIfAbrupt(done).

        v.  If done is FALSE, then

            1.  Let nextValue be IteratorValue(next).

            2.  ReturnIfAbrupt(nextValue).

            3.  Append nextValue to the end of the List values.

    f.  Let len be the number of elements in values.

    g.  Let newObj be the result of OrdinaryConstruct(C, (len)).

    h.  i.  ReturnIfAbrupt(newObj).

    j.  Let k be 0.

    k.  Repeat, while k < len

        i.  Let Pk be ToString(k).

        ii. Let kValue be the first element of values and remove
            that element from list.

        iii. If mapping is TRUE, then

            1.  Let mappedValue be the result of calling the [[Call]]
                internal method of mapfn with T as thisArgument
                and a List containing kValue as argumentsList.

            2.  ReturnIfAbrupt(mappedValue).

        iv. Else, let mappedValue be kValue.

        v.  Let putStatus be the result of Put(newObj, Pk,
            mappedValue, TRUE).

        vi. ReturnIfAbrupt(putStatus).

        vii. Increase k by 1.

    l.  Assert: values is now an empty List.

    m.  Return newObj.

10. Assert: items is not an Iterator so assume it is Array-like.

11. Let lenValue be the result of Get(items, "LENGTH").

12. Let len be ToInteger(lenValue).

13. ReturnIfAbrupt(len).

14. Let newObj be the result of OrdinaryConstruct(C, (len)).

15. 16. ReturnIfAbrupt(newObj).

17. Let k be 0.

18. Repeat, while k < len

    a.  Let Pk be ToString(k).

    b.  Let kValue be the result of Get(items, Pk).

    c.  ReturnIfAbrupt(kValue).

    d.  If mapping is TRUE, then

        i.  Let mappedValue be the result of calling the [[Call]]
            internal method of mapfn with T as thisArgument and a
            List containing kValue, k, and items as
            argumentsList.

        ii. ReturnIfAbrupt(mappedValue).

    e.  Else, let mappedValue be kValue.

    f.  Let putStatus be the result of Put(newObj, Pk,
        mappedValue, TRUE).

    g.  ReturnIfAbrupt(putStatus).

    h.  Increase k by 1.

19. Return newObj.

NOTE The FROM function is an intentionally generic factory method; it
does not require that its THIS value be the Array constructor. Therefore
it can be transferred to or inherited by any other constructors that may
be called with a single numeric argument. This function uses [[Put]] to
store elements into a newly created object and assume that the
constructor sets the LENGTH property of the new object to the argument
value passed to it.

%TypedArray% [ @@create ] ( )

The @@create method of %TypedArray% performs the following steps:

1.  Let F be the THIS value.

2.  If Type(F) is not Object, then throw a TYPEERROR exception.

3.  If F does not have a [[TypedArrayConstructor]] internal data
    property, then throw a TYPEERROR exception.

4.  Let proto be the result of GetPrototypeFromConstructor(F,
    "%TypedArrayPROTOTYPE%").

5.  6.  7.  ReturnIfAbrupt(proto).

8.  a.  b.  i.  ii. 

    c.  

9.  Let obj be the result of calling IntegerIndexedObjectCreate
    (proto).

10. Add a [[ViewedArrayBuffer]] internal data property to obj and set
    its initial value to UNDEFINED.

11. Add a [[TypedArrayName]] internal data property to obj and set its
    initial value to the value of F’s [[TypedArrayConstructor]]
    internal data property .

12. Add a [[ByteLength]] internal data property to obj and set its
    initial value to 0.

13. Add a [[ByteOffset]] internal data property to obj and set its
    initial value to 0.

14. Add a [[ArrayLength]] internal data property to obj and set its
    initial value to 0.

15. Call the [[PreventExtensions]] internal method of obj.

16. 17. Return obj.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Properties of the %TypedArrayPrototype% Object

The value of the [[Prototype]] internal data property of the
%TypedArrayPrototype% object is the standard built-in Object prototype
object (‎15.2.4). The %TypedArrayPrototype% object is an ordinary
object. It does not have a [[ViewedArrayBuffer]] or or any other of the
internal data properties that are specific to TypedArray instance
objects.

%TypedArray%.prototype.constructor

The initial value of %TypedArray%.prototype.constructor is the
%TypedArray% intrinsic object.

get %TypedArray%.prototype.buffer

%TypedArray%.PROTOTYPE.BUFFER is an accessor property whose set accessor
function is UNDEFINED. Its get accessor function performs the following
steps:

1.  Let O be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(O).

3.  If O does not have a [[ViewedArrayBuffer]] internal data property
    throw a TYPEERROR exception.

4.  Let buffer be the value of O’s [[ViewedArrayBuffer]] internal
    data property.

5.  If buffer is UNDEFINED, then throw a TYPEERROR exception.

6.  Return buffer.

get %TypedArray%.prototype.byteLength

%TypedArray%.PROTOTYPE.BYTELENGTH is an accessor property whose set
accessor function is UNDEFINED. Its get accessor function performs the
following steps:

1.  Let O be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(O).

3.  If O does not have a [[ViewedArrayBuffer]] internal data property
    throw a TYPEERROR exception.

4.  Let buffer be the value of O’s [[ViewedArrayBuffer]] internal
    data property.

5.  If buffer is UNDEFINED, then throw a TYPEERROR exception.

6.  Let size be the value of O’s [[ByteLength]] internal data
    property.

7.  Return size.

get %TypedArray%.prototype.byteOffset

%TypedArray%.PROTOTYPE.BYTEOFFSET is an accessor property whose set
accessor function is UNDEFINED. Its get accessor function performs the
following steps:

1.  Let O be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(O).

3.  If O does not have a [[ViewedArrayBuffer]] internal data property
    throw a TYPEERROR exception.

4.  Let buffer be the value of O’s [[ViewedArrayBuffer]] internal
    data property.

5.  If buffer is UNDEFINED, then throw a TYPEERROR exception.

6.  Let offset be the value of O’s [[ByteOffset]] internal data
    property.

7.  Return offset.

get %TypedArray%.prototype.length

%TypedArray%.PROTOTYPE.LENGTH is an accessor property whose set accessor
function is UNDEFINED. Its get accessor function performs the following
steps:

1.  Let O be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(O).

3.  If O does not have a [[ViewedArrayBuffer]] internal data property
    throw a TYPEERROR exception.

4.  Let buffer be the value of O’s [[ViewedArrayBuffer]] internal
    data property.

5.  If buffer is UNDEFINED, then throw a TYPEERROR exception.

6.  Let length be the value of O’s [[ArrayLength]] internal data
    property.

7.  Return length.

%TypedArray%.prototype.set(array, offset = 0 )

Set multiple values in this TypedArray, reading the values from the
object array. The optional offset value indicates the first element
index in this TypedArray where values are written. If omitted, it is
assumed to be 0.

1.  Assert: typedArray does not have a [[ViewedArrayBuffer]] internal
    data property. If it does, the definition in ‎15.13.6.3.7 applies.

2.  Let target be the result of calling ToObject with the THIS value
    as its argument.

3.  ReturnIfAbrupt(target).

4.  If target does not have a [[ViewedArrayBuffer]] internal data
    property throw a TYPEERROR exception.

5.  Let targetBuffer be the value of target’s [[ViewedArrayBuffer]]
    internal data property.

6.  If targetBuffer is UNDEFINED, then throw a TYPEERROR exception.

7.  Let targetLength be the value of target’s [[ArrayLength]]
    internal data property.

8.  Let targetOffset be ToInteger (offset)

9.  ReturnIfAbrupt(targetOffset).

10. If targetOffset < 0, then throw a RANGEERROR exception.

11. Let targetName be the string value target’s [[TypedArrayName]]
    internal data property.

12. 13. Let targetElementSize be the Number value of the Element Size
    value specified in Table 36 for targetName.

14. Let targetType be the string value of the Element Type value in
    Table 36 for targetName.

15. Let targetByteOffset be the value of target’s [[ByteOffset]]
    internal data property.

16. Let src be the result of ToObject(array).

17. ReturnIfAbrupt(src).

18. Let srcLen be the result of Get(src, "LENGTH").

19. Let numberLength be ToNumber(srcLen).

20. Let srcLength be ToInteger(numberLength).

21. ReturnIfAbrupt(srcLength).

22. If numberLength ≠ srcLength or srcLength < 0, then throw a
    TYPEERROR exception.

23. 24. 25. If srcLength + targetOffset > targetLength, then throw
    a RANGEERROR exception.

26. Let targetByteIndex be targetOffset × targetElementSize +
    targetByteOffset.

27. Let k be 0.

28. Let limit be targetByteIndex + targetElementSize ×
    min(srcLength, targetLength – targetOffset).

29. Repeat, while targetByteIndex < limit

    a.  Let Pk be ToString(k).

    b.  Let kValue be the result of Get(src, Pk).

    c.  Let kNumber be ToNumber(kValue).

    d.  ReturnIfAbrupt(kNumber).

    e.  Perform SetValueInBuffer(targetBuffer, targetByteIndex,
        targetType, kNumber).

    f.  Set k to k + 1.

    g.  Set targetByteIndex to targetByteIndex +
        targetElementSize.

30. Return UNDEFINED.

%TypedArray%.prototype.set(typedArray, offset = 0 )

Set multiple values in this TypedArray, reading the values from the
typedArray argument object. The optional offset value indicates the
first element index in this TypedArray where values are written. If
omitted, it is assumed to be 0.

1.  Assert: typedArray has a [[ViewedArrayBuffer]] internal data
    property. If it does not, the definition in ‎15.13.6.3.6 applies.

2.  Let target be the result of calling ToObject with the THIS value
    as its argument.

3.  ReturnIfAbrupt(target).

4.  If target does not have a [[ViewedArrayBuffer]] internal data
    property throw a TYPEERROR exception.

5.  Let targetBuffer be the value of target’s [[ViewedArrayBuffer]]
    internal data property.

6.  If targetBuffer is UNDEFINED, then throw a TYPEERROR exception.

7.  Let targetLength be the value of target’s [[ArrayLength]]
    internal data property.

8.  9.  Let targetOffset be ToInteger (offset)

10. ReturnIfAbrupt(targetOffset).

11. If targetOffset < 0, then throw a RANGEERROR exception.

12. Let targetName be the string value target’s [[TypedArrayName]]
    internal data property.

13. Let targetType be the string value of the Element Type value in
    Table 36 for targetName.

14. Let targetElementSize be the Number value of the Element Size
    value specified in Table 36 for targetName.

15. Let targetByteOffset be the value of target’s [[ByteOffset]]
    internal data property.

16. 17. 18. 19. Let srcBuffer be the value of typedArray’s
    [[ViewedArrayBuffer]] internal data property.

20. If srcBuffer is UNDEFINED, then throw a TYPEERROR exception.

21. Let srcName be the string value typedArray’s [[TypedArrayName]]
    internal data property.

22. Let srcType be the string value of the Element Type value in Table
    36 for srcName .

23. Let srcElementSize be the Number value of the Element Size value
    specified in Table 36 for srcName.

24. Let srcLength be the value of typedArray’s [[ArrayLength]]
    internal data property.

25. Let srcByteOffset be the value of typedArray’s [[ByteOffset]]
    internal data property.

26. If srcLength + targetOffset > targetLength, then throw a
    RANGEERROR exception.

27. 28. If SameValue(srcBuffer, targetBuffer) is TRUE, then

    a.  Let srcBuffer be the result of calling
        CloneArrayBuffer(srcBuffer, srcByteOffset, srcType,
        srcType, srcLength).

    b.  Let srcByteIndex be 0.

29. Else, let srcByteIndex be srcByteOffset.

30. Let targetByteIndex be targetOffset × targetElementSize +
    targetByteOffset.

31. 32. Let limit be targetByteIndex + targetElementSize ×
    min(srcLength, targetLength – targetOffset).

33. Repeat, while targetByteIndex < limit

    a.  Let value be the result of GetValueFromBuffer (srcBuffer,
        srcByteIndex, srcType).

    b.  Let status be the result of SetValueInBuffer (targetBuffer,
        targetByteIndex, targetType, value).

    c.  Set srcByteIndex to srcByteIndex + srcElementSize.Return

    d.  Set targetByteIndex to targetByteIndex +
        targetElementSize.

34. Return UNDEFINED.

%TypedArray%.prototype.subarray(begin = 0, end = this.length )

1.  2.  3.  a.  b.  

4.  5.  a.  

1.  

Returns a new TypedArray object whose element types is the same as
this TypedArray and whose ArrayBuffer is the same as the ArrayBuffer
of this TypedArray, referencing the elements at begin, inclusive, up
to end, exclusive. If either begin or end is negative, it refers
to an index from the end of the array, as opposed to from the beginning.

1.  Let O be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(O).

3.  If O does not have a [[ViewedArrayBuffer]] internal data property
    throw a TYPEERROR exception.

4.  Let buffer be the value of O’s [[ViewedArrayBuffer]] internal
    data property.

5.  If buffer is UNDEFINED, then throw a TYPEERROR exception.

6.  7.  Let srcLength be the value of O’s [[ArrayLength]] internal
    data property.

8.  Let beginInt be ToInteger(begin)

9.  ReturnIfAbrupt(beginInt).

10. If beginInt < 0, then let beginInt be srcLength + beginInt.

11. Let beginIndex be min(srcLength, max(0, beginInt)).

12. If end is UNDEFINED, then let end be srcLength.

13. Let endInt be ToInteger(end).

14. ReturnIfAbrupt(endInt).

15. If endInt < 0, then let endInt be srcLength + endInt.

16. Let endIndex be max(0,min(srcLength, endInt)).

17. If endIndex < beginIndex, then let endIndex be beginIndex.

18. Let newLength be endIndex - beginIndex.

19. Let constructorName be the string value O’s [[TypedArrayName]]
    internal data property.

20. Let elementType be the string value of the Element Type value in
    Table 36 for constructorName.

21. Let elementSize be the Number value of the Element Size value
    specified in Table 36 for constructorName.

22. Let srcByteOffset be the value of O’s [[ByteOffset]] internal
    data property.

23. Let beginByteOffset be srcByteOffset + beginIndex ×
    elementSize.

24. Let constructor be the result of Get(O, "CONSTRUCTOR").

25. ReturnIfAbrupt(constructor).

26. If IsConstructor(constructor) is FALSE, then throw a TYPEERROR
    exception.

27. Let argumentsList be a List consisting of buffer,
    beginByteOffset, and newLength.

28. Return the result of calling the [[Construct]] internal method of
    constructor with argumentsList as the argument.

%TypedArray%.prototype.toString ( )

The initial value of the %TypedArray%.prototype.toString data property
is the same built-in function object as the Array.prototype.toString
method defined in ‎15.4.3.2.

%TypedArray%.prototype.toLocaleString ( )

The initial value of the %TypedArray%.prototype.toLocaleString data
property is the same built-in function object as the
Array.prototype.toLocaleString method defined in ‎15.4.3.3.

%TypedArray%.prototype.join ( separator )

%TypedArray%.PROTOTYPE.JOIN is a distinct function that implements the
same algorithm as ARRAY.PROTOTYPE.JOIN as defined in ‎15.4.3.5. However,
the implementation of the algorithm may be optimized to assume that the
this value is an object that has a fixed length and whose integer
indexed properties are not sparse.

%TypedArray%.prototype.reverse ( )

%TypedArray%.PROTOTYPE.REVERSE is a distinct function that implements
the same algorithm as ARRAY.PROTOTYPE.REVERSE as defined in ‎15.4.3.8.
However, the implementation of the algorithm may be optimized to assume
that the this value is an object that has a fixed length and whose
integer indexed properties are not sparse.

%TypedArray%.prototype.slice ( start, end )

The interpretation and use of the arguments of
%TypedArray%.PROTOTYPE.SLICE are the same as for ARRAY.PROTOTYPE.SLICE
as defined in ‎‎‎15.4.3.10. The following steps are taken:

1.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(O).

3.  Let lenVal be the result of Get(O, "LENGTH").

4.  Let len be ToLength(lenVal).

5.  ReturnIfAbrupt(len).

6.  Let relativeStart be ToInteger(start).

7.  ReturnIfAbrupt(relativeStart).

8.  If relativeStart is negative, let k be max((len +
    relativeStart),0); else let k be min(relativeStart, len).

9.  If end is UNDEFINED, let relativeEnd be len; else let
    relativeEnd be ToInteger(end).

10. ReturnIfAbrupt(relativeEnd).

11. If relativeEnd is negative, let final be max((len +
    relativeEnd),0); else let final be min(relativeEnd, len).

12. Let count be final – k.

13. Let C be the result of Get(O, "CONSTRUCTOR").

14. ReturnIfAbrupt(C).

15. If IsConstructor(C) is TRUE, then

    a.  Let A be the result of OrdinaryConstruct(C, (count)).

16. Else,

    a.  Throw a TYPEERROR exception.

17. Let n be 0.

18. Repeat, while k < final

    a.  Let Pk be ToString(k).

    b.  Let kValue be the result of Get(O, Pk).

    c.  ReturnIfAbrupt(kValue).

    d.  Let status be the result of Put(A, ToString(n), kValue,
        TRUE ).

    e.  ReturnIfAbrupt(status).

    f.  If status is FALSE, throw a TYPEERROR exception.

    g.  Increase k by 1.

    h.  Increase n by 1.

19. Return A.

The LENGTH property of the SLICE method is 2.

%TypedArray%.prototype.sort ( comparefn )

%TypedArray%.PROTOTYPE.SORT is a distinct function that implements the
same requirements as those of ARRAY.PROTOTYPE.SORT as defined in
‎‎15.4.3.11. However, the implementation of the
%TypedArray%.PROTOTYPE.SORT algorithm may be optimized to assume that
the this value is an object that has a fixed length and whose integer
indexed properties are not sparse. The only internal methods of the this
object call that the algorithm may use are [[Get]] and [[Set]].

The following version of SortCompare is used by
%TypedArray%.PROTOTYPE.SORT. It performs a numeric coparison rather than
the string comparsion used in ‎15.4.3.11.

The Typed Array SortCompare abstract operation is called with two
arguments j and k, the following steps are taken:

1.  Let jString be ToString(j).

2.  Let kString be ToString(k).

3.  Let x be the result of Get(obj_,_jString).

4.  ReturnIfAbrupt(x).

5.  Let y be the result of Get(obj, kString).

6.  ReturnIfAbrupt(y).

7.  Assert: Both Type(x) and Type(y) is Number.

8.  If x and y are both NAN, return +0.

9.  If x is NAN, return 1.

10. If y is NAN, return −1.

11. If the argument comparefn is not UNDEFINED, then

    a.  If IsCallable(comparefn) is FALSE, throw a TYPEERROR
        exception.

    b.  Return the result of calling the [[Call]] internal method of
        comparefn passing UNDEFINED as thisArgument and with a List
        containing the values of x and y as the argumentsList.

12. If x < yStrin, return −1.

13. If x > y, return 1.

14. Return +0.

NOTE 1 Because NAN always compares greater than any other value, NAN
property values always sort to the end of the result.

%TypedArray%.prototype.indexOf (searchElement, fromIndex = 0 )

%TypedArray%.PROTOTYPE.INDEXOF is a distinct function that implements
the same algorithm as ARRAY.PROTOTYPE.INDEXOF as defined in ‎‎15.4.3.14.
However, the implementation of the algorithm may be optimized to assume
that the this value is an object that has a fixed length and whose
integer indexed properties are not sparse.

The LENGTH property of the INDEXOF method is 1.

%TypedArray%.prototype.lastIndexOf ( searchElement, fromIndex = this.length-1 )

%TypedArray%.PROTOTYPE.LASTINDEXOF is a distinct function that
implements the same algorithm as ARRAY.PROTOTYPE.LASTINDEXOF as defined
in ‎15.4.3.15. However, the implementation of the algorithm may be
optimized to assume that the this value is an object that has a fixed
length and whose integer indexed properties are not sparse.

The LENGTH property of the LASTINDEXOF method is 1.

%TypedArray%.prototype.every ( callbackfn, thisArg = undefined )

%TypedArray%.PROTOTYPE.EVERY is a distinct function that implements the
same algorithm as ARRAY.PROTOTYPE.EVERY as defined in ‎‎15.4.3.16.
However, the implementation of the algorithm may be optimized to assume
that the this value is an object that has a fixed length and whose
integer indexed properties are not sparse.

The LENGTH property of the EVERY method is 1.

%TypedArray%.prototype.some ( callbackfn, thisArg = undefined )

%TypedArray%.PROTOTYPE.SOME is a distinct function that implements the
same algorithm as ARRAY.PROTOTYPE.SOME as defined in ‎‎‎15.4.3.17.
However, the implementation of the algorithm may be optimized to assume
that the this value is an object that has a fixed length and whose
integer indexed properties are not sparse.

The LENGTH property of the SOME method is 1.

%TypedArray%.prototype.forEach ( callbackfn, thisArg = undefined )

%TypedArray%.PROTOTYPE.FOREACH is a distinct function that implements
the same algorithm as ARRAY.PROTOTYPE.FOREACH as defined in ‎15.4.3.18.
However, the implementation of the algorithm may be optimized to assume
that the this value is an object that has a fixed length and whose
integer indexed properties are not sparse.

The LENGTH property of the FOREACH method is 1.

%TypedArray%.prototype.map ( callbackfn, thisArg = undefined )

The interpretation and use of the arguments of
%TypedArray%.PROTOTYPE.MAP are the same as for ARRAY.PROTOTYPE.MAP as
defined in ‎‎15.4.3.19.

When the MAP method is called with one or two arguments, the following
steps are taken:

1.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(O).

3.  Let lenValue be the result of Get(O, "LENGTH")

4.  Let len be ToLength(lenValue).

5.  ReturnIfAbrupt(len).

6.  If IsCallable(callbackfn) is FALSE, throw a TYPEERROR exception.

7.  If thisArg was supplied, let T be thisArg; else let T be
    UNDEFINED.

8.  Let C be the result of Get(O, "CONSTRUCTOR").

9.  ReturnIfAbrupt(C).

10. If IsConstructor(C) is TRUE, then

    a.  Let A be the result of OrdinaryConstruct(C, (len)).

11. Else,

    a.  Throw a TYPEERROR exception.

12. Let k be 0.

13. Repeat, while k < len

    a.  Let Pk be ToString(k).

    b.  Let kValue be the result of Get(O, Pk).

    c.  ReturnIfAbrupt(kValue).

    d.  Let mappedValue be the result of calling the [[Call]] internal
        method of callbackfn with T as thisArgument and a List
        containing kValue, k, and O as argumentsList.

    e.  ReturnIfAbrupt(mappedValue).

    f.  Let status be the result of Put(A, Pk, mappedValue, TRUE
        ).

    g.  ReturnIfAbrupt(mappedValue).

    h.  Increase k by 1.

14. Return A.

The LENGTH property of the MAP method is 1.

%TypedArray%.prototype.filter ( callbackfn, thisArg = undefined )

The interpretation and use of the arguments of
%TypedArray%.PROTOTYPE.FILTER are the same as for ARRAY.PROTOTYPE.FILTER
as defined in ‎15.4.3.20.

When the FILTER method is called with one or two arguments, the
following steps are taken:

1.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(O).

3.  Let lenValue be the result of Get(O, "LENGTH").

4.  Let len be ToLength(lenValue).

5.  ReturnIfAbrupt(len).

6.  If IsCallable(callbackfn) is FALSE, throw a TYPEERROR exception.

7.  If thisArg was supplied, let T be thisArg; else let T be
    UNDEFINED.

8.  Let C be the result of Get(O, "CONSTRUCTOR").

9.  ReturnIfAbrupt(C).

10. If IsConstructor(C) is FALSE, then

    a.  Throw a TYPEERROR exception.

11. Let kept be a new empty List.

12. Let k be 0.

13. Let captured be 0.

14. Repeat, while k < len

    a.  Let Pk be ToString(k).

    b.  Let kValue be the result of Get(O, Pk).

    c.  ReturnIfAbrupt(kValue).

    d.  Let selected be the result of calling the [[Call]] internal
        method of callbackfn with T as thisArgument and a List
        containing kValue, k, and O as argumentsList.

    e.  ReturnIfAbrupt(selected).

    f.  If ToBoolean(selected) is TRUE, then

        i.  Append kValue to the end of kept.

        ii. Increase captured by 1.

    g.  Increase k by 1.

15. Let A be the result of OrdinaryConstruct(C, (captured)).

16. Let n be 0.

17. For each element e of kept

    a.  Let status be the result of CreateOwnDataProperty(A,
        ToString(n), e).

    b.  Assert: status is TRUE.

    c.  Increment n by 1.

18. Return A.

The LENGTH property of the FILTER method is 1.

%TypedArray%.prototype.reduce ( callbackfn [, initialValue] )

%TypedArray%.PROTOTYPE.REDUCE is a distinct function that implements the
same algorithm as ARRAY.PROTOTYPE.REDUCE as defined in ‎15.4.3.21.
However, the implementation of the algorithm may be optimized to assume
that the this value is an object that has a fixed length and whose
integer indexed properties are not sparse.

The LENGTH property of the REDUCE method is 1.

%TypedArray%.prototype.reduceRight ( callbackfn [, initialValue] )

%TypedArray%.PROTOTYPE.REDUCERIGHT is a distinct function that
implements the same algorithm as ARRAY.PROTOTYPE.REDUCERIGHT as defined
in ‎15.4.3.22. However, the implementation of the algorithm may be
optimized to assume that the this value is an object that has a fixed
length and whose integer indexed properties are not sparse.

The LENGTH property of the REDUCERIGHT method is 1.

%TypedArray%.prototype.find (predicate, thisArg = undefined)

%TypedArray%.PROTOTYPE.FIND is a distinct function that implements the
same algorithm as ARRAY.PROTOTYPE.FIND as defined in ‎15.4.3.23.
However, the implementation of the algorithm may be optimized to assume
that the this value is an object that has a fixed length and whose
integer indexed properties are not sparse.

The LENGTH property of the FIND method is 1.

%TypedArray%.prototype.findIndex ( predicate, thisArg = undefined )

%TypedArray%.PROTOTYPE.FINDINDEX is a distinct function that implements
the same algorithm as ARRAY.PROTOTYPE.FINDINDEX as defined in
‎‎15.4.3.24. However, the implementation of the algorithm may be
optimized to assume that the this value is an object that has a fixed
length and whose integer indexed properties are not sparse.

The LENGTH property of the FINDINDEX method is 1.

%TypedArray%.prototype.fill (value, start = 0, end = this.length )

%TypedArray%.PROTOTYPE.FILL is a distinct function that implements the
same algorithm as ARRAY.PROTOTYPE.FILL as defined in ‎‎15.4.3.30.
However, the implementation of the algorithm may be optimized to assume
that the this value is an object that has a fixed length and whose
integer indexed properties are not sparse.

The LENGTH property of the FIND method is 1.

%TypedArray%.prototype.copyWithin (target, start, end = this.length )

%TypedArray%.PROTOTYPE.COPYWITHIN is a distinct function that implements
the same algorithm as ARRAY.PROTOTYPE.COPYWITHIN as defined in
‎‎‎15.4.3.31. However, the implementation of the algorithm may be
optimized to assume that the this value is an object that has a fixed
length and whose integer indexed properties are not sparse.

The LENGTH property of the FIND method is 2.

%TypedArray%.prototype.entries ( )

The initial value of the %TypedArray%.PROTOTYPE.ENTRIES data property is
the same built-in function object as the ARRAY.PROTOTYPE.ENTRIES method
defined in ‎‎15.4.3.25.

1.  2.  3.  

%TypedArray%.prototype.keys ( )

The initial value of the %TypedArray%.PROTOTYPE.KEYS data property is
the same built-in function object as the ARRAY.PROTOTYPE.KEYS method
defined in ‎15.4.3.26.

1.  2.  3.  

%TypedArray%.prototype.values ( )

The initial value of the %TypedArray%.PROTOTYPE.VALUES data property is
the same built-in function object as the ARRAY.PROTOTYPE.VALUES method
defined in ‎‎‎15.4.3.27.

1.  2.  3.  

%TypedArray%.prototype [ @@iterator ] ( )

The initial value of the @@iterator property is the same function object
as the initial value of the %TypedArray%.PROTOTYPE.VALUES property.

1.  

-   -   -   -   

1.  2.  3.  4.  5.  6.  7.  8.  9.  10. 11. 12. 13. 14. 15. 

1.  2.  3.  4.  5.  6.  7.  8.  9.  10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 

get %

TypedArray%.prototype [ @@toStringTag ]

%TypedArray%.PROTOTYPE[@@TOSTRINGTAG] is an accessor property whose set
accessor function is UNDEFINED. Its get accessor function performs the
following steps:

1.  Let O be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(O).

3.  If O does not have a [[TypedArrayName]] internal data property
    throw a TYPEERROR exception.

4.  Let name be the value of O’s [[TypedArrayName]] internal data
    property.

5.  Assert: name is a String value.

6.  Return name.

This property has the attributes { [[Enumerable]]: FALSE,
[[Configurable]]: TRUE }.

The TypedArray Constructors

Each of these TypedArray constructor objects has the structure
described below, differing only in the name used as the constructor name
instead of TypedArray, in Table 36.

When a TypedArray constructor is called as a function rather than as a
constructor, it initialises a new TypedArray object. The THIS value
value passed in the call must be an Object with an [[ViewedArrayBuffer]]
internal data property whose value is UNDEFINED. The constructor
function initialises the THIS value using the argument values.

The TYPEDARRAY constructors are designed to be subclassable. They may
be used as the value of an EXTENDS clause of a class declaration.
Subclass constructors that intended to inherit the specified
TYPEDARRAY behaviour must include a SUPER call to the TYPEDARRAY
constructor to initialise subclass instances.

new TypedArray( ... argumentsList)

A TypedArray constructor with a list of arguments argumentsList
performs the following steps:

1.  Let F be the TypedArray function object that was called.

2.  let realmF be F’s [[Realm]] internal data property.

3.  Let super be realmF’s intrinsic object named %TypedArray%.

4.  Let argumentsList be the argumentsList argument of the [[Call]]
    internal method that invoked F.

5.  Return the result of calling the [[Call]] internal method of super
    with F and argumentsList as arguments.

new TypedArray( ... argumentsList)

A TypedArray constructor called as part of a new expression performs
the following steps:

1.  Let F be the TypedArray function object on which the NEW
    operator was applied.

2.  Let argumentsList be the argumentsList argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of OrdinaryConstruct(F, argumentsList).

Properties of the TypedArray Constructors

The value of the [[Prototype]] internal data property of each
TypedArray constructor is the %TypedArray% intrinsic object
(‎15.13.6.1).

Each TypedArray constructor has a [[TypedArrayConstructor]] internal
data property whose String value is the constructor name in the
corresponding row in Table 36.

Besides a LENGTH property (whose value is 3), each TypedArray
constructor has the following properties:

TypedArray.prototype

The initial value of TypedArray.prototype is the corresponding
TypedArray prototype object (‎15.13.6.3).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

TypedArray_.BYTES_PERELEMENT

The value of TypedArray_.BYTES_PERELEMENT is the Number value of the
Element Size value specified in Table 36 for TypedArray.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Properties of TypedArray Prototype Objects

The value of the [[Prototype]] internal data property of a TypedArray
prototype object is the standard built-in %TypedArrayPrototype% object
(‎15.13.6.3). A TypedArray prototype object is an ordinary object. It
does not have a [[ViewedArrayBuffer]] or or any other of the internal
data properties that are specific to TypedArray instance objects.

TypedArray.prototype.constructor

The initial value of a TypedArray.prototype.constructor is the
corresponding standard built-in TypedArray constructor.

TypedArray_.prototype.BYTES_PERELEMENT

The value of TypedArray_.prototype.BYTES_PERELEMENT is the Number
value of the Element Size value specified in Table 36 for TypedArray.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Properties of TypedArray Instances

TypedArray instances are Integer Indexed exotic objects. Each
TypedArray instances inherits properties from the corresponding
TypedArray prototype object. Each TypedArray instances have the
following internal data properties: [[ViewedArrayBuffer]],
[[TypedArrayName]], [[ByteLength]], [[ByteOffset]], and [[ArrayLength]].

DataView Objects

Abstract Operations For DataView Objects

GetViewValue(view, requestIndex, isLittleEndian, type)

The abstract operation GetViewValue with arguments view,
requestIndex, isLittleEndian, and type is used by functions on
DataView instances is to retrieve values from the view’s buffer. It
performs the following steps:

1.  Let v be ToObject(view)

2.  ReturnIfAbrupt(v).

3.  If v does not have a [[DataArrayBuffer]] internal data property,
    then throw a TYPEERROR exception.

4.  Let buffer be the value of v’s [[DataArrayBuffer]] internal data
    property.

5.  If buffer is UNDEFINED, then throw a TYPEERROR exception.

6.  Let numberIndex be ToNumber(requestIndex)

7.  Let getIndex be ToInteger(numberIndex).

8.  ReturnIfAbrupt(getIndex).

9.  If numberIndex ≠ getIndex or getIndex < 0, then throw a
    RANGEERROR exception.

10. Let isLittleEndian be ToBoolean(isLittleEndian).

11. ReturnIfAbrupt(isLittleEndian).

12. Let viewOffset be the value of v’s [[ByteOffset]] internal data
    property.

13. Let viewSize be the value of v’s [[ByteLength]] internal data
    property.

14. Let elementSize be the Number value of the Element Size value
    specified in Table 36 for type.

15. If getIndex +elementSize > viewSize, then throw a RANGEERROR
    exception.

16. Let bufferIndex be getIndex_+_viewOffset.

17. Return the result of GetValueFromBuffer(buffer, bufferIndex,
    type, isLittleEndian).

SetViewValue(view, requestIndex, isLittleEndian, type, value)

The abstract operation SetViewValue with arguments view,
requestIndex, isLittleEndian, type, and value is used by
functions on DataView instances to store values into the view’s buffer.
It performs the following steps:

1.  Let v be ToObject(view)

2.  ReturnIfAbrupt(v).

3.  If v does not have a [[DataArrayBuffer]] internal data property,
    then throw a TYPEERROR exception.

4.  Let buffer be the value of v’s [[DataArrayBuffer]] internal data
    property.

5.  If buffer is UNDEFINED, then throw a TYPEERROR exception.

6.  Let numberIndex be ToNumber(requestIndex)

7.  Let getIndex be ToInteger(numberIndex).

8.  ReturnIfAbrupt(getIndex).

9.  If numberIndex ≠ getIndex or getIndex < 0, then throw a
    RANGEERROR exception.

10. Let isLittleEndian be ToBoolean(isLittleEndian).

11. ReturnIfAbrupt(isLittleEndian).

12. Let viewOffset be the value of v’s [[ByteOffset]] internal data
    property.

13. Let viewSize be the value of v’s [[ByteLength]] internal data
    property.

14. Let elementSize be the Number value of the Element Size value
    specified in Table 36 for type.

15. If getIndex +elementSize > viewSize, then throw a RANGEERROR
    exception.

16. Let bufferIndex be getIndex_+_viewOffset.

17. Return the result of SetValueInBuffer(buffer, bufferIndex,
    type, value, isLittleEndian).

NOTE The algorithms for GetViewValue and SetViewValue are identical
except for their final steps.

The DataView Constructor 

When DATAVIEW is called as a function rather than as a constructor, it
creates and initialises a new DATAVIEW object. Thus the function call
DATAVIEW(…) is equivalent to the object creation expression NEW
DATAVIEW(…) with the same arguments. However, if the THIS value value
passed in the call is an Object with an [[DataArrayBuffer]] internal
data property whose value is UNDEFINED, it initializes the THIS value
using the argument values. This permits DATAVIEW to be used both as
factory method and to perform constructor instance initialization.

The DATAVIEW constructor is designed to be subclassable. It may be used
as the value of an EXTENDS clause of a class declaration. Subclass
constructors that intended to inherit the specified DATAVIEW behaviour
must include a SUPER call to the DATAVIEW constructor to initialise
subclass instances.

DataView(buffer, byteOffset=0, byteLength=undefined)

1.  2.  3.  4.  5.  6.  7.  8.  9.  

DATAVIEW called with arguments buffer, byteOffset, and length
performs the following steps:

1.  Let O be the THIS value.

2.  If Type(O) is not Object or if O does not have an
    [[DataArrayBuffer]] internal data property or if the value of O’s
    [[DataArrayBuffer]] internal data property is not UNDEFINED, then

    a.  Let F be this function object.

    b.  Let argumentsList be the argumentsList argument of the
        [[Call]] internal method that invoked F.

    c.  Return the result of calling OrdinaryConstruct (F,
        argumentsList).

3.  If Type(buffer) is not Object, then throw a TYPEERROR exception.

4.  If buffer does not have a [[ArrayBufferData]] internal data
    property, then throw a TYPEERROR exception.

5.  Let numberOffset be ToNumber(byteOffset).

6.  Let offset be ToInteger(numberOffset).

7.  ReturnIfAbrupt(offset).

8.  If numberOffset ≠ offset or offset < 0, then throw a
    RANGEERROR exception.

9.  Let bufferByteLength be the value of buffer’s
    [[ArrayBufferByteLength]] internal data property.

10. If offset > bufferByteLength, then throw a RANGEERROR exception.

11. If byteLength is UNDEFINED, then

    a.  Let viewByteLength be bufferByteLength – offset.

12. Else,

    a.  Let numberLength be ToNumber(byteLength).

    b.  Let viewLength be ToInteger (numberLength).

    c.  ReturnIfAbrupt(viewLength).

    d.  If numberLength ≠ viewLength or viewLength < 0, then throw
        a RANGEERROR exception.

    e.  Let viewByteLength be viewLength.

    f.  If offset_+_viewByteLength > bufferByteLength, then throw a
        RANGEERROR exception.

13. If the value of O’s [[DataArrayBuffer]] internal data property is
    not UNDEFINED, then throw a TYPEERROR exception,

14. Set O’s [[DataArrayBuffer]] to buffer.

15. Set O’s [[ByteLength]] internal data property to viewByteLength.

16. Set O’s [[ByteOffset]] internal data property to offset.

17. Return O.

new DataView( ... argumentsList)

DATAVIEW called as part of a new expression it performs the following
steps:

1.  Let F be the function object on which the NEW operator was
    applied.

2.  Let argumentsList be the argumentsList argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of OrdinaryConstruct(F, argumentsList).

If DATAVIEW is implemented as an ordinary function object, its
[[Construct]] internal method will perform the above steps.

Properties of the DataView Constructor

The value of the [[Prototype]] internal data property of the DATAVIEW
constructor is the FUNCTION prototype object (‎15.3.3).

Besides the internal properties and the length property (whose value is
3), the DataView constructor has the following properties:

DataView.prototype

The initial value of DATAVIEW.PROTOTYPE is the DataView prototype object
(‎15.13.7.4).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

DataView [ @@create ] ( )

The @@create method of a DataView function object F performs the
following steps:

1.  Let F be the THIS value.

2.  Let obj be the result of calling
    OrdinaryCreateFromConstructor(F, "%DATAVIEWPROTOTYPE%", (
    [[DataArrayBuffer]] , [[ByteLength]], [[ByteOffset]]) ).

3.  Return obj.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Properties of the DataView Prototype Object

The value of the [[Prototype]] internal data property of the DataView
prototype object is the standard built-in Object prototype object
(15.2.4). The DataView prototype object is an ordinary object. It does
not have a [[DataArrayBuffer]], [[ByteLength]], or [[ByteOffset]]
internal data property.

1.  2.  3.  4.  5.  6.  

1.  2.  3.  4.  5.  6.  

DataView.prototype.constructor

The initial value of DATAVIEW.PROTOTYPE.CONSTRUCTOR is the standard
built-in DataView constructor.

get DataView.prototype.buffer

DATAVIEW.PROTOTYPE.BUFFER is an accessor property whose set accessor
function is UNDEFINED. Its get accessor function performs the following
steps:

1.  Let O be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(O).

3.  If O does not have a [[DataArrayBuffer]] internal data property
    throw a TYPEERROR exception.

4.  Let buffer be the value of O’s [[DataArrayBuffer]] internal data
    property.

5.  If buffer is UNDEFINED, then throw a TYPEERROR exception.

6.  Return buffer.

get DataView.prototype.byteLength

DATAVIEW.PROTOTYPE.BYTELENGTH is an accessor property whose set accessor
function is UNDEFINED. Its get accessor function performs the following
steps:

1.  Let O be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(O).

3.  If O does not have a [[DataArrayBuffer]] internal data property
    throw a TYPEERROR exception.

4.  Let buffer be the value of O’s [[ViewedDataArrayBuffer]]
    internal data property.

5.  If buffer is UNDEFINED, then throw a TYPEERROR exception.

6.  Let size be the value of O’s [[ByteLength]] internal data
    property.

7.  Return size.

get DataView.prototype.byteOffset

DATAVIEW.PROTOTYPE.BYTEOFFSET is an accessor property whose set accessor
function is UNDEFINED. Its get accessor function performs the following
steps:

1.  Let O be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(O).

3.  If O does not have a [[DataArrayBuffer]] internal data property
    throw a TYPEERROR exception.

4.  Let buffer be the value of O’s [[DataArrayBuffer]] internal data
    property.

5.  If buffer is UNDEFINED, then throw a TYPEERROR exception.

6.  Let offset be the value of O’s [[ByteOffset]] internal data
    property.

7.  Return offset.

DataView.prototype.getInt8(byteOffset)

When the GETINT8 method is called with argument byteOffset the
following steps are taken:

1.  2.  3.  Let v be the THIS value.

4.  Return the result of GetViewValue(v, byteOffset, UNDEFINED,
    "INT8").

DataView.prototype.getUint8(byteOffset)

When the GETUINT8 method is called with argument byteOffset the
following steps are taken:

1.  Let v be the THIS value.

2.  Return the result of GetViewValue(v, byteOffset, UNDEFINED,
    "UINT8").

1.  2.  3.  

DataView.prototype.getInt16(byteOffset, littleEndian=false)

When the GETINT16 method is called with argument byteOffset and
optional argument littleEndian the following steps are taken:

1.  Let v be the THIS value.

2.  If littleEndian is not present, then let littleEndian be FALSE.

3.  Return the result of GetViewValue(v, byteOffset, littleEndian,
    "INT16").

1.  2.  3.  4.  

DataView.prototype.getUint16(byteOffset, littleEndian=false)

When the GETUINT16 method is called with argument byteOffset and
optional argument littleEndian the following steps are taken:

1.  Let v be the THIS value.

2.  If littleEndian is not present, then let littleEndian be FALSE.

3.  Return the result of GetViewValue(v, byteOffset, littleEndian,
    "UINT16").

1.  2.  3.  4.  

DataView.prototype.getInt32(byteOffset, littleEndian=false)

When the GETINT32 method is called with argument byteOffset and
optional argument littleEndian the following steps are taken:

1.  Let v be the THIS value.

2.  If littleEndian is not present, then let littleEndian be
    UNDEFINED.

3.  Return the result of GetViewValue(v, byteOffset, littleEndian,
    "INT32").

1.  2.  3.  4.  

DataView.prototype.getUint32(byteOffset, littleEndian=false)

When the GETUINT32 method is called with argument byteOffset and
optional argument littleEndian the following steps are taken:

1.  Let v be the THIS value.

2.  If littleEndian is not present, then let littleEndian be FALSE.

3.  Return the result of GetViewValue(v, byteOffset, littleEndian,
    "UINT32").

1.  2.  3.  4.  

DataView.prototype.getFloat32(byteOffset, littleEndian=false)

When the GETFLOAT32 method is called with argument byteOffset and
optional argument littleEndian the following steps are taken:

1.  Let v be the THIS value.

2.  If littleEndian is not present, then let littleEndian be FALSE.

3.  Return the result of GetViewValue(v, byteOffset, littleEndian,
    "FLOAT32").

1.  2.  3.  4.  

DataView.prototype.getFloat64(byteOffset, littleEndian=false)

When the GETFLOAT64 method is called with argument byteOffset and
optional argument littleEndian the following steps are taken:

1.  Let v be the THIS value.

2.  If littleEndian is not present, then let littleEndian be FALSE.

3.  Return the result of GetViewValue(v, byteOffset, littleEndian,
    "FLOAT64").

1.  2.  3.  4.  

DataView.prototype.setInt8(byteOffset, value)

When the SETINT8 method is called with arguments byteOffset and
value the following steps are taken:

1.  Let v be the THIS value.

2.  Return the result of SetViewValue(v, byteOffset, UNDEFINED,
    "INT8", value).

1.  2.  3.  

DataView.prototype.setUint8(byteOffset, value)

When the SETUINT8 method is called with arguments byteOffset and
value the following steps are taken:

1.  Let v be the THIS value.

2.  Return the result of SetViewValue(v, byteOffset, UNDEFINED,
    "UINT8", value).

1.  2.  3.  

DataView.prototype.setInt16(byteOffset, value, littleEndian=false)

When the SETINT16 method is called with arguments byteOffset and
value and optional argument littleEndian the following steps are
taken:

1.  Let v be the THIS value.

2.  If littleEndian is not present, then let littleEndian be FALSE.

3.  Return the result of SetViewValue(v, byteOffset, littleEndian,
    "INT16", value).

1.  2.  3.  4.  

DataView.prototype.setUint16(byteOffset, value, littleEndian=false)

When the SETUINT16 method is called with arguments byteOffset and
value and optional argument littleEndian the following steps are
taken:

1.  Let v be the THIS value.

2.  If littleEndian is not present, then let littleEndian be FALSE.

3.  Return the result of SetViewValue(v, byteOffset, littleEndian,
    "UINT16", value).

1.  2.  3.  4.  

DataView.prototype.setInt32(byteOffset, value, littleEndian=false)

When the SETINT32 method is called with arguments byteOffset and
value and optional argument littleEndian the following steps are
taken:

1.  Let v be the THIS value.

2.  If littleEndian is not present, then let littleEndian be FALSE.

3.  Return the result of SetViewValue(v, byteOffset, littleEndian,
    "INT32", value).

1.  2.  3.  4.  

DataView.prototype.setUint32(byteOffset, value, littleEndian=false)

When the SETUINT32 method is called with arguments byteOffset and
value and optional argument littleEndian the following steps are
taken:

1.  Let v be the THIS value.

2.  If littleEndian is not present, then let littleEndian be FALSE.

3.  Return the result of SetViewValue(v, byteOffset, littleEndian,
    "UINT32", value).

1.  2.  3.  4.  

DataView.prototype.setFloat32(byteOffset, value, littleEndian=false)

When the SETFLOAT32 method is called with arguments byteOffset and
value and optional argument littleEndian the following steps are
taken:

1.  Let v be the THIS value.

2.  If littleEndian is not present, then let littleEndian be FALSE.

3.  Return the result of SetViewValue(v, byteOffset, littleEndian,
    "FLOAT32", value).

1.  2.  3.  4.  

DataView.prototype.setFloat64(byteOffset, value, littleEndian=false)

When the SETFLOAT64 method is called with arguments byteOffset and
value and optional argument littleEndian the following steps are
taken:

1.  Let v be the THIS value.

2.  If littleEndian is not present, then let littleEndian be FALSE.

3.  Return the result of SetViewValue(v, byteOffset, littleEndian,
    "FLOAT64", value).

DataView.prototype[ @@toStringTag ]

The initial value of the @@toStringTag property is the string value
"DATAVIEW".

1.  2.  3.  4.  

Properties of DataView Instances

DataView instances are ordinary objects that inherit properties from the
DataView prototype object. DataView instances each have a
[[DataArrayBuffer]], [[ByteLength]], and [[ByteOffset]] internal data
properties.


Map Objects

Map objects are collections of key/value pairs where both the keys and
values may be arbitrary ECMAScript language values. A distinct key value
may only occur in one key/value pair within the Map’s collection.
Distinct key values as discriminated using the a comparision algorithm
that is selected when the Map is created.

A Map object can iterate its elements in insertion order. Map object
must be implemented using either hash tables or other mechanisms that,
on average, provide access times that are sublinear on the number of
elements in the collection. The data structures used in this Map objects
specification is only intended to describe the required observable
semantics of Map objects. It is not intended to be a viable
implementation model.

1.  

2.  3.  4.  

    a.  b.  c.  d.  e.  f.  g.  h.  

5.  

6.  7.  8.  a.  b.  c.  d.  e.  

    f.  g.  h.  i.  j.  

The Map Constructor 

The Map constructor is the %Map% intrinsic object and the initial value
of the MAP property of the global object. When MAP is called as a
function rather than as a constructor, it initialises its THIS value
with the internal state necessary to support the MAP.PROTOTYPE internal
methods.

The MAP constructor is designed to be subclassable. It may be used as
the value in an EXTENDS clause of a class definition. Subclass
constructors that intend to inherit the specified MAP behaviour must
include a SUPER call to MAP.

Map (iterable = undefined , comparator = undefined ) 

When the MAP function is called with optional arguments iterable and
comparator the following steps are taken:

1.  Let map be the THIS value.

2.  If Type(map) is not Object then, throw a TYPEERROR exception.

3.  If map does not have a [[MapData]] internal data property, then
    throw a TYPEERROR exception.

4.  If map’s [[MapData]] internal data property is not UNDEFINED, then
    throw a TYPEERROR exception.

5.  a.  

6.  7.  8.  9.  If iterable is not present, let iterable be
    UNDEFINED.

10. If iterable is either UNDEFINED or NULL, then let iter be
    UNDEFINED.

11. Else,

    a.  b.  c.  i.  

    d.  i.  

    e.  Let iter be the result of GetIterator(iterable).

    f.  ReturnIfAbrupt(iter).

    g.  h.  Let adder be the result of Get(map, "SET").

    i.  ReturnIfAbrupt(adder).

    j.  If IsCallable(adder) is FALSE, throw a TYPEERROR Exception.

12. If comparator is not UNDEFINED, then

    a.  If comparator is not "IS", then throw a RANGEERROR Exception.

13. Set map’s [[MapData]] internal data property to a new empty List.

14. Set map’s [[MapComparator]] internal data property to
    comparator.

15. If iter is UNDEFINED, then return map.

16. Repeat

    a.  Let next be the result of IteratorNext(iter).

    b.  ReturnIfAbrupt(next).

    c.  d.  Let done be IteratorComplete(next).

    e.  ReturnIfAbrupt(done).

    f.  If done is TRUE, then return NormalCompletion(map).

    g.  h.  i.  Let nextItem be IteratorValue(next).

    j.  ReturnIfAbrupt(nextItem).

    k.  If Type(nextItem) is not Object, then throw a TYPEERROR
        execution.

    l.  Let k be the result of Get(nextItem, "0").

    m.  ReturnIfAbrupt(k).

    n.  Let v be the result of Get(nextItem, "1").

    o.  ReturnIfAbrupt(v).

    p.  Let status be the result of calling the [[Call]] internal
        method of adder with map as thisArgument and a List whose
        elements are k and v as argumentsList.

17. a.  ReturnIfAbrupt(status).

1.  

NOTE If the parameter iterable is present, it is expected to be an
object that implements either an @@iterator method that returns an
iterator object that produces two element array-like objects whose first
element is a value that will be used as an Map key and whose second
element is the value to associate with that key.

new Map ( ... argumentsList )

When MAP is called as part of a NEW expression it is a constructor: it
initialises a newly created object.

MAP called as part of a new expression with argument list
argumentsList performs the following steps:

1.  Let F be the Map function object on which the NEW operator was
    applied.

2.  Let argumentsList be the argumentsList argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of OrdinaryConstruct(F, argumentsList).

If Map is implemented as an ordinary function object, its [[Construct]]
internal method will perform the above steps.

1.  2.  3.  

4.  

5.  

Properties of the Map Constructor

The value of the [[Prototype]] internal data property of the Map
constructor is the Function prototype object (15.3.3).

Besides the LENGTH property (whose value is 0), the Map constructor has
the following property:

Map.prototype

The initial value of MAP.PROTOTYPE is the Map prototype object
(15.14.4).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Map[ @@create ] ( )

The @@create method of a Map function object F performs the following
steps:

1.  Let F be the THIS value.

2.  Let obj be the result of calling
    OrdinaryCreateFromConstructor(F, "%MAPPROTOTYPE%", ( [[MapData]] ,
    [[MapComparator]]) ).

3.  4.  5.  Return obj.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Properties of the Map Prototype Object

The value of the [[Prototype]] internal data property of the Map
prototype object is the standard built-in Object prototype object
(15.2.4). The Map prototype object is an ordinary object. It does not
have a [[MapData]] or a [[MapComparator]] internal data property.

Map.prototype.constructor

The initial value of MAP.PROTOTYPE.CONSTRUCTOR is the built-in MAP
constructor.

Map.prototype.clear ()

The following steps are taken:

1.  Let M be the THIS value.

2.  If Type(M) is not Object, then throw a TYPEERROR exception.

3.  If M does not have a [[MapData]] internal data property throw a
    TYPEERROR exception.

4.  If M’s [[MapData]] internal data property is UNDEFINED, then throw
    a TYPEERROR exception.

5.  Let entries be the List that is the value of M’s [[MapData]]
    internal data property.

6.  Repeat for each Record {[[key]], [[value]]} p that is an element
    of entries,

    a.  Set p.[[key]] to empty.

    b.  Set p.[[value]] to empty.

7.  8.  Return UNDEFINED.

Map.prototype.delete ( key )

The following steps are taken:

1.  Let M be the THIS value.

2.  If Type(M) is not Object, then throw a TYPEERROR exception.

3.  If M does not have a [[MapData]] internal data property throw a
    TYPEERROR exception.

4.  If M’s [[MapData]] internal data property is UNDEFINED, then throw
    a TYPEERROR exception.

5.  If M’s [[MapComparator]] internal data property is UNDEFINED, then
    let same be the abstract operation SameValueZero.

6.  Else, let same be the abstract operation SameValue.

7.  Let entries be the List that is the value of M’s [[MapData]]
    internal data property.

8.  Repeat for each Record {[[key]], [[value]]} p that is an element
    of entries,

    a.  If same_(_p.[[key]], key), then

        i.  Set p.[[key]] to empty.

        ii. Set p.[[value]] to empty.

        iii. Return TRUE.

9.  Return FALSE.

NOTE The value EMPTY is used as a specification device to indicate that
an entry has been deleted. Actual implementations may take other actions
such as physically removing the entry from internal data structures.

Map.prototype.forEach ( callbackfn , thisArg = undefined )

callbackfn should be a function that accepts three arguments. FOREACH
calls callbackfn once for each key/value pair present in the map
object, in key insertion order. callbackfn is called only for keys of
the map which actually exist; it is not called for keys that have been
deleted from the map.

If a thisArg parameter is provided, it will be used as the THIS value
for each invocation of callbackfn. If it is not provided, UNDEFINED is
used instead.

NOTE If callbackfn is an Arrow Function, THIS was lexically bound when
the function was created so thisArg will have no effect.

callbackfn is called with three arguments: the value of the item, the
key of the item, and the Map object being traversed.

FOREACH does not directly mutate the object on which it is called but
the object may be mutated by the calls to callbackfn.

NOTE Each key is visited only once with the value that is current at the
time of the visit. If the value associated with a key is modified after
it has been visited, it is not re-visited. Keys that are deleted after
the call to FOREACH begins and before being visited are not visited. New
keys added, after the call to FOREACH begins are visited.

When the FOREACH method is called with one or two arguments, the
following steps are taken:

1.  Let M be the THIS value.

2.  If Type(M) is not Object, then throw a TYPEERROR exception.

3.  If M does not have a [[MapData]] internal data property throw a
    TYPEERROR exception.

4.  If M’s [[MapData]] internal data property is UNDEFINED, then throw
    a TYPEERROR exception.

5.  If IsCallable(callbackfn) is FALSE, throw a TYPEERROR exception.

6.  If thisArg was supplied, let T be thisArg; else let T be
    UNDEFINED.

7.  Let entries be the List that is the value of M’s [[MapData]]
    internal data property.

8.  Repeat for each Record {[[key]], [[value]]} e that is an element
    of entries, in original key insertion order

    a.  If e.[[key]] is not empty, then

        i.  Let funcResult be the result of calling the [[Call]]
            internal method of callbackfn with T as thisArgument
            and a List containing e.[[value]], e.[[key]], and M as
            argumentsList.

        ii. ReturnIfAbrupt(funcResult).

9.  Return UNDEFINED.

The LENGTH property of the FOREACH method is 1.

Map.prototype.get ( key )

The following steps are taken:

1.  Let M be the THIS value.

2.  If Type(M) is not Object, then throw a TYPEERROR exception.

3.  If M does not have a [[MapData]] internal data property throw a
    TYPEERROR exception.

4.  If M’s [[MapData]] internal data property is UNDEFINED, then throw
    a TYPEERROR exception.

5.  Let entries be the List that is the value of M’s [[MapData]]
    internal data property.

6.  If M’s [[MapComparator]] internal data property is UNDEFINED, then
    let same be the abstract operation SameValueZero.

7.  Else, let same be the abstract operation SameValue.

8.  Repeat for each Record {[[key]], [[value]]} p that is an element
    of entries,

    a.  If same_(_p.[[key]], key), then return p.[[value]]

9.  Return UNDEFINED.

Map.prototype.has ( key )

The following steps are taken:

1.  Let M be the THIS value.

2.  If Type(M) is not Object, then throw a TYPEERROR exception.

3.  If M does not have a [[MapData]] internal data property throw a
    TYPEERROR exception.

4.  If M’s [[MapData]] internal data property is UNDEFINED, then throw
    a TYPEERROR exception.

5.  Let entries be the List that is the value of M’s [[MapData]]
    internal data property.

6.  If M’s [[MapComparator]] internal data property is UNDEFINED, then
    let same be the abstract operation SameValueZero.

7.  Else, let same be the abstract operation SameValue.

8.  Repeat for each Record {[[key]], [[value]]} p that is an element
    of entries,

    a.  If same_(_p.[[key]], key), then return TRUE.

9.  Return FALSE.

Map.prototype.entries ( )

The following steps are taken:

1.  Let M be the THIS value.

2.  If Type(M) is not Object, then throw a TYPEERROR exception.

3.  Return the result of calling the CreateMapIterator abstract
    operation with arguments M and "KEY+VALUE".

Map.prototype.keys ( )

The following steps are taken:

1.  Let M be the THIS value.

2.  If Type(M) is not Object, then throw a TYPEERROR exception.

3.  Return the result of calling the CreateMapIterator abstract
    operation with arguments M and "KEY".

Map.prototype.set ( key , value )

The following steps are taken:

1.  Let M be the THIS value.

2.  If Type(M) is not Object, then throw a TYPEERROR exception.

3.  If M does not have a [[MapData]] internal data property throw a
    TYPEERROR exception.

4.  If M’s [[MapData]] internal data property is UNDEFINED, then throw
    a TYPEERROR exception.

5.  Let entries be the List that is the value of M’s [[MapData]]
    internal data property.

6.  If M’s [[MapComparator]] internal data property is UNDEFINED, then
    let same be the abstract operation SameValueZero.

7.  Else, let same be the abstract operation SameValue.

8.  Repeat for each Record {[[key]], [[value]]} p that is an element
    of entries,

    a.  If same_(_p.[[key]], key), then

        i.  Set p.[[value]] to value.

        ii. Return M.

9.  Let p be the Record {[[key]]: key, [[value]]: value}

10. Append p as the last element of entries.

11. Return M.

get Map.prototype.size 

Map.prototype.size is an accessor property whose set accessor function
is UNDEFINED. Its get accessor function performs the following steps:

1.  Let M be the THIS value.

2.  If Type(M) is not Object, then throw a TYPEERROR exception.

3.  If M does not have a [[MapData]] internal data property throw a
    TYPEERROR exception.

4.  If M’s [[MapData]] internal data property is UNDEFINED, then throw
    a TYPEERROR exception.

5.  Let entries be the List that is the value of M’s [[MapData]]
    internal data property.

6.  Let count be 0.

7.  For each Record {[[key]], [[value]]} p that is an element of
    entries

    a.  If p.[[key]] is not empty then

        i.  Set count to count+1.

8.  Return count.

Map.prototype.values ( )

The following steps are taken:

1.  Let M be the THIS value.

2.  If Type(M) is not Object, then throw a TYPEERROR exception.

3.  Return the result of calling the CreateMapIterator abstract
    operation with arguments M and "VALUE".

Map.prototype.@@iterator ( )

The initial value of the @@iterator property is the same function object
as the initial value of the ENTRIES property.

Map.prototype [ @@toStringTag ]

The initial value of the @@toStringTag property is the string value
"MAP".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Properties of Map Instances

Map instances are ordinary objects that inherit properties from the Map
prototype. Map instances also have a [[MapData]] internal data property
and a [[MapComparator]] internal data property.

Map Iterator Object Structure

A Map Iterator is an object, with the structure defined below, that
represents a specific iteration over some specific Map instance object.
There is not a named constructor for Map Iterator objects. Instead, map
iterator objects are created by calling certain methods of Map instance
objects.

CreateMapIterator Abstract Operation

Several methods of Map objects return Iterator objects. The abstract
operation CreateMapIterator with arguments map and kind is used to
create such iterator objects. It performs the following steps:

1.  Let M be the result of calling ToObject(map).

2.  ReturnIfAbrupt(M).

3.  If M does not have a [[MapData]] internal data property throw a
    TYPEERROR exception.

4.  Let entries be the List that is the value of M’s [[MapData]]
    internal data property.

5.  Let iterator be the result of ObjectCreate(%MapIteratorPrototype%,
    ([[Map]], [[MapNextIndex]], [[MapIterationKind]])).

6.  Set iterator’s [[Map]] internal data property to M.

7.  Set iterator’s [[MapNextIndex]] internal data property to 0.

8.  Set iterator’s [[MapIterationKind]] internal data property to
    kind.

9.  Return iterator.

The Map Iterator Prototype

All Map Iterator Objects inherit properties from a common Map Iterator
Prototype object. The [[Prototype]] internal data property of the Map
Iterator Prototype is the %ObjectPrototype% intrinsic object. In
addition, the Map Iterator Prototype has the following properties:

MapIterator.prototype.constructor

MapIterator.prototype.next( )

1.  Let O be the THIS value.

2.  If Type(O) is not Object, throw a TYPEERROR exception.

3.  If O does not have all of the internal properties of a Map
    Iterator Instance (15.14.7.1.2), throw a TYPEERROR exception.

4.  Let m be the value of the [[Map]] internal data property of O.

5.  Let index be the value of the [[MapNextIndex]] internal data
    property of O.

6.  Let itemKind be the value of the [[MapIterationKind]] internal
    data property of O.

7.  Assert: m has a [[MapData]] internal data property and m has
    been initialised so the value of [[MapData]] is not UNDEFINED.

8.  Let entries be the List that is the value of the [[MapData]]
    internal data property of m.

9.  Repeat while index is less than the total number of elements of
    entries. The number of elements must be redetermined each time
    this method is evaluated.

    a.  Let e be the Record {[[key]], [[value]]} at 0-origined
        insertion position index of entries.

    b.  Set index to index+1;

    c.  Set the [[MapNextIndex]] internal data property of O to
        index.

    d.  If e.[[key]] is not empty, then

        i.  If itemKind is "KEY" then, let result be e.[[key]].

        ii. Else if itemKind is "VALUE" then, let result be
            e.[[value]].

        iii. Else,

            1.  Assert: itemKind is "KEY+VALUE".

            2.  Let result be the result of the abstract operation
                ArrayCreate with argument 2.

            3.  Assert: result is a new, well-formed Array object so
                the following operations will never fail.

            4.  Call CreateOwnDataProperty(result, "0", e.[[key]]) .

            5.  Call CreateOwnDataProperty(result, "1",
                e.[[value]]).

        iv. Return CreateItrResultObject(result, FALSE).

10. Return CreateItrResultObject(UNDEFINED, TRUE).

 MapIterator.prototype [ @@iterator ] ( )

The following steps are taken:

1.  Return the THIS value.

MapIterator.prototype [ @@toStringTag ]

The initial value of the @@toStringTag property is the string value "MAP
ITERATOR".

Properties of Map Iterator Instances

Map Iterator instances are ordinary objects that inherit properties from
the Map Iterator prototype (the intrinsic, %MapIteratorPrototype%). Map
Iterator instances are initially created with the internal properties
described in Table 37.

Table 37 — Internal Data Properties of Map Iterator Instances

  ----------------------------- ------------------------------------------------------------------------------------------------------------------------------------------------
  INTERNAL DATA PROPERTY NAME   DESCRIPTION
  [[Map]]                       The Map object that is being iterated.
  [[MapNextIndex]]              The integer index of the next Map data element to be examined by this iteration.
  [[MapIterationKind]]          A string value that identifies what is to be returned for each element of the iteration. The possible values are: "KEY", "VALUE", "KEY+VALUE".
  ----------------------------- ------------------------------------------------------------------------------------------------------------------------------------------------


WeakMap Objects

WeakMap objects are collections of key/value pairs where the keys are
ECMAScript objects and values may be arbitrary ECMAScript language
values. A WeakMap may be queried to see if it contains an key/value pair
with a specific key, but no mechanisms is provided for enumerating the
objects it holds as keys. If an object that is being used as the key of
a WeakMap key/value pair is only reachable by following a chain of
references that start within that WeakMap, then that key/value pair is
inaccessible and is automatically removed from the WeakMap. WeakMap
implementations must detect and remove such key/value pairs and any
associated resources.

An implementation may impose an arbitrarily determined latency between
the time a key/value pair of a WeakMap becomes inaccessible and the time
when the key/value pair is removed from the WeakMap. If this latency was
observable to ECMAScript program, it would be a source of indeterminacy
that could impact program execution.  For that reason, an ECMAScript
implementation must not provide any means to observe a key of a WeakMap
that does not require the observer to present the observed key. 

WeakMap objects must be implemented using either hash tables or other
mechanisms that, on average, provide access times that are sublinear on
the number of key/value pairs in the collection. The data structure used
in this WeakMap objects specification are only intended to describe the
required observable semantics of WeakMap objects. It is not intended to
be a viable implementation model.

NOTE WeakMap and WeakSets are intended to provide mechanisms for
dynamically associating state with an object in a manner that does not
“leak” memory resources if, in the absence of the WeakMap or WeakSet,
the object otherwise became inaccessible and subject to resource
reclamation by the implementation’s garbage collection mechanisms.
Achieving this characteristic requires coordination between the WeakMap
or WeakSet implementation and the garbage collector. The following
references describe mechanism that may be useful to implementations of
WeakMap and WeakSets:

  Barry Hayes. 1997. Ephemerons: a new finalization mechanism. In
  _Proceedings of the 12th ACM SIGPLAN conference on Object-oriented
  programming, systems, languages, and applications (OOPSLA '97)_, A.
  Michael Berman (Ed.). ACM, New York, NY, USA, 176-183.
  http://doi.acm.org/10.1145/263698.263733

  Alexandra Barros, Roberto Ierusalimschy, Eliminating Cycles in Weak
  Tables. Journal of Universal Computer Science - J.UCS , vol. 14, no.
  21, pp. 3481-3497, 2008.
  http://www.jucs.org/jucs_14_21/eliminating_cycles_in_weak

1.  2.  3.  4.  a.  b.  c.  d.  e.  f.  g.  h.  

5.  6.  7.  8.  a.  b.  c.  d.  e.  f.  g.  h.  i.  j.  

The WeakMap Constructor 

The WeakMap constructor is the %WeakMap% intrinsic object and the
initial value of the WEAKMAP property of the global object. When WEAKMAP
is called as a function rather than as a constructor, it initialises its
THIS value with the internal state necessary to support the
WEAKMAP.PROTOTYPE methods.

The WEAKMAP constructor is designed to be subclassable. It may be used
as the value in an EXTENDS clause of a class definition. Subclass
constructors that intend to inherit the specified WEAKMAP behaviour must
include a SUPER call to WEAKMAP.

WeakMap (iterable = undefined )

When the WEAKMAP function is called with optional argument iterable
the following steps are taken:

1.  Let map be the THIS value.

2.  a.  

3.  4.  If Type(map) is not Object then, throw a TYPEERROR exception.

5.  If map does not have a [[WeakMapData]] internal data property,
    then throw a TYPEERROR exception.

6.  If map’s [[WeakMapData]] internal data property is not UNDEFINED,
    then throw a TYPEERROR exception.

7.  If iterable is not present, let iterable be UNDEFINED.

8.  If iterable is either UNDEFINED or NULL, then let iter be
    UNDEFINED.

9.  Else,

    a.  b.  c.  i.  

    d.  e.  Let iter be the result of GetIterator(iterable).

10. a.  b.  ReturnIfAbrupt(iter).

    c.  Let adder be the result of Get(map, "SET").

    d.  ReturnIfAbrupt(adder).

    e.  If IsCallable(adder) is FALSE, throw a TYPEERROR Exception.

11. Set map’s [[WeakMapData]] internal data property to a new empty
    List.

12. If iter is UNDEFINED, then return map.

13. Repeat

    a.  Let next be the result of IteratorNext(iter).

    b.  c.  d.  ReturnIfAbrupt(next).

    e.  f.  Let done be IteratorComplete(next).

    g.  ReturnIfAbrupt(done).

    h.  If done is TRUE, then return NormalCompletion(map).

    i.  Let nextValue be IteratorValue(next).

    j.  ReturnIfAbrupt(nextValue).

    k.  If Type(nextValue) is not Object, then throw a TYPEERROR
        execution.

    l.  Let k be the result of Get(nextValue, "0").

    m.  ReturnIfAbrupt(k).

    n.  Let v be the result of Get(nextValue, "1").

    o.  ReturnIfAbrupt(v).

    p.  Let status be the result of calling the [[Call]] internal
        method of adder with map as thisArgument and a List whose
        elements are k and v as argumentsList.

14. a.  ReturnIfAbrupt(status).

15. 

NOTE If the parameter iterable is present, it is expected to be an
object that implements an @@iterator method that returns an iterator
object that produces two element array-like objects whose first element
is a value that will be used as a WeakMap key and whose second element
is the value to associate with that key.

new WeakMap ( ... argumentsList )

When WEAKMAP is called as part of a NEW expression it is a constructor:
it initialises a newly created object.

WEAKMAP called as part of a new expression with argument list
argumentsList performs the following steps:

1.  Let F be the WeakMap function object on which the NEW operator was
    applied.

2.  Let argumentsList be the argumentsList argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of OrdinaryConstruct(F, argumentsList).

If WeakMap is implemented as an ordinary function object, its
[[Construct]] internal method will perform the above steps.

1.  2.  3.  4.  5.  

Properties of the WeakMap Constructor

The value of the [[Prototype]] internal data property of the WeakMap
constructor is the Function prototype object (15.3.3).

Besides the LENGTH property (whose value is 0), the WeakMap constructor
has the following property:

WeakMap.prototype

The initial value of WEAKMAP.PROTOTYPE is the WeakMap prototype object
(15.15.4).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

WeakMap[ @@create ] ( )

The @@create method of a WeakMap object F performs the following
steps:

1.  Let F be the THIS value.

2.  Let obj be the result of calling
    OrdinaryCreateFromConstructor(F, "%WEAKMAPPROTOTYPE%", (
    [[WeakMapData]] )).

3.  4.  5.  Return obj.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Properties of the WeakMap Prototype Object

The value of the [[Prototype]] internal data property of the WeakMap
prototype object is the standard built-in Object prototype object
(15.2.4). The WeakMap prototype object is an ordinary object. It does
not have a [[WeakMapData]] internal data property.

WeakMap.prototype.constructor

The initial value of WEAKMAP.PROTOTYPE.CONSTRUCTOR is the built-in
WEAKMAP constructor.

WeakMap.prototype.clear ()

The following steps are taken:

1.  Let M be the THIS value.

2.  If Type(M) is not Object, then throw a TYPEERROR exception.

3.  If M does not have a [[WeakMapData]] internal data property throw
    a TYPEERROR exception.

4.  If M’s [[WeakMapData]] internal data property is UNDEFINED, then
    throw a TYPEERROR exception.

5.  Set the value of M’s [[WeakMapData]] internal data property to a
    new empty List.

6.  Return UNDEFINED.

WeakMap.prototype.delete ( key )

The following steps are taken:

1.  Let M be the THIS value.

2.  If Type(M) is not Object, then throw a TYPEERROR exception.

3.  If M does not have a [[WeakMapData]] internal data property throw
    a TYPEERROR exception.

4.  Let entries be the List that is the value of M’s [[WeakMapData]]
    internal data property.

5.  If entries is UNDEFINED, then throw a TYPEERROR exception.

6.  If Type(key) is not Object, then throw a TYPEERROR exception.

7.  8.  9.  Repeat for each Record {[[key]], [[value]]} p that is an
    element of entries,

    a.  If p.[[key]] and key are the same object, then

        i.  Set p.[[key]] to empty.

        ii. Set p.[[value]] to empty.

        iii. Return TRUE.

10. Return FALSE.

NOTE The value EMPTY is used as a specification device to indicate that
an entry has been deleted. Actual implementations may take other actions
such as physically removing the entry from internal data structures.

WeakMap.prototype.get ( key )

The following steps are taken:

1.  Let M be the THIS value.

2.  If Type(M) is not Object, then throw a TYPEERROR exception.

3.  If M does not have a [[WeakMapData]] internal data property throw
    a TYPEERROR exception.

4.  Let entries be the List that is the value of M’s [[WeakMapData]]
    internal data property.

5.  If entries is UNDEFINED, then throw a TYPEERROR exception.

6.  If Type(key) is not Object, then throw a TYPEERROR exception.

7.  8.  9.  Repeat for each Record {[[key]], [[value]]} p that is an
    element of entries,

    a.  If p.[[key]] and key are the same object, then return
        p.[[value]]

10. Return UNDEFINED.

WeakMap.prototype.has ( key )

The following steps are taken:

1.  Let M be the THIS value.

2.  If Type(M) is not Object, then throw a TYPEERROR exception.

3.  If M does not have a [[WeakMapData]] internal data property throw
    a TYPEERROR exception.

4.  Let entries be the List that is the value of M’s [[WeakMapData]]
    internal data property.

5.  If entries is UNDEFINED, then throw a TYPEERROR exception.

6.  If Type(key) is not Object, then throw a TYPEERROR exception.

7.  8.  9.  Repeat for each Record {[[key]], [[value]]} p that is an
    element of entries,

    a.  If p.[[key]] and key are the same object, then return
        TRUE.

10. Return FALSE.

WeakMap.prototype.set ( key , value )

The following steps are taken:

1.  Let M be the THIS value.

2.  If Type(M) is not Object, then throw a TYPEERROR exception.

3.  If M does not have a [[WeakMapData]] internal data property throw
    a TYPEERROR exception.

4.  Let entries be the List that is the value of M’s [[WeakMapData]]
    internal data property.

5.  If entries is UNDEFINED, then throw a TYPEERROR exception.

6.  If Type(key) is not Object, then throw a TYPEERROR exception.

7.  8.  9.  Repeat for each Record {[[key]], [[value]]} p that is an
    element of entries,

    a.  If p.[[key]] and key are the same object, then

        i.  Set p.[[value]] to value.

        ii. Return M.

10. Let p be the Record {[[key]]: key, [[value]]: value}

11. Append p as the last element of entries.

12. Return M.

WeakMap.prototype [ @@toStringTag ]

The initial value of the @@toStringTag property is the string value
"WEAKMAP".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Properties of WeakMap Instances

WeakMap instances are ordinary objects that inherit properties from the
WeakMap prototype. WeakMap instances also have a [[WeakMapData]]
internal data property.


Set Objects

Set objects are collections of ECMAScript language values. A distinct
value may only occur once as an element of a Set’s collection. Distinct
values are discriminated using a comparision algorithm that is selected
when the Set is created.

A Set object can iterate its elements in insertion order. Set objects
must be implemented using either hash tables or other mechanisms that,
on average, provide access times that are sublinear on the number of
elements in the collection. The data structures used in this Set objects
specification is only intended to describe the required observable
semantics of Set objects. It is not intended to be a viable
implementation model.

1.  2.  3.  4.  a.  b.  c.  

    d.  e.  i.  

    f.  i.  ii. 

    g.  h.  i.  j.  

5.  6.  7.  8.  a.  b.  c.  d.  e.  f.  g.  

The Set Constructor 

The Set constructor is the %Set% intrinsic object and the initial value
of the SET property of the global object. When SET is called as a
function rather than as a constructor, it initialises its THIS value
with the internal state necessary to support the SET.PROTOTYPE internal
methods.

The SET constructor is designed to be subclassable. It may be used as
the value in an EXTENDS clause of a class definition. Subclass
constructors that intend to inherit the specified SET behaviour must
include a SUPER call to SET.

Set (iterable = undefined, comparator = undefined )

When the SET function is called with optional arguments iterable and
comparator the following steps are taken:

1.  Let set be the THIS value.

2.  a.  

3.  4.  5.  6.  If Type(set) is not Object then, throw a TYPEERROR
    exception.

7.  If set does not have a [[SetData]] internal data property, then
    throw a TYPEERROR exception.

8.  If set’s [[SetData]] internal data property is not UNDEFINED, then
    throw a TYPEERROR exception.

9.  If iterable is not present, let iterable be UNDEFINED.

10. If iterable is either UNDEFINED or NULL, then let iter be
    UNDEFINED.

11. Else,

    a.  b.  Let iter be the result of GetIterator(iterable).

    c.  ReturnIfAbrupt(iter).

    d.  Let adder be the result of Get(set, "ADD").

    e.  ReturnIfAbrupt(adder).

    f.  If IsCallable(adder) is FALSE, throw a TYPEERROR Exception.

12. If comparator is not present, let comparator be UNDEFINED.

13. If comparator is not UNDEFINED, then

    a.  If comparator is not "IS", then throw a RANGEERROR Exception.

14. Set set’s [[SetData]] internal data property to a new empty List.

15. Set set’s [[SetComparator]] internal data property to
    comparator.

16. If iter is UNDEFINED, then return set.

17. Repeat

    a.  Let next be the result of IteratorNext(iter).

    b.  ReturnIfAbrupt(next).

    c.  d.  Let done be IteratorComplete(next).

    e.  ReturnIfAbrupt(done).

    f.  If done is TRUE, then return set.

    g.  h.  Let nextValue be IteratorValue(next).

    i.  ReturnIfAbrupt(nextValue).

    j.  Let status be the result of calling the [[Call]] internal
        method of adder with set as thisArgument and a List whose
        sole element is nextValue as argumentsList.

18. a.  ReturnIfAbrupt(status).

19. 

new Set ( ... argumentsList )

When SET is called as part of a NEW expression it is a constructor: it
initialises a newly created object.

SET called as part of a new expression with argument list
argumentsList performs the following steps:

1.  2.  3.  4.  5.  

1.  Let F be the Set function object on which the NEW operator was
    applied.

2.  Let argumentsList be the argumentsList argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of OrdinaryConstruct(F, argumentsList).

If Set is implemented as an ordinary function object, its [[Construct]]
internal method will perform the above steps.

Properties of the Set Constructor

The value of the [[Prototype]] internal data property of the Set
constructor is the Function prototype object (15.3.3).

Besides the LENGTH property (whose value is 0), the Set constructor has
the following property:

Set.prototype

The initial value of SET.PROTOTYPE is the intrinsic %SetPrototype%
object (15.16.4).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Set[ @@create ] ( )

The @@create method of a Set function object F performs the following
steps:

1.  Let F be the THIS value.

2.  Let obj be the result of calling
    OrdinaryCreateFromConstructor(F, "%SETPROTOTYPE%", ( [[SetData]] ,
    [[SetComparator]] )).

3.  4.  5.  Return obj.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Properties of the Set Prototype Object

The value of the [[Prototype]] internal data property of the Set
prototype object is the standard built-in Object prototype object
(15.2.4). The Set prototype object is an ordinary object. It does not
have a [[SetData]] or a [[SetComparator]] internal data property.

Set.prototype.constructor

The initial value of SET.PROTOTYPE.CONSTRUCTOR is the built-in SET
constructor.

Set.prototype.add (value )

The following steps are taken:

1.  Let S be the THIS value.

2.  If Type(S) is not Object, then throw a TYPEERROR exception.

3.  If S does not have a [[SetData]] internal data property throw a
    TYPEERROR exception.

4.  If S’s [[SetData]] internal data property is UNDEFINED, then throw
    a TYPEERROR exception.

5.  Let entries be the List that is the value of S’s [[SetData]]
    internal data property.

6.  If S’s [[SetComparator]] internal data property is UNDEFINED, then
    let same be the abstract operation SameValueZero.

7.  Else, let same be the abstract operation SameValue.

8.  Repeat for each e that is an element of entries, in original
    insertion order

9.  a.  If e is not empty and same_(_e, value) is TRUE, then

        i.  Return S.

10. Append value as the last element of entries.

11. Return S.

Set.prototype.clear ()

The following steps are taken:

1.  Let S be THIS value.

2.  If Type(S) is not Object, then throw a TYPEERROR exception.

3.  If S does not have a [[SetData]] internal data property throw a
    TYPEERROR exception.

4.  If S’s [[SetData]] internal data property is UNDEFINED, then throw
    a TYPEERROR exception.

5.  Let entries be the List that is the value of S’s [[SetData]]
    internal data property.

6.  Repeat for each e that is an element of entries,

    a.  Replace the element of entries whose value is e with an
        element whose value is empty.

7.  8.  Return UNDEFINED.

Set.prototype.delete ( value )

The following steps are taken:

1.  Let S be the THIS value.

2.  If Type(S) is not Object, then throw a TYPEERROR exception.

3.  If S does not have a [[SetData]] internal data property throw a
    TYPEERROR exception.

4.  If S’s [[SetData]] internal data property is UNDEFINED, then throw
    a TYPEERROR exception.

5.  Let entries be the List that is the value of S’s [[SetData]]
    internal data property.

6.  If S’s [[SetComparator]] internal data property is UNDEFINED, then
    let same be the abstract operation SameValueZero.

7.  Else, let same be the abstract operation SameValue.

8.  Repeat for each e that is an element of entries, in original
    insertion order

    a.  If e is not empty and same_(_e, value) is TRUE, then

        i.  Replace the element of entries whose value is e with an
            element whose value is empty.

        ii. Return TRUE.

9.  Return FALSE.

NOTE The value EMPTY is used as a specification device to indicate that
an entry has been deleted. Actual implementations may take other actions
such as physically removing the entry from internal data structures.

Set.prototype.entries ( )

The following steps are taken:

1.  Let S be the THIS value.

2.  If Type(S) is not Object, then throw a TYPEERROR exception.

3.  Return the result of calling the CreateSetIterator abstract
    operation with arguments S and "KEY+VALUE".

NOTE For iteration purposes, a Set appears similar to a Map where each
entry has the same value for its key and value.

Set.prototype.forEach ( callbackfn , thisArg = undefined )

callbackfn should be a function that accepts three arguments. FOREACH
calls callbackfn once for each value present in the set object, in
value insertion order. callbackfn is called only for values of the Set
which actually exist; it is not called for keys that have been deleted
from the set.

If a thisArg parameter is provided, it will be used as the THIS value
for each invocation of callbackfn. If it is not provided, UNDEFINED is
used instead.

NOTE 1 If callbackfn is an Arrow Function, THIS was lexically bound
when the function was created so thisArg will have no effect.

callbackfn is called with three arguments: the first two arguments are
a value contained in the Set. The same value of passed for both
arguments. The Set object being traversed is passed as the third
argument.

NOTE 2 The callbackfn is called with three arguments to be consistent
with the call back functions used by FOREACH methods for Map and Array.
For Sets, each item value is considered to be both the key and the
value.

FOREACH does not directly mutate the object on which it is called but
the object may be mutated by the calls to callbackfn.

NOTE 3 Each value is normally visited only once. However, a value will
be revisited if it is deleted after it has been visited and then
re-added before the to FOREACH call completes. Values that are deleted
after the call to FOREACH begins and before being visited are not
visited unless the value is added again before the to FOREACH call
completes. New values added, after the call to FOREACH begins are
visited.

When the FOREACH method is called with one or two arguments, the
following steps are taken:

1.  Let S be the THIS value.

2.  If Type(S) is not Object, then throw a TYPEERROR exception.

3.  If S does not have a [[SetData]] internal data property throw a
    TYPEERROR exception.

4.  If S’s [[SetData]] internal data property is UNDEFINED, then throw
    a TYPEERROR exception.

5.  If IsCallable(callbackfn) is FALSE, throw a TYPEERROR exception.

6.  If thisArg was supplied, let T be thisArg; else let T be
    UNDEFINED.

7.  Let entries be the List that is the value of S’s [[SetData]]
    internal data property.

8.  Repeat for each e that is an element of entries, in original
    insertion order

    a.  If e is not empty, then

        i.  Let funcResult be the result of calling the [[Call]]
            internal method of callbackfn with T as thisArgument
            and a List containing e, e, and S as argumentsList.

        ii. ReturnIfAbrupt(funcResult).

9.  Return UNDEFINED.

The LENGTH property of the FOREACH method is 1.

Set.prototype.has ( value )

The following steps are taken:

1.  Let S be the THIS value.

2.  If Type(S) is not Object, then throw a TYPEERROR exception.

3.  If S does not have a [[SetData]] internal data property throw a
    TYPEERROR exception.

4.  If S’s [[SetData]] internal data property is UNDEFINED, then throw
    a TYPEERROR exception.

5.  Let entries be the List that is the value of S’s [[SetData]]
    internal data property.

6.  If S’s [[SetComparator]] internal data property is UNDEFINED, then
    let same be the abstract operation SameValueZero.

7.  Else, let same be the abstract operation SameValue.

8.  Repeat for each e that is an element of entries,

    a.  If e is not empty and same_(_e, value), then return
        TRUE.

9.  Return FALSE.

Set.prototype.keys ( )

The initial value of the KEYS property is the same function object as
the initial value of the VALUES property.

NOTE For iteration purposes, a Set appears similar to a Map where each
entry has the same value for its key and value.

get Set.prototype.size 

SET.PROTOTYPE.SIZE is an accessor property whose set accessor function
is UNDEFINED. Its get accessor function performs the following steps:

1.  Let S be the THIS value.

2.  If Type(S) is not Object, then throw a TYPEERROR exception.

3.  If S does not have a [[SetData]] internal data property throw a
    TYPEERROR exception.

4.  If S’s [[SetData]] internal data property is UNDEFINED, then throw
    a TYPEERROR exception.

5.  Let entries be the List that is the value of S’s [[SetData]]
    internal data property.

6.  Let count be 0.

7.  For each e that is an element of entries

    a.  If e is not empty then

        i.  Set count to count+1.

8.  Return count.

Set.prototype.values ( )

The following steps are taken:

1.  Let S be the THIS value.

2.  If Type(S) is not Object, then throw a TYPEERROR exception.

3.  Return the result of calling the CreateSetIterator abstract
    operation with argument S and "VALUE".

Set.prototype [@@iterator ] ( )

The initial value of the @@iterator property is the same function object
as the initial value of the VALUES property.

Set.prototype [ @@toStringTag ]

The initial value of the @@toStringTag property is the string value
"SET".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Properties of Set Instances

Set instances are ordinary objects that inherit properties from the Set
prototype. After initialisation by the Set constructor, Set instances
also have a [[SetData]] internal data property and a [[SetComparator]]
internal data property.

Set Iterator Object Structure

A Set Iterator is an ordinary object, with the structure defined below,
that represents a specific iteration over some specific Set instance
object. There is not a named constructor for Set Iterator objects.
Instead, set iterator objects are created by calling certain methods of
Set instance objects.

CreateSetIterator Abstract Operation

Several methods of Set objects return Iterator objects. The abstract
operation CreateSetIterator with arguments set and kind is used to
create such iterator objects. It performs the following steps:

1.  Let S be the result of calling ToObject(set).

2.  ReturnIfAbrupt(S).

3.  If S does not have a [[SetData]] internal data property throw a
    TYPEERROR exception.

4.  If S’s [[SetData]] internal data property is UNDEFINED, then throw
    a TYPEERROR exception.

5.  Let entries be the List that is the value of S’s [[SetData]]
    internal data property.

6.  Let iterator be the result of ObjectCreate(%SetIteratorPrototype%,
    ([[IteratedSet]], [[SetNextIndex]], [[SetIterationKind]])).

7.  Set iterator’s [[IteratedSet]] internal data property to S.

8.  Set iterator’s [[SetNextIndex]] internal data property to 0.

9.  Set iterator’s [[SetIterationKind]] internal data property to
    kind.

10. Return iterator.

The Set Iterator Prototype

All Set Iterator Objects inherit properties from a common Set Iterator
Prototype object. The [[Prototype]] internal data property of the Set
Iterator Prototype is the %ObjectPrototype% intrinsic object. In
addition, the Set Iterator Prototype has the following properties:

SetIterator.prototype.constructor

SetIterator.prototype.next( )

1.  Let O be the THIS value.

2.  If Type(O) is not Object, throw a TYPEERROR exception.

3.  If O does not have all of the internal properties of a Set
    Iterator Instance (15.16.7.1.2), throw a TYPEERROR exception.

4.  Let s be the value of the [[IteratedSet]] internal data property
    of O.

5.  Let index be the value of the [[SetNextIndex]] internal data
    property of O.

6.  Let itemKind be the value of the [[SetIterationKind]] internal
    data property of O.

7.  Assert: s has a [[SetData]] internal data property and s has
    been initialised so the value of [[SetData]] is not UNDEFINED.

8.  Let entries be the List that is the value of the [[SetData]]
    internal data property of s.

9.  Repeat while index is less than the total number of elements of
    entries. The number of elements must be redetermined each time
    this method is evaluated.

    a.  Let e be the element at 0-origined insertion position index
        of entries.

    b.  Set index to index+1;

    c.  Set the [[SetNextIndex]] internal data property of O to
        index.

    d.  If e is not empty, then

        i.  If itemKind is "KEY+VALUE" then,

            1.  Let result be the result of the abstract operation
                ArrayCreate with argument 2.

            2.  Assert: result is a new, well-formed Array object so
                the following operations will never fail.

            3.  Call CreateOwnDataProperty(result, "0", e) .

            4.  Call CreateOwnDataProperty(result, "1", e).

            5.  Return CreateItrResultObject(result, FALSE).

        ii. Return CreateItrResultObject(e, FALSE).

10. Return CreateItrResultObject(UNDEFINED, TRUE).

SetIterator.prototype.@@iterator ( )

The following steps are taken:

1.  Return the THIS value.

 SetIterator.prototype.@@toStringTag

The initial value of the @@toStringTag property is the string value "SET
ITERATOR".

Properties of Set Iterator Instances

Set Iterator instances inherit properties from the Set Iterator
prototype (the intrinsic, %SetIteratorPrototype%). Set Iterator
instances are initially created with the internal properties specified
in Table 38.

Table 38 — Internal Data Properties of Set Iterator Instances

  ----------------------------- -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  INTERNAL DATA PROPERTY NAME   DESCRIPTION
  [[IteratedSet]]               The Set object that is being iterated.
  [[SetNextIndex]]              The integer index of the next Set data element to be examined by this iteration.
  [[SetIterationKind]]          A string value that identifies what is to be returned for each element of the iteration. The possible values are: "KEY", "VALUE", "KEY+VALUE". "KEY" and "VALUE" have the same meaning.
  ----------------------------- -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


WeakSet Objects

WeakSet objects are collections of ECMAScript objects. A distinct object
may only occur once as an element of a WeakSet’s collection. A WeakSet
may be queried to see if it contains a specific object, but no
mechanisms is provided for enumerating the objects it holds. If an
object that is contain by a WeakSet is only reachable by following a
chain of references that start within that WeakSet, then that object is
inaccessible and is automatically removed from the WeakSet. WeakSet
implementations must detect and remove such objects and any associated
resources.

An implementation may impose an arbitrarily determined latency between
the time an object contained in a WeakSet becomes inaccessible and the
time when the object is removed from the WeakSet. If this latency was
observable to ECMAScript program, it would be a source of indeterminacy
that could impact program execution.  For that reason, an ECMAScript
implementation must not provide any means to determine if a WeakSet
contains a particular object that does not require the observer to
present the observed object.

WeakSet objects must be implemented using either hash tables or other
mechanisms that, on average, provide access times that are sublinear on
the number of elements in the collection. The data structure used in
this WeakSet objects specification is only intended to describe the
required observable semantics of WeakSet objects. It is not intended to
be a viable implementation model.

NOTE See the NOTE in 15.15.

The WeakSet Constructor 

The WeakSet constructor is the %WeakSet% intrinsic object and the
initial value of the WEAKSET property of the global object. When WEAKSET
is called as a function rather than as a constructor, it initialises its
THIS value with the internal state necessary to support the
WEAKSET.PROTOTYPE internal methods.

The WEAKSET constructor is designed to be subclassable. It may be used
as the value in an EXTENDS clause of a class definition. Subclass
constructors that intend to inherit the specified WEAKSET behaviour must
include a SUPER call to WEAKSET.

WeakSet (iterable = undefined)

When the WEAKSET function is called with optional argument iterable
the following steps are taken:

1.  Let set be the THIS value.

2.  If Type(set) is not Object then, throw a TYPEERROR exception.

3.  If set does not have a [[WeakSetData]] internal data property,
    then throw a TYPEERROR exception.

4.  If set’s [[WeakSetData]] internal data property is not UNDEFINED,
    then throw a TYPEERROR exception.

5.  If iterable is not present, let iterable be UNDEFINED.

6.  If iterable is either UNDEFINED or NULL, then let iter be
    UNDEFINED.

7.  Else,

    a.  Let iter be the result of GetIterator(iterable).

    b.  ReturnIfAbrupt(iter).

    c.  Let adder be the result of Get(set, "ADD").

    d.  ReturnIfAbrupt(adder).

    e.  If IsCallable(adder) is FALSE, throw a TYPEERROR Exception.

8.  Set set’s [[WeakSetData]] internal data property to a new empty
    List.

9.  If iter is UNDEFINED, then return set.

10. Repeat

    a.  Let next be the result of IteratorNext(iter).

    b.  ReturnIfAbrupt(next).

    c.  Let done be IteratorComplete(next).

    d.  ReturnIfAbrupt(done).

    e.  If done is TRUE, then return NormalCompletion(set).

    f.  Let nextValue be IteratorValue(next).

    g.  ReturnIfAbrupt(nextValue).

    h.  Let status be the result of calling the [[Call]] internal
        method of adder with set as thisArgument and a List whose
        sole element is nextValue as argumentsList.

    i.  ReturnIfAbrupt(status).

new WeakSet ( ... argumentsList)

When WEAKSET is called as part of a NEW expression it is a constructor:
it initialises a newly created object.

WEAKSET called as part of a new expression with argument list
argumentsList performs the following steps:

1.  Let F be the WEAKSET function object on which the NEW operator was
    applied.

2.  Let argumentsList be the argumentsList argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of OrdinaryConstruct(F, argumentsList).

If WeakSet is implemented as an ordinary function object, its
[[Construct]] internal method will perform the above steps.

Properties of the WeakSet Constructor

The value of the [[Prototype]] internal data property of the WeakSet
constructor is the Function prototype object (15.3.3).

Besides the LENGTH property (whose value is 0), the WeakSet constructor
has the following property:

WeakSet.prototype

The initial value of WEAKSET.PROTOTYPE is the intrinsic
%WeakSetPrototype% object (15.17.4).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

WeakSet [ @@create ] ( )

The @@create method of a WeakSet function object F performs the
following steps:

1.  Let F be the THIS value.

2.  Let obj be the result of calling
    OrdinaryCreateFromConstructor(F, "%WEAKSETPROTOTYPE%", (
    [[WeakSetData]] )).

3.  Return obj.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Properties of the WeakSet Prototype Object

The value of the [[Prototype]] internal data property of the WeakSet
prototype object is the standard built-in Object prototype object
(15.2.4). The WeakSet prototype object is an ordinary object. It does
not have a [[WeakSetData]] internal data property.

WeakSet.prototype.constructor

The initial value of WEAKSET.PROTOTYPE.CONSTRUCTOR is the %WeakSet%
intrinsic object.

WeakSet.prototype.add (value )

The following steps are taken:

1.  Let S be the THIS value.

2.  If Type(S) is not Object, then throw a TYPEERROR exception.

3.  If S does not have a [[WeakSetData]] internal data property throw
    a TYPEERROR exception.

4.  If S’s [[WeakSetData]] internal data property is UNDEFINED, then
    throw a TYPEERROR exception.

5.  If Type(value) is not Object, then throw a TYPEERROR exception.

6.  Let entries be the List that is the value of S’s [[WeakSetData]]
    internal data property.

7.  Repeat for each e that is an element of entries, in original
    insertion order

    a.  If e is not empty and SameValue(e, value) is TRUE, then

        i.  Return S.

8.  Append value as the last element of entries.

9.  Return S.

WeakSet.prototype.clear ()

The following steps are taken:

1.  Let S be THIS value.

2.  If Type(S) is not Object, then throw a TYPEERROR exception.

3.  If S does not have a [[WeakSetData]] internal data property throw
    a TYPEERROR exception.

4.  If S’s [[WeakSetData]] internal data property is UNDEFINED, then
    throw a TYPEERROR exception.

5.  Let entries be the List that is the value of S’s [[WeakSetData]]
    internal data property.

6.  Repeat for each e that is an element of entries,

    a.  Replace the element of entries whose value is e with an
        element whose value is empty.

7.  Return UNDEFINED.

WeakSet.prototype.delete ( value )

The following steps are taken:

1.  Let S be the THIS value.

2.  If Type(S) is not Object, then throw a TYPEERROR exception.

3.  If S does not have a [[WeakSetData]] internal data property throw
    a TYPEERROR exception.

4.  If S’s [[

5.  WeakSetData]] internal data property is UNDEFINED, then throw a
    TYPEERROR exception.

6.  If Type(value) is not Object, then throw a TYPEERROR exception.

7.  Let entries be the List that is the value of S’s [[WeakSetData]]
    internal data property.

8.  Repeat for each e that is an element of entries, in original
    insertion order

    a.  If e is not empty and SameValue(e, value) is TRUE, then

        i.  Replace the element of entries whose value is e with an
            element whose value is empty.

        ii. Return TRUE.

9.  Return FALSE.

NOTE The value EMPTY is used as a specification device to indicate that
an entry has been deleted. Actual implementations may take other actions
such as physically removing the entry from internal data structures.

WeakSet.prototype.has ( value )

The following steps are taken:

1.  Let S be the THIS value.

2.  If Type(S) is not Object, then throw a TYPEERROR exception.

3.  If S does not have a [[WeakSetData]] internal data property throw
    a TYPEERROR exception.

4.  If S’s [[WeakSetData]] internal data property is UNDEFINED, then
    throw a TYPEERROR exception.

5.  Let entries be the List that is the value of S’s [[WeakSetData]]
    internal data property.

6.  Repeat for each e that is an element of entries,

    a.  If e is not empty and SameValue(e, value), then return
        TRUE.

7.  Return FALSE.

WeakSet.prototype [ @@toStringTag ]

The initial value of the @@toStringTag property is the string value
"WEAKSET".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Properties of WeakSet Instances

WeakSet instances are ordinary objects that inherit properties from the
WeakSet prototype. After initialisation by the WeakSet constructor,
WeakSet instances also have a [[WeakSetData]] internal data property.


The Reflect Module

This is a place holder for the material in
http://wiki.ecmascript.org/doku.php?id=harmony:reflect_api

Exported Function Properties Reflecting the Essentional Internal Methods 

Reflect.getPrototypeOf (target)

When the GETPROTOTYPEOF function is called with argument target the
following steps are taken:

1.  Let obj be ToObject(target).

2.  ReturnIfAbrupt(obj).

3.  Return the result of calling the [[GetInheritance]] internal method
    of obj.

Reflect.setPrototypeOf (target, proto)

When the SETPROTOTYPEOF function is called with arguments target and
propertyKey, the following steps are taken:

1.  Let obj be ToObject(target).

2.  ReturnIfAbrupt(obj).

3.  If Type(proto) is not Object and proto is not NULL, then throw a
    TYPEERROR exception

4.  Return the result of calling the [[SetInheritance]] internal method
    of obj with argument proto.

Reflect.isExtensible (target)

When the ISEXTENSIBLE function is called with argument target the
following steps are taken:

1.  Let obj be ToObject(target).

2.  ReturnIfAbrupt(obj).

3.  Return the result of calling the [[IsExtensible]] internal method of
    obj.

Reflect.preventExtensions (target)

When the PREVENTEXTENSIONS function is called with argument target,
the following steps are taken:

1.  Let obj be ToObject(target).

2.  ReturnIfAbrupt(obj).

3.  Return the result of calling the [[PreventExtensions]] internal
    method of obj.

Reflect.has (target, propertyKey)

When the HASOWN function is called with arguments target and
propertyKey, the following steps are taken:

1.  Let obj be ToObject(target).

2.  ReturnIfAbrupt(obj).

3.  Let key be ToPropertyKey(propertyKey).

4.  ReturnIfAbrupt(key).

5.  Return the result of calling the [[HasProperty]] internal method of
    obj with argument key.

Reflect.hasOwn (target, propertyKey)

When the HASOWN function is called with arguments target and
propertyKey, the following steps are taken:

1.  Let obj be ToObject(target).

2.  ReturnIfAbrupt(obj).

3.  Let key be ToPropertyKey(propertyKey).

4.  ReturnIfAbrupt(key).

5.  Return the result of calling the [[HasOwnProperty]] internal method
    of obj with argument key.

Reflect.getOwnPropertyDescriptor(target, propertyKey)

When the GETOWNPROPERTYDESCRIPTOR function is called with arguments
target and propertyKey, the following steps are taken:

1.  Let obj be ToObject(target).

2.  ReturnIfAbrupt(obj).

3.  Let key be ToPropertyKey(propertyKey).

4.  ReturnIfAbrupt(key).

5.  Let desc be the result of calling the [[GetOwnProperty]] internal
    method of obj with argument key.

6.  ReturnIfAbrupt(desc).

7.  Return the result of calling FromPropertyDescriptor(desc).

Reflect.get (target, propertyKey, receiver=target)

When the GET function is called with arguments target, propertyKey,
and receiver the following steps are taken:

1.  Let obj be ToObject(target).

2.  ReturnIfAbrupt(obj).

3.  Let key be ToPropertyKey(propertyKey).

4.  ReturnIfAbrupt(key).

5.  If receiver is not present, then

    a.  Let receiver be target.

6.  Return the result of calling the [[Get]] internal method of obj
    with arguments key, and receiver.

Reflect.set (target, propertyKey, V, receiver=target)

When the SET function is called with arguments target, V,
propertyKey, and receiver the following steps are taken:

1.  Let obj be ToObject(target).

2.  ReturnIfAbrupt(obj).

3.  Let key be ToPropertyKey(propertyKey).

4.  ReturnIfAbrupt(key).

5.  If receiver is not present, then

    a.  Let receiver be target.

6.  Return the result of calling the [[Set]] internal method of obj
    with arguments key, V, and receiver.

Reflect.invoke (target, propertyKey, argumentsList, receiver=target)

When the INVOKE function is called with arguments target,
propertyKey, argumentsList, and receiver the following steps are
taken:

1.  Let obj be ToObject(target).

2.  ReturnIfAbrupt(obj).

3.  Let key be ToPropertyKey(propertyKey).

4.  ReturnIfAbrupt(key).

5.  If receiver is not present, then

    a.  Let receiver be target.

6.  Let argList be the result of
    CreateListFromArrayLike(argumentsList).

7.  ReturnIfAbrupt(argList ).

8.  Return the result of calling the [[Invoke]] internal method of obj
    with arguments key, argList, and receiver.

Reflect.deleteProperty (target, propertyKey)

When the DELETEPROPERTY function is called with arguments target and
propertyKey, the following steps are taken:

1.  Let obj be ToObject(target).

2.  ReturnIfAbrupt(obj).

3.  Let key be ToPropertyKey(propertyKey).

4.  ReturnIfAbrupt(key).

5.  Return the result of calling the [[Delete]] internal method of obj
    with argument key.

Reflect.defineProperty(target, propertyKey, attributes)

When the DEFINEPROPERTY function is called with arguments target,
propertyKey, and attributes the following steps are taken:

1.  Let obj be ToObject(target).

2.  ReturnIfAbrupt(obj).

3.  Let key be ToPropertyKey(propertyKey).

4.  ReturnIfAbrupt(key).

5.  Let desc be the result of calling ToPropertyDescriptor with
    attributes as the argument.

6.  ReturnIfAbrupt(desc).

7.  Return the result of calling the [[DefineOwnProperty]] internal
    method of obj with arguments key, and desc.

Reflect.enumerate (target)

When the ENUMERATE function is called with argument target the
following steps are taken:

1.  Let obj be ToObject(target).

2.  ReturnIfAbrupt(obj).

3.  Let iterator be the result of calling the [[Enumerate]] internal
    method of obj.

4.  Return iterator.

1.  2.  3.  4.  5.  

Reflect.ownKeys (target)

When the OWNKEYS function is called with argument target the following
steps are taken:

1.  Let obj be ToObject(target).

2.  ReturnIfAbrupt(obj).

3.  4.  5.  Let keys be the result of calling the [[OwnPropertyKeys]]
    internal method of obj.

1.  2.  3.  

1.  2.  3.  

1.  2.  3.  

1.  2.  3.  

Proxy Objects


The "std:iteration" Module

The "STD:ITERATION" module defines built-in objects that support the
for-of statement and similar iteration use cases. It also defines the
built-in objects that support Generator Functions.

Common Iteration Interfaces

An interface is a set of object property keys whose associated values
match a specific specification. Any object that provides all the
properties of an interface in conformance to the interface’s
specification conforms to that interface. An interface isn’t
represented by a single object and there may be many distinctly
implemented objects that conform to any interface. An individual object
may conform to multiple interfaces.

The Iterable Iterface

The Iterable interface includes the following property:

  PROPERTY     VALUE                                               REQUIREMENTS
  ------------ --------------------------------------------------- ---------------------------------------------------------------------------
  @@ITERATOR   A zero arguments function that returns an object.   The function returns an object that conforms to the iterator interface.

The Iterator Iterface

The Iterator interface includes the following properties:

  PROPERTY   VALUE                                REQUIREMENTS
  ---------- ------------------------------------ ----------------------------------------------------------------------------
  NEXT       A function that returns an object.   The function returns an object that conforms to the ItrResult interface.

NOTE Arguments may be passed to the next function but their
interpretation and validity is dependent upon the target Iterator.
Generic use of Iterators should not pass any arguments.

The ItrResult Iterface

The ItrResult interface includes the following properties:

  PROPERTY   VALUE                           REQUIREMENTS
  ---------- ------------------------------- ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  DONE       Either TRUE or FALSE.           This is the result status of the an iterator NEXT method call. If the end of the iterator was reached DONE is TRUE. If the end was not reached DONE is FALSE and a value is available.
  VALUE      Any ECMAScript languge value.   If done is FALSE, this is the current iteration element value. If done is TRUE, this is the return value of the iterator, if it supplied one. If the iterator does not have a return value, VALUE is UNDEFINED. In that case, the VALUE property may be absent form the conforming object if it does not inherit an explicit VALUE property.

 "std:iteration" Exports 

The "STD:ITERATION" module exports the names:

-   iterator

-   GeneratorFunction

-   Generator

GeneratorFunction Objects

GENERATOR FUNCTION objects are constructor functions that are usually
created by evaluating GeneratorDeclaration, GeneratorExpression, and
GeneratorMethod syntactic productions. They may also be created by
calling the GENERATORFUNCTION constructor.

1.  2.  3.  4.  5.  

1.  

  --
  --

Figure 2 (Informative) -- Generator Objects Relationships

The GeneratorFunction Constructor

The GeneratorFunction constructor is the %GeneratorFunction% intrinsic
object and the value of the name GENERATORFUNCTION exported from the
built-in module "STD:ITERATION". When GENERATORFUNCTION is called as a
function rather than as a constructor, it creates and initialises a new
GeneratorFunction object. Thus the function call GENERATORFUNCTION (…)
is equivalent to the object creation expression NEW GENERATORFUNCTION
(…) with the same arguments. However, if the THIS value value passed in
the call is an Object with an [[Code]] internal data property whose
value is UNDEFINED, it initialises the THIS value using the argument
values. This permits GENERATORFUNCTION to be used both as factory method
and to perform constructor instance initialization.

GENERATORFUNCTION may be subclassed and subclass constructors may
perform a SUPER invocation of the GENERATORFUNCTION constructor to
initialise subclass instances. However, all syntactic forms for defining
generator function objects create direct instances of GENERATORFUNCTION.
There is no syntactic means to create instances of GENERATORFUNCTION
subclasses.

GeneratorFunction (p1, p2, … , pn, body)

The last argument specifies the body (executable code) of a generator
function; any preceding arguments specify formal parameters.

When the GENERATORFUNCTION function is called with some arguments p1,
p2, … , pn, body (where n might be 0, that is, there are no
“p” arguments, and where body might also not be provided), the
following steps are taken:

1.  Let argCount be the total number of arguments passed to this
    function invocation.

2.  Let P be the empty String.

3.  If argCount = 0, let bodyText be the empty String.

4.  Else if argCount = 1, let bodyText be that argument.

5.  Else argCount > 1,

    a.  Let firstArg be the first argument.

    b.  Let P be ToString(firstArg).

    c.  ReturnIfAbrupt(P).

    d.  Let k be 2.

    e.  Repeat, while k < argCount

        i.  Let nextArg be the k’th argument.

        ii. Let nextArgString be ToString(nextArg).

        iii. ReturnIfAbrupt(nextArgString).

        iv. Let P be the result of concatenating the previous value of
            P, the String "," (a comma), and nextArgString.

        v.  Increase k by 1.

    f.  Let bodyText be the k’th argument.

6.  Let bodyText be ToString(bodyText).

7.  ReturnIfAbrupt(bodyText).

8.  Let parameters be the result of parsing P, interpreted as UTF-16
    encoded Unicode text as described in 8.4, using FormalParameters
    as the goal symbol. Throw a SYNTAXERROR exception if the parse
    fails.

9.  Let funcBody be the result of parsing bodyText, interpreted as
    UTF-16 encoded Unicode text as described in 8.4, using
    FunctionBody as the goal symbol. Throw a SYNTAXERROR exception if
    the parse fails or if any static semantics errors are detected.

10. If funcBody Contains YieldExpression is FALSE, then throw a
    SYNTAXERROR exception.

11. If IsSimpleParameterList of parameters is FALSE and any element of
    the BoundNames of parameters also occurs in the VarDeclaredNames
    of funcBody, then throw a SYNTAXERROR exception.

12. If any element of the BoundNames of parameters also occurs in the
    LexicallyDeclaredNames of funcBody, then throw a SYNTAXERROR
    exception.

13. If bodyText is strict mode code (see 10.1.1) then let strict be
    TRUE, else let strict be FALSE.

14. Let scope be the Global Environment.

15. Let F be the THIS value.

16. If Type(F) is not Object or if F does not have a [[Code]]
    internal data property or if the value of [[Code]] is not UNDEFINED,
    then

    a.  Let F be the result of calling FunctionAllocate with arguments
        %GENERATOR% and "GENERATOR".

17. If the value of F’s [[FunctionKind]] internal data property is not
    "GENERATOR", then throw a TYPEERROR exception.

18. Using funcBody as the FunctionBody production, let body be the
    supplemental syntactic grammar production: GeneratorBody :
    FunctionBody.

19. Perform the FunctionInitialise abstract operation with arguments
    F, Normal, parameters, _body, scope_, and strict.

20. Let prototype be the result of the abstract operation ObjectCreate
    with the intrinsic object %GeneratorPrototype% as its argument.

21. Perform the abstract operation MakeConstructor with arguments F,
    TRUE, and prototype.

22. Return F.

A PROTOTYPE property is automatically created for every function created
using the GENERATORFUNCTION constructor, to provide for the possibility
that the function will be used as a constructor.

new GeneratorFunction ( ... argumentsList)

When GENERATORFUNCTION is called as part of a NEW expression, it creates
and initialises a newly created object.

1.  Let F be the GENERATORFUNCTION function object on which the NEW
    operator was applied.

2.  Let argumentsList be the argumentsList argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of OrdinaryConstruct (F, argumentsList).

If GENERATORFUNCTION is implemented as an ordinary function object, its
[[Construct]] internal method will perform the above steps.

Properties of the GeneratorFunction Constructor

The GeneratorFunction constructor is a built-in Function object that
inherits from the Function constructor. The value of the [[Prototype]]
internal data property of the GeneratorFunction constructor is the
intrinsic object %Function%.

The value of the [[Extensible]] internal data property of the
GeneratorFunction constructor is TRUE.

The GeneratorFunction constructor has the following properties:

GeneratorFunction.prototype

The initial value of GENERATORFUNCTION.PROTOTYPE is %Generator%, the
standard built-in GeneratorFunction prototype.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

 GeneratorFunction.length

This is a data property with a value of 1. This property has the
attributes { [[Writable]]: FALSE, [[Enumerable]]: FALSE,
[[Configurable]]: FALSE }.

 GeneratorFunction[ @@create ] ( )

The @@create method of an object F performs the following steps:

1.  Let F be the THIS value.

2.  Let proto be the result of GetPrototypeFromConstructor(F,
    "%GENERATOR%").

3.  ReturnIfAbrupt(proto).

4.  Let obj be the result of calling FunctionAllocate with argument
    proto and "GENERATOR".

5.  Return obj.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

NOTE The GeneratorFunction @@CREATE function is intentionally generic;
it does not require that its THIS value be the GeneratorFunction
constructor object. It can be transferred to other constructor functions
for use as a @@CREATE method. When used with other constructors, this
function will create a function object whose [[Prototype]] value is
obtained from the associated constructor.

Properties of the GeneratorFunction Prototype Object

The GeneratorFunction prototype object is an ordinary object. It is not
a function object and does not have a [[Code]] internal data property or
any other of the internal data properties listed in Table 13. In
addition to being the value of the prototype property of the
%GeneratorFunction% intrinsic and is itself the %Generator% intrinsic.

The value of the [[Prototype]] internal data property of the
GeneratorFunction prototype object is the %FunctionPrototype% intrinsic
object. The initial value of the [[Extensible]] internal data property
of the GeneratorFunction prototype object is TRUE.

GeneratorFunction.prototype.constructor

The initial value of GENERATORFUNCTION.PROTOTYPE.CONSTRUCTOR is the
intrinsic object %GeneratorFunction%.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

GeneratorFunction.prototype.prototype

The value of GENERATORFUNCTION.PROTOTYPE.PROTOTYPE is the
%GeneratorPrototype% intrinsic object.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

 GeneratorFunction.prototype [ @@toStringTag ]

The initial value of the @@toStringTag property is the string value
"GENERATORFUNCTION".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

 GeneratorFunction.prototype [ @@create ] ( )

The @@create method of an object F performs the following steps:

1.  Let F be the THIS value.

2.  Let obj be the result of calling
    OrdinaryCreateFromConstructor(F, "%GENERATORPROTOTYPE%", (
    [[GeneratorState]], [[GeneratorContext]]) ).

3.  Return obj.

This property has the attributes { [[Writable]]: TRUE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

GeneratorFunction Instances

Every GeneratorFunction instance is an ordinary function object and has
the internal data properties listed in Table 13. The value of the
[[FunctionKind]] internal data property for all such instances is
"GENERATOR".

The GeneratorFunction instances have the following own properties:

length

The value of the LENGTH property is an integer that indicates the
typical number of arguments expected by the GeneratorFunction. However,
the language permits the function to be invoked with some other number
of arguments. The behaviour of a GeneratorFunction when invoked on a
number of arguments other than the number specified by its LENGTH
property depends on the function.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

prototype

Whenever a GeneratorFunction instance is created another ordinary object
is also created and is the initial value of the generator function’s
PROTOTYPE property. The value of the prototype property is used to
initialise the [[Prototype]] internal data property of a newly created
Generator object before the generator function object is invoked as a
constructor for that newly created object.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

NOTE Unlike function instances, the object that is the value of the a
GeneratorFunction’s PROTOTYPE property does not have a CONSTRUCTOR
property whose value is the GeneratorFunction instance.

Generator Objects

A Generator object is an instance of a generator function and conforms
to both the Iterator and Iterable interfaces.

Generator instances directly inherit properties from the object that is
the value of the PROTOTYPE property of the Generator function that
created the instance. Generator instances indirectly inherit properties
from the Generator Prototype intrinsic, %GeneratorPrototype%.

Properties of Generator Prototype

The Generator prototype object is the %GeneratorPrototype% intrinsic. It
is also the initial value of the PROTOTYPE property of the %Generator%
intrinsic (the GeneratorFrunction.prototype).

The Generator prototype is an ordinary object. It is not a Generator
instance and does not have a [[GeneratorState]] internal data property.

The value of the [[Prototype]] internal data property of the Generator
prototype object is the intrinsic object %ObjectPrototype% (15.2.4). The
initial value of the [[Extensible]] internal data property of the
Function prototype object is TRUE.

All Generator instances indirectly inherit properties of the Generator
prototype object.

Generator.prototype.constructor

The initial value of GENERATOR.PROTOTYPE.CONSTRUCTOR is the intrinsic
object %Generator%.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

 Generator.prototype.next ( value )

The NEXT method performs the following steps:

1.  Let g be the THIS value.

2.  Return the result of GeneratorResume(g, value).

Generator.prototype.throw ( exception )

The THROW method performs the following steps:

1.  Let generator be the THIS value.

2.  If Type(generator) is not Object, then throw a TYPEERROR
    exception.

3.  If generator does not have a [[GeneratorState]] internal data
    property, then throw a TYPEERROR exception.

4.  Let state be the value of generator’s [[GeneratorState]]
    internal data property.

5.  Assert: generator also has a [[GeneratorContext]] internal data
    property.

6.  If state is neither "SUSPENDEDSTART" or "SUSPENDEDYIELD", then
    throw a TYPEERROR exception.

7.  Let E be Completion {[[type]]: throw, [[value]]: exception,
    [[target]]: empty}.

8.  If state is "SUSPENDEDSTART" then,

    a.  Set generator’s [[GeneratorState]] internal data property to
        "COMPLETED".

    b.  Once a generator enters the "COMPLETED" state it never leaves it
        and its associated execution context is never resumed. Any
        execution state associated with generator can be discard at
        this point.

    c.  Return E.

9.  Let genContext be value of generator’s [[GeneratorContext]]
    internal data property.

10. Let methodContext be the running execution context.

11. Suspend methodContext.

12. Set generator’s [[GeneratorState]] internal data property to
    "EXECUTING".

13. Push genContext onto the execution context stack; genContext is
    now the running execution context.

14. Resume the suspended evaluation of genContext using E as the
    result of the operation that suspended it. Let result be the value
    returned by the resumed compation.

15. Assert: When we return here, genContext has already been removed
    from the execution context stack and methodContext is the
    currently running execution context.

16. Return result.

Generator.prototype [ @@iterator ] ( )

The following steps are taken:

1.  Return the THIS value.

 Generator.prototype [ @@toStringTag ]

The initial value of the @@toStringTag property is the string value
"GENERATOR".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Properties of Generator Instances

Generator instances are initially created with the internal data
properties described in Table 37.

Table 39 — Internal Data Properties of Generator Instances

  ----------------------------- -----------------------------------------------------------------------------------------------------------------------------------------------------
  INTERNAL DATA PROPERTY NAME   DESCRIPTION
  [[GeneratorState]]            The current execution state of the generator. The possible values are: UNDEFINED, "SUSPENDEDSTART", "SUSPENDEDYIELD", "EXECUTING", and "COMPLETED".
  [[GeneratorContext]]          The execution context that is used when executing the code of this generator.
  ----------------------------- -----------------------------------------------------------------------------------------------------------------------------------------------------

Iteration Related Abstract Operations

 GeneratorStart (generator, generatorBody)

1.  Assert: The value of generator’s [[GeneratorState]] internal data
    property is UNDEFINED.

2.  Let genContext be the running execution context.

3.  Set the Generator component of genContext to generator.

4.  Set the code evaluation state of genContext such that when
    evaluation is resumed for that execution context the following steps
    will be performed:

    a.  Let result be the result of evaluating generatorBody.

    b.  Assert: If we return here, the generator either threw an
        exception or performed either an implicit or explicit return.

    c.  Remove genContext from the execution context stack and restore
        the execution context that is at the top of the execution
        context stack as the running execution context.

    d.  Set generator’s [[GeneratorState]] internal data property to
        "COMPLETED".

    e.  Once a generator enters the "COMPLETED" state it never leaves it
        and its associated execution context is never resumed. Any
        execution state associated with generator can be discard at
        this point.

    f.  ReturnIfAbrupt(result).

    g.  Return CreateItrResultObject(result, TRUE).

5.  Set generator’s [[GeneratorContext]] internal data property to
    genContext.

6.  Set generator’s [[GeneratorState]] internal data property to
    "SUSPENDEDSTART".

7.  Return NormalCompletion(generator).

 GeneratorResume ( generator, value )

The abstract operation GeneratorResume with arguments generator and
value performs the following steps:

1.  If Type(generator) is not Object, then throw a TYPEERROR
    exception.

2.  If generator does not have a [[GeneratorState]] internal data
    property, then throw a TYPEERROR exception.

3.  Let state be the value of generator’s [[GeneratorState]]
    internal data property.

4.  Assert: generator also has a [[GeneratorContext]] internal data
    property.

5.  If state is neither "SUSPENDEDSTART" or "SUSPENDEDYIELD", then
    throw a TYPEERROR exception.

6.  If state is "SUSPENDEDSTART" and value is not UNDEFINED, then
    throw a TYPEERROR exception.

7.  Let genContext be value of generator’s [[GeneratorContext]]
    internal data property.

8.  Let methodContext be the running execution context.

9.  Suspend methodContext.

10. Set generator’s [[GeneratorState]] internal data property to
    "EXECUTING".

11. Push genContext onto the execution context stack; genContext is
    now the running execution context.

12. Resume the suspended evaluation of genContext using
    NormalCompletion(value) as the result of the operation that
    suspended it. Let result be the value returned by the resumed
    computation.

13. Assert: When we return here, genContext has already been removed
    from the execution context stack and methodContext is the
    currently running execution context.

14. Return result.

 GeneratorYield ( itrNextObj )

The abstract operation GeneratorYield with argument itrNextObj
performs the following steps:

1.  Assert: itrNextObj is an Object that implemented the ItrResult
    interface.

2.  Let genContext be the running execution context.

3.  Assert: genContext is the execution context of a generator.

4.  Let generator be the value of the Generator component of
    genContext.

5.  Set the value of generator’s [[GeneratorState]] internal data
    property to "SUSPENDEDYIELD".

6.  Remove genContext from the execution context stack and restore the
    execution context that is at the top of the execution context stack
    as the running execution context.

7.  Set the code evaluation state of genContext such that when
    evaluation is resumed with a Completion resumptionValue the
    following steps will be performed:

    a.  Return resumptionValue.

    b.  NOTE: This returns to the evaluation of the YieldExpression
        production that originally called this abstract operation.

8.  Resume the suspended evaluation of genContext using
    NormalCompletion(value) as the result of the operation that
    suspended it. Let result be the value returned by the resumed
    computation.

9.  Assert: When we return here, genContext has already been removed
    from the execution context stack and the currently running execution
    context is the context that most recently resumed execution of
    generator.

10. Return NormalCompletion(itrNextObj).

11. NOTE: This returns to the evaluation of the operation that had most
    previously resumed evaluation of genContext.

 CreateItrResultObject (value, done)

The abstract operation CreateItrResultObject with arguments value and
done creates an object that supports the ItrResult interface by
performing the following steps:

1.  Assert: Type(done) is Boolean.

2.  Let obj be the result of performing
    ObjectCreate(%ObjectPrototype%).

3.  Perform CreateOwnDataProperty(obj, "VALUE", value).

4.  Perform CreateOwnDataProperty(obj, "DONE", done).

5.  Return obj.

GetIterator ( obj )

The abstract operation GetIterator with argument obj performs the
following steps:

1.  Let iterator be the result of performing Invoke with arguments
    obj, @@iterator and an empty List.

2.  ReturnIfAbrupt(iterator_)_.

3.  If Type(iterator) is not Object, then throw a TYPEERROR exception.

4.  Return iterator.

IteratorNext ( iterator, value )

The abstract operation IteratorNext with argument iterator and
optional argument value performs the following steps:

1.  If value was not passed, let value be UNDEFINED.

2.  Let result be the result of Invoke(iterator, "NEXT", (value)).

3.  ReturnIfAbrupt(result).

4.  If Type(result) is not Object, then throw a TYPEERROR exception.

5.  Return result.

IteratorComplete ( itrResult )

The abstract operation IteratorComplete with argument itrResult
performs the following steps:

1.  Assert: Type(itrResult) is Object.

2.  Let done be the result of Get(itrResult, "DONE").

3.  Return ToBoolean(done).

IteratorValue ( itrResult )

The abstract operation IteratorValue with argument itrResult
performing the following steps:

1.  Assert: Type(itrResult) is Object.

2.  Return the result of Get(itrResult, "VALUE).

 CreateEmptyIterator ( )

The abstract operation CreateEmptyIterator with no arguments creates an
Iterator object whose next method always reports that the iterator is
done. It performs the following steps:

1.  Let obj be the result of performing
    ObjectCreate(%ObjectPrototype%).

2.  Let emptyNextMethod be the result of CreateBuiltinFunction using
    the steps defined below.

3.  Perform CreateOwnDataProperty(obj, "NEXT", emptyNextMethod).

4.  Return obj.

An emptyNextMethod method performs the following steps:

1.  Let result be the result of performing CreateItrResultObject
    (UNDEFINED, TRUE).

2.  Return result.



ERRORS


An implementation must report most errors at the time the relevant
ECMAScript language construct is evaluated. An _early error_ is an error
that can be detected and reported prior to the evaluation of any
construct in the Script containing the error. An implementation must
report early errors in a Script prior to the first evaluation of that
Script. Early errors in EVAL code are reported at the time EVAL is
called but prior to evaluation of any construct within the EVAL code.
All errors that are not early errors are runtime errors.

An implementation must treat as an early error any instance of an early
error that is specified in a static

-   

An implementation shall not treat other kinds of errors as early errors
even if the compiler can prove that a construct cannot execute without
error under any circumstances. An implementation may issue an early
warning in such a case, but it should not report the error until the
relevant construct is actually executed.

An implementation shall report all errors as specified, except for the
following:

-   An implementation may extend script syntax and regular expression
      pattern or flag syntax. To permit this, all operations (such as
      calling EVAL, using a regular expression literal, or using the
      FUNCTION or REGEXP constructor) that are allowed to throw
      SYNTAXERROR are permitted to exhibit implementation-defined
      behaviour instead of throwing SYNTAXERROR when they encounter an
      implementation-defined extension to the script syntax or regular
      expression pattern or flag syntax.

-   An implementation may provide additional types, values, objects,
      properties, and functions beyond those described in this
      specification. This may cause constructs (such as looking up a
      variable in the global scope) to have implementation-defined
      behaviour instead of throwing an error (such as REFERENCEERROR).

-   An implementation may define behaviour other than throwing
      RANGEERROR for TOFIXED, TOEXPONENTIAL, and TOPRECISION when the
      fractionDigits or precision argument is outside the specified
      range.

(informative)
Grammar Summary


Lexical Grammar

SourceCharacter :: See clause 6

any Unicode code unit

InputElementDiv :: See clause 7

WhiteSpace
LineTerminator
Comment
Token
DivPunctuator

InputElementRegExp :: See clause 7

WhiteSpace
LineTerminator
Comment
Token
RegularExpressionLiteral

WhiteSpace :: See 7.2

<TAB>
<VT>
<FF>
<SP>
<NBSP>
<BOM>
<USP>

LineTerminator :: See 7.3

<LF>
<CR>
<LS>
<PS>

LineTerminatorSequence :: See 7.3

<LF>
<CR> [lookahead ∉ <LF> ]
<LS>
<PS>
<CR> <LF>

Comment :: See 7.4

MultiLineComment
SingleLineComment

MultiLineComment :: See 7.4

/* MultiLineCommentChars~opt~ */

MultiLineCommentChars :: See 7.4

MultiLineNotAsteriskChar MultiLineCommentChars~opt~
* PostAsteriskCommentChars~opt~

PostAsteriskCommentChars :: See 7.4

MultiLineNotForwardSlashOrAsteriskChar MultiLineCommentChars~opt~
* PostAsteriskCommentChars~opt~

MultiLineNotAsteriskChar :: See 7.4

SourceCharacter BUT NOT *

MultiLineNotForwardSlashOrAsteriskChar :: See 7.4

SourceCharacter BUT NOT ONE OF / OR *

SingleLineComment :: See 7.4

// SingleLineCommentChars~opt~

SingleLineCommentChars :: See 7.4

SingleLineCommentChar SingleLineCommentChars~opt~

SingleLineCommentChar :: See 7.4

SourceCharacter BUT NOT LineTerminator

Token :: See 7.5

IdentifierName
Punctuator
NumericLiteral
StringLiteral

Identifier :: See 7.6

IdentifierName BUT NOT ReservedWord

IdentifierName :: See 7.6

IdentifierStart
IdentifierName IdentifierPart

IdentifierStart :: See 7.6

UnicodeLetter
$
_
\ UnicodeEscapeSequence

IdentifierPart :: See 7.6

IdentifierStart
UnicodeCombiningMark
UnicodeDigit
UnicodeConnectorPunctuation
<ZWNJ>
<ZWJ>

UnicodeLetter :: See 7.6

any character in the Unicode categories “Uppercase letter (Lu)”,
“Lowercase letter (Ll)”, “Titlecase letter (Lt)”, “Modifier letter
(Lm)”, “Other letter (Lo)”, or “Letter number (Nl)”.

UnicodeCombiningMark :: See 7.6

any character in the Unicode categories “Non-spacing mark (Mn)” or
“Combining spacing mark (Mc)”

UnicodeDigit :: See 7.6

any character in the Unicode category “Decimal number (Nd)”

UnicodeConnectorPunctuation :: See 7.6

any character in the Unicode category “Connector punctuation (Pc)”

ReservedWord :: See 7.6.1

Keyword
FutureReservedWord
NullLiteral
BooleanLiteral

Keyword :: ONE OF See 7.6.1.1

  ---------- ---------- ------------ --------
  break      do         instanceof   typeof
  case       else       new          var
  catch      finally    return       void
  continue   for        switch       while
  debugger   function   this         with
  default    if         throw        
  delete     in         try          
  ---------- ---------- ------------ --------

FutureReservedWord :: ONE OF See 7.6.1.2

  ------- -------- --------- -------
  class   enum     extends   super
  const   export   import    
  ------- -------- --------- -------

  The following tokens are also considered to be FutureReservedWords
  when parsing strict mode code (see 10.1.1).

  ------------ --------- ----------- --------
  implements   let       private     public
  interface    package   protected   static
  yield                              
  ------------ --------- ----------- --------

Punctuator :: ONE OF See 7.7

  ----- ------ ----- ----- ----- -----
  {     }      (     )     [     ]
  .     ;      ,     <     >     <=
  >=    ==     !=    ===   !==   
  +     -      *     %     ++    --
  <<    >>     >>>   &     |     ^
  !     ~      &&    ||    ?     :
  =     +=     -=    *=    %=    <<=
  >>=   >>>=   &=    |=    ^=    
  ----- ------ ----- ----- ----- -----

DivPunctuator :: ONE OF See 7.7

  --- ---- -- -- -- --
  /   /=            
  --- ---- -- -- -- --

Literal :: See 7.8

NullLiteral
BooleanLiteral
NumericLiteral
StringLiteral
RegularExpressionLiteral

NullLiteral :: See 7.8.1

NULL

BooleanLiteral :: See 7.8.2

TRUE
FALSE

NumericLiteral :: See 7.8.3

DecimalLiteral
HexIntegerLiteral

DecimalLiteral :: See 7.8.3

DecimalIntegerLiteral . DecimalDigits~opt~ ExponentPart~opt~
. DecimalDigits ExponentPart~opt~
DecimalIntegerLiteral ExponentPart~opt~

DecimalIntegerLiteral :: See 7.8.3

0
NonZeroDigit DecimalDigits~opt~

DecimalDigits :: See 7.8.3

DecimalDigit
DecimalDigits DecimalDigit

DecimalDigit :: ONE OF See 7.8.3

0 1 2 3 4 5 6 7 8 9

NonZeroDigit :: ONE OF See 7.8.3

1 2 3 4 5 6 7 8 9

ExponentPart :: See 7.8.3

ExponentIndicator SignedInteger

ExponentIndicator :: ONE OF See 7.8.3

E E

SignedInteger :: See 7.8.3

DecimalDigits
+ DecimalDigits
- DecimalDigits

HexIntegerLiteral :: See 7.8.3

0X HexDigit
0X HexDigit
HexIntegerLiteral HexDigit

HexDigit :: ONE OF See 7.8.3

0 1 2 3 4 5 6 7 8 9 A B C D E F A B C D E F

StringLiteral :: See 7.8.4

" DoubleStringCharacters~opt~ "
' SingleStringCharacters~opt~ '

DoubleStringCharacters :: See 7.8.4

DoubleStringCharacter DoubleStringCharacters~opt~

SingleStringCharacters :: See 7.8.4

SingleStringCharacter SingleStringCharacters~opt~

DoubleStringCharacter :: See 7.8.4

SourceCharacter BUT NOT ONE OF " OR \ OR LineTerminator
\ EscapeSequence
LineContinuation

SingleStringCharacter :: See 7.8.4

SourceCharacter BUT NOT ONE OF ' OR \ OR LineTerminator
\ EscapeSequence
LineContinuation

LineContinuation :: See 7.8.4

\ LineTerminatorSequence

EscapeSequence :: See 7.8.4

CharacterEscapeSequence
0 [lookahead ∉ DecimalDigit]
HexEscapeSequence
UnicodeEscapeSequence

CharacterEscapeSequence :: See 7.8.4

SingleEscapeCharacter
NonEscapeCharacter

SingleEscapeCharacter :: ONE OF See 7.8.4

' " \ B F N R T V

NonEscapeCharacter :: See 7.8.4

SourceCharacter BUT NOT ONE OF EscapeCharacter OR LineTerminator

EscapeCharacter :: See 7.8.4

SingleEscapeCharacter
DecimalDigit
X
U

HexEscapeSequence :: See 7.8.4

X HexDigit HexDigit

UnicodeEscapeSequence :: See 7.8.4

U HexDigit HexDigit HexDigit HexDigit

RegularExpressionLiteral :: See 7.8.5

/ RegularExpressionBody / RegularExpressionFlags

RegularExpressionBody :: See 7.8.5

RegularExpressionFirstChar RegularExpressionChars

RegularExpressionChars :: See 7.8.5

[empty]
RegularExpressionChars RegularExpressionChar

RegularExpressionFirstChar :: See 7.8.5

RegularExpressionNonTerminator BUT NOT ONE OF * OR \ OR / OR [
RegularExpressionBackslashSequence
RegularExpressionClass

RegularExpressionChar :: See 7.8.5

RegularExpressionNonTerminator BUT NOT \ OR / OR [
RegularExpressionBackslashSequence
RegularExpressionClass

RegularExpressionBackslashSequence :: See 7.8.5

\ RegularExpressionNonTerminator

RegularExpressionNonTerminator :: See 7.8.5

SourceCharacter BUT NOT LineTerminator

RegularExpressionClass :: See 7.8.5

[ RegularExpressionClassChars ]

RegularExpressionClassChars :: See 7.8.5

[empty]
RegularExpressionClassChars RegularExpressionClassChar

RegularExpressionClassChar :: See 7.8.5

RegularExpressionNonTerminator BUT NOT ] OR \
RegularExpressionBackslashSequence

RegularExpressionFlags :: See 7.8.5

[empty]
RegularExpressionFlags IdentifierPart


Number Conversions

StringNumericLiteral ::: See 9.1.3.1

StrWhiteSpace~opt~
StrWhiteSpace~opt~ StrNumericLiteral StrWhiteSpace~opt~

StrWhiteSpace ::: See 9.1.3.1

StrWhiteSpaceChar StrWhiteSpace~opt~

StrWhiteSpaceChar ::: See 9.1.3.1

WhiteSpace
LineTerminator

StrNumericLiteral ::: See 9.1.3.1

StrDecimalLiteral
HexIntegerLiteral

StrDecimalLiteral ::: See 9.1.3.1

StrUnsignedDecimalLiteral
+ StrUnsignedDecimalLiteral
- StrUnsignedDecimalLiteral

StrUnsignedDecimalLiteral ::: See 9.1.3.1

INFINITY
DecimalDigits . DecimalDigits~opt~ ExponentPart~opt~
. DecimalDigits ExponentPart~opt~
DecimalDigits ExponentPart~opt~

DecimalDigits ::: See 9.1.3.1

DecimalDigit
DecimalDigits DecimalDigit

DecimalDigit ::: ONE OF See 9.1.3.1

0 1 2 3 4 5 6 7 8 9

ExponentPart ::: See 9.1.3.1

ExponentIndicator SignedInteger

ExponentIndicator ::: ONE OF See 9.1.3.1

E E

SignedInteger ::: See 9.1.3.1

DecimalDigits
+ DecimalDigits
- DecimalDigits

HexIntegerLiteral ::: See 9.1.3.1

0X HexDigit
0X HexDigit
HexIntegerLiteral HexDigit

HexDigit ::: ONE OF See 9.1.3.1

0 1 2 3 4 5 6 7 8 9 A B C D E F A B C D E F


Expressions

PrimaryExpression : See 11.1

THIS
Identifier
Literal
ArrayLiteral
ObjectLiteral
( Expression )

ArrayLiteral : See 11.1.4

[ Elision~opt~ ]
[ ElementList ]
[ ElementList , Elision~opt~ ]

ElementList : See 11.1.4

Elision~opt~ AssignmentExpression
ElementList , Elision~opt~ AssignmentExpression

Elision : See 11.1.4

,
Elision ,

ObjectLiteral : See 11.1.5

{ }
{ PropertyDefinitionList }
{ PropertyDefinitionList , }

PropertyDefinitionList : See 11.1.5

PropertyDefinition
PropertyDefinitionList , PropertyDefinition

PropertyDefinition : See 11.1.5

PropertyName : AssignmentExpression
GET PropertyName ( ) { FunctionBody }
SET PropertyName ( PropertySetParameterList ) { FunctionBody }

PropertyName : See 11.1.5

IdentifierName
StringLiteral
NumericLiteral

PropertySetParameterList : See 11.1.5

Identifier

MemberExpression : See 11.2

PrimaryExpression
FunctionExpression
MemberExpression [ Expression ]
MemberExpression . IdentifierName
NEW MemberExpression Arguments

NewExpression : See 11.2

MemberExpression
NEW NewExpression

CallExpression : See 11.2

MemberExpression Arguments
CallExpression Arguments
CallExpression [ Expression ]
CallExpression . IdentifierName

Arguments : See 11.2

( )
( ArgumentList )

ArgumentList : See 11.2

AssignmentExpression
ArgumentList , AssignmentExpression

LeftHandSideExpression : See 11.2

NewExpression
CallExpression

PostfixExpression : See 11.3

LeftHandSideExpression
LeftHandSideExpression [no LineTerminator here] ++
LeftHandSideExpression [no LineTerminator here] --

UnaryExpression : See 11.4

PostfixExpression
DELETE UnaryExpression
VOID UnaryExpression
TYPEOF UnaryExpression
++ UnaryExpression
-- UnaryExpression
+ UnaryExpression
- UnaryExpression
~ UnaryExpression
! UnaryExpression

MultiplicativeExpression : See 11.5

UnaryExpression
MultiplicativeExpression * UnaryExpression
MultiplicativeExpression / UnaryExpression
MultiplicativeExpression % UnaryExpression

AdditiveExpression : See 11.6

MultiplicativeExpression
AdditiveExpression + MultiplicativeExpression
AdditiveExpression - MultiplicativeExpression

ShiftExpression : See 11.7

AdditiveExpression
ShiftExpression << AdditiveExpression
ShiftExpression >> AdditiveExpression
ShiftExpression >>> AdditiveExpression

RelationalExpression : See 11.8

ShiftExpression
RelationalExpression < ShiftExpression
RelationalExpression > ShiftExpression
RelationalExpression <= ShiftExpression
RelationalExpression >= ShiftExpression
RelationalExpression INSTANCEOF ShiftExpression
RelationalExpression IN ShiftExpression

EqualityExpression : See 11.9

RelationalExpression
EqualityExpression == RelationalExpression
EqualityExpression != RelationalExpression
EqualityExpression === RelationalExpression
EqualityExpression !== RelationalExpression

BitwiseANDExpression : See 11.10

EqualityExpression
BitwiseANDExpression & EqualityExpression

BitwiseXORExpression : See 11.10

BitwiseANDExpression
BitwiseXORExpression ^ BitwiseANDExpression

BitwiseORExpression : See 11.10

BitwiseXORExpression
BitwiseORExpression | BitwiseXORExpression

LogicalANDExpression : See 11.11

BitwiseORExpression
LogicalANDExpression && BitwiseORExpression

LogicalORExpression : See 11.11

LogicalANDExpression
LogicalORExpression || LogicalANDExpression

ConditionalExpression : See 11.12

LogicalORExpression
LogicalORExpression ? AssignmentExpression : AssignmentExpression

AssignmentExpression : See 11.13

ConditionalExpression
LeftHandSideExpression = AssignmentExpression
LeftHandSideExpression AssignmentOperator AssignmentExpression

AssignmentOperator : ONE OF See 11.13

  ---- ---- ---- ---- ---- ----- ----- ------ ---- ---- ----
  *=   /=   %=   +=   -=   <<=   >>=   >>>=   &=   ^=   |=
  ---- ---- ---- ---- ---- ----- ----- ------ ---- ---- ----

Expression : See 11.14

AssignmentExpression
Expression , AssignmentExpression


Statements

Statement : See clause 12

Block
VariableStatement
EmptyStatement
ExpressionStatement
IfStatement
IterationStatement
ContinueStatement
BreakStatement
ReturnStatement
WithStatement
LabelledStatement
SwitchStatement
ThrowStatement
TryStatement
DebuggerStatement

Block : See 12.1

{ StatementList~opt~ }

StatementList : See 12.1

Statement
StatementList Statement

VariableStatement : See 12.2

VAR VariableDeclarationList ;

VariableDeclarationList : See 12.2

VariableDeclaration
VariableDeclarationList , VariableDeclaration

VariableDeclaration : See 12.2

Identifier Initialiser~opt~

Initialiser : See 12.2

= AssignmentExpression

EmptyStatement : See 12.3

;

ExpressionStatement : See 12.4

[lookahead ∉ {{, FUNCTION}] Expression ;

IfStatement : See 12.5

IF ( Expression ) Statement ELSE Statement
IF ( Expression ) Statement

IterationStatement : See 12.6

DO Statement WHILE ( Expression );
WHILE ( Expression ) Statement
FOR (Expression~opt~; Expression~opt~ ; Expression~opt~ ) Statement
FOR ( VAR VariableDeclarationList; Expression~opt~ ; Expression~opt~ )
Statement
FOR ( LeftHandSideExpression IN Expression ) Statement
FOR ( VAR VariableDeclaration IN Expression ) Statement

ContinueStatement : See 12.7

CONTINUE ;
CONTINUE [no LineTerminator here] Identifier ;

BreakStatement : See 12.8

BREAK ;
BREAK [no LineTerminator here] Identifier ;

ReturnStatement : See 12.9

RETURN ;
RETURN [no LineTerminator here] Expression ;

WithStatement : See 12.10

WITH ( Expression ) Statement

SwitchStatement : See 12.11

SWITCH ( Expression ) CaseBlock

CaseBlock : See 12.11

{ CaseClauses~opt~ }
{ CaseClauses~opt~ DefaultClause CaseClauses~opt~ }

CaseClauses : See 12.11

CaseClause
CaseClauses CaseClause

CaseClause : See 12.11

CASE Expression : StatementList~opt~

DefaultClause : See 12.11

DEFAULT : StatementList~opt~

LabelledStatement : See 12.12

Identifier : Statement

ThrowStatement : See 12.13

THROW [no LineTerminator here] Expression ;

TryStatement : See 12.14

TRY Block Catch~
~TRY Block Finally~
~TRY Block Catch Finally

Catch : See 12.14

CATCH ( Identifier ) Block

Finally : See 12.14

FINALLY Block

DebuggerStatement : See 12.15

DEBUGGER ;


Functions and Scripts

FunctionDeclaration : See clause 13

FUNCTION Identifier ( FormalParameterList~opt~ ) { FunctionBody }

FunctionExpression : See clause 13

FUNCTION Identifier~opt~ ( FormalParameterList~opt~ ) { FunctionBody }

FormalParameterList : See clause 13

Identifier
FormalParameterList , Identifier

FunctionBody : See clause 13

SourceElements~opt~

Program : See clause 14

SourceElements~opt~

SourceElements : See clause 14

SourceElement
SourceElements SourceElement

SourceElement : See clause 14

Statement
FunctionDeclaration


Universal Resource Identifier Character Classes

uri ::: See 15.1.3

uriCharacters~opt~

uriCharacters ::: See 15.1.3

uriCharacter uriCharacters~opt~

uriCharacter ::: See 15.1.3

uriReserved
uriUnescaped
uriEscaped

uriReserved ::: ONE OF See 15.1.3

; / ? : @ & = + $ ,

uriUnescaped ::: See 15.1.3

uriAlpha
DecimalDigit
uriMark

uriEscaped ::: See 15.1.3

% HexDigit HexDigit

uriAlpha ::: ONE OF See 15.1.3

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

uriMark ::: ONE OF See 15.1.3

- _ . ! ~ * ' ( )


Regular Expressions

Pattern :: See 15.10.1

Disjunction

Disjunction :: See 15.10.1

Alternative
 Alternative | Disjunction

Alternative :: See 15.10.1

[empty]
Alternative Term

Term :: See 15.10.1

Assertion
Atom
Atom Quantifier

Assertion :: See 15.10.1

^
$
\ B
\ B
( ? = Disjunction )
( ? ! Disjunction )

Quantifier :: See 15.10.1

QuantifierPrefix
QuantifierPrefix ?

QuantifierPrefix :: See 15.10.1

*
+
?
{ DecimalDigits }
{ DecimalDigits , }
{ DecimalDigits , DecimalDigits }

Atom :: See 15.10.1

PatternCharacter
.
\ AtomEscape
CharacterClass
( Disjunction )
( ? : Disjunction )

PatternCharacter :: See 15.10.1

SourceCharacter BUT NOT ONE OF-
 ^ $ \ . * + ? ( ) [ ] { } |

AtomEscape :: See 15.10.1

DecimalEscape
CharacterEscape
CharacterClassEscape

CharacterEscape :: See 15.10.1

ControlEscape
C ControlLetter
HexEscapeSequence
UnicodeEscapeSequence
IdentityEscape

ControlEscape :: ONE OF See 15.10.1

F N R T V

ControlLetter :: ONE OF See 15.10.1

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

IdentityEscape :: See 15.10.1

SourceCharacter BUT NOT IdentifierPart
<ZWJ>
<ZWNJ>

DecimalEscape :: See 15.10.1

DecimalIntegerLiteral [lookahead ∉ DecimalDigit]

CharacterClassEscape :: ONE OF See 15.10.1

D D S S W W

CharacterClass :: See 15.10.1

[ [lookahead ∉ {^}] ClassRanges ]
[ ^ ClassRanges ]

ClassRanges :: See 15.10.1

[empty]
NonemptyClassRanges

NonemptyClassRanges :: See 15.10.1

ClassAtom
ClassAtom NonemptyClassRangesNoDash
ClassAtom – ClassAtom ClassRanges

NonemptyClassRangesNoDash :: See 15.10.1

ClassAtom
ClassAtomNoDash NonemptyClassRangesNoDash
ClassAtomNoDash – ClassAtom ClassRanges

ClassAtom :: See 15.10.1

-
ClassAtomNoDash

ClassAtomNoDash :: See 15.10.1

SourceCharacter BUT NOT ONE OF \ OR ] OR -
\ ClassEscape

ClassEscape :: See 15.10.1

DecimalEscape
B
CharacterEscape
CharacterClassEscape


JSON

JSON Lexical Grammar

JSONWhiteSpace :: See 15.12.1.1

_<TAB>
<CR>
<LF>
<SP>_

JSONString :: See 15.12.1.1

" JSONStringCharacters~opt~ "

JSONStringCharacters :: See 15.12.1.1

JSONStringCharacter JSONStringCharacters~opt~

JSONStringCharacter :: See 15.12.1.1

SourceCharacter BUT NOT ONE OF " OR \ OR U+0000 THROUGH U+001F

\ JSONEscapeSequence

JSONEscapeSequence :: See 15.12.1.1

JSONEscapeCharacter

UnicodeEscapeSequence

JSONEscapeCharacter :: ONE OF See 15.12.1.1

" / \ B F N R T

JSONNumber :: See 15.12.1.1

-~opt~ DecimalIntegerLiteral JSONFraction~opt~ ExponentPart~opt~

JSONFraction :: See 15.12.1.1

. DecimalDigits

JSONNullLiteral :: See 15.12.1.1

NullLiteral

JSONBooleanLiteral :: See 15.12.1.1

BooleanLiteral

JSON Syntactic Grammar

JSONText : See 15.12.1.2

JSONValue

JSONValue : See 15.12.1.2

JSONNullLiteral
JSONBooleanLiteral
JSONObject
JSONArray
JSONString
JSONNumber

JSONObject : See 15.12.1.2

{ }
{ JSONMemberList }

JSONMember : See 15.12.1.2

JSONString : JSONValue

JSONMemberList : See 15.12.1.2

JSONMember
JSONMemberList , JSONMember

JSONArray : See 15.12.1.2

[ ]
[ JSONElementList ]

JSONElementList : See 15.12.1.2

JSONValue
JSONElementList , JSONValue

(normative)
Additional ECMAScript Features for Web Browsers

The ECMAScript language syntax and semantics defined in this annex are
required when the ECMAScript host is a web browser. The content of this
annex is normative but optional if the ECMAScript host is not a web
browser.


Additional Syntax

Numeric Literals

The syntax and semantics of 7.8.3 is extended as follows except that
this extension is not allowed for strict mode code:

Syntax

NumericLiteral ::

DecimalLiteral
BinaryIntegerLiteral
OctalIntegerLiteral
HexIntegerLiteral
LegacyOctalIntegerLiteral

LegacyOctalIntegerLiteral ::

0 OctalDigit
LegacyOctalIntegerLiteral OctalDigit

STATIC

SEMANTICS

-   -   -   -   -   -   -   -   -   -   The MV of
      LegacyOctalIntegerLiteral :: 0 OctalDigit is the MV of
      OctalDigit.

-   The MV of LegacyOctalIntegerLiteral :: LegacyOctalIntegerLiteral
      OctalDigit is (the MV of LegacyOctalIntegerLiteral times 8)
      plus the MV of OctalDigit.

String Literals

The syntax and semantics of 7.8.4 is extended as follows except that
this extension is not allowed for strict mode code:

Syntax

EscapeSequence ::

CharacterEscapeSequence
OctalEscapeSequence
HexEscapeSequence
UnicodeEscapeSequence

OctalEscapeSequence ::

OctalDigit [lookahead ∉ DecimalDigit]
ZeroToThree OctalDigit [lookahead ∉ DecimalDigit]
FourToSeven OctalDigit
ZeroToThree OctalDigit OctalDigit

ZeroToThree :: ONE OF

0 1 2 3

FourToSeven :: ONE OF

4 5 6 7

Static Semantics

-   The CV of EscapeSequence :: OctalEscapeSequence is the CV of the
    OctalEscapeSequence.

-   The CV of OctalEscapeSequence :: OctalDigit [lookahead ∉
    DecimalDigit] is the character whose code unit value is the MV of
    the OctalDigit.

-   The CV of OctalEscapeSequence :: ZeroToThree OctalDigit
    [lookahead ∉ DecimalDigit] is the character whose code unit value
    is (8 times the MV of the ZeroToThree) plus the MV of the
    OctalDigit.

-   The CV of OctalEscapeSequence :: FourToSeven OctalDigit is the
    character whose code unit value is (8 times the MV of the
    FourToSeven) plus the MV of the OctalDigit.

-   The CV of OctalEscapeSequence :: ZeroToThree OctalDigit
    OctalDigit is the character whose code unit value is (64 (that is,
    8^2^) times the MV of the ZeroToThree) plus (8 times the MV of the
    first OctalDigit) plus the MV of the second OctalDigit.

-   The MV of ZeroToThree :: 0 is 0.

-   The MV of ZeroToThree :: 1 is 1.

-   The MV of ZeroToThree :: 2 is 2.

-   The MV of ZeroToThree :: 3 is 3.

-   The MV of FourToSeven :: 4 is 4.

-   The MV of FourToSeven :: 5 is 5.

-   The MV of FourToSeven :: 6 is 6.

-   The MV of FourToSeven :: 7 is 7.

HTML-like Comments

TODO See http://javascript.spec.whatwg.org/#comment-syntax


Additional Properties

When the ECMAScript host is a web browser the following additional
properties of the standard built-in objects are defined.

Additional Properties of the Global Object

escape (string)

The ESCAPE function is a property of the global object. It computes a
new version of a String value in which certain characters have been
replaced by a hexadecimal escape sequence.

For those characters being replaced whose code unit value is 0XFF or
less, a two-digit escape sequence of the form %xx is used. For those
characters being replaced whose code unit value is greater than 0XFF, a
four-digit escape sequence of the form %Uxxxx is used.

When the ESCAPE function is called with one argument string, the
following steps are taken:

NOTE The encoding is partly based on the encoding described in RFC 1738,
but the entire encoding specified in this standard is described above
without regard to the contents of RFC 1738. This encoding does not
reflect changes to RFC 1738 made by RFC 3986.

unescape (string)

The UNESCAPE function is a property of the global object. It computes a
new version of a String value in which each escape sequence of the sort
that might be introduced by the ESCAPE function is replaced with the
character that it represents.

When the UNESCAPE function is called with one argument string, the
following steps are taken:

Additional Properties of the Object.prototype Object

Object.prototype._proto_ 

Object.prototype._proto_ is an accessor property with attributes {
[[Enumerable]]: FALSE, [[Configurable]]: TRUE }. The [[Get]] and [[Set]]
attributes are defined as follows

get Object.prototype._proto_ 

The value of the [[Get]] attribute is a built-in function that requires
no arguments. It performs the following steps:

1.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(O).

3.  4.  5.  Return the result of calling the [[GetInheritance]] internal
    method of O.

set Object.prototype._proto_ 

The value of the [[Set]] attribute is a built-in function that takes an
argument proto. It performs the following steps:

1.  Let O be CheckObjectCoercible(THIS value).

2.  ReturnIfAbrupt(O).

3.  If Type(proto) is neither Object or Null, then return proto.

4.  If Type(O) is not Object, then return proto.

5.  Let status be the result of calling the [[SetInheritance]]
    internal method of O with argument proto.

6.  ReturnIfAbrupt(status).

7.  If status is FALSE, then throw a TYPEERROR exception.

8.  Return proto.

Additional Properties of the String.prototype Object

String.prototype.substr (start, length)

The SUBSTR method takes two arguments, start and length, and returns
a substring of the result of converting the this object to a String,
starting from character position start and running for length
characters (or through the end of the String if length is UNDEFINED).
If start is negative, it is treated as (sourceLength_+_start) where
sourceLength is the length of the String. The result is a String
value, not a String object. The following steps are taken:

The LENGTH property of the SUBSTR method is 2.

NOTE The SUBSTR function is intentionally generic; it does not require
that its THIS value be a String object. Therefore it can be transferred
to other kinds of objects for use as a method.

String.prototype.anchor ( name )

When the ANCHOR method is called with argument name, the following
steps are taken:

The abstract operation CreateHTML is called with arguments _string,
tag_, attribute, and value. The arguments tag and attribute must
be string values. The following steps are taken:

1.  Let str be CheckObjectCoercible(string).

2.  Let S be ToString(str).

3.  ReturnIfAbrupt(S).

4.  a.  b.  

5.  Let p1 be the string value that is the concatenation of "<" and
    tag.

6.  If attribute is not the empty String, then

    a.  Let V be the result of performing ToString(value).

    b.  ReturnIfAbrupt(V).

    c.  Let escapedV be the string value that is the same as V
        except that each occurrence of the character " (code unit value
        0x0022) in V has been replaced with the six character sequence
        "&QUOT;".

    d.  Let p1 be the string value that is the concatenation of the
        following string values:

-   p1

-   a single space code unit 0x0020

-   attribute

-   "="

-   ′"′

-   escapedV

-   ′"′

1.  Let p2 be the string value that is the concatenation of p1 and
    ">".

2.  Let p3 be the string value that is the concatenation of p2 and
    S.

3.  Let p4 be the string value that is the concatenation of p2,
    "</", tag, and ">".

4.  Return p4.

String.prototype.big ()

When the BIG method is called with no arguments, the following steps are
taken:

1.  Let S be the THIS value.

2.  Return the result of performing the abstract operation CreateHTML
    with arguments S, "BIG", "" and "".

String.prototype.blink ()

When the BLINK method is called with no arguments, the following steps
are taken:

1.  Let S be the THIS value.

2.  Return the result of performing the abstract operation CreateHTML
    with arguments S, "BLINK", "" and "".

String.prototype.bold ()

When the BOLD method is called with no arguments, the following steps
are taken:

1.  Let S be the THIS value.

2.  Return the result of performing the abstract operation CreateHTML
    with arguments S, "B", "" and "".

String.prototype.fixed ()

When the FIXED method is called with no arguments, the following steps
are taken:

1.  Let S be the THIS value.

2.  Return the result of performing the abstract operation CreateHTML
    with arguments S, "TT", "" and "".

String.prototype.fontcolor ( color )

When the FONTCOLOR method is called with argument color, the following
steps are taken:

1.  Let S be the THIS value.

2.  Return the result of performing the abstract operation CreateHTML
    with arguments S, "FONT", "COLOR" and color.

String.prototype.fontsize ( size )

When the FONTSIZE method is called with argument size, the following
steps are taken:

1.  Let S be the THIS value.

2.  Return the result of performing the abstract operation CreateHTML
    with arguments S, "FONT", "SIZE" and size.

String.prototype.italics ()

When the ITALICS method is called with no arguments, the following steps
are taken:

1.  Let S be the THIS value.

2.  Return the result of performing the abstract operation CreateHTML
    with arguments S, "I", "" and "".

String.prototype.link ( url )

When the LINK method is called with argument url, the following steps
are taken:

1.  Let S be the THIS value.

2.  Return the result of performing the abstract operation CreateHTML
    with arguments S, "A", "HREF" and url.

String.prototype.small ()

When the SMALL method is called with no arguments, the following steps
are taken:

1.  Let S be the THIS value.

2.  Return the result of performing the abstract operation CreateHTML
    with arguments S, "SMALL", "" and "".

String.prototype.strike ()

When the STRIKE method is called with no arguments, the following steps
are taken:

1.  Let S be the THIS value.

2.  Return the result of performing the abstract operation CreateHTML
    with arguments S, "STRIKE", "" and "".

String.prototype.sub ()

When the SUB method is called with no arguments, the following steps are
taken:

1.  Let S be the THIS value.

2.  Return the result of performing the abstract operation CreateHTML
    with arguments S, "SUB", "" and "".

String.prototype.sup ()

When the SUP method is called with no arguments, the following steps are
taken:

1.  Let S be the THIS value.

2.  Return the result of performing the abstract operation CreateHTML
    with arguments S, "SUP", "" and "".

Additional Properties of the Date.prototype Object

Date.prototype.getYear ( )

NOTE The GETFULLYEAR method is preferred for nearly all purposes,
because it avoids the “year 2000 problem.”

When the GETYEAR method is called with no arguments, the following steps
are taken:

1.  Let t be this time value.

2.  ReturnIfAbrupt(t).

3.  If t is NAN, return NAN.

4.  Return YearFromTime(LocalTime(t)) − 1900.

Date.prototype.setYear (year)

NOTE The SETFULLYEAR method is preferred for nearly all purposes,
because it avoids the “year 2000 problem.”

When the SETYEAR method is called with one argument year, the
following steps are taken:

Date.prototype.toGMTString ( )

NOTE The property TOUTCSTRING is preferred. The TOGMTSTRING property is
provided principally for compatibility with old code. It is recommended
that the TOUTCSTRING property be used in new ECMAScript code.

The Function object that is the initial value of
DATE.PROTOTYPE.TOGMTSTRING is the same Function object that is the
initial value of DATE.PROTOTYPE.TOUTCSTRING.

Additional Properties of the RegExp.prototype Object

RegExp.prototype.compile (pattern, flags )

When the COMPILE method is called with arguments pattern and flags,
the following steps are taken:

1.  Let O be the THIS value.

2.  If Type(O) is not Object or Type(O) is Object and O does not
    have a [[RegExpMatcher]] internal data property, then

    a.  Throw a TYPEERROR exception.

3.  Let extensible be the result of calling the [[IsExtensible]]
    internal method of O.

4.  If extensible is FALSE, then throw a TYPEERROR exception.

5.  If Type(pattern) is Object and pattern has a [[RegExpMatcher]]
    internal data property, then

    a.  If the value of pattern’s [[RegExpMatcher]] internal data
        property is UNDEFINED, then throw a TYPEERROR exception.

    b.  If flags is not UNDEFINED, then throw a TYPEERROR exception.

    c.  Let P be the value of pattern’s [[OriginalSource]] internal
        data property.

    d.  Let F be the value of pattern’s [[OriginalFlags]] internal
        data property.

6.  Else,

    a.  let P be pattern.

    b.  let F be flags.

7.  Return the result of the abstract operation RegExpInitialise with
    arguments O, P, and F.

NOTE The COMPILE method completely reinitialised the this object RegExp
with a new pattern and flags. An implementaton may interpret use of this
method as an assertion that the resulting RegExp object will be used
multiple times and hence is a candidate for extra optimization.


Other Additional Features

_proto__ Property Names in Object Initialisers

In ‎11.1.5 the Property Definition Evaluation algorithm for the
production PropertyDefinition : PropertyName :
AssignmentExpression is replaced with the following:

PropertyDefinition : PropertyName : AssignmentExpression

1.  Let propKey be the result of evaluating PropertyName.

2.  ReturnIfAbrupt(propKey).

3.  Let exprValue be the result of evaluating AssignmentExpression.

4.  Let propValue be GetValue(exprValue).

5.  ReturnIfAbrupt(propValue).

6.  If propKey is the string value "_PROTO_" and if
    isComputedPropertyName(propKey) is FALSE, then

    a.  If Type(v) is either Object or Null, then

        i.  Return the result of calling the [[SetInheritance]] internal
            method of object with argument propValue.

    b.  Retrun NormalCompletion(empty).

7.  If the source code corresponding to PropertyDefinition is strict
    code and if isComputedPropertyName(propKey) is TRUE, then

    a.  Let duplicateKey be the result of calling the
        [[HasOwnProperty]] internal method of object with argument
        propKey.

    b.  ReturnIfAbrupt(duplicateKey).

    c.  If duplicateKey is TRUE, then throw a TYPEERROR exception.

8.  Let desc be the Property Descriptor{[[Value]]: propValue,
    [[Writable]]: TRUE, [[Enumerable]]: TRUE, [[Configurable]]: TRUE}

9.  Return the result of DefinePropertyOrThrow(object, propKey,
    desc).

    1.  Web Legacy Compatibility for Block-Level Function Declarations

1.  a.  b.  i.  

2.  

1.  a.  b.  i.  ii. iii. 

2.  

1.  a.  

2.  

1.  a.  i.  

2.  

1.  2.  3.  a.  b.  c.  i.  

    d.  

4.  5.  

6.  7.  

Prior to the Sixth Edition, the ECMAScript specification did not define
the occurrence of a FunctionDeclaration as an element of a Block
statement’s StatementList. However, support for that form of
FunctionDeclaration was an allowable extension and most browser-hosted
ECMAScript implementations permitted them. However, the semantics of
such declarations differ among those implementations. Because of these
semantic differences, existing web ECMAScript code that uses Block
level function declarations is only portable among browser
implementation if the usage only depends upon the semantic intersection
of all of the browser implementations for such declarations. The
following are the use cases that fall within that intersection
semantics:

1.  A function is declared and only referenced within a single block

    -   A function declaration with the name f is declared exactly
        once within the function code of an enclosing function g and
        that declaration is nested within a Block.

    -   No other declaration of f that is not a VAR declaration occurs
        within the function code of g

    -   All references to f occur within the StatementList of the
        Block containing the declaration of f.

2.  A function is declared and possibly used within a single Block but
    also referenced by an inner function definition that is not
    contained within that same Block.

    -   A function declaration with the name f is declared exactly
        once within the function code of an enclosing function g and
        that declaration is nested within a Block.

    -   No other declaration of f that is not a VAR declaration occurs
        within the function code of g

    -   References to f may occur within the StatementList of the
        Block containing the declaration of f.

    -   References to f occur within the function code of g that
        lexically follows the Block containing the declaration of f.

3.  A function is declared and possibly used within a single block but
    also referenced within subsequent blocks.

    -   A function declaration with the name f is declared exactly
        once within the function code of an enclosing function g and
        that declaration is nested within a Block.

    -   No other declaration of f that is not a VAR declaration occurs
        within the function code of g

    -   References to f may occur within the StatementList of the
        Block containing the declaration of f.

    -   References to f occur within another function h that is
        nested within g and no other declaration of f shadows the
        references to f from within h.

    -   All invocations of h occur after the declaration of f has
        been evaluated.

The first use case is interoperable with the inclusion of Block level
function declarations in the sixth edition. Any pre-existing ECMAScript
code that employees that use case will operate using the Block level
function declarations semantics defined by clauses 10 and 13 of this
specification.

Sixth edition interoperability for the second and third use cases
requires the following extensions to the clauses 10 and 13 semantics.
These extensions are applied to a non-strict mode functions g if the
above pre-conditions of use cases 2 and 3 above exist at the time of
static semantic analysis of g. However, the last pre-condition of use
case 3 is not included in this determination and the determination is
not applied to any function declaration that is nested within syntactic
constructs that are specified in the Fifth edition of this
specification.

1.  Let B be environment record for the construct within g that
    introduces a new environment contour and which most closely encloses
    the declaration of f, all function code references to f, and the
    definitions of all nested functions that contain unshadowed
    references to f. This syntactic construct may be the definition of
    g itself, in which case B is the function environment record for
    g.

2.  As part of the instantiation of B, its CreateMutableBinding
    concrete method is called with arguments “f” (the string name of the
    function) and FALSE. This creates an uninitialised binding for the
    name f. Any reference that resolves to that binding prior to step
    3 below will throw a REFERENCEERROR exception.

3.  When the InitialiseBinding concrete method is used to initialise the
    binding for the function declaration f also invoke InitialiseBind
    on B using the same arguments.

If an ECMAScript implication has a mechanism that produces diagnostic
warning messages, a warning should be produced for each function g for
which the above steps are performed.

(informative)
The Strict Mode of ECMAScript

THE STRICT MODE RESTRICTION AND EXCEPTIONS

-   The identifiers "IMPLEMENTS", "INTERFACE", "LET", "PACKAGE",
      "PRIVATE", "PROTECTED", "PUBLIC", "STATIC", and "YIELD" are
      classified as FutureReservedWord tokens within strict mode code.
      (7.6.1.2).

-   A conforming implementation, when processing strict mode code, may
      not extend the syntax of NumericLiteral (7.8.3) to include
      LegacyOctalIntegerLiteral as described in B.1.1.

-   A conforming implementation, when processing strict mode code (see
      10.1.1), may not extend the syntax of EscapeSequence to include
      LegacyOctalEscapeSequence as described in B.1.2.

-   Assignment to an undeclared identifier or otherwise unresolvable
      reference does not create a property in the global object. When a
      simple assignment occurs within strict mode code, its
      LeftHandSide must not evaluate to an unresolvable Reference. If
      it does a REFERENCEERROR exception is thrown (8.9.2). The
      LeftHandSide also may not be a reference to a data property with
      the attribute value {[[Writable]]:FALSE}, to an accessor property
      with the attribute value {[[Set]]:UNDEFINED}, nor to a
      non-existent property of an object whose [[Extensible]] internal
      data property has the value FALSE. In these cases a TYPEERROR
      exception is thrown (11.13.1).

-   The identifier EVAL or ARGUMENTS may not appear as the
      LeftHandSideExpression of an Assignment operator (11.13) or of a
      PostfixExpression (11.3) or as the UnaryExpression operated
      upon by a Prefix Increment (11.4.4) or a Prefix Decrement (11.4.5)
      operator.

-   Arguments objects for strict mode functions define non-configurable
      accessor properties named "CALLER" and "CALLEE" which throw a
      TYPEERROR exception on access (10.6).

-   Arguments objects for strict mode functions do not dynamically share
      their array indexed property values with the corresponding formal
      parameter bindings of their functions. (10.6).

-   For strict mode functions, if an arguments object is created the
      binding of the local identifier ARGUMENTS to the arguments object
      is immutable and hence may not be the target of an assignment
      expression. (10.5).

-   It is a SYNTAXERROR if strict mode code contains an ObjectLiteral
      with more than one definition of any data property (11.1.5).

-   It is a SYNTAXERROR if the Identifier "EVAL" or the Identifier
      "ARGUMENTS" occurs as the Identifier in a
      PropertySetParameterList of a PropertyDefinition that is
      contained in strict code or if its FunctionBody is strict code
      (11.1.5).

-   Strict mode eval code cannot instantiate variables or functions in
      the variable environment of the caller to eval. Instead, a new
      variable environment is created and that environment is used for
      declaration binding instantiation for the eval code (10.4.2).

-   If THIS is evaluated within strict mode code, then the THIS value is
      not coerced to an object. A THIS value of NULL or UNDEFINED is not
      converted to the global object and primitive values are not
      converted to wrapper objects. The THIS value passed via a function
      call (including calls made using FUNCTION.PROTOTYPE.APPLY and
      FUNCTION.PROTOTYPE.CALL) do not coerce the passed this value to an
      object (10.4.3, 11.1.1, 15.3.3.3, 15.3.3.4).

-   When a DELETE operator occurs within strict mode code, a SYNTAXERROR
      is thrown if its UnaryExpression is a direct reference to a
      variable, function argument, or function name(11.4.1).

-   When a DELETE operator occurs within strict mode code, a TYPEERROR
      is thrown if the property to be deleted has the attribute {
      [[Configurable]]:FALSE } (11.4.1).

-   It is a SYNTAXERROR if a VariableDeclaration occurs within strict
      code and its Identifier is EVAL or ARGUMENTS (12.2.1).

-   Strict mode code may not include a WithStatement. The occurrence
      of a WithStatement in such a context is an SYNTAXERROR (12.10).

-   It is a SYNTAXERROR if a TryStatement with a Catch occurs within
      strict code and the Identifier of the Catch production is EVAL
      or ARGUMENTS (12.14.1)

-   It is a SYNTAXERROR if the identifier EVAL or ARGUMENTS appears
      within the FormalParameters of a strict mode
      FunctionDeclaration or FunctionExpression (13.1)

-   A strict mode function may not have two or more formal parameters
      that have the same name. An attempt to create such a function
      using a FunctionDeclaration, FunctionExpression, or FUNCTION
      constructor is a SYNTAXERROR (13.1, 15.3.1).

-   An implementation may not extend, beyond that defined in this
      specification, the meanings within strict mode functions of
      properties named CALLER or ARGUMENTS of function instances.
      ECMAScript code may not create or modify properties with these
      names on function objects that correspond to strict mode functions
      (8.3.15.6, 10.6, 15.3.3.5.3).

-   It is a SYNTAXERROR to use within strict mode code the identifiers
      EVAL or ARGUMENTS as the Identifier of a FunctionDeclaration
      or FunctionExpression or as a formal parameter name (13.1).
      Attempting to dynamically define such a strict mode function using
      the FUNCTION constructor (15.3.1) will throw a SYNTAXERROR
      exception.

(informative)
Corrections and Clarifications with Possible Compatibility Impact

IN EDITION 6

15.9.1.14: Previous editions permitted the TimeClip abstract operation
to return either +0 or −0 as the representation of a 0 time value. The
6^th^ Edition specifies that +0 always returned. This means that for the
6^th^ Edition the time value of a Date object is never observably −0 and
methods that return time values never return −0.

15.9.1.15: If a time zone offset is not present, the local time zone is
used. Edition 5.1 incorrectly stated that a missing time zone should be
interpreted as “z”.

15.9.5.2: Previous editions did not specify the value returned by
Date.prototype.toString when this time value is NaN. The 6^th^ Edition
specifies the result to be the String value is "INVALID DATE"

IN EDITION 5.1

7.8.4: CV definitions added for DoubleStringCharacter ::
LineContinuation and SingleStringCharacter :: LineContinuation.

10.2.1.1.3: The argument S is not ignored. It controls whether an
exception is thrown when attempting to set an immutable binding.

10.2.1.2.2: In algorithm step 5, TRUE is passed as the last argument to
[[DefineOwnProperty]].

10.5: Former algorithm step 5.e is now 5.f and a new step 5.e was added
to restore compatibility with 3^rd^ Edition when redefining global
functions.

11.5.3: In the final bullet item, use of IEEE 754 round-to-nearest mode
is specified.

12.6.3: Missing ToBoolean restored in step 3.a.ii of both algorithms.

12.6.4: Additional final sentences in each of the last two paragraphs
clarify certain property enumeration requirements.

12.7, 12.8, 12.9: BNF modified to clarify that a CONTINUE or BREAK
statement without an Identifier or a RETURN statement without an
Expression may have a LineTerminator before the semi-colon.

12.14: Step 3 of algorithm 1 and step 2.a of algorithm 3 are corrected
such that the value field of B is passed as a parameter rather than
B itself.

15.1.2.2: In step 2 of algorithm, clarify that S may be the empty
string.

15.1.2.3: In step 2 of algorithm clarify that trimmedString may be the
empty string.

15.1.3: Added notes clarifying that ECMAScript’s URI syntax is based
upon RFC 2396 and not the newer RFC 3986. In the algorithm for Decode, a
step was removed that immediately preceded the current step 4.d.vii.10.a
because it tested for a condition that cannot occur.

15.2.3.7: Corrected use of variable P in steps 5 and 6 of algorithm.

15.2.4.2: Edition 5 handling of UNDEFINED and NULL as THIS value caused
existing code to fail. Specification modified to maintain compatibility
with such code. New steps 1 and 2 added to the algorithm.

15.3.3.3: Steps 5 and 7 of Edition 5 algorithm have been deleted because
they imposed requirements upon the argArray argument that are
inconsistent with other uses of generic array-like objects.

15.4.3.12: In step 9.a, incorrect reference to relativeStart was
replaced with a reference to actualStart.

15.4.3.15: Clarified that the default value for fromIndex is the
length minus 1 of the array.

15.4.3.18: In step 10 (corresponding to step 8 in 5.1) of the algorithm,
UNDEFINED is now the specified return value.

15.4.3.22: In step 11.d.iii (corresponding to 9.c.ii in 5.1) the first
argument to the [[Call]] internal method has been changed to UNDEFINED
for consistency with the definition of Array.prototype.reduce.

15.4.5.1: In Algorithm steps 3.l.ii and 3.l.iii the variable name was
inverted resulting in an incorrectly inverted test.

15.5.4.9: Normative requirement concerning canonically equivalent
strings deleted from paragraph following algorithm because it is listed
as a recommendation in NOTE 2.

15.5.4.14: In split algorithm step 11.a and 13.a, the positional order
of the arguments to SplitMatch was corrected to match the actual
parameter signature of SplitMatch. In step 13.a.iii.7.d, lengthA
replaces A.length.

15.5.5.2: In first paragraph, removed the implication that the
individual character property access had “array index” semantics.
Modified algorithm steps 3 and 5 such that they do not enforce “array
index” requirement.

15.9.1.15: Specified legal value ranges for fields that lacked them.
Eliminated “time-only” formats. Specified default values for all
optional fields.

15.10.2.2: The step numbers of the algorithm for the internal closure
produced by step 2 were incorrectly numbered in a manner that implied
that they were steps of the outer algorithm.

15.10.2.6: In the abstract operation IsWordChar the first character in
the list in step 3 is “A” rather than “A”.

15.10.2.8: In the algorithm for the closure returned by the abstract
operation CharacterSetMatcher, the variable defined by step 3 and passed
as an argument in step 4 was renamed to ch in order to avoid a name
conflict with a formal parameter of the closure.

15.10.6.2: Step 9.e was deleted because It performed an extra increment
of i.

15.11.1.1: Removed requirement that the message own property is set to
the empty String when the message argument is UNDEFINED.

15.11.1.2: Removed requirement that the message own property is set to
the empty String when the message argument is UNDEFINED.

15.11.4.4: Steps 6-10 modified/added to correctly deal with missing or
empty message property value.

15.11.1.2: Removed requirement that the message own property is set to
the empty String when the message argument is UNDEFINED.

15.12.3: In step 10.b.iii of the JA abstract operation, the last
element of the concatenation is “]”.

B.2.1: Added to NOTE that the encoding is based upon RFC 1738 rather
than the newer RFC 3986.

Annex C: An item was added corresponding to 7.6.12 regarding
FutureReservedWords in strict mode.

IN EDITION 5

Throughout: In the Edition 3 specification the meaning of phrases such
as “as if by the expression NEW ARRAY()” are subject to
misinterpretation. In the Edition 5 specification text for all internal
references and invocations of standard built-in objects and methods has
been clarified by making it explicit that the intent is that the actual
built-in object is to be used rather than the current dynamically
resolved value of the correspondingly identifier binding.

11.8.1: ECMAScript generally uses a left to right evaluation order,
however the Edition 3 specification language for the > and <= operators
resulted in a partial right to left order. The specification has been
corrected for these operators such that it now specifies a full left to
right evaluation order. However, this change of order is potentially
observable if side-effects occur during the evaluation process.

11.1.4: Edition 5 clarifies the fact that a trailing comma at the end of
an ArrayInitialiser does not add to the length of the array. This is
not a semantic change from Edition 3 but some implementations may have
previously misinterpreted this.

11.2.3: Edition 5 reverses the order of steps 2 and 3 of the algorithm.
The original order as specified in Editions 1 through 3 was incorrectly
specified such that side-effects of evaluating Arguments could affect
the result of evaluating MemberExpression.

12.4: In Edition 3, an object is created, as if by NEW OBJECT()to serve
as the scope for resolving the name of the exception parameter passed to
a CATCH clause of a TRY statement. If the actual exception object is a
function and it is called from within the CATCH clause, the scope object
will be passed as the THIS value of the call. The body of the function
can then define new properties on its THIS value and those property
names become visible identifiers bindings within the scope of the CATCH
clause after the function returns. In Edition 5, when an exception
parameter is called as a function, UNDEFINED is passed as the THIS
value.

13: In Edition 3, the algorithm for the production FunctionExpression
with an Identifier adds an object created as if by NEW OBJECT() to the
scope chain to serve as a scope for looking up the name of the function.
The identifier resolution rules (10.1.4 in Edition 3) when applied to
such an object will, if necessary, follow the object’s prototype chain
when attempting to resolve an identifier. This means all the properties
of Object.prototype are visible as identifiers within that scope. In
practice most implementations of Edition 3 have not implemented this
semantics. Edition 5 changes the specified semantics by using a
Declarative Environment Record to bind the name of the function.

14: In Edition 3, the algorithm for the production SourceElements :
_SourceElements SourceElement_ did not correctly propagate statement
result values in the same manner as Block. This could result in the
EVAL function producing an incorrect result when evaluating a Program
text. In practice most implementations of Edition 3 have implemented the
correct propagation rather than what was specified in Edition 5.

15.10.6: RegExp.prototype is now a RegExp object rather than an instance
of Object. The value of its [[Class]] internal data property which is
observable using Object.prototype.toString is now “RegExp” rather than
“Object”.

(informative)
Additions and Changes that
Introduce Incompatibilities with Prior Editions


In the 6^th^ Edition

11.2.3: In Edition 6, Function calls are not allowed to return a
Reference value.

12.6: In Edition 6, a terminating semi-colon is no longer required at
the end of a do-while statement.

12.6: Prior to Edition 6, an initialisation expression could appear as
part of the VariableDeclaration that precedes the IN keyword. The
value of that expression was always discarded. In Edition 6, the
ForBind in that same position does not allow the occurance of such an
initialiser.

12.14: In Edition 6, it is an early error for a Catch clause to
contained a VAR declaration for the same Identifier that appears as
the Catch clause parameter. In previous editions, such a variable
declaration would be instantiated in the enclosing variable environment
but the declaration’s Initialiser value would be assigned to the
Catch parameter.

13.3 In Edition 6, the function objects that are created as the values
of the [[Get]] or [[Set]] attribute of accessor properties in an
ObjectLiteral are not constructor functions. In Edition 5, they were
constructors.

15.2.3.2: In Edition 6, if the argument to OBJECT.GETPROTOTYPEOF is not
an object an attempt is make to coerce the argument using ToObject. If
the coerecion is successful the result is used in place of the original
argument value. In Edition 5, a non-object argument always causes a
TYPEERROR to be thrown.

15.2.3.3: In Edition 6, if the argument to
OBJECT.GETOWNPROPERTYDESCRIPTOR is not an object an attempt is make to
coerce the argument using ToObject. If the coerecion is successful the
result is used in place of the original argument value. In Edition 5, a
non-object argument always causes a TYPEERROR to be thrown.

15.2.3.4: In Edition 6, if the argument to OBJECT.GETOWNPROPERTYNAMES is
not an object an attempt is make to coerce the argument using ToObject.
If the coerecion is successful the result is used in place of the
original argument value. In Edition 5, a non-object argument always
causes a TYPEERROR to be thrown.

15.2.3.5 and 15.2.3.7: In Edition 6, all property additions and changes
are processed, even if one of them throws an exception. If an exception
occurs during such processing, the first such exception is thrown after
all propertie are processed. In Edition 5, processing of property
additions and changes immediately terminated when the first exception
occurred.

15.2.3.8: In Edition 6, if the argument to OBJECT.SEAL is not an object
it is treated as if it was a non-extensible ordinary object with no own
properties. In Edition 5, a non-object argument always causes a
TYPEERROR to be thrown.

15.2.3.9: In Edition 6, if the argument to OBJECT.FREEZE is not an
object it is treated as if it was a non-extensible ordinary object with
no own properties. In Edition 5, a non-object argument always causes a
TYPEERROR to be thrown.

15.2.3.10: In Edition 6, if the argument to OBJECT.PREVENTEXTENSIONS is
not an object it is treated as if it was a non-extensible ordinary
object with no own properties. In Edition 5, a non-object argument
always causes a TYPEERROR to be thrown.

15.2.3.11: In Edition 6, if the argument to OBJECT.ISSEALED is not an
object it is treated as if it was a non-extensible ordinary object with
no own properties. In Edition 5, a non-object argument always causes a
TYPEERROR to be thrown.

15.2.3.12: In Edition 6, if the argument to OBJECT.ISFROZEN is not an
object it is treated as if it was a non-extensible ordinary object with
no own properties. In Edition 5, a non-object argument always causes a
TYPEERROR to be thrown.

15.2.3.13: In Edition 6, if the argument to OBJECT.ISEXTENSIBLE is not
an object it is treated as if it was a non-extensible ordinary object
with no own properties. In Edition 5, a non-object argument always
causes a TYPEERROR to be thrown.

15.2.3.14: In Edition 6, if the argument to OBJECT.KEYS is not an object
an attempt is make to coerce the argument using ToObject. If the
coerecion is successful the result is used in place of the original
argument value. In Edition 5, a non-object argument always causes a
TYPEERROR to be thrown.

15.3.4.1: In Edition 6, the LENGTH property of function instances is
configurable. In previous editions it was non-configurable.

15.5.4 In Edition 6, the Array prototype object is not a Array instance.
In previous editions it was an Array instance with a length property
whose value was +0.

15.5.4 In Edition 6, the String prototype object is not a String
instance. In previous editions it was a String instance whose String
value was the empty string.

15.6.4 In Edition 6, the Boolean prototype object is not a Boolean
instance. In previous editions it was a Boolean instance whose Boolean
value was FALSE.

15.7.4 In Edition 6, the Number prototype object is not a Number
instance. In previous editions it was a Number instance whose number
value was +0.

15.9.5 In Edition 6, the Date prototype object is not a Date instance.
In previous editions it was a Date instance whose TimeValue was NaN.

15.10.6 In Edition 6, the RegExp prototype object is not a RegExp
instance. In previous editions it was a RegExp instance whose pattern is
the empty string.

15.10.7 In Edition 6, SOURCE, GLOBAL, IGNORECASE, and MULTILINE are
accessor properties defined on the RegExp prototype object. In previous
editions they were data properties defined on RegExp instances.


In the 5^th^ Edition

7.1: Unicode format control characters are no longer stripped from
ECMAScript source text before processing. In Edition 5, if such a
character appears in a StringLiteral or RegularExpressionLiteral the
character will be incorporated into the literal where in Edition 3 the
character would not be incorporated into the literal.

7.2: Unicode character <BOM> is now treated as whitespace and its
presence in the middle of what appears to be an identifier could result
in a syntax error which would not have occurred in Edition 3

7.3: Line terminator characters that are preceded by an escape sequence
are now allowed within a string literal token. In Edition 3 a syntax
error would have been produced.

7.8.5: Regular expression literals now return a unique object each time
the literal is evaluated. This change is detectable by any programs that
test the object identity of such literal values or that are sensitive to
the shared side effects.

7.8.5: Edition 5 requires early reporting of any possible RegExp
constructor errors that would be produced when converting a
RegularExpressionLiteral to a RegExp object. Prior to Edition 5
implementations were permitted to defer the reporting of such errors
until the actual execution time creation of the object.

7.8.5: In Edition 5 unescaped “/” characters may appear as a
CharacterClass in a regular expression literal. In Edition 3 such a
character would have been interpreted as the final character of the
literal.

10.4.2: In Edition 5, indirect calls to the EVAL function use the global
environment as both the variable environment and lexical environment for
the eval code. In Edition 3, the variable and lexical environments of
the caller of an indirect EVAL was used as the environments for the eval
code.

15.4.3: In Edition 5 all methods of ARRAY.PROTOTYPE are intentionally
generic. In Edition 3 TOSTRING and TOLOCALESTRING were not generic and
would throw a TYPEERROR exception if applied to objects that were not
instances of Array.

10.6: In Edition 5 the array indexed properties of argument objects that
correspond to actual formal parameters are enumerable. In Edition 3,
such properties were not enumerable.

10.6: In Edition 5 the value of the [[Class]] internal data property of
an arguments object is "ARGUMENTS". In Edition 3, it was "OBJECT". This
is observable if TOSTRING is called as a method of an arguments object.

12.6.4: for-in statements no longer throw a TYPEERROR if the IN
expression evaluates to NULL or UNDEFINED. Instead, the statement
behaves as if the value of the expression was an object with no
enumerable properties.

15: In Edition 5, the following new properties are defined on built-in
objects that exist in Edition 3: OBJECT.GETPROTOTYPEOF,
OBJECT.GETOWNPROPERTYDESCRIPTOR, OBJECT.GETOWNPROPERTYNAMES,
OBJECT.CREATE, OBJECT.DEFINEPROPERTY, OBJECT.DEFINEPROPERTIES,
OBJECT.SEAL, OBJECT.FREEZE, OBJECT.PREVENTEXTENSIONS, OBJECT.ISSEALED,
OBJECT.ISFROZEN, OBJECT.ISEXTENSIBLE, OBJECT.KEYS,
FUNCTION.PROTOTYPE.BIND, ARRAY.PROTOTYPE.INDEXOF,
ARRAY.PROTOTYPE.LASTINDEXOF, ARRAY.PROTOTYPE.EVERY,
ARRAY.PROTOTYPE.SOME, ARRAY.PROTOTYPE.FOREACH, ARRAY.PROTOTYPE.MAP,
ARRAY.PROTOTYPE.FILTER, ARRAY.PROTOTYPE.REDUCE,
ARRAY.PROTOTYPE.REDUCERIGHT, STRING.PROTOTYPE.TRIM, DATE.NOW,
DATE.PROTOTYPE.TOISOSTRING, DATE.PROTOTYPE.TOJSON.

15: Implementations are now required to ignore extra arguments to
standard built-in methods unless otherwise explicitly specified. In
Edition 3 the handling of extra arguments was unspecified and
implementations were explicitly allowed to throw a TYPEERROR exception.

15.1.1: The value properties NAN, INFINITY, and UNDEFINED of the Global
Object have been changed to be read-only properties.

15.1.2.1. Implementations are no longer permitted to restrict the use of
eval in ways that are not a direct call. In addition, any invocation of
eval that is not a direct call uses the global environment as its
variable environment rather than the caller’s variable environment.

15.1.2.2: The specification of the function PARSEINT no longer allows
implementations to treat Strings beginning with a 0 character as octal
values.

15.3.3.3: In Edition 3, a TYPEERROR is thrown if the second argument
passed to FUNCTION.PROTOTYPE.APPLY is neither an array object nor an
arguments object. In Edition 5, the second argument may be any kind of
generic array-like object that has a valid LENGTH property.

15.3.3.3, 15.3.3.4: In Edition 3 passing UNDEFINED or NULL as the first
argument to either FUNCTION.PROTOTYPE.APPLY or FUNCTION.PROTOTYPE.CALL
causes the global object to be passed to the indirectly invoked target
function as the THIS value. If the first argument is a primitive value
the result of calling ToObject on the primitive value is passed as the
THIS value. In Edition 5, these transformations are not performed and
the actual first argument value is passed as the THIS value. This
difference will normally be unobservable to existing ECMAScript Edition
3 code because a corresponding transformation takes place upon
activation of the target function. However, depending upon the
implementation, this difference may be observable by host object
functions called using APPLY or CALL. In addition, invoking a standard
built-in function in this manner with NULL or UNDEFINED passed as the
THIS value will in many cases cause behaviour in Edition 5
implementations that differ from Edition 3 behaviour. In particular, in
Edition 5 built-in functions that are specified to actually use the
passed THIS value as an object typically throw a TYPEERROR exception if
passed NULL or UNDEFINED as the THIS value.

15.3.4.2: In Edition 5, the PROTOTYPE property of Function instances is
not enumerable. In Edition 3, this property was enumerable.

15.5.5.2: In Edition 5, the individual characters of a String object’s
[[StringData]] may be accessed as array indexed properties of the String
object. These properties are non-writable and non-configurable and
shadow any inherited properties with the same names. In Edition 3, these
properties did not exist and ECMAScript code could dynamically add and
remove writable properties with such names and could access inherited
properties with such names.

15.9.4.2: DATE.PARSE is now required to first attempt to parse its
argument as an ISO format string. Programs that use this format but
depended upon implementation specific behaviour (including failure) may
behave differently.

15.10.2.12: In Edition 5, \S now additionally matches <BOM>.

15.10.4.1: In Edition 3, the exact form of the String value of the
SOURCE property of an object created by the REGEXP constructor is
implementation defined. In Edition 5, the String must conform to certain
specified requirements and hence may be different from that produced by
an Edition 3 implementation.

15.10.6.4: In Edition 3, the result of REGEXP.PROTOTYPE.TOSTRING need
not be derived from the value of the RegExp object’s SOURCE property. In
Edition 5 the result must be derived from the SOURCE property in a
specified manner and hence may be different from the result produced by
an Edition 3 implementation.

15.11.2.1, 15.11.4.3: In Edition 5, if an initial value for the MESSAGE
property of an Error object is not specified via the ERROR constructor
the initial value of the property is the empty String. In Edition 3,
such an initial value is implementation defined.

15.11.4.4: In Edition 3, the result of ERROR.PROTOTYPE.TOSTRING is
implementation defined. In Edition 5, the result is fully specified and
hence may differ from some Edition 3 implementations.

15.12: In Edition 5, the name JSON is defined in the global environment.
In Edition 3, testing for the presence of that name will show it to be
UNDEFINED unless it is defined by the program or implementation.

(informative)
Static Semantic Rule Cross Reference

  ROUTINE NAME                 PURPOSE                                                                                                                                                                                            DEFINITIONS                                                     USES
  ---------------------------- -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- --------------------------------------------------------------- ------
  BoundNames                   Produces a list of the Identifiers bound by a production. Does not include Identifiers that are bound within inner environments associated with the production.                                    12.2.1, 12.2.2, 12.2.4, 12.6.4, 13.1, 13.2, 13.5                
  ConstructorMethod            From a ClassBody return the first ClassElement whose PropName is ″CONSTRUCTOR″. Returns empty if the ClassBody does not contain one.                                                         13.5                                                            
  Contains                     Determine if a grammar production either directly or indirectly includes a grammar symbol.                                                                                                         5.3, 13.1, 13.2, 13.5                                           
  CoveredFormalsList           Reparse a covered Expression using FormalsList as the goal symbol.                                                                                                                             13.2                                                            
  CV                           Determines the “character value” of a component of a StringLiteral.                                                                                                                              7.8.4                                                           
  Elision Width                Determine the number of commas in an Elision.                                                                                                                                                    11.1.4.1                                                        
  ExpectedArgumentCount        Determine the “length” of an argument list for the purpose of initializing the “length” property of a function object.                                                                             13.1, 13.2, 13.3                                                
  HasInitialiser               Determines whether the production contains an Initialiser production.                                                                                                                            12.2.4, 13.1                                                    
  IsConstantDeclaration        Determines whether the production introduces a immutable environment record binding                                                                                                                12.2, 13.1, 13.5                                                
  IsInvalidAssignmentPattern   Determines if a LeftHandSideExpression is a valid assignment target. Primarily for dealing with destructuring assignment targets.                                                                11.2                                                            
  LexicalDeclarations          Return a List containing the components of a production that are processed as lexical declarations                                                                                                 12.1, 12.11, 12.5                                               
  LexicallyDeclaredNames       Returns a list of the lexically scoped identifiers declared by a production.                                                                                                                       12.1, 13.1, 13.2, 13.5                                          
  PrototypeMethodDefinitions   Return a list of the non-static MethodDefinition productions that are part of a ClassElementList.                                                                                              13.5                                                            
  MV                           Determines the “mathematical value” of a numeric lirteral or component of a numeric literal.                                                                                                       7.8.3                                                           
  PropName                     Determines the string value of the property name referenced by a production.                                                                                                                       11.1.5.1, 13.3, 13.5                                            
  PropNameList                 Returns a List of the string values of the property names referenced by a production. The list reflects the order of the references in the source text. The list may contain duplicate elements.   11.5.1, 13.5                                                    
  PrototypeMethodDefinitions   Return a list of the non-static MethodDefinition productions that are part of a ClassElementList.                                                                                              13.5                                                            
  ReferencesSuper              Determine if a MethodDefinition contains any references to the ReservedWord SUPER.                                                                                                             13.3                                                            
  SpecialMethod                Determine if a MethodDefinition defines a generator method or an accessor property.                                                                                                              13.3                                                            
  StaticMethodDefinitions      Return a list of the static MethodDefinition productions that are part of a ClassElementList.                                                                                                  13.5                                                            
  SV                           Determines the “string value” of a StringLiteral or component of a StringLiteral.                                                                                                              7.8.4                                                           
                                                                                                                                                                                                                                                                                                  
  VarDeclaredNames             Returns a list of the local top-level scoped identifiers declared by a production. These are identifier that are scoped as if by a var statement.                                                  12.1, 12.5, 12.6.1, 12.6.2, 12.6.3, 12.6.4, 12.12, 13.1, 13.5   

A place to temporarily hand on to stuff that’s been deleted

MemberExpression :

MemberExpression <| TriangleLiteral

TriangleLiteral :

SealedArrayLiteral
SealedObjectLiteral
FunctionExpression
ArrowFunction
ValueLiteral

CallExpression :

CallExpression <| TriangleLiteral

15.2.3.15 Object.isObject ( O )

When the ISOBJECT function is called with argument O, the following
steps are taken:

1.  If Type(O) is Object return TRUE.

2.  Return FALSE.

15.5.4.25 STRING.PROTOTYPE.TOARRAY()

The following steps are taken:

1.  Let O be CheckObjectCoercible(THIS value).

2.  Let S be ToString(O).

3.  ReturnIfAbrupt(S).

4.  Let len be the number of characters in S.

5.  Let array be the result of the abstract operation ArrayCreate with
    argument len.

6.  Let n be 0

7.  Repeat, while n < len:

    a.  Let c be the character at position n in S.

    b.  Call the [[DefineOwnProperty]] internal method of array with
        arguments ToString(n), the PropertyDescriptor {[[Value]]: c,
        [[Writable]]: TRUE, [[Enumerable]]: TRUE, [[Configurable]]:
        TRUE}, and FALSE.

    c.  Increment n by 1.

8.  Return array.

The LENGTH property of the TOARRAY method is 0.

NOTE 1 Returns an Array object with elements corresponding to the
characters of this object (converted to a String).

NOTE 2 The TOARRAY function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

STATIC SEMANTICS: TOPLEVELLEXICALLYDECLAREDNAMES

OuterStatementList : _OuterStatementList OuterItem_

1.  Let names be TopLevelLexicallyDeclaredNames of
    OuterStatementList.

2.  Append to names the elements of the TopLevelLexicallyDeclaredNames
    of OuterItem.

3.  Return names.

OuterItem : StatementListItem

1.  Return a new empty List.

StatementListItem : Declaration

1.  If Declaration is Declaration : FunctionDeclaration, then
    return a new empty List.

2.  Return the BoundNames of Declaration.

Preliminary work on Irrefutable Destructuring Binding Patterns

Syntax

BindingPattern :

Irrefutable~opt~ ObjectBindingPattern
Irrefutable~opt~ ArrayBindingPattern

Irrefutable :

?

ObjectBindingPattern :

{ }
{ BindingPropertyList }
{ BindingPropertyList , }

ArrayBindingPattern :

[ Elision~opt~ BindingRestElement~opt~ ]
[ BindingElementList ]
[ BindingElementList , Elision~opt~ BindingRestElement~opt~ ]

BindingPropertyList :

Irrefutable~opt~ BindingProperty
BindingPropertyList , Irrefutable~opt~ BindingProperty

BindingElementList :

Elision~opt~ BindingElement
BindingElementList , Elision~opt~ BindingElement

BindingProperty :

SingleNameBinding ~
~ PropertyName : BindingElement

BindingElement :

SingleNameBinding
BindingPattern Initialiser~opt~

SingleNameBinding :

BindingIdentifier Initialiser~opt~

BindingRestElement :

... BindingIdentifier

Static Semantics

STATIC SEMANTICS: EARLY ERRORS

BindingPattern : Irrefutable~opt~ ObjectBindingPattern

-   It is a Syntax Error if the BoundNames of ObjectBindingPattern
    contains the string “EVAL” or the string “ARGUMENTS”.

BindingPattern : Irrefutable~opt~ ArrayBindingPattern

-   It is a Syntax Error if the BoundNames of ArrayBindingPattern
    contains the string “EVAL” or the string “ARGUMENTS”.

STATIC SEMANTICS: BOUNDNAMES

BindingPattern : Irrefutable~opt~ ObjectBindingPattern

1.  Return the BoundNames of ObjectBindingPattern.

BindingPattern : Irrefutable~opt~ ArrayBindingPattern

1.  Return the BoundNames of ArrayBindingPattern.

ObjectBindingPattern : { }

1.  Return an empty List.

ArrayBindingPattern : [ Elision~opt~ ]

1.  Return an empty List.

ArrayBindingPattern : [ Elision~opt~ BindingRestElement ]

1.  Return the BoundNames of BindingRestElement.

ArrayBindingPattern : [ BindingElementList , Elision~opt~ ]

1.  Return the BoundNames of BindingElementList.

ArrayBindingPattern : [ BindingElementList , Elision~opt~
BindingRestElement ]

1.  Let names be BoundNames of BindingElementList.

2.  Append to names the elements of BoundNames of
    BindingRestElement.

3.  Return names.

BindingPropertyList : Irrefutable~opt~ BindingProperty

1.  Return the BoundNames of BindingProperty.

BindingPropertyList : BindingPropertyList , Irrefutable~opt~
BindingProperty

1.  Let names be BoundNames of BindingPropertyList.

2.  Append to names the elements of BoundNames of BindingProperty.

3.  Return names.

BindingElementList : Elision~opt~ BindingElement

1.  Return BoundNames of BindingElement.

BindingElementList : BindingElementList , Elision~opt~
BindingElement

1.  Let names be BoundNames of BindingElementList.

2.  Append to names the elements of BoundNames of BindingElement.

3.  Return names.

BindingProperty : PropertyName : _BindingElement _

1.  Return the BoundNames of BindingElement.

SingleNameBinding : _BindingIdentifier Initialiser_~opt~

1.  Return the BoundNames of BindingIdentifier.

BindingElement : _BindingPattern Initialiser_~opt~

1.  Return the BoundNames of BindingPattern.

1.  

1.  2.  

1.  2.  

1.  2.  

1.  

1.  

1.  

1.  

1.  2.  a.  b.  c.  

3.  

1.  

1.  2.  

1.  

1.  

8.3.10 [[Enumerate]] (includePrototype, onlyEnumerable )

When the [[Enumerate]] internal method of O is called with Boolean
arguments includePrototype and onlyEnumerable, the following steps
are taken:

1.  Return an Iterator object (reference xxxx) whose next method
    iterates over all the keys of enumerable property keys of O. If
    includePrototype is FALSE, then only own properties of O are
    included. If onlyEnumerable is FALSE, then all properties that do
    not have private name keys are included. The mechanics and order of
    enumerating the properties is not specified but must conform to the
    rules specified below.

Enumerated properties do not include properties whose property key is a
private name. Properties of the object being enumerated may be deleted
during enumeration. If a property that has not yet been visited during
enumeration is deleted, then it will not be visited. If new properties
are added to the object being enumerated during enumeration, the newly
added properties are not guaranteed to be visited in the active
enumeration. A property name must not be visited more than once in any
enumeration.

Enumerating the properties of an object includes enumerating properties
of its prototype, and the prototype of the prototype, and so on,
recursively; but a property of a prototype is not enumerated if it is
“shadowed” because some previous object in the prototype chain has a
property with the same name. The values of [[Enumerable]] attributes are
not considered when determining if a property of a prototype object is
shadowed by a previous object on the prototype chain.

The following is an informative algorithm that conforms to these rules

1.  Let obj be O.

2.  Let proto be the value of the [[Prototype]] internal data property
    of O.

3.  If includePrototype is FALSE or proto is the value NULL, then

    a.  Let propList be a new empty List.

4.  Else

    a.  Let propList be the result of calling the [[Enumerate]]
        internal method of proto with arguments TRUE and
        onlyEnumerable.

5.  For each string name that is the property key of an own property
    of O

    a.  Let desc be the result of calling the [[GetOwnProperty]]
        internal method of O with argument name.

    b.  If name is an element of propList, then remove name as an
        element of propList.

    c.  If onlyEnumerable is FALSE or desc.[[Enumerable]] is TRUE,
        then add name as an element of propList.

6.  Order the elements of propList in an implementation defined order.

7.  Return propList.

_This follow version places function body declarations in_ _scope of
parameter initialisers_

9.1.11 ToPositiveInteger

The abstract operation ToInteger converts its argument to an integral
numeric value. This abstract operation functions as follows:

1.  Let number be the result of calling ToNumber on the input
    argument.

2.  ReturnIfAbrupt(number).

3.  If number is NAN, return +0.

4.  If number is +∞, or −∞, return number.

5.  If number ≤ 0, return +0.

6.  Return the result of computing floor(number).

10.5.3 Function Declaration Instantiation

NOTE When an execution context is established for evaluating function
code a new Declarative Environment Record is created and bindings for
each formal parameter, and each function level variable, constant, or
function declarated in the function are instantiated in the environment
record. Formal parameters and functions are initialised as part of this
process. All other bindings are initialised during execution of the
function code.

Function Declaration Instantiation is performed as follows using
arguments _func, argumentsList_, and env. func is the function
object that for which the execution context is being established. env
is the declarative environment record in which bindings are to be
created.

1.  Let code be the value of the [[Code]] internal property of func.

2.  Let strict be the value of the [[Strict]] internal property of
    func.

3.  Let formals be the value of the [[FormalParameterList]] internal
    property of func.

4.  Let parameterNames be the BoundNames of formals.

5.  Let varDeclarations be the VarScopedDeclarations of code.

6.  Let functionsToInitialise be an empty List.

7.  Let argumentsObjectNotNeeded be FALSE.

8.  For each d in varDeclarations, in reverse list order do

    a.  If d is a FunctionDeclaration then

        i.  NOTE If there are multiple FunctionDeclarations for the
            same name, the last declaration is used.

        ii. Let fn be the sole element of the BoundNames of d.

        iii. If fn is "ARGUMENTS", then let argumentsObjectNotNeeded
            be TRUE.

        iv. Let alreadyDeclared be the result of calling env’s
            HasBinding concrete method passing fn as the argument.

        v.  If alreadyDeclared is FALSE, then

            1.  Let status be the result of calling env’s
                CreateMutableBinding concrete method passing fn as the
                argument.

            2.  Assert: status is never an abrupt completion.

            3.  Append d to functionsToInitialise.

9.  For each String paramName in parameterNames, do

    a.  Let alreadyDeclared be the result of calling env’s
        HasBinding concrete method passing paramName as the argument.

    b.  NOTE Duplicate parameter names can only occur in non-strict
        functions. Parameter names that are the same as function
        declaration names do not get initialised to UNDEFINED.

    c.  If alreadyDeclared is FALSE, then

        i.  If paramName is "ARGUMENTS", then let
            argumentsObjectNotNeeded be TRUE.

        ii. Let status be the result of calling env’s
            CreateMutableBinding concrete method passing paramName as
            the argument.

        iii. Assert: status is never an abrupt completion

        iv. Call env’s InitialiseBinding concrete method passing
            paramName, and UNDEFINED as the arguments.

10. NOTE If there is a function declaration or formal parameter with the
    name "ARGUMENTS" then an argument object is not created.

11. If argumentsObjectNotNeeded is FALSE, then

    a.  If strict is TRUE, then

        i.  Call env’s CreateImmutableBinding concrete method passing
            the String "ARGUMENTS" as the argument.

    b.  Else,

        i.  Call env’s CreateMutableBinding concrete method passing
            the String "ARGUMENTS" as the argument.

12. Let varNames be the VarDeclaredNames of code.

13. For each String varName in varNames, in list order do

    a.  Let alreadyDeclared be the result of calling env’s
        HasBinding concrete method passing varName as the argument.

    b.  NOTE A VarDeclaredNames is only instantiated and initialied here
        if it is not also the name of a formal parameter or a
        FunctionDeclarations.

    c.  If alreadyDeclared is FALSE, then

        i.  Call env’s CreateMutableBinding concrete method passing
            varName as the argument.

14. Let lexDeclarations be the LexicalDeclarations of code.

15. For each element d in lexDeclarations do

    a.  NOTE A lexically declared name cannot be the same as a function
        declaration, formal parameter, or a var name. Lexically
        declarated names are only instantiated here but not initialised.

    b.  For each element dn of the BoundNames of d do

        i.  If IsConstantDeclaration of d is TRUE, then

            1.  Call env’s CreateImmutableBinding concrete method
                passing dn as the argument.

        ii. Else,

            1.  Call env’s CreateMutableBinding concrete method
                passing dn and FALSE as the arguments.

16. For each FunctionDeclaration f in functionsToInitialise, do

    a.  Let fn be the sole element of the BoundNames of f.

    b.  Let fo be the result of performing InstantiateFunctionObject
        for f with argument env.

    c.  Call env’s SetMutableMinding concrete method passing fn,
        fo, and FALSE as the arguments.

17. NOTE Function declaration are initialised prior to parameter
    initialisation so that default value expressions may reference them.
    it is not extended code. "ARGUMENTS" is not initialised until after
    parameter initialization.

18. Let ao be the result of InstantiateArgumentsObject with argument
    argumentsList.

19. NOTE If argumentsObjectNotNeeded is TRUE then the value of ao is
    not directly observable to ECMAScript code and need not actually
    exist. In that case, its use in the above steps is strictly as a
    device for specifying formal parameter initialisation semantics.

20. If argumentsObjectNotNeeded is FALSE, then

    a.  If strict is TRUE, then

        i.  Perform the abstract operation CompleteStrictArgumentsObject
            with argument a0.

    b.  Else,

        i.  Perform the abstract operation CompleteMappedArgumentsObject
            with arguments _a0, func_, formals, and env.

    c.  Call env’s InitialiseBinding concrete method passing
        "ARGUMENTS" and ao as arguments.

21. Let formalStatus be the result of performing Binding
    Initialisation for formals with ao and UNDEFINED as arguments.

22. ReturnIfAbrupt(formalStatus).

23. Return NormalCompletion(empty).

The _proto_ pseudo property.

Object.prototype._proto_

The initial value of the _PROTO_ property of the Object prototype
object is a data property whose initial value is NULL. This property
initially has the attributes { [[Writable]]: TRUE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Manipulations of this property as tracked by the Boolean valued
primordial internal variable UnderscoreProtoEnabled. The default initial
value of UnderscoreProtoEnabled is TRUE only if this property is
initially present on the primordial Object prototype object.

NOTE Any modification of this property or its attributes causes
UnderscoreProtoEnabled to be set to FALSE.

 Changes To Internal Methods

The definition of the [[Get]] internal method given in 8.12.3 is
replaced with the following:

1.  If P is the string value "_PROTO_" and UnderscoreProtoEnabled is
    TRUE, then

    a.  Let desc be the result of calling the [[GetProperty]] internal
        method of O with property name P.

    b.  If desc is not UNDEFINED and was created by step 1.a to
        describe the property defined in B.3.1.1 then,

        i.  Return the value of the [[Prototype]] internal data property
            of O.

2.  Continue by executing the steps of 8.12.3 starting with step 1.

The definition of the [[Put]] internal method given in 8.12.5 is
replaced with the following:

1.  If P is the string value "_PROTO_" and UnderscoreProtoEnabled is
    TRUE and O is not the standard built-in Object prototype object,
    then

    a.  Let desc be the result of calling the [[GetProperty]] internal
        method of O with property name P.

    b.  If desc is not UNDEFINED and was created by step 1.a to
        describe the property defined in B.3.1.1 then,

        i.  If the type of V is neither Object or Null, return

        ii. Set the value of the [[Prototype]] internal data property of
            O to V.

        iii. Return.

2.  Continue by executing the steps of 8.12.5 starting with step 1.

The definition of the [[Delete]] internal method given in 8.12.7 is
replaced with the following:

1.  If UnderscoreProtoEnabled is TRUE and P is the string value
    "_PROTO_" and O is the standard built-in Object prototype
    object, then

    a.  Set UnderscoreProtoEnabled to FALSE.

2.  Continue by executing the steps of 8.12.7 starting with step 1.

The definition of the [[DefineOwnProperty]] internal method given in
8.12.9 is replaced with the following:

1.  If UnderscoreProtoEnabled is TRUE and P is the string value
    "_PROTO_" and O is the standard built-in Object prototype
    object, then

    a.  If any attribute contained in Desc is not present or has a
        different value from the corresponding attribute in {
        [[Writable]]: TRUE, [[Enumerable]]: TRUE, [[Configurable]]: TRUE
        }then,

        i.  Set UnderscoreProtoEnabled to FALSE.

2.  Continue by executing the steps of 8.12.9 starting with step 1.

_15.18.1.14 Reflect.freeze (target)

When the FREEZE function is called with argument target the following
steps are taken:

1.  Let obj be ToObject(target).

2.  ReturnIfAbrupt(obj).

3.  Return the result of calling the [[Freeze]] internal method of
    obj.

15.18.1.15 Reflect.seal (target)

When the SEAL function is called with argument target the following
steps are taken:

1.  Let obj be ToObject(target).

2.  ReturnIfAbrupt(obj).

3.  Return the result of calling the [[Seal]] internal method of obj.

15.18.1.16 Reflect.isFrozen (target)

When the ISFROZEN function is called with argument target the
following steps are taken:

1.  Let obj be ToObject(target).

2.  ReturnIfAbrupt(obj).

3.  Return the result of calling the [[IsFrozen]] internal method of
    obj.

15.18.1.17 Reflect.isSealed (target)

When the ISSEALED function is called with argument target the
following steps are taken:

1.  Let obj be ToObject(target).

2.  ReturnIfAbrupt(obj).

3.  Return the result of calling the [[IsSealed]] internal method of
    obj.

proto__ Object Initialisers _

Definitions of two algorithms in 11.1.5 are replaced with the following:

The production PropertyDefinitionList : PropertyDefinition is
evaluated as follows:

1.  Let obj be the result of the abstract operation ObjectCreate with
    the intrinsic object %ObjectPrototype% as its argument.

2.  Let propId be the result of evaluating PropertyDefinition.

3.  If propId.name is the string value "_PROTO_" and
    UnderscoreProtoEnabled is TRUE and
    IsDataDescriptor(propId.descriptor) is TRUE, then

    a.  Let v be propId.descriptor.value.

    b.  If _desc be propId_.descriptor

    c.  If the type of v is either Object or Null,

        i.  Set the value of the [[Prototype]] internal data property of
            obj to v.

    d.  Return obj.

4.  Call the [[DefineOwnProperty]] internal method of obj with
    arguments propId.name, propId.descriptor, and FALSE.

5.  Return obj.

The production
 PropertyDefinitionList : PropertyDefinitionList ,
PropertyDefinition
is evaluated as follows:

6.  Call the [[DefineOwnProperty]] internal method of obj with
    arguments propId.name, propId.descriptor, and FALSE.

7.  Return obj.

Table 40 — Internal Properties Only Defined for Some Objects

  _INTERNAL PROPERTY_       _VALUE TYPE DOMAIN_                           DESCRIPTION
  ------------------------- --------------------------------------------- ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  [[BuiltinBrand]]          The BuiltinBrand enumeration.                 A tag value used by this specification to categorize various kinds of ECMAScript objects defined in this specification.
  [[PrimitiveValue]]        primitive                                   Internal state information associated with this object. Of the standard built-in ECMAScript objects, only Boolean, Date, Number, and String objects implement [[PrimitiveValue]].
  [[Scope]]                 Lexical Environment                           A lexical environment that is the environment in which a Function object is executed. Of the standard built-in ECMAScript objects, only Function objects implement [[Scope]].
  [[FormalParameters]]      Parse Tree                                    A parse tree for ECMAScript code parsed with FormalParameters as the goal symbol. Of the standard built-in ECMAScript objects, only Function objects implement [[FormalParameters]].
  [[Code]]                  Parse Tree                                    A parse tree for ECMAScript code parsed with FunctionBody as the goal symbol. Of the standard built-in ECMAScript objects, only Function objects implement [[Code]].
  [[Strict]]                Boolean                                       TRUE if a Function object is a strict mode function. Of the standard built-in ECMAScript objects, only Function objects implement [[Strict]].
  [[BoundTargetFunction]]   Object                                        The target function of a function object created using the standard built-in Function.prototype.bind method. Only ECMAScript objects created using Function.prototype.bind have a [[BoundTargetFunction]] internal property.
  [[BoundThis]]             any                                         The pre-bound this value of a function Object created using the standard built-in Function.prototype.bind method. Only ECMAScript objects created using Function.prototype.bind have a [[BoundThis]] internal property.
  [[BoundArguments]]        List of any                                 The pre-bound argument values of a function Object created by the standard built-in Function.prototype.bind method. Only objects created by Function.prototype.bind have a [[BoundArguments]] internal property.
  [[RegExpMatcher]]         SpecOp(String, index) → MatchResult   Tests for a regular expression match and returns a MatchResult value (see 15.10.2.1). Of the standard built-in ECMAScript objects, only RegExp objects implement [[RegExpMatch]].
  [[ParameterMap]]          Object                                        Provides a mapping between the properties of an arguments object (see 10.6) and the formal parameters of the associated function. Only objects that are arguments objects have a [[ParameterMap]] internal property.

Bibliography

IEEE Std 754-2008: IEEE Standard for Floating-Point Arithmetic.
Institute of Electrical and Electronic Engineers, New York (2008)

The Unicode Consortium. The Unicode Standard, Version 3.0, defined by:
The Unicode Standard, Version 3.0 (Reading, MA, Addison-Wesley, 2000.
ISBN 0-201-61633-5)

ISO 8601:2004(E) _Data elements and interchange formats – Information
interchange -- Representation of dates and times_

RFC 1738 “Uniform Resource Locators (URL)”, available at
<http://tools.ietf.org/html/rfc1738>

RFC 2396 “Uniform Resource Identifiers (URI): Generic Syntax”, available
at <http://tools.ietf.org/html/rfc2396>

RFC 3629 “UTF-8, a transformation format of ISO 10646”, available at
<http://tools.ietf.org/html/rfc3629>

RFC 4627 “The application/json Media Type for JavaScript Object Notation
(JSON)” , available at <http://tools.ietf.org/html/rfc4627>

Unicode Inc. (2010), Unicode Technical Report #15: “Unicode
Normalization Forms”, available at
<http://www.unicode.org/reports/tr15/tr15-29.html>

[1] Note: Please note that for ECMAScript Edition 4 the Ecma standard
number “ECMA-262 Edition 4” was reserved but not used in the Ecma
publication process. Therefore “ECMA-262 Edition 4” as an Ecma
International publication does not exist.
