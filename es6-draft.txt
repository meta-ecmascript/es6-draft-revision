Contents Page

Introduction vii

_1_ _Scope_ 

_2_ _Conformance_ 

_3_ _Normative references_ 

_4_ _Overview_ 

_4.1_ _Web Scripting_ 

_4.2_ _ECMAScript Overview_ 

_4.2.1_ _Objects_ 

_4.2.2_ _The Strict Variant of ECMAScript_ 

_4.3_ _Terms and definitions_ 

_4.4_ _Organization of This Specification_ 

_5_ _Notational Conventions_ 

_5.1_ _Syntactic and Lexical Grammars_ 

_5.1.1_ _Context-Free Grammars_ 

_5.1.2_ _The Lexical and RegExp Grammars_ 

_5.1.3_ _The Numeric String Grammar_ 

_5.1.4_ _The Syntactic Grammar_ 

_5.1.5_ _Grammar Notation_ 

_5.2_ _Algorithm Conventions_ 

_5.3_ _Static Semantic Rules_ 

_6_ _ECMAScript Data Types and Values_ 

_6.1_ _ECMAScript Language Types_ 

_6.1.1_ _The Undefined Type_ 

_6.1.2_ _The Null Type_ 

_6.1.3_ _The Boolean Type_ 

_6.1.4_ _The String Type_ 

_6.1.5_ _The Symbol Type_ 

_6.1.6_ _The Number Type_ 

_6.1.7_ _The Object Type_ 

_6.2_ _ECMAScript Specification Types_ 

_6.2.1_ _The List and Record Specification Type_ 

_6.2.2_ _The Completion Record Specification Type_ 

_6.2.3_ _The Reference Specification Type_ 

_6.2.4_ _The Property Descriptor Specification Type_ 

_6.2.5_ _The Lexical Environment and Environment Record Specification
Types_ 39

_6.2.6_ _Data Blocks_ 

_7_ _Abstract Operations_ 

_7.1_ _Type Conversion and Testing_ 

_7.1.1_ _ToPrimitive ( input [, PreferredType] )_ 

_7.1.2_ _ToBoolean ( argument )_ 

_7.1.3_ _ToNumber ( argument )_ 

_7.1.4_ _ToInteger ( argument )_ 

_7.1.5_ _ToInt32 ( argument ) — Signed 32 Bit Integer_ 

_7.1.6_ _ToUint32 ( argument ) — Unsigned 32 Bit Integer_ 

_7.1.7_ _ToInt16 ( argument ) — Signed 16 Bit Integer_ 

_7.1.8_ _ToUint16 ( argument ) — Unsigned 16 Bit Integer_ 

_7.1.9_ _ToInt8 ( argument ) — Signed 8 Bit Integer_ 

_7.1.10_ _ToUint8 ( argument ) — Unsigned 8 Bit Integer_ 

_7.1.11_ _ToUint8Clamp ( argument ) — Unsigned 8 Bit Integer, Clamped
4

_7.1.12_ _ToString ( argument )_ 

_7.1.13_ _ToObject ( argument )_ 

_7.1.14_ _ToPropertyKey ( argument )_ 

_7.1.15_ _ToLength ( argument )_ 

_7.1.16_ _CanonicalNumericIndexString ( argument )_ 

_7.2_ _Testing and Comparison Operations_ 

_7.2.1_ _CheckObjectCoercible ( argument )_ 

_7.2.2_ _IsCallable ( argument )_ 

_7.2.3_ _SameValue(x, y)_ 

_7.2.4_ _SameValueZero(x, y)_ 

_7.2.5_ _IsConstructor ( argument )_ 

_7.2.6_ _IsPropertyKey ( argument )_ 

_7.2.7_ _IsExtensible (O)_ 

_7.2.8_ _IsInteger ( argument )_ 

_7.2.9_ _Abstract Relational Comparison_ 

_7.2.10_ _Abstract Equality Comparison_ 

_7.2.11_ _Strict Equality Comparison_ 

_7.3_ _Operations on Objects_ 

_7.3.1_ _Get (O, P)_ 

_7.3.2_ _Put (O, P, V, Throw)_ 

_7.3.3_ _CreateDataProperty (O, P, V)_ 

_7.3.4_ _CreateDataPropertyOrThrow (O, P, V)_ 

_7.3.5_ _DefinePropertyOrThrow (O, P, desc)_ 

_7.3.6_ _DeletePropertyOrThrow (O, P)_ 

_7.3.7_ _GetMethod (O, P)_ 

_7.3.8_ _HasProperty (O, P)_ 

_7.3.9_ _HasOwnProperty (O, P)_ 

_7.3.10_ _Invoke(O,P, [args])_ 

_7.3.11_ _SetIntegrityLevel (O, level)_ 

_7.3.12_ _TestIntegrityLevel (O, level)_ 

_7.3.13_ _CreateArrayFromList (elements)_ 

_7.3.14_ _CreateListFromArrayLike (obj)_ 

_7.3.15_ _OrdinaryHasInstance (C, O)_ 

_7.3.16_ _GetPrototypeFromConstructor ( constructor,
intrinsicDefaultProto )_ 60

_7.3.17_ _CreateFromConstructor (F)_ 

_7.3.18_ _Construct (F, argumentsList)_ 

_7.3.19_ _GetOption (options, P)_ 

_7.3.20_ _EnumerableOwnNames (O)_ 

_7.3.21_ _GetFunctionRealm ( obj ) Abstract Operation_ 

_7.4_ _Operations on Iterator Objects_ 

_7.4.1_ _CheckIterable ( obj )_ 

_7.4.2_ _GetIterator ( obj, method )_ 

_7.4.3_ _IteratorNext ( iterator, value )_ 

_7.4.4_ _IteratorComplete ( iterResult )_ 

_7.4.5_ _IteratorValue ( iterResult )_ 

_7.4.6_ _IteratorStep ( iterator )_ 

_7.4.7_ _CreateIterResultObject (value, done)_ 

_7.4.8_ _CreateListIterator (list)_ 

_7.4.9_ _CreateEmptyIterator ( )_ 

_7.4.10_ _CreateCompoundIterator ( iterator1, iterator2 )_ 

_7.5_ _Operations on Promise Objects_ 

_7.5.1_ _PromiseNew ( executor ) Abstract Operation_ 

_7.5.2_ _PromiseBuiltinCapability () Abstract Operation_ 

_7.5.3_ _PromiseOf (value) Abstract Operation_ 

_7.5.4_ _PromiseAll (promiseList) Abstract Operation_ 

_7.5.5_ _PromiseCatch (promise, rejectedAction) Abstract Operation_ 

_7.5.6_ _PromiseThen (promise, resolvedAction, rejectedAction) Abstract
Operation_ 66

_8_ _Executable Code and Execution Contexts_ 

_8.1_ _Lexical Environments_ 

_8.1.1_ _Environment Records_ 

_8.1.2_ _Lexical Environment Operations_ 

_8.2_ _Code Realms_ 

_8.2.1_ _CreateRealm ( ) Abstract Operation_ 

_8.2.2_ _CreateIntrinsics ( realmRec ) Abstract Operation_ 

_8.2.3_ _SetRealmGlobalObj ( realmRec, globalObj ) Abstract Operation
8

_8.2.4_ _SetDefaultGlobalBindings ( realmRec ) Abstract Operation_ 

_8.3_ _Execution Contexts_ 

_8.3.1_ _ResolveBinding ( name ) Abstract Operation_ 

_8.3.2_ _GetThisEnvironment ( ) Abstract Operation_ 

_8.3.3_ _ResolveThisBinding ( ) Abstract Operation_ 

_8.3.4_ _GetGlobalObject ( ) Abstract Operation_ 

_8.4_ _Jobs and Job Queues_ 

_8.4.1_ _EnqueueJob ( queueName, job, arguments) Abstract Operation_ 

_8.4.2_ _NextJob result_ 

_8.5_ _Initialization_ 

_8.5.1_ _InitializeFirstRealm ( realm ) Abstract Operation_ 

_9_ _Ordinary and Exotic Objects Behaviours_ 

_9.1_ _Ordinary Object Internal Methods and Internal Slots_ 

_9.1.1_ _[[GetPrototypeOf]] ( )_ 

_9.1.2_ _[[SetPrototypeOf]] (V)_ 

_9.1.3_ _[[IsExtensible]] ( )_ 

_9.1.4_ _[[PreventExtensions]] ( )_ 

_9.1.5_ _[[GetOwnProperty]] (P)_ 

_9.1.6_ _[[DefineOwnProperty]] (P, Desc)_ 

_9.1.7_ _[[HasProperty]](P)_ 

_9.1.8_ _[[Get]] (P, Receiver)_ 

_9.1.9_ _[[Set]] ( P, V, Receiver)_ 

_9.1.10_ _[[Delete]] (P)_ 

_9.1.11_ _[[Enumerate]] ()_ 

_9.1.12_ _[[OwnPropertyKeys]] ( )_ 

_9.1.13_ _ObjectCreate(proto, internalSlotsList) Abstract Operation_ 

_9.1.14_ _OrdinaryCreateFromConstructor ( constructor,
intrinsicDefaultProto, internalSlotsList )_ 95

_9.2_ _ECMAScript Function Objects_ 

_9.2.1_ _[[GetOwnProperty]] (P)_ 

_9.2.2_ _[[Call]] ( thisArgument, argumentsList)_ 

_9.2.3_ _[[Construct]] ( argumentsList)_ 

_9.2.4_ _FunctionAllocate (functionPrototype, strict) Abstract
Operation_ 99

_9.2.5_ _FunctionInitialize (F, kind, Strict, ParameterList, Body,
Scope) Abstract Operation_ 99

_9.2.6_ _FunctionCreate (kind, ParameterList, Body, Scope, Strict)
Abstract Operation_ 100

_9.2.7_ _GeneratorFunctionCreate (kind, ParameterList, Body, Scope,
Strict) Abstract Operation_ 100

_9.2.8_ _AddRestrictedFunctionProperties ( F, realm ) Abstract
Operation_ 100

_9.2.9_ _MakeConstructor (F, writablePrototype, prototype) Abstract
Operation_ 101

_9.2.10_ _MakeMethod ( F, methodName, homeObject) Abstract Operation
1

_9.2.11_ _SetFunctionName (F, name, prefix) Abstract Operation_ 

_9.2.12_ _CloneMethod(function, newHome, newName) Abstract Operation
1

_9.2.13_ _FunctionDeclarationInstantiation(func, argumentsList, env )
Abstract Operation_ 103

_9.3_ _Built-in Function Objects_ 

_9.3.1_ _[[Call]] ( thisArgument, argumentsList)_ 

_9.3.2_ _CreateBuiltinFunction(realm, steps, prototype,
internalSlotsList) Abstract Operation_ 106

_9.4_ _Built-in Exotic Object Internal Methods and Data Fields_ 

_9.4.1_ _Bound Function Exotic Objects_ 

_9.4.2_ _Array Exotic Objects_ 

_9.4.3_ _String Exotic Objects_ 

_9.4.4_ _Arguments Exotic Objects_ 

_9.4.5_ _Integer Indexed Exotic Objects_ 

_9.4.6_ _Module Exotic Objects_ 

_9.5_ _Proxy Object Internal Methods and Internal Slots_ 

_9.5.1_ _[[GetPrototypeOf]] ( )_ 

_9.5.2_ _[[SetPrototypeOf]] (V)_ 

_9.5.3_ _[[IsExtensible]] ( )_ 

_9.5.4_ _[[PreventExtensions]] ( )_ 

_9.5.5_ _[[GetOwnProperty]] (P)_ 

_9.5.6_ _[[DefineOwnProperty]] (P, Desc)_ 

_9.5.7_ _[[HasProperty]] (P)_ 

_9.5.8_ _[[Get]] (P, Receiver)_ 

_9.5.9_ _[[Set]] ( P, V, Receiver)_ 

_9.5.10_ _[[Delete]] (P)_ 

_9.5.11_ _[[Enumerate]] ()_ 

_9.5.12_ _[[OwnPropertyKeys]] ( )_ 

_9.5.13_ _[[Call]] (thisArgument, argumentsList)_ 

_9.5.14_ _[[Construct]] Internal Method_ 

_9.5.15_ _ProxyCreate(target, handler) Abstract Operation_ 

_10_ _ECMAScript Language: Source Code_ 

_10.1_ _Source Text_ 

_10.1.1_ _Static Semantics: UTF-16Encoding_ 

_10.1.2_ _Static Semantics: UTF16Decode(lead, trail)_ 

_10.2_ _Types of Source Code_ 

_10.2.1_ _Strict Mode Code_ 

_10.2.2_ _Non-ECMAScript Functions_ 

_11_ _ECMAScript Language: Lexical Grammar_ 

_11.1_ _Unicode Format-Control Characters_ 

_11.2_ _White Space_ 

_11.3_ _Line Terminators_ 

_11.4_ _Comments_ 

_11.5_ _Tokens_ 

_11.6_ _Names and Keywords_ 

_11.6.1_ _Identifier Names_ 

_11.6.2_ _Reserved Words_ 

_11.7_ _Punctuators_ 

_11.8_ _Literals_ 

_11.8.1_ _Null Literals_ 

_11.8.2_ _Boolean Literals_ 

_11.8.3_ _Numeric Literals_ 

_11.8.4_ _String Literals_ 

_11.8.5_ _Regular Expression Literals_ 

_11.8.6_ _Template Literal Lexical Components_ 

_11.9_ _Automatic Semicolon Insertion_ 

_11.9.1_ _Rules of Automatic Semicolon Insertion_ 

_11.9.2_ _Examples of Automatic Semicolon Insertion_ 

_12_ _ECMAScript Language: Expressions_ 

_12.1_ _Identifiers_ 

_12.1.1_ _Static Semantics: Early Errors_ 

_12.1.2_ _Static Semantics: BoundNames_ 

_12.1.3_ _Static Semantics: StringValue_ 

_12.1.4_ _Runtime Semantics: BindingInitialization_ 

_12.1.5_ _Runtime Semantics: Evaluation_ 

_12.2_ _Primary Expression_ 

_12.2.0_ _Semantics_ 

_12.2.1_ _The this Keyword_ 

_12.2.2_ _Identifier Reference_ 

_12.2.3_ _Literals_ 

_12.2.4_ _Array Initializer_ 

_12.2.5_ _Object Initializer_ 

_12.2.6_ _Function Defining Expressions_ 

_12.2.7_ _Generator Comprehensions_ 

_12.2.8_ _Regular Expression Literals_ 

_12.2.9_ _Template Literals_ 

_12.2.10_ _The Grouping Operator_ 

_12.3_ _Left-Hand-Side Expressions_ 

_12.3.1_ _Static Semantics_ 

_12.3.2_ _Property Accessors_ 

_12.3.3_ _The new Operator_ 

_12.3.4_ _Function Calls_ 

_12.3.5_ _The super Keyword_ 

_12.3.6_ _Argument Lists_ 

_12.3.7_ _Tagged Templates_ 

_12.4_ _Postfix Expressions_ 

_12.4.1_ _Static Semantics: Early Errors_ 

_12.4.2_ _Static Semantics: IsFunctionDefinition_ 

_12.4.3_ _Static Semantics: IsValidSimpleAssignmentTarget_ 

_12.4.4_ _Postfix Increment Operator_ 

_12.4.5_ _Postfix Decrement Operator_ 

_12.5_ _Unary Operators_ 

_12.5.1_ _Static Semantics: Early Errors_ 

_12.5.2_ _Static Semantics: IsFunctionDefinition_ 

_12.5.3_ _Static Semantics: IsValidSimpleAssignmentTarget_ 

_12.5.4_ _The delete Operator_ 

_12.5.5_ _The void Operator_ 

_12.5.6_ _The typeof Operator_ 

_12.5.7_ _Prefix Increment Operator_ 

_12.5.8_ _Prefix Decrement Operator_ 

_12.5.9_ _Unary + Operator_ 

_12.5.10_ _Unary - Operator_ 

_12.5.11_ _Bitwise NOT Operator ( ~ )_ 

_12.5.12_ _Logical NOT Operator ( ! )_ 

_12.6_ _Multiplicative Operators_ 

_12.6.1_ _Static Semantics: IsFunctionDefinition_ 

_12.6.2_ _Static Semantics: IsValidSimpleAssignmentTarget_ 

_12.6.3_ _Runtime Semantics: Evaluation_ 

_12.7_ _Additive Operators_ 

_12.7.1_ _Static Semantics: IsFunctionDefinition_ 

_12.7.2_ _Static Semantics: IsValidSimpleAssignmentTarget_ 

_12.7.3_ _The Addition operator ( + )_ 

_12.7.4_ _The Subtraction Operator ( - )_ 

_12.7.5_ _Applying the Additive Operators to Numbers_ 

_12.8_ _Bitwise Shift Operators_ 

_12.8.1_ _Static Semantics: IsFunctionDefinition_ 

_12.8.2_ _Static Semantics: IsValidSimpleAssignmentTarget_ 

_12.8.3_ _The Left Shift Operator ( << )_ 

_12.8.4_ _The Signed Right Shift Operator ( >> )_ 

_12.8.5_ _The Unsigned Right Shift Operator ( >>> )_ 

_12.9_ _Relational Operators_ 

_12.9.1_ _Static Semantics: IsFunctionDefinition_ 

_12.9.2_ _Static Semantics: IsValidSimpleAssignmentTarget_ 

_12.9.3_ _Runtime Semantics: Evaluation_ 

_12.9.4_ _Runtime Semantics: InstanceofOperator(O, C)_ 

_12.10_ _Equality Operators_ 

_12.10.1_ _Static Semantics: IsFunctionDefinition_ 

_12.10.2_ _Static Semantics: IsValidSimpleAssignmentTarget_ 

_12.10.3_ _Runtime Semantics: Evaluation_ 

_12.11_ _Binary Bitwise Operators_ 

_12.11.1_ _Static Semantics: IsFunctionDefinition_ 

_12.11.2_ _Static Semantics: IsValidSimpleAssignmentTarget_ 

_12.11.3_ _Runtime Semantics: Evaluation_ 

_12.12_ _Binary Logical Operators_ 

_12.12.1_ _Static Semantics: IsFunctionDefinition_ 

_12.12.2_ _Static Semantics: IsValidSimpleAssignmentTarget_ 

_12.12.3_ _Runtime Semantics: Evaluation_ 

_12.13_ _Conditional Operator ( ? : )_ 

_12.13.1_ _Static Semantics: IsFunctionDefinition_ 

_12.13.2_ _Static Semantics: IsValidSimpleAssignmentTarget_ 

_12.13.3_ _Runtime Semantics: Evaluation_ 

_12.14_ _Assignment Operators_ 

_12.14.1_ _Static Semantics: Early Errors_ 

_12.14.2_ _Static Semantics: IsFunctionDefinition_ 

_12.14.3_ _Static Semantics: IsValidSimpleAssignmentTarget_ 

_12.14.4_ _Runtime Semantics: Evaluation_ 

_12.14.5_ _Destructuring Assignment_ 

_12.15_ _Comma Operator ( , )_ 

_12.15.1_ _Static Semantics: IsFunctionDefinition_ 

_12.15.2_ _Static Semantics: IsValidSimpleAssignmentTarget_ 

_12.15.3_ _Runtime Semantics: Evaluation_ 

_13_ _ECMAScript Language: Statements and Declarations_ 

_13.0_ _Statement Semantics_ 

_13.0.1_ _Static Semantics: VarDeclaredNames_ 

_13.0.2_ _Static Semantics: VarScopedDeclarations_ 

_13.0.3_ _Runtime Semantics: LabelledEvaluation_ 

_13.0.4_ _Runtime Semantics: Evaluation_ 

_13.1_ _Block_ 

_13.1.1_ _Static Semantics: Early Errors_ 

_13.1.2_ _Static Semantics: LexicallyDeclaredNames_ 

_13.1.3_ _Static Semantics: LexicallyScopedDeclarations_ 

_13.1.4_ _Static Semantics: TopLevelLexicallyDeclaredNames_ 

_13.1.5_ _Static Semantics: TopLevelLexicallyScopedDeclarations_ 

_13.1.6_ _Static Semantics: TopLevelVarDeclaredNames_ 

_13.1.7_ _Static Semantics: TopLevelVarScopedDeclarations_ 

_13.1.8_ _Static Semantics: VarDeclaredNames_ 

_13.1.9_ _Static Semantics: VarScopedDeclarations_ 

_13.1.10_ _Runtime Semantics: Evaluation_ 

_13.1.11_ _Runtime Semantics: BlockDeclarationInstantiation( code, env
)_ 224

_13.2_ _Declarations and the Variable Statement_ 

_13.2.1_ _Let and Const Declarations_ 

_13.2.2_ _Variable Statement_ 

_13.2.3_ _Destructuring Binding Patterns_ 

_13.3_ _Empty Statement_ 

_13.3.1_ _Runtime Semantics: Evaluation_ 

_13.4_ _Expression Statement_ 

_13.4.1_ _Runtime Semantics: Evaluation_ 

_13.5_ _The if Statement_ 

_13.5.1_ _Static Semantics: Early Errors_ 

_13.5.2_ _Static Semantics: VarDeclaredNames_ 

_13.5.3_ _Static Semantics: VarScopedDeclarations_ 

_13.5.4_ _Runtime Semantics: Evaluation_ 

_13.6_ _Iteration Statements_ 

_13.6.0_ _Semantics_ 

_13.6.1_ _The do-while Statement_ 

_13.6.2_ _The while Statement_ 

_13.6.3_ _The for Statement_ 

_13.6.4_ _The for-in and for-of Statements_ 

_13.7_ _The continue Statement_ 

_13.7.1_ _Static Semantics: Early Errors_ 

_13.7.2_ _Runtime Semantics: Evaluation_ 

_13.8_ _The break Statement_ 

_13.8.1_ _Static Semantics: Early Errors_ 

_13.8.2_ _Runtime Semantics: Evaluation_ 

_13.9_ _The return Statement_ 

_13.9.1_ _Runtime Semantics: Evaluation_ 

_13.10_ _The with Statement_ 

_13.10.1_ _Static Semantics: Early Errors_ 

_13.10.2_ _Static Semantics: VarDeclaredNames_ 

_13.10.3_ _Static Semantics: VarScopedDeclarations_ 

_13.10.4_ _Runtime Semantics: Evaluation_ 

_13.11_ _The switch Statement_ 

_13.11.1_ _Static Semantics: Early Errors_ 

_13.11.2_ _Static Semantics: LexicallyDeclaredNames_ 

_13.11.3_ _Static Semantics: LexicallyScopedDeclarations_ 

_13.11.4_ _Static Semantics: VarDeclaredNames_ 

_13.11.5_ _Static Semantics: VarScopedDeclarations_ 

_13.11.6_ _Runtime Semantics: CaseBlockEvaluation_ 

_13.11.7_ _Runtime Semantics: CaseSelectorEvaluation_ 

_13.11.8_ _Runtime Semantics: Evaluation_ 

_13.12_ _Labelled Statements_ 

_13.12.1_ _Static Semantics: Early Errors_ 

_13.12.2_ _Static Semantics: CurrentLabelSet_ 

_13.12.3_ _Static Semantics: IsLabelledFunction ( stmt )_ 

_13.12.4_ _Static Semantics: LexicallyDeclaredNames_ 

_13.12.5_ _Static Semantics: LexicallyScopedDeclarations_ 

_13.12.6_ _Static Semantics: TopLevelLexicallyDeclaredNames_ 

_13.12.7_ _Static Semantics: TopLevelLexicallyScopedDeclarations_ 

_13.12.8_ _Static Semantics: TopLevelVarDeclaredNames_ 

_13.12.9_ _Static Semantics: TopLevelVarScopedDeclarations_ 

_13.12.10_ _Static Semantics: VarDeclaredNames_ 

_13.12.11_ _Static Semantics: VarScopedDeclarations_ 

_13.12.12_ _Runtime Semantics: LabelledEvaluation_ 

_13.13_ _The throw Statement_ 

_13.13.1_ _Runtime Semantics: Evaluation_ 

_13.14_ _The try Statement_ 

_13.14.1_ _Static Semantics: Early Errors_ 

_13.14.2_ _Static Semantics: VarDeclaredNames_ 

_13.14.3_ _Static Semantics: VarScopedDeclarations_ 

_13.14.4_ _Runtime Semantics: BindingInitialization_ 

_13.14.5_ _Runtime Semantics: CatchClauseEvaluation_ 

_13.14.6_ _Runtime Semantics: Evaluation_ 

_13.15_ _The debugger statement_ 

_13.15.1_ _Runtime Semantics: Evaluation_ 

_14_ _ECMAScript Language: Functions and Classes_ 

_14.1_ _Function Definitions_ 

_14.1.1_ _Directive Prologues and the Use Strict Directive_ 

_14.1.2_ _Static Semantics: Early Errors_ 

_14.1.3_ _Static Semantics: BoundNames_ 

_14.1.4_ _Static Semantics: Contains_ 

_14.1.5_ _Static Semantics: ContainsExpression_ 

_14.1.6_ _Static Semantics: ExpectedArgumentCount_ 

_14.1.7_ _Static Semantics: HasInitializer_ 

_14.1.8_ _Static Semantics: HasName_ 

_14.1.9_ _Static Semantics: IsAnonymousFunctionDefinition ( production)
Abstract Operation_ 269

_14.1.10_ _Static Semantics: IsConstantDeclaration_ 

_14.1.11_ _Static Semantics: IsFunctionDefinition_ 

_14.1.12_ _Static Semantics: IsSimpleParameterList_ 

_14.1.13_ _Static Semantics: IsStrict_ 

_14.1.14_ _Static Semantics: LexicallyDeclaredNames_ 

_14.1.15_ _Static Semantics: LexicallyScopedDeclarations_ 

_14.1.16_ _Static Semantics: ReferencesSuper_ 

_14.1.17_ _Static Semantics: VarDeclaredNames_ 

_14.1.18_ _Static Semantics: VarScopedDeclarations_ 

_14.1.19_ _Runtime Semantics: EvaluateBody_ 

_14.1.20_ _Runtime Semantics: IteratorBindingInitialization_ 

_14.1.21_ _Runtime Semantics: InstantiateFunctionObject_ 

_14.1.22_ _Runtime Semantics: Evaluation_ 

_14.2_ _Arrow Function Definitions_ 

_14.2.1_ _Static Semantics: Early Errors_ 

_14.2.2_ _Static Semantics: BoundNames_ 

_14.2.3_ _Static Semantics: Contains_ 

_14.2.4_ _Static Semantics: ContainsExpression_ 

_14.2.5_ _Static Semantics: CoveredFormalsList_ 

_14.2.6_ _Static Semantics: ExpectedArgumentCount_ 

_14.2.7_ _Static Semantics: HasInitializer_ 

_14.2.8_ _Static Semantics: HasName_ 

_14.2.9_ _Static Semantics: IsSimpleParameterList_ 

_14.2.10_ _Static Semantics: LexicallyDeclaredNames_ 

_14.2.11_ _Static Semantics: LexicallyScopedDeclarations_ 

_14.2.12_ _Static Semantics: ReferencesSuper_ 

_14.2.13_ _Static Semantics: VarDeclaredNames_ 

_14.2.14_ _Static Semantics: VarScopedDeclarations_ 

_14.2.15_ _Runtime Semantics: IteratorBindingInitialization_ 

_14.2.16_ _Runtime Semantics: EvaluateBody_ 

_14.2.17_ _Runtime Semantics: Evaluation_ 

_14.3_ _Method Definitions_ 

_14.3.1_ _Static Semantics: Early Errors_ 

_14.3.2_ _Static Semantics: ComputedPropertyContains_ 

_14.3.3_ _Static Semantics: ExpectedArgumentCount_ 

_14.3.4_ _Static Semantics: HasComputedPropertyKey_ 

_14.3.5_ _Static Semantics: PropName_ 

_14.3.6_ _Static Semantics: ReferencesSuper_ 

_14.3.7_ _Static Semantics: SpecialMethod_ 

_14.3.8_ _Runtime Semantics: DefineMethod_ 

_14.3.9_ _Runtime Semantics: PropertyDefinitionEvaluation_ 

_14.4_ _Generator Function Definitions_ 

_14.4.1_ _Static Semantics: Early Errors_ 

_14.4.2_ _Static Semantics: BoundNames_ 

_14.4.3_ _Static Semantics: ComputedPropertyContains_ 

_14.4.4_ _Static Semantics: Contains_ 

_14.4.5_ _Static Semantics: HasComputedPropertyKey_ 

_14.4.6_ _Static Semantics: HasName_ 

_14.4.7_ _Static Semantics: IsConstantDeclaration_ 

_14.4.8_ _Static Semantics: IsFunctionDefinition_ 

_14.4.9_ _Static Semantics: PropName_ 

_14.4.10_ _Static Semantics: ReferencesSuper_ 

_14.4.11_ _Runtime Semantics: EvaluateBody_ 

_14.4.12_ _Runtime Semantics: InstantiateFunctionObject_ 

_14.4.13_ _Runtime Semantics: PropertyDefinitionEvaluation_ 

_14.4.14_ _Runtime Semantics: Evaluation_ 

_14.5_ _Class Definitions_ 

_14.5.1_ _Static Semantics: Early Errors_ 

_14.5.2_ _Static Semantics: BoundNames_ 

_14.5.3_ _Static Semantics: ConstructorMethod_ 

_14.5.4_ _Static Semantics: Contains_ 

_14.5.5_ _Static Semantics: ComputedPropertyContains_ 

_14.5.6_ _Static Semantics: HasName_ 

_14.5.7_ _Static Semantics: IsConstantDeclaration_ 

_14.5.8_ _Static Semantics: IsFunctionDefinition_ 

_14.5.9_ _Static Semantics: IsStatic_ 

_14.5.10_ _Static Semantics: NonConstructorMethodDefinitions_ 

_14.5.11_ _Static Semantics: PrototypePropertyNameList_ 

_14.5.12_ _Static Semantics: PropName_ 

_14.5.13_ _Static Semantics: StaticPropertyNameList_ 

_14.5.14_ _Runtime Semantics: ClassDefinitionEvaluation_ 

_14.5.15_ _Runtime Semantics: Evaluation_ 

_14.6_ _Tail Position Calls_ 

_14.6.1_ _Static Semantics: IsInTailPosition(nonterminal) Abstract
Operation_ 293

_14.6.2_ _Static Semantics: HasProductionInTailPosition_ 

_14.6.3_ _Runtime Semantics: PrepareForTailCall ( )_ 

_15_ _ECMAScript Language: Scripts and Modules_ 

_15.1_ _Scripts_ 

_15.1.1_ _Static Semantics: Early Errors_ 

_15.1.2_ _Static Semantics: IsStrict_ 

_15.1.3_ _Static Semantics: LexicallyDeclaredNames_ 

_15.1.4_ _Static Semantics: LexicallyScopedDeclarations_ 

_15.1.5_ _Static Semantics: VarDeclaredNames_ 

_15.1.6_ _Static Semantics: VarScopedDeclarations_ 

_15.1.7_ _Runtime Semantics: ScriptEvaluation_ 

_15.1.8_ _Runtime Semantics: GlobalDeclarationInstantiation_ 

_15.1.9_ _Runtime Semantics: ScriptEvaluationJob ( source )_ 

_15.2_ _Modules_ 

_15.2.0_ _Module Static Semantics_ 

_15.2.1_ _Imports_ 

_15.2.2_ _Exports_ 

_15.2.3_ _Runtime Semantics: Loader State_ 

_15.2.4_ _Runtime Semantics: Module Loading_ 

_15.2.5_ _Runtime Semantics: Module Linking_ 

_15.2.6_ _Runtime Semantics: Module Evaluation_ 

_16_ _Error Handling and Language Extensions_ 

_17_ _ECMAScript Standard Built-in Objects_ 

_18_ _The Global Object_ 

_18.1_ _Value Properties of the Global Object_ 

_18.1.1_ _Infinity_ 

_18.1.2_ _NaN_ 

_18.1.3_ _undefined_ 

_18.2_ _Function Properties of the Global Object_ 

_18.2.1_ _eval (x)_ 

_18.2.2_ _isFinite (number)_ 

_18.2.3_ _isNaN (number)_ 

_18.2.4_ _parseFloat (string)_ 

_18.2.5_ _parseInt (string , radix)_ 

_18.2.6_ _URI Handling Functions_ 

_18.3_ _Constructor Properties of the Global Object_ 

_18.3.1_ _Array ( . . . )_ 

_18.3.2_ _ArrayBuffer ( . . . )_ 

_18.3.3_ _Boolean ( . . . )_ 

_18.3.4_ _DataView ( . . . )_ 

_18.3.5_ _Date ( . . . )_ 

_18.3.6_ _Error ( . . . )_ 

_18.3.7_ _EvalError ( . . . )_ 

_18.3.8_ _Float32Array ( . . . )_ 

_18.3.9_ _Float64Array ( . . . )_ 

_18.3.10_ _Function ( . . . )_ 

_18.3.11_ _Int8Array ( . . . )_ 

_18.3.12_ _Int16Array ( . . . )_ 

_18.3.13_ _Int32Array ( . . . )_ 

_18.3.14_ _Map ( . . . )_ 

_18.3.15_ _Number ( . . . )_ 

_18.3.16_ _Object ( . . . )_ 

_18.3.17_ _RangeError ( . . . )_ 

_18.3.18_ _ReferenceError ( . . . )_ 

_18.3.19_ _RegExp ( . . . )_ 

_18.3.20_ _Set ( . . . )_ 

_18.3.21_ _String ( . . . )_ 

_18.3.22_ _Symbol ( . . . )_ 

_18.3.23_ _SyntaxError ( . . . )_ 

_18.3.24_ _TypeError ( . . . )_ 

_18.3.25_ _Uint8Array ( . . . )_ 

_18.3.26_ _Uint8ClampedArray ( . . . )_ 

_18.3.27_ _Uint16Array ( . . . )_ 

_18.3.28_ _Uint32Array ( . . . )_ 

_18.3.29_ _URIError ( . . . )_ 

_18.3.30_ _WeakMap ( . . . )_ 

_18.3.31_ _WeakSet ( . . . )_ 

_18.4_ _Other Properties of the Global Object_ 

_18.4.1_ _JSON_ 

_18.4.2_ _Math_ 

_18.4.3_ _Proxy ( . . . )_ 

_18.4.4_ _Reflect_ 

_18.4.5_ _System_ 

_19_ _Fundamental Objects_ 

_19.1_ _Object Objects_ 

_19.1.1_ _The Object Constructor_ 

_19.1.2_ _Properties of the Object Constructor_ 

_19.1.3_ _Properties of the Object Prototype Object_ 

_19.1.4_ _Properties of Object Instances_ 

_19.2_ _Function Objects_ 

_19.2.1_ _The Function Constructor_ 

_19.2.2_ _Properties of the Function Constructor_ 

_19.2.3_ _Properties of the Function Prototype Object_ 

_19.2.4_ _Function Instances_ 

_19.3_ _Boolean Objects_ 

_19.3.1_ _The Boolean Constructor_ 

_19.3.2_ _Properties of the Boolean Constructor_ 

_19.3.3_ _Properties of the Boolean Prototype Object_ 

_19.3.4_ _Properties of Boolean Instances_ 

_19.4_ _Symbol Objects_ 

_19.4.1_ _The Symbol Constructor class_ 

_19.4.2_ _Properties of the Symbol Constructor_ 

_19.4.3_ _Properties of the Symbol Prototype Object_ 

_19.4.4_ _Properties of Symbol Instances_ 

_19.5_ _Error Objects_ 

_19.5.1_ _The Error Constructor_ 

_19.5.2_ _Properties of the Error Constructor_ 

_19.5.3_ _Properties of the Error Prototype Object_ 

_19.5.4_ _Properties of Error Instances_ 

_19.5.5_ _Native Error Types Used in This Standard_ 

_19.5.6_ __NativeError Object Structure__ 

_20_ _Numbers and Dates_ 

_20.1_ _Number Objects_ 

_20.1.1_ _The Number Constructor_ 

_20.1.2_ _Properties of the Number Constructor_ 

_20.1.3_ _Properties of the Number Prototype Object_ 

_20.1.4_ _Properties of Number Instances_ 

_20.2_ _The Math Object_ 

_20.2.1_ _Value Properties of the Math Object_ 

_20.2.2_ _Function Properties of the Math Object_ 

_20.3_ _Date Objects_ 

_20.3.1_ _Overview of Date Objects and Definitions of Abstract
Operations_ 394

_20.3.2_ _The Date Constructor_ 

_20.3.3_ _Properties of the Date Constructor_ 

_20.3.4_ _Properties of the Date Prototype Object_ 

_20.3.5_ _Properties of Date Instances_ 

_21_ _Text Processing_ 

_21.1_ _String Objects_ 

_21.1.1_ _The String Constructor_ 

_21.1.2_ _Properties of the String Constructor_ 

_21.1.3_ _Properties of the String Prototype Object_ 

_21.1.4_ _Properties of String Instances_ 

_21.1.5_ _String Iterator Objects_ 

_21.2_ _RegExp (Regular Expression) Objects_ 

_21.2.1_ _Patterns_ 

_21.2.2_ _Pattern Semantics_ 

_21.2.3_ _The RegExp Constructor_ 

_21.2.4_ _Properties of the RegExp Constructor_ 

_21.2.5_ _Properties of the RegExp Prototype Object_ 

_21.2.6_ _Properties of RegExp Instances_ 

_22_ _Indexed Collections_ 

_22.1_ _Array Objects_ 

_22.1.1_ _The Array Constructor_ 

_22.1.2_ _Properties of the Array Constructor_ 

_22.1.3_ _Properties of the Array Prototype Object_ 

_22.1.4_ _Properties of Array Instances_ 

_22.1.5_ _Array Iterator Objects_ 

_22.2_ __TypedArray Objects__ 

_22.2.1_ _The %TypedArray% Intrinsic Object_ 

_22.2.2_ _Properties of the %TypedArray% Intrinsic Object_ 

_22.2.3_ _Properties of the %TypedArrayPrototype% Object_ 

_22.2.4_ _The _TypedArray_ Constructors_ 

_22.2.5_ _Properties of the _TypedArray_ Constructors_ 

_22.2.6_ _Properties of _TypedArray_ Prototype Objects_ 

_22.2.7_ _Properties of _TypedArray_ Instances_ 

_23_ _Keyed Collection_ 

_23.1_ _Map Objects_ 

_23.1.1_ _The Map Constructor_ 

_23.1.2_ _Properties of the Map Constructor_ 

_23.1.3_ _Properties of the Map Prototype Object_ 

_23.1.4_ _Properties of Map Instances_ 

_23.1.5_ _Map Iterator Objects_ 

_23.2_ _Set Objects_ 

_23.2.1_ _The Set Constructor_ 

_23.2.2_ _Properties of the Set Constructor_ 

_23.2.3_ _Properties of the Set Prototype Object_ 

_23.2.4_ _Properties of Set Instances_ 

_23.2.5_ _Set Iterator Objects_ 

_23.3_ _WeakMap Objects_ 

_23.3.1_ _The WeakMap Constructor_ 

_23.3.2_ _Properties of the WeakMap Constructor_ 

_23.3.3_ _Properties of the WeakMap Prototype Object_ 

_23.3.4_ _Properties of WeakMap Instances_ 

_23.4_ _WeakSet Objects_ 

_23.4.1_ _The WeakSet Constructor_ 

_23.4.2_ _Properties of the WeakSet Constructor_ 

_23.4.3_ _Properties of the WeakSet Prototype Object_ 

_23.4.4_ _Properties of WeakSet Instances_ 

_24_ _Structured Data_ 

_24.1_ _ArrayBuffer Objects_ 

_24.1.1_ _Abstract Operations For ArrayBuffer Objects_ 

_24.1.2_ _The ArrayBuffer Constructor_ 

_24.1.3_ _Properties of the ArrayBuffer Constructor_ 

_24.1.4_ _Properties of the ArrayBuffer Prototype Object_ 

_24.1.5_ _Properties of the ArrayBuffer Instances_ 

_24.2_ _DataView Objects_ 

_24.2.1_ _Abstract Operations For DataView Objects_ 

_24.2.2_ _The DataView Constructor_ 

_24.2.3_ _Properties of the DataView Constructor_ 

_24.2.4_ _Properties of the DataView Prototype Object_ 

_24.2.5_ _Properties of DataView Instances_ 

_24.3_ _The JSON Object_ 

_24.3.1_ _JSON.parse ( text [ , reviver ] )_ 

_24.3.2_ _JSON.stringify ( value [ , replacer [ , space ] ] )_ 

_24.3.3_ _JSON [ @@toStringTag ]_ 

_25_ _Control Abstraction Objects_ 

_25.1_ _Common Iteration Interfaces_ 

_25.1.1_ _The _Iterable_ Interface_ 

_25.1.2_ _The _Iterator_ Interface_ 

_25.1.3_ _The _IteratorResult_ Interface_ 

_25.2_ _GeneratorFunction Objects_ 

_25.2.1_ _The GeneratorFunction Constructor_ 

_25.2.2_ _Properties of the GeneratorFunction Constructor_ 

_25.2.3_ _Properties of the GeneratorFunction Prototype Object_ 

_25.2.4_ _GeneratorFunction Instances_ 

_25.3_ _Generator Objects_ 

_25.3.1_ _Properties of Generator Prototype_ 

_25.3.2_ _Properties of Generator Instances_ 

_25.3.3_ _Generator Abstract Operations_ 

_25.4_ _Promise Objects_ 

_25.4.1_ _Promise Abstract Operations_ 

_25.4.2_ _Promise Jobs_ 

_25.4.3_ _The Promise Constructor_ 

_25.4.4_ _Properties of the Promise Constructor_ 

_25.4.5_ _Properties of the Promise Prototype Object_ 

_25.4.6_ _Properties of Promise Instances_ 

_26_ _Reflection_ 

_26.1_ _The Reflect Object_ 

_26.1.1_ _Reflect.apply ( target, thisArgument, argumentsList )_ 

_26.1.2_ _Reflect.construct ( target, argumentsList )_ 

_26.1.3_ _Reflect.defineProperty ( target, propertyKey, attributes )
5

_26.1.4_ _Reflect.deleteProperty ( target, propertyKey )_ 

_26.1.5_ _Reflect.enumerate ( target )_ 

_26.1.6_ _Reflect.get ( target, propertyKey [ , receiver ])_ 

_26.1.7_ _Reflect.getOwnPropertyDescriptor ( target, propertyKey )_ 

_26.1.8_ _Reflect.getPrototypeOf ( target )_ 

_26.1.9_ _Reflect.has ( target, propertyKey )_ 

_26.1.10_ _Reflect.isExtensible (target)_ 

_26.1.11_ _Reflect.ownKeys ( target )_ 

_26.1.12_ _Reflect.preventExtensions ( target )_ 

_26.1.13_ _Reflect.set ( target, propertyKey, V [ , receiver ] )_ 

_26.1.14_ _Reflect.setPrototypeOf ( target, proto )_ 

_26.2_ _Realm Objects_ 

_26.2.1_ _The Reflect.Realm Constructor_ 

_26.2.2_ _Properties of the Reflect.Realm Constructor_ 

_26.2.3_ _Properties of the Reflect.Realm Prototype Object_ 

_26.2.4_ _Properties of Reflect.Realm Instances_ 

_26.3_ _Loader Objects_ 

_26.3.1_ _The Reflect.Loader Constructor_ 

_26.3.2_ _Properties of the Loader Constructor_ 

_26.3.3_ _Properties of the Reflect.Loader Prototype Object_ 

_26.3.4_ _Properties of Reflect.Loader Instances_ 

_26.3.5_ _Loader Iterator Objects_ 

_26.4_ _The System Object_ 

_26.5_ _Proxy Objects_ 

_26.5.1_ _The Proxy Constructor Function_ 

_26.5.2_ _Properties of the Proxy Constructor Function_ 

_Annex A (informative) Grammar Summary_ 

_A.1_ _Lexical Grammar_ 

_A.2_ _Expressions_ 

_A.3_ _Statements_ 

_A.4_ _Functions and Scripts_ 

_A.5_ _Number Conversions_ 

_A.6_ _Universal Resource Identifier Character Classes_ 

_A.7_ _Regular Expressions_ 

_Annex B (normative) Additional ECMAScript Features for Web Browsers
6

_B.1_ _Additional Syntax_ 

_B.1.1_ _Numeric Literals_ 

_B.1.2_ _String Literals_ 

_B.1.3_ _HTML-like Comments_ 

_B.1.4_ _Regular Expressions Patterns_ 

_B.2_ _Additional Built-in Properties_ 

_B.2.1_ _Additional Properties of the Global Object_ 

_B.2.2_ _Additional Properties of the Object.prototype Object_ 

_B.2.3_ _Additional Properties of the String.prototype Object_ 

_B.2.4_ _Additional Properties of the Date.prototype Object_ 

_B.2.5_ _Additional Properties of the RegExp.prototype Object_ 

_B.3_ _Other Additional Features_ 

_B.3.1_ ___proto__ Property Names in Object Initializers_ 

_B.3.2_ _Labelled Function Declarations_ 

_B.3.3_ _Block-Level Function Declarations Web Legacy Compatibility
Semantics_ 634

_B.3.4_ _FunctionDeclarations in IfStatement Statement Clauses._ 

_B.3.5_ _VariableStatements in Catch blocks_ 

_Annex C (informative) The Strict Mode of ECMAScript_ 

_Annex D (informative) Corrections and Clarifications with Possible
Compatibility Impact_ 639

_D.1_ _In Edition 6_ 

_D.2_ _In Edition 5.1_ 

_D.3_ _In Edition 5_ 

_Annex E (informative) Additions and Changes That Introduce
Incompatibilities with Prior Editions_ 643

_E.1_ _In the 6^th^ Edition_ 

_E.2_ _In the 5^th^ Edition_ 

Introduction

This Ecma Standard is based on several originating technologies, the
most well known being JavaScript (Netscape) and JScript (Microsoft). The
language was invented by Brendan Eich at Netscape and first appeared in
that company’s Navigator 2.0 browser. It has appeared in all subsequent
browsers from Netscape and in all browsers from Microsoft starting with
Internet Explorer 3.0.

The development of this Standard started in November 1996. The first
edition of this Ecma Standard was adopted by the Ecma General Assembly
of June 1997.

That Ecma Standard was submitted to ISO/IEC JTC 1 for adoption under the
fast-track procedure, and approved as international standard ISO/IEC
16262, in April 1998. The Ecma General Assembly of June 1998 approved
the second edition of ECMA-262 to keep it fully aligned with ISO/IEC
16262. Changes between the first and the second edition are editorial in
nature.

The third edition of the Standard introduced powerful regular
expressions, better string handling, new control statements, try/catch
exception handling, tighter definition of errors, formatting for numeric
output and minor changes in anticipation of forthcoming
internationalization facilities and future language growth. The third
edition of the ECMAScript standard was adopted by the Ecma General
Assembly of December 1999 and published as ISO/IEC 16262:2002 in June
2002.

After publication of the third edition, ECMAScript achieved massive
adoption in conjunction with the World Wide Web where it has become the
programming language that is supported by essentially all web browsers.
Significant work was done to develop a fourth edition of ECMAScript.
Although that work was not completed and not published[1] as the fourth
edition of ECMAScript, it informs continuing evolution of the language.
The fifth edition of ECMAScript (published as ECMA-262 5^th^ edition)
codified de facto interpretations of the language specification that
have become common among browser implementations and added support for
new features that had emerged since the publication of the third
edition. Such features include accessor properties, reflective creation
and inspection of objects, program control of property attributes,
additional array manipulation functions, support for the JSON object
encoding format, and a strict mode that provides enhanced error checking
and program security.

The edition 5.1 of the ECMAScript Standard is fully aligned with the
third edition of the international standard ISO/IEC 16262:2011.

This present sixth edition of the Standard………

ECMAScript is a vibrant language and the evolution of the language is
not complete. Significant technical enhancement will continue with
future editions of this specification.

This Ecma Standard has been adopted by the General Assembly of <month>
<year>.

_"DISCLAIMER

_This draft document may be copied and furnished to others, and
derivative works that comment on or otherwise explain it or assist in
its implementation may be prepared, copied, published, and distributed,
in whole or in part, without restriction of any kind, provided that the
above copyright notice and this section are included on all such copies
and derivative works. However, this document itself may not be modified
in any way, including by removing the copyright notice or references to
Ecma International, except as needed for the purpose of developing any
document or deliverable produced by Ecma International._

_This disclaimer is valid only prior to final version of this document.
After approval all rights on the standard are reserved by Ecma
International._

_The limited permissions are granted through the standardization phase
and will not be revoked by Ecma International or its successors or
assigns during this time._

_This document and the information contained herein is provided on an
"AS IS" basis and ECMA INTERNATIONAL DISCLAIMS ALL WARRANTIES, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
THE INFORMATION HEREIN WILL NOT INFRINGE ANY OWNERSHIP RIGHTS OR ANY
IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE."_

ECMAScript Language Specification



SCOPE


This Standard defines the ECMAScript scripting language.



CONFORMANCE


A conforming implementation of ECMAScript must provide and support all
the types, values, objects, properties, functions, and program syntax
and semantics described in this specification.

A conforming implementation of ECMAScript must interpret source code
input in conformance with the Unicode Standard, Version 5.1.0 or later
and ISO/IEC 10646. If the adopted ISO/IEC 10646-1 subset is not
otherwise specified, it is presumed to be the Unicode set, collection
10646.

A conforming implementation of ECMAScript that provides an application
programming interface that supports programs that need to adapt to the
linguistic and cultural conventions used by different human languages
and countries must implement the interface defined by the most recent
edition of ECMA-402 that is compatible with this specification.

A conforming implementation of ECMAScript may provide additional types,
values, objects, properties, and functions beyond those described in
this specification. In particular, a conforming implementation of
ECMAScript may provide properties not described in this specification,
and values for those properties, for objects that are described in this
specification.

A conforming implementation of ECMAScript may support program and
regular expression syntax not described in this specification. In
particular, a conforming implementation of ECMAScript may support
program syntax that makes use of the “future reserved words” listed in
subclause 11.6.2.2 of this specification.



NORMATIVE REFERENCES


The following referenced documents are indispensable for the application
of this document. For dated references, only the edition cited applies.
For undated references, the latest edition of the referenced document
(including any amendments) applies.

IEEE Std 754-2008: _IEEE Standard for Floating-Point Arithmetic_.
Institute of Electrical and Electronic Engineers, New York (2008)

ISO/IEC 10646:2003: _Information Technology – Universal Multiple-Octet
Coded Character Set (UCS) plus Amendment 1:2005, Amendment 2:2006,
Amendment 3:2008, and Amendment 4:2008_, plus additional amendments and
corrigenda, or successor

_The Unicode Standard, Version 5.0_, as amended by Unicode 5.1.0, or
successor

_Unicode Standard Annex #15, Unicode Normalization Forms, version
Unicode 5.1.0_, or successor

_Unicode Standard Annex #31, Unicode Identifiers and Pattern Syntax,
version Unicode 5.1.0_, or successor.

ECMA-402, _ECMAScript Internationalization API Specification_.
_http://www.ecma-international.org/publications/standards/Ecma-402.htm

ECMA-404, _The JSON Data Interchange Format_.
_http://www.ecma-international.org/publications/standards/Ecma-404.htm



OVERVIEW


This section contains a non-normative overview of the ECMAScript
language.

ECMAScript is an object-oriented programming language for performing
computations and manipulating computational objects within a host
environment. ECMAScript as defined here is not intended to be
computationally self-sufficient; indeed, there are no provisions in this
specification for input of external data or output of computed results.
Instead, it is expected that the computational environment of an
ECMAScript program will provide not only the objects and other
facilities described in this specification but also certain
environment-specific objects, whose description and behaviour are beyond
the scope of this specification except to indicate that they may provide
certain properties that can be accessed and certain functions that can
be called from an ECMAScript program.

A _SCRIPTING LANGUAGE_ is a programming language that is used to
manipulate, customize, and automate the facilities of an existing
system. In such systems, useful functionality is already available
through a user interface, and the scripting language is a mechanism for
exposing that functionality to program control. In this way, the
existing system is said to provide a host environment of objects and
facilities, which completes the capabilities of the scripting language.
A scripting language is intended for use by both professional and
non-professional programmers. ECMAScript was originally designed to be
used as a scripting language, but has become widely used as a general
purpose programming language.

ECMAScript was originally designed to be a _WEB SCRIPTING LANGUAGE_,
providing a mechanism to enliven Web pages in browsers and to perform
server computation as part of a Web-based client-server architecture.
ECMAScript is now used both as a general propose programming language
and to provide core scripting capabilities for a variety of host
environments. Therefore the core language is specified in this document
apart from any particular host environment.

Some of the facilities of ECMAScript are similar to those used in other
programming languages; in particular C, Java, Self, and Scheme as
described in:

ISO/IEC 9899:1996, Programming Languages – C.

Gosling, James, Bill Joy and Guy Steele. The Java^^ Language
Specification. Addison Wesley Publishing Co., 1996.

Ungar, David, and Smith, Randall B. Self: The Power of Simplicity.
OOPSLA '87 Conference Proceedings, pp. 227–241, Orlando, FL, October
1987.

IEEE Standard for the Scheme Programming Language. IEEE Std 1178-1990.


Web Scripting

A web browser provides an ECMAScript host environment for client-side
computation including, for instance, objects that represent windows,
menus, pop-ups, dialog boxes, text areas, anchors, frames, history,
cookies, and input/output. Further, the host environment provides a
means to attach scripting code to events such as change of focus, page
and image loading, unloading, error and abort, selection, form
submission, and mouse actions. Scripting code appears within the HTML
and the displayed page is a combination of user interface elements and
fixed and computed text and images. The scripting code is reactive to
user interaction and there is no need for a main program.

A web server provides a different host environment for server-side
computation including objects representing requests, clients, and files;
and mechanisms to lock and share data. By using browser-side and
server-side scripting together, it is possible to distribute computation
between the client and server while providing a customized user
interface for a Web-based application.

Each Web browser and server that supports ECMAScript supplies its own
host environment, completing the ECMAScript execution environment.


ECMAScript Overview

The following is an informal overview of ECMAScript—not all parts of the
language are described. This overview is not part of the standard
proper.

ECMAScript is object-based: basic language and host facilities are
provided by objects, and an ECMAScript program is a cluster of
communicating objects. In ECMAScript, an _OBJECT_ is a collection of
_PROPERTIES_ each with zero or more _ATTRIBUTES_ that determine how each
property can be used—for example, when the Writable attribute for a
property is set to FALSE, any attempt by executed ECMAScript code to
change the value of the property fails. Properties are containers that
hold other objects, _PRIMITIVE VALUES_, or _FUNCTIONS_. A primitive
value is a member of one of the following built-in types: UNDEFINED,
NULL, BOOLEAN, NUMBER, SYMBOL and STRING; an object is a member of the
remaining built-in type OBJECT; and a function is a callable object. A
function that is associated with an object via a property is a _METHOD_.

ECMAScript defines a collection of _BUILT-IN OBJECTS_ that round out the
definition of ECMAScript entities. These built-in objects include the
global object, the OBJECT object, the FUNCTION object, the ARRAY object,
the STRING object, the BOOLEAN object, the NUMBER object, the MATH
object, the DATE object, the REGEXP object, the JSON object, and the
Error objects ERROR, EVALERROR, RANGEERROR, REFERENCEERROR, SYNTAXERROR,
TYPEERROR and URIERROR.

ECMAScript also defines a set of built-in _OPERATORS_. ECMAScript
operators include various unary operations, multiplicative operators,
additive operators, bitwise shift operators, relational operators,
equality operators, binary bitwise operators, binary logical operators,
assignment operators, and the comma operator.

ECMAScript syntax intentionally resembles Java syntax. ECMAScript syntax
is relaxed to enable it to serve as an easy-to-use scripting language.
For example, a variable is not required to have its type declared nor
are types associated with properties, and defined functions are not
required to have their declarations appear textually before calls to
them.

Objects

ECMAScript objects are not fundamentally class-based such as those in
C++, Smalltalk, or Java. Instead objects may be created in various ways
including via a literal notation or via _CONSTRUCTORS_ which create
objects and then execute code that initializes all or part of them by
assigning initial values to their properties. Each constructor is a
function that has a property named “PROTOTYPE” that is used to implement
_PROTOTYPE-BASED INHERITANCE_ and _SHARED PROPERTIES_. Objects are
created by using constructors in NEW expressions; for example, NEW
DATE(2009,11) creates a new Date object. Invoking a constructor without
using NEW has consequences that depend on the constructor. For example,
DATE() produces a string representation of the current date and time
rather than an object.

Every object created by a constructor has an implicit reference (called
the object’s _prototype_) to the value of its constructor’s “PROTOTYPE”
property. Furthermore, a prototype may have a non-null implicit
reference to its prototype, and so on; this is called the _prototype
chain_. When a reference is made to a property in an object, that
reference is to the property of that name in the first object in the
prototype chain that contains a property of that name. In other words,
first the object mentioned directly is examined for such a property; if
that object contains the named property, that is the property to which
the reference refers; if that object does not contain the named
property, the prototype for that object is examined next; and so on.

  --
  --

Figure 1 — Object/Prototype Relationships

In a class-based object-oriented language, in general, state is carried
by instances, methods are carried by classes, and inheritance is only of
structure and behaviour. In ECMAScript, the state and methods are
carried by objects, while structure, behaviour, and state are all
inherited.

All objects that do not directly contain a particular property that
their prototype contains share that property and its value. Figure 1
illustrates this:

CF is a constructor (and also an object). Five objects have been created
by using NEW expressions: CF~1~, CF~2~, CF~3~, CF~4~, and CF~5~. Each of
these objects contains properties named q1 and q2. The dashed lines
represent the implicit prototype relationship; so, for example, CF~3~’s
prototype is CF~P~. The constructor, CF, has two properties itself,
named P1 and P2, which are not visible to CF~P~, CF~1~, CF~2~, CF~3~,
CF~4~, or CF~5~. The property named CFP1 in CF~P~ is shared by CF~1~,
CF~2~, CF~3~, CF~4~, and CF~5~ (but not by CF), as are any properties
found in CF~P~’s implicit prototype chain that are not named q1, q2, or
CFP1. Notice that there is no implicit prototype link between CF and
CF~P~.

Unlike most class-based object languages, properties can be added to
objects dynamically by assigning values to them. That is, constructors
are not required to name or assign values to all or any of the
constructed object’s properties. In the above diagram, one could add a
new shared property for CF~1~, CF~2~, CF~3~, CF~4~, and CF~5\ ~by
assigning a new value to the property in CF~P~.

Although ECMAScript objects are not inherently class-based, it is often
convenient to define class-like abstractions based upon a common pattern
of constructor functions, prototype objects, and methods. The ECMAScript
built-in object themselves follow such a class-like pattern. The
ECMAScript language includes syntatic class definitions that permit
programmers to concisely define objects that conform to the same
class-like abstraction pattern used by the built-in objects.

The Strict Variant of ECMAScript

The ECMAScript Language recognizes the possibility that some users of
the language may wish to restrict their usage of some features available
in the language. They might do so in the interests of security, to avoid
what they consider to be error-prone features, to get enhanced error
checking, or for other reasons of their choosing. In support of this
possibility, ECMAScript defines a strict variant of the language. The
strict variant of the language excludes some specific syntactic and
semantic features of the regular ECMAScript language and modifies the
detailed semantics of some features. The strict variant also specifies
additional error conditions that must be reported by throwing error
exceptions in situations that are not specified as errors by the
non-strict form of the language.

The strict variant of ECMAScript is commonly referred to as the _strict
mode_ of the language. Strict mode selection and use of the strict mode
syntax and semantics of ECMAScript is explicitly made at the level of
individual ECMAScript code units. Because strict mode is selected at the
level of a syntactic code unit, strict mode only imposes restrictions
that have local effect within such a code unit. Strict mode does not
restrict or modify any aspect of the ECMAScript semantics that must
operate consistently across multiple code units. A complete ECMAScript
program may be composed for both strict mode and non-strict mode
ECMAScript code units. In this case, strict mode only applies when
actually executing code that is defined within a strict mode code unit.

In order to conform to this specification, an ECMAScript implementation
must implement both the full unrestricted ECMAScript language and the
strict mode variant of the ECMAScript language as defined by this
specification. In addition, an implementation must support the
combination of unrestricted and strict mode code units into a single
composite program.


Terms and definitions

For the purposes of this document, the following terms and definitions
apply.

4.3.

type

set of data values as defined in clause 6 of this specification

4.3.

primitive value

member of one of the types Undefined, Null, Boolean, Number, Symbol, or
String as defined in clause 6

NOTE A primitive value is a datum that is represented directly at the
lowest level of the language implementation.

4.3.

object

member of the type Object

NOTE An object is a collection of properties and has a single prototype
object. The prototype may be the null value.

4.3.

constructor

function object that creates and initializes objects

NOTE The value of a constructor’s “prototype” property is a prototype
object that is used to implement inheritance and shared properties.

4.3.

prototype

object that provides shared properties for other objects

NOTE When a constructor creates an object, that object implicitly
references the constructor’s “PROTOTYPE” property for the purpose of
resolving property references. The constructor’s “PROTOTYPE” property
can be referenced by the program expression _constructor_.PROTOTYPE, and
properties added to an object’s prototype are shared, through
inheritance, by all objects sharing the prototype. Alternatively, a new
object may be created with an explicitly specified prototype by using
the OBJECT.CREATE built-in function.

4.3.

ordinary object

object that has the default behaviour for the essential internal methods
that must be supported by all objects.

4.3.

exotic object

object that has does not have the default behaviour for one or more of
the essential internal methods that must be supported by all objects.

NOTE Any object that is not an ordinary object is an exotic object.

4.3.

standard object

object whose semantics are defined by this specification.

4.3.

built-in object

object supplied by an ECMAScript implementation, independent of the host
environment, that is present at the start of the execution of an
ECMAScript program

NOTE Standard built-in objects are defined in this specification, and an
ECMAScript implementation may specify and define others. A _built-in
constructor_ is a built-in object that is also a constructor.

4.3.

undefined value

primitive value used when a variable has not been assigned a value

4.3.

Undefined type

type whose sole value is the UNDEFINED value

4.3.

null value

primitive value that represents the intentional absence of any object
value

4.3.

Null type

type whose sole value is the null value

4.3.

Boolean value

member of the Boolean type

NOTE There are only two Boolean values, TRUE and FALSE.

4.3.

Boolean type

type consisting of the primitive values TRUE and FALSE

4.3.

Boolean object

member of the Object type that is an instance of the standard built-in
BOOLEAN constructor

NOTE A Boolean object is created by using the BOOLEAN constructor in a
NEW expression, supplying a Boolean value as an argument. The resulting
object has an internal slot whose value is the Boolean value. A Boolean
object can be coerced to a Boolean value.

4.3.

String value

primitive value that is a finite ordered sequence of zero or more 16-bit
unsigned integer

NOTE A String value is a member of the String type. Each integer value
in the sequence usually represents a single 16-bit unit of UTF-16 text.
However, ECMAScript does not place any restrictions or requirements on
the values except that they must be 16-bit unsigned integers.

4.3.

String type

set of all possible String values

4.3.

String object

member of the Object type that is an instance of the standard built-in
STRING constructor

NOTE A String object is created by using the STRING constructor in a NEW
expression, supplying a String value as an argument. The resulting
object has an internal slot whose value is the String value. A String
object can be coerced to a String value by calling the STRING
constructor as a function (21.1.1.1).

4.3.

Number value

primitive value corresponding to a double-precision 64-bit binary format
IEEE 754 value

NOTE A Number value is a member of the Number type and is a direct
representation of a number.

4.3.

Number type

set of all possible Number values including the special “Not-a-Number”
(NaN) value, positive infinity, and negative infinity

4.3.

Number object

member of the Object type that is an instance of the standard built-in
NUMBER constructor

NOTE A Number object is created by using the NUMBER constructor in a NEW
expression, supplying a Number value as an argument. The resulting
object has an internal slot whose value is the Number value. A Number
object can be coerced to a Number value by calling the NUMBER
constructor as a function (20.1.1.1).

4.3.

Infinity

number value that is the positive infinite Number value

4.3.

NaN

number value that is an IEEE 754 “Not-a-Number” value

4.3.

Symbol value

primitive value that represents a unique, non-String Object property
key.

4.3.

Symbol type

set of all possible Symbol values

4.3.

Symbol object

member of the Object type that is an instance of the standard built-in
SYMBOL constructor

4.3.

function

member of the Object type that may be invoked as a subroutine

NOTE In addition to its properties, a function contains executable code
and state that determine how it behaves when invoked. A function’s code
may or may not be written in ECMAScript.

4.3.

built-in function

built-in object that is a function

NOTE Examples of built-in functions include PARSEINT and MATH.EXP. An
implementation may provide implementation-dependent built-in functions
that are not described in this specification.

4.3.

property

association between a key and a value that is a part of an object. The
key be either a String value or a Symbol value.

NOTE Depending upon the form of the property the value may be
represented either directly as a data value (a primitive value, an
object, or a function object) or indirectly by a pair of accessor
functions.

4.3.

method

function that is the value of a property

NOTE When a function is called as a method of an object, the object is
passed to the function as its THIS value.

4.3.

built-in method

method that is a built-in function

NOTE Standard built-in methods are defined in this specification, and an
ECMAScript implementation may specify and provide other additional
built-in methods.

4.3.

attribute

internal value that defines some characteristic of a property

4.3.

own property

property that is directly contained by its object

4.3.

inherited property

property of an object that is not an own property but is a property
(either own or inherited) of the object’s prototype


Organization of This Specification

The remainder of this specification is organized as follows:

Clause 5 defines the notational conventions used throughout the
specification.

Clauses 6−8.5.1 define the execution environment within which ECMAScript
programs operate.

Clauses 10−16 define the actual ECMAScript programming language
includings its syntactic encoding and the execution semantics of all
language features.

Clauses 17−26 define the ECMAScript standard library. It includes the
definitions of all of the standard objects that are available for use by
ECMAScript programs as they execute.



NOTATIONAL CONVENTIONS


Syntactic and Lexical Grammars

Context-Free Grammars

A _context-free grammar_ consists of a number of _productions_. Each
production has an abstract symbol called a _nonterminal_ as its
_left-hand side_, and a sequence of zero or more nonterminal and
_terminal_ symbols as its _right-hand side_. For each grammar, the
terminal symbols are drawn from a specified alphabet.

A _chain production_ is a production that has exactly one nonterminal
symbol on its right-hand side along with zero or more terminal symbols.

Starting from a sentence consisting of a single distinguished
nonterminal, called the _goal symbol_, a given context-free grammar
specifies a _language_, namely, the (perhaps infinite) set of possible
sequences of terminal symbols that can result from repeatedly replacing
any nonterminal in the sequence with a right-hand side of a production
for which the nonterminal is the left-hand side.

The Lexical and RegExp Grammars

A _lexical grammar_ for ECMAScript is given in clause 11. This grammar
has as its terminal symbols Unicode code points that conform to the
rules for _SourceCharacter_ defined in 10.1. It defines a set of
productions, starting from the goal symbol _InputElementDiv_ or
_InputElementRegExp_, that describe how sequences of such code points
are translated into a sequence of input elements.

Input elements other than white space and comments form the terminal
symbols for the syntactic grammar for ECMAScript and are called
ECMAScript _tokens_. These tokens are the reserved words, identifiers,
literals, and punctuators of the ECMAScript language. Moreover, line
terminators, although not considered to be tokens, also become part of
the stream of input elements and guide the process of automatic
semicolon insertion (11.9). Simple white space and single-line comments
are discarded and do not appear in the stream of input elements for the
syntactic grammar. A _MultiLineComment_ (that is, a comment of the form
“/*…*/” regardless of whether it spans more than one line) is likewise
simply discarded if it contains no line terminator; but if a
_MultiLineComment_ contains one or more line terminators, then it is
replaced by a single line terminator, which becomes part of the stream
of input elements for the syntactic grammar.

A _RegExp grammar_ for ECMAScript is given in 21.2.1. This grammar also
has as its terminal symbols the code points as defined by
_SourceCharacter_. It defines a set of productions, starting from the
goal symbol _Pattern_, that describe how sequences of code points are
translated into regular expression patterns.

Productions of the lexical and RegExp grammars are distinguished by
having two colons “::” as separating punctuation. The lexical and RegExp
grammars share some productions.

The Numeric String Grammar

Another grammar is used for translating Strings into numeric values.
This grammar is similar to the part of the lexical grammar having to do
with numeric literals and has as its terminal symbols _SourceCharacter_.
This grammar appears in 7.1.3.1.

Productions of the numeric string grammar are distinguished by having
three colons “:::” as punctuation.

The Syntactic Grammar

The _syntactic grammar_ for ECMAScript is given in clauses 11, 12, 13,
14, and 15. This grammar has ECMAScript tokens defined by the lexical
grammar as its terminal symbols (5.1.2). It defines a set of
productions, starting from the goal symbol _Script_, that describe how
sequences of tokens can form syntactically correct independent
components of an ECMAScript programs.

When a stream of code points is to be parsed as an ECMAScript script, it
is first converted to a stream of input elements by repeated application
of the lexical grammar; this stream of input elements is then parsed by
a single application of the syntactic grammar. The script is
syntactically in error if the tokens in the stream of input elements
cannot be parsed as a single instance of the goal nonterminal _Script_,
with no tokens left over.

Productions of the syntactic grammar are distinguished by having just
one colon “:” as punctuation.

The syntactic grammar as presented in clauses 12, 13, 14 and 15 is
actually not a complete account of which token sequences are accepted as
correct ECMAScript scripts. Certain additional token sequences are also
accepted, namely, those that would be described by the grammar if only
semicolons were added to the sequence in certain places (such as before
line terminator characters). Furthermore, certain token sequences that
are described by the grammar are not considered acceptable if a line
terminator character appears in certain “awkward” places.

In certain cases in order to avoid ambiguities the syntactic grammar
uses generalized productions that permit token sequences that are not
valid ECMAScript scripts. For example, this technique is used for object
literals and object destructuring patterns. In such cases a more
restrictive _supplemental grammar_ is provided that further restricts
the acceptable token sequences. In certain contexts, when explicitly
specific, the input elements corresponding to such a production are
parsed again using a goal symbol of a supplemental grammar. The script
is syntactically in error if the tokens in the stream of input elements
cannot be parsed as a single instance of the supplemental goal symbol,
with no tokens left over.

Grammar Notation

Terminal symbols of the lexical, RegExp, and numeric string grammars,
and some of the terminal symbols of the other grammars, are shown in
FIXED WIDTH font, both in the productions of the grammars and throughout
this specification whenever the text directly refers to such a terminal
symbol. These are to appear in a script exactly as written. All terminal
symbol code points specified in this way are to be understood as the
appropriate Unicode code points from the Basic Latin range, as opposed
to any similar-looking code points from other Unicode ranges.

Nonterminal symbols are shown in _italic_ type. The definition of a
nonterminal (also called a “production”) is introduced by the name of
the nonterminal being defined followed by one or more colons. (The
number of colons indicates to which grammar the production belongs.) One
or more alternative right-hand sides for the nonterminal then follow on
succeeding lines. For example, the syntactic definition:

WhileStatement :

WHILE ( Expression ) Statement

states that the nonterminal _WhileStatement_ represents the token WHILE,
followed by a left parenthesis token, followed by an _Expression_,
followed by a right parenthesis token, followed by a _Statement_. The
occurrences of _Expression_ and _Statement_ are themselves nonterminals.
As another example, the syntactic definition:

ArgumentList :

AssignmentExpression
ArgumentList , AssignmentExpression

states that an _ArgumentList_ may represent either a single
_AssignmentExpression_ or an _ArgumentList_, followed by a comma,
followed by an _AssignmentExpression_. This definition of _ArgumentList_
is recursive, that is, it is defined in terms of itself. The result is
that an _ArgumentList_ may contain any positive number of arguments,
separated by commas, where each argument expression is an
_AssignmentExpression_. Such recursive definitions of nonterminals are
common.

The subscripted suffix “~opt~”, which may appear after a terminal or
nonterminal, indicates an optional symbol. The alternative containing
the optional symbol actually specifies two right-hand sides, one that
omits the optional element and one that includes it. This means that:

VariableDeclaration :

BindingIdentifier Initializer~opt~

is a convenient abbreviation for:

VariableDeclaration :

BindingIdentifier
BindingIdentifier Initializer

and that:

IterationStatement :

FOR ( LexicalDeclaration Expression~opt~ ; Expression~opt~ ) Statement

is a convenient abbreviation for:

IterationStatement :

FOR ( LexicalDeclaration ; Expression~opt~ ) Statement
FOR ( LexicalDeclaration Expression ; Expression~opt~ ) Statement

which in turn is an abbreviation for:

IterationStatement :

FOR ( LexicalDeclaration ; ) Statement
FOR ( LexicalDeclaration ; Expression ) Statement
FOR ( LexicalDeclaration Expression ; ) Statement
FOR ( LexicalDeclaration Expression ; Expression ) Statement

so, in this example, the nonterminal _IterationStatement_ actually has
four alternative right-hand sides.

A production may be parameterized by a subscripted annotation of the
form “~[parameters]~”, which may appear as a suffix to the nonterminal
symbol defined by the production. “~parameters~” may be either a single
name or a comma separated list of names. A parameterized production is
shorthand for a set of productions defining all combinations of the
parameter names, preceeded by an underscore, appended to the
parameterized nonterminal symbol. This means that:

StatementList~[Return]~ :

ReturnStatement
ExpressionStatement

is a convenient abbreviation for:

StatementList :

ReturnStatement
ExpressionStatement

StatementList_Return :

ReturnStatement
ExpressionStatement

and that:

StatementList~[Return,\ In]~ :

ReturnStatement
ExpressionStatement

is an abbreviation for:

StatementList :

ReturnStatement
ExpressionStatement

StatementList_Return :

ReturnStatement
ExpressionStatement

StatementList_In :

ReturnStatement
ExpressionStatement

StatementList_Return_In :

ReturnStatement
ExpressionStatement

Multiple parameters produce a combinatory number of productions, not all
of which are necessarily referenced in a complete grammar.

References to nonterminals on the right hand side of a production can
also be parameterized. For example:

StatementList :

ReturnStatement
ExpressionStatement~[In]~

is equivalent to saying:

StatementList :

ReturnStatement
ExpressionStatement_In

A nonterminal reference may have both a parameter list and an “~opt~”
suffix. For example:

VariableDeclaration :

BindingIdentifier Initializer~[In]opt~

is an abbreviation for:

VariableDeclaration :

BindingIdentifier
BindingIdentifier Initializer_In

Prefixing a parameter name with “~?~” on a right hand side nonterminal
reference makes that parameter value dependent upon the occurrence of
the parameter name on the reference to the current production’s left
hand side symbol. For example:

VariableDeclaration~[In]~ :

BindingIdentifier Initializer~[?In]~

is an abbreviation for:

VariableDeclaration :

BindingIdentifier Initializer

VariableDeclaration_In :

BindingIdentifier Initializer_In

If a right hand side alternative is prefixed with “[+parameter]” that
alternative is only available if the named parameter was used in
referencing the production’s nonterminal symbol. If a right hand side
alternative is prefixed with “[~parameter]” that alternative is only
available if the named parameter was _not_ used in referencing the
production’s nonterminal symbol. This means that:

StatementList~[Return]~ :

[+Return] ReturnStatement
ExpressionStatement

is an abbreviation for:

StatementList :

ExpressionStatement

StatementList_Return :

ReturnStatement
ExpressionStatement

and that

StatementList~[Return]~ :

[~Return] ReturnStatement
ExpressionStatement

is an abbreviation for:

StatementList :

ReturnStatement
ExpressionStatement

StatementList_Return :

ExpressionStatement

When the words “ONE OF” follow the colon(s) in a grammar definition,
they signify that each of the terminal symbols on the following line or
lines is an alternative definition. For example, the lexical grammar for
ECMAScript contains the production:

NonZeroDigit :: ONE OF

1 2 3 4 5 6 7 8 

which is merely a convenient abbreviation for:

NonZeroDigit ::

1
2
3
4
5
6
7
8
9

If the phrase “[empty]” appears as the right-hand side of a production,
it indicates that the production's right-hand side contains no terminals
or nonterminals.

If the phrase “[lookahead ∉ _set_]” appears in the right-hand side of a
production, it indicates that the production may not be used if the
immediately following input token is a member of the given _set_. The
_set_ can be written as a list of terminals enclosed in curly braces.
For convenience, the set can also be written as a nonterminal, in which
case it represents the set of all terminals to which that nonterminal
could expand. If the _set_ consists of a single terminal the phrase
“[lookahead ≠ _terminal_]” may be used.

For example, given the definitions

DecimalDigit :: ONE OF

0 1 2 3 4 5 6 7 8 

DecimalDigits ::

DecimalDigit
DecimalDigits DecimalDigit

the definition

LookaheadExample ::

N [lookahead ∉ {1, 3, 5, 7, 9}] DecimalDigits
DecimalDigit [lookahead ∉ DecimalDigit ]

matches either the letter N followed by one or more decimal digits the
first of which is even, or a decimal digit not followed by another
decimal digit.

If the phrase “[no _LineTerminator_ here]” appears in the right-hand
side of a production of the syntactic grammar, it indicates that the
production is _a restricted production_: it may not be used if a
_LineTerminator_ occurs in the input stream at the indicated position.
For example, the production:

ThrowStatement :

THROW [no LineTerminator here] Expression ;

indicates that the production may not be used if a _LineTerminator_
occurs in the script between the THROW token and the _Expression_.

Unless the presence of a _LineTerminator_ is forbidden by a restricted
production, any number of occurrences of _LineTerminator_ may appear
between any two consecutive tokens in the stream of input elements
without affecting the syntactic acceptability of the script.

The lexical grammar has multiple goal symbols and the appropriate goal
symbol to use depends upon the syntactic grammar context. If a phrase of
the form “[Lexical goal _LexicalGoalSymbol_]” appears on the
right-hand-side of a syntactic production then the next token must be
lexically recognized using the indicated goal symbol. In the absence of
such a phrase the default lexical goal symbol is used.

When an alternative in a production of the lexical grammar or the
numeric string grammar appears to be a multi-code point token, it
represents the sequence of code points that would make up such a token.

The right-hand side of a production may specify that certain expansions
are not permitted by using the phrase “BUT NOT” and then indicating the
expansions to be excluded. For example, the production:

Identifier ::

IdentifierName BUT NOT ReservedWord

means that the nonterminal _Identifier_ may be replaced by any sequence
of code points that could replace _IdentifierName_ provided that the
same sequence of code points could not replace _ReservedWord_.

Finally, a few nonterminal symbols are described by a descriptive phrase
in sans-serif type in cases where it would be impractical to list all
the alternatives:

SourceCharacter ::

any Unicode code point


Algorithm Conventions

The specification often uses a numbered list to specify steps in an
algorithm. These algorithms are used to precisely specify the required
semantics of ECMAScript language constructs. The algorithms are not
intended to imply the use of any specific implementation technique. In
practice, there may be more efficient algorithms available to implement
a given feature.

Algorithms may be explicitly parameterized, in which case the names and
usage of the parameters must be provided as part of the algorithm’s
definition. In order to facilitate their use in multiple parts of this
specification, some algorithms, called _abstract_ _operations_, are
named and written in parameterized functional form so that they may be
referenced by name from within other algorithms.

Algorithms may be associated with productions of one of the ECMAScript
grammars. A production that has multiple alternative definitions will
typically have a distinct algorithm for each alternative. When an
algorithm is associated with a grammar production, it may reference the
terminal and nonterminal symbols of the production alternative as if
they were parameters of the algorithm. When used in this manner,
nonterminal symbols refer to the actual alternative definition that is
matched when parsing the script souce code.

When an algorithm is associated with a production alternative, the
alternative is typically shown without any “[ ]” grammar annotations.
Such annotations should only affect the syntactic recognition of the
alternative and have no effect on the associated semantics for the
alternative.

Unless explicitly specified otherwise, all chain productions have an
implicit associated definition for every algorithm that might be applied
to that production’s left-hand side nonterminal. The implicit definition
simply reapplies the same algorithm name with the same parameters, if
any, to the chain production’s sole right-hand side nonterminal and then
result. For example, assume there is a production:

Block :

{ StatementList }

but there is no corresponding Evaluation algorithm that is explicitly
specified for that production. If in some algorithm there is a statement
of the form: “Return the result of evaluating _Block_” it is implicit
that an Evaluation algorithm exists of the form:

RUNTIME SEMANTICS: EVALUATION

_Block_ : { _StatementList_ }

1.  Return the result of evaluating _StatementList_.

For clarity of expression, algorithm steps may be subdivided into
sequential substeps. Substeps are indented and may themselves be further
divided into indented substeps. Outline numbering conventions are used
to identify substeps with the first level of substeps labelled with
lower case alphabetic characters and the second level of substeps
labelled with lower case roman numerals. If more than three levels are
required these rules repeat with the fourth level using numeric labels.
For example:

1.  Top-level step

    a.  Substep.

    b.  Substep.

        i.  Subsubstep.

            1.  Subsubsubstep

                a.  Subsubsubsubstep

                    i.  Subsubsubsubsubstep

A step or substep may be written as an “if” predicate that conditions
its substeps. In this case, the substeps are only applied if the
predicate is true. If a step or substep begins with the word “else”, it
is a predicate that is the negation of the preceding “if” predicate step
at the same level.

A step may specify the iterative application of its substeps.

A step may assert an invariant condition of its algorithm. Such
assertions are used to make explicit algorithmic invariants that would
otherwise be implicit. Such assertions add no additional semantic
requirements and hence need not be checked by an implementation. They
are used simply to clarify algorithms.

Mathematical operations such as addition, subtraction, negation,
multiplication, division, and the mathematical functions defined later
in this clause should always be understood as computing exact
mathematical results on mathematical real numbers, which do not include
infinities and do not include a negative zero that is distinguished from
positive zero. Algorithms in this standard that model floating-point
arithmetic include explicit steps, where necessary, to handle infinities
and signed zero and to perform rounding. If a mathematical operation or
function is applied to a floating-point number, it should be understood
as being applied to the exact mathematical value represented by that
floating-point number; such a floating-point number must be finite, and
if it is +0 or −0 then the corresponding mathematical value is simply 0.

The mathematical function abs(_x_) produces the absolute value of _x_,
which is −_x_ if _x_ is negative (less than zero) and otherwise is _x_
itself.

The mathematical function sign(_x_) produces 1 if _x_ is positive and −1
if _x_ is negative. The sign function is not used in this standard for
cases when _x_ is zero.

The mathematical function min(_x_~1~, _x_~2~, ..., _x_~n~) produces the
mathematically smallest of _x_~1~ through _x_~n~.

The notation “_x_ modulo _y_” (_y_ must be finite and nonzero) computes
a value _k_ of the same sign as _y_ (or zero) such that abs(_k_) <
abs(_y_) and _x_−_k_ = _q_ × _y_ for some integer _q_.

The mathematical function floor(_x_) produces the largest integer
(closest to positive infinity) that is not larger than _x_.

NOTE floor(_x_) = _x_−(_x_ modulo 1).


Static Semantic Rules

Context-free grammars are not sufficiently powerful to express all the
rules that define whether a stream of input elements form a valid
ECMAScript script that may be evaluated. In some situations additional
rules are needed that may be expressed using either ECMAScript algorithm
conventions or prose requirements. Such rules are always associated with
a production of a grammar and are called the _static semantics_ of the
production.

Static Semantic Rules have names and typically are defined using an
algorithm. Named Static Semantic Rules are associated with grammar
productions and a production that has multiple alternative definitions
will typically have for each alternative a distinct algorithm for each
applicable named static semantic rule.

Unless otherwise specified every grammar production alternative in this
specification implicitly has a definition for a static semantic rule
named Contains which takes an argument named _symbol_ whose value is a
terminal or nonterminal of the grammar that includes the associated
production. The default definition of Contains is:

1.  For each terminal and nonterminal grammar symbol, _sym_, in the
    definition of this production do

    a.  If _sym_ is the same grammar symbol as _symbol_, return TRUE.

    b.  If _sym_ is a nonterminal, then

        i.  Let _contained_ be the result of _sym_ Contains _symbol_.

        ii. If _contained_ is TRUE, return TRUE.

2.  Return FALSE.

The above definition is explicitly over-ridden for specific productions.

A special kind of static semantic rule is an Early Error Rule. Early
error rules define early error conditions (see clause 16) that are
associated with specific grammar productions. Evaluation of most early
error rules are not explicitly invoked within the algorithms of this
specification. A conforming implementation must, prior to the first
evaluation of a _Script_, validate all of the early error rules of the
productions used to parse that _Script_. If any of the early error rules
are violated the _Script_ is invalid and cannot be evaluated.



ECMASCRIPT DATA TYPES AND VALUES 


Algorithms within this specification manipulate values each of which has
an associated type. The possible value types are exactly those defined
in this clause. Types are further subclassified into ECMAScript language
types and specification types.

Within this specification, the notation “Type(_x_)” is used as shorthand
for “the type of _x_” where “type” refers to the ECMAScript language and
specification types defined in this clause.


ECMAScript Language Types

An ECMAScript language type corresponds to values that are directly
manipulated by an ECMAScript programmer using the ECMAScript language.
The ECMAScript language types are Undefined, Null, Boolean, String,
Symbol, Number, and Object. An ECMAScript language value is a value that
is characterized by an ECMAScript language type.

The Undefined Type

The Undefined type has exactly one value, called UNDEFINED. Any variable
that has not been assigned a value has the value UNDEFINED.

The Null Type

The Null type has exactly one value, called NULL.

The Boolean Type

The Boolean type represents a logical entity having two values, called
TRUE and FALSE.

The String Type

The String type is the set of all finite ordered sequences of zero or
more 16-bit unsigned integer values (“elements”). The String type is
generally used to represent textual data in a running ECMAScript
program, in which case each element in the String is treated as a UTF-16
code unit value. Each element is regarded as occupying a position within
the sequence. These positions are indexed with nonnegative integers. The
first element (if any) is at index 0, the next element (if any) at index
1, and so on. The length of a String is the number of elements (i.e.,
16-bit values) within it. The empty String has length zero and therefore
contains no elements.

Where ECMAScript operations interpret String values, each element is
interpreted as a single UTF-16 code unit. However, ECMAScript does not
place any restrictions or requirements on the sequence of code units in
a String value, so they may be ill-formed when interpreted as UTF-16
code unit sequences. Operations that do not interpret String contents
treat them as sequences of undifferentiated 16-bit unsigned integers. No
operations ensure that Strings are in a normalized form. Only operations
that are explicitly specified to be language or locale sensitive produce
language-sensitive results

NOTE The rationale behind this design was to keep the implementation of
Strings as simple and high-performing as possible. If ECMAScript source
code is in Normalized Form C, string literals are guaranteed to also be
normalized, as long as they do not contain any Unicode escape sequences.

Some operations interpret String contents as UTF-16 encoded Unicode code
points. In that case the interpretation is:

-   A code unit in the range 0 to 0xD7FF or in the range 0xE000 to
    0xFFFF is interpreted as a code point with the same value.

-   A sequence of two code units, where the first code unit _c1_ is in
    the range 0xD800 to 0xDBFF and the second code unit _c2_ is in the
    range 0xDC00 to 0xDFFF, is a surrogate pair and is interpreted as a
    code point with the value (_c1_ - 0xD800) × 0x400 + (_c2_ –
    0xDC00) + 0x10000.

-   A code unit that is in the range 0xD800 to 0xDFFF, but is not part
    of a surrogate pair, is interpreted as a code point with the same
    value.

The Symbol Type

The Symbol type is the set of all non-String values that may be used as
the key of an Object property (6.1.7).

Each possible Symbol values is unique and immutable.

Each Symbol value immutably holds an associated value called
[[Description]] that is either UNDEFINED or a String value.

Well-Known Symbols

Well-known symbols are built-in Symbol values that are explicitly
referenced by algorithms of this specification. They are typically used
as the keys of properties whose values serve as extension points of a
specification algorithm. Unless otherwise specified, well-known symbols
values are shared by all Code Realms (8.1.2.5).

Within this specification a well-known symbol is referred to by using a
notation of the form @@name, where “name” is one of the values listed in
Table 1.

Table 1— Well-known Symbols

  ----------------------- ----------------------------- ------------------------------------------------------------------------------------------------------------------------------------------------------------------
  _SPECIFICATION NAME _   _[[DESCRIPTION]]_             _VALUE AND PURPOSE_
  @@create                "SYMBOL.CREATE"               A method used to allocate an object. Called from the [[Construct]] internal method.
  @@hasInstance           "SYMBOL.HASINSTANCE"          A method that determines if a constructor object recognizes an object as one of the constructor’s instances. Called by the semantics of the INSTANCEOF operator.
  @@isConcatSpreadable    "SYMBOL.ISCONCATSPREADABLE"   A Boolean value that if true indicates that an object should be flatten to its array elements by Array.prototype.concat.
  @@isRegExp              "SYMBOL.ISREGEXP"             A Boolean value that if true indicates that an object may be used as a regular expression.
  @@iterator              "SYMBOL.ITERATOR"             A method that returns the default iterator for an object. Called by the semantics of the for-of statement.
  @@toPrimitive           "SYMBOL.TOPRIMITIVE"          A method that converts an object to a corresponding primitive value. Called by the ToPrimitive abstract operation.
  @@toStringTag           "SYMBOL.TOSTRINGTAG"          A string value that is used in the creation of the default string description of an object. Called by the built-in method Object.prototype.toString.
  @@unscopables           "SYMBOL.UNSCOPABLES"          An Array of string values that are property names that are excluded from the with environment bindings of the associated objects.
  ----------------------- ----------------------------- ------------------------------------------------------------------------------------------------------------------------------------------------------------------

The Number Type

The Number type has exactly 18437736874454810627 (that is,
2^64^−2^53^+3) values, representing the double-precision 64-bit format
IEEE 754 values as specified in the IEEE Standard for Binary
Floating-Point Arithmetic, except that the 9007199254740990 (that is,
2^53^−2) distinct “Not-a-Number” values of the IEEE Standard are
represented in ECMAScript as a single special NAN value. (Note that the
NAN value is produced by the program expression NAN.) In some
implementations, external code might be able to detect a difference
between various Not-a-Number values, but such behaviour is
implementation-dependent; to ECMAScript code, all NaN values are
indistinguishable from each other.

There are two other special values, called POSITIVE INFINITY and
NEGATIVE INFINITY. For brevity, these values are also referred to for
expository purposes by the symbols +∞ and −∞, respectively. (Note that
these two infinite Number values are produced by the program expressions
+INFINITY (or simply INFINITY) and -INFINITY.)

The other 18437736874454810624 (that is, 2^64^−2^53^) values are called
the finite numbers. Half of these are positive numbers and half are
negative numbers; for every finite positive Number value there is a
corresponding negative value having the same magnitude.

Note that there is both a POSITIVE ZERO and a NEGATIVE ZERO. For
brevity, these values are also referred to for expository purposes by
the symbols +0 and −0, respectively. (Note that these two different zero
Number values are produced by the program expressions +0 (or simply 0)
and -0.)

The 18437736874454810622 (that is, 2^64^−2^53^−2) finite nonzero values
are of two kinds:

18428729675200069632 (that is, 2^64^−2^54^) of them are normalized,
having the form

  _s_ × _m_ × 2_^e^_

where _s_ is +1 or −1, _m_ is a positive integer less than 2^53^ but not
less than 2^52^, and _e_ is an integer ranging from −1074 to 971,
inclusive.

The remaining 9007199254740990 (that is, 2^53^−2) values are
denormalized, having the form

  _s_ × _m_ × 2_^e^_

where _s_ is +1 or −1, _m_ is a positive integer less than 2^52^, and
_e_ is −1074.

Note that all the positive and negative integers whose magnitude is no
greater than 2^53^ are representable in the Number type (indeed, the
integer 0 has two representations, +0 and -0).

A finite number has an _odd significand_ if it is nonzero and the
integer _m_ used to express it (in one of the two forms shown above) is
odd. Otherwise, it has an _even significand_.

In this specification, the phrase “the Number value for _x_” where _x_
represents an exact nonzero real mathematical quantity (which might even
be an irrational number such as π) means a Number value chosen in the
following manner. Consider the set of all finite values of the Number
type, with −0 removed and with two additional values added to it that
are not representable in the Number type, namely 2^1024^ (which is +1 ×
2^53^ × 2^971^) and −2^1024^ (which is −1 × 2^53^ × 2^971^). Choose the
member of this set that is closest in value to _x_. If two values of the
set are equally close, then the one with an even significand is chosen;
for this purpose, the two extra values 2^1024^ and −2^1024^ are
considered to have even significands. Finally, if 2^1024^ was chosen,
replace it with +∞; if −2^1024^ was chosen, replace it with −∞; if +0
was chosen, replace it with −0 if and only if _x_ is less than zero; any
other chosen value is used unchanged. The result is the Number value for
_x_. (This procedure corresponds exactly to the behaviour of the IEEE
754 “round to nearest” mode.)

Some ECMAScript operators deal only with integers in the range −2^31^
through 2^31^−1, inclusive, or in the range 0 through 2^32^−1,
inclusive. These operators accept any value of the Number type but first
convert each such value to one of 2^32^ integer values. See the
descriptions of the ToInt32 and ToUint32 operators in 7.1.5 and 7.1.6,
respectively.

The Object Type

An Object is logically a collection of properties. Each property is
either a data property, or an accessor property:

-   A _data property_ associates a key value with an ECMAScript language
    value and a set of Boolean attributes.

-   An _accessor property_ associates a key value with one or two
    accessor functions, and a set of Boolean attributes. The accessor
    functions are used to store or retrieve an ECMAScript language value
    that is associated with the property.

Properties are identified using key values. A key value is either an
ECMAScript String value or a Symbol value. All String and Symbol values,
including the empty string, are valid as property keys.

An _integer index_ is a String-valued property key that is a canonical
numeric String (see 7.1.16) and whose numeric value is either +0 or a
positive integer ≤ 2^53^−1. An _array index_ is an integer index whose
numeric value _i_ is in the range +0 ≤ _i_ < 2^32^−1.

Property keys are used to access properties and their values. There are
two kinds of access for properties: _get_ and _set_, corresponding to
value retrieval and assignment, respectively. The properties accessible
via get and set access includes both _own properties_ that are a direct
part of an object and _inherited properties_ which are provided by
another associated object via a property inheritance relationship.
Inherited properties may be either own or inherited properties of the
associated object. Each own properties of an object must each have a key
value that is distinct from the key values of the other own properties
of that object.

All objects are logically collections of properties, but there are
multiple forms of objects that differ in their semantics for accessing
and manipulating their properties. O_rdinary objects_ are the most
common form of objects and have the default object semantics. An _exotic
object_ is any form of object whose property semantics differ in any way
from the default semantics.

Property Attributes

Attributes are used in this specification to define and explain the
state of Object properties. A data property associates a key value with
the attributes listed in Table 2.

Table 2 — Attributes of a Data Property

  _ATTRIBUTE NAME_   _VALUE DOMAIN_                 _DESCRIPTION_
  ------------------ ------------------------------ ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  [[Value]]          Any ECMAScript language type   The value retrieved by a get access of the property.
  [[Writable]]       Boolean                        If FALSE, attempts by ECMAScript code to change the property’s [[Value]] attribute using [[Set]] will not succeed.
  [[Enumerable]]     Boolean                        If TRUE, the property will be enumerated by a for-in enumeration (see 13.6.3.6). Otherwise, the property is said to be non-enumerable.
  [[Configurable]]   Boolean                        If FALSE, attempts to delete the property, change the property to be an accessor property, or change its attributes (other than [[Value]], or changing [[Writable]] to FALSE) will fail.

An accessor property associates a key value with the attributes listed
in Table 3.

Table 3 — Attributes of an Accessor Property

  _ATTRIBUTE NAME_   _VALUE DOMAIN_          _DESCRIPTION_
  ------------------ ----------------------- ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  [[Get]]            Object _or_ Undefined   If the value is an Object it must be a function Object. The function’s [[Call]] internal method (Table 6) is called with an empty arguments list to retrieve the property value each time a get access of the property is performed.
  [[Set]]            Object _or_ Undefined   If the value is an Object it must be a function Object. The function’s [[Call]] internal method (Table 6) is called with an arguments list containing the assigned value as its sole argument each time a set access of the property is performed. The effect of a property's [[Set]] internal method may, but is not required to, have an effect on the value returned by subsequent calls to the property's [[Get]] internal method.
  [[Enumerable]]     Boolean                 If TRUE, the property is to be enumerated by a for-in enumeration (see 13.6.3.6). Otherwise, the property is said to be non-enumerable.
  [[Configurable]]   Boolean                 If FALSE, attempts to delete the property, change the property to be a data property, or change its attributes will fail.

If the initial values of a property’s attributes are not explicitly
specified by this specification, the default value defined in Table 4 is
used.

Table 4 — Default Attribute Values

  ATTRIBUTE NAME     DEFAULT VALUE
  ------------------ ---------------
  [[Value]]          UNDEFINED
  [[Get]]            UNDEFINED
  [[Set]]            UNDEFINED
  [[Writable]]       FALSE
  [[Enumerable]]     FALSE
  [[Configurable]]   FALSE

Object Internal Methods and Internal Slots

The actual semantics of objects, in ECMAScript, are specified via
algorithms called _internal methods_. Each object in an ECMAScript
engine is associated with a set of internal methods that defines its
runtime behaviour. These internal methods are not part of the ECMAScript
language. They are defined by this specification purely for expository
purposes. However, each object within an implementation of ECMAScript
must behave as specified by the internal methods associated with it. The
exact manner in which this is accomplished is determined by the
implementation.

Internal method names are polymorphic. This means that different object
values may perform different algorithms when a common internal method
name is invoked upon them. If, at runtime, the implementation of an
algorithm attempts to use an internal method of an object that the
object does not support, a TYPEERROR exception is thrown.

Internal slots correspond to internal state that is associated with
objects and used by various ECMAScript specification algorithms.
Internal slots are not object properties and they are not inherited.
Depending upon the specific internal slot specification, such state may
consist of values of any ECMAScript language type or of specific ECMA
specification type values. Unless explicitly specified otherwise,
internal slots are allocated as part of the process of creating an
object and may not be dynamically added to an object. Unless specified
otherwise, the initial value of an internal slot is the value UNDEFINED.
Various algorithms within this specification create objects that have
internal slots. However, the ECMAScript language provides no direct way
to associate internal slots with an object.

Internal methods and internal slots are identified within this
specification using names enclosed in double square brackets [[ ]].

Table 5 summarizes the _essential internal methods_ used by this
specification that are applicable to all objects created or manipulated
by ECMAScript code. Every object must have algorithms for all of the
essential internal methods. However, all objects do not necessarily use
the same algorithms for those methods.

The “Signature” column of Table 5 and other similar tables describes the
invocation pattern for each internal method. The invocation pattern
always includes a parenthesized list of descriptive parameter names. If
a parameter name is the same as an ECMAScript type name then the name
describes the required type of the parameter value. If an internal
method explicitly returns a value, its parameter list is followed by the
symbol “→” and the type name of the returned value. The type names used
in signatures refer to the types defined in clause 6 augmented by the
following additional names. “_any_” means the value may be any
ECMAScript language type. An internal method implicitly returns a
Completion Record as described in 6.2.2. In addition to its parameters,
an internal method always has access to the object upon which it is
invoked as a method.

Table 5 — Essential Internal Methods

  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  _INTERNAL METHOD_       _SIGNATURE_                                       _DESCRIPTION_
  ----------------------- ------------------------------------------------- -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  [[GetPrototypeOf]]      ()_→_Object or Null                               Determine the object that provides inherited properties for this object. A NULL value indicates that there are no inherited properties.

  [[SetPrototypeOf]]      (_Object_ or Null)_→_Boolean                      Associate with an object another object that provides inherited properties. Passing NULL indicates that there are no inherited properties. Returns TRUE indicating that the operation was completed successfully or FALSE indicating that the operation was not successful.

  [[IsExtensible]]        ( )_→_Boolean                                     Determine whether it is permitted to add additional properties to an object.

  [[PreventExtensions]]   ( )_→_Boolean                                     Control whether new properties may be added to an object. Returns TRUE indicating that the operation was completed successfully or FALSE indicating that the operation was not successful.

  [[GetOwnProperty]]      (_propertyKey_) →                                 Returns a Property Descriptor for the own property of this object whose key is _propertyKey_, or UNDEFINED if no such property exists.
                                                                            
                          Undefined or Property Descriptor                  

  [[HasProperty]]         (_propertyKey_) _→_ Boolean                       Returns a Boolean value indicating whether the object already has either an own or inherited property whose key is _propertyKey_.

  [[Get]]                 (_propertyKey_, _Receiver_) _→ any_               Retrieve the value of an object’s property using the _propertyKey_ parameter. If any ECMAScript code must be executed to retrieve the property value, _Receiver_ is used as the THIS value when evaluating the code.

  [[Set]]                 (_propertyKey_,_value_, _Receiver_) _→ Boolean_   Try to set the value of an object’s property indentified by _propertyKey_ to _value_. If any ECMAScript code must be executed to set the property value, _Receiver_ is used as the THIS value when evaluating the code. Returns TRUE indicating that the property value was set or FALSE indicating that it could not be set.

  [[Delete]]              (_propertyKey_) _→_ Boolean                       Removes the own property indentified by the _propertyKey_ parameter from the object. Return FALSE if the property was not deleted and is still present. Return TRUE if the property was deleted or was not present.

  [[DefineOwnProperty]]   (_propertyKey, PropertyDescriptor_) _→_ Boolean   Creates or alters the named own property to have the state described by a Property Descriptor. Returns TRUE indicating that the property was successfully created/updated or FALSE indicating that the property could not be created or updated.

  [[Enumerate]]           ()_→_Object                                       Returns an iterator object over the keys of the string-keyed enumerable properties of the object.

  [[OwnPropertyKeys]]     ()_→_Array of propertyKey                         Returns an Array object whose elements are all of the own property keys for the object.
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Table 6 summarizes additional essential internal methods that are
supported by objects that may be called as functions.

Table 6 — Additional Essential Internal Methods of Function Objects

  _INTERNAL METHOD_   _SIGNATURE_                          _DESCRIPTION_
  ------------------- ------------------------------------ ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  [[Call]]            (_any_, a List of _any_) _→_ _any_   Executes code associated with the object. Invoked via a function call expression. The arguments to the internal method are a THIS value and a list containing the arguments passed to the function by a call expression. Objects that implement this internal method are _callable_.
  [[Construct]]       (a List of _any_) _→_ Object         Creates an object. Invoked via the NEW operator. The arguments to the internal method are the arguments passed to the NEW operator. Objects that implement this internal method are called _constructors_. A Function object is not necessarily a constructor and such non-constructor Function objects do not have a [[Construct]] internal method.

The semantics of the essential internal method for ordinary objects and
standard exotic objects are specified in clause 8.5.1. If any specified
use of an exotic object's internal methods is not supported by an
implementation, that usage must throw a TYPEERROR exception when
attempted.

Invariants of the Essential Internal Methods

The Internal Methods of Objects of an ECMAScript engine must conform to
the list of invariants specified below. Ordinary ECMAScript Objects as
well as all standard exotic objects in this specification maintain these
invariants. ECMAScript Proxy objects maintain these invariants by means
of runtime checks on the result of traps invoked on the [[ProxyHandler]]
object.

Any implementation provided exotic objects must also maintain these
invariants for those objects. Violation of these invariants may cause
ECMAScript code to have unpredictable behaviour and create security
issues. However, violation of these invariants must never compromise the
memory safety of an implementation.

Definitions:

● The _target_ of an internal method is the object the internal method
is called upon.

● A target is _non-extensible_ if it has been observed to return false
from its [[IsExtensible]] internal method, or true from its
[[PreventExtensions]] internal method.

● A _non-existent_ property is a property that does not exist as an own
property on a non-extensible target.

● All references to _SameValue_ are according to the definition of
SameValue algorithm specified in 7.2.3.

[[GETPROTOTYPEOF]] ( )

● The Type of the return value must be either Object or Null.

● If target is non-extensible, and [[GetPrototypeOf]] returns a value v,
then any future calls to [[GetPrototypeOf]] should return the SameValue
as v.

● An object’s prototype chain must have finite length (that is, starting
from any object, recursively applying the [[GetPrototypeOf]] internal
method to its result must eventually lead to the value null.

[[SETPROTOTYPEOF]] (V)

● The Type of the return value must be Boolean.

● If target is non-extensible, [[SetPrototypeOf]] must return false,
unless V is the SameValue as the target’s observed [[GetPrototypeOf]]
value.

[[PREVENTEXTENSIONS]] ( )

● The Type of the return value must be Boolean.

● If [[PreventExtensions]] returns true, all future calls to
[[IsExtensible]] on the target must return false and the target is now
considered non-extensible.

[[GETOWNPROPERTY]] (P)

● The Type of the return value must be either Object or Undefined.

● If the Type of the return value is Object, that object must be a
complete property descriptor (see 6.2.4.6).

● If a property is described as a data property and it may return
different values over time, then either or both of the Desc.[[Writable]]
and Desc.[[Configurable]] attributes must be true even if no mechanism
to change the value is exposed via the other internal methods.

● If a property P is described as a data property with Desc.[[Value]]
equal to v and Desc.[[Writable]] and Desc.[[Configurable]] are both
false, then the SameValue must be returned for the Desc.[[Value]]
attribute of the property on all future calls to [[GetOwnProperty]] ( P
).

● If P’s attributes other than [[Writable]] may change over time or if
the property might disappear, then P’s [[Configurable]] attribute must
be true.

● If the [[Writable]] attribute may change from false to true, then the
[[Configurable]] attribute must be true.

● If the target is non-extensible and P is non-existent, then all future
calls to [[GetOwnProperty]] (P) on the target must describe P as
non-existent (i.e. [[GetOwnProperty]] (P) must return undefined)

[[DEFINEOWNPROPERTY]] (P, DESC)

● The Type of the return value must be Boolean.

● [[DefineOwnProperty]] must return false if P has previously been
observed as a non-configurable own property of the target, unless
either:

  1. P is a non-configurable writable own data property. A
  non-configurable writable data property can be changed into a
  non-configurable non-writable data property.

2. All attributes in Desc are the SameValue as P’s attributes.

● [[DefineOwnProperty]] (P, Desc) must return false if target is
non-extensible and P is a non-existent own property. That is, a
non-extensible target object cannot be extended with new properties.

[[HASPROPERTY]] ( P )

● The Type of the return value must be Boolean.

● If P was previously observed as a non-configurable data or accessor
own property of the target, [[HasProperty]] must return true.

[[GET]] (P, RECEIVER)

● If P was previously observed as a non-configurable, non-writable own
data property of the target with value v, then [[Get]] must return the
SameValue.

● If P was previously observed as a non-configurable own accessor
property of the target whose [[Get]] attribute is undefined, the [[Get]]
operation must return undefined.

[[SET]] ( P, V, RECEIVER)

● The Type of the return value must be Boolean.

● If P was previously observed as a non-configurable, non-writable own
data property of the target, then [[Set]] must return false unless V is
the SameValue as P’s [[Value]] attribute.

● If P was previously observed as a non-configurable own accessor
property of the target whose [[Set]] attribute is undefined, the [[Set]]
operation must return false.

[[DELETE]] ( P )

● The Type of the return value must be Boolean.

● If P was previously observed to be a non-configurable own data or
accessor property of the target, [[Delete]] must return false.

[[ENUMERATE]] ( )

● The Type of the return value must be Object.

[[OWNPROPERTYKEYS]] ( )

● The Type of the return value must be Object.

● The return value must be an exotic Array object.

● The returned array must contain at least the keys of all
non-configurable own properties that have previously been observed.

● If the object is non-extensible, the returned array must contain only
the keys of all own properties of the object that are observable using
[[GetOwnProperty]].

[[CONSTRUCT]] ( )

● The Type of the return value must be Object.

Well-Known Intrinsic Objects

Well-known intrinsics are built-in objects that are explicitly
referenced by the algorithms of this specification and which usually
have Realm specific identities. Unless otherwise specified each
intrinsic object actually corresponds to a set of similar objects, one
per Realm.

Within this specification a reference such as %name% means the intrinsic
object, associated with the current Realm, corresponding to the name.
Determination of the current Realm and its intrinsics is described in
8.1.2.5. The well-known intrinsics are listed in Table 7.

Table 7 — Well-known Intrinsic Objects

  --------------------------- --------------- --------------------------------------------------------------------------------------------------
  _INTRINSIC NAME_            _GLOBAL NAME_   _ECMASCRIPT LANGUAGE ASSOCIATION_

                                              

  %ObjectPrototype%                           The initial value of the "PROTOTYPE" data property of the intrinsic %Object%. (19.1.3)

  %ThrowTypeError%                            A function that, when called, throws a TypeError exception.

  %FunctionPrototype%                         The initial value of the "prototype" data property of the intrinsic %Function%.

  %Object%                    "Object"        The Object constructor (19.1.1)

  %ObjProto_toString%                         The initial value of the "TOSTRING" data property of the intrinsic %ObjectPrototype%. (19.1.3.6)

  %Function%                  "FUNCTION"      The FUNCTION constructor (19.2.1)

                                              

  %Array%                     "ARRAY"         The ARRAY constructor (22.1.1)

  %ArrayPrototype%                            The initial value of the "PROTOTYPE" data property of the intrinsic %Array%.

  %ArrayProto_values%                         The initial value of the "VALUES" data property of the intrinsic %ArrayPrototype%. (22.1.3.29)

  %ArrayIteratorPrototype%                    The prototype object used for
                                              Iterator objects created by the CreateArrayIterator abstract operation.

  %String%                    "STRING"        The STRING constructor (21.1.1)

  %StringPrototype%                           The initial value of the "PROTOTYPE" data property of the intrinsic %String%.

  %StringIteratorPrototype%                   The prototype object used for
                                              Iterator objects created by the CreateStringIterator abstract operation

  %Boolean%                   "BOOLEAN"       The initial value of the global object property named "BOOLEAN".

  %BooleanPrototype%                          The initial value of the "PROTOTYPE" data property of the intrinsic %Boolean%.

  %Number%                    "NUMBER"        The initial value of the global object property named "NUMBER".

  %NumberPrototype%                           The initial value of the "PROTOTYPE" data property of the intrinsic %Number%.

  %Date%                      "DATE"          The initial value of the global object property named "DATE".

  %DatePrototype%                             The initial value of the "PROTOTYPE" data property of the intrinsic %Date%.

  %RegExp%                    "REGEXP"        The initial value of the global object property named "REGEXP".

  %RegExpPrototype%                           The initial value of the "PROTOTYPE" data property of the intrinsic %RegExp%.

  %Map%                       "MAP"           The initial value of the global object property named "MAP".

  %MapPrototype%                              The initial value of the "PROTOTYPE" data property of the intrinsic %Map%.

  %MapIteratorPrototype%                      The prototype object used for
                                              Iterator objects created by the CreateMapIterator abstract operation

  %WeakMap%                   "WEAKMAP"       The initial value of the global object property named "WEAKMAP".

  %WeakMapPrototype%                          The initial value of the "PROTOTYPE" data property of the intrinsic %WeakMap%.

  %Set%                       "SET"           The initial value of the global object property named "SET".

  %SetPrototype%                              The initial value of the "PROTOTYPE" data property of the intrinsic %Set%.

  %WeakSet%                   "WEAKSET"       The initial value of the global object property named "WEAKSET".

  %WeakSetPrototype%                          The initial value of the "PROTOTYPE" data property of the intrinsic %WeakSet%.

  %SetIteratorPrototype%                      The prototype object used for
                                              Iterator objects created by the CreateSetIterator abstract operation

  %GeneratorFunction%                         The constructor of generator functions.

  %Generator%                                 The initial value of the PROTOTYPE property of the %GeneratorFunction intrinsic

  %GeneratorPrototype%                        The initial value of the PROTOTYPE property of the %Generator% intrinsic

  %Error%                                     

  %EvalError%                                 

  %RangeError%                                

  %ReferenceError%                            

  %SyntaxError%                               

  %TypeError%                                 

  %URIError%                                  

                                              

  %ErrorPrototype%                            

  %EvalErrorPrototype%                        

  %RangeErrorPrototype%                       

  %ReferenceErrorPrototype%                   

  %SyntaxErrorPrototype%                      

  %TypeErrorPrototype%                        

  %URIErrorPrototype%                         

  %ArrayBuffer%                               

  %ArrayBufferPrototype%                      The initial value of the "PROTOTYPE" data property of the intrinsic %ArrayBuffer%.

  %TypedArray%                                

  %TypedArrayPrototype%                       The initial value of the "PROTOTYPE" data property of the intrinsic %TypedArray%.

  %Int8Array%                                 

  %Int8ArrayPrototype%                        

  %DataView%                                  

  %DataViewPrototype%                         

  %ThrowTypeError%                            A function object that unconditionally throws a new instance of %TypeError%.

  %Realm%                                     

  %RealmPrototype%                            

  %Promise%                                   

  %PromisePrototype%                          

  %Loader%                                    

  %LoaderPrototype%                           

  %LoaderIteratorPrototype%                   

  %ReturnUndefined%                           

  %Symbol%                                    
  --------------------------- --------------- --------------------------------------------------------------------------------------------------


 ECMAScript Specification Types

A specification type corresponds to meta-values that are used within
algorithms to describe the semantics of ECMAScript language constructs
and ECMAScript language types. The specification types are Reference,
List, Completion, Property Descriptor, Lexical Environment, Environment
Record, and Data Block. Specification type values are specification
artefacts that do not necessarily correspond to any specific entity
within an ECMAScript implementation. Specification type values may be
used to describe intermediate results of ECMAScript expression
evaluation but such values cannot be stored as properties of objects or
values of ECMAScript language variables.

The List and Record Specification Type

The List type is used to explain the evaluation of argument lists (see
12.3.6) in NEW expressions, in function calls, and in other algorithms
where a simple ordered list of values is needed. Values of the List type
are simply ordered sequences of list elements containing the individual
values. These sequences may be of any length. The elements of a list may
be randomly accessed using 0-origin indices. For notational convience an
array-like syntax can be used to access List elements. For example,
_arguments_[2] is shorthand for saying the 3^rd^ element of the List
_arguments_.

The Record type is used to describe data aggregations within the
algorithms of this specification. A Record type value consists of one or
more named fields. The value of each field is either an ECMAScript value
or an abstract value represented by a name associated with the Record
type. Field names are always enclosed in double brackets, for example
[[value]]

For notational convenience within this specification, an object
literal-like syntax can be used to express a Record value. For example,
{[[field1]]: 42, [[field2]]: FALSE, [[field3]]: EMPTY} defines a Record
value that has three fields each of which is initialized to a specific
value. Field name order is not significant. Any fields that are not
explicitly listed are considered to be absent.

In specification text and algorithms, dot notation may be used to refer
to a specific field of a Record value. For example, if R is the record
shown in the previous paragraph then R.[[field2]] is shorthand for “the
field of R named [[field2]]”.

Schema for commonly used Record field combinations may be named, and
that name may be used as a prefix to a literal Record value to identify
the specific kind of aggregations that is being described. For example:
PropertyDescriptor{[[Value]]: 42, [[Writable]]: FALSE, [[Configurable]]:
TRUE}.

The Completion Record Specification Type

The Completion type is a Record used to explain the runtime propagation
of values and control flow such as the behaviour of statements (BREAK,
CONTINUE, RETURN and THROW) that perform nonlocal transfers of control.

Values of the Completion type are Record values whole fields are defined
as by Table 8.

Table 8 — Completion Record Fields

  -------------- -------------------------------------------------- --------------------------------------------------
  _FIELD NAME_   _VALUE_                                            _MEANING_
  [[type]]       One of NORMAL, BREAK, CONTINUE, RETURN, or THROW   The type of completion that occurred.
  [[value]]      any ECMAScript language value or EMPTY             The value that was produced.
  [[target]]     any ECMAScript string or EMPTY                     The target label for directed control transfers.
  -------------- -------------------------------------------------- --------------------------------------------------

The term “abrupt completion” refers to any completion with a [[type]]
value other than NORMAL.

NormalCompletion

The abstract operation NormalCompletion with a single _argument_, such
as:

1.  Return NormalCompletion(_argument_).

Is a shorthand that is defined as follows:

1.  Return Completion{[[type]]: normal, [[value]]: _argument_,
    [[target]]:empty}.

Implicit Completion Values

The algorithms of this specification often implicitly return Completion
Records whose [[type]] is NORMAL. Unless it is otherwise obvious from
the context, an algorithm statement that returns a value that is not a
Completion Record, such as:

1.  Return "Infinity".

Generally means the same thing as:

1.  Return NormalCompletion("INFINITY").

A “return” statement without a value in an algorithm step means the same
thing as:

1.  Return NormalCompletion(UNDEFINED).

Similarly, any reference to a Completion Record value that is in a
context that does not explicitly require a complete Completion Record
value is equivalent to an explicit reference to the [[value]] field of
the Completion Record value unless the Completion Record is an abrupt
completion.

Throw an Exception

Algorithms steps that say to throw an exception, such as

1.  Throw a TYPEERROR exception.

mean the same things as:

1.  Return Completion{[[type]]: throw, [[value]]: a newly created
    TYPEERROR object, [[target]]:empty}.

ReturnIfAbrupt

Algorithms steps that say

1.  ReturnIfAbrupt(_argument_).

mean the same thing as:

1.  If _argument_ is an abrupt completion, then return _argument_.

2.  Else if _argument_ is a Completion Record, then let _argument_ be
    _argument_.[[value]].

The Reference Specification Type

NOTE The Reference type is used to explain the behaviour of such
operators as DELETE, TYPEOF, the assignment operators, the SUPER keyword
and other language features. For example, the left-hand operand of an
assignment is expected to produce a reference.

A REFERENCE is a resolved name or property binding. A Reference consists
of three components, the _base_ value, the _referenced name_ and the
Boolean valued _strict reference_ flag. The _base_ value is either
UNDEFINED, an Object, a Boolean, a String, a Symbol, a Number, or an
environment record (8.1.1). A _base_ value of UNDEFINED indicates that
the Reference could not be resolved to a binding. The _referenced name_
is a String or Symbol value.

A Super Reference is a Reference that is used to represents a name
binding that was expressed using the super keyword. A Super Reference
has an additional _thisValue_ component and its _base_ value will never
be an environment record.

The following abstract operations are used in this specification to
access the components of references:

-   GetBase(V). Returns the _base_ value component of the reference V.

-   GetReferencedName(V). Returns the _referenced name_ component of the
      reference V.

-   IsStrictReference(V). Returns the _strict reference_ flag component
      of the reference V.

-   HasPrimitiveBase(V). Returns TRUE if Type(_base_) is a Boolean,
      String, Symbol, or Number.

-   IsPropertyReference(V). Returns TRUE if either the _base_ value is
      an object or HasPrimitiveBase(V) is TRUE; otherwise returns FALSE.

-   IsUnresolvableReference(V). Returns TRUE if the _base_ value is
      UNDEFINED and FALSE otherwise.

-   IsSuperReference(V). Returns TRUE if this reference has a
      _thisValue_ component.

The following abstract operations are used in this specification to
operate on references:

GetValue (V)

1.  ReturnIfAbrupt(_V_).

2.  If Type(_V_) is not Reference, return _V_.

3.  Let _base_ be GetBase(_V_).

4.  If IsUnresolvableReference(_V_), throw a REFERENCEERROR exception.

5.  If IsPropertyReference(_V_), then

    a.  If HasPrimitiveBase(_V_) is TRUE, then

        i.  Assert: In this case, _base_ will never be NULL or
            UNDEFINED.

        ii. Let _base_ be ToObject(_base_).

    b.  Return the result of calling the [[Get]] internal method of
        _base_ passing GetReferencedName(_V_) and GetThisValue(_V_) as
        the arguments.

6.  Else _base_ must be an environment record,

    a.  Return the result of calling the GetBindingValue (see 8.1.1)
        concrete method of _base_ passing GetReferencedName(_V_) and
        IsStrictReference(_V_) as arguments.

NOTE The object that may be created in step 5.a.ii is not accessible
outside of the above abstract operation and the ordinary object [[Get]]
internal method. An implementation might choose to avoid the actual
creation of the object.

PutValue (V, W)

1.  ReturnIfAbrupt(_V_).

2.  ReturnIfAbrupt(_W_).

3.  If Type(_V_) is not Reference, throw a REFERENCEERROR exception.

4.  Let _base_ be GetBase(_V_).

5.  If IsUnresolvableReference(_V_), then

    a.  If IsStrictReference(_V_) is TRUE, then

        i.  Throw REFERENCEERROR exception.

    b.  Let _globalObj_ be the result of the abstract operation
        GetGlobalObject.

    c.  Return Put(_globalObj_,GetReferencedName(_V_), _W_, FALSE).

6.  Else if IsPropertyReference(_V_), then

    a.  If HasPrimitiveBase(_V_) is TRUE, then

        i.  Assert: In this case, _base_ will never be NULL or
            UNDEFINED.

        ii. Set _base_ to ToObject(_base_).

    b.  Let _succeeded_ be the result of calling the [[Set]] internal
        method of _base_ passing GetReferencedName(_V_), _W_, and
        GetThisValue(_V_) as arguments.

    c.  ReturnIfAbrupt(_succeeded_).

    d.  If _succeeded_ is FALSE and IsStrictReference(_V_) is TRUE, then
        throw a TYPEERROR exception.

    e.  Return.

7.  Else _base_ must be a Reference whose base is an environment record.

    a.  Return the result of calling the SetMutableBinding (8.1.1)
        concrete method of _base_, passing GetReferencedName(_V_), _W_,
        and IsStrictReference(_V_) as arguments.

NOTE The object that may be created in step 6.a.ii is not accessible
outside of the above algorithm and the ordinary object [[Set]] internal
method. An implementation might choose to avoid the actual creation of
that object.

GetThisValue (V)

1.  Assert: IsPropertyReference(_V_) is TRUE.

2.  If IsSuperReference(_V_), then

    a.  Return the value of the _thisValue_ component of the reference
        _V_.

3.  Return GetBase(_V_).

The Property Descriptor Specification Type

The Property Descriptor type is used to explain the manipulation and
reification of Object property attributes. Values of the Property
Descriptor type are Records. Each field’s name is an attribute name and
its value is a corresponding attribute value as specified in 6.1.7.1. In
addition, any field may be present or absent. The schema name used
within this specification to tag literal descriptions of Property
Descriptor records is “PropertyDescriptor”.

Property Descriptor values may be further classified as data Property
Descriptors and accessor Property Descriptors based upon the existence
or use of certain fields. A data Property Descriptor is one that
includes any fields named either [[Value]] or [[Writable]]. An accessor
Property Descriptor is one that includes any fields named either [[Get]]
or [[Set]]. Any Property Descriptor may have fields named [[Enumerable]]
and [[Configurable]]. A Property Descriptor value may not be both a data
Property Descriptor and an accessor Property Descriptor; however, it may
be neither. A generic Property Descriptor is a Property Descriptor value
that is neither a data Property Descriptor nor an accessor Property
Descriptor. A fully populated Property Descriptor is one that is either
an accessor Property Descriptor or a data Property Descriptor and that
has all of the fields that correspond to the property attributes defined
in either Table 2 or Table 3.

The following abstract operations are used in this specification to
operate upon Property Descriptor values:

IsAccessorDescriptor ( Desc )

When the abstract operation IsAccessorDescriptor is called with Property
Descriptor _Desc_, the following steps are taken:

1.  If _Desc_ is UNDEFINED, then return FALSE.

2.  If both _Desc_.[[Get]] and _Desc_.[[Set]] are absent, then return
    FALSE.

3.  Return TRUE.

IsDataDescriptor ( Desc )

When the abstract operation IsDataDescriptor is called with Property
Descriptor _Desc_, the following steps are taken:

1.  If _Desc_ is UNDEFINED, then return FALSE.

2.  If both _Desc_.[[Value]] and _Desc_.[[Writable]] are absent, then
    return FALSE.

3.  Return TRUE.

IsGenericDescriptor ( Desc )

When the abstract operation IsGenericDescriptor is called with Property
Descriptor _Desc_, the following steps are taken:

1.  If _Desc_ is UNDEFINED, then return FALSE.

2.  If IsAccessorDescriptor(_Desc_) and IsDataDescriptor(_Desc_) are
    both FALSE, then return TRUE.

3.  Return FALSE.

FromPropertyDescriptor ( Desc )

When the abstract operation FromPropertyDescriptor is called with
Property Descriptor _Desc_, the following steps are taken:

1.  If _Desc_ is UNDEFINED, then return UNDEFINED.

2.  3.  Let _obj_ be ObjectCreate(%ObjectPrototype%).

4.  Assert: _obj_ is an extensible ordinary object with no own
    properties.

5.  If _Desc_ has a [[Value]] field, then

    a.  Call OrdinaryDefineOwnProperty with arguments _obj_, "VALUE",
        and PropertyDescriptor{[[Value]]: _Desc_.[[Value]],
        [[Writable]]: TRUE, [[Enumerable]]: TRUE, [[Configurable]]:
        TRUE}

6.  If _Desc_ has a [[Writable]] field, then

    a.  Call OrdinaryDefineOwnProperty with arguments _obj_, "WRITABLE",
        and PropertyDescriptor{[[Value]]: _Desc_.[[Writable]],
        [[Writable]]: TRUE, [[Enumerable]]: TRUE, [[Configurable]]:
        TRUE}.

7.  If _Desc_ has a [[Get]] field, then

    a.  Call OrdinaryDefineOwnProperty with arguments _obj_, "GET", and
        PropertyDescriptor{[[Value]]: _Desc_.[[Get]], [[Writable]]:
        TRUE, [[Enumerable]]: TRUE, [[Configurable]]: TRUE}.

8.  If _Desc_ has a [[Set]] field, then

    a.  Call OrdinaryDefineOwnProperty with arguments _obj_, "SET", and
        PropertyDescriptor{[[Value]]: _Desc_.[[Set]], [[Writable]]:
        TRUE, [[Enumerable]]: TRUE, [[Configurable]]: TRUE}.

9.  If _Desc_ has an [[Enumerable]] field, then

    a.  Call OrdinaryDefineOwnProperty with arguments _obj_,
        "ENUMERABLE", and PropertyDescriptor{[[Value]]:
        _Desc_.[[Enumerable]], [[Writable]]: TRUE, [[Enumerable]]: TRUE,
        [[Configurable]]: TRUE}.

10. If _Desc_ has a [[Configurable]] field, then

    a.  Call OrdinaryDefineOwnProperty with arguments _obj_ ,
        "CONFIGURABLE", and PropertyDescriptor{[[Value]]:
        _Desc_.[[Configurable]], [[Writable]]: TRUE, [[Enumerable]]:
        TRUE, [[Configurable]]: TRUE}.

11. Return _obj_.

ToPropertyDescriptor ( Obj )

When the abstract operation ToPropertyDescriptor is called with object
_Obj_, the following steps are taken:

1.  ReturnIfAbrupt(_Obj_).

2.  If Type(_Obj_) is not Object throw a TYPEERROR exception.

3.  Let _desc_ be a new Property Descriptor that initially has no
    fields.

4.  If HasProperty(_Obj_, "ENUMERABLE") is TRUE, then

    a.  Let _enum_ be Get(_Obj_, "ENUMERABLE").

    b.  ReturnIfAbrupt(_enum_).

    c.  Set the [[Enumerable]] field of _desc_ to ToBoolean(_enum_).

5.  If HasProperty(_Obj_, "CONFIGURABLE") is TRUE, then

    a.  Let _conf_ be Get(_Obj_, "CONFIGURABLE").

    b.  ReturnIfAbrupt(_conf_).

    c.  Set the [[Configurable]] field of _desc_ to ToBoolean(_conf_).

6.  If HasProperty(_Obj_, "VALUE") is TRUE, then

    a.  Let _value_ be Get(_Obj_, "VALUE").

    b.  ReturnIfAbrupt(_value_).

    c.  Set the [[Value]] field of _desc_ to _value_.

7.  If HasProperty(_Obj_, "WRITABLE") is TRUE, then

    a.  Let _writable_ be Get(_Obj_, "WRITABLE").

    b.  ReturnIfAbrupt(_writable_).

    c.  Set the [[Writable]] field of _desc_ to ToBoolean(_writable_).

8.  If HasProperty(_Obj_, "GET") is TRUE, then

    a.  Let _getter_ be Get(_Obj_, "GET").

    b.  ReturnIfAbrupt(_getter_).

    c.  If IsCallable(_getter_) is FALSE and _getter_ is not UNDEFINED,
        then throw a TYPEERROR exception.

    d.  Set the [[Get]] field of _desc_ to _getter_.

9.  If HasProperty(_Obj_, "SET") is TRUE, then

    a.  Let _setter_ be Get(_Obj_, "SET").

    b.  ReturnIfAbrupt(_setter_).

    c.  If IsCallable(_setter_) is FALSE and _setter_ is not UNDEFINED,
        then throw a TYPEERROR exception.

    d.  Set the [[Set]] field of _desc_ to _setter_.

10. If either _desc_.[[Get]] or _desc_.[[Set]] are present, then

    a.  If either _desc_.[[Value]] or _desc_.[[Writable]] are present,
        then throw a TYPEERROR exception.

11. 12. Return _desc_.

CompletePropertyDescriptor ( Desc )

When the abstract operation CompletePropertyDescriptor is called with
Property Descriptor _Desc_ the following steps are taken:

1.  2.  ReturnIfAbrupt(_Desc_).

3.  Assert: _Desc_ is a Property Descriptor

4.  5.  Let _like_ be Record{[[Value]]: UNDEFINED, [[Writable]]: FALSE,
    [[Get]]: UNDEFINED, [[Set]]: UNDEFINED, [[Enumerable]]: FALSE,
    [[Configurable]]: FALSE}.

6.  a.  b.  

7.  If either IsGenericDescriptor(_Desc_) or IsDataDescriptor(_Desc_) is
    TRUE, then

    a.  If _Desc_ does not have a [[Value]] field, then set
        _Desc_.[[Value]] to _like_.[[Value]].

    b.  If _Desc_ does not have a [[Writable]] field, then set
        _Desc_.[[Writable]] to _like_.[[Writable]].

8.  Else,

    a.  If _Desc_ does not have a [[Get]] field, then set _Desc_.[[Get]]
        to _like_.[[Get]].

    b.  If _Desc_ does not have a [[Set]] field, then set _Desc_.[[Set]]
        to _like_.[[Set]].

9.  If _Desc_ does not have an [[Enumerable]] field, then set
    _Desc_.[[Enumerable]] to _like_.[[Enumerable]].

10. If _Desc_ does not have a [[Configurable]] field, then set
    _Desc_.[[Configurable]] to _like_.[[Configurable]].

11. Return _Desc_.

The Lexical Environment and Environment Record Specification Types

The Lexical Environment and Environment Record types are used to explain
the behaviour of name resolution in nested functions and blocks. These
types and the operations upon them are defined in 8.1.

Data Blocks

The Data Block specification type is used to describe a distinct and
mutable sequence of byte-sized (8 bit) numeric values. A Data Block
value is created with a fixed number of bytes that each have the initial
value 0.

For notational convenience within this specification, an array-like
syntax can be used to express to the individual bytes of a Data Block
value. This notation presents a Data Block value as a 0-origined integer
indexed sequence of bytes. For example, if _db_ is a 5 byte Data Block
value then _db_[2] can be used to express access to its 3^rd^ byte.

The following abstract operations are used in this specification to
operate upon Data Block values:

CreateByteDataBlock(size)

When the abstract operation CreateByteDataBlock is called with integer
argument _size_, the following steps are taken:

1.  Assert: _size_≥0.

2.  Let _db_ be a new Data Block value consisting of _size_ bytes. If it
    is impossible to create such a Data Block, then throw a RANGEERROR
    exception.

3.  Set all of the bytes of _db_ to 0.

4.  Return _db_.

CopyDataBlockBytes(toBlock, toIndex, fromBlock, fromIndex, count)

When the abstract operation CopyDataBlockBytes is called the following
steps are taken:

1.  Assert: _fromBlock_ and _toBlock_ are distinct Data Block values.

2.  Assert: _fromIndex_, _toIndex_, and _count_ are positive integer
    values.

3.  Let _fromSize_ be the number of bytes in _fromBlock_.

4.  Assert: _fromIndex_+_count_ ≤ _fromSize_.

5.  Let _toSize_ be the number of bytes in _toBlock_.

6.  Assert: _toIndex_+_count_ ≤ _toSize_.

7.  Repeat, while _count_>

    a.  Set _toBlock_[_toIndex_] to the value of
        _fromBlock_[_fromIndex_].

    b.  Increment _toIndex_ and _fromIndex_ each by 1.

    c.  Decrement _count_ by 1.

8.  Return NormalCompletion(empty)



ABSTRACT OPERATIONS 


These operations are not a part of the ECMAScript language; they are
defined here to solely to aid the specification of the semantics of the
ECMAScript language. Other, more specialized abstract operations are
defined throughout this specification.


Type Conversion and Testing

The ECMAScript language implicitly performs automatic type conversion as
needed. To clarify the semantics of certain constructs it is useful to
define a set of conversion abstract operations. The conversion abstract
operations are polymorphic; they can accept a value of any ECMAScript
language type or of a Completion Record value. But no other
specification types are used with these operations.

ToPrimitive ( input [, PreferredType] )

The abstract operation ToPrimitive takes an _input_ argument and an
optional argument _PreferredType_. The abstract operation ToPrimitive
converts its _input_ argument to a non-Object type. If an object is
capable of converting to more than one primitive type, it may use the
optional hint _PreferredType_ to favour that type. Conversion occurs
according to Table 9:

Table 9 — ToPrimitive Conversions

  ------------------- -----------------------------------------------------------------------------------------------------------------------------------------------------
  _INPUT TYPE_        _RESULT_
  Completion Record   If _input_ is an abrupt completion, return _input_. Otherwise return ToPrimitive(_input_.[[value]]) also passing the optional hint _PreferredType_.
  Undefined           Return _input_ (no conversion).
  Null                Return _input_ (no conversion).
  Boolean             Return _input_ (no conversion).
  Number              Return _input_ (no conversion).
  String              Return _input_ (no conversion).
  Symbol              Return _input_ (no conversion).
  Object              Perform the steps following this table.
  ------------------- -----------------------------------------------------------------------------------------------------------------------------------------------------

When Type(_input_) is Object, the following steps are taken:

1.  If _PreferredType_ was not passed, let _hint_ be "DEFAULT".

2.  Else if _PreferredType_ is hint String, let _hint_ be "STRING".

3.  Else _PreferredType_ is hint Number, let _hint_ be "NUMBER".

4.  Let _exoticToPrim_ be GetMethod(_input_, @@toPrimitive).

5.  ReturnIfAbrupt(_exoticToPrim_).

6.  If _exoticToPrim_ is not UNDEFINED, then

    a.  Let _result_ be the result of calling the [[Call]] internal
        method of _exoticToPrim_, with _input_ as _thisArgument_ and
        (_hint_) as _argumentsList_.

    b.  ReturnIfAbrupt(_result_).

    c.  If Type(_result_) is not Object, then return _result_.

    d.  Throw a TYPEERROR exception.

7.  If _hint_ is "DEFAULT" then, let _hint_ be "NUMBER".

8.  Return OrdinaryToPrimitive(_input,hint_).

When the abstract operation OrdinaryToPrimitive is called with arguments
_O_ and _hint_, the following steps are taken:

1.  Assert: Type(_O_) is Object

2.  Assert: Type(_hint_) is String and its value is either "STRING" or
    "NUMBER".

3.  If _hint_ is "STRING", then

    a.  Let _methodNames_ be the List ( "TOSTRING", "VALUEOF").

4.  Else,

    a.  Let _methodNames_ be the List ( "VALUEOF", "TOSTRING").

5.  For each _name_ in _methodNames_ in List order, do

    a.  Let _method_ be Get(_O_, _name_).

    b.  ReturnIfAbrupt(_method_).

    c.  If IsCallable(_method)_ is TRUE then,

        i.  Let _result_ be the result of calling the [[Call]] internal
            method of _method_, with _O_ as _thisArgument_ and an empty
            List as _argumentsList_.

        ii. ReturnIfAbrupt(_result_).

        iii. If Type(_result_) is not Object, then return _result_.

6.  Throw a TYPEERROR exception.

NOTE When ToPrimitive is called with no hint, then it generally behaves
as if the hint were Number. However, objects may over-ride this
behaviour by defining a @@toPrimitive method. Of the objects defined in
this specification only Date objects (see 20.3) and Symbol objects (see
19.4.3.4) over-ride the default ToPrimitive behaviour. Date objects
treat no hint as if the hint were String.

ToBoolean ( argument )

The abstract operation ToBoolean converts _argument_ to a value of type
Boolean according to Table 10:

Table 10 — ToBoolean Conversions

  ------------------- ------------------------------------------------------------------------------------------------------------
  _ARGUMENT TYPE_     _RESULT_
  Completion Record   If _argument_ is an abrupt completion, return _argument_. Otherwise return ToBoolean(_argument_.[[value]])
  Undefined           Return FALSE
  Null                Return FALSE
  Boolean             Return _argument_ (no conversion).
  Number              Return FALSE if _argument_ is +0, −0, or NAN; otherwise return TRUE.
  String              Return FALSE if _argument_ is the empty String (its length is zero); otherwise return TRUE.
  Symbol              Return TRUE
  Object              Return TRUE
  ------------------- ------------------------------------------------------------------------------------------------------------

ToNumber ( argument )

The abstract operation ToNumber converts _argument_ to a value of type
Number according to Table 11:

Table 11 — ToNumber Conversions

  ------------------- -----------------------------------------------------------------------------------------------------------
  _ARGUMENT TYPE_     _RESULT_

  Completion Record   If _argument_ is an abrupt completion, return _argument_. Otherwise return ToNumber(_argument_.[[value]])

  Undefined           Return NAN

  Null                Return +0

  Boolean             Return 1 if _argument_ is TRUE. Return +0 if _argument_ is FALSE.

  Number              Return _argument_ (no conversion).

  String              See grammar and conversion algorithm below.

  Symbol              Throw a TYPEERROR exception.

  Object              Apply the following steps:
                      
                      Let _primValue_ be ToPrimitive(_argument_, hint Number).
                      
                      Return ToNumber(_primValue_).
  ------------------- -----------------------------------------------------------------------------------------------------------

ToNumber Applied to the String Type

ToNumber applied to Strings applies the following grammar to the input
String interpreted as a sequence of UTF-16 encoded code points. If the
grammar cannot interpret the String as an expansion of
_StringNumericLiteral_, then the result of ToNumber is NAN.

NOTE The terminal symbols of this grammar are all composed of Unicode
BMP code points so the result will be NAN if the string contains the
UTF-16 encoding of any supplementary code points or any unpaired
surrogate code points

Syntax

StringNumericLiteral :::

StrWhiteSpace~opt~
StrWhiteSpace~opt~ StrNumericLiteral StrWhiteSpace~opt~

StrWhiteSpace :::

StrWhiteSpaceChar StrWhiteSpace~opt~

StrWhiteSpaceChar :::

WhiteSpace
LineTerminator

StrNumericLiteral :::

StrDecimalLiteral
HexIntegerLiteral

StrDecimalLiteral :::

StrUnsignedDecimalLiteral
+ StrUnsignedDecimalLiteral
- StrUnsignedDecimalLiteral

StrUnsignedDecimalLiteral :::

INFINITY
 DecimalDigits . DecimalDigits~opt~ ExponentPart~opt~
. DecimalDigits ExponentPart~opt~
DecimalDigits ExponentPart~opt~

DecimalDigits :::

DecimalDigit
DecimalDigits DecimalDigit

DecimalDigit ::: ONE OF

0 1 2 3 4 5 6 7 8 

ExponentPart :::

ExponentIndicator SignedInteger

ExponentIndicator ::: ONE OF

E E

SignedInteger :::

DecimalDigits
+ DecimalDigits
- DecimalDigits

HexIntegerLiteral :::

0X HexDigit
0X HexDigit
HexIntegerLiteral HexDigit

HexDigit ::: ONE OF

0 1 2 3 4 5 6 7 8 9 A B C D E F A B C D E F

NOTE Some differences should be noted between the syntax of a
_StringNumericLiteral_ and a _NumericLiteral_ (see 11.8.3):

-   A _StringNumericLiteral_ may include leading and/or trailing white
    space and/or line terminators.

-   A _StringNumericLiteral_ that is decimal may have any number of
    leading 0 digits.

-   A _StringNumericLiteral_ that is decimal may include a + or - to
    indicate its sign.

-   A _StringNumericLiteral_ that is empty or contains only white space
    is converted to +0.

-   INFINITY AND –INFINITY are recognized as a _StringNumericLiteral_
    but not as a _NumericLiteral_.

Runtime Semantics: MV’s

The conversion of a String to a Number value is similar overall to the
determination of the Number value for a numeric literal (see 11.8.3),
but some of the details are different, so the process for converting a
String numeric literal to a value of Number type is given here in full.
This value is determined in two steps: first, a mathematical value (MV)
is derived from the String numeric literal; second, this mathematical
value is rounded as described below.

-   The MV of _StringNumericLiteral_ ::: [empty] is 0.

-   The MV of _StringNumericLiteral_ ::: _StrWhiteSpace_ is 0.

-   The MV of _StringNumericLiteral_ ::: _StrWhiteSpace~opt~_
      _StrNumericLiteral_ _StrWhiteSpace~opt~_ is the MV of
      _StrNumericLiteral_, no matter whether white space is present or
      not.

-   The MV of _StrNumericLiteral_ ::: _StrDecimalLiteral_ is the MV of
      _StrDecimalLiteral_.

-   The MV of _StrNumericLiteral_ ::: _HexIntegerLiteral_ is the MV of
      _HexIntegerLiteral_.

-   The MV of _StrDecimalLiteral_ ::: _StrUnsignedDecimalLiteral_ is the
      MV of _StrUnsignedDecimalLiteral_.

-   The MV of _StrDecimalLiteral_ ::: + _StrUnsignedDecimalLiteral_ is
      the MV of _StrUnsignedDecimalLiteral_.

-   The MV of _StrDecimalLiteral_ ::: - _StrUnsignedDecimalLiteral_ is
      the negative of the MV of _StrUnsignedDecimalLiteral_. (Note that
      if the MV of _StrUnsignedDecimalLiteral_ is 0, the negative of
      this MV is also 0. The rounding rule described below handles the
      conversion of this signless mathematical zero to a floating-point
      +0 or −0 as appropriate.)

-   The MV of _StrUnsignedDecimalLiteral_::: INFINITY is 10^10000^ (a
      value so large that it will round to +∞).

-   The MV of _StrUnsignedDecimalLiteral_::: _DecimalDigits_. is the MV
      of _DecimalDigits_.

-   The MV of _StrUnsignedDecimalLiteral_::: _DecimalDigits_ .
      _DecimalDigits_ is the MV of the first _DecimalDigits_ plus (the
      MV of the second _DecimalDigits_ times 10^−_n_^), where _n_ is the
      number of code points in the second _DecimalDigits_.

-   The MV of _StrUnsignedDecimalLiteral_::: _DecimalDigits_.
      _ExponentPart_ is the MV of _DecimalDigits_ times 10_^e^_, where
      _e_ is the MV of _ExponentPart_.

-   The MV of _StrUnsignedDecimalLiteral_::: _DecimalDigits_.
      _DecimalDigits ExponentPart_ is (the MV of the first
      _DecimalDigits_ plus (the MV of the second _DecimalDigits_ times
      10^−_n_^)) times 10_^e^_, where _n_ is the number of code points
      in the second _DecimalDigits_ and _e_ is the MV of _ExponentPart_.

-   The MV of _StrUnsignedDecimalLiteral_:::. _DecimalDigits_ is the MV
      of _DecimalDigits_ times 10^−_n_^, where _n_ is the number of code
      points in _DecimalDigits_.

-   The MV of _StrUnsignedDecimalLiteral_:::. _DecimalDigits
      ExponentPart_ is the MV of _DecimalDigits_ times 10^_e_−_n_^,
      where _n_ is the number of code points in _DecimalDigits_ and _e_
      is the MV of _ExponentPart_.

-   The MV of _StrUnsignedDecimalLiteral_::: _DecimalDigits_ is the MV
      of _DecimalDigits_.

-   The MV of _StrUnsignedDecimalLiteral_::: _DecimalDigits_
      _ExponentPart_ is the MV of _DecimalDigits_ times 10_^e^_, where
      _e_ is the MV of _ExponentPart_.

-   The MV of _DecimalDigits_ ::: _DecimalDigit_ is the MV of
      _DecimalDigit_.

-   The MV of _DecimalDigits_ ::: _DecimalDigits_ _DecimalDigit_ is (the
      MV of _DecimalDigits_ times 10) plus the MV of _DecimalDigit_.

-   The MV of _ExponentPart_ ::: _ExponentIndicator SignedInteger_ is
      the MV of _SignedInteger_.

-   The MV of _SignedInteger_ ::: _DecimalDigits_ is the MV of
      _DecimalDigits_.

-   The MV of _SignedInteger_ ::: + _DecimalDigits_ is the MV of
      _DecimalDigits_.

-   The MV of _SignedInteger_ ::: - _DecimalDigits_ is the negative of
      the MV of _DecimalDigits_.

-   The MV of _DecimalDigit_ ::: 0 or of _HexDigit_ ::: 0 is 0.

-   The MV of _DecimalDigit_ ::: 1 or of _HexDigit_ ::: 1 is 1.

-   The MV of _DecimalDigit_ ::: 2 or of _HexDigit_ ::: 2 is 2.

-   The MV of _DecimalDigit_ ::: 3 or of _HexDigit_ ::: 3 is 3.

-   The MV of _DecimalDigit_ ::: 4 or of _HexDigit_ ::: 4 is 4.

-   The MV of _DecimalDigit_ ::: 5 or of _HexDigit_ ::: 5 is 5.

-   The MV of _DecimalDigit_ ::: 6 or of _HexDigit_ ::: 6 is 6.

-   The MV of _DecimalDigit_ ::: 7 or of _HexDigit_ ::: 7 is 7.

-   The MV of _DecimalDigit_ ::: 8 or of _HexDigit_ ::: 8 is 8.

-   The MV of _DecimalDigit_ ::: 9 or of _HexDigit_ ::: 9 is 9.

-   The MV of _HexDigit_ ::: A or of _HexDigit_ ::: A is 10.

-   The MV of _HexDigit_ ::: B or of _HexDigit_ ::: B is 11.

-   The MV of _HexDigit_ ::: C or of _HexDigit_ ::: C is 12.

-   The MV of _HexDigit_ ::: D or of _HexDigit_ ::: D is 13.

-   The MV of _HexDigit_ ::: E or of _HexDigit_ ::: E is 14.

-   The MV of _HexDigit_ ::: F or of _HexDigit_ ::: F is 15.

-   The MV of _HexIntegerLiteral_ ::: 0X _HexDigit_ is the MV of
      _HexDigit_.

-   The MV of _HexIntegerLiteral_ ::: 0X _HexDigit_ is the MV of
      _HexDigit_.

-   The MV of _HexIntegerLiteral_ ::: _HexIntegerLiteral_ _HexDigit_ is
      (the MV of _HexIntegerLiteral_ times 16) plus the MV of
      _HexDigit_.

Once the exact MV for a String numeric literal has been determined, it
is then rounded to a value of the Number type. If the MV is 0, then the
rounded value is +0 unless the first non white space code point in the
String numeric literal is ‘-’, in which case the rounded value is −0.
Otherwise, the rounded value must be the Number value for the MV (in the
sense defined in 6.1.6), unless the literal includes a
_StrUnsignedDecimalLiteral_ and the literal has more than 20 significant
digits, in which case the Number value may be either the Number value
for the MV of a literal produced by replacing each significant digit
after the 20th with a 0 digit or the Number value for the MV of a
literal produced by replacing each significant digit after the 20th with
a 0 digit and then incrementing the literal at the 20th digit position.
A digit is _significant_ if it is not part of an _ExponentPart_ and

-   it is not 0; or

-   there is a nonzero digit to its left and there is a nonzero digit,
    not in the _ExponentPart_, to its right.

ToInteger ( argument )

The abstract operation ToInteger converts _argument_ to an integral
numeric value. This abstract operation functions as follows:

1.  Let _number_ be ToNumber(_argument_).

2.  ReturnIfAbrupt(_number_).

3.  If _number_ is NAN, return +0.

4.  If _number_ is +0, −0, +∞, or −∞, return _number_.

5.  Return the result of computing sign(_number_) ×
    floor(abs(_number_)).

ToInt32 ( argument ) — Signed 32 Bit Integer

The abstract operation ToInt32 converts _argument_ to one of 2^32^
integer values in the range −2^31^ through 2^31^−1, inclusive. This
abstract operation functions as follows:

1.  Let _number_ be ToNumber(_argument_).

2.  ReturnIfAbrupt(_number_).

3.  If _number_ is NAN, +0, −0, +∞, or −∞, return +0.

4.  Let _int_ be sign(_number_) × floor(abs(_number_)).

5.  Let _int32bit_ be _int_ modulo 2^32^.

6.  If _int32bit_ ≥ 2^31^, return _int32bit_ − 2^32^, otherwise return
    _int32bit_.

NOTE Given the above definition of ToInt32:

-   The ToInt32 abstract operation is idempotent: if applied to a result
    that it produced, the second application leaves that value
    unchanged.

-   _ToInt32(ToUint32(x))_ is equal to ToInt32(_x_) for all values of
    _x_. (It is to preserve this latter property that +∞ and −∞ are
    mapped to +0.)

-   ToInt32 maps −0 to +0.

ToUint32 ( argument ) — Unsigned 32 Bit Integer

The abstract operation ToUint32 converts _argument_ to one of 2^32^
integer values in the range 0 through 2^32^−1, inclusive. This abstract
operation functions as follows:

1.  Let _number_ be ToNumber(_argument_).

2.  ReturnIfAbrupt(_number_).

3.  If _number_ is NAN, +0, −0, +∞, or −∞, return +0.

4.  Let _int_ be sign(_number_) × floor(abs(_number_)).

5.  Let _int32bit_ be _int_ modulo 2^32^.

6.  Return _int32bit_.

NOTE Given the above definition of ToUint32:

-   Step 6 is the only difference between ToUint32 and ToInt32.

-   The ToUint32 abstract operation is idempotent: if applied to a
    result that it produced, the second application leaves that value
    unchanged.

-   ToUint32(ToInt32(_x_)) is equal to ToUint32(_x_) for all values of
    _x_. (It is to preserve this latter property that +∞ and −∞ are
    mapped to +0.)

-   ToUint32 maps −0 to +0.

ToInt16 ( argument ) — Signed 16 Bit Integer

The abstract operation ToInt16 converts _argument_ to one of 2^16^
integer values in the range −32768 through 32767, inclusive. This
abstract operation functions as follows:

1.  Let _number_ be ToNumber(_argument_).

2.  ReturnIfAbrupt(_number_).

3.  If _number_ is NAN, +0, −0, +∞, or −∞, return +0.

4.  Let _int_ be sign(_number_) × floor(abs(_number_)).

5.  Let _int16bit_ be _int_ modulo 2^16^.

6.  If _int16bit_ ≥ 2^15^, return _int16bit_ − 2^16^, otherwise return
    _int16bit_.

ToUint16 ( argument ) — Unsigned 16 Bit Integer

The abstract operation ToUint16 converts _argument_ to one of 2^16^
integer values in the range 0 through 2^16^−1, inclusive. This abstract
operation functions as follows:

1.  Let _number_ be ToNumber(_argument_).

2.  ReturnIfAbrupt(_number_).

3.  If _number_ is NAN, +0, −0, +∞, or −∞, return +0.

4.  Let _int_ be sign(_number_) × floor(abs(_number_)).

5.  Let _int16bit_ be _int_ modulo 2^16^.

6.  Return _int16bit_.

NOTE Given the above definition of ToUint16:

-   The substitution of 2^16^ for 2^32^ in step 5 is the only difference
    between ToUint32 and ToUint16.

-   ToUint16 maps −0 to +0.

ToInt8 ( argument ) — Signed 8 Bit Integer

The abstract operation ToInt8 converts _argument_ to one of 2^8^ integer
values in the range −128 through 127, inclusive. This abstract operation
functions as follows:

1.  Let _number_ be ToNumber(_argument_).

2.  ReturnIfAbrupt(_number_).

3.  If _number_ is NAN, +0, −0, +∞, or −∞, return +0.

4.  Let _int_ be sign(_number_) × floor(abs(_number_)).

5.  Let _int8bit_ be _int_ modulo 2^8^.

6.  If _int8bit_ ≥ 2^7^, return _int8bit_ − 2^8^, otherwise return
    _int8bit_.

ToUint8 ( argument ) — Unsigned 8 Bit Integer

The abstract operation ToUint8 converts _argument_ to one of 2^8^
integer values in the range 0 through 255, inclusive. This abstract
operation functions as follows:

1.  Let _number_ be ToNumber(_argument_).

2.  ReturnIfAbrupt(_number_).

3.  If _number_ is NAN, +0, −0, +∞, or −∞, return +0.

4.  Let _int_ be sign(_number_) × floor(abs(_number_)).

5.  Let _int8bit_ be _int_ modulo 2^8^.

6.  Return _int8bit_.

ToUint8Clamp ( argument ) — Unsigned 8 Bit Integer, Clamped

The abstract operation ToUint8Clamp converts _argument_ to one of 2^8^
integer values in the range 0 through 255, inclusive. This abstract
operation functions as follows:

1.  Let _number_ be ToNumber(_argument_).

2.  ReturnIfAbrupt(_number_).

3.  If _number_ is NAN, return +0.

4.  If _number_ ≤ 0, return +0.

5.  If _number_ ≥ 255, return 255.

6.  Let _f_ be floor(_number_).

7.  If _f_ _+_ 0.5 < _number_, then return _f_ + 1.

8.  If _number_ < _f +_ 0.5, then return _f_.

9.  If _f_ is odd, then return _f_ + 1.

10. Return _f_.

NOTE Note that unlike the other ECMAScript integer conversion abstract
operation, ToUint8Clamp rounds rather than truncates non-integer values
and does not convert +∞ to 0. ToUint8Clamp does “round half to even”
tie-breaking. This differs from MATH.ROUND which does “round half up”
tie-breaking.

ToString ( argument )

The abstract operation ToString converts _argument_ to a value of type
String according to Table 12:

Table 12 — ToString Conversions

  ------------------- -----------------------------------------------------------------------------------------------------------
  _ARGUMENT TYPE_     _RESULT_

  Completion Record   If _argument_ is an abrupt completion, return _argument_. Otherwise return ToString(_argument_.[[value]])

  Undefined           "UNDEFINED"

  Null                "NULL"

  Boolean             If _argument_ is TRUE, then return "TRUE".
                      
                      If _argument_ is FALSE, then return "FALSE".

  Number              See 7.1.12.1.

  String              Return _argument_ (no conversion)

  Symbol              Throw a TYPEERROR exception.

  Object              Apply the following steps:
                      
                      1. Let _primValue_ be ToPrimitive(_argument_, hint String).
                      
                      2. Return ToString(_primValue_).
  ------------------- -----------------------------------------------------------------------------------------------------------

ToString Applied to the Number Type

The abstract operation ToString converts a Number _m_ to String format
as follows:

1.  If _m_ is NAN, return the String "NAN".

2.  If _m_ is +0 or −0, return the String "0".

3.  If _m_ is less than zero, return the String concatenation of the
    String "-" and ToString(−_m_).

4.  If _m_ is +∞, return the String "INFINITY".

5.  Otherwise, let _n_, _k_, and _s_ be integers such that _k_ ≥ 1,
    10^_k_−1^ ≤ _s_ < 10_^k^_, the Number value for _s_ × 10_^n−k^_ is
    _m_, and _k_ is as small as possible. Note that _k_ is the number of
    digits in the decimal representation of _s_, that _s_ is not
    divisible by 10, and that the least significant digit of _s_ is not
    necessarily uniquely determined by these criteria.

6.  If _k_ ≤ _n_ ≤ 21, return the String consisting of the code points
    of the _k_ digits of the decimal representation of _s_ (in order,
    with no leading zeroes), followed by _n−k_ occurrences of the code
    point U+0030 (DIGIT ZERO).

7.  If 0 < _n_ ≤ 21, return the String consisting of code points of the
    the most significant _n_ digits of the decimal representation of
    _s_, followed by the code point U+002E (FULL STOP), followed by the
    code points of the remaining _k−n_ digits of the decimal
    representation of _s_.

8.  If −6 < _n_ ≤ 0, return the String consisting of the code point
    U+0030 (DIGIT ZERO), followed by a the code point U+002E (FULL
    STOP), followed by −_n_ occurrences of the code point U+0030 (DIGIT
    ZERO), followed by the code points of the _k_ digits of the decimal
    representation of _s_.

9.  Otherwise, if _k_ = 1, return the String consisting of the code
    point of the single digit of _s_, followed by code point U+0065
    (LATIN SMALL LETTER E), followed by the code point U+002B (PLUS
    SIGN) or the code point U+002D (HYPHEN-MINUS) according to whether
    _n_−1 is positive or negative, followed by the code points of the
    decimal representation of the integer abs(_n_−1) (with no leading
    zeroes).

10. Return the String consisting of the code point of the most
    significant digit of the decimal representation of _s_, followed by
    code point U+002E (FULL STOP), followed by the code points of the
    remaining _k_−1 digits of the decimal representation of _s_,
    followed by code point U+0065 (LATIN SMALL LETTER E), followed by
    code point U+002B (PLUS SIGN) or the code point U+002D
    (HYPHEN-MINUS) according to whether _n_−1 is positive or negative,
    followed by the code points of the decimal representation of the
    integer abs(_n_−1) (with no leading zeroes).

NOTE 1 The following observations may be useful as guidelines for
implementations, but are not part of the normative requirements of this
Standard:

-   If x is any Number value other than −0, then ToNumber(ToString(x))
    is exactly the same Number value as x.

-   The least significant digit of s is not always uniquely determined
    by the requirements listed in step 5.

NOTE 2 For implementations that provide more accurate conversions than
required by the rules above, it is recommended that the following
alternative version of step 5 be used as a guideline:

  Otherwise, let _n_, _k_, and _s_ be integers such that _k_ ≥ 1,
  10^_k_−1^ ≤ _s_ < 10_^k^_, the Number value for _s_ × 10^_n_−_k_^ is
  _m_, and _k_ is as small as possible. If there are multiple
  possibilities for _s_, choose the value of _s_ for which _s_ ×
  10^_n_−_k_^ is closest in value to _m_. If there are two such possible
  values of _s_, choose the one that is even. Note that _k_ is the
  number of digits in the decimal representation of _s_ and that _s_ is
  not divisible by 10.

NOTE 3 Implementers of ECMAScript may find useful the paper and code
written by David M. Gay for binary-to-decimal conversion of
floating-point numbers:

  Gay, David M. Correctly Rounded Binary-Decimal and Decimal-Binary
  Conversions. Numerical Analysis, Manuscript 90-10. AT&T Bell
  Laboratories (Murray Hill, New Jersey). November 30, 1990. Available
  as
  http://cm.bell-labs.com/cm/cs/doc/90/4-10.ps.gz. Associated code
  available as
  http://netlib.sandia.gov/fp/dtoa.c and as
  http://netlib.sandia.gov/fp/g_fmt.c and may also be found at the
  various NETLIB mirror sites.

ToObject ( argument )

The abstract operation ToObject converts _argument_ to a value of type
Object according to Table 13:

Table 13 — ToObject Conversions

  ------------------- ---------------------------------------------------------------------------------------------------------------------------------------------------
  _ARGUMENT TYPE_     _RESULT_
  Completion Record   If _argument_ is an abrupt completion, return _argument_. Otherwise return ToObject(_argument_.[[value]])
  Undefined           Throw a TYPEERROR exception.
  Null                Throw a TYPEERROR exception.
  Boolean             Return a new Boolean object whose [[BooleanData]] internal slot is set to the value of _argument_. See 19.3 for a description of Boolean objects.
  Number              Return a new Number object whose [[NumberData]] internal slot is set to the value of _argument_. See 20.1 for a description of Number objects.
  String              Return a new String object whose [[StringData]] internal slot is set to the value of _argument_. See 21.1 for a description of String objects.
  Symbol              Return a new Symbol object whose [[SymbolData]] internal slot is set to the value of _argument_. See 19.4 for a description of Symbol objects.
  Object              Return _argument_ (no conversion).
  ------------------- ---------------------------------------------------------------------------------------------------------------------------------------------------

ToPropertyKey ( argument ) 

The abstract operation ToPropertyKey converts _argument_ to a value that
can be used as a property key by performing the following steps:

1.  ReturnIfAbrupt(_argument_).

2.  If Type(_argument_) is Symbol, then

    a.  Return _argument_.

3.  Return ToString(_argument_).

ToLength ( argument ) 

The abstract operation ToLength converts _argument_ to an integer
suitable for use as the length of an array-like object. It performs the
following steps:

1.  ReturnIfAbrupt(_argument_).

2.  Let _len_ be ToInteger(_argument_).

3.  ReturnIfAbrupt(_len_).

4.  If _len_ ≤ +0, then return +0.

5.  Return min(_len_, 2^53^-1).

CanonicalNumericIndexString ( argument )

The abstract operation CanonicalNumericIndexString returns _argument_
converted to a numeric value if it is a String representation of a
Number that would be produced by ToString, or the string "-0".
Otherwise, it returns UNDEFINED. This abstract operation functions as
follows:

1.  Assert: Type(_argument_) is String.

2.  If _argument_ is "-0", then return −0.

3.  Let _n_ be ToNumber(_argument_).

4.  5.  If SameValue(ToString(_n_), _argument_) is FALSE, then return
    UNDEFINED.

6.  Return _n_.

A _canonical numeric string_ is any String value for which the
CanonicalNumericIndexString abstraction operation does not return
UNDEFINED.


Testing and Comparison Operations

CheckObjectCoercible ( argument )

The abstract operation CheckObjectCoercible throws an error if
_argument_ is a value that cannot be converted to an Object using
ToObject. It is defined by Table 14:

Table 14 — CheckObjectCoercible Results

  _ARGUMENT TYPE_     _RESULT_
  ------------------- -----------------------------------------------------------------------------------------------------------------------
  Completion Record   If _argument_ is an abrupt completion, return _argument_. Otherwise return CheckObjectCoercible(_argument_.[[value]])
  Undefined           Throw a TYPEERROR exception.
  Null                Throw a TYPEERROR exception.
  Boolean             Return _argument_
  Number              Return _argument_
  String              Return _argument_
  Symbol              Return _argument_
  Object              Return _argument_

IsCallable ( argument )

The abstract operation IsCallable determines if _argument_, which must
be an ECMAScript language value or a Completion Record, is a callable
function Object according to Table 15:

Table 15 — IsCallable Results

  ------------------- -------------------------------------------------------------------------------------------------------------
  _ARGUMENT TYPE_     _RESULT_
  Completion Record   If _argument_ is an abrupt completion, return _argument_. Otherwise return IsCallable(_argument_.[[value]])
  Undefined           Return FALSE.
  Null                Return FALSE.
  Boolean             Return FALSE.
  Number              Return FALSE.
  String              Return FALSE.
  Symbol              Return FALSE.
  Object              If _argument_ has a [[Call]] internal method, then return TRUE, otherwise return FALSE.
  ------------------- -------------------------------------------------------------------------------------------------------------

SameValue(x, y)

The internal comparison abstract operation SameValue(_x_, _y_), where
_x_ and _y_ are ECMAScript language values, produces TRUE or FALSE. Such
a comparison is performed as follows:

1.  ReturnIfAbrupt(_x_).

2.  ReturnIfAbrupt(_y_).

3.  If Type(_x_) is different from Type(_y_), return FALSE.

4.  If Type(_x_) is Undefined, return TRUE.

5.  If Type(_x_) is Null, return TRUE.

6.  If Type(_x_) is Number, then

    a.  If _x_ is NaN and _y_ is NaN, return TRUE.

    b.  If _x_ is +0 and _y_ is -0, return FALSE.

    c.  If _x_ is -0 and _y_ is +0, return FALSE.

    d.  If _x_ is the same Number value as _y_, return TRUE.

    e.  Return FALSE.

7.  If Type(_x_) is String, then

    a.  If _x_ and _y_ are exactly the same sequence of code units (same
        length and same code units in corresponding positions) return
        TRUE; otherwise, return FALSE.

8.  If Type(_x_) is Boolean, then

    a.  If _x_ and _y_ are both TRUE or both FALSE, then return TRUE;
        otherwise, return FALSE.

9.  If Type(_x_) is Symbol, then

    a.  If _x_ and _y_ are both the same Symbol value, then return TRUE;
        otherwise, return FALSE.

10. Return TRUE if _x_ and _y_ are the same Object value. Otherwise,
    return FALSE.

SameValueZero(x, y)

The internal comparison abstract operation SameValueZero(_x_, _y_),
where _x_ and _y_ are ECMAScript language values, produces TRUE or
FALSE. Such a comparison is performed as follows:

1.  ReturnIfAbrupt(_x_).

2.  ReturnIfAbrupt(_y_).

3.  If Type(_x_) is different from Type(_y_), return FALSE.

4.  If Type(_x_) is Undefined, return TRUE.

5.  If Type(_x_) is Null, return TRUE.

6.  If Type(_x_) is Number, then

    a.  If _x_ is NaN and _y_ is NaN, return TRUE.

    b.  If _x_ is +0 and _y_ is -0, return TRUE.

    c.  If _x_ is -0 and _y_ is +0, return TRUE.

    d.  If _x_ is the same Number value as _y_, return TRUE.

    e.  Return FALSE.

7.  If Type(_x_) is String, then

    a.  If _x_ and _y_ are exactly the same sequence of code units (same
        length and same code units in corresponding positions) return
        TRUE; otherwise, return FALSE.

8.  If Type(_x_) is Boolean, then

    a.  If _x_ and _y_ are both TRUE or both FALSE, then return TRUE;
        otherwise, return FALSE.

9.  If Type(_x_) is Symbol, then

    a.  If _x_ and _y_ are both the same Symbol value, then return TRUE;
        otherwise, return FALSE.

10. Return TRUE if _x_ and _y_ are the same Object value. Otherwise,
    return FALSE.

NOTE SameValueZero differs from SameValue only in its treatment of +0
and -0.

IsConstructor ( argument )

The abstract operation IsConstructor determines if _argument_, which
must be an ECMAScript language value or a Completion Record, is a
function object with a [[Construct]] internal method.

1.  ReturnIfAbrupt(_argument_).

2.  If Type(_argument_) is not Object, return FALSE.

3.  If _argument_ has a [[Construct]] internal method, return TRUE.

4.  Return FALSE.

IsPropertyKey ( argument )

The abstract operation IsPropertyKey determines if _argument_, which
must be an ECMAScript language value or a Completion Record, is a value
that may be used as a property key.

1.  ReturnIfAbrupt(_argument_).

2.  If Type(_argument_) is String, return TRUE.

3.  If Type(_argument_) is Symbol, return TRUE.

4.  Return FALSE.

IsExtensible (O)

The abstract operation IsExtensible is used to determine whether
additional properties can be added to the object that is _O_. A Boolean
value is returned. This abstract operation performs the following steps:

1.  Assert: Type(_O_) is Object.

2.  Return the result of calling the [[IsExtensible]] internal method of
    _O_.

IsInteger ( argument )

The abstract operation IsInteger determines if _argument_ is a finite
integer numeric value.

1.  ReturnIfAbrupt(_argument_).

2.  If Type(_argument_) is not Number, return FALSE.

3.  If _argument_ is NAN, +∞, or −∞, return FALSE.

4.  If floor(abs(_argument_)) ≠ abs(_argument_), then return FALSE.

5.  Return TRUE.

Abstract Relational Comparison 

The comparison _x_ < _y_, where _x_ and _y_ are values, produces TRUE,
FALSE, or UNDEFINED (which indicates that at least one operand is NAN).
In addition to _x_ and _y_ the algorithm takes a Boolean flag named
_LeftFirst_ as a parameter. The flag is used to control the order in
which operations with potentially visible side-effects are performed
upon _x_ and _y_. It is necessary because ECMAScript specifies left to
right evaluation of expressions. The default value of _LeftFirst_ is
TRUE and indicates that the _x_ parameter corresponds to an expression
that occurs to the left of the _y_ parameter’s corresponding expression.
If _LeftFirst_ is FALSE, the reverse is the case and operations must be
performed upon _y_ before _x_. Such a comparison is performed as
follows:

1.  ReturnIfAbrupt(_x_).

2.  ReturnIfAbrupt(_y_).

3.  If the _LeftFirst_ flag is TRUE, then

    a.  Let _px_ be ToPrimitive(_x_, hint Number).

    b.  ReturnIfAbrupt(_px_).

    c.  Let _py_ be ToPrimitive(_y_, hint Number).

    d.  ReturnIfAbrupt(_py_).

4.  Else the order of evaluation needs to be reversed to preserve left
    to right evaluation

    a.  Let _py_ be ToPrimitive(_y_, hint Number).

    b.  ReturnIfAbrupt(_py_).

    c.  Let _px_ be ToPrimitive(_x_, hint Number).

    d.  ReturnIfAbrupt(_px_).

5.  If both _px_ and _py_ are Strings, then

    a.  If _py_ is a prefix of _px_, return FALSE. (A String value _p_
        is a prefix of String value _q_ if _q_ can be the result of
        concatenating _p_ and some other String _r_. Note that any
        String is a prefix of itself, because _r_ may be the empty
        String.)

    b.  If _px_ is a prefix of _py_, return TRUE.

    c.  Let _k_ be the smallest nonnegative integer such that the code
        unit at position _k_ within _px_ is different from the code unit
        at position _k_ within _py_. (There must be such a _k_, for
        neither String is a prefix of the other.)

    d.  Let _m_ be the integer that is the code unit value at position
        _k_ within _px_.

    e.  Let _n_ be the integer that is the code unit value at position
        _k_ within _py_.

    f.  If _m_ < _n_, return TRUE. Otherwise, return FALSE.

6.  Else,

    a.  Let _nx_ be ToNumber(_px_). Because _px_ and _py_ are primitive
        values evaluation order is not important.

    b.  ReturnIfAbrupt(_nx_).

    c.  Let _ny_ be ToNumber(_py_).

    d.  ReturnIfAbrupt(_ny_).

    e.  If _nx_ is NAN, return UNDEFINED.

    f.  If _ny_ is NAN, return UNDEFINED.

    g.  If _nx_ and _ny_ are the same Number value, return FALSE.

    h.  If _nx_ is +0 and _ny_ is −0, return FALSE.

    i.  If _nx_ is −0 and _ny_ is +0, return FALSE.

    j.  If _nx_ is +∞, return FALSE.

    k.  If _ny_ is +∞, return TRUE.

    l.  If _ny_ is −∞, return FALSE.

    m.  If _nx_ is −∞, return TRUE.

    n.  If the mathematical value of _nx_ is less than the mathematical
        value of _ny_ —note that these mathematical values are both
        finite and not both zero—return TRUE. Otherwise, return FALSE.

NOTE 1 Step 5 differs from step 11 in the algorithm for the addition
operator + (12.7.3) in using “and” instead of “or”.

NOTE 2 The comparison of Strings uses a simple lexicographic ordering on
sequences of code unit values. There is no attempt to use the more
complex, semantically oriented definitions of character or string
equality and collating order defined in the Unicode specification.
Therefore String values that are canonically equal according to the
Unicode standard could test as unequal. In effect this algorithm assumes
that both Strings are already in normalized form. Also, note that for
strings containing supplementary characters, lexicographic ordering on
sequences of UTF-16 code unit values differs from that on sequences of
code point values.

Abstract Equality Comparison 

The comparison _x_ == _y_, where _x_ and _y_ are values, produces TRUE
or FALSE. Such a comparison is performed as follows:

1.  ReturnIfAbrupt(_x_).

2.  ReturnIfAbrupt(_y_).

3.  If Type(_x_) is the same as Type(_y_), then

    a.  Return the result of performing Strict Equality Comparison _x_
        === _y_.

4.  If _x_ is NULL and _y_ is UNDEFINED, return TRUE.

5.  If _x_ is UNDEFINED and _y_ is NULL, return TRUE.

6.  If Type(_x_) is Number and Type(_y_) is String,
    return the result of the comparison _x_ == ToNumber(_y_).

7.  If Type(_x_) is String and Type(_y_) is Number,
    return the result of the comparison ToNumber(_x_) == _y_.

8.  If Type(_x_) is Symbol or Type(_y_) is Symbol, return FALSE.

9.  If Type(_x_) is Boolean, return the result of the comparison
    ToNumber(_x_) == _y_.

10. If Type(_y_) is Boolean, return the result of the comparison _x_ ==
    ToNumber(_y_).

11. If Type(_x_) is either String or Number and Type(_y_) is Object,
    return the result of the comparison _x_ == ToPrimitive(_y_).

12. If Type(_x_) is Object and Type(_y_) is either String or Number,
    return the result of the comparison ToPrimitive(_x_) == _y_.

13. Return FALSE.

Strict Equality Comparison 

The comparison _x_ === _y_, where _x_ and _y_ are values, produces TRUE
or FALSE. Such a comparison is performed as follows:

1.  If Type(_x_) is different from Type(_y_), return FALSE.

2.  If Type(_x_) is Undefined, return TRUE.

3.  If Type(_x_) is Null, return TRUE.

4.  If Type(_x_) is Number, then

    a.  If _x_ is NAN, return FALSE.

    b.  If _y_ is NAN, return FALSE.

    c.  If _x_ is the same Number value as _y_, return TRUE.

    d.  If _x_ is +0 and _y_ is −0, return TRUE.

    e.  If _x_ is −0 and _y_ is +0, return TRUE.

    f.  Return FALSE.

5.  If Type(_x_) is String, then

    a.  If _x_ and _y_ are exactly the same sequence of code units (same
        length and same code units in corresponding positions), return
        TRUE.

    b.  Else, return FALSE.

6.  If Type(_x_) is Boolean, then

    a.  If _x_ and _y_ are both TRUE or both FALSE, return TRUE.

    b.  Else, return FALSE.

7.  If _x_ and _y_ are the same Symbol value, return TRUE.

8.  If _x_ and _y_ are the same Object value, return TRUE.

9.  Return FALSE.

NOTE This algorithm differs from the SameValue Algorithm (7.2.3) in its
treatment of signed zeroes and NaNs.


 Operations on Objects

Get (O, P)

The abstract operation Get is used to retrieve the value of a specific
property of an object. The operation is called with arguments _O_ and
_P_ where _O_ is the object and _P_ is the property key. This abstract
operation performs the following steps:

1.  Assert: Type(_O_) is Object.

2.  Assert: IsPropertyKey(_P_) is TRUE.

3.  Return the result of calling the [[Get]] internal method of _O
    passing _P_ and _O_ as the arguments.

Put (O, P, V, Throw)

The abstract operation Put is used to set the value of a specific
property of an object. The operation is called with arguments _O_, _P_,
_V_, and _Throw_ where _O_ is the object, _P_ is the property key, _V
is the new value for the property and _Throw_ is a Boolean flag. This
abstract operation performs the following steps:

1.  Assert: Type(_O_) is Object.

2.  Assert: IsPropertyKey(_P_) is TRUE.

3.  Assert: Type(_Throw_) is Boolean.

4.  Let _success_ be the result of calling the [[Set]] internal method
    of _O_ passing _P_, _V_, and _O_ as the arguments.

5.  ReturnIfAbrupt(_success_).

6.  If _success_ is FALSE and _Throw_ is TRUE, then throw a TYPEERROR
    exception.

7.  Return _success_.

CreateDataProperty (O, P, V)

The abstract operation CreateDataProperty is used to create a new own
property of an object. The operation is called with arguments _O_, _P_,
and _V_ where _O_ is the object, _P_ is the property key, and _V_ is the
value for the property. This abstract operation performs the following
steps:

1.  Assert: Type(_O_) is Object.

2.  Assert: IsPropertyKey(_P_) is TRUE.

3.  Let _newDesc_ be the PropertyDescriptor{[[Value]]: _V_,
    [[Writable]]: TRUE, [[Enumerable]]: TRUE, [[Configurable]]: TRUE}.

4.  Return the result of calling the [[DefineOwnProperty]] internal
    method of _O_ passing _P_ and _newDesc_ as arguments.

NOTE This abstract operation creates a property whose attributes are set
to the same defaults used for properties created by the ECMAScript
language assignment operator. Normally, the property will not already
exist. If it does exist and is not configurable or O is not extensible
[[DefineOwnProperty]] will return FALSE.

CreateDataPropertyOrThrow (O, P, V)

The abstract operation CreateDataPropertyOrThrow is used to create a new
own property of an object. It throws a TYPEERROR exception if the
requested property update cannot be performed. The operation is called
with arguments _O_, _P_, and _V_ where _O_ is the object, _P_ is the
property key, and _V_ is the value for the property. This abstract
operation performs the following steps:

1.  Assert: Type(_O_) is Object.

2.  Assert: IsPropertyKey(_P_) is TRUE.

3.  Let _success_ be CreateDataProperty(_O_, _P_, _V_).

4.  ReturnIfAbrupt(_success_).

5.  If _success_ is FALSE, then throw a TYPEERROR exception.

6.  Return _success_.

NOTE This abstract operation creates a property whose attributes are set
to the same defaults used for properties created by the ECMAScript
language assignment operator. Normally, the property will not already
exist. If it does exist and is not configurable or O is not extensible
[[DefineOwnProperty]] will return FALSE causing this operation to throw
a TYPEERROR exception.

DefinePropertyOrThrow (O, P, desc)

The abstract operation DefinePropertyOrThrow is used to call the
[[DefineOwnProperty]] internal method of an object in a manner that will
throw a TYPEERROR exception if the requested property update cannot be
performed. The operation is called with arguments _O_, _P_, and _desc_
where _O_ is the object, _P_ is the property key, and _desc_ is the
Property Descriptor for the property. This abstract operation performs
the following steps:

1.  Assert: Type(_O_) is Object.

2.  Assert: IsPropertyKey(_P_) is TRUE.

3.  Let _success_ be the result of calling the [[DefineOwnProperty]]
    internal method of _O_ passing _P_ and _desc_ as arguments.

4.  ReturnIfAbrupt(_success_).

5.  If _success_ is FALSE, then throw a TYPEERROR exception.

6.  Return _success_.

DeletePropertyOrThrow (O, P)

The abstract operation DeletePropertyOrThrow is used to remove a
specific own property of an object. It throws an exception if the
property is not configurable. The operation is called with arguments _O_
and _P_ where _O_ is the object and _P_ is the property key. This
abstract operation performs the following steps:

1.  Assert: Type(_O_) is Object.

2.  Assert: IsPropertyKey(_P_) is TRUE.

3.  Let _success_ be the result of calling the [[Delete]] internal
    method of _O_ passing _P_ as the argument.

4.  ReturnIfAbrupt(_success_).

5.  If _success_ is FALSE, then throw a TYPEERROR exception.

6.  Return _success_.

GetMethod (O, P)

The abstract operation GetMethod is used to get the value of a specific
property of an object when the value of the property is expected to be a
function. The operation is called with arguments _O_ and _P_ where _O_
is the object, _P_ is the property key. This abstract operation performs
the following steps:

1.  Assert: Type(_O_) is Object.

2.  Assert: IsPropertyKey(_P_) is TRUE.

3.  Let _func_ be the result of calling the [[Get]] internal method of
    _O_ passing _P_ and _O_ as the arguments.

4.  ReturnIfAbrupt(_func_).

5.  If _func_ is either UNDEFINED or NULL, then return UNDEFINED.

6.  If IsCallable(_func_) is FALSE, then throw a TYPEERROR exception.

7.  Return _func_.

HasProperty (O, P)

The abstract operation HasProperty is used to determine whether an
object has a property with the specified property key. The property may
be either an own or inherited. A Boolean value is returned. The
operation is called with arguments _O_ and _P_ where _O_ is the object
and _P_ is the property key. This abstract operation performs the
following steps:

1.  Assert: Type(_O_) is Object.

2.  Assert: IsPropertyKey(_P_) is TRUE.

3.  Return the result of calling the [[HasProperty]] internal method of
    _O_ with argument _P_.

HasOwnProperty (O, P)

The abstract operation HasOwnProperty is used to determine whether an
object has an own property with the specified property key. A Boolean
value is returned. The operation is called with arguments _O_ and _P_
where _O_ is the object and _P_ is the property key. This abstract
operation performs the following steps:

1.  Assert: Type(_O_) is Object.

2.  Assert: IsPropertyKey(_P_) is TRUE.

3.  Let _desc_ be the result of calling the [[GetOwnProperty]] internal
    method of _O_ passing _P_ as the argument.

4.  ReturnIfAbrupt(_desc_).

5.  If _desc_ is UNDEFINED, return FALSE.

6.  Return TRUE.

Invoke(O,P, [args])

The abstract operation Invoke is used to call a method property of an
object. The operation is called with arguments _O_, _P_ , and optionally
_args_ where _O_ serves as both the lookup point for the property and
the THIS value of the call, _P_ is the property key, and _args_ is the
list of arguments values passed to the method. If _args_ is not present,
an empty List is used as its value. This abstract operation performs the
following steps:

1.  Assert: _P_ is a valid property key.

2.  If _args_ was not passed, then let _args_ be a new empty List.

3.  Let _obj_ be ToObject(_O_).

4.  ReturnIfAbrupt(_obj_).

5.  Let _func_ be the result of calling the [[Get]] internal method of
    _obj_ passing _P_ and _O_ as the arguments.

6.  ReturnIfAbrupt(_func_).

7.  If IsCallable(_func_) is FALSE, then throw a TYPEERROR exception.

8.  9.  Return the result of calling the [[Call]] internal method of
    _func_ passing _O_ as _thisArgument_ and _args_ as _argumentsList_.

SetIntegrityLevel (O, level)

The abstract operation SetIntegrityLevel is used to fix the set of own
properties of an object. This abstract operation performs the following
steps:

1.  Assert: Type(_O_) is Object.

2.  Assert: _level_ is either "SEALED" or "FROZEN".

3.  Let _keysArray_ be the result of calling the [[OwnPropertyKeys]]
    internal method of _O_.

4.  Let _keys_ be CreateListFromArrayLike(_keysArray_).

5.  ReturnIfAbrupt(_keys_).

6.  Let _pendingException_ be UNDEFINED.

7.  If _level_ is "SEALED", then

    a.  Repeat for each element _k_ of _keys_,

        i.  Let _status_ be DefinePropertyOrThrow(_O_, _k_,
            PropertyDescriptor{ [[Configurable]]: FALSE}).

        ii. If _status_ is an abrupt completion, then

            1.  If _pendingException_ is UNDEFINED, then set
                _pendingException_ to _status_.

8.  Else _level_ is "FROZEN",

    a.  Repeat for each element _k_ of _keys_,

        i.  Let _status_ be the result of calling the [[GetOwnProperty]]
            internal method of _O_ with _k_.

        ii. If _status_ is an abrupt completion, then

            1.  If _pendingException_ is UNDEFINED, then set
                _pendingException_ to _status_.

        iii. Else,

            1.  Let _currentDesc_ be _status_.[[value]].

            2.  If _currentDesc_ is not UNDEFINED, then

                a.  If IsAccessorDescriptor(_currentDesc_) is TRUE, then

                    i.  Let _desc_ be the
                        PropertyDescriptor{[[Configurable]]: FALSE}.

                b.  Else,

                    i.  Let _desc_ be the PropertyDescriptor {
                        [[Configurable]]: FALSE, [[Writable]]: FALSE }.

                c.  Let _status_ be DefinePropertyOrThrow(_O_, _k_,
                    _desc_).

                d.  If _status_ is an abrupt completion, then

                    i.  If _pendingException_ is UNDEFINED, then set
                        _pendingException_ to _status_.

9.  If _pendingException_ is not UNDEFINED, then return
    _pendingException_.

10. Return the result of calling the [[PreventExtensions]] internal
    method of _O_.

TestIntegrityLevel (O, level)

The abstract operation TestIntegrityLevel is used to determine if the
set of own properties of an object are fixed. This abstract operation
performs the following steps:

1.  Assert: Type(_O_) is Object.

2.  Assert: _level_ is either "SEALED" or "FROZEN".

3.  Let _status_ be IsExtensible(_O_).

4.  ReturnIfAbrupt(_status_).

5.  If _status_ is TRUE, then return FALSE

6.  NOTE If the object is extensible, none of its properties are
    examined.

7.  Let _keysArray_ be the result of calling the [[OwnPropertyKeys]]
    internal method of _O_.

8.  Let _keys_ be CreateListFromArrayLike(_keysArray_).

9.  ReturnIfAbrupt(_keys_).

10. Let _pendingException_ be UNDEFINED.

11. Let _configurable_ be FALSE.

12. Let _writable_ be FALSE.

13. Repeat for each element _k_ of _keys_,

    a.  Let _status_ be the result of calling the [[GetOwnProperty]]
        internal method of _O_ with _k_.

    b.  If _status_ is an abrupt completion, then

        i.  If _pendingException_ is UNDEFINED, then set
            _pendingException_ to _status_.

        ii. 

    c.  Else,

        i.  Let _currentDesc_ be _status_.[[value]].

        ii. If _currentDesc_ is not UNDEFINED, then

            1.  Set _configurable_ to _configurable_ logically ored with
                _currentDesc_.[[Configurable]].

            2.  If IsDataDescriptor(_currentDesc_) is TRUE, then

                a.  Set _writable_ to _writable_ logically ored with
                    _currentDesc_.[[Writable]].

14. If _pendingException_ is not UNDEFINED, then return
    _pendingException_.

15. If _level_ is "FROZEN" and _writable_ is TRUE, then return FALSE.

16. If _configurable_ is TRUE, then return FALSE.

17. Return TRUE.

CreateArrayFromList (elements)

The abstract operation CreateArrayFromList is used to create an Array
object whose elements are provided by a List. This abstract operation
performs the following steps:

1.  Assert: _elements_ is a List whose elements are all ECMAScript
    language values.

2.  Let _array_ be ArrayCreate(0) (see 9.4.2.2).

3.  Let _n_ be 0.

4.  For each element _e_ of _elements

    a.  Let _status_ be the result of CreateDataProperty(_array_,
        ToString(_n_), _e_).

    b.  Assert: _status_ is TRUE.

    c.  Increment _n_ by 1.

5.  Return _array_.

CreateListFromArrayLike (obj)

The abstract operation CreateListFromArrayLike is used to create a List
value whose elements are provided by the indexed properties of an
array-like object. This abstract operation performs the following steps:

1.  ReturnIfAbrupt(_obj_).

2.  If Type(_obj_) is not Object, then throw a TYPEERROR exception.

3.  Let _len_ be Get(_obj_, "LENGTH").

4.  Let _n_ be ToLength(_len_).

5.  ReturnIfAbrupt(_n_).

6.  Let _list_ be an empty List.

7.  Let _index_ be 0.

8.  Repeat while _index_ < _n

    a.  Let _indexName_ be ToString(_index_).

    b.  Let _next_ be Get(_obj_, _indexName_).

    c.  ReturnIfAbrupt(_next_).

    d.  Append _next_ as the last element of _list_.

    e.  Set _index_ to _index_ + 1.

9.  Return _list_.

OrdinaryHasInstance (C, O)

The abstract operation OrdinaryHasInstance implements the default
algorithm for determining if an object _O_ inherits from the instance
object inheritance path provided by constructor _C_. This abstract
operation performs the following steps:

1.  If IsCallable(_C_) is FALSE, return FALSE.

2.  If _C_ has a [[BoundTargetFunction]] internal slot, then

    a.  Let _BC_ be the value of _C’s_ [[BoundTargetFunction]] internal
        slot.

    b.  Return InstanceofOperator(_O_,_BC_) (see 12.9.4).

3.  If Type(_O_) is not Object, return FALSE.

4.  Let _P_ be Get(_C_, "PROTOTYPE").

5.  ReturnIfAbrupt(_P_).

6.  If Type(_P_) is not Object, throw a TYPEERROR exception.

7.  Repeat

    a.  Set _O_ to the result of calling the [[GetPrototypeOf]] internal
        method of _O_ with no arguments.

    b.  ReturnIfAbrupt(_O_).

    c.  If _O_ is NULL, return FALSE.

    d.  If SameValue(_P_, _O_) is TRUE, return TRUE.

GetPrototypeFromConstructor ( constructor, intrinsicDefaultProto )

The abstract operation GetPrototypeFromConstructor determines the
[[Prototype]] value that should be used to create an object
corresponding to a specific constructor. The value is retrieved from the
constructor’s PROTOTYPE property, if it exists. Otherwise the supplied
default is used for [[Prototype]]. This abstract operation performs the
following steps:

1.  Assert: _intrinsicDefaultProto_ is a string value that is this
    specification’s name of an intrinsic object. The corresponding
    object must be an intrinsic that is intended to be used as the
    [[Prototype]] value of an object.

2.  If IsConstructor (_constructor_) is FALSE, then throw a TYPEERROR
    exception.

3.  Let _proto_ be Get(_constructor_, "PROTOTYPE").

4.  ReturnIfAbrupt(_proto_).

5.  If Type(_proto_) is not Object, then

    a.  Let _realm_ be GetFunctionRealm(_constructor_).

    b.  i.  ii. 

    c.  Let _proto_ be _realm’s_ intrinsic object named
        _intrinsicDefaultProto_.

6.  Return _proto_.

NOTE If _constructor_ does not supply a [[Prototype]] value, the default
value that is used is obtained from the Code Realm of the _constructor_
function rather than from the running execution context. This accounts
for the possibility that a built-in @@create method from a different
Code Realm might be installed on _constructor_.

CreateFromConstructor (F)

When the abstract operation CreateFromConstructor is called with Object
_F_ the following steps are taken:

1.  Let _creator_ be GetMethod (_F_, @@create).

2.  ReturnIfAbrupt(_creator_).

3.  If _creator_ is UNDEFINED, then return UNDEFINED.

4.  Let _obj_ be the result of calling the [[Call]] internal method of
    _creator_ with arguments _F_ and an empty List.

5.  ReturnIfAbrupt(_obj_).

6.  If Type(_obj_) is not Object, then throw a TYPEERROR exception.

7.  Return _obj_.

NOTE This operation is equivalent to: F[SYMBOL.CREATE]()followed by an
error check.

Construct (F, argumentsList)

When the abstract operation Construct is called with Object _F_ and List
_argumentsList_ the following steps are taken:

1.  Assert: Type(_F_) is Object.

2.  Let _obj_ be CreateFromConstructor(_F_).

3.  ReturnIfAbrupt(_obj_).

4.  If _obj_ is UNDEFINED, then

    a.  Let _obj_ be OrdinaryCreateFromConstructor(_F_,
        "%OBJECTPROTOTYPE%").

    b.  ReturnIfAbrupt(_obj_).

    c.  Assert: Type(_obj_) is Object.

5.  Let _result_ be the result of calling the [[Call]] internal method
    of _F_, providing _obj_ and _argumentsList_ as the arguments.

6.  ReturnIfAbrupt(_result_).

7.  If Type(_result_) is Object then return _result_.

8.  Return _obj_.

NOTE This operation is equivalent to: NEW F(...ARGUMENTSLIST)

GetOption (options, P)

The abstract operation GetOption is used to retrieve the value of a
specific property of an object in situation where the object may not be
present. The operation is called with arguments _options_ and _P_ where
_options_ is the object and _P_ is the property key. This abstract
operation performs the following steps:

1.  Assert: IsPropertyKey(_P_) is TRUE.

2.  If _options_ is UNDEFINED, then return UNDEFINED.

3.  If Type(_options_) is not Object, then throw a TYPEERROR exception.

4.  Return the result of calling the [[Get]] internal method of
    _options_ passing _P_ and _options_ as the arguments.

EnumerableOwnNames (O)

When the abstract operation EnumerableOwnNames is called with Object _O_
the following steps are taken:

1.  Assert: Type(_O_) is Object.

2.  Let _ownKey_ be the result of calling the [[OwnPropertyKeys]]
    internal method of _O_ with no arguments.

3.  ReturnIfAbrupt(_ownKeys_).

4.  Let _length_ be ToLength(Get(_ownKeys_, "LENGTH")).

5.  ReturnIfAbrupt(_length_).

6.  Let _names_ be a new empty List.

7.  Let _k_ be 0.

8.  Repeat, while _k <_ _length

    a.  Let _key_ be Get(_ownKeys_, ToString(_k_)).

    b.  ReturnIfAbrupt(_key_).

    c.  If Type(_key_) is String, then

        i.  Let _desc_ be the resulting of calling the
            [[GetOwnProperty]] internal method of _O_ with argument
            _key_.

        ii. ReturnIfAbrupt(_desc_).

        iii. If _desc_ is not UNDEFINED, then

            1.  If _desc._[[Enumerable]] is TRUE, then append _key_ to
                _names_.

    d.  Let _k_ be _k_ + 1.

9.  Return _names_.

GetFunctionRealm ( obj ) Abstract Operation

The abstract operation GetFunctionRealm with argument _obj_ performs the
following steps:

1.  Assert: _obj_ is a callable object.

2.  If _obj_ has a [[Realm]] internal slot, then

    a.  Return _obj_’s [[Realm]] internal slot.

3.  If _obj_ is a Bound Function exotic object, then

    a.  Let _target_ be _obj_s [[BoundTargetFunction]] internal slot.

    b.  Return GetFunctionRealm(_target_).

4.  If _obj_ is a Proxy exotic object, then

    a.  Let _proxyTarget_ be the value of _obj_’s [[ProxyTarget]]
        internal slot.

    b.  Return GetFunctionRealm(_proxyTarget_).

5.  Return the running execution context’s Realm.

NOTE Step 5 will only be reached if _target_ is a non-standard exotic
function object that does not have a [[Realm]] internal slot.


Operations on Iterator Objects

See Commmon Iteration Interfaces (25.1).

CheckIterable ( obj )

The abstract operation CheckIterable with argument _obj_ performs the
following steps:

1.  If Type(_obj_) is not Object, then return UNDEFINED.

2.  Return Get(_obj_, @@iterator).

3.  

GetIterator ( obj, method )

The abstract operation GetIterator with argument _obj_ and optional
argument _method_ performs the following steps:

1.  ReturnIfAbrupt(_obj_).

2.  If _method_ was not passed, then

    a.  Let _method_ be CheckIterable(_obj_).

    b.  ReturnIfAbrupt(_method_).

3.  If IsCallable(_method_) is FALSE, then throw a TYPEERROR
    exception_._

4.  Let _iterator_ be the result of calling the [[Call]] internal method
    of _method_ with _obj_ as _thisArgument_ and an empty List as
    _argumentsList_.

5.  ReturnIfAbrupt(_iterator_)_.

6.  If Type(_iterator_) is not Object, then throw a TYPEERROR exception.

7.  Return _iterator_.

1.  2.  3.  

IteratorNext ( iterator, value )

The abstract operation IteratorNext with argument _iterator_ and
optional argument _value_ performs the following steps:

1.  If _value_ was not passed,

    a.  Let _result_ be Invoke(_iterator_, "NEXT", ( )).

2.  Else,

    a.  Let _result_ be Invoke(_iterator_, "NEXT", (_value_)).

3.  ReturnIfAbrupt(_result_).

4.  If Type(_result_) is not Object, then throw a TYPEERROR exception.

5.  Return _result_.

IteratorComplete ( iterResult )

The abstract operation IteratorComplete with argument _iterResult_
performs the following steps:

1.  Assert: Type(_iterResult_) is Object.

2.  Let _done_ be Get(_iterResult_, "DONE").

3.  Return ToBoolean(_done_).

IteratorValue ( iterResult )

The abstract operation IteratorValue with argument _iterResult_ performs
the following steps:

1.  Assert: Type(_iterResult_) is Object.

2.  Return Get(_iterResult_, "VALUE").

IteratorStep ( iterator )

The abstract operation IteratorStep with argument _iterator_ requests
the next value from _iterator_ and returns either FALSE indicating that
the iterator has reached its end or the IteratorResult object if a next
value is available. IteratorStep performs the following steps:

1.  Let _result_ be IteratorNext(_iterator_).

2.  ReturnIfAbrupt(_result_).

3.  Let _done_ be IteratorComplete(_result_).

4.  ReturnIfAbrupt(_done_).

5.  If _done_ is TRUE, then return FALSE.

6.  Return _result_.

CreateIterResultObject (value, done)

The abstract operation CreateIterResultObject with arguments _value_ and
_done_ creates an object that supports the IteratorResult interface by
performing the following steps:

1.  Assert: Type(_done_) is Boolean.

2.  Let _obj_ be ObjectCreate(%ObjectPrototype%).

3.  Perform CreateDataProperty(_obj_, "VALUE", _value_).

4.  Perform CreateDataProperty(_obj_, "DONE", _done_).

5.  Return _obj_.

CreateListIterator (list) 

The abstract operation CreateListIterator with argument _list_ creates
an Iterator (25.1.2) object whose next method returns the successive
elements of _list_. It performs the following steps:

1.  Let _iterator_ be ObjectCreate(%ObjectPrototype%, ([[IteratorNext]],
    [[IteratedList]], [[ListIteratorNextIndex]])).

2.  Set _iterator’s_ [[IteratedList]] internal slot to _list_.

3.  Set _iterator’s_ [[ListIteratorNextIndex]] internal slot to 0.

4.  Let _next_ be a new built-in function object as defined in
    ListIterator NEXT (7.4.8.1).

5.  Set _iterator’s_ [[IteratedNext]] internal slot to _next_.

6.  Let _status_ be the result of CreateDataProperty(_iterator_, "NEXT",
    _next_).

7.  Return _iterator_.

ListIterator next( ) 

The ListIterator NEXT method is a standard built-in function object
(clause 17) that performs the following steps:

1.  Let _O_ be the THIS value.

2.  Let _f_ be the active function object.

3.  If _O_ does not have a [[IteratedNext]] internal slot, then throw a
    TYPEERROR exception.

4.  Let _next_ be the value of the [[IteratedNext]] internal slot of
    _O_.

5.  If SameValue(_f_, _next_) is FALSE, then throw a TYPEERROR
    exception.

6.  If _O_ does not have a [[IteratedList]] internal slot, then throw a
    TYPEERROR exception.

7.  Let _list_ be the value of the [[IteratedList]] internal slot of
    _O_.

8.  Let _index_ be the value of the [[ListIteratorNextIndex]] internal
    slot of _O_.

9.  Let _len_ be the number of elements of _list_.

10. If _index_ ≥ _len_, then

    a.  Return CreateIterResultObject(UNDEFINED, TRUE).

11. Set the value of the [[ListIteratorNextIndex]] internal slot of _O
    to _index_+1.

12. Return CreateIterResultObject(_list_[_index_], FALSE).

NOTE A ListIterator NEXT method will throw an exception if applied to
any object other than the one with which it was originally associated.

CreateEmptyIterator ( )

The abstract operation CreateEmptyIterator with no arguments creates an
Iterator object whose next method always reports that the iterator is
done. It performs the following steps:

1.  Let _empty_ be a List with no elements.

2.  Return CreateListIterator(_empty_).

CreateCompoundIterator ( iterator1, iterator2 ) 

The abstract operation CreateCompoundIterator with arguments _iterator1_
and _iterator2_ creates an Iterator (25.1.2) object whose next method
returns the successive elements of _iterator1_ followed by the
successive elements of _iterator2_. It performs the following steps:

1.  Let _iterator_ be ObjectCreate(%ObjectPrototype%, ([[Iterator1]],
    [[Iterator2]], [[State]], [[IteratorNext]])).

2.  Set _iterator’s_ [[Iterator1]] internal slot to _iterator1_.

3.  Set _iterator’s_ [[Iterator2]] internal slot to _iterator2_.

4.  Set _iterator’s_ [[State]] internal slot to 1.

5.  Let _next_ be a new built-in function object as defined in
    CompundIterator NEXT (7.4.10.1).

6.  Set _iterator’s_ [[IteratedNext]] internal slot to _next_.

7.  Let _status_ be the result of CreateDataProperty(_iterator_, "NEXT",
    _next_).

8.  Return _iterator_.

CompoundIterator next( ) 

The CompoundIterator NEXT method is a standard built-in function object
that performs the following steps:

1.  Let _O_ be the THIS value.

2.  Let _f_ be the active function object.

3.  If _O_ does not have a [[IteratedNext]] internal slot, then throw a
    TYPEERROR exception.

4.  Let _next_ be the value of the [[IteratedNext]] internal slot of
    _O_.

5.  If SameValue(_f_, _next_) is FALSE, then throw a TYPEERROR
    exception.

6.  If _O_ does not have a [[Iterator1]] internal slot, then throw a
    TYPEERROR exception.

7.  Assert: _O_ is an object created and initialized by
    CreateCompoundIterator.

8.  Let _state_ be the value of _O’s_ [[State] internal slot.

9.  If _state_ = 1, then

    a.  Let _iterator1_ be the value of _O’s_ [[Iterator1] internal
        slot.

    b.  Let _result1_ be IteratorStep(_iterator1_).

    c.  If _result1_ is not FALSE, then,

        i.  Return _result1._

    d.  Set _O’s_ [[State] internal slot to 2.

10. Let _iterator2_ be the value of _O’s_ [[Iterator2] internal slot.

11. Return IteratorNext(_iterator2_).

NOTE A CompoundIterator NEXT method will throw an exception if applied
to any object other than the one with which it was originally
associated.


Operations on Promise Objects

Promise Objects (25.4) serve as a placeholder for the eventual result of
a deferred (and possibly asynchronous) computation.

Within this specification the adjective “eventual” mean a value or a
Promise object that will ultimately resolves to the value. For example,
“Returns an eventual String” is equivalent to “Returns either a String
or a Promise object that will eventually resolves to a String”. A
“resolved value” is the final value of an “eventual value”.

NOTE The Promise related abstract operations defined in this subclause
are used by specification algorithms when they perform or respond to
asynchronous operations. They ensure that the actual built-in Promise
operations are used by the algorithms, even if ECMAScript code has
modified the properties of %Promise% or %PromisePrototype%.

PromiseNew ( executor ) Abstract Operation

The abstract operation PromiseNew allocates and initializes a new
_promise_ object for use by specification algorithm. The _executor
argument initiates the deferred computation.

1.  Let _promise_ be AllocatePromise(%Promise%).

2.  Return InitializePromise(_promise_, _executor_).

PromiseBuiltinCapability () Abstract Operation

The abstract operation PromiseBuiltinCapability allocates a
PromiseCapability record (25.4.1.1) for a builtin _promise_ object for
use by specification algorithm.

1.  Let _promise_ be AllocatePromise(%Promise%).

2.  Return CreatePromiseCapabilityRecord(_promise_, %Promise%).

NOTE This abstract operation is the same as the default built-in
behaviour of NewPromiseCapability abstract operation (25.4.1.4).

PromiseOf (value) Abstract Operation

The abstract operation PromiseOf returns a new Promise that resolves to
the argument _value_.

1.  Assert: IsPromise(_value_) is FALSE.

2.  Let _capability_ be PromiseBuiltinCapability( ).

3.  ReturnIfAbrupt(_capability_).

4.  Let _resolveResult_ be the result of calling the [[Call]] internal
    method of _capability_.[[Resolve]] with UNDEFINED as _thisArgument_
    and (_value_) as _argumentsList_.

5.  ReturnIfAbrupt(_resolveResult_).

6.  Return _capability_.[[Promise]].

NOTE This abstract operation is the same as the default built-in
behaviour of the Promise.resolve method (25.4.4.5). However, PromiseOf
does not accept a Promise is its argument.

PromiseAll (promiseList) Abstract Operation

PromiseCatch (promise, rejectedAction) Abstract Operation

PromiseThen (promise, resolvedAction, rejectedAction) Abstract Operation



EXECUTABLE CODE AND EXECUTION CONTEXTS


Lexical Environments

A _Lexical Environment_ is a specification type used to define the
association of _Identifiers_ to specific variables and functions based
upon the lexical nesting structure of ECMAScript code. A Lexical
Environment consists of an Environment Record and a possibly null
reference to an _outer_ Lexical Environment. Usually a Lexical
Environment is associated with some specific syntactic structure of
ECMAScript code such as a _FunctionDeclaration_, a _BlockStatement_, or
a _Catch_ clause of a _TryStatement_ and a new Lexical Environment is
created each time such code is evaluated.

An _Environment Record_ records the identifier bindings that are created
within the scope of its associated Lexical Environment.

The outer environment reference is used to model the logical nesting of
Lexical Environment values. The outer reference of a (inner) Lexical
Environment is a reference to the Lexical Environment that logically
surrounds the inner Lexical Environment. An outer Lexical Environment
may, of course, have its own outer Lexical Environment. A Lexical
Environment may serve as the outer environment for multiple inner
Lexical Environments. For example, if a _FunctionDeclaration_ contains
two nested _FunctionDeclarations_ then the Lexical Environments of each
of the nested functions will have as their outer Lexical Environment the
Lexical Environment of the current evaluation of the surrounding
function.

A _global environment_ is a Lexical Environment which does not have an
outer environment. The global environment’s outer environment reference
is NULL. A global environment’s environment record may be prepopulated
with identifier bindings and includes an associated _global object_
whose properties provide some of the global environment’s identifier
bindings. This global object is the value of a global environment’s THIS
binding. As ECMAScript code is executed, additional properties may be
added to the global object and the initial properties may be modified.

A method environment is a Lexical Environment that corresponds to the
invocation of an ECMAScript function object that establishes a new THIS
binding. A method environment also captures the state necessary to
support SUPER method invocations.

Lexical Environments and Environment Record values are purely
specification mechanisms and need not correspond to any specific
artefact of an ECMAScript implementation. It is impossible for an
ECMAScript program to directly access or manipulate such values.

Environment Records

There are two primary kinds of Environment Record values used in this
specification: _declarative environment records_ and _object environment
records_. Declarative environment records are used to define the effect
of ECMAScript language syntactic elements such as
_FunctionDeclarations_, _VariableDeclarations_, and _Catch_ clauses that
directly associate identifier bindings with ECMAScript language values.
Object environment records are used to define the effect of ECMAScript
elements such as _WithStatement_ that associate identifier bindings with
the properties of some object. Global Environment Records and Function
Environment Records are specializations that are used for specifically
for _Script_ global declarations and for top-level declarations within
functions.

For specification purposes Environment Record values can be thought of
as existing in a simple object-oriented hierarchy where Environment
Record is an abstract class with three concrete subclasses, declarative
environment record, object environment record, and global environment
record. Function environment records are a subclass of declarative
environment record. The abstract class includes the abstract
specification methods defined in Table 16. These abstract methods have
distinct concrete algorithms for each of the concrete subclasses.

Table 16 — Abstract Methods of Environment Records

  _METHOD_                     _PURPOSE_
  ---------------------------- --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  HasBinding(N)                Determine if an environment record has a binding for an identifier. Return TRUE if it does and FALSE if it does not. The String value _N_ is the text of the identifier.
  CreateMutableBinding(N, D)   Create a new but uninitialized mutable binding in an environment record. The String value _N_ is the text of the bound name. If the optional Boolean argument _D_ is TRUE the binding is may be subsequently deleted.
  CreateImmutableBinding(N)    Create a new but uninitialized immutable binding in an environment record. The String value N is the text of the bound name.
  InitializeBinding(N,V)       Set the value of an already existing but uninitialized binding in an environment record. The String value N is the text of the bound name. V is the value for the binding and is a value of any ECMAScript language type.
  SetMutableBinding(N,V, S)    Set the value of an already existing mutable binding in an environment record. The String value _N_ is the text of the bound name. _V_ is the value for the binding and may be a value of any ECMAScript language type. _S_ is a Boolean flag. If _S_ is TRUE and the binding cannot be set throw a TYPEERROR exception. _S_ is used to identify strict mode references.
  GetBindingValue(N,S)         Returns the value of an already existing binding from an environment record. The String value _N_ is the text of the bound name. _S_ is used to identify strict mode references. If _S_ is TRUE and the binding does not exist throw a REFERENCEERROR exception. If the binding exists but is uninitialized a REFERENCEERROR is thrown, regardless of the value of _S._
  DeleteBinding(N)             Delete a binding from an environment record. The String value _N_ is the text of the bound name If a binding for _N_ exists, remove the binding and return TRUE. If the binding exists but cannot be removed return FALSE. If the binding does not exist return TRUE.
  HasThisBinding()             Determine if an environment record establishes a THIS binding. Return TRUE if it does and FALSE if it does not.
  HasSuperBinding()            Determine if an environment record establishes a SUPER method binding. Return TRUE if it does and FALSE if it does not.
  WithBaseObject ()            If this environment record is associated with a WITH statement, return the with object. Otherwise, return UNDEFINED.

Declarative Environment Records

Each declarative environment record is associated with an ECMAScript
program scope containing variable, constant, let, class, module, import,
and/or function declarations. A declarative environment record binds the
set of identifiers defined by the declarations contained within its
scope.

The behaviour of the concrete specification methods for Declarative
Environment Records is defined by the following algorithms.

HasBinding(N)

The concrete environment record method HasBinding for declarative
environment records simply determines if the argument identifier is one
of the identifiers bound by the record:

1.  Let _envRec_ be the declarative environment record for which the
    method was invoked.

2.  If _envRec_ has a binding for the name that is the value of _N_,
    return TRUE.

3.  Return FALSE.

CreateMutableBinding (N, D)

The concrete Environment Record method CreateMutableBinding for
declarative environment records creates a new mutable binding for the
name _N_ that is uninitialized. A binding must not already exist in this
Environment Record for _N_. If Boolean argument _D_ is provided and has
the value TRUE the new binding is marked as being subject to deletion.

1.  Let _envRec_ be the declarative environment record for which the
    method was invoked.

2.  Assert: _envRec_ does not already have a binding for _N_.

3.  Create a mutable binding in _envRec_ for _N_ and record that it is
    uninitialized. If _D_ is TRUE record that the newly created binding
    may be deleted by a subsequent DeleteBinding call.

4.  Return NormalCompletion(empty).

CreateImmutableBinding (N)

The concrete Environment Record method CreateImmutableBinding for
declarative environment records creates a new immutable binding for the
name _N_ that is uninitialized. A binding must not already exist in this
environment record for _N_.

1.  Let _envRec_ be the declarative environment record for which the
    method was invoked.

2.  Assert: _envRec_ does not already have a binding for _N_.

3.  Create an immutable binding in _envRec_ for _N_ and record that it
    is uninitialized.

InitializeBinding (N,V)

The concrete Environment Record method InitializeBinding for declarative
environment records is used to set the bound value of the current
binding of the identifier whose name is the value of the argument _N_ to
the value of argument _V_. An uninitialized binding for _N_ must already
exist.

1.  Let _envRec_ be the declarative environment record for which the
    method was invoked.

2.  Assert: _envRec_ must have an uninitialized binding for _N_.

3.  Set the bound value for _N_ in _envRec_ to _V_.

4.  Record that the binding for _N_ in _envRec_ has been initialized.

SetMutableBinding (N,V,S)

The concrete Environment Record method SetMutableBinding for declarative
environment records attempts to change the bound value of the current
binding of the identifier whose name is the value of the argument _N_ to
the value of argument _V_. A binding for _N_ must already exist. If the
binding is an immutable binding, a TYPEERROR is thrown if S is TRUE.

1.  Let _envRec_ be the declarative environment record for which the
    method was invoked.

2.  Assert: _envRec_ must have a binding for _N_.

3.  If the binding for _N_ in _envRec_ has not yet been initialized
    throw a REFERENCEERROR exception.

4.  Else if the binding for _N_ in _envRec_ is a mutable binding, change
    its bound value to _V_.

5.  Else this must be an attempt to change the value of an immutable
    binding so if _S_ is TRUE throw a TYPEERROR exception.

6.  Return NormalCompletion(empty).

GetBindingValue(N,S)

The concrete Environment Record method GetBindingValue for declarative
environment records simply returns the value of its bound identifier
whose name is the value of the argument _N_. If the binding exists but
is uninitialized a REFERENCEERROR is thrown, regardless of the value of
_S.

1.  Let _envRec_ be the declarative environment record for which the
    method was invoked.

2.  Assert: _envRec_ has a binding for _N_.

3.  a.  

4.  If the binding for _N_ in _envRec_ is an uninitialized binding, then

5.  throw a REFERENCEERROR exception.

6.  7.  Return the value currently bound to _N_ in _envRec_.

DeleteBinding (N)

The concrete Environment Record method DeleteBinding for declarative
environment records can only delete bindings that have been explicitly
designated as being subject to deletion.

1.  Let _envRec_ be the declarative environment record for which the
    method was invoked.

2.  If _envRec_ does not have a binding for the name that is the value
    of _N_, return TRUE.

3.  If the binding for _N_ in _envRec_ cannot be deleted, return FALSE.

4.  Remove the binding for _N_ from _envRec_.

5.  Return TRUE.

HasThisBinding () 

Regular Declarative Environment Records do not provide a THIS binding.

1.  Return FALSE.

HasSuperBinding ()

Regular Declarative Environment Records do not provide a SUPER binding.

1.  Return FALSE.

 WithBaseObject()

Declarative Environment Records always return UNDEFINED as their
WithBaseObject.

1.  Return UNDEFINED.

Object Environment Records

Each object environment record is associated with an object called its
_binding object_. An object environment record binds the set of string
identifier names that directly correspond to the property names of its
binding object. Property keys that are not strings in the form of an
_IdentifierName_ are not included in the set of bound identifiers. Both
own and inherited properties are included in the set regardless of the
setting of their [[Enumerable]] attribute. Because properties can be
dynamically added and deleted from objects, the set of identifiers bound
by an object environment record may potentially change as a side-effect
of any operation that adds or deletes properties. Any bindings that are
created as a result of such a side-effect are considered to be a mutable
binding even if the Writable attribute of the corresponding property has
the value FALSE. Immutable bindings do not exist for object environment
records.

Object environment records also have a possibly empty List of strings
called _unscopables_. The strings in this List are excluded from the
environment records set of bound names, regardless of whether or not
they exist as property keys of its binding object.

Object environment records created for WITH statements (13.10) can
provide their binding object as an implicit this value for use in
function calls. The capability is controlled by a _withEnvironment_
Boolean value that is associated with each object environment record. By
default, the value of _withEnvironment_ is FALSE for any object
environment record.

The behaviour of the concrete specification methods for Object
Environment Records is defined by the following algorithms.

HasBinding(N)

The concrete Environment Record method HasBinding for object environment
records determines if its associated binding object has a property whose
name is the value of the argument _N_:

1.  Let _envRec_ be the object environment record for which the method
    was invoked.

2.  3.  Let _bindings_ be the binding object for _envRec_.

4.  Repeat, while _bindings_ is not NULL,

    a.  Let _hasOwn_ be HasOwnProperty(_bindings_, _N_).

    b.  ReturnIfAbrupt(_hasOwn_).

    c.  If _hasOwn_ is TRUE, then

        i.  Let _hasUnscopables_ be HasOwnProperty(_bindings_,
            @@unscopables).

        ii. ReturnIfAbrupt(_hasUnscopables_).

        iii. If _hasUnscopables_ is FALSE, then return TRUE.

        iv. Let _unscopables_ be Get(_bindings_, @@unscopables).

        v.  ReturnIfAbrupt(_unscopables_).

        vi. If Type(_unscopables_) is not Object, then return TRUE.

        vii. Let _isBlocked_ be HasOwnProperty(_unscopables_, _N_).

        viii. ReturnIfAbrupt(_isBlocked_).

        ix. If _isBlocked_ is FALSE, then return TRUE.

    d.  Let _bindings_ be the result of calling the [[GetPrototypeOf]]
        internal method of _bindings_ with no arguments.

    e.  ReturnIfAbrupt(_bindings_).

5.  Return FALSE.

CreateMutableBinding (N, D)

The concrete Environment Record method CreateMutableBinding for object
environment records creates in an environment record’s associated
binding object a property whose name is the String value and initializes
it to the value UNDEFINED. If Boolean argument _D_ is provided and has
the value TRUE the new property’s [[Configurable]] attribute is set to
TRUE, otherwise it is set to FALSE.

1.  Let _envRec_ be the object environment record for which the method
    was invoked.

2.  Let _bindings_ be the binding object for _envRec_.

3.  If _D_ is TRUE then let _configValue_ be TRUE otherwise let
    _configValue_ be FALSE.

4.  Return DefinePropertyOrThrow(_bindings_, _N_,
    PropertyDescriptor{[[Value]]:UNDEFINED, [[Writable]]: TRUE,
    [[Enumerable]]: TRUE , [[Configurable]]: _configValue_}).

NOTE Normally _envRec_ will not have a binding for _N_ but if it does,
the semantics of DefinePropertyOrThrow may result in an existing binding
being replaced or shadowed or cause an abrupt completion to be returned.

CreateImmutableBinding (N)

The concrete Environment Record method CreateImmutableBinding is never
used within this specification in association with Object environment
records.

InitializeBinding (N,V)

The concrete Environment Record method InitializeBinding for object
environment records is used to set the bound value of the current
binding of the identifier whose name is the value of the argument _N_ to
the value of argument _V_. An uninitialized binding for _N_ must already
exist.

1.  Let _envRec_ be the object environment record for which the method
    was invoked.

2.  Assert: _envRec_ must have an uninitialized binding for _N_.

3.  Record that the binding for _N_ in _envRec_ has been initialized.

4.  Return the result of calling the SetMutableBinding concrete method
    of _envRec_ with _N_, _V_, and FALSE as arguments.

SetMutableBinding (N,V,S)

The concrete Environment Record method SetMutableBinding for object
environment records attempts to set the value of the environment
record’s associated binding object’s property whose name is the value of
the argument _N_ to the value of argument _V_. A property named _N_
normally already exists but if it does not or is not currently writable,
error handling is determined by the value of the Boolean argument _S_.

1.  Let _envRec_ be the object environment record for which the method
    was invoked.

2.  Let _bindings_ be the binding object for _envRec_.

3.  Return Put(_bindings_, _N_, _V_, and _S_).

GetBindingValue(N,S)

The con

crete Environment Record method GetBindingValue for object environment
records returns the value of its associated binding object’s property
whose name is the String value of the argument identifier _N_. The
property should already exist but if it does not the result depends upon
the value of the _S_ argument:

1.  Let _envRec_ be the object environment record for which the method
    was invoked.

2.  Let _bindingThis_ be the binding object for _envRec_.

3.  Let _bindings_ be _bindingThis.

4.  Repeat, while _bindings_ is not NULL,

    a.  Let _hasOwn_ be HasOwnProperty(_bindings_, _N_).

    b.  ReturnIfAbrupt(_hasOwn_).

    c.  If _hasOwn_ is TRUE, then

        i.  Let _hasUnscopables_ be HasOwnProperty(_bindings_,
            @@unscopables).

        ii. ReturnIfAbrupt(_hasUnscopables_).

        iii. Let _isBlocked_ be FALSE.

        iv. If _hasUnscopables_ is TRUE, then

            1.  Let _unscopables_ be Get(_bindings_, @@unscopables).

            2.  ReturnIfAbrupt(_unscopables_).

            3.  If Type(_unscopables_) is Object, then

                a.  Let _isBlocked_ be HasOwnProperty(_unscopables_,
                    _N_).

                b.  ReturnIfAbrupt(_isBlocked_).

        v.  If _isBlocked_ is FALSE, then

            1.  Return the result of calling the [[Get]] internal method
                of _bindings_ with arguments _N_ and _bindingThis_.

    d.  Let _bindings_ be the result of calling the [[GetPrototypeOf]]
        internal method of _bindings_ with no arguments.

    e.  ReturnIfAbrupt(_bindings_).

5.  6.  7.  8.  If _S_ is FALSE, return the value UNDEFINED, otherwise
    throw a REFERENCEERROR exception.

DeleteBinding (N)

The concrete Environment Record method DeleteBinding for object
environment records can only delete bindings that correspond to
properties of the environment object whose [[Configurable]] attribute
have the value TRUE.

1.  Let _envRec_ be the object environment record for which the method
    was invoked.

2.  Let _bindings_ be the binding object for _envRec_.

3.  Return the result of calling the [[Delete]] internal method of
    _bindings_ passing _N_ as the argument.

HasThisBinding ()

Regular Object Environment Records do not provide a THIS binding.

1.  Return FALSE.

HasSuperBinding ()

Regular Object Environment Records do not provide a SUPER binding.

1.  Return FALSE.

 WithBaseObject()

Object Environment Records return UNDEFINED as their WithBaseObject
unless their _withEnvironment_ flag is TRUE.

1.  Let _envRec_ be the object environment record for which the method
    was invoked.

2.  If the _withEnvironment_ flag of _envRec_ is TRUE, return the
    binding object for _envRec_.

3.  Otherwise, return UNDEFINED.

Function Environment Records

A function environment record is a declarative environment record that
is used to represent the outer most scope of a function that provides a
THIS binding. In addition to its identifier bindings, a function
environment record contains the THIS value used within its scope. If
such a function references SUPER, its function environment record also
contains the state that is used to perform SUPER method invocations from
within the function.

Function environment records store their THIS binding as the value of
their _thisValue_. If the associated function references SUPER, the
environment record stores in _HomeObject_ the object that the function
is bound to as a method and in _MethodName_ the property key used for
unqualified super invocations from within the function. The default
value for _HomeObject_ and _MethodName_ is UNDEFINED.

Methods environment records support all of Declarative Environment
Record methods listed in Table 16 and share the same specifications for
all of those methods except for HasThisBinding and HasSuperBinding. In
addition, declarative environment records support the methods listed in
Table 17:

Table 17 — Additional Methods of Function Environment Records

  _METHOD_           _PURPOSE_
  ------------------ --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  GetThisBinding()   Return the value of this environment record’s THIS binding.
  GetSuperBase()     Return the object that is the base for SUPER property accesses bound in this environment record. The object is derived from this environment record’s HomeObject binding. If the value is Empty, return UNDEFINED.
  GetMethodName()    Return the value of this environment record’s MethodName binding.

The behaviour of the additional concrete specification methods for
Function Environment Records is defined by the following algorithms:

HasThisBinding ()

Function Environment Records always provide a THIS binding.

1.  Return TRUE.

HasSuperBinding ()

1.  If this environment record’s _HomeObject_ has the value Empty, then
    return FALSE. Otherwise, return TRUE.

GetThisBinding ()

1.  Return the value of this environment record’s _thisValue_.

GetSuperBase ()

1.  Let _home_ be the value of this environment record’s _HomeObject_.

2.  If _home_ has the value Empty, then return UNDEFINED.

3.  Assert: Type(_home_) is Object.

4.  Return the result of calling _home’s_ [[GetPrototypeOf]] internal
    method.

GetMethodName ()

1.  Return the value of this environment record’s _MethodName_.

Global Environment Records

A global environment record is used to represent the outer most scope
that is shared by all of the ECMAScript _Script_ elements that are
processed in a common Realm (8.1.2.5). A global environment record
provides the bindings for built-in globals (clause 18), properties of
the global object, and for all declarations that are not function code
and that occur within _Script_ productions.

A global environment record is logically a single record but it is
specified as a composite encapsulating an object environment record and
a declarative environment record. The object environment record has as
its base object the global object of the associated Realm. This global
object is also the value of the global environment record’s _thisValue_.
The object environment record component of a global environment record
contains the bindings for all built-in globals (clause 18) and all
bindings introduced by a _FunctionDeclaration_, _GeneratorDeclaration_,
or _VariableStatement_ contained in global code. The bindings for all
other ECMAScript declarations in global code are contained in the
declarative environment record component of the global environment
record.

Properties may be created directly on a global object. Hence, the object
environment record component of a global environment record may contain
both bindings created explicitly by _FunctionDeclaration_,
_GeneratorDeclaration_, or _VariableDeclaration_ declarations and
binding created implicitly as properties of the global object. In order
to identify which bindings were explicitly created using declarations, a
global environment record maintains a list of the names bound using its
CreateGlobalVarBindings and CreateGlobalFunctionBindings concrete
methods.

Global environment records have the additional state components listed
in Table 18 and the additional methods listed in Table 19.

Table 18 — Components of Global Environment Records

  _COMPONENT_         _PURPOSE_
  ------------------- -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ObjectRecord        An Object Environment Record whose base object is the global object. It contains global built-in bindings as well as _FunctionDeclaration_, _GeneratorDeclaration_, and _VariableDeclaration_ bindings in global code for the associated Realm.
  DeclarativeRecord   A Declarative Environment Record that contains bindings for all declarations in global code for the associated Realm code except for _FunctionDeclaration_, _GeneratorDeclaration_, and _VariableDeclaration_ _bindings_.
  VarNames            A List containing the string names bound by _FunctionDeclaration_, _GeneratorDeclaration_, and _VariableDeclaration_ declarations in global code for the associated Realm.

Table 19 — Additional Methods of Global Environment Records

  _METHOD_                               _PURPOSE_
  -------------------------------------- ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  GetThisBinding()                       Return the value of this environment record’s THIS binding.
  HasVarDeclaration (N)                  Determines if the argument identifier has a binding in this environment record that was created using a _VariableDeclaration_, _FunctionDeclaration_, or _GeneratorDeclaration_.
  HasLexicalDeclaration (N)              Determines if the argument identifier has a binding in this environment record that was created using a lexical declaration such as a _LexicalDeclaration_ or a _ClassDeclaration_.
  CanDeclareGlobalVar (N)                Determines if a corresponding CreateGlobalVarBinding call would succeed if called for the same argument _N_.
  CanDeclareGlobalFunction (N)           Determines if a corresponding CreateGlobalFunctionBinding call would succeed if called for the same argument _N_.
  CreateGlobalVarBinding(N, D)           Used to create global VAR bindings in the ObjectRecord component of a global environment record. The binding will be a mutable binding. The corresponding global object property will have attribute values approate for a VAR. The String value _N_ is the text of the bound name. _D_ is TRUE the binding is may be subsequently deleted. This is logically equivalent to CreateMutableBinding but it allows var declarations to receive special treatment.
  CreateGlobalFunctionBinding(N, V, D)   Used to create and initialize global FUNCTION bindings in the ObjectRecord component of a global environment record. The binding will be a mutable binding. The corresponding global object property will have attribute values approate for a FUNCTION.The String value _N_ is the text of the bound name. _V_ is the initial value of the binding. If the optional Boolean argument _D_ is TRUE the binding is may be subsequently deleted. This is logically equivalent to CreateMutableBinding followed by a SetMutableBinding but it allows function declarations to receive special treatment.
                                         

The behaviour of the concrete specification methods for Global
Environment Records is defined by the following algorithms.

HasBinding(N)

The concrete environment record method HasBinding for global environment
records simply determines if the argument identifier is one of the
identifiers bound by the record:

1.  Let _envRec_ be the global environment record for which the method
    was invoked.

2.  Let _DclRec_ be _envRec’s_ DeclarativeRecord.

3.  If the result of calling _DclRec’s_ HasBinding concrete method with
    argument _N_ is TRUE, return TRUE.

4.  Let _ObjRec_ be _envRec’s_ ObjectRecord.

5.  Return the result of calling _ObjRec’s_ HasBinding concrete method
    with argument _N_.

CreateMutableBinding (N, D)

The concrete environment record method CreateMutableBinding for global
environment records creates a new mutable binding for the name _N_ that
is uninitialized. The binding is created in the associated
DeclarativeRecord. A binding for _N_ must not already exist in the
DeclarativeRecord. If Boolean argument _D_ is provided and has the value
TRUE the new binding is marked as being subject to deletion.

1.  Let _envRec_ be the global environment record for which the method
    was invoked.

2.  Let _DclRec_ be _envRec’s_ DeclarativeRecord.

3.  Let _alreadyThere_ be the result of calling the HasBinding concrete
    method of of _DclRec_ with argument _N_.

4.  ReturnIfAbrupt(_alreadyThere_).

5.  Return the result of calling the CreateMutableBinding concrete
    method of _DclRec_ with arguments _N_ and _D_.

CreateImmutableBinding (N)

The concrete Environment Record method CreateImmutableBinding for global
environment records creates a new immutable binding for the name _N_
that is uninitialized. A binding must not already exist in this
environment record for _N_.

1.  Let _envRec_ be the global environment record for which the method
    was invoked.

2.  Let _DclRec_ be _envRec’s_ DeclarativeRecord.

3.  Let _alreadyThere_ be the result of calling the HasBinding concrete
    method of of _DclRec_ with argument _N_.

4.  ReturnIfAbrupt(_alreadyThere_).

5.  6.  Return the result of calling the CreateImmutableBinding concrete
    method of _DclRec_ with argument _N_.

InitializeBinding (N,V)

The concrete Environment Record method InitializeBinding for global
environment records is used to set the bound value of the current
binding of the identifier whose name is the value of the argument _N_ to
the value of argument _V_. An uninitialized binding for _N_ must already
exist.

1.  Let _envRec_ be the global environment record for which the method
    was invoked.

2.  Let _DclRec_ be _envRec’s_ DeclarativeRecord.

3.  If the result of calling _DclRec’s_ HasBinding concrete method with
    argument _N_ is TRUE, then

    a.  Return the result of calling _DclRec’s_ InitializeBinding
        concrete method with arguments _N_ and _V_.

4.  Assert: If the binding exists it must be in the object environment
    record.

5.  Let _ObjRec_ be _envRec’s_ ObjectRecord.

6.  Return the result of calling _ObjRec’s_ InitializeBinding concrete
    method with arguments _N_ and _V_.

SetMutableBinding (N,V,S)

The concrete Environment Record method SetMutableBinding for global
environment records attempts to change the bound value of the current
binding of the identifier whose name is the value of the argument _N_ to
the value of argument _V_. If the binding is an immutable binding, a
TYPEERROR is thrown if S is TRUE. A property named _N_ normally already
exists but if it does not or is not currently writable, error handling
is determined by the value of the Boolean argument _S_.

1.  Let _envRec_ be the global environment record for which the method
    was invoked.

2.  Let _DclRec_ be _envRec’s_ DeclarativeRecord.

3.  If the result of calling _DclRec’s_ HasBinding concrete method with
    argument _N_ is TRUE, then

    a.  Return the result of calling the SetMutableBinding concrete
        method of _DclRec_ with arguments _N_, _V_, and _S_.

4.  Let _ObjRec_ be _envRec’s_ ObjectRecord.

5.  Return the result of calling the SetMutableBinding concrete method
    of _ObjRec_ with arguments _N_, _V_, and _S_.

GetBindingValue(N,S)

The concrete Environment Record method GetBindingValue for global
environment records simply returns the value of its bound identifier
whose name is the value of the argument _N_. If the binding is an
uninitialized binding throw a REFERENCEERROR exception. A property named
_N_ normally already exists but if it does not or is not currently
writable, error handling is determined by the value of the Boolean
argument _S_.

1.  Let _envRec_ be the global environment record for which the method
    was invoked.

2.  Let _DclRec_ be _envRec’s_ DeclarativeRecord.

3.  If the result of calling _DclRec’s_ HasBinding concrete method with
    argument _N_ is TRUE, then

    a.  Return the result of calling the GetBindingValue concrete method
        of _DclRec_ with arguments _N_ and _S_.

4.  Let _ObjRec_ be _envRec’s_ ObjectRecord.

5.  Return the result of calling the GetBindingValue concrete method of
    _ObjRec_ with arguments _N_, and _S_.

DeleteBinding (N)

The concrete Environment Record method DeleteBinding for global
environment records can only delete bindings that have been explicitly
designated as being subject to deletion.

1.  Let _envRec_ be the global environment record for which the method
    was invoked.

2.  Let _DclRec_ be _envRec’s_ DeclarativeRecord.

3.  If the result of calling _DclRec’s_ HasBinding concrete method with
    argument _N_ is TRUE, then

    a.  Return the result of calling the DeleteBinding concrete method
        of _DclRec_ with argument _N_.

4.  Let _ObjRec_ be _envRec’s_ ObjectRecord.

5.  If the result of calling _ObjRec’s_ HasBinding concrete method with
    argument _N_ is TRUE, then

    a.  Let _status_ be the result of calling the DeleteBinding concrete
        method of _ObjRec_ with argument _N_.

    b.  ReturnIfAbrupt(_status_).

    c.  If _status_ is TRUE, then

        i.  Let _varNames_ be _envRec’s_ VarNames List.

        ii. If _N_ is an element of _varNames_, then remove that element
            from the _varNames_.

    d.  Return _status_.

6.  Return TRUE.

HasThisBinding ()

Global Environment Records always provide a THIS binding whose value is
the associated global object.

1.  Return TRUE.

HasSuperBinding ()

1.  Return FALSE.

 WithBaseObject()

Global Environment Records always return UNDEFINED as their
WithBaseObject.

1.  Return UNDEFINED.

GetThisBinding ()

1.  Let _envRec_ be the global environment record for which the method
    was invoked.

2.  Let _ObjRec_ be _envRec’s_ ObjectRecord.

3.  Let _bindings_ be the binding object for _ObjRec_.

4.  Return _bindings_.

HasVarDeclaration (N)

The concrete environment record method HasVarDeclaration for global
environment records determines if the argument identifier has a binding
in this record that was created using a _VariableStatement_ or a
_FunctionDeclaration_:

1.  Let _envRec_ be the global environment record for which the method
    was invoked.

2.  Let _varDeclaredNames_ be _envRec’s_ VarNames List.

3.  If _varDeclaredNames_ contains the value of _N_, return TRUE.

4.  Return FALSE.

HasLexicalDeclaration (N)

The concrete environment record method HasLexicalDeclaration for global
environment records determines if the argument identifier has a binding
in this record that was created using a lexical declaration such as a
_LexicalDeclaration_ or a _ClassDeclaration_:

1.  Let _envRec_ be the global environment record for which the method
    was invoked.

2.  Let _DclRec_ be _envRec’s_ DeclarativeRecord.

3.  Return the result of calling _DclRec’s_ HasBinding concrete method
    with argument _N_.

 CanDeclareGlobalVar (N)

The concrete environment record method CanDeclareGlobalVar for global
environment records determines if a corresponding CreateGlobalVarBinding
call would succeed if called for the same argument _N_. Redundent var
declarations and var declarations for pre-existing global object
properties are allowed.

1.  Let _envRec_ be the global environment record for which the method
    was invoked.

2.  Let _ObjRec_ be _envRec’s_ ObjectRecord.

3.  If the result of calling _ObjRec’s_ HasBinding concrete method with
    argument _N_ is TRUE, return TRUE.

4.  Let _bindings_ be the binding object for _ObjRec_.

5.  Let _extensible_ be IsExtensible(_bindings_).

6.  Return _extensible_.

 CanDeclareGlobalFunction (N)

The concrete environment record method CanDeclareGlobalFunction for
global environment records determines if a corresponding
CreateGlobalFunctionBinding call would succeed if called for the same
argument _N_.

1.  Let _envRec_ be the global environment record for which the method
    was invoked.

2.  Let _ObjRec_ be _envRec’s_ ObjectRecord.

3.  Let _globalObject_ be the binding object for _ObjRec_.

4.  Let _extensible_ be IsExtensible(_globalObject_).

5.  ReturnIfAbrupt(_extensible_).

6.  If the result of calling _ObjRec’s_ HasBinding concrete method with
    argument _N_ is FALSE, then return _extensible_.

7.  Let _existingProp_ be the result of calling the [[GetOwnProperty]]
    internal method of _globalObject_ with argument _N_.

8.  ReturnIfAbrupt(_existingProp_).

9.  If _existingProp_ is UNDEFINED, then return _extensible_.

10. If _existingProp_.[[Configurable]] is TRUE, then return TRUE.

11. If IsDataDescriptor(_existingProp_) is TRUE and _existingProp_ has
    attribute values {[[Writable]]: TRUE, [[Enumerable]]: TRUE}, then
    return TRUE.

12. Return FALSE.

 CreateGlobalVarBinding (N, D)

The concrete Environment Record method CreateGlobalVarBinding for global
environment records creates a mutable binding in the associated object
environment record and records the bound name in the associated VarNames
List. If a binding already exists, it is reused.

1.  Let _envRec_ be the global environment record for which the method
    was invoked.

2.  Let _ObjRec_ be _envRec’s_ ObjectRecord.

3.  If the result of calling _ObjRec’s_ HasBinding concrete method with
    argument _N_ is FALSE, then

    a.  Let _status_ be the result of calling the CreateMutableBinding
        concrete method of _ObjRec_ with arguments _N_ and _D_.

    b.  ReturnIfAbrupt(_status_).

4.  Let _varDeclaredNames_ be _envRec’s_ VarNames List.

5.  If _varDeclaredNames_ does not contain the value of _N_, then

    a.  Append _N_ to _varDeclaredNames_.

6.  Return NormalCompletion(empty).

CreateGlobalFunctionBinding (N, V, D)

The concrete Environment Record method CreateGlobalFunctionBinding for
global environment records creates a mutable binding in the associated
object environment record and records the bound name in the associated
VarNames List. If a binding already exists, it is replaced.

1.  Let _envRec_ be the global environment record for which the method
    was invoked.

2.  Let _ObjRec_ be _envRec’s_ ObjectRecord.

3.  Let _globalObject_ be the binding object for _ObjRec_.

4.  Let _existingProp_ be the result of calling the [[GetOwnProperty]]
    internal method of _globalObject_ with argument _N_.

5.  ReturnIfAbrupt(_existingProp_).

6.  If _existingProp_ is UNDEFINED or _existingProp_.[[Configurable]] is
    TRUE, then

    a.  Let _desc_ be the PropertyDescriptor{[[Value]]:_V_,
        [[Writable]]: TRUE, [[Enumerable]]: TRUE , [[Configurable]]:
        _D_}.

7.  Else,

    a.  Let _desc_ be the PropertyDescriptor{[[Value]]:_V_ }.

8.  Let _status_ be DefinePropertyOrThrow(_globalObject_, _N_, _desc_).

9.  ReturnIfAbrupt(_status_).

10. Let _varDeclaredNames_ be _envRec’s_ VarNames List.

11. If _varDeclaredNames_ does not contain the value of _N_, then

    a.  Append _N_ to _varDeclaredNames_.

12. Return NormalCompletion(empty).

NOTE Global function declarations are always represented as own
properties of the global object. If possible, an existing own property
is reconfigured to have a standard set of attribute values.

Lexical Environment Operations

The following abstract operations are used in this specification to
operate upon lexical environments:

GetIdentifierReference (lex, name, strict) Abstract Operation

The abstract operation GetIdentifierReference is called with a Lexical
Environment _lex_, a String _name_, and a Boolean flag _strict._ The
value of _lex_ may be NULL. When called, the following steps are
performed:

1.  If _lex_ is the value NULL, then

    a.  Return a value of type Reference whose base value is UNDEFINED,
        whose referenced name is _name_, and whose strict reference flag
        is _strict_.

2.  Let _envRec_ be _lex_’s environment record.

3.  Let _exists_ be the result of calling the HasBinding concrete method
    of _envRec_ passing _name_ as the argument.

4.  ReturnIfAbrupt(_exists_).

5.  If _exists_ is TRUE, then

    a.  Return a value of type Reference whose base value is _envRec_,
        whose referenced name is _name_, and whose strict reference flag
        is _strict._

6.  Else

    a.  Let _outer_ be the value of _lex’s_ outer environment reference.

    b.  Return GetIdentifierReference(_outer_, _name_, _strict_).

NewDeclarativeEnvironment (E) Abstract Operation

When the abstract operation NewDeclarativeEnvironment is called with
either a Lexical Environment or NULL as argument _E_ the following steps
are performed:

1.  Let _env_ be a new Lexical Environment.

2.  Let _envRec_ be a new declarative environment record containing no
    bindings.

3.  Set _env’s_ environment record to be _envRec_.

4.  Set the outer lexical environment reference of _env_ to _E_.

5.  Return _env_.

NewObjectEnvironment (O, E) Abstract Operation

When the abstract operation NewObjectEnvironment is called with an
Object _O_ and a Lexical Environment _E_ (or NULL) as arguments, the
following steps are performed:

1.  Let _env_ be a new Lexical Environment.

2.  Let _envRec_ be a new object environment record containing _O_ as
    the binding object.

3.  4.  Set _env’s_ environment record to _envRec_.

5.  Set the outer lexical environment reference of _env_ to _E_.

6.  Return _env_.

NewFunctionEnvironment (F, T) Abstract Operation

When the abstract operation NewFunctionEnvironment is called with an
ECMAScript function Object _F_ and an ECMAScript value _T_ as arguments,
the following steps are performed:

1.  Assert: The value of _F’s_ [[ThisMode]] internal slot is not
    lexical.

2.  Let _env_ be a new Lexical Environment.

3.  Let _envRec_ be a new Function environment record containing
    containing no bindings.

4.  Set _envRec’s_ _thisValue_ to _T_.

5.  If _F_’s [[NeedsSuper]] internal slot is TRUE, then

    a.  Let _home_ be the value of _F’s_ [[HomeObject]] internal slot.

    b.  If _home_ is UNDEFINED, then throw a REFERENCEERROR exception.

    c.  Set _envRec’s_ _HomeObject_ to _home_.

    d.  Set _envRec’s_ _MethodName_ to the value of _F’s_ [[MethodName]]
        internal slot.

6.  Else,

    a.  Set _envRec’s_ _HomeObject_ to Empty.

7.  Set _env’s_ environment record to be _envRec_.

8.  Set the outer lexical environment reference of _env_ to the value of
    _F’s_ [[Environment]] internal slot.

9.  Return _env_.

NewGlobalEnvironment ( G ) Abstract Operation

When the abstract operation NewGlobalEnvironment is called with an
ECMAScript Object _G_ as its argument, the following steps are
performed:

1.  Let _env_ be a new Lexical Environment.

2.  Let _objRec_ be a new object environment record containing _G_ as
    the binding object.

3.  Set _objRec’s_ _unscopables_ to an empty List.

4.  Let _dclRec_ be a new declarative environment record containing no
    bindings.

5.  Let _globalRec_ be a new global environment record.

6.  Set _globalRec’s_ ObjectRecord to _objRec_.

7.  Set _globalRec’s_ DeclarativeRecord to _dclRec_.

8.  Set _globalRec’s_ VarNames to a new empty List.

9.  Set _env’s_ environment record to _globalRec_.

10. Set the outer lexical environment reference of _env_ to NULL

11. Return _env_.


Code Realms

Before it is evaluated, all ECMAScript code must be associated with a
_Realm_. Conceptually, a realm consists of a set of intrinsic objects,
an ECMAScript global environment, all of the ECMAScript code that is
loaded within the scope of that global environment, a Loader object that
can associate new ECMAScript code with the realm, and other associated
state and resources.

A Realm is specified as a Record with the fields specified in Table 20:

Table 20 — Realm Record Fields

  ------------------------- ---------------------------------------------------------------------------- ------------------------------------------------------------------------
  _FIELD NAME_              _VALUE_                                                                      _MEANING_
  [[intrinsics]]            A record whose field names are intrinsic keys and whose values are objects   These are the intrinsic values used by code associated with this Realm
  [[globalThis]]            An object                                                                    The global object for this Realm
  [[globalEnv]]             An ECMAScript environment                                                    The global environment for this Realm
  [[directEvalTranslate]]   UNDEFINED or an object that is callable as a function.                       
  [[nonEvalFallback]]       UNDEFINED or an object that is callable as a function.                       
  [[indirectEval]]          UNDEFINED or an object that is callable as a function.                       
                                                                                                         
  [[loader]]                any ECMAScript identifier or EMPTY                                           The Loader object that can associate ECMAScript code with this Realm
  ------------------------- ---------------------------------------------------------------------------- ------------------------------------------------------------------------

CreateRealm ( ) Abstract Operation

The abstract operation CreateRealm with no arguments performs the
following steps:

1.  Let _realmRec_ be a new Record.

2.  Let _intrinsics_ be CreateIntrinsics(_realmRec_).

3.  4.  5.  6.  7.  8.  Set _realmRec_.[[globalThis]] to UNDEFINED.

9.  10. Set _realmRec_.[[globalEnv]] to UNDEFINED.

11. Set each of _realmRec_.[[directEvalTranslate]],
    _realmRec_.[[nonEvalFallback]], and _realmRec_.[[indirectEval]] to
    UNDEFINED.

12. Return _realmRec_.

CreateIntrinsics ( realmRec ) Abstract Operation

When the abstract operation CreateIntrinsics with argument _realmRec_
performs the following:

1.  Let _intrinsics_ be a new Record.

2.  Set _realmRec_.[[intrinsics]] to _intrinsics_.

3.  Let _objProto_ be ObjectCreate(NULL).

4.  Set _intrinsics_.[[%ObjectPrototype%]] to _objProto_.

5.  Let _throwerSteps_ be the algorithm steps of the %ThrowTypeError%
    function (9.2.8.1).

6.  Let _thrower_ be CreateBuiltinFunction(_realmRec_, _throwerSteps_,
    NULL).

7.  8.  9.  10. 11. 12. Set _intrinsics_.[[%ThrowTypeError%]] to
    _thrower_.

13. Let _noSteps_ be an empty sequence of algorithm steps.

14. Let _funcProto_ be the CreateBuiltinFunction(_realmRec_, _noSteps_,
    _objProto_).

15. Set _intrinsics_.[[%FunctionPrototype%]] to _funcProto_.

16. Call the [[SetPrototypeOf]] internal method of _thrower_ with
    argument _funcProto_.

17. Set fields of _intrinsics_ with the values listed in Table 7 that
    have not already been handled above. The field names are the names
    listed in column one of the table. The value of each field is a new
    object value fully and recursively populated with property values as
    defined by the specification of each object in clauses 18-26. All
    object property values are newly created object values. All values
    that are built-in function objects are created by performing
    CreateBuiltinFunction(_realmRec_, <steps>, <prototype>, <slots>)
    where <steps> is the definition of that function provided by this
    specification, <prototype> is the specified value of the function’s
    [[Prototype]] internal slot and <slots> is a list of the names, if
    any, of the functions specified internal slots. The creation of the
    intrinsics and their properties must be ordered to avoid any
    dependencies upon objects that have not yet been created.

18. Return _intrinsics_.

SetRealmGlobalObj ( realmRec, globalObj ) Abstract Operation

The abstract operation SetRealmGlobalObj with arguments _realmRec_ and
_globalObj_ performs the following steps:

1.  If _globalObj_ is UNDEFINED, then

    a.  Let _globalObj_ be
        ObjectCreate(_realmRec_.[[instrinsics]].[[%ObjectPrototype%]]).

2.  Assert: Type(_globalObj_) is Object.

3.  Set _realmRec_.[[globalThis]] to _newGlobal_.

4.  Let _newGlobalEnv_ be NewGlobalEnvironment(_newGlobal_).

5.  Set _realmRec_.[[globalEnv]] to _newGlobalEnv_.

6.  Return _realmRec_.

SetDefaultGlobalBindings ( realmRec ) Abstract Operation

The abstract operation SetDefaultGlobalBindings with argument _realmRec_
performs the following steps:

1.  Let _global_ be _realmRec_.[[globalThis]].

2.  For each property of the Global Object specified in clause 18, do

    a.  Let _name_ be the string value of the property name.

    b.  Let _desc_ be the fully populated data property descriptor for
        the property containing the specified attributes for the
        property. For properties whose values are functions, the value
        of the [[Value]] attribute is the corresponding intrinsic
        function object from _realmRec_.

    c.  Let _status_ be DefinePropertyOrThrow(_global_, _name_, _desc_).

    d.  ReturnIfAbrupt(_status_).

3.  Return _global_.


Execution Contexts

An _execution context_ is a specification device that is used to track
the runtime evaluation of code by an ECMAScript implementation. At any
point in time, there is at most one execution context that is actually
executing code. This is known as the _running_ execution context. A
stack is used to track execution contexts. The running execution context
is always the top element of this stack. A new execution context is
created whenever control is transferred from the executable code
associated with the currently running execution context to executable
code that is not associated with that execution context. The newly
created execution context is pushed onto the stack and becomes the
running execution context.

An execution context contains whatever implementation specific state is
necessary to track the execution progress of its associated code. Each
execution context has at least the state components listed in Table 21.

Table 21 —State Components for All Execution Contexts

  _COMPONENT_             _PURPOSE_
  ----------------------- --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  code evaluation state   Any state needed to perform, suspend, and resume evaluation of the code associated with this execution context.
  Function                If this execution context is evaluating the code of a function object, then the value of this is the that function. If the context is evaluation the code of a _Script_ the value is NULL.
  Realm                   The Realm from which associated code accesses ECMAScript resources.

Evaluation of code by the running execution context may be suspended at
various points defined within this specification. Once the running
execution context has been suspended a different execution context may
become the running execution context and commence evaluating its code.
At some later time a suspended execution context may again become the
running execution context and continue evaluating its code at the point
where it had previously been suspended. Transition of the running
execution context status among execution contexts usually occurs in
stack-like last-in/first-out manner. However, some ECMAScript features
require non-LIFO transitions of the running execution context.

The value of the Realm component of the running execution context is
also called the _current Realm_. The value of the Function component of
the running execution context is also called the _active Function._

Execution contexts for ECMAScript code have the additional state
components listed in Table 22.

Table 22 — Additional State Components for ECMAScript Code Execution
Contexts

  _COMPONENT_           _PURPOSE_
  --------------------- -------------------------------------------------------------------------------------------------------------------------------------------
  LexicalEnvironment    Identifies the Lexical Environment used to resolve identifier references made by code within this execution context.
  VariableEnvironment   Identifies the Lexical Environment whose environment record holds bindings created by _VariableStatements_ within this execution context.

The LexicalEnvironment and VariableEnvironment components of an
execution context are always Lexical Environments. When an execution
context is created its LexicalEnvironment and VariableEnvironment
components initially have the same value. The value of the
VariableEnvironment component never changes while the value of the
LexicalEnvironment component may change during execution of code within
an execution context.

Execution contexts representing the evaluation of generator objects have
the additional state components listed in Table 23.

Table 23 — Additional State Components for Generator Execution Contexts

  _COMPONENT_   _PURPOSE_
  ------------- ----------------------------------------------------------------
  Generator     The GeneratorObject that this execution context is evaluating.

In most situations only the running execution context (the top of the
execution context stack) is directly manipulated by algorithms within
this specification. Hence when the terms “LexicalEnvironment”, and
“VariableEnvironment” are used without qualification they are in
reference to those components of the running execution context.

An execution context is purely a specification mechanism and need not
correspond to any particular artefact of an ECMAScript implementation.
It is impossible for ECMAScript code to directly access or observe an
execution context.

ResolveBinding ( name ) Abstract Operation

The ResolveBinding abstract operation is used to determine the binding
of _name_ passed as a string value using the LexicalEnvironment of the
running execution context. During execution of ECMAScript code,
ResolveBinding is performed using the following algorithm:

1.  Let _env_ be the running execution context’s LexicalEnvironment.

2.  If the syntactic production that is being evaluated is contained in
    strict mode code, then let _strict_ be TRUE, else let _strict_ be
    FALSE.

3.  Return GetIdentifierReference(_env_, _name_, _strict_ ).

NOTE The result of ResolveBinding is always a Reference value with its
referenced name component equal to the _name_ argument.

GetThisEnvironment ( ) Abstract Operation

The abstract operation GetThisEnvironment finds the lexical environment
that currently supplies the binding of the keyword THIS.
GetThisEnvironment performs the following steps:

1.  Let _lex_ be the running execution context’s LexicalEnvironment.

2.  Repeat

    a.  Let _envRec_ be _lex_’s environment record.

    b.  Let _exists_ be the result of calling the HasThisBinding
        concrete method of _envRec_.

    c.  If _exists_ is TRUE, then return _envRec_.

    d.  Let _outer_ be the value of _lex’s_ outer environment reference.

    e.  Let _lex_ be _outer_.

NOTE The loop in step 2 will always terminate because the list of
environments always ends with the global environment which has a THIS
binding.

ResolveThisBinding ( ) Abstract Operation

The abstract operation ResolveThisBinding determines the binding of the
keyword THIS using the LexicalEnvironment of the running execution
context. ResolveThisBinding performs the following steps:

1.  Let _env_ be GetThisEnvironment( ).

2.  Return the result of calling the GetThisBinding concrete method of
    _env_.

GetGlobalObject ( ) Abstract Operation

The abstract operation GetGlobalObject returns the global object used by
the currently running execution context. GetGlobalObject performs the
following steps:

1.  Let _ctx_ be the running execution context.

2.  Let _currentRealm_ be _ctx’s_ Realm.

3.  Return _currentRealm_.[[globalThis]].


Jobs and Job Queues

A Job is an abstract operation that initiates an ECAMScript computation
when no other ECMAScript computation is currently in progress. A Job
abstract operation may be defined to accept an arbitrary set of job
parameters.

Execution of a Job can be initiated only when there is no running
execution context and the execution context stack is empty. A PendingJob
is a request for the future execution of a Job. A PendingJob is an
internal Record whose fields are specified in Table 24.

Table 24 — PendingJob Record Fields

  ----------------- -------------------------------------- ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  _FIELD NAME_      _VALUE_                                _MEANING_
  [[Job]]           The name of a Job abstract operation   This is the abstract operation that is performed when execution of this PendingJob is initiated. Jobs are abstract operations that use NextJob rather than Return to indicate that they have completed.
  [[Arguments]]     A List.                                The List of argument values that are to be passed to [[Job]] when it is activated.
  [[Realm]]         A Realm Record                         The Realm for the initial execution context when this Pending Job is initiated.
  [[HostDefined]]   Any, default value is UNDEFINED.       Field reserved for use by host environments that need to associate additional information with a pending Job.
  ----------------- -------------------------------------- ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

A Job Queue is a FIFO queue of PendingJob records. Each Job Queue has a
name and the full set of available Job Queues are defined by an
ECMAScript implementation. Every ECMAScript implementation has at least
the Job Queues defined in Table 25.

Table 25 — Required Job Queues

  _NAME_        _PURPOSE_
  ------------- -----------------------------------------------------------------------------------------------------
  ScriptJobs    Jobs that validate and evaluate ECMAScript _Script_ and _Module_ code units. See clauses 10 and 15.
  PromiseJobs   Jobs that are responses to the settlement of a Promise (see 25.4).

A request for the future execution of a Job is made by enqueueing, on a
Job Queue, a PendingJob record that includes a Job abstract operation
name and any necessary argument values. When there is no running
execution context and the execution context stack is empty, the
ECMAScript implementation removes the first PendingJob from a Job Queue
and uses the information contained in it to create an execution context
and starts execution of the associated Job abstract operation.

The PendingJob records from a single Job Queue are always initiated in
FIFO order. This specification does not define the order in which
multiple Job Queues are serviced. An ECMAScript implementation may
interweave the FIFO evaluation of the PendingJob records of a Job Queue
with the evaluation of the PendingJob records of one or more other Job
Queues. An implementation must define what occurs when there are no
running execution context and all Job Queues are empty.

NOTE Typically an ECMAScript implementation will have its Job Queues
pre-initialized with at least one PendingJob and one of those Jobs will
be the first to be executed. An implementation might choose to free all
resources and terminate if the current Job completes and all Job Queues
are empty. Alternatively, it might choose to wait for a some
implementation specific agent or mechanism to enqueue new PendingJob
requests.

The following abstract operations are used to create and manage Jobs and
Job Queues:

EnqueueJob ( queueName, job, arguments) Abstract Operation

The abstract operation requires three arguments: _queueName_, _job_, and
_arguments_. It performs the following steps:

1.  Assert: Type(_queueName_) is String and its value is the name of a
    Job Queue recognized by this implementation.

2.  Assert: _job_ is the name of a Job.

3.  Assert: _arguments_ is a List that has the same number of elements
    as the number of parameters required by _job_.

4.  Let _callerContext_ be the running execution context.

5.  Let _callerRealm_ be _callerContext’s_ Realm.

6.  Let _pending_ be PendingJob{ [[Job]]: _job_, [[Arguments]]:
    _arguments_, [[Realm]]: _callerRealm_, [[HostDefined]]: UNDEFINED }.

7.  Perform any implementation or host environment defined processing of
    _pending_. This may including modify the [[HostDefined]] field or
    any other field of _pending_.

8.  Add _pending_ at the back of the Job Queue named by _queueName_.

9.  Return NormalCompletion(empty).

NextJob result 

An algorithm step such as:

1.  NextJob _result_.

is used in Job abstract operations in place of:

1.  Return _result_.

Job abstract operations must not contain a Return step or a
ReturnIfAbrupt step. The NextJob _result_ operation is equivalent to the
following steps:

1.  If _result_ is an abrupt completion, then perform implementation
    defined unhandled exception processing.

2.  Suspend the running execution context.

3.  Assert: The execution context stack is now empty.

4.  Let _nextQueue_ be a non-empty Job Queue chosen in an implementation
    defined manner. If all Job Queues are empty, the result is
    implementation defined.

5.  Let _nextPending_ be the PendingJob record at the front of
    _nextQueue_. Remove that record from _nextQueue_.

6.  Let _newContext_ be a new execution context.

7.  Set _newContext_’s Realm to _nextPending_.[[Realm]].

8.  Push _newContext_ onto the execution context stack; _newContext_ is
    now the running execution context.

9.  Perform any implementation or host environment defined job
    initialization using _nextPending_.

10. Perform the abstract operation named by _nextPending_.[[Job]] using
    the elements of _nextPending_.[[Arguments]] as its arguments.


Initialization

An ECMAScript implementation performs the following steps prior to the
execution of any Jobs or the evaluation of any ECMAScript code:

1.  Let _realm_ be CreateRealm().

2.  Let _newContext_ be a new execution context.

3.  Set the Function of _newContext_ to NULL.

4.  Set the Realm of _newContext_ to _realm_.

5.  Push _newContext_ onto the execution context stack; _newContext_ is
    now the running execution context.

6.  Let _status_ be InitializeFirstRealm(_realm_).

7.  If _status_ is an abrupt completion, then

    a.  Assert: The first realm could not be created.

    b.  Terminate ECMAScript execution.

8.  In an implementation dependent manner, obtain the _SourceCharacter
    sequence (see 10) for zero or more ECMAScript scripts. For each such
    sequence _source_ do,

    a.  EnqueueJob("ScriptJobs", ScriptEvaluationJob, (_source_)).

9.  NextJob NormalCompletion(UNDEFINED).

InitializeFirstRealm ( realm ) Abstract Operation

The abstract operation InitializeFirstRealm with parameter _realm_
performs the following steps:

1.  Let _intrinsics_ be CreateIntrinsics(_realm_).

2.  If this implementation requires use of an exotic object to serve as
    _realm_’s global object, then let _global_ be such an object created
    in an implementation defined manner. Otherwise, let _global_ be
    UNDEFINED indicating that an ordinary object should be created as
    the global object.

3.  Perform SetRealmGlobalObject(_realm_, _global_).

4.  Let _globalObj_ be SetDefaultGlobalBindings(_realm_).

5.  ReturnIfAbrupt(_globalObj_).

6.  Create any implementation defined global object properties on
    _globalObj_.

7.  Return NormalCompletion(UNDEFINED).



ORDINARY AND EXOTIC OBJECTS BEHAVIOURS 


Ordinary Object Internal Methods and Internal Slots

All ordinary objects have an internal slot called [[Prototype]]. The
value of this internal slot is either NULL or an object and is used for
implementing inheritance. Data properties of the [[Prototype]] object
are inherited (are visible as properties of the child object) for the
purposes of get access, but not for set access. Accessor properties are
inherited for both get access and set access.

Every ordinary object has a Boolean-valued [[Extensible]] internal slot
that controls whether or not properties may be added to the object. If
the value of the [[Extensible]] internal slot is FALSE then additional
properties may not be added to the object. In addition, if
[[Extensible]] is FALSE the value of the [[Prototype]] internal slot of
the object may not be modified. Once the value of an object’s
[[Extensible]] internal slot has been set to FALSE it may not be
subsequently changed to TRUE.

In the following algorithm descriptions, assume _O_ is an ordinary
object, _P_ is a property key value, _V_ is any ECMAScript language
value, and _Desc_ is a Property Descriptor record.

[[GetPrototypeOf]] ( )

When the [[GetPrototypeOf]] internal method of _O_ is called the
following steps are taken:

1.  Return the value of the [[Prototype]] internal slot of _O_.

[[SetPrototypeOf]] (V)

When the [[SetPrototypeOf]] internal method of _O_ is called with
argument _V_ the following steps are taken:

1.  Assert: Either Type(_V_) is Object or Type(_V_) is Null.

2.  Let _extensible_ be the value of the [[Extensible]] internal slot of
    _O_.

3.  Let _current_ be the value of the [[Prototype]] internal slot of
    _O_.

4.  If SameValue(_V_, _current_), then return TRUE.

5.  If _extensible_ is FALSE, then return FALSE.

6.  If _V_ is not NULL, then

    a.  Let _p_ be _V_.

    b.  Repeat, while _p_ is not NULL

        i.  If SameValue(_p_, _O_) is TRUE, then return FALSE.

        ii. Let _nextp_ be the result of calling the [[GetPrototypeOf]]
            internal method of _p_ with no arguments.

        iii. ReturnIfAbrupt(_nextp_).

        iv. Let _p_ be _nextp_.

7.  Let _extensible_ be the value of the [[Extensible]] internal slot of
    _O_.

8.  If _extensible_ is FALSE, then

    a.  Let _current2_ be the value of the [[Prototype]] internal slot
        of _O_.

    b.  If SameValue(_V_, _current2_) is TRUE, then return TRUE.

    c.  Return FALSE.

9.  Set the value of the [[Prototype]] internal slot of _O_ to _V_.

10. Return TRUE.

[[IsExtensible]] ( )

When the [[IsExtensible]] internal method of _O_ is called the following
steps are taken:

1.  Return the value of the [[Extensible]] internal slot of _O_.

[[PreventExtensions]] ( )

When the [[PreventExtensions]] internal method of _O_ is called the
following steps are taken:

1.  Set the value of the [[Extensible]] internal slot of _O_ to FALSE.

2.  Return TRUE.

[[GetOwnProperty]] (P)

When the [[GetOwnProperty]] internal method of _O_ is called with
property key _P_, the following steps are taken:

1.  Return OrdinaryGetOwnProperty(_O_, _P_).

OrdinaryGetOwnProperty (O, P)

When the abstract operation OrdinaryGetOwnProperty is called with Object
_O_ and with property key _P_, the following steps are taken:

1.  Assert: IsPropertyKey(_P_) is TRUE.

2.  If _O_ does not have an own property with key _P_, return UNDEFINED.

3.  Let _D_ be a newly created Property Descriptor with no fields.

4.  Let _X_ be _O_’s own property whose key is _P_.

5.  If _X_ is a data property, then

    a.  Set _D_.[[Value]] to the value of _X_’s [[Value]] attribute.

    b.  Set _D_.[[Writable]] to the value of _X_’s [[Writable]]
        attribute

6.  Else _X_ is an accessor property, so

    a.  Set _D_.[[Get]] to the value of _X_’s [[Get]] attribute.

    b.  Set _D_.[[Set]] to the value of _X_’s [[Set]] attribute.

7.  Set _D_.[[Enumerable]] to the value of _X_’s [[Enumerable]]
    attribute.

8.  Set _D_.[[Configurable]] to the value of _X_’s [[Configurable]]
    attribute.

9.  Return _D_.

[[DefineOwnProperty]] (P, Desc)

When the [[DefineOwnProperty]] internal method of _O_ is called with
property key _P_ and Property Descriptor _Desc_, the following steps are
taken:

1.  Return OrdinaryDefineOwnProperty(_O_, _P_, _Desc_).

OrdinaryDefineOwnProperty (O, P, Desc)

When the abstract operation OrdinaryDefineOwnProperty is called with
Object _O_, property key _P_, and Property Descriptor _Desc_ the
following steps are taken:

1.  Let _current_ be the result of calling the [[GetOwnProperty]]
    internal method of _O_ with argument _P_.

2.  ReturnIfAbrupt(_current_).

3.  Let _extensible_ be the value of the [[Extensible]] internal slot of
    _O_.

4.  Return ValidateAndApplyPropertyDescriptor(_O_, _P_, _extensible_,
    _Desc_, _current_).

IsCompatiblePropertyDescriptor (Extensible, Desc, Current)

When the abstract operation IsCompatiblePropertyDescriptor is called
with Boolean value _Extensible_, and Property Descriptors _Desc_, and
_Current_ the following steps are taken:

1.  Return ValidateAndApplyPropertyDescriptor(UNDEFINED, UNDEFINED,
    _Extensible_, _Desc_, _Current_).

ValidateAndApplyPropertyDescriptor (O, P, extensible, Desc, current)

When the abstract operation ValidateAndApplyPropertyDescriptor is called
with Object _O_, property key _P_, Boolean value _extensible_, and
Property Descriptors _Desc_, and _current_ the following steps are
taken:

This algorithm contains steps that test various fields of the Property
Descriptor _Desc_ for specific values. The fields that are tested in
this manner need not actually exist in _Desc_. If a field is absent then
its value is considered to be FALSE.

NOTE If UNDEFINED is passed as the _O_ argument only validation is
performed and no object updates are performed.

1.  Assert: If _O_ is not UNDEFINED then _P_ is a valid property key.

2.  If _current_ is UNDEFINED, then

    a.  If _extensible_ is FALSE, then return FALSE.

    b.  Assert: _extensible_ is TRUE.

    c.  If IsGenericDescriptor(_Desc_) or IsDataDescriptor(_Desc_) is
        TRUE, then

        i.  If _O_ is not UNDEFINED, then create an own data property
            named _P_ of object _O_ whose [[Value]], [[Writable]],
            [[Enumerable]] and [[Configurable]] attribute values are
            described by _Desc_. If the value of an attribute field of
            _Desc_ is absent, the attribute of the newly created
            property is set to its default value.

    d.  Else _Desc_ must be an accessor Property Descriptor,

        i.  If _O_ is not UNDEFINED, then create an own accessor
            property named _P_ of object _O_ whose [[Get]], [[Set]],
            [[Enumerable]] and [[Configurable]] attribute values are
            described by _Desc_. If the value of an attribute field of
            _Desc_ is absent, the attribute of the newly created
            property is set to its default value.

    e.  Return TRUE.

3.  Return TRUE, if every field in _Desc_ is absent.

4.  Return TRUE, if every field in _Desc_ also occurs in _current_ and
    the value of every field in _Desc_ is the same value as the
    corresponding field in _current_ when compared using the SameValue
    algorithm.

5.  If the [[Configurable]] field of _current_ is FALSE then

    a.  Return FALSE, if the [[Configurable]] field of _Desc_ is TRUE.

    b.  Return FALSE, if the [[Enumerable]] field of _Desc_ is present
        and the [[Enumerable]] fields of _current_ and _Desc_ are the
        Boolean negation of each other.

6.  If IsGenericDescriptor(_Desc_) is TRUE, then no further validation
    is required.

7.  Else if IsDataDescriptor(_current_) and IsDataDescriptor(_Desc_)
    have different results, then

    a.  Return FALSE, if the [[Configurable]] field of _current_ is
        FALSE.

    b.  If IsDataDescriptor(_current_) is TRUE, then

        i.  If _O_ is not UNDEFINED, then convert the property named _P_
            of object _O_ from a data property to an accessor property.
            Preserve the existing values of the converted property’s
            [[Configurable]] and [[Enumerable]] attributes and set the
            rest of the property’s attributes to their default values.

    c.  Else,

        i.  If _O_ is not UNDEFINED, then convert the property named _P_
            of object _O_ from an accessor property to a data property.
            Preserve the existing values of the converted property’s
            [[Configurable]] and [[Enumerable]] attributes and set the
            rest of the property’s attributes to their default values.

8.  Else if IsDataDescriptor(_current_) and IsDataDescriptor(_Desc_) are
    both TRUE, then

    a.  If the [[Configurable]] field of _current_ is FALSE, then

        i.  Return FALSE, if the [[Writable]] field of _current_ is
            FALSE and the [[Writable]] field of _Desc_ is TRUE.

        ii. If the [[Writable]] field of _current_ is FALSE, then

            1.  Return FALSE, if the [[Value]] field of _Desc_ is
                present and SameValue(_Desc_.[[Value]],
                _current_.[[Value]]) is FALSE.

    b.  Else the [[Configurable]] field of _current_ is TRUE, so any
        change is acceptable.

9.  Else IsAccessorDescriptor(_current_) and
    IsAccessorDescriptor(_Desc_) are both TRUE,

    a.  If the [[Configurable]] field of _current_ is FALSE, then

        i.  Return FALSE, if the [[Set]] field of _Desc_ is present and
            SameValue(_Desc_.[[Set]], _current_.[[Set]]) is FALSE.

        ii. Return FALSE, if the [[Get]] field of _Desc_ is present and
            SameValue(_Desc_.[[Get]], _current_.[[Get]]) is FALSE.

10. If _O_ is not UNDEFINED, then

    a.  For each field of _Desc_ that is present, set the corresponding
        attribute of the property named _P_ of object _O_ to the value
        of the field.

11. Return TRUE.

NOTE Step 8.b allows any field of Desc to be different from the
corresponding field of current if current’s [[Configurable]] field is
TRUE. This even permits changing the [[Value]] of a property whose
[[Writable]] attribute is FALSE. This is allowed because a TRUE
[[Configurable]] attribute would permit an equivalent sequence of calls
where [[Writable]] is first set to TRUE, a new [[Value]] is set, and
then [[Writable]] is set to FALSE.

 [[HasProperty]](P)

When the [[HasProperty]] internal method of _O_ is called with property
key _P_, the following steps are taken:

1.  Assert: IsPropertyKey(_P_) is TRUE.

2.  Let _hasOwn_ be the result of calling the [[GetOwnProperty]]
    internal method of _O_ with argument _P_.

3.  ReturnIfAbrupt(_hasOwn_).

4.  If _hasOwn_ is not UNDEFINED, then return TRUE.

5.  Let _parent_ be the result of calling the [[GetPrototypeOf]]
    internal method of _O_.

6.  ReturnIfAbrupt(_parent_).

7.  If _parent_ is not NULL, then

    a.  Return the result of calling the [[HasProperty]] internal method
        of _parent_ with argument _P_.

8.  Return FALSE.

[[Get]] (P, Receiver)

When the [[Get]] internal method of _O_ is called with property key _P_
and ECMAScript language value _Receiver_ the following steps are taken:

1.  Assert: IsPropertyKey(_P_) is TRUE.

2.  Let _desc_ be the result of calling the [[GetOwnProperty]] internal
    method of _O_ with argument _P_.

3.  ReturnIfAbrupt(_desc_).

4.  If _desc_ is UNDEFINED, then

    a.  Let _parent_ be the result of calling the [[GetPrototypeOf]]
        internal method of _O_.

    b.  ReturnIfAbrupt(_parent_).

    c.  If _parent_ is NULL, then return UNDEFINED.

    d.  Return the result of calling the [[Get]] internal method of
        _parent_ with arguments _P_ and _Receiver_.

5.  If IsDataDescriptor(_desc_) is TRUE, return _desc_.[[Value]].

6.  Otherwise, IsAccessorDescriptor(_desc_) must be TRUE so, let
    _getter_ be _desc_.[[Get]].

7.  If _getter_ is UNDEFINED, return UNDEFINED.

8.  Return the result of calling the [[Call]] internal method of
    _getter_ with _Receiver_ as the _thisArgument_ and an empty List as
    _argumentsList_.

[[Set]] ( P, V, Receiver)

When the [[Set]] internal method of _O_ is called with property key _P_,
value _V_, and ECMAScript language value _Receiver_, the following steps
are taken:

1.  Assert: IsPropertyKey(_P_) is TRUE.

2.  Let _ownDesc_ be the result of calling the [[GetOwnProperty]]
    internal method of _O_ with argument _P_.

3.  ReturnIfAbrupt(_ownDesc_).

4.  If _ownDesc_ is UNDEFINED, then

    a.  Let _parent_ be the result of calling the [[GetPrototypeOf]]
        internal method of _O_.

    b.  ReturnIfAbrupt(_parent_).

    c.  If _parent_ is not NULL, then

        i.  Return the result of calling the [[Set]] internal method of
            _parent_ with arguments _P_, _V_, and _Receiver_.

    d.  Else,

        i.  Let _ownDesc_ be the PropertyDescriptor{[[Value]]:
            UNDEFINED, [[Writable]]: TRUE, [[Enumerable]]: TRUE,
            [[Configurable]]: TRUE}.

5.  If IsDataDescriptor(_ownDesc_) is TRUE, then

    a.  If _ownDesc_.[[Writable]] is FALSE, return FALSE.

    b.  If Type(_Receiver_) is not Object, return FALSE.

    c.  Let _existingDescriptor_ be the result of calling the
        [[GetOwnProperty]] internal method of _Receiver_ with argument
        _P_.

    d.  ReturnIfAbrupt(_existingDescriptor_).

    e.  If _existingDescriptor_ is not UNDEFINED, then

        i.  Let _valueDesc_ be the PropertyDescriptor{[[Value]]: _V_}.

        ii. Return the result of calling the [[DefineOwnProperty]]
            internal method of _Receiver_ with arguments _P_ and
            _valueDesc_.

    f.  Else _Receiver_ does not currently have a property _P_,

        i.  Return CreateDataProperty(_Receiver_, _P_, _V_).

6.  If IsAccessorDescriptor(_ownDesc_) is TRUE, then

    a.  Let _setter_ be _ownDesc_.[[Set]].

    b.  If _setter_ is UNDEFINED, return FALSE.

    c.  Let _setterResult_ be the result of calling the [[Call]]
        internal method of _setter_ providing _Receiver_ as
        _thisArgument_ and a new List containing _V_ as _argumentsList_.

    d.  ReturnIfAbrupt(_setterResult_).

    e.  Return TRUE.

 [[Delete]] (P)

When the [[Delete]] internal method of _O_ is called with property key
_P_ the following steps are taken:

1.  Assert: IsPropertyKey(_P_) is TRUE.

2.  Let _desc_ be the result of calling the [[GetOwnProperty]] internal
    method of _O_ with argument _P_.

3.  ReturnIfAbrupt(_desc_).

4.  If _desc_ is UNDEFINED, then return TRUE.

5.  If _desc_.[[Configurable]] is TRUE, then

    a.  Remove the own property with name _P_ from _O_.

    b.  Return TRUE.

6.  Return FALSE.

[[Enumerate]] ()

When the [[Enumerate]] internal method of _O_ is called the following
steps are taken:

1.  Return an Iterator object (25.1.2) whose NEXT method iterates over
    all the String-valued keys of enumerable properties of _O_. The
    mechanics and order of enumerating the properties is not specified
    but must conform to the rules specified below.

The iterator’s NEXT method processes object properties to deterime
whether the property key should be returned as an iterator value.
Processed properties do not include properties whose property key is a
Symbol. Properties of the object being enumerated may be deleted during
enumeration. A property that is deleted before it is processed by the
iterator’s NEXT method is ignored. If new properties are added to the
object being enumerated during enumeration, the newly added properties
are not guaranteed to be processed in the active enumeration. A property
name will be return by the iterator’s NEXT method at most once in any
enumeration.

Enumerating the properties of an object includes processing properties
of its prototype, and the prototype of the prototype, and so on,
recursively; but a property of a prototype is not processed if has the
same name as a property that has already been processed by the
iterator’s NEXT method. The values of [[Enumerable]] attributes are not
considered when determining if a property of a prototype object has
already been processed.

The following is an informative definition of an ECMAScript generator
function that conforms to these rules:

function* enumerate(obj) {

if (Object(obj)!== obj) return undefined;

let visited = new Set;

while (obj !== null) {

for (name of Object.getOwnPropertyNames(obj)) {

//any new properties added to obj by vistor are ignored.

if (!visited.has(name)) {

let desc = Object.getOwnPropertyDescriptor(obj,name);

if (desc) {

visited.add(name);

if (desc.enumerable) yield name;

}

}

}

obj = Object.getPrototypeOf(obj);

}

}

1.  

2.  

3.  4.  5.  

    1.  

6.  7.  a.  i.  ii. iii. iv. 

8.  9.  

[[OwnPropertyKeys]] ( )

When the [[OwnPropertyKeys]] internal method of _O_ is called the
following steps are taken:

1.  Let _keys_ be a new empty List.

2.  For each own property key _P_ of _O_ that is an integer index, in
    ascending numeric index order

    a.  Add _P_ as the last element of _keys_.

3.  For each own property key _P_ of _O_ that is a String but is not an
    integer index, in property creation order

    a.  Add _P_ as the last element of _keys_.

4.  For each own property key _P_ of _O_ that is a Symbol, in property
    creation order

    a.  Add _P_ as the last element of _keys_.

5.  Return CreateArrayFromList(_keys_).

ObjectCreate(proto, internalSlotsList) Abstract Operation

The abstract operation ObjectCreate with argument _proto_ (an object or
null) is used to specify the runtime creation of new ordinary objects.
The optional argument _internalSlotsList_ is a List of the names of
additional internal slots that must be defined as part of the object. If
the list is not provided, an empty List is used. This abstract operation
performs the following steps:

1.  If _internalSlotsList_ was not provided, let _internalSlotsList_ be
    an empty List.

2.  Let _obj_ be a newly created object with an internal slot for each
    name in _internalSlotsList_.

3.  Set _obj_’s essential internal methods to the default ordinary
    object definitions specified in 9.1.

4.  Set the [[Prototype]] internal slot of _obj_ to _proto_.

5.  Set the [[Extensible]] internal slot of _obj_ to TRUE.

6.  Return _obj_.

OrdinaryCreateFromConstructor ( constructor, intrinsicDefaultProto, internalSlotsList )

The abstract operation OrdinaryCreateFromConstructor creates an ordinary
object whose [[Prototype]] value is retrieved from a constructor’s
PROTOTYPE property, if it exists. Otherwise the supplied default is used
for [[Prototype]]. The optional _internalSlotsList_ is a List of the
names of additional internal slots that must be defined as part of the
object. If the list is not provided, an empty List is used. This
abstract operation performs the following steps:

1.  Assert: _intrinsicDefaultProto_ is a string value that is this
    specification’s name of an intrinsic object. The corresponding
    object must be an intrinsic that is intended to be used as the
    [[Prototype]] value of an object.

2.  Let _proto_ be GetPrototypeFromConstructor(_constructor_,
    _intrinsicDefaultProto_).

3.  ReturnIfAbrupt(_proto_).

4.  Return ObjectCreate(_proto_, _internalSlotsList_).


ECMAScript Function Objects

ECMAScript function objects encapsulate parameterized ECMAScript code
closed over a lexical environment and support the dynamic evaluation of
that code. An ECMAScript function object is an ordinary object and has
the same internal slots and (except as noted below) and the same
internal methods as other ordinary objects. The code of an ECMAScript
function object may be either strict mode code (10.2.1) or non-strict
mode code.

ECMAScript function objects have the additional internal slots listed in
Table 26.

ECMAScript function objects whose code is not strict mode code (10.2.1)
provide an alternative definition for the [[GetOwnProperty]] internal
method. This alternative prevents the value of strict mode function from
being revealed as the value of a function object property named
"CALLER". The alternative definition exist solely to preclude a
non-standard legacy feature of some ECMAScript implementations from
revealing information about strict mode callers. If an implementation
does not provide such a feature, it need not implement this alternative
internal method for ECMAScript function objects. ECMAScript function
objects are considered to be ordinary objects even though they may use
the alternative definition of [[GetOwnProperty]].

Table 26 — Internal Slots of ECMAScript Function Objects

  _INTERNAL SLOT_        _TYPE_                      _DESCRIPTION_
  ---------------------- --------------------------- --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  [[Environment]]        Lexical Environment         The Lexical Environment that the function was closed over. Used as the outer environment when evaluating the code of the function.
  [[FormalParameters]]   Parse Node                  The root parse node of the source code that defines the function’s formal parameter list.
  [[FunctionKind]]       String                      Either "NORMAL" or "GENERATOR".
  [[Code]]               Parse Node                  The root parse node of the source code that defines the function’s body.
  [[Realm]]              Realm Record                The Code Realm in which the function was created and which provides any intrinsic objects that are accessed when evaluating the function.
  [[ThisMode]]           (lexical, strict, global)   Defines how THIS references are interpreted within the formal parameters and code body of the function. LEXICAL means that THIS refers to the THIS value of a lexically enclosing function. STRICT means that the THIS value is used exactly as provided by an invocation of the function. GLOBAL means that a THIS value of UNDEFINED is interpreted as a reference to the global object.
  [[Strict]]             Boolean                     TRUE if this is a strict mode function, FALSE if this is not a strict mode function.
  [[NeedsSuper]]         Boolean                     TRUE if this function uses SUPER.
  [[HomeObject]]         Object                      If the function uses SUPER, this is the object whose [[GetPrototypeOf]] provides the object where SUPER property lookups begin.
  [[MethodName]]         String or Symbol            If the function uses SUPER, this is the property key that is used for unqualified references to SUPER.

All ECMAScript function objects have the [[Call]] internal method
defined here. ECMAScript functions that are also constructors in
addition have the [[Construct]] internal method. ECMAScript function
objects whose code is not strict mode code have the [[Get]] and
[[GetOwnProperty]] internal methods defined here.

[[GetOwnProperty]] (P)

When the [[GetOwnProperty]] internal method of non-strict ECMAScript
function object _F_ is called with property key _P_, the following steps
are taken:

1.  Let _v_ be OrdinaryGetOwnProperty(_F_, _P_).

2.  3.  If IsDataDescriptor(_v_) is TRUE, then

    a.  If _P_ is "CALLER" then,

        i.  Let _callerValue_ be _v_.[[Value]].

        ii. If _callerValue_ is an ECMAScript Function object, then

            1.  If _callerValue_’s [[Strict]] internal slot is TRUE,
                then set _v_.[[Value]] to NULL.

4.  Return _v_.

If an implementation does not provide a built-in CALLER property for
non-strict ECMAScript function objects then it must not use this
definition. Instead the ordinary object [[GetOwnProperty]] internal
method is used.

1.  2.  3.  4.  5.  6.  7.  8.  9.  10. 11. 12. 13. 14. 

[[Call]] ( thisArgument, argumentsList) 

The [[Call]] internal method for an ECMAScript function object _F_ is
called with parameters _thisArgument_ and _argumentsList_, a List of
ECMAScript language values. The following steps are taken:

1.  If _F_’s [[Code]] internal slot has the value UNDEFINED, then throw
    a TYPEERROR exception.

2.  Let _callerContext_ be the running execution context.

3.  If _callerContext_ is not already suspended, then Suspend
    _callerContext_.

4.  Let _calleeContext_ be a new ECMAScript Code execution context.

5.  Set the Function of _calleeContext_ to _F_.

6.  Let _calleeRealm_ be the value of _F’s_ [[Realm]] internal slot.

7.  Set the Realm of _calleeContext_ to _calleeRealm_.

8.  Let _thisMode_ be the value of _F_’s [[ThisMode]] internal slot.

9.  Let _needsThisWrapper_ be FALSE.

10. If _thisMode_ is lexical, then

    a.  Let _localEnv_ be the result of calling
        NewDeclarativeEnvironment passing the value of the
        [[Environment]] internal slot of _F_ as the argument.

11. Else,

    a.  If _thisMode_ is strict, then let _thisValue_ be _thisArgument_.

    b.  Else

        i.  if _thisArgument_ is NULL or UNDEFINED, then

            1.  Let _thisValue_ be _calleeRealm_.[[globalThis]].

        ii. Else

            1.  if Type(_thisArgument_) is not Object, then let
                _needsThisWrapper_ be TRUE.

            2.  Let _thisValue_ be _thisArgument_.

    c.  Let _localEnv_ be NewFunctionEnvironment(_F_, _thisValue_).

    d.  ReturnIfAbrupt(_localEnv_).

    e.  NOTE Any exception objects produced by NewFunctionEnvironment
        are associated with _callerReam_.

12. Set the LexicalEnvironment of _calleeContext_ to _localEnv_.

13. Set the VariableEnvironment of _calleeContext_ to _localEnv_.

14. Push _calleeContext_ onto the execution context stack;
    _calleeContext_ is now the running execution context.

15. If _needsThisWrapper_ is TRUE then,

    a.  Let _wrapperedThis_ be ToObject(_thisArgument_).

    b.  Assert: _wrapperedThis_ is not an abrupt completion.

    c.  NOTE Wrappering deferred until _calleeContext_ is running so
        that ToObject produces objects using _calleeRealm_.

    d.  Let _functionEnv_ be _localEnv_’s environment record.

    e.  Set _functionEnv_’s _thisValue_ to _wrapperedThis_.

16. Let _status_ be the result of performing
    FunctionDeclarationInstantiation using the function _F_,
    _argumentsList_ , and _localEnv_ as described in 9.2.13.

17. If _status_ is an abrupt completion, then

    a.  Remove _calleeContext_ from the execution context stack and
        restore _callerContext_ as the running execution context.

    b.  Return _status_.

18. Let _result_ be the result of EvaluateBody of the production that is
    the value of _F_'s [[Code]] internal slot passing _F_ as the
    argument.

19. Remove _calleeContext_ from the execution context stack and restore
    _callerContext_ as the running execution context.

20. Return _result_.

NOTE 1 Most ECMAScript functions use a Function Environment Record as
their LexicalEnvironment. ECMAScript functions that are arrow functions
use a Declarative Environment Record as their LexicalEnvironment.

NOTE 2 When _calleeContext_ is removed from the execution context stack
it must not be destroyed because it may have been suspended and retained
by a generator object for later resumption_._

[[Construct]] ( argumentsList)

The [[Construct]] internal method for an ECMAScript Function object _F_
is called with a single parameter _argumentsList_ which is a possibly
empty List of ECMAScript language values. The following steps are taken:

1.  If _F_’s [[Code]] internal slot has the value UNDEFINED, then throw
    a TYPEERROR exception.

2.  Return Construct(_F_, _argumentsList_).

FunctionAllocate (functionPrototype, strict) Abstract Operation

The abstract operation FunctionAllocate requires the two arguments
_functionPrototype_ and _strict_. It also accepts one optional argument,
_functionKind_. FunctionAllocate performs the following steps:

1.  Assert: Type(_functionPrototype_) is Object.

2.  Assert: If _functionKind_ is present, its value is either "NORMAL",
    "NON-CONSTRUCTOR"or "GENERATOR".

3.  If _functionKind_ is not present, then let _functionKind_ be
    "NORMAL".

4.  If _functionKind_ is "NON-CONSTRUCTOR", then

    a.  Let _functionKind_ be "NORMAL".

    b.  Let _needsConstruct_ be FALSE.

5.  Else let _needsConstruct_ be TRUE.

6.  Let _F_ be a newly created ECMAScript function object with the
    internal slots listed in Table 26. All of those internal slots are
    initialized to UNDEFINED.

7.  Set _F_’s essential internal methods except for [[GetOwnProperty]]
    to the default ordinary object definitions specified in 9.1.

8.  If _strict_ is TRUE, set _F_’s [[GetOwnProperty]] internal method to
    the default ordinary object definitions specified in 9.1.

9.  Else, set _F_’s [[GetOwnProperty]] internal method to the
    definitions specified in 9.2.1.

10. Set _F_’s [[Call]] internal method to the definition specified in
    9.2.2.

11. If _needsConstruct_ is TRUE, then

    a.  Set _F_’s [[Construct]] internal method to the definition
        specified in 9.2.3.

12. Set the [[Strict]] internal slot of _F_ to _strict_.

13. Set the [[FunctionKind]] internal slot of _F_ to _functionKind_.

14. Set the [[Prototype]] internal slot of _F_ to _functionPrototype_.

15. Set the [[Extensible]] internal slot of _F_ to TRUE.

16. Set the [[Realm]] internal slot of _F_ to the running execution
    context’s Realm.

17. Return _F_.

FunctionInitialize (F, kind, Strict, ParameterList, Body, Scope) Abstract Operation

The abstract operation FunctionInitialize requires the arguments: a
function object _F_, _kind_ which is one of (Normal, Method, Arrow), a
Boolean _Strict_, a parameter list production specified by
_ParameterList_, a body production specified by _Body_, a Lexical
Environment specified by _Scope_. FunctionInitialize performs the
following steps:

1.  Let _len_ be the ExpectedArgumentCount of _ParameterList_.

2.  3.  Let _realm_ be the value of _F’s_ [[Realm]] internal slot.

4.  Let _status_ be DefinePropertyOrThrow(_F_, "LENGTH",
    PropertyDescriptor{[[Value]]: _len_, [[Writable]]: FALSE,
    [[Enumerable]]: FALSE, [[Configurable]]: TRUE}).

5.  ReturnIfAbrupt(_status_).

6.  If _Strict_ is TRUE, then

    a.  Let _status_ be AddRestrictedFunctionProperties(_F_, _realm_).

    b.  ReturnIfAbrupt(_status_).

7.  Set the [[Strict]] internal slot of _F_ to _Strict_.

8.  Set the [[Environment]] internal slot of _F_ to the value of
    _Scope_.

9.  Set the [[FormalParameters]] internal slot of _F_ to _ParameterList
    .

10. Set the [[Code]] internal slot of _F_ to _Body_.

11. If _kind_ is Arrow, then set the [[ThisMode]] internal slot of _F
    to lexical.

12. Else if _Strict_ is TRUE, then set the [[ThisMode]] internal slot of
    _F_ to strict.

13. Else set the [[ThisMode]] internal slot of _F_ to global.

14. Return _F_.

FunctionCreate (kind, ParameterList, Body, Scope, Strict) Abstract Operation

The abstract operation FunctionCreate requires the arguments: _kind_
which is one of (Normal, Method, Arrow), a parameter list production
specified by _ParameterList_, a body production specified by _Body_, a
Lexical Environment specified by _Scope_, a Boolean flag _Strict_, and
optionally, an object _functionPrototype_. FunctionCreate performs the
following steps:

1.  If the _functionPrototype_ argument was not passed, then

    a.  Let _functionPrototype_ be the intrinsic object
        %FunctionPrototype%.

2.  If _kind_ is not Normal, then let _allocKind_ be "NON-CONSTRUCTOR".

3.  Else let _allocKind_ be "NORMAL".

4.  Let _F_ be FunctionAllocate(_functionPrototype_, _Strict_,
    _allocKind_).

5.  Return FunctionInitialize(_F_, _kind_, _Strict_, _ParameterList_,
    _Body_, _Scope_).

GeneratorFunctionCreate (kind, ParameterList, Body, Scope, Strict) Abstract Operation

The abstract operation GeneratorFunctionCreate requires the arguments:
_kind_ which is one of (Normal, Method, Arrow), a parameter list
production specified by _ParameterList_, a body production specified by
_Body_, a Lexical Environment specified by _Scope_, and a Boolean flag
_Strict_. GeneratorFunctionCreate performs the following steps:

1.  2.  Let _functionPrototype_ be the intrinsic object %Generator%.

3.  Let _F_ be FunctionAllocate(_functionPrototype_, _Strict_,
    "GENERATOR").

4.  Return FunctionInitialize(_F_, _kind_, _Strict_, _ParameterList_,
    _Body_, _Scope_).

AddRestrictedFunctionProperties ( F, realm ) Abstract Operation

The abstract operation AddRestrictedFunctionProperties is called with a
function object _F_ and Realm Record _realm_ as its argument. It
performs the following steps:

1.  If _realm_.[[intrinsics]].[[%ThrowTypeError%]] exists and has been
    initialized, then

    a.  Let _thrower_ be _realm_.[[intrinsics]].[[%ThrowTypeError%]].

2.  Else,

    a.  NOTE %ThrowTypeError% must be the first intrinsic built-in
        function created for any Realm. If
        _realm_.[[intrinsics]].[[%ThrowTypeError%]] has not been
        initialized, _F_ must be %ThrowTypeError%.

    b.  Let _thrower_ be _F_.

3.  4.  5.  Let _status_ be DefinePropertyOrThrow(_F_, "CALLER",
    PropertyDescriptor {[[Get]]: _thrower_, [[Set]]: _thrower_,
    [[Enumerable]]: FALSE, [[Configurable]]: TRUE}).

6.  Assert: _status_ is not an abrupt completion.

7.  Return DefinePropertyOrThrow(_F_ , "ARGUMENTS", PropertyDescriptor
    {[[Get]]: _thrower_, [[Set]]: _thrower_, [[Enumerable]]: FALSE,
    [[Configurable]]: TRUE}).

8.  Assert: The above returned value is not an abrupt completion.

%ThrowTypeError% ( )

The %ThrowTypeError% intrinsic is an anonymous built-in function object
that is defined once for each Realm. When %ThrowTypeError% is called it
performs the following steps:

1.  2.  Throw a TYPEERROR exception.

The value of the [[Extensible]] internal slot of a %ThrowTypeError%
function is FALSE.

The LENGTH property of a %ThrowTypeError% function has the attributes
{ [[Writable]]: FALSE, [[Enumerable]]: FALSE, [[Configurable]]: FALSE }.

1.  2.  3.  4.  

MakeConstructor (F, writablePrototype, prototype) Abstract Operation

The abstract operation MakeConstructor requires a Function argument _F_
and optionally, a Boolean _writablePrototype_ and an object _prototype_.
If _prototype_ is provided it is assumed to already contain, if needed,
a "CONSTRUCTOR" property whose value is _F_. This operation converts _F_
into a constructor by performing the following steps:

1.  Assert: _F_ is an ECMAScript function object.

2.  Assert: _F_ has a [[Constructor]] internal method.

3.  Let _installNeeded_ be FALSE.

4.  If the _prototype_ argument was not provided, then

    a.  Let _installNeeded_ be TRUE.

    b.  Let _prototype_ be ObjectCreate(%ObjectPrototype%).

5.  If the _writablePrototype_ argument was not provided, then

    a.  Let _writablePrototype_ be TRUE.

6.  7.  If _installNeeded_, then

    a.  Let _status_ be DefinePropertyOrThrow(_prototype_,
        "CONSTRUCTOR", PropertyDescriptor{[[Value]]: _F_, [[Writable]]:
        _writablePrototype_, [[Enumerable]]: FALSE, [[Configurable]]:
        _writablePrototype_ }).

    b.  ReturnIfAbrupt(_status_).

8.  Let _status_ be DefinePropertyOrThrow(_F_, "PROTOTYPE",
    PropertyDescriptor{[[Value]]: _prototype_, [[Writable]]:
    _writablePrototype_, [[Enumerable]]: FALSE, [[Configurable]]:
    FALSE}).

9.  ReturnIfAbrupt(_status_).

10. Return NormalCompletion(UNDEFINED).

MakeMethod ( F, methodName, homeObject) Abstract Operation

The abstract operation MakeMethod with arguments _F_, _methodName_ and
_homeObject_ configures _F_ as a method by performing the following
steps:

1.  Assert: _F_ is an ECMAScript function object.

2.  Assert: _methodName_ is either UNDEFINED or a property key.

3.  Assert: Type(_homeObject_ ) is either Undefined or Object.

4.  Set the [[NeedsSuper]] internal slot of _F_ to TRUE.

5.  Set the [[HomeObject]] internal slot of _F_ to _homeObject_.

6.  Set the [[MethodName]] internal slot of _F_ to _methodName_.

7.  Return NormalCompletion(UNDEFINED).

SetFunctionName (F, name, prefix) Abstract Operation

The abstract operation SetFunctionName requires a Function argument _F_,
a String or Symbol argument _name_ and optionally a String argument
_prefix_. This operation adds a NAME property to _F_ by performing the
following steps:

1.  Assert: _F_ is an extensible ECMAScript function object that does
    not have a NAME own property.

2.  Assert: Type(_name_) is either Symbol or String.

3.  If Type(_name_) is Symbol, then

    a.  Let _description_ be _name_’s [[Description]] value.

    b.  If _description_ is UNDEFINED, then let _name_ be the empty
        String.

    c.  Else, let _name_ be the concatenation of "[", _description_, and
        "]".

4.  Let _name_ be the concatenation of _prefix_, Unicode code point
    U+0020 (Space) , and _name_.

5.  Return DefinePropertyOrThrow(_F_, "NAME",
    PropertyDescriptor{[[Value]]: _name_, [[Writable]]: FALSE,
    [[Enumerable]]: FALSE, [[Configurable]]: TRUE}.

6.  7.  

1.  2.  3.  

CloneMethod(function, newHome, newName) Abstract Operation

The abstract operation CloneMethod is called with a function object
_function_, an object _newHome_, and a property key _newName_ as its
argument. It performs the following steps:

1.  Assert: _function_ is an ECMAScript function object or an exotic
    Built-in function object.

2.  Assert: Type(_newHome_) is Object.

3.  Assert: Type(_newName_) is one of Undefined, String, or Symbol.

4.  If _function_ is an ECMAScript function, then

    a.  Let _new_ be a new ECMAScript function object that has all of
        the same internal methods and internal slots as _function_.

5.  Else

    a.  Assert: _function_ is an exotic Built-in function object.

    b.  Let _new_ be a new exotic Built-in function object that has all
        of the same internal methods and internal slots as _function_.

6.  Set the value of each of _new’s_ internal slots, except for
    [[Extensible]], [[HomeObject]] and [[MethodName]] to the value of
    _function’s_ corresponding internal slot.

7.  Set _new_’s [[Extensible]] internal slot to TRUE.

8.  If the value of _function_’s [[NeedsSuper]] internal slot is TRUE,
    then

    a.  Set the value of _new’s_ [[HomeObject]] internal slot to
        _newHome_.

    b.  If _newName_ is not UNDEFINED, then

        i.  Set the value of _new’s_ [[MethodName]] internal slot to
            _newName_.

    c.  Else,

        i.  Set the value of _new’s_ [[MethodName]] internal slot to the
            value of _function’s_ [[MethodName]] internal slot.

9.  If _function_ is an exotic Built-in function object or if
    _function_’s [[Strict]] internal slot is TRUE, then

    a.  Let _realm_ be GetFunctionRealm(_new_).

    b.  Let _status_ be AddRestrictedFunctionProperties(_new_, _realm_).

    c.  ReturnIfAbrupt(_status_).

10. Return _new_.

NOTE The purpose of this abstract operation is to create a new function
object that is identical to the argument object in all always except for
its identity and the value of its [[HomeObject]] internal slot. However,
properties of the function object, except for the restricted function
properties, are not created or copied.

FunctionDeclarationInstantiation(func, argumentsList, env ) Abstract Operation

NOTE When an execution context is established for evaluating an
ECMAScript function a new Declarative Environment Record is created and
bindings for each formal parameter are instantiated in that environment
record. Each declaration in the function body is also instantiated. If
the function’s formal parameters do not include any default value
initializers then the body declarations are instantiated in the same
environment record as the parameters. If default value parameter
initializers exist, a second environment record is created for the body
declarations. Formal parameters and functions are initialized as part of
FunctionDeclarationInstantiation. All other bindings are initialized
during evaluation of the function body.

FunctionDeclarationInstantiation is performed as follows using arguments
_func, argumentsList_, and _env_. _func_ is the function object that for
which the execution context is being established. _env_ is the
declarative environment record in which formal parameter bindings are to
be created.

1.  Let _code_ be the value of the [[Code]] internal slot of _func_.

2.  Let _strict_ be the value of the [[Strict]] internal slot of _func_.

3.  Let _formals_ be the value of the [[FormalParameters]] internal slot
    of _func_.

4.  Let _parameterNames_ be the BoundNames of _formals_.

5.  If _parameterNames_ has any duplicate entries, let _hasDuplicates
    be TRUE. Otherwise, let _hasDuplicates_ be FALSE.

6.  7.  Let _simpleParameterList_ be IsSimpleParameterList of _formals_.

8.  Let _hasParameterExpressions_ be ContainsExpresson of _formals.

9.  Let _varNames_ be the VarDeclaredNames of _code_.

10. Let _varDeclarations_ be the VarScopedDeclarations of _code_.

11. Let _lexicalNames_ be the LexicallyDeclaredNames of _code_.

12. Let _functionNames_ be an empty List.

13. Let _functionsToInitialize_ be an empty List.

14. For each _d_ in _varDeclarations_, in reverse list order do

    a.  If _d_ is neither a _VariableDeclaration_ or a _ForBinding_,
        then

        i.  Assert: _d_ is either a _FunctionDeclaration_ or a
            _GeneratorDeclaration_.

        ii. Let _fn_ be the sole element of the BoundNames of _d._

        iii. If _fn_ is not an element of _functionNames_, then

            1.  2.  Insert _fn_ as the first element of _functionNames_.

            3.  NOTE If there are multiple _FunctionDeclarations_ or
                _GeneratorDeclarations_ for the same name, the last
                declaration is used.

            4.  Insert _d_ as the first element of
                _functionsToInitialize_.

15. 16. Let _argumentsObjectNeeded_ be TRUE.

17. If the value of the [[ThisMode]] internal slot of _func_ is lexical,
    then

    a.  NOTE Arrow functions never have an arguments objects.

    b.  c.  Let _argumentsObjectNeeded_ be FALSE.

18. Else if "ARGUMENTS" is an element of _parameterNames_, then

    a.  b.  Let _argumentsObjectNeeded_ be FALSE.

19. Else

20. if _hasParameterExpressions_ is FALSE, then

21. If "ARGUMENTS" is an element of _functionNames

    a.  or if "ARGUMENTS" is an element of _lexicalNames_, then

        i.  Let _argumentsObjectNeeded_ be FALSE.

22. For each String _paramName_ in _parameterNames_, do

    a.  Let _alreadyDeclared_ be the result of calling _env’s_
        HasBinding concrete method passing _paramName_ as the argument.

    b.  NOTE Early errors ensure that duplicate parameter names can only
        occur in non-strict functions that do not have parameter default
        values or rest parameters.

    c.  If _alreadyDeclared_ is FALSE, then

        i.  Let _status_ be the result of calling _env’s_
            CreateMutableBinding concrete method passing _paramName_ as
            the argument.

        ii. If _hasDuplicates_ is TRUE, then

            1.  Let _status_ be the result of calling _env’s_
                InitializeBinding concrete method passing _paramName_
                and UNDEFINED as the argument.

        iii. Assert: _status_ is never an abrupt completion for either
            of the above operations.

23. If _argumentsObjectNeeded_ is TRUE, then

24. a.  If _strict_ is TRUE or if _simpleParameterList_ is FALSE, then

        i.  Let _ao_ be
            CreateUnmappedArgumentsObject(_argumentsList_)_._

    b.  Else,

        i.  NOTE mapped argument object is only provided for non-strict
            functions that don’t have a rest parameter, any parameter
            default value initializers, or any destructured parameters .

        ii. Let _ao_ be CreateMappedArgumentsObject(_func_, _formals_,
            _argumentsList_, _env_).

    c.  ReturnIfAbrupt(_ao_).

25. a.  i.  

    b.  i.  

    c.  d.  e.  i.  ii. 1.  

        iii. 1.  

        iv. 

    f.  

26. a.  If _strict_ is TRUE, then

        i.  Let _status_ be the result of calling _env’s_
            CreateImmutableBinding concrete method passing "ARGUMENTS"
            as the argument.

    b.  Else,

        i.  Let _status_ be the result of calling _env’s_
            CreateMutableBinding concrete method passing "ARGUMENTS" as
            the argument.

    c.  Assert: _status_ is never an abrupt completion.

    d.  e.  Call _env_’s InitializeBinding concrete method passing
        "ARGUMENTS" and _ao_ as arguments.

    f.  Append "ARGUMENTS" to _parameterNames_.

27. If _hasDuplicates_ is TRUE, then

    a.  Let _formalStatus_ be the result of performing
        IteratorBindingInitialization for _formals_ with
        CreateListIterator(_argumentsList_) and UNDEFINED as arguments.

28. Else,

    a.  Let _formalStatus_ be the result of performing
        IteratorBindingInitialization for _formals_ with
        CreateListIterator(_argumentsList_) and _env_ as arguments.

29. ReturnIfAbrupt(_formalStatus_).

30. 31. 32. 33. 34. If _hasParameterExpressions_ is FALSE, then

    a.  NOTE Only a single environment record is needed.

    b.  Let _bodyEnv_ be _env_.

    c.  Let _instantiatedVarNames_ be a copy of the List
        _parameterNames_.

    d.  For each _n_ in _varNames_, do

        i.  If _n_ is not an element of _instantiatedVarNames_, then

            1.  Append _n_ to _instantiatedVarNames_.

            2.  Let _status_ be the result of calling _bodyEnv’s_
                CreateMutableBinding concrete method passing _n_ as the
                argument.

            3.  Assert: _status_ is never an abrupt completion.

            4.  Call _bodyEnv_’s InitializeBinding concrete method
                passing _n_ and UNDEFINED as arguments.

35. Else,

    a.  NOTE A separate environment record is needed to ensure that
        closures created by expressions in the formal parameter list do
        not have visibility of declarations in the function body.

    b.  Let _bodyEnv_ be NewDeclarativeEnvironment(_env_).

    c.  Let _calleeContext_ be the running execution context.

    d.  Set the LexicalEnvironment of _calleeContext_ to _bodyEnv_.

    e.  Set the VariableEnvironment of _calleeContext_ to _bodyEnv_.

    f.  Let _instantiatedVarNames_ be a new emptyList.

    g.  For each _n_ in _varNames_, do

        i.  If _n_ is not an element of _instantiatedVarNames_, then

            1.  Append _n_ to _instantiatedVarNames_.

            2.  Let _status_ be the result of calling _bodyEnv’s_
                CreateMutableBinding concrete method passing _n_ as the
                argument.

            3.  Assert: _status_ is never an abrupt completion.

            4.  If _n_ is not an element of _parameterNames_ or if _n_
                is an element of _functionNames_, then let
                _initialValue_ be UNDEFINED.

            5.  else,

                a.  Let _initialValue_ be the result of calling _env’s_
                    GetBindingValue concrete method passing _n_ and
                    FALSE as the arguments.

                b.  ReturnIfAbrupt(_initialValue_).

            6.  Call _bodyEnv_’s InitializeBinding concrete method
                passing _n_ and _initialValue_ as arguments.

            7.  NOTE vars whose names are the same as a formal
                parameter, initially have the same value as the
                corresponding initialized parameter.

36. Let _lexDeclarations_ be the LexicallyScopedDeclarations of _code_.

37. For each element _d_ in _lexDeclarations_ do

    a.  NOTE A lexically declared name cannot be the same as a
        function/generator declaration, formal parameter, or a var name.
        Lexically declared names are only instantiated here but not
        initialized.

    b.  For each element _dn_ of the BoundNames of _d_ do

        i.  If IsConstantDeclaration of _d_ is TRUE, then

            1.  Let _status_ be the result of calling _bodyEnv_’s
                CreateImmutableBinding concrete method passing _dn_ as
                the argument.

        ii. Else,

            1.  Let _status_ be the result of calling _bodyEnv_’s
                CreateMutableBinding concrete method passing _dn_ and
                FALSE as the arguments.

    c.  Assert: _status_ is never an abrupt completion.

38. For each production _f_ in _functionsToInitialize_, do

    a.  Let _fn_ be the sole element of the BoundNames of _f._

    b.  Let _fo_ be the result of performing InstantiateFunctionObject
        for _f_ with argument _bodyEnv_.

    c.  d.  Let _status_ be the result of calling _bodyEnv_’s
        SetMutableBinding concrete method passing _fn_, _fo_ and FALSE
        as the arguments..

    e.  Assert: _status_ is never an abrupt completion.

39. Return NormalCompletion(empty).

NOTE B.3.2 provides an extension to the above algorithm that is
necessary for backwards compatability with web browser implementations
of ECAMScript that predate the sixth edition of ECMA-262.


Built-in Function Objects

The built-in function objects defined in this specification may be
implemented as either ECMAScript function objects (9.2) whose behaviour
is provided using ECMAScript code or as implementation provided exotic
function objects whose behaviour is provided in some other manner. In
either case, the effect of calling such functions must conform to their
specifications.

If a built-in function object is implemented as an exotic object it must
have the ordinary object behaviour specified in 9.1 except
[[GetOwnProperty]] which must be as specified in 9.2.1. All such exotic
function objects also have [[Prototype]] and [[Extensible]] internal
slots.

Unless otherwise specified every built-in function object initially has
the %FunctionPrototype% object (19.2.3) as the initial value of its
[[Prototype]] internal slot.

The behaviour specified for each built-in function via algorithm steps
or other means is the specification of the [[Call]] behaviour for that
function with the [[Call]] _thisArgument_ providing the THIS value and
the [[Call]] _argumentsList_ providing the named parameters for each
built-in function. If the built-in function is implemented as an
ECMAScript function object then this specified behaviour must be
implemented by the ECMAScript code that is the body of the function.
Built-in functions that are ECMAScript function objects must be strict
mode functions.

Built-in function objects that are not identified as constructors do not
implement the [[Construct]] internal method unless otherwise specified
in the description of a particular function. When a built-in constructor
is called as part of a NEW expression the _argumentsList_ parameter of
the invoked [[Construct]] internal method provides the values for the
built-in constructor’s named parameters.

Built-in functions that are not constructors do not have a PROTOTYPE
property unless otherwise specified in the description of a particular
function.

If a built-in function object is not implemented as an ECMAScript
function it must have a [[Realm]] internal slot. It must also have a
[[Call]] internal method that conforms to the following definition:

[[Call]] ( thisArgument, argumentsList) 

The [[Call]] internal method for a built-in function object _F_ is
called with parameters _thisArgument_ and _argumentsList_, a List of
ECMAScript language values. The following steps are taken:

1.  Let _callerContext_ be the running execution context.

2.  If _callerContext_ is not already suspended, then Suspend
    _callerContext_.

3.  Let _calleeContext_ be a new execution context.

4.  Set the Function of _calleeContext_ to _F_.

5.  Let _calleeRealm_ be the value of _F’s_ [[Realm]] internal slot.

6.  Set the Realm of _calleeContext_ to _calleeRealm_.

7.  Perform any necessary implementation defined initialization of
    _calleeContext_.

8.  Push _calleeContext_ onto the execution context stack;
    _calleeContext_ is now the running execution context.

9.  Let _result_ be the Completion Record that is the result of
    evaluating _F_ in an implementation defined manner that conforms to
    this specification of _F_.

10. Remove _calleeContext_ from the execution context stack and restore
    _callerContext_ as the running execution context.

11. Return _result_.

NOTE 1 When _calleeContext_ is removed from the execution context stack
it must not be destroyed because it may have been suspended and retained
by a generator object for later resumption_._

CreateBuiltinFunction(realm, steps, prototype, internalSlotsList) Abstract Operation

The abstract operation CreateBuiltinFunction takes arguments _realm_,
_prototype_, and _steps_. The optional argument _internalSlotsList_ is a
List of the names of additional internal slot that must be defined as
part of the object. If the list is not provided, an empty List is used.
CreateBuiltinFunction returns a built-in function object created by the
following steps:

1.  Assert: _realm_ is a Realm Record.

2.  Assert: _steps_ is either a set of algorithm steps or other
    definition of a functions behaviour provided in this specification.

3.  Let _func_ be a new built-in function object that when called
    performs the action described by _steps_. The new function object
    has internal slots whose names are the elements of
    _internalSlotsList_. The initial value of each of those internal
    slots is UNDEFINED_._

4.  Set the [[Realm]] internal slot of _func_ to _realm_.

5.  Call the [[SetPrototypeOf]] internal method of _func_ with argument
    _prototype_.

6.  Perform the AddRestrictedFunctionProperties(_func_, _realm_).

7.  Return _func_.


Built-in Exotic Object Internal Methods and Data Fields

This specification defines several kinds of built-in exotic objects.
These objects generally behave similar to ordinary objects except for a
few specific situations. The following exotic objects use the ordinary
object internal methods except where it is explicitly specified
otherwise below:

Bound Function Exotic Objects

A _bound function_ is an exotic object that wrappers another function
object. A bound function is callable (it has a [[Call]] internal method
and may have a [[Construct]] internal method). Calling a bound function
generally results in a call of its wrapped function.

Bound function objects do not have the internal slots of ECMAScript
function objects defined in Table 26. Instead they have the internal
slots defined in Table 27.

Table 27 — Internal Slots of Exotic Bound Function Objects

  _INTERNAL SLOT_           _TYPE_            _DESCRIPTION_
  ------------------------- ----------------- -------------------------------------------------------------------------------------------------------------
  [[BoundTargetFunction]]   Callable Object   The wrappered function object.
  [[BoundThis]]             Any               The value that is always passed as the THIS value when calling the wrappered function.
  [[BoundArguments]]        List of Any       A list of values that whose elements are used as the first arguments to any call to the wrappered function.

Unlike ECMAScript function objects, bound function objects do not use
alternative definitions of the [[Get]] and [[GetOwnProperty]] internal
methods. Bound function objects provide all of the essential internal
methods as specified in 9.1. However, they use the following definitions
for the essential internal methods of function objects.

[[Call]]

When the [[Call]] internal method of an exotic bound function object,
_F_, which was created using the bind function is called with parameters
_thisArgument_ and _argumentsList_, a List of ECMAScript language
values, the following steps are taken:

1.  Let _boundArgs_ be the value of _F’s_ [[BoundArguments]] internal
    slot.

2.  Let _boundThis_ be the value of _F’s_ [[BoundThis]] internal slot.

3.  Let _target_ be the value of _F’s_ [[BoundTargetFunction]] internal
    slot.

4.  Let _args_ be a new list containing the same values as the list
    _boundArgs_ in the same order followed by the same values as the
    list _argumentsList_ in the same order.

5.  Return the result of calling the [[Call]] internal method of
    _target_ providing _boundThis_ as _thisArgument_ and providing
    _args_ as _argumentsList_.

[[Construct]]

When the [[Construct]] internal method of an exotic bound function
object, _F_ that was created using the bind function is called with a
list of arguments _ExtraArgs_, the following steps are taken:

1.  Let _target_ be the value of _F’s_ [[BoundTargetFunction]] internal
    slot.

2.  Assert: _target_ has a [[Construct]] internal method.

3.  Let _boundArgs_ be the value of _F’s_ [[BoundArguments]] internal
    slot.

4.  Let _args_ be a new list containing the same values as the list
    _boundArgs_ in the same order followed by the same values as the
    list _ExtraArgs_ in the same order.

5.  Return the result of calling the [[Construct]] internal method of
    _target_ providing _args_ as the arguments.

BoundFunctionCreate (targetFunction, boundThis, boundArgs) Abstract Operation

The abstract operation BoundFunctionCreate with arguments
_targetFunction_, _boundThis_ and _boundArgs_ is used to specify the
creation of new Bound Function exotic objects. It performs the following
steps:

1.  Let _proto_ be the intrinsic %FunctionPrototype%.

2.  Let _obj_ be a newly created object.

3.  Set _obj_’s essential internal methods to the default ordinary
    object definitions specified in 9.1.

4.  Set the [[Call]] internal method of _obj_ as described in 9.4.1.1.

5.  If _targetFunction_ has a [[Construct]] internal method, then

    a.  Set the [[Construct]] internal method of _obj_ as described in
        9.4.1.2.

6.  Set the [[Prototype]] internal slot of _obj_ to _proto_.

7.  Set the [[Extensible]] internal slot of _obj_ to TRUE.

8.  Set the [[BoundTargetFunction]] internal slot of _obj_ to
    _targetFunction_.

9.  Set the [[BoundThis]] internal slot of _obj_ to the value of
    _boundThis_.

10. Set the [[BoundArguments]] internal slot of _obj_ to _boundArgs_.

11. Return _obj_.

BoundFunctionClone ( function ) Abstract Operation

The abstract operation BoundFunctionClone is called with argument
_function_ it performs the following steps:

1.  Assert: _function_ is a Bound Function exotic object.

2.  3.  Let _new_ be a new Bound Function exotic object that has all of
    the same internal methods and internal slots as _function_.

4.  Set the value of each of _new’s_ internal slots, except for
    [[Extensible]] to the value of _function’s_ corresponding internal
    slot.

5.  Set _new_’s [[Extensible]] internal slot to TRUE.

6.  Let _realm_ be GetFunctionRealm(_new_).

7.  Let _status_ be AddRestrictedFunctionProperties(_new_, _realm_).

8.  ReturnIfAbrupt(_status_).

9.  Return _new_.

1.  2.  3.  a.  

4.  a.  

5.  

Array Exotic Objects

An _Array object_ is an exotic object that gives special treatment to
array index property keys (see 6.1.7). A property whose property name is
an array index is also called an _element_. Every Array object has a
LENGTH property whose value is always a nonnegative integer less than
2^32^. The value of the LENGTH property is numerically greater than the
name of every property whose name is an array index; whenever a property
of an Array object is created or changed, other properties are adjusted
as necessary to maintain this invariant. Specifically, whenever a
property is added whose name is an array index, the LENGTH property is
changed, if necessary, to be one more than the numeric value of that
array index; and whenever the LENGTH property is changed, every property
whose name is an array index whose value is not smaller than the new
length is automatically deleted. This constraint applies only to own
properties of an Array object and is unaffected by LENGTH or array index
properties that may be inherited from its prototypes.

NOTE A String property name _P_ is an _array index_ if and only if
ToString(ToUint32(_P_)) is equal to _P_ and ToUint32(_P_) is not equal
to 2^32^−1.

Exotic Array objects have the same internal slots as ordinary objects.
They also have an [[ArrayInitializationState]] internal slot.

Exotic Array objects always have a non-configurable property named
"LENGTH".

Exotic Array objects provide an alternative definition for the
[[DefineOwnProperty]] internal method. Except for that internal method,
exotic Array objects provide all of the other essential internal methods
as specified in 9.1.

[[DefineOwnProperty]] ( P, Desc)

When the [[DefineOwnProperty]] internal method of an exotic Array object
_A_ is called with property key _P_, and Property Descriptor _Desc_ the
following steps are taken:

1.  Assert: IsPropertyKey(_P_) is TRUE.

2.  If _P_ is "LENGTH", then

    a.  Return ArraySetLength(_A_, _Desc_).

3.  Else if _P_ is an array index, then

    a.  Let _oldLenDesc_ be OrdinaryGetOwnProperty(_A_, "LENGTH").

    b.  Assert: _oldLenDesc_ will never be UNDEFINED or an accessor
        descriptor because Array objects are created with a length data
        property that cannot be deleted or reconfigured.

    c.  Let _oldLen_ be _oldLenDesc_.[[Value]].

    d.  Let _index_ be ToUint32(_P_).

    e.  f.  Assert: _index_ will never be an abrupt completion.

    g.  If _index_ ≥ _oldLen_ and _oldLenDesc_.[[Writable]] is FALSE,
        then return FALSE.

    h.  Let _succeeded_ be the result of calling
        OrdinaryDefineOwnProperty passing _A_, _P_, and _Desc_ as
        arguments.

    i.  ReturnIfAbrupt(_succeeded_).

    j.  If _succeeded_ is FALSE, then return FALSE.

    k.  If _index_ ≥ _oldLen_

        i.  Set _oldLenDesc_.[[Value]] to _index_ + 1.

        ii. Let _succeeded_ be OrdinaryDefineOwnProperty(_A_, "LENGTH",
            _oldLenDesc_).

        iii. ReturnIfAbrupt(_succeeded_).

    l.  Return TRUE.

4.  Return OrdinaryDefineOwnProperty(_A_, _P_, _Desc_).

ArrayCreate(length, proto) Abstract Operation

The abstract operation ArrayCreate with argument _length_ (a positive
integer or UNDEFINED) and optional argument _proto_ is used to specify
the creation of new exotic Array objects. It performs the following
steps:

1.  Assert: _length_ is either UNDEFINED or a integer Number ≥ 0.

2.  If _length_ is −0, then let _length_ be +0.

3.  If the _proto_ argument was not passed, then let _proto_ be the
    intrinsic object %ArrayPrototype%.

4.  Let _A_ be a newly created Array exotic object.

5.  Set _A_’s essential internal methods except for
    [[DefineOwnProperty]] to the default ordinary object definitions
    specified in 9.1.

6.  Set the [[DefineOwnProperty]] internal method of _A_ as specified in
    9.4.2.1.

7.  Set the [[Prototype]] internal slot of _A_ to _proto_.

8.  Set the [[Extensible]] internal slot of _A_ to TRUE.

9.  If _length_ is not UNDEFINED, then

    a.  Set the [[ArrayInitializationState]] internal slot of _A_ to
        TRUE.

10. Else

    a.  Set the [[ArrayInitializationState]] internal slot of _A_ to
        FALSE.

    b.  Let _length_ be +0.

11. If _length_>2^32^-1, then throw a RANGEERROR exception.

12. Call OrdinaryDefineOwnProperty with arguments _A_, "LENGTH" and
    PropertyDescriptor{[[Value]]: _length_, [[Writable]]: TRUE,
    [[Enumerable]]: FALSE, [[Configurable]]: FALSE}.

13. Return _A_.

ArraySetLength(A, Desc) Abstract Operation

When the abstract operation ArraySetLength is called with an exotic
Array object _A_, and Property Descriptor _Desc_ the following steps are
taken:

1.  If the [[Value]] field of _Desc_ is absent, then

    a.  Return OrdinaryDefineOwnProperty(_A_, "LENGTH", _Desc_).

2.  Let _newLenDesc_ be a copy of _Desc_.

3.  Let _newLen_ be ToUint32(_Desc_.[[Value]]).

4.  If _newLen_ is not equal to ToNumber( _Desc_.[[Value]]), throw a
    RANGEERROR exception.

5.  Set _newLenDesc_.[[Value]] to _newLen_.

6.  Let _oldLenDesc_ be the result of calling the [[GetOwnProperty]]
    internal method of _A_ passing "LENGTH" as the argument.

7.  ReturnIfAbrupt(_oldLenDesc_).

8.  Assert: _oldLenDesc_ will never be UNDEFINED or an accessor
    descriptor because Array objects are created with a length data
    property that cannot be deleted or reconfigured.

9.  Let _oldLen_ be _oldLenDesc_.[[Value]].

10. If _newLen_ ≥_oldLen_, then

    a.  Return OrdinaryDefineOwnProperty(_A_, "LENGTH", _newLenDesc_).

11. If _oldLenDesc_.[[Writable]] is FALSE, then return FALSE.

12. If _newLenDesc_.[[Writable]] is absent or has the value TRUE, let
    _newWritable_ be TRUE.

13. Else,

    a.  Need to defer setting the [[Writable]] attribute to FALSE in
        case any elements cannot be deleted.

    b.  Let _newWritable_ be FALSE.

    c.  Set _newLenDesc_.[[Writable]] to TRUE.

14. Let _succeeded_ be OrdinaryDefineOwnProperty(_A_, "LENGTH",
    _newLenDesc_).

15. ReturnIfAbrupt(_succeeded_).

16. If _succeeded_ is FALSE, return FALSE.

17. While _newLen_ < _oldLen_ repeat,

    a.  Set _oldLen_ to _oldLen_ – 1.

    b.  Let _deleteSucceeded_ be the result of calling the [[Delete]]
        internal method of _A_ passing ToString(_oldLen_).

    c.  ReturnIfAbrupt(_succeeded_).

    d.  If _deleteSucceeded_ is FALSE, then

        i.  Set _newLenDesc_.[[Value]] to _oldLen+1_.

        ii. If _newWritable_ is FALSE, set _newLenDesc_.[[Writable]] to
            FALSE.

        iii. Let _succeeded_ be OrdinaryDefineOwnProperty(_A_, "LENGTH",
            _newLenDesc_).

        iv. ReturnIfAbrupt(_succeeded_).

        v.  Return FALSE.

18. If _newWritable_ is FALSE, then

    a.  Call OrdinaryDefineOwnProperty passing _A_, "LENGTH", and
        PropertyDescriptor{[[Writable]]: FALSE} as arguments. This call
        will always return TRUE.

19. Return TRUE.

NOTE In steps 3 and 4, if _Desc_.[[Value]] is an object then its VALUEOF
method is called twice. This is legacy behaviour that was specified with
this effect starting with the 2^nd^ Edition of this specification.

String Exotic Objects

A _String object_ is an exotic object that encapsulates a String value
and exposes virtual integer indexed data properties corresponding to the
individual code unit elements of the string value. Exotic String objects
always have a data property named "LENGTH" whose value is the number of
code unit elements in the encapsulated String value. Both the code unit
data properties and the "LENGTH" property are non-writable and
non-configurable.

Exotic String objects have the same internal slots as ordinary objects.
They also have a [[StringData]] internal slot.

Exotic String objects provide alternative definitions for the following
internal methods. All of the other exotic String object essential
internal methods that are not defined below are as specified in 9.1.

 [[GetOwnProperty]] ( P )

When the [[GetOwnProperty]] internal method of an exotic String object
_S_ is called with property key _P_ the following steps are taken:

1.  Assert: IsPropertyKey(_P_) is TRUE.

2.  Let _desc_ be OrdinaryGetOwnProperty(_S_, _P_).

3.  4.  If _desc_ is not UNDEFINED return _desc_.

5.  If Type(_P_) is not String, then return UNDEFINED.

6.  Let _index_ be CanonicalNumericIndexString (_P_).

7.  Assert: _index_ is not an abrupt completion.

8.  If _index_ is UNDEFINED, then return UNDEFINED.

9.  If IsInteger(_index_) is FALSE, then return UNDEFINED.

10. If _index_ = −0, then return UNDEFINED.

11. 12. Let _str_ be the String value of the [[StringData]] internal
    slot of _S_, if the value of [[StringData]] is UNDEFINED the empty
    string is used as its value.

13. Let _len_ be the number of elements in _str_.

14. If _index_ < 0 or _len_ ≤ _index_, return UNDEFINED.

15. Let _resultStr_ be a String value of length 1, containing one code
    unit from _str_, specifically the code unit at position _index_,
    where the first (leftmost) element in _str_ is considered to be at
    position 0, the next one at position 1, and so on.

16. Return a PropertyDescriptor{ [[Value]]: _resultStr_, [[Enumerable]]:
    TRUE, [[Writable]]: FALSE, [[Configurable]]: FALSE }.

 [[Enumerate]] ()

When the [[Enumerate]] internal method of an exotic String object _O_ is
called the following steps are taken:

1.  Let _indexKeys_ be a new empty List.

2.  Let _str_ be the String value of the [[StringData]] internal slot of
    _O_, if the value of [[StringData]] is UNDEFINED the empty string is
    used as its value.

3.  Let _len_ be the number of elements in _str_.

4.  For each integer _i_ starting with 0 such that _i_ < _len_, in
    ascending order,

    a.  Add ToString(_i_) as the last element of _indexKeys_

5.  Let _ordinary_ be the result of calling the default ordinary object
    [[Enumerate]] internal method (9.1.11) on _O_.

6.  ReturnIfAbrupt(_ordinary_).

7.  Return CreateCompoundIterator(CreateListIterator(_indexKeys_),
    _ordinary_)_._

[[OwnPropertyKeys]] ( )

When the [[OwnPropertyKeys]] internal method of a String exotic object
_O_ is called the following steps are taken:

1.  Let _keys_ be a new empty List.

2.  Let _str_ be the String value of the [[StringData]] internal slot of
    _O_, if the value of [[StringData]] is UNDEFINED the empty string is
    used as its value.

3.  Let _len_ be the number of elements in _str_.

4.  For each integer _i_ starting with 0 such that _i_ < _len_, in
    ascending order,

    a.  Add ToString(_i_) as the last element of _keys_

5.  For each own property key _P_ of _O_ such that _P_ is an integer
    index and ToInteger(_P_) ≥ _len_, in ascending numeric index order,

    a.  Add _P_ as the last element of _keys_.

6.  For each own property key _P_ of _O_ such that Type(_P_) is String
    and _P_ is not an integer index, in property creation order,

    a.  Add _P_ as the last element of _keys_.

7.  For each own property key _P_ of _O_ such that Type(_P_) is Symbol,
    in property creation order,

    a.  Add _P_ as the last element of _keys_.

8.  Return CreateArrayFromList(_keys_).

StringCreate Abstract Operation

The abstract operation StringCreate with argument _prototype_ is used to
specify the creation of new exotic String objects. It performs the
following steps:

1.  Let _A_ be a newly created String exotic object.

2.  Set _A_’s essential internal methods to the default ordinary object
    definitions specified in 9.1.

3.  Set the [[GetOwnProperty]] internal method of _A_ as specified in
    9.4.3.1.

4.  5.  Set the [[Enumerate]] internal method of _A_ as specified in
    9.4.3.2.

6.  Set the [[OwnPropertyKeys]] internal method of _A_ as specified in
    9.4.3.3.

7.  Set the [[Prototype]] internal slot of _A_ to _prototype_.

8.  Set the [[Extensible]] internal slot of _A_ to TRUE.

9.  Return _A_.

Arguments Exotic Objects

Most ECMAScript functions make an arguments objects available to their
code. Depending upon the characteristics of the function definition, its
argument object is either an ordinary object or an _arguments exotic
object_. An aguments exotic object is an exotic object whose array index
properties map to the formal parameters bindings of an invocation of its
associated ECMAScript function.

Arguments exotic objects have the same internal slots as ordinary
objects. They also have a [[ParameterMap]] internal slot. Ordinary
arguments objects also have a [[ParameterMap]] internal slot whose value
is always undefined. For ordinany argument objects the [[ParameterMap]]
internal slot is only used by OBJECT.PROTOTYPE.TOSTRING (19.1.3.6) to
identify them as such.

Arguments exotic objects provide alternative definitions for the
following internal methods. All of the other exotic arguments object
essential internal methods that are not defined below are as specified
in 9.1

NOTE 1 For non-strict mode functions the integer indexed data properties
of an arguments object whose numeric name values are less than the
number of formal parameters of the corresponding function object
initially share their values with the corresponding argument bindings in
the function’s execution context. This means that changing the property
changes the corresponding value of the argument binding and vice-versa.
This correspondence is broken if such a property is deleted and then
redefined or if the property is changed into an accessor property. For
strict mode functions, the values of the arguments object’s properties
are simply a copy of the arguments passed to the function and there is
no dynamic linkage between the property values and the formal parameter
values.

NOTE 2 The ParameterMap object and its property values are used as a
device for specifying the arguments object correspondence to argument
bindings. The ParameterMap object and the objects that are the values of
its properties are not directly observable from ECMAScript code. An
ECMAScript implementation does not need to actually create or use such
objects to implement the specified semantics.

NOTE 3 Arguments objects for strict mode functions define
non-configurable accessor properties named "CALLER" and "CALLEE" which
throw a TYPEERROR exception on access. The "CALLEE" property has a more
specific meaning for non-strict mode functions and a "CALLER" property
has historically been provided as an implementation-defined extension by
some ECMAScript implementations. The strict mode definition of these
properties exists to ensure that neither of them is defined in any other
manner by conforming ECMAScript implementations.

 [[GetOwnProperty]] (P)

The [[GetOwnProperty]] internal method of an arguments exotic object
when called with a property name _P_ performs the following steps:

1.  Let _args_ be the arguments object.

2.  Let _desc_ be OrdinaryGetOwnProperty(_args_, _P_).

3.  If _desc_ is UNDEFINED then return _desc_.

4.  Let _map_ be the value of the [[ParameterMap]] internal slot of the
    arguments object.

5.  Let _isMapped_ be the result of calling the [[GetOwnProperty]]
    internal method of _map_ passing _P_ as the argument.

6.  Assert: _isMapped_ is never an abrupt completion.

7.  If the value of _isMapped_ is true, then

    a.  Set _desc_.[[Value]] to Get(_map_, _P_).

1.  If IsDataDescriptor(_desc_) is TRUE and _P_ is "CALLER" and
    _desc_.[[Value]] is a strict mode Function object, throw a TYPEERROR
    exception.

1.  Return _desc_.

If an implementation does not provide a built-in CALLER property for
argument exotic objects then step 8 of this algorithm is must be
skipped.

 [[DefineOwnProperty]] (P, Desc)

The [[DefineOwnProperty]] internal method of an arguments exotic object
when called with a property name _P_ and Property Descriptor _Desc_
performs the following steps:

1.  Let _args_ be the arguments object.

2.  Let _map_ be the value of the [[ParameterMap]] internal slot of the
    arguments object.

3.  Let _isMapped_ be HasOwnProperty(_map_, _P_).

4.  Let _allowed_ be OrdinaryDefineOwnProperty(_args_, _P_, _Desc_).

5.  ReturnIfAbrupt(_allowed_).

6.  If _allowed_ is FALSE, then return FALSE.

7.  If the value of _isMapped_ is TRUE, then

    a.  If IsAccessorDescriptor(_Desc_) is TRUE, then

        i.  Call the [[Delete]] internal method of _map_ passing _P_ as
            the argument.

    b.  Else

        i.  If _Desc_.[[Value]] is present, then

            1.  Let _putStatus_ be Put(_map_, _P_, _Desc_.[[Value]],
                FALSE).

            2.  Assert: _putStatus_ is TRUE because formal parameters
                mapped by argument objects are always writable.

        ii. If _Desc_.[[Writable]] is present and its value is FALSE,
            then

            1.  Call the [[Delete]] internal method of _map_ passing _P_
                as the argument.

8.  Return TRUE.

[[Get]] (P, Receiver)

The [[Get]] internal method of an arguments exotic object when called
with a property name _P_ and ECMAScript language value _Receiver_
performs the following steps:

1.  Let _args_ be the arguments object.

2.  Let _map_ be the value of the [[ParameterMap]] internal slot of the
    arguments object.

3.  Let _isMapped_ be HasOwnProperty(_map_, _P_).

4.  Assert: _isMapped_ is not an abrupt completion.

5.  If the value of _isMapped_ is FALSE, then

    a.  Let _v_ be the result of calling the default ordinary object
        [[Get]] internal method (9.1.8) on _args_ passing _P_ and
        _Receiver_ as the arguments.

6.  Else _map_ contains a formal parameter mapping for _P_,

    a.  Let _v_ be Get(_map_, _P_).

7.  ReturnIfAbrupt(_v_).

8.  If _P_ is "CALLER" and _v_ is a strict mode Function object, throw a
    TYPEERROR exception.

9.  Return _v_.

If an implementation does not provide a built-in CALLER property for
argument exotic objects then step 8 of this algorithm must be skipped.

 [[Set]] ( P, V, Receiver)

The [[Set]] internal method of an arguments exotic object when called
with property key _P_, value _V_, and ECMAScript language value
_Receiver_ performs the following steps:

1.  Let _args_ be the arguments object.

2.  If SameValue(_args_, _Receiver_) is FALSE, then

    a.  Let _isMapped_ be UNDEFINED.

3.  Else,

    a.  Let _map_ be the value of the [[ParameterMap]] internal slot of
        the arguments object.

    b.  Let _isMapped_ be HasOwnProperty(_map_, _P_).

    c.  Assert: _isMapped_ is not an abrupt completion.

4.  If the value of _isMapped_ is FALSE, then

    a.  Return the result of calling the default ordinary object [[Set]]
        internal method (9.1.8) on _args_ passing _P_, _V_ and
        _Receiver_ as the arguments.

5.  Else _map_ contains a formal parameter mapping for _P_,

    a.  Return Put(_map_, _P_, _V_, FALSE).

 [[Delete]] (P)

The [[Delete]] internal method of an arguments exotic object when called
with a property key _P_ performs the following steps:

1.  Let _map_ be the value of the [[ParameterMap]] internal slot of the
    arguments object.

2.  Let _isMapped_ be HasOwnProperty(_map_, _P_).

3.  Assert: _isMapped_ is not an abrupt completion.

4.  Let _result_ be the result of calling the default [[Delete]]
    internal method for ordinary objects (9.1.10) on the arguments
    object passing _P_ as the argument.

5.  ReturnIfAbrupt(_result_).

6.  If _result_ is TRUE and the value of _isMapped_ is TRUE, then

    a.  Call the [[Delete]] internal method of _map_ passing _P_ as the
        argument.

7.  Return _result_.

NOTE 1 For non-strict mode functions with simple parameter lists, those
integer indexed data properties of an arguments object whose numeric
name values are less than the number of formal parameters of the
function initially share their values with the corresponding argument
bindings in the function’s execution context. This means that changing
the property changes the corresponding value of the argument binding and
vice-versa. This correspondence is broken if such a property is deleted
and then redefined or if the property is changed into an accessor
property. For strict mode functions, the values of the arguments
object’s properties are simply a copy of the arguments passed to the
function and there is no dynamic linkage between the property values and
the formal parameter values.

NOTE 2 The ParameterMap object and its property values are used as a
device for specifying the arguments object correspondence to argument
bindings. The ParameterMap object and the objects that are the values of
its properties are not directly accessible from ECMAScript code. An
ECMAScript implementation does not need to actually create or use such
objects to implement the specified semantics.

NOTE 3 Arguments objects for strict mode functions define
non-configurable accessor properties named "CALLER" and "CALLEE" which
throw a TYPEERROR exception on access. The "CALLEE" property has a more
specific meaning for non-strict mode functions and a "CALLER" property
has historically been provided as an implementation-defined extension by
some ECMAScript implementations. The strict mode definition of these
properties exists to ensure that neither of them is defined in any other
manner by conforming ECMAScript implementations.

CreateUnmappedArgumentsObject(argumentsList) Abstract Operation

The abstract operation CreateUnmappedArgumentsObject called with an
argument _argumentsList_ performs the following steps:

1.  Let _len_ be the number of elements in _argumentsList_.

2.  Let _obj_ be ObjectCreate(%ObjectPrototype%, ([[ParameterMap]])).

3.  Set _obj_’s [[ParameterMap]] internal slot to UNDEFINED.

4.  Perform DefinePropertyOrThrow(_obj_, "LENGTH",
    PropertyDescriptor{[[Value]]: _len_, [[Writable]]: TRUE,
    [[Enumerable]]: FALSE, [[Configurable]]: TRUE}).

5.  Let _index_ be 0.

6.  Repeat while _index_ < _len_,

    a.  Let _val_ be the element of _argumentsList_ at 0-origined list
        position _index_.

    b.  Perform CreateDataProperty(_obj_, ToString(_index_), _val_).

    c.  Let _index_ be _index_ + 1

1.  Perform DefinePropertyOrThrow(_obj_, @@iterator, PropertyDescriptor
    {[[Value]]:%ArrayProto_values%, [[Writable]]: TRUE, [[Enumerable]]:
    FALSE, [[Configurable]]: TRUE}).

2.  Perform DefinePropertyOrThrow(_obj_, "CALLER", PropertyDescriptor
    {[[Get]]: %ThrowTypeError%, [[Set]]: %ThrowTypeError%,
    [[Enumerable]]: FALSE, [[Configurable]]: FALSE}).

3.  Perform DefinePropertyOrThrow(_obj_, "CALLEE", PropertyDescriptor
    {[[Get]]: %ThrowTypeError%, [[Set]]: %ThrowTypeError%,
    [[Enumerable]]: FALSE, [[Configurable]]: FALSE}).

1.  Assert: the above property definitions will not produce an abrupt
    completion.

2.  Return _obj

CreateMappedArgumentsObject ( func, formals, argumentsList, env ) Abstract Operation

The abstract operation CreateMappedArgumentsObject is called with object
_func_, grammar production _formals_, List _argumentsList_, and
environment record _env_. The following steps are performed:

1.  Assert: _formals_ does not contain a rest parameter, any binding
    patterns, or any initializers. It may contain duplicate identifiers.

2.  Let _len_ be the number of elements in _argumentsList_.

3.  Let _obj_ be a newly created arguments exotic object with a
    [[ParameterMap]] internal slot.

4.  Set the [[GetOwnProperty]] internal method of _obj_ as specified in
    9.4.4.1.

5.  Set the [[DefineOwnProperty]] internal method of _obj_ as specified
    in 0.

6.  Set the [[Get]] internal method of _obj_ as specified in 9.4.4.3.

7.  Set the [[Set]] internal method of _obj_ as specified in 0.

8.  Set the [[Delete]] internal method of _obj_ as specified in 9.4.4.5.

9.  Set the remainder of _obj_’s essential internal methods to the
    default ordinary object definitions specified in 9.1.

10. Set the [[Prototype]] internal slot of _obj_ to %ObjectPrototype%.

11. Set the [[Extensible]] internal slot of _obj_ to TRUE.

12. Let _parameterNames_ be the BoundNames of _formals_.

13. Let _numberOfParameters_ be the number of elements in
    _parameterNames_

14. Let _index_ be 0.

15. Repeat while _index_ < _len_ ,

    a.  Let _val_ be the element of _argumentsList_ at 0-origined list
        position _index_.

    b.  Perform CreateDataProperty(_obj_, ToString(_index_), _val_).

    c.  Let _index_ be _index_ + 1

16. Perform DefinePropertyOrThrow(_obj_, "LENGTH",
    PropertyDescriptor{[[Value]]: _len_, [[Writable]]: TRUE,
    [[Enumerable]]: FALSE, [[Configurable]]: TRUE}).

17. Let _map_ be ObjectCreate(NULL).

18. Let _mappedNames_ be an empty List.

19. Let _index_ be _numberOfParameters_ − 1.

20. Repeat while _index_ ≥ 0 ,

    a.  Let _name_ be the element of _parameterNames_ at 0-origined list
        position _index_.

    b.  If _name_ is not an element of _mappedNames_, then

        i.  Add _name_ as an element of the list _mappedNames_.

        ii. If _index_ < _len_, then

            1.  Let _g_ be MakeArgGetter(_name_, _env_).

            2.  Let _p_ be MakeArgSetter(_name_, _env_).

            3.  Call the [[DefineOwnProperty]] internal method of _map_
                passing ToString(_index_) and the
                PropertyDescriptor{[[Set]]: _p_, [[Get]]:
                _g,_[[Enumerable]]: FALSE, [[Configurable]]: TRUE} as
                arguments.

    c.  Let _index_ be _index_ − 1

21. Set the [[ParameterMap]] internal slot of _obj_ to _map_.

22. Perform DefinePropertyOrThrow(_obj_, @@iterator, PropertyDescriptor
    {[[Value]]:%ArrayProto_values%, [[Writable]]: TRUE, [[Enumerable]]:
    FALSE, [[Configurable]]: TRUE}).

23. Perform DefinePropertyOrThrow(_obj_, "CALLEE", PropertyDescriptor
    {[[Value]]: _func_, [[Writable]]: TRUE, [[Enumerable]]: FALSE,
    [[Configurable]]: TRUE}).

24. Assert: the above property definitions will not produce an abrupt
    completion.

25. Return _obj

MakeArgGetter ( name, env) Abstract Operation

The abstract operation MakeArgGetter called with String _name_ and
environment record _env_ creates a built-in function object that when
executed returns the value bound for _name_ in _env_. It performs the
following steps:

1.  Let _realm_ be the current Realm.

2.  Let _steps_ be the steps of a ArgGetter function as specified below.

3.  Let _getter_ be CreateBuiltinFunction(_realm_, _steps_,
    %FunctionPrototype%, ([[name]], [[env]]) ).

4.  Set _getter’s_ [[name]] internal slot to _name_.

5.  Set _getter’s_ [[env]] internal slot to _env_.

6.  Return _getter_.

An ArgGetter function is an anonymous built-in function with [[name]]
and [[env]] internal slots. When an ArgGetter function _f_ that expects
no arguments is called it performs the following steps:

1.  Let _name_ be the value of _f’s_ [[name]] internal slot.

2.  Let _env_ be the value of _f’s_ [[env]] internal slot

3.  Return the result of calling the GetBindingValue concrete method of
    _env_ with arguments _name_ and FALSE.

NOTE ArgGetter functions are never directly accessible to ECMAScript
code.

MakeArgSetter ( name, env) Abstract Operation

The abstract operation MakeArgSetter called with String _name_ and
environment record _env_ creates a built-in function object that when
executed sets the value bound for _name_ in _env_. It performs the
following steps:

1.  Let _realm_ be the current Realm.

2.  Let _steps_ be the steps of a ArgSetter function as specified below.

3.  Let _setter_ be CreateBuiltinFunction(_realm_, _steps_,
    %FunctionPrototype%, ([[name]], [[env]]) ).

4.  Set _setter’s_ [[name]] internal slot to _name_.

5.  Set _setter’s_ [[env]] internal slot to _env_.

6.  Return _setter_.

An ArgSetter function is an anonymous built-in function with [[name]]
and [[env]] internal slots. When an ArgSetter function _f_ is called
with argument _value_ it performs the following steps:

1.  Let _name_ be the value of _f’s_ [[name]] internal slot.

2.  Let _env_ be the value of _f’s_ [[env]] internal slot

3.  Return the result of calling the SetMutableBinding concrete method
    of _env_ with arguments _name_, _value_, and FALSE.

NOTE ArgSetter functions are never directly accessible to ECMAScript
code.

Integer Indexed Exotic Objects

An _Integer Indexed object_ is an exotic object that performs special
handling of integer index property keys.

Integer Indexed exotic objects have the same internal slots as ordinary
objects additionally [[ViewedArrayBuffer]], [[ArrayLength]],
[[ByteOffset]], and [[TypedArrayName]] internal slots.

Integer Indexed Exotic objects provide alternative definitions for the
following internal methods. All of the other Integer Indexed exotic
object essential internal methods that are not defined below are as
specified in 9.1.

[[GetOwnProperty]] ( P )

When the [[GetOwnProperty]] internal method of an Integer Indexed exotic
object _O_ is called with property key _P_ the following steps are
taken:

1.  Assert: IsPropertyKey(_P_) is TRUE.

2.  Assert: _O_ is an Object that has a [[ViewedArrayBuffer]] internal
    slot.

3.  If Type(_P_) is String, then

    a.  Let _numericIndex_ be CanonicalNumericIndexString(_P_).

    b.  Assert: _numericIndex_ is not an abrupt completion.

    c.  If _numericIndex_ is not UNDEFINED, then

        i.  Let _value_ be IntegerIndexedElementGet (_O_,
            _numericIndex_).

        ii. ReturnIfAbrupt(_value_).

        iii. If _value_ is UNDEFINED, then return UNDEFINED.

        iv. Return a PropertyDescriptor{ [[Value]]: _value_,
            [[Enumerable]]: TRUE, [[Writable]]: TRUE, [[Configurable]]:
            FALSE }.

4.  Return OrdinaryGetOwnProperty(_O_, _P_).

[[DefineOwnProperty]] ( P, Desc)

When the [[DefineOwnProperty]] internal method of an Integer Indexed
exotic object _O_ is called with property key _P_, and Property
Descriptor _Desc_ the following steps are taken:

1.  Assert: IsPropertyKey(_P_) is TRUE.

2.  Assert: _O_ is an Object that has a [[ViewedArrayBuffer]] internal
    slot.

3.  If Type(_P_) is String, then

    a.  b.  Let _numericIndex_ be CanonicalNumericIndexString (_P_).

    c.  Assert: _numericIndex_ is not an abrupt completion.

    d.  If _numericIndex_ is not UNDEFINED, then

        i.  If the value of _O_’s [[ViewedArrayBuffer]] is UNDEFINED,
            then throw a TYPEERROR exception.

    a.  i.  If IsInteger(_numericIndex_) is FALSE then return FALSE

        ii. Let _intIndex_ be _numericIndex_.

        i.  If _intIndex_ = −0, then return FALSE.

        ii. If _intIndex_ < 0, then return FALSE.

        iii. Let _length_ be the value of _O_’s [[ArrayLength]] internal
            slot.

        iv. If _intIndex_ ≥ _length_, then return FALSE.

        v.  If IsAccessorDescriptor(_Desc_) is TRUE, then return FALSE.

        vi. If _Desc_ has a [[Configurable]] field and if
            _Desc_.[[Configurable]] is TRUE, then return FALSE_._

        vii. If _Desc_ has an [[Enumerable]] field and if
            _Desc_.[[Enumerable]] is FALSE, then return FALSE_._

        viii. If _Desc_ has a [[Writable]] field and if
            _Desc_.[[Writable]] is FALSE, then return FALSE.

        ix. If _Desc_ has a [[Value]] field, then

            1.  Let _value_ be _Desc_.[[Value]].

            2.  Let _status_ be IntegerIndexedElementSet (_O_,
                _intIndex_, _value_).

            3.  ReturnIfAbrupt(_status_).

        x.  Return TRUE.

4.  Return OrdinaryDefineOwnProperty(_O_, _P, Desc_).

[[Get]] (P, Receiver)

When the [[Get]] internal method of an Integer Indexed exotic object _O_
is called with property key _P_ and ECMAScript language value _Receiver_
the following steps are taken:

1.  Assert: IsPropertyKey(_P_) is TRUE.

2.  If Type(_P_) is String and if SameValue(_O_, _Receiver_) is TRUE,
    then

    a.  Let _numericIndex_ be CanonicalNumericIndexString (_P_).

    b.  Assert: _numericIndex_ is not an abrupt completion.

    c.  If _numericIndex_ is not UNDEFINED, then

        i.  Return IntegerIndexedElementGet (_O_, _numericIndex_).

3.  Return the result of calling the default ordinary object [[Get]]
    internal method (9.1.8) on _O_ passing _P_ and _Receiver_ as
    arguments.

[[Set]] ( P, V, Receiver)

When the [[Set]] internal method of an Integer Indexed exotic object _O_
is called with property key _P_, value _V_, and ECMAScript language
value _Receiver_, the following steps are taken:

1.  Assert: IsPropertyKey(_P_) is TRUE.

2.  If Type(_P_) is String and if SameValue(_O_, _Receiver_) is TRUE,
    then

    a.  Let _numericIndex_ be CanonicalNumericIndexString (_P_).

    b.  Assert: _numericIndex_ is not an abrupt completion.

    c.  If _numericIndex_ is not UNDEFINED, then

        i.  Return ToBoolean(IntegerIndexedElementSet (_O_,
            _numericIndex_, _V_)).

3.  Return the result of calling the default ordinary object [[Set]]
    internal method (9.1.8) on _O_ passing _P_, _V_, and _Receiver_ as
    arguments.

[[Enumerate]] ()

When the [[Enumerate]] internal method of an Integer Indexed exotic
object _O_ is called the following steps are taken:

1.  Let _indexKeys_ be a new empty List.

2.  Assert: _O_ is an Object that has [[ViewedArrayBuffer]],
    [[ArrayLength]], [[ByteOffset]], and [[TypedArrayName]] internal
    slots.

3.  4.  If the value of _O_’s [[ViewedArrayBuffer]] is UNDEFINED, then
    throw a TYPEERROR exception.

5.  Let _len_ be the value of _O_’s [[ArrayLength]] internal slot.

6.  For each integer _i_ starting with 0 such that _i_ < _len_, in
    ascending order,

    a.  Add ToString(_i_) as the last element of _indexKeys_.

7.  Let _ordinary_ be the result of calling the default ordinary object
    [[Enumerate]] internal method (9.1.11) on _O_.

8.  ReturnIfAbrupt(_ordinary_).

9.  Return CreateCompoundIterator(CreateListIterator(_indexKeys_),
    _ordinary_)_._

10. 

[[OwnPropertyKeys]] ()

When the [[OwnPropertyKeys]] internal method of an Integer Indexed
exotic object _O_ is called the following steps are taken:

1.  Let _keys_ be a new empty List.

2.  Assert: _O_ is an Object that has [[ViewedArrayBuffer]],
    [[ArrayLength]], [[ByteOffset]], and [[TypedArrayName]] internal
    slots.

3.  4.  If the value of _O_’s [[ViewedArrayBuffer]] is UNDEFINED, then
    throw a TYPEERROR exception.

5.  Let _len_ be the value of _O_’s [[ArrayLength]] internal slot.

6.  For each integer _i_ starting with 0 such that _i_ < _len_, in
    ascending order,

    a.  Add ToString(_i_) as the last element of _keys_.

7.  For each own property key _P_ of _O_ such that _P_ is an integer
    index and ToInteger(_P_) ≥ _len_, in ascending numeric index order

    a.  Add _P_ as the last element of _keys_.

8.  For each own property key _P_ of _O_ such that Type(_P_) is String
    and _P_ is not an integer index, in property creation order

    a.  Add _P_ as the last element of _keys_.

9.  For each own property key _P_ of _O_ such that Type(_P_) is Symbol,
    in property creation order

    a.  Add _P_ as the last element of _keys_.

10. Return CreateArrayFromList(_keys_).

IntegerIndexedObjectCreate (prototype, internalSlotsList) Abstract Operation

The abstract operation IntegerIndexedObjectCreate with arguments
_prototype_ and _internalSlotsList_ is used to specify the creation of
new Integer Indexed exotic objects. The argument _internalSlotsList_ is
a List of the names of additional internal slots that must be defined as
part of the object. IntegerIndexedObjectCreate performs the following
steps:

1.  Let _A_ be a newly created object with an internal slot for each
    name in _internalSlotsList_.

2.  Set _A_’s essential internal methods to the default ordinary object
    definitions specified in 9.1.

3.  Set the [[GetOwnProperty]] internal method of _A_ as specified in
    9.4.5.1.

4.  Set the [[DefineOwnProperty]] internal method of _A_ as specified in
    9.4.5.2.

5.  Set the [[Get]] internal method of _A_ as specified in 9.4.5.3.

6.  Set the [[Set]] internal method of _A_ as specified in 9.4.5.4.

7.  Set the [[Enumerate]] internal method of _A_ as specified in
    9.4.5.5.

8.  Set the [[OwnPropertyKeys]] internal method of _A_ as specified in
    9.4.5.6.

9.  Set the [[Prototype]] internal slot of _A_ to _prototype_.

10. Set the [[Extensible]] internal slot of _A_ to TRUE.

11. Return _A_.

IntegerIndexedElementGet ( O, index ) Abstract Operation

The abstract operation IntegerIndexedElementGet with arguments _O_ and
_index_ performs the following steps:

1.  Assert: Type(_index_) is Number.

2.  Assert: _O_ is an Object that has [[ViewedArrayBuffer]],
    [[ArrayLength]], [[ByteOffset]], and [[TypedArrayName]] internal
    slots.

3.  Let _buffer_ be the value of _O_’s [[ViewedArrayBuffer]] internal
    slot.

4.  If _buffer_ is UNDEFINED, then throw a TYPEERROR exception.

5.  If IsNeuteredBuffer(_buffer_) is TRUE, then throw a TYPEERROR
    exception.

6.  If IsInteger(_index_) is FALSE then return UNDEFINED

7.  If _index_ = −0, then return UNDEFINED.

8.  Let _length_ be the value of _O_’s [[ArrayLength]] internal slot.

9.  If _index_ < 0 or _index_ ≥ _length_, then return UNDEFINED.

10. Let _offset_ be the value of _O_’s [[ByteOffset]] internal slot.

11. Let _arrayTypeName_ be the string value of _O_’s [[TypedArrayName]]
    internal slot.

12. Let _elementSize_ be the Number value of the Element Size value
    specified in Table 45 for _arrayTypeName_.

13. Let _indexedPosition_ = (_index_ × _elementSize_) + _offset_.

14. Let _elementType_ be the string value of the Element Type value in
    Table 45 for _arrayTypeName_.

15. Return GetValueFromBuffer(_buffer_, _indexedPosition_,
    _elementType_).

IntegerIndexedElementSet ( O, index, value ) Abstract Operation

The abstract operation IntegerIndexedElementSet with arguments _O_,
_index_, and _value_ performs the following steps:

1.  Assert: Type(_index_) is Number.

2.  Assert: _O_ is an Object that has [[ViewedArrayBuffer]],
    [[ArrayLength]], [[ByteOffset]], and [[TypedArrayName]] internal
    slots.

3.  Let _numValue_ be ToNumber(_value)_.

4.  ReturnIfAbrupt(_numValue_).

5.  Let _buffer_ be the value of _O_’s [[ViewedArrayBuffer]] internal
    slot.

6.  If _buffer_ is UNDEFINED, then throw a TYPEERROR exception.

7.  If IsNeuteredBuffer(_buffer_) is TRUE, then throw a TYPEERROR
    exception.

8.  If IsInteger(_index_) is FALSE then return FALSE

9.  If _index_ = −0, then return FALSE.

10. 11. Let _length_ be the value of _O_’s [[ArrayLength]] internal
    slot.

12. 13. 14. If _index_ < 0 or _index_ ≥ _length_, then return FALSE.

15. Let _offset_ be the value of _O_’s [[ByteOffset]] internal slot.

16. Let _arrayTypeName_ be the string value of _O_’s [[TypedArrayName]]
    internal slot.

17. Let _elementSize_ be the Number value of the Element Size value
    specified in Table 45 for _arrayTypeName_.

18. Let _indexedPosition_ = (_index_ × _elementSize_) + _offset_.

19. Let _elementType_ be the string value of the Element Type value in
    Table 45 for _arrayTypeName_.

20. Let _status_ be SetValueInBuffer(_buffer_, _indexedPosition_,
    _elementType_, _numValue_).

21. ReturnIfAbrupt(_status_).

22. Return TRUE.

Module Exotic Objects

A _module object_ is an exotic object that exposes the bindings exported
from an ECMAScript _Module_ (See 15.1.9). There is a one-to-one
correspondence between the own properties of a module exotic object and
the ExportedBindings of the _Module_. Each own property name is the
StringValue of the corresponding exported binding. These are the only
properties of a module exotic object. Each such property has the
attributes {[[Configurable]]: FALSE, [[Enumerable]]: TRUE}. Module
objects are not extensible.

Module objects have the internal slots defined in Table 28.

Table 28 — Internal Slots of Module Exotic Objects

  _INTERNAL SLOT_         _TYPE_           _DESCRIPTION_
  ----------------------- ---------------- ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  [[ModuleEnvironment]]   Environment      The Declarative Environment Record that contains all of the declared top-level bindings for the corresponding module.
  [[Exports]]             List of String   A List containing the bound names exposed as own properties of this object. The list is ordered as if an Array of the same values had been sorted using ARRAY.PROTOTYPE.SORT using SortCompare as _comparefn._
                                           

Module exotic objects provide alternative definitions for all of the
internal methods.

[[GetPrototypeOf]] ( )

When the [[GetPrototypeOf]] internal method of a module exotic object
_O_ is called the following steps are taken:

1.  Return NULL.

[[SetPrototypeOf]] (V)

When the [[SetPrototypeOf]] internal method of a module exotic object
_O_ is called with argument _V_ the following steps are taken:

1.  Assert: Either Type(_V_) is Object or Type(_V_) is Null.

2.  Return FALSE.

[[IsExtensible]] ( )

When the [[IsExtensible]] internal method of a module exotic object _O_
is called the following steps are taken:

1.  Return FALSE.

[[PreventExtensions]] ( )

When the [[PreventExtensions]] internal method of a module exotic object
_O_ is called the following steps are taken:

1.  Return TRUE.

[[GetOwnProperty]] (P)

When the [[GetOwnProperty]] internal method of a module exotic object
_O_ is called with property key _P_, the following steps are taken:

1.  Throw a TYPEERROR exception.

[[DefineOwnProperty]] (P, Desc)

When the [[DefineOwnProperty]] internal method of a module exotic object
_O_ is called with property key _P_ and Property Descriptor _Desc_, the
following steps are taken:

1.  Return FALSE.

[[HasProperty]] (P)

When the [[HasProperty]] internal method of a module exotic object _O_
is called with property key _P_, the following steps are taken:

1.  Let _exports_ be the value of _O_’s [[Exports]] internal slot.

2.  If _P_ is an element of _exports_, then return TRUE.

3.  Return FALSE.

 [[Get]] (P, Receiver)

When the [[Get]] internal method of a module exotic object _O_ is called
with property key _P_ and ECMAScript language value _Receiver_ the
following steps are taken:

1.  Assert: IsPropertyKey(_P_) is TRUE.

2.  Let _exports_ be the value of _O_’s [[Exports]] internal slot.

3.  If _P_ is not an element of _exports_, then return UNDEFINED.

4.  Let _env_ be the value of _O_’s [[ModuleEnvironment]] internal slot.

5.  Return the result of calling the GetBindingValue concrete method of
    _env_ with arguments _P_ and TRUE.

NOTE Attempting to [[Get]] the value of a module export that has not yet
been initialized will throw a ReferenceError exception.

[[Set]] ( P, V, Receiver)

When the [[Set]] internal method of a module exotic object _O_ is called
with property key _P_, value _V_, and ECMAScript language value
_Receiver_, the following steps are taken:

1.  Return FALSE.

[[Delete]] (P)

When the [[Delete]] internal method of a module exotic object _O_ is
called with property key _P_ the following steps are taken:

1.  Assert: IsPropertyKey(_P_) is TRUE.

2.  Let _exports_ be the value of _O_’s [[Exports]] internal slot.

3.  If _P_ is an element of _exports_, then return FALSE.

4.  Return TRUE.

[[Enumerate]] ()

When the [[Enumerate]] internal method of a module exotic object _O_ is
called the following steps are taken:

1.  Let _exports_ be the value of _O_’s [[Exports]] internal slot.

2.  Return CreateListIterator(_exports_).

[[OwnPropertyKeys]] ( )

When the [[OwnPropertyKeys]] internal method of a module exotic object
_O_ is called the following steps are taken:

1.  Let _exports_ be the value of _O_’s [[Exports]] internal slot.

2.  Return CreateArrayFromList (_exports_).

ModuleObjectCreate (environment, exports)

1.  Assert: _environment_ is a Declarative Environment Record.

2.  Assert: _exports_ is a List of string values.

3.  Let _M_ be a newly created object.

4.  Set _M_’s essential internal methods to the definitions specified in
    9.4.6.

5.  Set _M_’s [[ModuleEnvironment]] internal slot to _environment_.

6.  Set _M_’s [[Exports]] internal slot to _exports_.

7.  Return _M_.


Proxy Object Internal Methods and Internal Slots

A proxy object is an exotic object whose essential internal methods are
partially implemented using ECMAScript code. Every proxy objects has an
internal slot called [[ProxyHandler]]. The value of [[ProxyHandler]] is
always an object, called the proxy’s _handler object_. Methods (see
Table 29) of a handler object may be used to augment the implementation
for one or more of the proxy object’s internal methods. Every proxy
object also has an internal slot called [[ProxyTarget]] whose value is
either an object or the NULL value. This object is called the proxy’s
_target object_.

Table 29 — Proxy Handler Methods

  _INTERNAL METHOD_       _HANDLER METHOD_
  ----------------------- --------------------------
  [[GetPrototypeOf]]      GETPROTOTYPEOF
  [[SetPrototypeOf]]      SETPROTOTYPEOF
  [[IsExtensible]]        ISEXTENSIBLE
  [[PreventExtensions]]   PREVENTEXTENSIONS
  [[GetOwnProperty]]      GETOWNPROPERTYDESCRIPTOR
  [[HasProperty]]         HAS
  [[Get]]                 GET
  [[Set]]                 SET
  [[Delete]]              DELETEPROPERTY
  [[DefineOwnProperty]]   DEFINEPROPERTY
  [[Enumerate]]           ENUMERATE
  [[OwnPropertyKeys]]     OWNKEYS
  [[Call]]                APPLY
  [[Construct]]           CONSTRUCT

When a handler method is called to provide the implementation of a proxy
object internal method, the handler method is passed the proxy’s target
object as a parameter. A proxy’s handler object does not necessarily
have a method corresponding to every essential internal method. Invoking
an internal method on the proxy results in the invocation of the
corresponding internal method on the proxy’s target object if the
handler object does not have a method corresponding to the internal
trap.

The [[ProxyHandler]] and [[ProxyTarget]] internal slots of a proxy
object are always initialized when the object is created and typically
may not be modified. Some proxy objects are created in a manner that
permits them to be subsequently _revoked_. When a proxy is revoked, its
[[ProxyHander]] and [[ProxyTarget]] internal slots are set to NULL
causing subsequent invocations of internal methods on that proxy obeject
to throw a TYPEERROR exception.

Because proxy permit arbitrary ECMAScript code to be used to in the
implementation of internal methods, it is possible to define a proxy
object whose handler methods violates the invariants defined in 6.1.7.3.
Some of the internal method invariants defined in 6.1.7.3 are essential
integrity invariants. These invariants are explicitly enforced by the
proxy internal methods specified in this section. An ECMAScript
implementation must be robust in the presence of all possible invariant
violations.

In the following algorithm descriptions, assume _O_ is an ECMAScript
proxy object, _P_ is a property key value, _V_ is any ECMAScript
language value, Desc is a Property Descriptor record, and _B_ is a
Boolean flag.

[[GetPrototypeOf]] ( )

When the [[GetPrototypeOf]] internal method of an exotic Proxy object
_O_ is called the following steps are taken:

1.  Let _handler_ be the value of the [[ProxyHandler]] internal slot of
    _O_.

2.  If _handler_ is NULL, then throw a TYPEERROR exception.

3.  Let _target_ be the value of the [[ProxyTarget]] internal slot of
    _O_.

4.  Let _trap_ be GetMethod(_handler_, "GETPROTOTYPEOF").

5.  ReturnIfAbrupt(_trap_).

6.  If _trap_ is UNDEFINED, then

    a.  Return the result of calling the [[GetPrototypeOf]] internal
        method of _target_.

7.  Let _handlerProto_ be the result of calling the [[Call]] internal
    method of _trap_ with _handler_ as the THIS value and a new List
    containing _target_.

8.  ReturnIfAbrupt(_handlerProto_).

9.  If Type(_handlerProto_) is neither Object nor Null, then throw a
    TYPEERROR exception.

10. Let _extensibleTarget_ be IsExtensible(_target_).

11. ReturnIfAbrupt(_extensibleTarget_).

12. If _extensibleTarget_ is TRUE, then return _handlerProto_.

13. Let _targetProto_ be the result of calling the [[GetPrototypeOf]]
    internal method of _target_.

14. ReturnIfAbrupt(_targetProto_).

15. If SameValue(_handlerProto_, _targetProto_) is FALSE, then throw a
    TYPEERROR exception.

16. Return _handlerProto_.

NOTE [[GetPrototypeOf]] for proxy objects enforces the following
invariant:

-   The result of [[GetPrototypeOf]] must be either an Object or NULL.

-   If the target object is not extensible, [[GetPrototypeOf]] applied
    to the proxy object must return the same value as [[GetPrototypeOf]
    applied to the proxy object’s target object.

[[SetPrototypeOf]] (V)

When the [[SetPrototypeOf]] internal method of an exotic Proxy object
_O_ is called with argument _V_ the following steps are taken:

1.  Assert: Either Type(_V_) is Object or Type(_V_) is Null.

2.  Let _handler_ be the value of the [[ProxyHandler]] internal slot of
    _O_.

3.  If _handler_ is NULL, then throw a TYPEERROR exception.

4.  Let _target_ be the value of the [[ProxyTarget]] internal slot of
    _O_.

5.  Let _trap_ be GetMethod(_handler_, "SETPROTOTYPEOF").

6.  ReturnIfAbrupt(_trap_).

7.  If _trap_ is UNDEFINED, then

    a.  Return the result of calling the [[SetPrototypeOf]] internal
        method of _target_ with argument _V_.

8.  Let _trapResult_ be the result of calling the [[Call]] internal
    method of _trap_ with _handler_ as the THIS value and a new List
    containing _target_ and _V_.

9.  Let _booleanTrapResult_ be ToBoolean(_trapResult_).

10. ReturnIfAbrupt(_booleanTrapResult_).

11. Let _extensibleTarget_ be IsExtensible(_target_).

12. ReturnIfAbrupt(_extensibleTarget_).

13. If _extensibleTarget_ is TRUE, then return _booleanTrapResult_.

14. Let _targetProto_ be the result of calling the [[GetPrototypeOf]]
    internal method of _target_.

15. ReturnIfAbrupt(_targetProto_).

16. If _booleanTrapResult_ is TRUE and SameValue(_V_, _targetProto_) is
    FALSE, then throw a TYPEERROR exception.

17. Return _booleanTrapResult_.

NOTE [[SetPrototypeOf]] for proxy objects enforces the following
invariant:

-   If the target object is not extensible, the argument value must be
    the same as the result of [[GetPrototypeOf]] applied to target
    object.

[[IsExtensible]] ( )

When the [[IsExtensible]] internal method of an exotic Proxy object _O_
is called the following steps are taken:

1.  Let _handler_ be the value of the [[ProxyHandler]] internal slot of
    _O_.

2.  If _handler_ is NULL, then throw a TYPEERROR exception.

3.  Let _target_ be the value of the [[ProxyTarget]] internal slot of
    _O_.

4.  Let _trap_ be GetMethod(_handler_, "ISEXTENSIBLE").

5.  ReturnIfAbrupt(_trap_).

6.  If _trap_ is UNDEFINED, then

    a.  Return the result of calling the [[IsExtensible]] internal
        method of _target_.

7.  Let _trapResult_ be the result of calling the [[Call]] internal
    method of _trap_ with _handler_ as the THIS value and a new List
    containing _target_.

8.  Let _booleanTrapResult_ be ToBoolean(_trapResult_).

9.  ReturnIfAbrupt(_booleanTrapResult_).

10. Let _targetResult_ be the result of calling the [[IsExtensible]]
    internal method of _target_.

11. ReturnIfAbrupt(_targetResult_).

12. If SameValue(_booleanTrapResult_, _targetResult_) is FALSE, then
    throw a TYPEERROR exception.

13. Return _booleanTrapResult_.

NOTE [[IsExtensible]] for proxy objects enforces the following
invariant:

-   [[IsExtensible]] applied to the proxy object must return the same
    value as [[IsExtensible]] applied to the proxy object’s target
    object with the same argument.

[[PreventExtensions]] ( )

When the [[PreventExtensions]] internal method of an exotic Proxy object
_O_ is called the following steps are taken:

1.  Let _handler_ be the value of the [[ProxyHandler]] internal slot of
    _O_.

2.  If _handler_ is NULL, then throw a TYPEERROR exception.

3.  Let _target_ be the value of the [[ProxyTarget]] internal slot of
    _O_.

4.  Let _trap_ be GetMethod(_handler_, "PREVENTEXTENSIONS").

5.  ReturnIfAbrupt(_trap_).

6.  If _trap_ is UNDEFINED, then

    a.  Return the result of calling the [[PreventExtensions]] internal
        method of _target_.

7.  Let _trapResult_ be the result of calling the [[Call]] internal
    method of _trap_ with _handler_ as the THIS value and a new List
    containing _target_.

8.  Let _booleanTrapResult_ be ToBoolean(_trapResult_)

9.  ReturnIfAbrupt(_booleanTrapResult_).

10. If _booleanTrapResult_ is TRUE, then

    a.  Let _targetIsExtensible_ be the result of calling the
        [[IsExtensible]] internal method of _target_.

    b.  ReturnIfAbrupt(_targetIsExtensible_).

    c.  If _targetIsExtensible_ is TRUE, then throw a TYPEERROR
        exception.

11. Return _booleanTrapResult_.

NOTE [[PreventExtensions]] for proxy objects enforces the following
invariant:

-   [[PreventExtensions]] applied to the proxy object only returns TRUE
    if [[IsExtensible]] applied to the proxy object’s target object is
    FALSE.

 [[GetOwnProperty]] (P)

When the [[GetOwnProperty]] internal method of an exotic Proxy object
_O_ is called with property key _P_, the following steps are taken:

1.  Assert: IsPropertyKey(_P_) is TRUE.

2.  Let _handler_ be the value of the [[ProxyHandler]] internal slot of
    _O_.

3.  If _handler_ is NULL, then throw a TYPEERROR exception.

4.  Let _target_ be the value of the [[ProxyTarget]] internal slot of
    _O_.

5.  Let _trap_ be GetMethod(_handler_, "GETOWNPROPERTYDESCRIPTOR").

6.  ReturnIfAbrupt(_trap_).

7.  If _trap_ is UNDEFINED, then

    a.  Return the result of calling the [[GetOwnProperty]] internal
        method of _target_ with argument _P_.

8.  Let _trapResultObj_ be the result of calling the [[Call]] internal
    method of _trap_ with _handler_ as the THIS value and a new List
    containing _target_ and _P_.

9.  ReturnIfAbrupt(_trapResultObj_).

10. If Type(_trapResultObj_) is neither Object nor Undefined, then throw
    a TYPEERROR exception.

11. Let _targetDesc_ be the result of calling the [[GetOwnProperty]]
    internal method of _target_ with argument _P_.

12. ReturnIfAbrupt(_targetDesc_).

13. If _trapResultObj_ is UNDEFINED, then

    a.  If _targetDesc_ is UNDEFINED, then return UNDEFINED.

    b.  If _targetDesc_.[[Configurable]] is FALSE, then throw a
        TYPEERROR exception.

    c.  Let _extensibleTarget_ be IsExtensible(_target_).

    d.  ReturnIfAbrupt(_extensibleTarget_).

    e.  If ToBoolean(_extensibleTarget_) is FALSE, then throw a
        TYPEERROR exception.

    f.  Return UNDEFINED.

14. Let _extensibleTarget_ be IsExtensible(_target_).

15. ReturnIfAbrupt(_extensibleTarget_).

16. Let _resultDesc_ be ToPropertyDescriptor(_trapResultObj_).

17. ReturnIfAbrupt(_resultDesc_).

18. Call CompletePropertyDescriptor(_resultDesc_).

19. Let _valid_ be IsCompatiblePropertyDescriptor (_extensibleTarget_,
    _resultDesc_, _targetDesc_).

20. If _valid_ is FALSE, then throw a TYPEERROR exception.

21. If _resultDesc_.[[Configurable]] is FALSE, then

    a.  If _targetDesc_ is UNDEFINED or _targetDesc_.[[Configurable]] is
        TRUE_,_ then

        i.  Throw a TYPEERROR exception.

22. Return _resultDesc_.

NOTE [[GetOwnProperty]] for proxy objects enforces the following
invariants:

-   The result of [[GetOwnProperty]] must be either an Object or
    UNDEFINED.

-   A property cannot be reported as non-existent, if it exists as a
    non-configurable own property of the target object.

-   A property cannot be reported as non-existent, if it exists as an
    own property of the target object and the target object is not
    extensible.

-   A property cannot be reported as existent, if it does not exists as
    an own property of the target object and the target object is not
    extensible.

-   A property cannot be reported as non-configurable, if it does not
    exists as an own property of the target object or if it exists as a
    configurable own property of the target object.

-   The result of [[GetOwnProperty]] can be applied to the target object
    using [[DefineOwnProperty]] and will not throw an exception.

[[DefineOwnProperty]] (P, Desc)

When the [[DefineOwnProperty]] internal method of an exotic Proxy object
_O_ is called with property key _P_ and Property Descriptor _Desc_, the
following steps are taken:

1.  Assert: IsPropertyKey(_P_) is TRUE.

2.  Let _handler_ be the value of the [[ProxyHandler]] internal slot of
    _O_.

3.  If _handler_ is NULL, then throw a TYPEERROR exception.

4.  Let _target_ be the value of the [[ProxyTarget]] internal slot of
    _O_.

5.  Let _trap_ be GetMethod(_handler_, "DEFINEPROPERTY").

6.  ReturnIfAbrupt(_trap_).

7.  If _trap_ is UNDEFINED, then

    a.  Return the result of calling the [[DefineOwnProperty]] internal
        method of _target_ with arguments _P_ and _Desc_.

8.  Let _descObj_ be FromPropertyDescriptor(_Desc_).

9.  NOTE If _Desc_ was originally generated from an object using
    ToPropertyDescriptor, then _descObj_ will be that original object.

10. Let _trapResult_ be the result of calling the [[Call]] internal
    method of _trap_ with _handler_ as the THIS value and a new List
    containing _target_, _P_, and _descObj_.

11. Let _booleanTrapResult_ be ToBoolean(_trapResult_).

12. ReturnIfAbrupt(_booleanTrapResult_).

13. If _booleanTrapResult_ is FALSE, then return FALSE.

14. Let _targetDesc_ be the result of calling the [[GetOwnProperty]]
    internal method of _target_ with argument _P_.

15. ReturnIfAbrupt(_targetDesc_).

16. Let _extensibleTarget_ be IsExtensible(_target_).

17. ReturnIfAbrupt(_extensibleTarget_).

18. If _Desc_ has a [[Configurable]] field and if
    _Desc_.[[Configurable]] is FALSE, then

    a.  Let _settingConfigFalse_ be TRUE.

19. Else let _settingConfigFalse_ be FALSE.

20. If _targetDesc_ is UNDEFINED, then

    a.  If _extensibleTarget_ is FALSE, then throw a TYPEERROR
        exception.

    b.  If _settingConfigFalse_ is TRUE, then throw a TYPEERROR
        exception.

21. Else _targetDesc_ is not UNDEFINED_,

    a.  If IsCompatiblePropertyDescriptor(_extensibleTarget_, _Desc_ ,
        _targetDesc_) is FALSE, then throw a TYPEERROR exception.

    b.  If _settingConfigFalse_ is TRUE and
        _targetDesc_.[[Configurable]] is TRUE, then throw a TYPEERROR
        exception.

22. Return TRUE.

NOTE [[DefineOwnProperty]] for proxy objects enforces the following
invariants:

-   A property cannot be added, if the target object is not extensible.

-   A property cannot be added as or modified to be non-configurable, if
    it does not exists as a non-configurable own property of the target
    object.

-   A property may not be non-configurable, if is corresponding
    configurable property of the target object exists.

-   If a property has a corresponding target object property then apply
    the Property Descriptor of the property to the target object using
    [[DefineOwnProperty]] will not throw an exception.

[[HasProperty]] (P)

When the [[HasProperty]] internal method of an exotic Proxy object _O_
is called with property key _P_, the following steps are taken:

1.  Assert: IsPropertyKey(_P_) is TRUE.

2.  Let _handler_ be the value of the [[ProxyHandler]] internal slot of
    _O_.

3.  If _handler_ is NULL, then throw a TYPEERROR exception.

4.  Let _target_ be the value of the [[ProxyTarget]] internal slot of
    _O_.

5.  Let _trap_ be GetMethod(_handler_, "HAS").

6.  ReturnIfAbrupt(_trap_).

7.  If _trap_ is UNDEFINED, then

    a.  Return the result of calling the [[HasProperty]] internal method
        of _target_ with argument _P_.

8.  Let _trapResult_ be the result of calling the [[Call]] internal
    method of _trap_ with _handler_ as the THIS value and a new List
    containing _target_ and _P_.

9.  Let _booleanTrapResult_ be ToBoolean(_trapResult_).

10. ReturnIfAbrupt(_booleanTrapResult_).

11. If _booleanTrapResult_ is FALSE, then

    a.  Let _targetDesc_ be the result of calling the [[GetOwnProperty]]
        internal method of _target_ with argument _P_.

    b.  ReturnIfAbrupt(_targetDesc_).

    c.  If _targetDesc_ is not UNDEFINED, then

        i.  If _targetDesc_.[[Configurable]] is FALSE, then throw a
            TYPEERROR exception.

        ii. Let _extensibleTarget_ be IsExtensible(_target_).

        iii. ReturnIfAbrupt(_extensibleTarget_).

        iv. If _extensibleTarget_ is FALSE, then throw a TYPEERROR
            exception.

12. Return _booleanTrapResult_.

NOTE [[HasProperty]] for proxy objects enforces the following
invariants:

-   A property cannot be reported as non-existent, if it exists as a
    non-configurable own property of the target object.

-   A property cannot be reported as non-existent, if it exists as an
    own property of the target object and the target object is not
    extensible.

[[Get]] (P, Receiver)

When the [[Get]] internal method of an exotic Proxy object _O_ is called
with property key _P_ and ECMAScript language value _Receiver_ the
following steps are taken:

1.  Assert: IsPropertyKey(_P_) is TRUE.

2.  Let _handler_ be the value of the [[ProxyHandler]] internal slot of
    _O_.

3.  If _handler_ is NULL, then throw a TYPEERROR exception.

4.  Let _target_ be the value of the [[ProxyTarget]] internal slot of
    _O_.

5.  Let _trap_ be GetMethod(_handler_, "GET").

6.  ReturnIfAbrupt(_trap_).

7.  If _trap_ is UNDEFINED, then

    a.  Return the result of calling the [[Get]] internal method of
        _target_ with arguments _P_ and _Receiver_.

8.  Let _trapResult_ be the result of calling the [[Call]] internal
    method of _trap_ with _handler_ as the THIS value and a new List
    containing _target_, _P_, and _Receiver_.

9.  ReturnIfAbrupt(_trapResult_).

10. Let _targetDesc_ be the result of calling the [[GetOwnProperty]]
    internal method of _target_ with argument _P_.

11. ReturnIfAbrupt(_targetDesc_).

12. If _targetDesc_ is not UNDEFINED, then

    a.  If IsDataDescriptor(_targetDesc_) and
        _targetDesc_.[[Configurable]] is FALSE and
        _targetDesc_.[[Writable]] is FALSE, then

        i.  If SameValue(_trapResult_, _targetDesc_.[[Value]]) is FALSE,
            then throw a TYPEERROR exception.

    b.  If IsAccessorDescriptor(_targetDesc_) and
        _targetDesc_.[[Configurable]] is FALSE and _targetDesc_.[[Get]]
        is UNDEFINED, then

        i.  If _trapResult_ is not UNDEFINED, then throw a TYPEERROR
            exception.

13. Return _trapResult_.

NOTE [[Get]] for proxy objects enforces the following invariants:

-   The value reported for a property must be the same as the value of
    the corresponding target object property if the target object
    property is a non-writable, non-configurable data property.

-   The value reported for a property must be UNDEFINED if the
    corresponding corresponding target object property is
    non-configurable accessor property that has UNDEFINED as its [[Get]]
    attribute.

[[Set]] ( P, V, Receiver)

When the [[Set]] internal method of an exotic Proxy object _O_ is called
with property key _P_, value _V_, and ECMAScript language value
_Receiver_, the following steps are taken:

1.  Assert: IsPropertyKey(_P_) is TRUE.

2.  Let _handler_ be the value of the [[ProxyHandler]] internal slot of
    _O_.

3.  If _handler_ is NULL, then throw a TYPEERROR exception.

4.  Let _target_ be the value of the [[ProxyTarget]] internal slot of
    _O_.

5.  Let _trap_ be GetMethod(_handler_, "SET").

6.  ReturnIfAbrupt(_trap_).

7.  If _trap_ is UNDEFINED, then

    a.  Return the result of calling the [[Set]] internal method of
        _target_ with arguments _P_, _V_, and _Receiver_.

8.  Let _trapResult_ be the result of calling the [[Call]] internal
    method of _trap_ with _handler_ as the THIS value and a new List
    containing _target_, _P_, _V_, and _Receiver_.

9.  Let _booleanTrapResult_ be ToBoolean(_trapResult_).

10. ReturnIfAbrupt(_booleanTrapResult_).

11. If _booleanTrapResult_ is FALSE, then return FALSE.

12. Let _targetDesc_ be the result of calling the [[GetOwnProperty]]
    internal method of _target_ with argument _P_.

13. ReturnIfAbrupt(_targetDesc_).

14. If _targetDesc_ is not UNDEFINED, then

    a.  If IsDataDescriptor(_targetDesc_) and
        _targetDesc_.[[Configurable]] is FALSE and
        _targetDesc_.[[Writable]] is FALSE, then

        i.  If SameValue(_V_, _targetDesc_.[[Value]]) is FALSE, then
            throw a TYPEERROR exception.

    b.  If IsAccessorDescriptor(_targetDesc_) and
        _targetDesc_.[[Configurable]] is FALSE, then

        i.  If _targetDesc_.[[Set]] is UNDEFINED, then throw a TYPEERROR
            exception.

15. Return TRUE.

NOTE [[Set]] for proxy objects enforces the following invariants:

-   Cannnot change the value of a property to be different from the
    value of the corresponding target object property if the
    corresponding target object property is a non-writable,
    non-configurable data property.

-   Cannot set the value of a property if the corresponding
    corresponding target object property is a non-configurable accessor
    property that has UNDEFINED as its [[Set]] attribute.

 [[Delete]] (P)

When the [[Delete]] internal method of an exotic Proxy object _O_ is
called with property name _P_ the following steps are taken:

1.  Assert: IsPropertyKey(_P_) is TRUE.

2.  Let _handler_ be the value of the [[ProxyHandler]] internal slot of
    _O_.

3.  If _handler_ is NULL, then throw a TYPEERROR exception.

4.  Let _target_ be the value of the [[ProxyTarget]] internal slot of
    _O_.

5.  Let _trap_ be GetMethod(_handler_, "DELETEPROPERTY").

6.  ReturnIfAbrupt(_trap_).

7.  If _trap_ is UNDEFINED, then

    a.  Return the result of calling the [[Delete]] internal method of
        _target_ with argument _P_.

8.  Let _trapResult_ be the result of calling the [[Call]] internal
    method of _trap_ with _handler_ as the THIS value and a new List
    containing _target_ and _P_.

9.  Let _booleanTrapResult_ be ToBoolean(_trapResult_).

10. ReturnIfAbrupt(_booleanTrapResult_).

11. If _booleanTrapResult_ is FALSE, then return FALSE.

12. Let _targetDesc_ be the result of calling the [[GetOwnProperty]]
    internal method of _target_ with argument _P_.

13. ReturnIfAbrupt(_targetDesc_).

14. If _targetDesc_ is UNDEFINED, then return TRUE.

15. If _targetDesc_.[[Configurable]] is FALSE, then throw a TYPEERROR
    exception.

16. Return TRUE.

NOTE [[Delete]] for proxy objects enforces the following invariant:

-   A property cannot be deleted, if it exists as a non-configurable own
    property of the target object.

[[Enumerate]] ()

When the [[Enumerate]] internal method of an exotic Proxy object _O_ is
called the following steps are taken:

1.  Let _handler_ be the value of the [[ProxyHandler]] internal slot of
    _O_.

2.  If _handler_ is NULL, then throw a TYPEERROR exception.

3.  Let _target_ be the value of the [[ProxyTarget]] internal slot of
    _O_.

4.  Let _trap_ be GetMethod(_handler_, "ENUMERATE").

5.  ReturnIfAbrupt(_trap_).

6.  If _trap_ is UNDEFINED, then

    a.  Return the result of calling the [[Enumerate]] internal method
        of _target_.

7.  Let _trapResult_ be the result of calling the [[Call]] internal
    method of _trap_ with _handler_ as the THIS value and a new List
    containing _target_.

8.  ReturnIfAbrupt(_trapResult_).

9.  If Type(_trapResult_) is not Object, then throw a TYPEERROR
    exception.

10. Return _trapResult_.

NOTE [[Enumerate]] for proxy objects enforces the following invariants:

-   The result of [[Enumerate]] must be an Object.

[[OwnPropertyKeys]] ( )

When the [[OwnPropertyKeys]] internal method of an exotic Proxy object
_O_ is called the following steps are taken:

1.  Let _handler_ be the value of the [[ProxyHandler]] internal slot of
    _O_.

2.  If _handler_ is NULL, then throw a TYPEERROR exception.

3.  Let _target_ be the value of the [[ProxyTarget]] internal slot of
    _O_.

4.  Let _trap_ be GetMethod(_handler_, "OWNKEYS").

5.  ReturnIfAbrupt(_trap_).

6.  If _trap_ is UNDEFINED, then

    a.  Return the result of calling the [[OwnPropertyKeys]] internal
        method of _target_.

7.  Let _trapResult_ be the result of calling the [[Call]] internal
    method of _trap_ with _handler_ as the THIS value and a new List
    containing _target_.

8.  ReturnIfAbrupt(_trapResult_).

9.  If Type(_trapResult_) is not Object, then throw a TYPEERROR
    exception.

10. If _trapResult_ is not an Array exotic object, then throw a
    TYPEERROR exception.

1.  Let _extensibleTarget_ be IsExtensible(_target_).

2.  ReturnIfAbrupt(_extensibleTarget_).

1.  Let _targetKeys_ be the result of calling the [[OwnPropertyKeys]]
    internal method of _target_.

2.  ReturnIfAbrupt(_targetKeys_).

3.  Let _targetLength_ be ToLength(Get(_targetKeys_, "LENGTH").

4.  ReturnIfAbrupt(_targetLength_).

5.  Let _targetConfigurableKeys_ be an empty List.

6.  Let _targetNonconfigurableKeys_ be an empty List.

7.  Let _n_ be 0.

8.  Repeat, while _n_<_targetLength_,

    a.  Let _key_ be Get(_targetKeys_, ToString(_n_)).

    b.  ReturnIfAbrupt(_key_).

    c.  Let _desc_ the result of calling the [[GetOwnProperty]] internal
        method of _target_ with argument _key_.

    d.  ReturnIfAbrupt(_desc_).

    e.  If _desc_ is not UNDEFINED AND _desc._[[Configurable]] is FALSE,
        then

        i.  Append _key_ as an element of _targetNonconfurableKeys_.

    f.  Else,

        i.  Append _key_ as an element of _targetConfigurableKeys_.

    g.  Let _n_ be _n_ + 1.

9.  If _extensibleTarget_ is TRUE and _targetNonconfigurableKeys_ is
    empty, then

    a.  Return _trapResult_.

10. Let _resultLength_ be ToLength(Get(_trapResult_, "LENGTH").

11. ReturnIfAbrupt(_resultLength_).

12. Let _uncheckedResultKeys_ be an empty List.

13. Let _n_ be 0.

14. Repeat, while _n_< _resultLength_,

    a.  Let _key_ be Get(_trapResult_, ToString(_n_)).

    b.  ReturnIfAbrupt(_key_).

    c.  Append _key_ as an element of _uncheckedResultKeys_.

    d.  Let _n_ be _n_ + 1.

15. Repeat, for each _key_ that is an element of
    _targetNonconfigurableKeys_,

    a.  If _key_ is not an element of _uncheckedResultKeys_, then throw
        a TYPEERROR exception.

    b.  Remove _key_ from _uncheckedResultKeys_

16. If _extensibleTarget_ is TRUE, then return _trapResult_.

17. Repeat, for each _key_ that is an element of
    _targetConfigurableKeys_,

    a.  If _key_ is not an element of _uncheckedResultKeys_, then throw
        a TYPEERROR exception.

    b.  Remove _key_ from _uncheckedResultKeys_

18. If _uncheckedResultKeys_ is not empty, then throw a TYPEERROR
    exception.

19. Return _trapResult_.

NOTE [[OwnPropertyKeys]] for proxy objects enforces the following
invariants:

-   The result of [[OwnPropertyKeys]] must be an exotic Array Object.

-   The result array must contain the keys of all non-configurable own
    properties of the target object.

-   If the target object is not extensible, then the result array must
    contain all the keys of the own properties of the target object and
    no other values.

[[Call]] (thisArgument, argumentsList) 

The [[Call]] internal method of an exotic Proxy object _O_ is called
with parameters _thisArgument_ and _argumentsList_, a List of ECMAScript
language values. The following steps are taken:

1.  Let _handler_ be the value of the [[ProxyHandler]] internal slot of
    _O_.

2.  If _handler_ is NULL, then throw a TYPEERROR exception.

3.  Let _target_ be the value of the [[ProxyTarget]] internal slot of
    _O_.

4.  Let _trap_ be GetMethod(_handler_, "APPLY").

5.  ReturnIfAbrupt(_trap_).

6.  If _trap_ is UNDEFINED, then

    a.  Return the result of calling the [[Call]] internal method of
        _target_ with arguments _thisArgument_ and _argumentsList_.

7.  Let _argArray_ be CreateArrayFromList(_argumentsList_).

8.  Return the result of calling the [[Call]] internal method of _trap
    with _handler_ as the THIS value and a new List containing _target_,
    _thisArgument_, and _argArray_.

NOTE A Proxy exotic object only has a [[Call]] internal method if the
initial value of its [[ProxyTarget]] internal slot is an object that has
a [[Call]] internal method.

[[Construct]] Internal Method

The [[Construct]] internal method of an exotic Proxy object _O_ is
called with a single parameter _argumentsList_ which is a possibly empty
List of ECMAScript language values. The following steps are taken:

1.  Let _handler_ be the value of the [[ProxyHandler]] internal slot of
    _O_.

2.  If _handler_ is NULL, then throw a TYPEERROR exception.

3.  Let _target_ be the value of the [[ProxyTarget]] internal slot of
    _O_.

4.  Let _trap_ be GetMethod(_handler_, "CONSTRUCT").

5.  ReturnIfAbrupt(_trap_).

6.  If _trap_ is UNDEFINED, then

    a.  If _target_ does not have a [[Construct]] internal method, then
        throw a TYPEERROR exception.

    b.  Return the result of calling the [[Construct]] internal method
        of _target_ with argument _argumentsList_.

7.  Let _argArray_ be CreateArrayFromList(_argumentsList_).

8.  Let _newObj_ be the result of calling _trap_ with _handler_ as the
    THIS value and a new List containing _target_ and _argArray_.

9.  ReturnIfAbrupt(_newObj_).

10. If Type(_newObj_) is not Object, then throw a TYPEERROR exception.

11. Return _newObj_.

NOTE 1 A Proxy exotic object only has a [[Construct]] internal method if
the initial value of its [[ProxyTarget]] internal slot is an object that
has a [[Construct]] internal method.

NOTE 2 [[Construct]]] for proxy objects enforces the following
invariants:

-   The result of [[Construct]] must be an Object.

ProxyCreate(target, handler) Abstract Operation

The abstract operation ProxyCreate with arguments _target_ and _handler_
is used to specify the creation of new Proxy exotic objects. It performs
the following steps:

1.  If Type(_target_) is not Object, throw a TYPEERROR Exception.

2.  If Type(_handler_) is not Object, throw a TYPEERROR Exception.

3.  Let _P_ be a newly created object.

4.  Set _P_’s essential internal methods (except for [[Call]] nad
    [[Construct]]) to the definitions specified in 9.5.

5.  If IsCallable(_target_) is TRUE, then

    a.  Set the [[Call]] internal method of _P_ as specified in 9.5.13.

    b.  If _target_ has a [[Construct]] internal method, then

        i.  Set the [[Construct]] internal method of _P_ as specified in
            9.5.14.

6.  Set the [[ProxyTarget]] internal slot of _P_ to _target_.

7.  Set the [[ProxyHandler]] internal slot of _P_ to _handler_.

8.  Return _P_.



ECMASCRIPT LANGUAGE: SOURCE CODE


Source Text

Syntax

SourceCharacter ::

  any Unicode code point

The ECMAScript code is expressed using Unicode, version 5.1 or later.
ECMAScript source text is a sequence of code points. All Unicode code
point values from U+0000 to U+10FFFF, including surrogate code points,
may occur in source text where permitted by the ECMAScript grammars. The
actual encodings used to store and interchange ECMAScript source text is
not relevant to this specification. Regardless of the external source
text encoding, a conforming ECMAScript implementation processes the
source text as if it was an equivalent sequence of _SourceCharacter_
values. Each _SourceCharacter_ being a Unicode code point. Conforming
ECMAScript implementations are not required to perform any normalization
of text, or behave as though they were performing normalization of text.

The components of a combining character sequence are treated as
individual Unicode code points even though a user might think of the
whole sequence as a single character.

NOTE In string literals, regular expression literals, template literals
and identifiers, any Unicode code point may also be expressed using
Unicode escape sequences that explicitly express a code point’s numeric
value. Within a comment, such an escape sequence is effectively ignored
as part of the comment.

ECMAScript differs from the Java programming language in the behaviour
of Unicode escape sequences. In a Java program, if the Unicode escape
sequence \U000A, for example, occurs within a single-line comment, it is
interpreted as a line terminator (Unicode code point U+000A is line
feed) and therefore the next code point is not part of the comment.
Similarly, if the Unicode escape sequence \U000A occurs within a string
literal in a Java program, it is likewise interpreted as a line
terminator, which is not allowed within a string literal—one must write
\N instead of \U000A to cause a line feed to be part of the string value
of a string literal. In an ECMAScript program, a Unicode escape sequence
occurring within a comment is never interpreted and therefore cannot
contribute to termination of the comment. Similarly, a Unicode escape
sequence occurring within a string literal in an ECMAScript program
always contributes to the literal and is never interpreted as a line
terminator or as a quote mark that might terminate the string literal.

Static Semantics: UTF-16Encoding

The UTF-16Encoding of a numeric code point value, _cp_, is determined as
follows:

1.  Assert: 0 ≤ _cp_ ≤ 0x10FFFF.

2.  If _cp_ ≤ 65535, then return _cp_.

3.  Let _cu1_ be floor((_cp_ – 65536) / 1024) + 0xD800.

4.  Let _cu2_ be ((_cp_ – 65536) modulo 1024) + 0xDC00.

5.  Return the code unit sequence consisting of _cu1_ followed by _cu2_.

Static Semantics: UTF16Decode(lead, trail)

Two code units, _lead_ and _trail_, that form a UTF-16 surrogate pair
are converted to a code point by performing the following steps:

1.  Assert: 0xD800 ≤ _lead_ ≤ 0xDBFF and 0xDC00 ≤ _trail_ ≤ 0xDFFF.

2.  Let _cp_ be (_lead_–0xD800)×1024+( _trail_–0xDC00)+0x10000.

3.  Return the code point _cp_.


Types of Source Code

There are four types of ECMAScript code:

-   _Global code_ is source text that is treated as an ECMAScript
      _Script_. The global code of a particular _Script_ does not
      include any source text that is parsed as part of a
      _FunctionBody_, _GeneratorBody_, _ConciseBody_, _ClassBody_, or
      _ModuleBody_.

-   _Eval code_ is the source text supplied to the built-in EVAL
      function. More precisely, if the parameter to the built-in EVAL
      function is a String, it is treated as an ECMAScript _Script_. The
      eval code for a particular invocation of EVAL is the global code
      portion of that _Script_.

-   _Function code_ is source text that is parsed to supply the value of
      the [[Code]] internal slot (see 9.1.14) of function and generator
      objects. It includes the code that defines and initializes the
      formal parameters of the function. The _function code_ of a
      particular function or generator does not include any source text
      that is parsed as the function code of a nested _FunctionBody_,
      _GeneratorBody_, _ConciseBody_, or _ClassBody_.

-   _Module code_ is source text that is code that is provided as a
      _ModuleBody_. It is the code that is directly evaluated when a
      module is initialized. The module code of a particular module does
      not include any source text that is parsed as part of a nested
      _FunctionBody_, _GeneratorBody_, _ConciseBody_, _ClassBody_, or
      _ModuleBody_.

NOTE Function code is generally provided as the bodies of Function
Definitions (14.1), Arrow Function Definitions (14.2), Method
Definitions (14.3) and Generator Definitions (14.4). Function code is
also derived from the last argument to the Function constructor
(19.2.1.1) and the GeneratorFunction constructor (25.2.1.1).

Strict Mode Code

An ECMAScript _Script_ syntactic unit may be processed using either
unrestricted or strict mode syntax and semantics. When processed using
strict mode the four types of ECMAScript code are referred to as module
code, strict global code, strict eval code, and strict function code.
Code is interpreted as strict mode code in the following situations:

-   Global code is strict global code if it begins with a Directive
      Prologue that contains a Use Strict Directive (see 14.1.1).

-   Module code is always strict code.

-   All parts of a _ClassDeclaration_ or a _ClassExpression_ are strict
      code.

-   Eval code is strict eval code if it begins with a Directive Prologue
      that contains a Use Strict Directive or if the call to eval is a
      direct call (see 18.2.1.1) to the eval function that is contained
      in strict mode code.

-   Function code that is part of a _FunctionDeclaration_,
      _FunctionExpression_, _GeneratorDeclaration_,
      _GeneratorExpression_, _MethodDefinition_, or _ArrowFunction_ is
      strict function code if its _GeneratorDeclaration_,
      _GeneratorExpression_, _MethodDefinition_, or _ArrowFunction_ is
      contained in strict mode code or if its _FunctionBody_ begins with
      a Directive Prologue that contains a Use Strict Directive.

-   Function code that is supplied as the last argument to the built-in
      Function constructor is strict function code if the last argument
      is a String that when processed as a _FunctionBody_ begins with a
      Directive Prologue that contains a Use Strict Directive.

Non-ECMAScript Functions

An ECMAScript implementation may support the evaluation of exotic
function objects whose evaluative behaviour is expressed in some
implementation defined form of executable code other than via ECMAScript
code. Whether a function object is an ECMAScript code function or a
non-ECMAScript function is not semantically observable from the
perspective of an ECMAScript code function that calls or is called by
such a non-ECMAScript function.



ECMASCRIPT LANGUAGE: LEXICAL GRAMMAR


The source text of an ECMAScript script is first converted into a
sequence of input elements, which are tokens, line terminators,
comments, or white space. The source text is scanned from left to right,
repeatedly taking the longest possible sequence of code units as the
next input element.

There are several situations where the identification of lexical input
elements is sensitive to the syntactic grammar context that is consuming
the input elements. This requires multiple goal symbols for the lexical
grammar. The _InputElementDiv_ goal symbol is the default goal symbol
and is used in those syntactic grammar contexts where a leading division
(/) or division-assignment (/=) operator is permitted. The
_InputElementRegExp_ goal symbol is used in all syntactic grammar
contexts where a _RegularExpressionLiteral_ is permitted. The
_InputElementTemplateTail_ goal is used in syntactic grammar contexts
where a _TemplateLiteral_ logically continues after a substitution
element.

NOTE There are no syntactic grammar contexts where both a leading
division or division-assignment, and a leading
_RegularExpressionLiteral_ are permitted. This is not affected by
semicolon insertion (see 11.9); in examples such as the following:

  A = B
  /HI/G.EXEC(C).MAP(D);

where the first non-whitespace, non-comment code point after a
_LineTerminator_ is slash (/) and the syntactic context allows division
or division-assignment, no semicolon is inserted at the
_LineTerminator_. That is, the above example is interpreted in the same
way as:

  A = B / HI / G.EXEC(C).MAP(D);

Syntax

InputElementDiv ::

WhiteSpace
LineTerminator
Comment
Token
DivPunctuator
RightBracePunctuator

InputElementRegExp ::

WhiteSpace
LineTerminator
Comment
Token
RightBracePunctuator
RegularExpressionLiteral

InputElementTemplateTail ::

WhiteSpace
LineTerminator
Comment
Token
DivPunctuator
TemplateSubstitutionTail


Unicode Format-Control Characters

The Unicode format-control characters (i.e., the characters in category
“Cf” in the Unicode Character Database such as left-to-right mark or
right-to-left mark) are control codes used to control the formatting of
a range of text in the absence of higher-level protocols for this (such
as mark-up languages).

It is useful to allow format-control characters in source text to
facilitate editing and display. All format control characters may be
used within comments, and within string literals, template literals, and
regular expression literals.

U+200C (Zero width non-joiner) and U+200D (Zero width joiner) are
format-control characters that are used to make necessary distinctions
when forming words or phrases in certain languages. In ECMAScript source
text these code points may also be used in an _IdentifierName_ (see
11.6.1) after the first character.

U+FEFF (Byte Order Mark) is a format-control character used primarily at
the start of a text to mark it as Unicode and to allow detection of the
text's encoding and byte order. <BOM> characters intended for this
purpose can sometimes also appear after the start of a text, for example
as a result of concatenating files. In ECMAScript source text <BOM> code
points are treated as white space characters (see 11.2).

The special treatment of certain format-control characters outside of
comments, string literals, and regular expression literals is summarized
in Table 30.

Table 30 — Format-Control Code Point Usage

  --------------- ----------------------- ---------------- ------------------
  _CODE POINT _   _NAME_                  _ABBREVIATION_   _USAGE_
  U+200C          Zero width non-joiner   <ZWNJ>           _IdentifierPart_
  U+200D          Zero width joiner       <ZWJ>            _IdentifierPart_
  U+FEFF          Byte Order Mark         <BOM>            _Whitespace_
  --------------- ----------------------- ---------------- ------------------


White Space

White space code points are used to improve source text readability and
to separate tokens (indivisible lexical units) from each other, but are
otherwise insignificant. White space code points may occur between any
two tokens and at the start or end of input. White space code points may
occur within a _StringLiteral_, a _RegularExpressionLiteral_, a
_Template_, or a _TemplateSubstitutionTail_ where they are considered
significant code points forming part of a literal value. They may also
occur within a _Comment_, but cannot appear within any other kind of
token.

The ECMAScript white space code points are listed in Table 31.

Table 31 — Whitespace Code Point

  --------------------- ------------------------------------------------- ----------------
  _CODE POINT _         _NAME_                                            _ABBREVIATION_
  U+0009                Character Tabulation                              <TAB>
  U+000B                LINE TABULATION                                   <VT>
  U+000C                Form Feed                                         <FF>
  U+0020                Space                                             <SP>
  U+00A0                No-break space                                    <NBSP>
  U+FEFF                Byte Order Mark                                   <BOM>
  Other category “Zs”   Any other Unicode “Separator, space” code point   <USP>
  --------------------- ------------------------------------------------- ----------------

ECMAScript implementations must recognize as _Whitespace_ code points
listed in the “Separator, space” (Zs) category by Unicode 5.1.
ECMAScript implementations may also recognize as _Whitespace_ additional
category Zs code points from subsequent editions of the Unicode
Standard.

NOTE Other than for the code points listed in Table 31, ECMAScript
_Whitespace_ intentionally excludes all code points that have the
Unicode “White_Space” property but which are not classified in category
“Zs”.

Syntax

WhiteSpace ::

<TAB>
<VT>
<FF>
<SP>
<NBSP>
<BOM>
<USP>


Line Terminators

Like white space code points, line terminator code points are used to
improve source text readability and to separate tokens (indivisible
lexical units) from each other. However, unlike white space code points,
line terminators have some influence over the behaviour of the syntactic
grammar. In general, line terminators may occur between any two tokens,
but there are a few places where they are forbidden by the syntactic
grammar. Line terminators also affect the process of automatic semicolon
insertion (11.9). A line terminator cannot occur within any token except
a _StringLiteral_, _Template_, or _TemplateSubstitutionTail_. Line
terminators may only occur within a _StringLiteral_ token as part of a
_LineContinuation_.

A line terminator can occur within a _MultiLineComment_ (11.4) but
cannot occur within a _SingleLineComment_.

Line terminators are included in the set of white space code points that
are matched by the \S class in regular expressions.

The ECMAScript line terminator code points are listed in Table 32.

Table 32 — Line Terminator Code Points

  --------------- --------------------- ----------------
  _CODE POINT _   _UNICODE NAME_        _ABBREVIATION_
  U+000A          Line Feed             <LF>
  U+000D          Carriage Return       <CR>
  U+2028          Line separator        <LS>
  U+2029          Paragraph separator   <PS>
  --------------- --------------------- ----------------

Only the Unicode code points in Table 32 are treated as line
terminators. Other new line or line breaking Unicode code points are not
treated as line terminators but are treated as white space if they meet
the requirements listed in Table 31. The sequence <CR><LF> is commonly
used as a line terminator. It should be considered a single
_SourceCharacter_ for the purpose of reporting line numbers.

Syntax

LineTerminator ::

<LF>
<CR>
<LS>
<PS>

LineTerminatorSequence ::

<LF>
<CR> [lookahead ∉ <LF> ]
<LS>
<PS>
<CR> <LF>


Comments

Comments can be either single or multi-line. Multi-line comments cannot
nest.

Because a single-line comment can contain any Unicode code point except
a _LineTerminator_ code point, and because of the general rule that a
token is always as long as possible, a single-line comment always
consists of all code points from the // marker to the end of the line.
However, the _LineTerminator_ at the end of the line is not considered
to be part of the single-line comment; it is recognized separately by
the lexical grammar and becomes part of the stream of input elements for
the syntactic grammar. This point is very important, because it implies
that the presence or absence of single-line comments does not affect the
process of automatic semicolon insertion (see 11.9).

Comments behave like white space and are discarded except that, if a
_MultiLineComment_ contains a line terminator code point, then the
entire comment is considered to be a _LineTerminator_ for purposes of
parsing by the syntactic grammar.

Syntax

Comment ::

MultiLineComment
SingleLineComment

MultiLineComment ::

/* MultiLineCommentChars~opt~ */

MultiLineCommentChars ::

MultiLineNotAsteriskChar MultiLineCommentChars~opt~
* PostAsteriskCommentChars~opt~

PostAsteriskCommentChars ::

MultiLineNotForwardSlashOrAsteriskChar MultiLineCommentChars~opt~
* PostAsteriskCommentChars~opt~

MultiLineNotAsteriskChar ::

SourceCharacter BUT NOT *

MultiLineNotForwardSlashOrAsteriskChar ::

SourceCharacter BUT NOT ONE OF / OR *

SingleLineComment ::

// SingleLineCommentChars~opt~

SingleLineCommentChars ::

SingleLineCommentChar SingleLineCommentChars~opt~

SingleLineCommentChar ::

SourceCharacter BUT NOT LineTerminator


Tokens

Syntax

Token ::

IdentifierName
Punctuator
NumericLiteral
StringLiteral
Template

NOTE The _DivPunctuator_, _RegularExpressionLiteral_,
_RightBracePunctuator,_ and _TemplateSubstitutionTail_ productions
define tokens, but are not included in the _Token_ production.


Names and Keywords

_IdentifierName_ and _ReservedWord_ are tokens that are interpreted
according to the Default Identifier Syntax given in Unicode Standard
Annex #31, Identifier and Pattern Syntax, with some small modifications.
_ReservedWord_ is an enumerated subset of _IdentifierName_. The
syntactic grammer defines _Identifier_ as an _IdentifierName_ that is
not a _ReservedWord_ (see 11.6.2). The Unicode identifier grammar is
based on character properties specified by the Unicode Standard. The
Unicode code points in the specified categories in version 5.1.0 of the
Unicode standard must be treated as in those categories by all
conforming ECMAScript implementations. ECMAScript implementations may
recognize identifier code points defined in later editions of the
Unicode Standard.

NOTE 1 This standard specifies specific code point additions: U+0024
(dollar sign) and U+005F (LOW LINE) are permitted anywhere in an
_IdentifierName_, and the characters U+200C (zero-width non-joiner) and
U+200D (zero-width joiner) are permitted anywhere after the first code
unit of an _IdentifierName_.

Unicode escape sequences are permitted in an _IdentifierName_, where
they contribute a single Unicode code point to the _IdentifierName_. The
code point is expressed by the _HexDigits_ of the
_UnicodeEscapeSequence_ (see 11.8.4). The \ preceding the
_UnicodeEscapeSequence_ and the U and { } code units, if they appear, do
not contribute code points to the _IdentifierName_. A
_UnicodeEscapeSequence_ cannot be used to put a code point into an
_IdentifierName_ that would otherwise be illegal. In other words, if a \
_UnicodeEscapeSequence_ sequence were replaced by the _SourceCharacter
it contributes, the result must still be a valid _IdentifierName_ that
has the exact same sequence of _SourceCharacter_ elements as the
original _IdentifierName_. All interpretations of _IdentifierName_
within this specification are based upon their actual code points
regardless of whether or not an escape sequence was used to contribute
any particular code point.

Two _IdentifierName_ that are canonically equivalent according to the
Unicode standard are _not_ equal unless they are represented by the
exact same sequence of code points (in other words, conforming
ECMAScript implementations are only required to do bitwise comparison on
_IdentifierName_ values).

Syntax

IdentifierName ::

IdentifierStart
IdentifierName IdentifierPart

IdentifierStart ::

UnicodeIDStart
$
_
\ UnicodeEscapeSequence

IdentifierPart ::

UnicodeIDContinue
$
_
\ UnicodeEscapeSequence
<ZWNJ>
<ZWJ>

UnicodeIDStart ::

any Unicode code point with the Unicode property “ID_Start” or
“Other_ID_Start”

UnicodeIDContinue ::

any Unicode code point with the Unicode property “ID_Continue” or
“Other_ID_ Continue”

The definitions of the nonterminal _UnicodeEscapeSequence_ is given in
11.8.4.

Identifier Names

Static Semantics: Early Errors

_IdentifierStart_ :: \ _UnicodeEscapeSequence

-   It is a Syntax Error if SV(_UnicodeEscapeSequence_) is neither the
    UTF-16Encoding (10.1.1) of a single Unicode code point with the
    Unicode property “ID_Start” nor "$" or "_".

_IdentifierPart_ :: \ _UnicodeEscapeSequence

-   It is a Syntax Error if SV(_UnicodeEscapeSequence_) is neither the
    UTF-16Encoding (10.1.1) of a single Unicode code point with the
    Unicode property “ID_Continue” nor "$" or "_" nor the UTF-16Encoding
    of either <ZWNJ> or <ZWJ>.

Static Semantics: StringValue

See also: 11.8.4.2, 12.1.3.

IdentifierName ::

IdentifierStart
IdentifierName IdentifierPart

1.  Return the String value consisting of the sequence of code units
    corresponding to _IdentifierName_. In determining the sequence any
    occurrences of \ _UnicodeEscapeSequence_ are first replaced with the
    code point represented by the _UnicodeEscapeSequence_ and then the
    code points of the entire _IdentifierName_ are converted to code
    units by UTF-16Encoding (10.1.1) each code point.

Reserved Words

A reserved word is an _IdentifierName_ that cannot be used as an
_Identifier_.

Syntax

ReservedWord ::

Keyword
FutureReservedWord
NullLiteral
BooleanLiteral

NOTE The _ReservedWord_ definitions are specified as literal sequences
of specific _SourceCharacter_ elements. A code point in a _ReservedWord_
cannot be expressed by a \ _UnicodeEscapeSequence_.

Keywords

The following tokens are ECMAScript keywords and may not be used as
_Identifiers_ in ECMAScript programs.

Syntax

Keyword :: ONE OF

  ---------- ---------- ------------ --------
  break      do         in           typeof
  case       else       instanceof   var
  catch      export     new          void
  class      extends    return       while
  const      finally    super        with
  continue   for        switch       yield
  debugger   function   this         
  default    if         throw        
  delete     import     try          
  ---------- ---------- ------------ --------

NOTE In some contexts YIELD is given the semantics of an _Identifier_.
See 12.1.1. In strict mode code, LET is treated as a keyword through
static semantic restrictions (see 12.1.1, 12.2.4.2.1, 13.2.1.1,
13.6.4.1, and 14.5.1) rather than the lexical grammar.

Future Reserved Words

The following words are used as keywords in proposed extensions and are
therefore reserved to allow for the possibility of future adoption of
those extensions.

Syntax

FutureReservedWord ::

  ------- -- -- --
  enum          
  await         
  ------- -- -- --

AWAIT is only treated as a _FutureReservedWord_ when _Module_ is the
goal symbol of the syntactic grammar.

NOTE Use of the following tokens within strict mode code (see 10.2.1) is
also reserved. That usage is restricted using static semantic
restrictions (see 12.1.1) rather than the lexical grammar:

  ------------ --------- ----------- --------
  implements   package   protected   static
  interface    private   public      
  ------------ --------- ----------- --------

  -- -- -- -- --
              
              
  -- -- -- -- --


Punctuators

Syntax

Punctuator :: ONE OF

  ----- ------ ----- ----- ----- -----
  {     (      )     [     ]     .
  ...   ;      ,     <     >     <=
  >=    ==     !=    ===   !==   
  +     -      *     %     ++    --
  <<    >>     >>>   &     |     ^
  !     ~      &&    ||    ?     :
  =     +=     -=    *=    %=    <<=
  >>=   >>>=   &=    |=    ^=    =>
  ----- ------ ----- ----- ----- -----

DivPunctuator :: ONE OF

  --- ---- -- -- -- --
  /   /=            
  --- ---- -- -- -- --

RightBracePunctuator ::

  --- -- -- -- -- --
  }               
  --- -- -- -- -- --


Literals

Null Literals

Syntax

NullLiteral ::

NULL

Boolean Literals

Syntax

BooleanLiteral ::

TRUE
FALSE

Numeric Literals

Syntax

NumericLiteral ::

DecimalLiteral
BinaryIntegerLiteral
OctalIntegerLiteral
HexIntegerLiteral

DecimalLiteral ::

DecimalIntegerLiteral . DecimalDigits~opt~ ExponentPart~opt~
. DecimalDigits ExponentPart~opt~
DecimalIntegerLiteral ExponentPart~opt~

DecimalIntegerLiteral ::

0
NonZeroDigit DecimalDigits~opt~

DecimalDigits ::

DecimalDigit
DecimalDigits DecimalDigit

DecimalDigit :: ONE OF

0 1 2 3 4 5 6 7 8 

NonZeroDigit :: ONE OF

1 2 3 4 5 6 7 8 

ExponentPart ::

ExponentIndicator SignedInteger

ExponentIndicator :: ONE OF

E E

SignedInteger ::

DecimalDigits
+ DecimalDigits
- DecimalDigits

BinaryIntegerLiteral ::

0B BinaryDigits
0B BinaryDigits

BinaryDigits ::

BinaryDigit
BinaryDigits BinaryDigit

BinaryDigit :: ONE OF

0 

OctalIntegerLiteral ::

0O OctalDigits
0O OctalDigits

OctalDigits ::

OctalDigit
OctalDigits OctalDigit

OctalDigit :: ONE OF

0 1 2 3 4 5 6 

HexIntegerLiteral ::

0X HexDigits
0X HexDigits

HexDigits ::

HexDigit
HexDigits HexDigit

HexDigit :: ONE OF

0 1 2 3 4 5 6 7 8 9 A B C D E F A B C D E F

The _SourceCharacter_ immediately following a _NumericLiteral_ must not
be an _IdentifierStart_ or _DecimalDigit_.

NOTE For example:

  3in

is an error and not the two input elements 3 and IN.

A conforming implementation, when processing strict mode code (see
10.2.1), must not extend the syntax of _NumericLiteral_ to include
_LegacyOctalIntegerLiteral_ as described in B.1.1.

Static Semantics: MV’s

A numeric literal stands for a value of the Number type. This value is
determined in two steps: first, a mathematical value (MV) is derived
from the literal; second, this mathematical value is rounded as
described below.

-   The MV of _NumericLiteral_ :: _DecimalLiteral_ is the MV of
    _DecimalLiteral_.

-   The MV of _NumericLiteral_ :: _BinaryIntegerLiteral_ is the MV of
    _BinaryIntegerLiteral_.

-   The MV of _NumericLiteral_ :: _OctalIntegerLiteral_ is the MV of
    _OctalIntegerLiteral_.

-   The MV of _NumericLiteral_ :: _HexIntegerLiteral_ is the MV of
    _HexIntegerLiteral_.

-   The MV of _DecimalLiteral_ :: _DecimalIntegerLiteral_ . is the MV of
    _DecimalIntegerLiteral_.

-   The MV of _DecimalLiteral_ :: _DecimalIntegerLiteral_ .
    _DecimalDigits_ is the MV of _DecimalIntegerLiteral_ plus (the MV of
    _DecimalDigits_ × 10^–_n_^), where _n_ is the number of code points
    in _DecimalDigits_.

-   The MV of _DecimalLiteral_ :: _DecimalIntegerLiteral_ .
    _ExponentPart_ is the MV of _DecimalIntegerLiteral_ × 10_^e^_, where
    _e_ is the MV of _ExponentPart_.

-   The MV of _DecimalLiteral_ :: _DecimalIntegerLiteral_ .
    _DecimalDigits ExponentPart_ is (the MV of _DecimalIntegerLiteral_
    plus (the MV of _DecimalDigits_ × 10^–_n_^)) × 10_^e^_, where _n_ is
    the number of code points in _DecimalDigits_ and _e_ is the MV of
    _ExponentPart_.

-   The MV of _DecimalLiteral_ ::. _DecimalDigits_ is the MV of
    _DecimalDigits_ × 10^–_n_^, where _n_ is the number of code points
    in _DecimalDigits_.

-   The MV of _DecimalLiteral_ ::. _DecimalDigits ExponentPart_ is the
    MV of _DecimalDigits_ × 10^_e_–_n_^, where _n_ is the number of code
    points in _DecimalDigits_ and _e_ is the MV of _ExponentPart_.

-   The MV of _DecimalLiteral_ :: _DecimalIntegerLiteral_ is the MV of
    _DecimalIntegerLiteral_.

-   The MV of _DecimalLiteral_ :: _DecimalIntegerLiteral ExponentPart_
    is the MV of _DecimalIntegerLiteral_ × 10_^e^_, where _e_ is the MV
    of _ExponentPart_.

-   The MV of _DecimalIntegerLiteral_ :: 0 is 0.

-   The MV of _DecimalIntegerLiteral_ :: _NonZeroDigit_ is the MV of
    _NonZeroDigit._

-   The MV of _DecimalIntegerLiteral_ :: _NonZeroDigit_ _DecimalDigits_
    is (the MV of _NonZeroDigit_ × 10_^n^_) plus the MV of
    _DecimalDigits_, where _n_ is the number of code points in
    _DecimalDigits_.

-   The MV of _DecimalDigits_ :: _DecimalDigit_ is the MV of
    _DecimalDigit_.

-   The MV of _DecimalDigits_ :: _DecimalDigits_ _DecimalDigit_ is (the
    MV of _DecimalDigits_ × 10) plus the MV of _DecimalDigit_.

-   The MV of _ExponentPart_ :: _ExponentIndicator SignedInteger_ is the
    MV of _SignedInteger_.

-   The MV of _SignedInteger_ :: _DecimalDigits_ is the MV of
    _DecimalDigits_.

-   The MV of _SignedInteger_ :: + _DecimalDigits_ is the MV of
    _DecimalDigits_.

-   The MV of _SignedInteger_ :: - _DecimalDigits_ is the negative of
    the MV of _DecimalDigits_.

-   The MV of _DecimalDigit_ :: 0 or of _HexDigit_ :: 0 or of
    _OctalDigit_ :: 0 or of _BinaryDigit_ :: 0 is 0.

-   The MV of _DecimalDigit_ :: 1 or of _NonZeroDigit_ :: 1 or of
    _HexDigit_ :: 1 or of _OctalDigit_ :: 1 or
    of _BinaryDigit_ :: 1 is 1.

-   The MV of _DecimalDigit_ :: 2 or of _NonZeroDigit_ :: 2 or of
    _HexDigit_ :: 2 or of _OctalDigit_ :: 2 is 2.

-   The MV of _DecimalDigit_ :: 3 or of _NonZeroDigit_ :: 3 or of
    _HexDigit_ :: 3 or of _OctalDigit_ :: 3 is 3.

-   The MV of _DecimalDigit_ :: 4 or of _NonZeroDigit_ :: 4 or of
    _HexDigit_ :: 4 or of _OctalDigit_ :: 4 is 4.

-   The MV of _DecimalDigit_ :: 5 or of _NonZeroDigit_ :: 5 or of
    _HexDigit_ :: 5 or of _OctalDigit_ :: 5 is 5.

-   The MV of _DecimalDigit_ :: 6 or of _NonZeroDigit_ :: 6 or of
    _HexDigit_ :: 6 or of _OctalDigit_ :: 6 is 6.

-   The MV of _DecimalDigit_ :: 7 or of _NonZeroDigit_ :: 7 or of
    _HexDigit_ :: 7 or of _OctalDigit_ :: 7 is 7.

-   The MV of _DecimalDigit_ :: 8 or of _NonZeroDigit_ :: 8 or of
    _HexDigit_ :: 8 is 8.

-   The MV of _DecimalDigit_ :: 9 or of _NonZeroDigit_ :: 9 or of
    _HexDigit_ :: 9 is 9.

-   The MV of _HexDigit_ :: A or of _HexDigit_ :: A is 10.

-   The MV of _HexDigit_ :: B or of _HexDigit_ :: B is 11.

-   The MV of _HexDigit_ :: C or of _HexDigit_ :: C is 12.

-   The MV of _HexDigit_ :: D or of _HexDigit_ :: D is 13.

-   The MV of _HexDigit_ :: E or of _HexDigit_ :: E is 14.

-   The MV of _HexDigit_ :: F or of _HexDigit_ :: F is 15.

-   The MV of _BinaryIntegerLiteral_ :: 0B _BinaryDigits_ is the MV of
    _BinaryDigits_.

-   The MV of _BinaryIntegerLiteral_ :: 0B _BinaryDigits_ is the MV of
    _BinaryDigits_.

-   The MV of _BinaryDigits_ :: _BinaryDigit_ is the MV of
    _BinaryDigit_.

-   The MV of _BinaryDigits_ :: _BinaryDigits_ _BinaryDigit_ is (the MV
    of _BinaryDigits_ × 2) plus the MV of _BinaryDigit_.

-   The MV of _OctalIntegerLiteral_ :: 0O _OctalDigits_ is the MV of
    _OctalDigits_.

-   The MV of _OctalIntegerLiteral_ :: 0O _OctalDigits_ is the MV of
    _OctalDigits_.

-   The MV of _OctalDigits_ :: _OctalDigit_ is the MV of _OctalDigit_.

-   The MV of _OctalDigits_ :: _OctalDigits_ _OctalDigit_ is (the MV of
    _OctalDigits_ × 8) plus the MV of _OctalDigit_.

-   The MV of _HexIntegerLiteral_ :: 0X _HexDigits_ is the MV of
    _HexDigits_.

-   The MV of _HexIntegerLiteral_ :: 0X _HexDigits_ is the MV of
    _HexDigits_.

-   The MV of _HexDigits_ :: _HexDigit_ is the MV of _HexDigit_.

-   The MV of _HexDigits_ :: _HexDigits_ _HexDigit_ is (the MV of
    _HexDigits_ × 16) plus the MV of _HexDigit_.

Once the exact MV for a numeric literal has been determined, it is then
rounded to a value of the Number type. If the MV is 0, then the rounded
value is +0; otherwise, the rounded value must be the Number value for
the MV (as specified in 6.1.6), unless the literal is a _DecimalLiteral_
and the literal has more than 20 significant digits, in which case the
Number value may be either the Number value for the MV of a literal
produced by replacing each significant digit after the 20th with a 0
digit or the Number value for the MV of a literal produced by replacing
each significant digit after the 20th with a 0 digit and then
incrementing the literal at the 20th significant digit position. A digit
is _significant_ if it is not part of an _ExponentPart_ and

-   it is not 0; or

-   there is a nonzero digit to its left and there is a nonzero digit,
    not in the _ExponentPart_, to its right.

String Literals

NOTE A string literal is zero or more Unicode code points enclosed in
single or double quotes. Unicode code points may also be represented by
an escape sequence. All code points may appear literally in a string
literal except for the closing quote code points, backslash, carriage
return, line separator, paragraph separator, and line feed. Any code
points may appear in the form of an escape sequence. String literals
evaluate to ECAMScript String values. When generating these string
values Unicode code points are UTF-16 encoded as defined in 10.1.1. Code
points belonging to Basic Multilingual Plane are encoded as a single
code unit element of the string. All other code points are encoded as
two code unit elements of the string.

Syntax

StringLiteral ::

" DoubleStringCharacters~opt~ "
' SingleStringCharacters~opt~ '

DoubleStringCharacters ::

DoubleStringCharacter DoubleStringCharacters~opt~

SingleStringCharacters ::

SingleStringCharacter SingleStringCharacters~opt~

DoubleStringCharacter ::

SourceCharacter BUT NOT ONE OF " OR \ OR LineTerminator
\ EscapeSequence
LineContinuation

SingleStringCharacter ::

SourceCharacter BUT NOT ONE OF ' OR \ OR LineTerminator
\ EscapeSequence
LineContinuation

LineContinuation ::

\ LineTerminatorSequence

EscapeSequence ::

CharacterEscapeSequence
0 [lookahead ∉ DecimalDigit]
HexEscapeSequence
UnicodeEscapeSequence

A conforming implementation, when processing strict mode code (see
10.2.1), must not extend the syntax of _EscapeSequence_ to include
_LegacyOctalEscapeSequence_ as described in B.1.1.

CharacterEscapeSequence ::

SingleEscapeCharacter
NonEscapeCharacter

SingleEscapeCharacter :: ONE OF

' " \ B F N R T V

NonEscapeCharacter ::

SourceCharacter BUT NOT ONE OF EscapeCharacter OR LineTerminator

EscapeCharacter ::

SingleEscapeCharacter
DecimalDigit
X
U

HexEscapeSequence ::

X HexDigit HexDigit

UnicodeEscapeSequence ::

U Hex4Digits
U{ HexDigits }

Hex4Digits ::

HexDigit HexDigit HexDigit HexDigit

The definition of the nonterminal _HexDigit_ is given in 11.8.3.
_SourceCharacter_ is defined in 10.1.

NOTE A line terminator code point cannot appear in a string literal,
except as part of a _LineContinuation_ to produce the empty code points
sequence. The correct way to cause a line terminator code points to be
part of the String value of a string literal is to use an escape
sequence such as \N or \U000A.

Static Semantics: Early Errors

_UnicodeEscapeSequence_ :: U{ _HexDigits_ }

-   It is a Syntax Error if the MV of _HexDigits_ > 1114111_._

Static Semantics: StringValue

See also: 11.6.1.2, 12.1.3.

StringLiteral ::

" DoubleStringCharacters~opt~ "
' SingleStringCharacters~opt~ '

1.  Return the String value whose elements are the SV of this
    _StringLiteral_.

Static Semantics: SV’s and CV’s

A string literal stands for a value of the String type. The String value
(SV) of the literal is described in terms of code unit values (CV)
contributed by the various parts of the string literal. As part of this
process, some Unicode code points within the string literal are
interpreted as having a mathematical value (MV), as described below or
in 11.8.3.

-   The SV of _StringLiteral_ :: "" is the empty code unit sequence.

-   The SV of _StringLiteral_ :: '' is the empty code unit sequence.

-   The SV of _StringLiteral_ :: " _DoubleStringCharacters_ " is the SV
    of _DoubleStringCharacters_.

-   The SV of _StringLiteral_ :: ' _SingleStringCharacters_ ' is the SV
    of _SingleStringCharacters_.

-   The SV of _DoubleStringCharacters_ :: _DoubleStringCharacter_ is a
    sequence of one or two code units that is the CV of
    _DoubleStringCharacter_.

-   The SV of _DoubleStringCharacters_ :: _DoubleStringCharacter_
    _DoubleStringCharacters_ is a sequence of one or two code units that
    is the CV of _DoubleStringCharacter_ followed by all the code units
    in the SV of _DoubleStringCharacters_ in order.

-   The SV of _SingleStringCharacters_ :: _SingleStringCharacter_ is a
    sequence of one or two code units that is the CV of
    _SingleStringCharacter_.

-   The SV of _SingleStringCharacters_ :: _SingleStringCharacter_
    _SingleStringCharacters_ is a sequence of one or two code units that
    is the CV of _SingleStringCharacter_ followed by all the code units
    in the SV of _SingleStringCharacters_ in order.

-   The CV of _DoubleStringCharacter_ :: _SourceCharacter_ BUT NOT ONE
    OF " OR \ OR _LineTerminator_ is the UTF-16Encoding (10.1.1) of the
    code point value of _SourceCharacter_.

-   The CV of _DoubleStringCharacter_ :: \ _EscapeSequence_ is the CV of
    the _EscapeSequence_.

-   The CV of _DoubleStringCharacter_ :: _LineContinuation_ is the empty
    code unit sequence.

-   The CV of _SingleStringCharacter_ :: _SourceCharacter_ BUT NOT ONE
    OF ' OR \ OR _LineTerminator_ is the UTF-16Encoding (10.1.1) of the
    code point value of _SourceCharacter_.

-   The CV of _SingleStringCharacter_ :: \ _EscapeSequence_ is the CV of
    the _EscapeSequence_.

-   The CV of _SingleStringCharacter_ :: _LineContinuation_ is the empty
    code unit sequence.

-   The CV of _EscapeSequence_ :: _CharacterEscapeSequence_ is the CV of
    the _CharacterEscapeSequence_.

-   The CV of _EscapeSequence_ :: 0 is the code unit value 0.

-   The CV of _EscapeSequence_ :: _HexEscapeSequence_ is the CV of the
    _HexEscapeSequence_.

-   The CV of _EscapeSequence_ :: _UnicodeEscapeSequence_ is the CV of
    the _UnicodeEscapeSequence_.

-   The CV of _CharacterEscapeSequence_ :: _SingleEscapeCharacter_ is
    the code unit whose value is determined by the
    _SingleEscapeCharacter_ according to Table 33.

Table 33 — String Single Character Escape Sequences

  ------------------- ------------------- -------------------------- ----------
  _ESCAPE SEQUENCE_   _CODE UNIT VALUE_   _UNICODE CHARACTER NAME_   _SYMBOL_
  \B                  0X0008              BACKSPACE                  <BS>
  \T                  0X0009              CHARACTER TABULATION       <HT>
  \N                  0X000A              line feed                  <LF>
  \V                  0X000B              LINE TABULATION            <VT>
  \F                  0X000C              form feed                  <FF>
  \R                  0X000D              carriage return            <CR>
  \"                  0X0022              quotation Mark             "
  \'                  0X0027              apostrophe                 '
  \\                  0X005C              REverse Solidus            \
  ------------------- ------------------- -------------------------- ----------

-   The CV of _CharacterEscapeSequence_ :: _NonEscapeCharacter_ is the
    CV of the _NonEscapeCharacter_.

-   The CV of _NonEscapeCharacter_ :: _SourceCharacter_ BUT NOT ONE OF
    _EscapeCharacter_ OR _LineTerminator_ is the UTF-16Encoding (10.1.1)
    of the code point value of _SourceCharacter_.

-   The CV of _HexEscapeSequence_ :: X _HexDigit_ _HexDigit_ is the code
    unit value that is (16 times the MV of the first _HexDigit_) plus
    the MV of the second _HexDigit_.

-   The CV of _UnicodeEscapeSequence_ :: U _Hex4Digits_ is the CV of
    _Hex4Digits_.

-   The CV of _Hex4Digits_ :: _HexDigit_ _HexDigit_ _HexDigit_
    _HexDigit_ is the code unit value that is (4096 times the MV of the
    first _HexDigit_) plus (256 times the MV of the second _HexDigit_)
    plus (16 times the MV of the third _HexDigit_) plus the MV of the
    fourth _HexDigit_.

-   The CV of _UnicodeEscapeSequence_ :: U{ _HexDigits_ } is the
    UTF-16Encoding (10.1.1) of the MV of _HexDigits_.

Regular Expression Literals

NOTE A regular expression literal is an input element that is converted
to a RegExp object (see 21.1.5) each time the literal is evaluated. Two
regular expression literals in a program evaluate to regular expression
objects that never compare as === to each other even if the two
literals' contents are identical. A RegExp object may also be created at
runtime by NEW REGEXP (see 21.2.3.2) or calling the REGEXP constructor
as a function (21.2.3.1).

The productions below describe the syntax for a regular expression
literal and are used by the input element scanner to find the end of the
regular expression literal. The source code comprising the
_RegularExpressionBody_ and the _RegularExpressionFlags_ are
subsequently parsed using the more stringent ECMAScript Regular
Expression grammar (21.2.1).

An implementation may extend the ECMAScript Regular Expression grammar
defined in 21.2.1, but it must not extend the _RegularExpressionBody_
and _RegularExpressionFlags_ productions defined below or the
productions used by these productions.

Syntax

RegularExpressionLiteral ::

/ RegularExpressionBody / RegularExpressionFlags

RegularExpressionBody ::

RegularExpressionFirstChar RegularExpressionChars

RegularExpressionChars ::

[empty]
RegularExpressionChars RegularExpressionChar

RegularExpressionFirstChar ::

RegularExpressionNonTerminator BUT NOT ONE OF * OR \ OR / OR [
RegularExpressionBackslashSequence
RegularExpressionClass

RegularExpressionChar ::

RegularExpressionNonTerminator BUT NOT ONE OF \ OR / OR [
RegularExpressionBackslashSequence
RegularExpressionClass

RegularExpressionBackslashSequence ::

\ RegularExpressionNonTerminator

RegularExpressionNonTerminator ::

SourceCharacter BUT NOT LineTerminator

RegularExpressionClass ::

[ RegularExpressionClassChars ]

RegularExpressionClassChars ::

[empty]
RegularExpressionClassChars RegularExpressionClassChar

RegularExpressionClassChar ::

RegularExpressionNonTerminator BUT NOT ONE OF ] OR \
RegularExpressionBackslashSequence

RegularExpressionFlags ::

[empty]
RegularExpressionFlags IdentifierPart

NOTE Regular expression literals may not be empty; instead of
representing an empty regular expression literal, the code unit sequence
// starts a single-line comment. To specify an empty regular expression,
use: /(?:)/.

Static Semantics: Early Errors

_RegularExpressionFlags_ :: _RegularExpressionFlags IdentifierPart 

-   It is a Syntax Error if _IdentifierPart_ contains a Unicode escape
    sequence_._

Static Semantics: BodyText

_RegularExpressionLiteral_ :: / _RegularExpressionBody_ /
_RegularExpressionFlags

1.  Return the source code that was recognized as
    _RegularExpressionBody_.

Static Semantics: FlagText

_RegularExpressionLiteral_ :: / _RegularExpressionBody_ /
_RegularExpressionFlags

1.  Return the source code that was recognized as
    _RegularExpressionFlags_.

Template Literal Lexical Components

Syntax

Template ::

NoSubstitutionTemplate
TemplateHead

NoSubstitutionTemplate ::

` TemplateCharacters~opt~ `

TemplateHead ::

` TemplateCharacters~opt~ ${

TemplateSubstitutionTail ::

TemplateMiddle
TemplateTail

TemplateMiddle ::

} TemplateCharacters~opt~ ${

TemplateTail ::

} TemplateCharacters~opt~ `

TemplateCharacters ::

TemplateCharacter TemplateCharacters~opt~

TemplateCharacter ::

$ [lookahead ≠ { ]
\ EscapeSequence
LineContinuation
LineTerminatorSequence
SourceCharacter BUT NOT ONE OF ` OR \ OR $ OR LineTerminatorSequence

A conforming implementation must not use the extended definition of
_EscapeSequence_ described in B.1.2 when parsing a _TemplateCharacter_.

NOTE _TemplateSubstitutionTail_ is used by the
_InputElementTemplateTail_ alternative lexical goal.

Static Semantics: TV’s and TRV’s

A template literal component is interpreted as a sequence of Unicode
code points. The Template Value (TV) of a literal component is described
in terms of code unit values (CV, 11.8.4) contributed by the various
parts of the template literal component. As part of this process, some
Unicode code points within the template component are interpreted as
having a mathematical value (MV, 11.8.3). In determining a TV, escape
sequences are replaced by the UTF-16 code unit(s) of the Unicode code
point represented by the escape sequence. The Template Raw Value (TRV)
is similar to a Template Value with the difference that in TRVs escape
sequences are interpreted literally.

-   The TV and TRV of _NoSubstitutionTemplate_ :: `` is the empty code
    unit sequence.

-   The TV and TRV of _TemplateHead_ :: `${ is the empty code unit
    sequence.

-   The TV and TRV of _TemplateMiddle_ :: }${ is the empty code unit
    sequence.

-   The TV and TRV of _TemplateTail_ :: }` is the empty code unit
    sequence.

-   The TV of _NoSubstitutionTemplate_ :: ` _TemplateCharacters_ ` is
    the TV of _TemplateCharacters_.

-   The TV of _TemplateHead_ :: ` _TemplateCharacters_ ${ is the TV of
    _TemplateCharacters_.

-   The TV of _TemplateMiddle_ :: } _TemplateCharacters_ ${ is the TV of
    _TemplateCharacters_.

-   The TV of _TemplateTail_ :: } _TemplateCharacters_ ` is the TV of
    _TemplateCharacters_.

-   The TV of _TemplateCharacters_ :: _TemplateCharacter_ is the TV of
    _TemplateCharacter_.

-   The TV of _TemplateCharacters_ :: _TemplateCharacter_
    _TemplateCharacters_ is a sequence consisting of the code units in
    the TV of _TemplateCharacter_ followed by all the code units in the
    TV of _TemplateCharacters_ in order.

-   The TV of _TemplateCharacter_ :: _SourceCharacter_ BUT NOT ONE OF `
    OR \ OR $ OR _LineTerminatorSequence_ is the UTF-16Encoding (10.1.1)
    of the code point value of _SourceCharacter_.

-   The TV of _TemplateCharacter_ :: $ is the code unit value 0x0024.

-   The TV of _TemplateCharacter_ :: \ _EscapeSequence_ is the CV of
    _EscapeSequence_.

-   The TV of _TemplateCharacter_ :: _LineContinuation_ is the TV of
    _LineContinuation_.

-   The TV of _TemplateCharacter_ :: _LineTerminatorSequence_ is the TRV
    of _LineTerminatorSequence_.

-   The TV of _LineContinuation_ :: \ _LineTerminatorSequence_ is the
    empty code unit sequence.

-   The TRV of _NoSubstitutionTemplate_ :: ` _TemplateCharacters_ ` is
    the TRV of _TemplateCharacters_.

-   The TRV of _TemplateHead_ :: ` _TemplateCharacters_ ${ is the TRV of
    _TemplateCharacters_.

-   The TRV of _TemplateMiddle_ :: } _TemplateCharacters_ ${ is the TRV
    of _TemplateCharacters_.

-   The TRV of _TemplateTail_ :: } _TemplateCharacters_ ` is the TRV of
    _TemplateCharacters_.

-   The TRV of _TemplateCharacters_ :: _TemplateCharacter_ is the TRV of
    _TemplateCharacter_.

-   The TRV of _TemplateCharacters_ :: _TemplateCharacter_
    _TemplateCharacters_ is a sequence consisting of the code units in
    the TRV of _TemplateCharacter_ followed by all the code units in the
    TRV of _TemplateCharacters,_ in order.

-   The TRV of _TemplateCharacter_ :: _SourceCharacter_ BUT NOT ONE OF `
    OR \ OR $ OR _LineTerminatorSequence_ is the UTF-16Encoding (10.1.1)
    of the code point value of _SourceCharacter_.

-   The TRV of _TemplateCharacter_ :: $ is the code unit value 0x0024.

-   The TRV of _TemplateCharacter_ :: \ _EscapeSequence_ is the sequence
    consisting of the code unit value 0x005C followed by the code units
    of TRV of _EscapeSequence_.

-   The TRV of _TemplateCharacter_ :: _LineContinuation_ is the TRV of
    _LineContinuation_.

-   The TRV of _TemplateCharacter_ :: _LineTerminatorSequence_ is the
    TRV of _LineTerminatorSequence_.

-   The TRV of _EscapeSequence_ :: _CharacterEscapeSequence_ is the TRV
    of the _CharacterEscapeSequence_.

-   The TRV of _EscapeSequence_ :: 0 is the code unit value 0x0030.

-   The TRV of _EscapeSequence_ :: _HexEscapeSequence_ is the TRV of the
    _HexEscapeSequence_.

-   The TRV of _EscapeSequence_ :: _UnicodeEscapeSequence_ is the TRV of
    the _UnicodeEscapeSequence_.

-   The TRV of _CharacterEscapeSequence_ :: _SingleEscapeCharacter_ is
    the TRV of the _SingleEscapeCharacter_.

-   The TRV of _CharacterEscapeSequence_ :: _NonEscapeCharacter_ is the
    CV of the _NonEscapeCharacter_.

-   The TRV of _SingleEscapeCharacter_ :: ONE OF ' " \ B F N R T V is
    the CV of the _SourceCharacter_ that is that single code point.

-   The TRV of _HexEscapeSequence_ :: X _HexDigit HexDigit_ is the
    sequence consisting of code unit value 0x0078 followed by TRV of the
    first _HexDigit_ followed by the TRV of the second _HexDigit_.

-   The TRV of _UnicodeEscapeSequence_ :: U _Hex4Digits_ is the sequence
    consisting of code unit value 0x0075 followed by TRV of
    _Hex4Digits_.

-   The TRV of _UnicodeEscapeSequence_ :: U{ _HexDigits_ } is the
    sequence consisting of code unit value 0x0075 followed by code unit
    value 0x007B followed by TRV of _HexDigits_ followed by code unit
    value 0x007D.

-   The TRV of _Hex4Digits_ :: _HexDigit_ _HexDigit_ _HexDigit_
    _HexDigit_ is the sequence consisting of the TRV of the first
    _HexDigit_ followed by the TRV of the second _HexDigit_ followed by
    the TRV of the third _HexDigit_ followed by the TRV of the fourth
    _HexDigit_.

-   The TRV of _HexDigits_ :: _HexDigit_ is the TRV of _HexDigit_.

-   The TRV of _HexDigits_ :: _HexDigits_ _HexDigit_ is the sequence
    consisting of TRV of _HexDigits_ followed by TRV of _HexDigit_.

-   The TRV of a _HexDigit_ is the CV of the _SourceCharacter_ that is
    that _HexDigit_.

-   The TRV of _LineContinuation_ :: \ _LineTerminatorSequence_ is the
    sequence consisting of the code unit value 0x005C followed by the
    code units of TRV of _LineTerminatorSequence_.

-   The TRV of _LineTerminatorSequence_ :: <LF> is the code unit value
    0x000A.

-   The TRV of _LineTerminatorSequence_ :: <CR> is the code unit value
    0x000A.

-   The TRV of _LineTerminatorSequence_ :: <LS> is the code unit value
    0x2028.

-   The TRV of _LineTerminatorSequence_ :: <PS> is the code unit value
    0x2029.

-   The TRV of _LineTerminatorSequence_ :: <CR><LF> is the sequence
    consisting of the code unit value 0x000A.

NOTE TV excludes the code units of _LineContinuation_ while TRV includes
them. <CR><LF> and <CR> _LineTerminatorSequences_ are normalized to <LF>
for both TV and TRV. An explicit _EscapeSequence_ is needed to include a
<CR> or <CR><LF> sequence.


Automatic Semicolon Insertion

Certain ECMAScript statements (empty statement, LET, CONST, IMPORT,
EXPORT, AND MODULE declarations, variable statement, expression
statement, DEBUGGER statement, CONTINUE statement, BREAK statement,
RETURN statement, and THROW statement) must be terminated with
semicolons. Such semicolons may always appear explicitly in the source
text. For convenience, however, such semicolons may be omitted from the
source text in certain situations. These situations are described by
saying that semicolons are automatically inserted into the source code
token stream in those situations.

Rules of Automatic Semicolon Insertion

There are three basic rules of semicolon insertion:

1.  When, as the script is parsed from left to right, a token (called
    the _offending token_) is encountered that is not allowed by any
    production of the grammar, then a semicolon is automatically
    inserted before the offending token if one or more of the following
    conditions is true:

-   The offending token is separated from the previous token by at least
      one _LineTerminator_.

-   The offending token is }.

    1.  When, as the script is parsed from left to right, the end of the
        input stream of tokens is encountered and the parser is unable
        to parse the input token stream as a single complete ECMAScript
        _script_, then a semicolon is automatically inserted at the end
        of the input stream.

    2.  When, as the script is parsed from left to right, a token is
        encountered that is allowed by some production of the grammar,
        but the production is a _restricted production_ and the token
        would be the first token for a terminal or nonterminal
        immediately following the annotation “[no _LineTerminator_
        here]” within the restricted production (and therefore such a
        token is called a restricted token), and the restricted token is
        separated from the previous token by at least one
        _LineTerminator_, then a semicolon is automatically inserted
        before the restricted token.

However, there is an additional overriding condition on the preceding
rules: a semicolon is never inserted automatically if the semicolon
would then be parsed as an empty statement or if that semicolon would
become one of the two semicolons in the header of a FOR statement (see
13.6.3).

NOTE The following are the only restricted productions in the grammar:

PostfixExpression~[Yield]~ :

LeftHandSideExpression~[?Yield]~ [no LineTerminator here] ++
LeftHandSideExpression~[?Yield]~ [no LineTerminator here] --

ContinueStatement~[Yield]~ :

CONTINUE;
CONTINUE [no LineTerminator here] LabelIdentifier~[?Yield]~ ;

BreakStatement~[Yield]~ :

BREAK ;
BREAK [no LineTerminator here] LabelIdentifier~[?Yield]~ ;

ReturnStatement~[Yield]~ :

RETURN [no LineTerminator here] Expression ;
RETURN [no LineTerminator here] Expression~[In,\ ?Yield]~ ;

ThrowStatement~[Yield]~ :

THROW [no LineTerminator here] Expression~[In,\ ?Yield]~ ;

_ArrowFunction_~[In,\ Yield]~ :

_ArrowParameters_~[?Yield]~ [no LineTerminator here] =>
_ConciseBody_~[?In]~

YieldExpression~[In]~ :

YIELD [no LineTerminator here] * [Lexical goal InputElementRegExp]
AssignmentExpression~[?In,\ Yield]~
YIELD [no LineTerminator here] [Lexical goal InputElementRegExp]
AssignmentExpression~[?In,\ Yield]~

ModuleImport :

MODULE [no LineTerminator here] ImportedBinding FromClause ;

The practical effect of these restricted productions is as follows:

  When a ++ or -- token is encountered where the parser would treat it
  as a postfix operator, and at least one _LineTerminator_ occurred
  between the preceding token and the ++ or -- token, then a semicolon
  is automatically inserted before the ++ or -- token.

  When a CONTINUE, BREAK, RETURN, THROW, or YIELD token is encountered
  and a _LineTerminator_ is encountered before the next token, a
  semicolon is automatically inserted after the CONTINUE, BREAK, RETURN,
  THROW, or YIELD token.

The resulting practical advice to ECMAScript programmers is:

  A postfix ++ or -- operator should appear on the same line as its
  operand.

  An _Expression_ in a RETURN or THROW statement or an
  _AssignmentExpression_ in a YIELD expression should start on the same
  line as the RETURN, THROW, or YIELD token.

  An _IdentifierReference_ in a BREAK or CONTINUE statement should be on
  the same line as the BREAK or CONTINUE token.

Examples of Automatic Semicolon Insertion

The source

  { 1 2 } 3

is not a valid sentence in the ECMAScript grammar, even with the
automatic semicolon insertion rules. In contrast, the source

  { 1
  2 } 3

is also not a valid ECMAScript sentence, but is transformed by automatic
semicolon insertion into the following:

  { 1
  ;2 ;} 3;

which is a valid ECMAScript sentence.

The source

  for (a; b
  )

is not a valid ECMAScript sentence and is not altered by automatic
semicolon insertion because the semicolon is needed for the header of a
FOR statement. Automatic semicolon insertion never inserts one of the
two semicolons in the header of a FOR statement.

The source

  return
  a + b

is transformed by automatic semicolon insertion into the following:

  return;
  a + b;

NOTE The expression A + B is not treated as a value to be returned by
the RETURN statement, because a _LineTerminator_ separates it from the
token RETURN.

The source

  a = b
  ++c

is transformed by automatic semicolon insertion into the following:

  a = b;
  ++c;

NOTE The token ++ is not treated as a postfix operator applying to the
variable B, because a _LineTerminator_ occurs between B and ++.

The source

  if (a > b)
  else c = d

is not a valid ECMAScript sentence and is not altered by automatic
semicolon insertion before the ELSE token, even though no production of
the grammar applies at that point, because an automatically inserted
semicolon would then be parsed as an empty statement.

The source

  a = b + c
  (d + e).print()

is _not_ transformed by automatic semicolon insertion, because the
parenthesized expression that begins the second line can be interpreted
as an argument list for a function call:

a = b + c(d + e).print()

In the circumstance that an assignment statement must begin with a left
parenthesis, it is a good idea for the programmer to provide an explicit
semicolon at the end of the preceding statement rather than to rely on
automatic semicolon insertion.



ECMASCRIPT LANGUAGE: EXPRESSIONS 


Identifiers

SYNTAX

IdentifierReference~[Yield]~ :

Identifier
[~Yield] YIELD

_BindingIdentifier_~[Default,\ Yield]~ :

  [+Default] DEFAULT
  [~Yield] YIELD_
  Identifier_

LabelIdentifier~[Yield]~ :

_Identifier
[~Yield] YIELD

Identifier :

IdentifierName BUT NOT ReservedWord

Static Semantics: Early Errors

-   

_BindingIdentifier_ : _Identifier

-   It is a Syntax Error if this production is contained in strict code
    and the StringValue of _Identifier_ is "ARGUMENTS" or "EVAL".

_IdentifierReference_~[Yield]~ : _Identifier

_BindingIdentifier_~[Default,\ Yield]~ : _Identifier

_LabelIdentifier_ ~[Yield]~ : _Identifier

-   It is a Syntax Error if this production has a ~[Yield]~ parameter
    and the StringValue of _Identifier_ is "YIELD".

_IdentifierReference_ : YIELD

_BindingIdentifier_ : YIELD

_LabelIdentifier_ : YIELD

-   It is a Syntax Error if this production is contained in strict
    code_._

-   It is a Syntax Error if this production is within the _FunctionBody_
    of a _GeneratorMethod, GeneratorDeclaration,_ or
    _GeneratorExpression_.

_Identifier_ :: _IdentifierName_ BUT NOT _ReservedWord

-   It is a Syntax Error if this production is contained in strict code
    and the StringValue of _IdentifierName_ is: "IMPLEMENTS",
    "INTERFACE", "LET", "PACKAGE", "PRIVATE", "PROTECTED", "PUBLIC", or
    "STATIC".

-   It is a Syntax Error if this production is contained in strict code
    and the StringValue of _IdentifierName_ is "YIELD".

-   It is a Syntax Error if StringValue of _IdentifierName_ is the same
    string value as the StringValue of any _ReservedWord_ except for
    YIELD.

NOTE StringValue of _IdentifierName_ normalizes any Unicode escape
sequences in _IdentifierName_ hence such escapes cannot be used to write
an _Identifier_ whose code point sequence is the same as a
_ReservedWord_.

Static Semantics: BoundNames

See also: 13.2.1.2, 13.2.2.1, 13.6.4.2, 14.1.3, 14.2.2, 14.4.2, 14.5.2,
15.2.1.2, 15.2.2.1.

_BindingIdentifier_ : _Identifier

1.  Return a new List containing the StringValue of _Identifier_.

_BindingIdentifier_ : YIELD

1.  Return a new List containing "YIELD".

_BindingIdentifier_ : DEFAULT

1.  Return a new List containing "DEFAULT".

Static Semantics: StringValue

See also: 11.6.1.2, 11.8.4.2.

_IdentifierReference_ : YIELD

_BindingIdentifier_ : YIELD

_LabelIdentifier_ : YIELD

1.  Return "YIELD".

_BindingIdentifier_ : DEFAULT

1.  Return "DEFAULT".

_Identifier_ : _IdentifierName_ BUT NOT _ReservedWord

1.  Return the StringValue of _IdentifierName_.

Runtime Semantics: BindingInitialization

  With arguments _value_ and _environment_.

See also: 12.2.4.2.2, 13.2.2.4, 13.2.3.5, 13.14.4.

NOTE UNDEFINED is passed for _environment_ to indicate that a PutValue
operation should be used to assign the initialization value. This is the
case for VAR statements and formal parameter lists of some non-strict
functions (See 9.2.13). In those cases a lexical binding is hoisted and
preinitialized prior to evaluation of its initializer.

_BindingIdentifier_ _:_ _Identifier

1.  Let _name_ be StringValue of _Identifier_.

2.  Return InitializeBoundName( _name_, _value_, _environment_).

_BindingIdentifier_ : DEFAULT

1.  Return InitializeBoundName("DEFAULT", _value_, _environment_).

_BindingIdentifier_ : YIELD

1.  Return InitializeBoundName("YIELD", _value_, _environment_).

Runtime Semantics: InitializeBoundName(name, value, environment)

1.  Assert: Type(_name_) is String.

2.  If _environment_ is not UNDEFINED, then

    a.  Let _env_ be the environment record component of _environment_.

    b.  Call the InitializeBinding concrete method of _env_ passing
        _name_ and _value_ as the arguments.

    c.  Return NormalCompletion(UNDEFINED).

3.  Else

    a.  Let _lhs_ be ResolveBinding(_name_).

    b.  Return PutValue(_lhs_, _value_).

Runtime Semantics: Evaluation

_IdentifierReference_ : _Identifier

1.  Return ResolveBinding(StringValue(_Identifier_)).

_IdentifierReference_ : YIELD

1.  Return ResolveBinding("YIELD").

NOTE 1: The result of evaluating an _IdentifierReference_ is always a
value of type Reference.

NOTE 2: In non-strict code, the keyword YIELD may be used as an
identifier. Evaluating the _IdentifierReference_ production resolves the
binding of YIELD as if it was an _Identifier_. Early Error restriction
ensures that such an evaluation only can occur for non-strict code. See
13.2.1 for the handling of YIELD in binding creation contexts.


Primary Expression

Syntax

PrimaryExpression~[Yield]~ :

THIS
IdentifierReference~[?Yield]~
Literal
ArrayInitializer~[?Yield]~
ObjectLiteral~[?Yield]~
FunctionExpression
ClassExpression
GeneratorExpression
GeneratorComprehension~[?Yield]~
RegularExpressionLiteral
TemplateLiteral~[?Yield]~
CoverParenthesizedExpressionAndArrowParameterList~[?Yield]~

CoverParenthesizedExpressionAndArrowParameterList~[Yield]~ :

( Expression~[In,\ ?Yield]~ )
( )
( ... BindingIdentifier~[?Yield]~ )
( Expression~[In,\ ?Yield]~ , ... BindingIdentifier~[?Yield]~ )

Supplemental Syntax

When processing the production

_PrimaryExpression_~[Yield]~ :
_CoverParenthesizedExpressionAndArrowParameterList_~[?Yield]~
_the interpretation of
_CoverParenthesizedExpressionAndArrowParameterList_ is refined using the
following grammar:

_ParenthesizedExpression_~[Yield]~ :

( Expression~[In,\ ?Yield]~ )

Semantics

Static Semantics: CoveredParenthesizedExpression

CoverParenthesizedExpressionAndArrowParameterList~[Yield]~ : (
Expression~[In,\ ?Yield]~ )

1.  Return the result of parsing the lexical token stream matched by
    _CoverParenthesizedExpressionAndArrowParameterList_~[Yield]~ using
    either _ParenthesizedExpression_ or
    _ParenthesizedExpression_~[Yield]~ as the goal symbol depending upon
    whether the ~[Yield]~ grammar parameter was present when
    _CoverParenthesizedExpressionAndArrowParameterList_ was matched.

Static Semantics: IsFunctionDefinition

See also: 12.2.10.2, 12.3.1.2, 12.4.2, 12.5.2, 12.6.1, 12.7.1, 12.8.1,
12.9.1, 12.10.1, 12.11.1, 12.12.1, 12.13.1, 12.14.2, 12.15.1, 14.1.11,
14.4.8, 14.5.8.

PrimaryExpression :

THIS
IdentifierReference
Literal
ArrayInitializer
ObjectLiteral
GeneratorComprehension
RegularExpressionLiteral
TemplateLiteral

1.  Return FALSE.

_PrimaryExpression_ :
_CoverParenthesizedExpressionAndArrowParameterList

1.  Let _expr_ be CoveredParenthesizedExpression of
    _CoverParenthesizedExpressionAndArrowParameterList_.

2.  Return IsFunctionDefinition of _expr_.

Static Semantics: IsIdentifierRef

See also: 12.3.1.3.

PrimaryExpression :

IdentifierReference

1.  Return TRUE.

PrimaryExpression :

THIS
Literal
ArrayInitializer
ObjectLiteral
FunctionExpression
ClassExpression
GeneratorExpression
GeneratorComprehension
RegularExpressionLiteral
TemplateLiteral
CoverParenthesizedExpressionAndArrowParameterList

1.  Return FALSE.

Static Semantics: IsValidSimpleAssignmentTarget

See also: 12.2.10.3, 12.3.1.3, 12.4.3, 12.5.3, 12.6.2, 12.7.2, 12.8.2,
12.9.2, 12.10.2, 12.11.2, 12.12.2, 12.13.2, 12.14.3, 12.15.2.

PrimaryExpression :

THIS
Literal
ArrayInitializer
ObjectLiteral
FunctionExpression
ClassExpression
GeneratorExpression
GeneratorComprehension
RegularExpressionLiteral
TemplateLiteral

1.  Return FALSE.

_PrimaryExpression_ : _IdentifierReference

1.  If this _PrimaryExpression_ is contained in strict code and
    StringValue of _IdentifierReference_ is "EVAL" or "ARGUMENTS", then
    return FALSE.

2.  Return TRUE.

_PrimaryExpression_ :
_CoverParenthesizedExpressionAndArrowParameterList

1.  Let _expr_ be CoveredParenthesizedExpression of
    _CoverParenthesizedExpressionAndArrowParameterList_.

2.  Return IsValidSimpleAssignmentTarget of _expr_.

The this Keyword

Runtime Semantics: Evaluation

_PrimaryExpression_ : THIS

1.  Return ResolveThisBinding( ) .

Identifier Reference

See 12.1 for _PrimaryExpression_ : _IdentifierReference_.

1.  

Literals 

Syntax

Literal :

NullLiteral
ValueLiteral

ValueLiteral :

BooleanLiteral
NumericLiteral
StringLiteral

Runtime Semantics: Evaluation

_Literal_ : _NullLiteral

1.  Return NULL.

_ValueLiteral_ : _BooleanLiteral

1.  Return FALSE if _BooleanLiteral_ is the token FALSE.

2.  Return TRUE if _BooleanLiteral_ is the token TRUE.

_ValueLiteral_ : _NumericLiteral

1.  Return the number whose value is MV of _NumericLiteral_ as defined
    in 11.8.3.

_ValueLiteral_ _: StringLiteral

1.  Return the StringValue of _StringLiteral_ as defined in 11.8.4.2.

Array Initializer

Syntax

ArrayInitializer~[Yield]~ :

ArrayLiteral~[?Yield]~
ArrayComprehension~[?Yield]~

Array Literal

NOTE An _ArrayLiteral_ is an expression describing the initialization of
an Array object, using a list, of zero or more expressions each of which
represents an array element, enclosed in square brackets. The elements
need not be literals; they are evaluated each time the array initializer
is evaluated.

Array elements may be elided at the beginning, middle or end of the
element list. Whenever a comma in the element list is not preceded by an
_AssignmentExpression_ (i.e., a comma at the beginning or after another
comma), the missing array element contributes to the length of the Array
and increases the index of subsequent elements. Elided array elements
are not defined. If an element is elided at the end of an array, that
element does not contribute to the length of the Array.

Syntax

ArrayLiteral~[Yield]~ :

[ Elision~opt~ ]
[ ElementList~[?Yield]~ ]
[ ElementList~[?Yield]~ , Elision~opt~ ]

ElementList~[Yield]~ :

Elision~opt~ AssignmentExpression~[In,\ ?Yield]~
Elision~opt~ SpreadElement~[?Yield]~
ElementList~[?Yield]~ , Elision~opt~ AssignmentExpression~[In,\ ?Yield]~
ElementList~[?Yield]~ , Elision~opt~ SpreadElement~[?Yield]~

Elision :

,
Elision ,

SpreadElement~[Yield]~ :

... AssignmentExpression~[In,\ ?Yield]~

Static Semantics: ElisionWidth

_Elision_ : ,

1.  Return the numeric value 1.

_Elision_ : _Elision_ ,

1.  Let _preceding_ be the ElisionWidth of _Elision_.

2.  Return _preceding_+1.

Runtime Semantics: ArrayAccumulation

  With parameters _array_ and _nextIndex_.

_ElementList_ : _Elision_~opt~ _AssignmentExpression

1.  Let _padding_ be the ElisionWidth of _Elision_; if _Elision_ is not
    present, use the numeric value zero.

2.  Let _initResult_ be the result of evaluating _AssignmentExpression_.

3.  Let _initValue_ be GetValue(_initResult_).

4.  ReturnIfAbrupt(_initValue_).

5.  Let _created_ be the result of calling the [[DefineOwnProperty]]
    internal method of _array_ with arguments
    ToString(ToUint32(_nextIndex+padding_)) and the PropertyDescriptor{
    [[Value]]: _initValue_, [[Writable]]: TRUE, [[Enumerable]]: TRUE,
    [[Configurable]]: TRUE}.

6.  Assert: _created_ is TRUE_.

7.  Return _nextIndex+padding+_1.

_ElementList_ : _Elision_~opt~ _SpreadElement

1.  Let _padding_ be the ElisionWidth of _Elision_; if _Elision_ is not
    present, use the numeric value zero.

2.  Return the result of performing ArrayAccumulation for
    _SpreadElement_ with arguments _array_ and _nextIndex_+_padding_.

_ElementList_ : _ElementList_ , _Elision_~opt~ _AssignmentExpression

1.  Let _postIndex_ be the result of performing ArrayAccumulation for
    _ElementList_ with arguments _array_ and _nextIndex_.

2.  ReturnIfAbrupt(_postIndex_).

3.  Let _padding_ be the ElisionWidth of _Elision_; if _Elision_ is not
    present, use the numeric value zero.

4.  Let _initResult_ be the result of evaluating _AssignmentExpression_.

5.  Let _initValue_ be GetValue(_initResult_).

6.  ReturnIfAbrupt(_initValue_).

7.  Let _created_ be the result of calling the [[DefineOwnProperty]]
    internal method of _array_ with arguments
    ToString(ToUint32(_postIndex_+_padding_)) and the
    PropertyDescriptor{ [[Value]]: _initValue_, [[Writable]]: TRUE,
    [[Enumerable]]: TRUE, [[Configurable]]: TRUE}.

8.  Assert: _created_ is TRUE.

9.  Return _postIndex_+_padding+_1.

_ElementList_ : _ElementList_ , _Elision_~opt~ _SpreadElement

1.  Let _postIndex_ be the result of performing ArrayAccumulation for
    _ElementList_ with arguments _array_ and _nextIndex_.

2.  ReturnIfAbrupt(_postIndex_).

3.  Let _padding_ be the ElisionWidth of _Elision_; if _Elision_ is not
    present, use the numeric value zero.

4.  Return the result of performing ArrayAccumulation for
    _SpreadElement_ with arguments _array_ and _postIndex_+_padding_.

_SpreadElement_ : ... _AssignmentExpression

1.  Let _spreadRef_ be the result of evaluating _AssignmentExpression_.

2.  Let _spreadObj_ be ToObject(GetValue(_spreadRef_)).

3.  4.  5.  Let _iterator_ be GetIterator(_spreadObj_).

6.  ReturnIfAbrupt(_iterator_).

7.  Repeat

    a.  Let _next_ be IteratorStep(_iterator_).

    b.  ReturnIfAbrupt(_next_).

    c.  If _next_ is FALSE, then return _nextIndex_.

    d.  Let _nextValue_ be IteratorValue(_next_).

    e.  ReturnIfAbrupt(_nextValue_).

    f.  Let _defineStatus_ be CreateDataPropertyOrThrow(_array_,
        ToString(ToUint32(_nextIndex_)), _nextValue_).

    g.  ReturnIfAbrupt(_defineStatus_).

    h.  Let _nextIndex_ be _nextIndex_ + 1.

NOTE [[DefineOwnProperty]] is used to ensure that own properties are
defined for the array even if the standard built-in Array prototype
object has been modified in a manner that would preclude the creation of
new own properties using [[Set]].

Runtime Semantics: Evaluation

_ArrayLiteral_ : [ _Elision_~opt~ ]

1.  Let _array_ be ArrayCreate(0).

2.  Let _pad_ be the ElisionWidth of _Elision_; if _Elision_ is not
    present, use the numeric value zero.

3.  Perform Put(_array_, "LENGTH", _pad_, FALSE).

4.  Return _array_.

_ArrayLiteral_ : [ _ElementList_ ]

1.  Let _array_ be ArrayCreate(0).

2.  Let _len_ be the result of performing ArrayAccumulation for
    _ElementList_ with arguments _array_ and 0.

3.  ReturnIfAbrupt(_len_).

4.  Perform Put(_array_, "LENGTH", _len_, FALSE).

5.  Return _array_.

_ArrayLiteral_ : [ _ElementList_ , _Elision_~opt~ ]

1.  Let _array_ be ArrayCreate(0).

2.  Let _len_ be the result of performing ArrayAccumulation for
    _ElementList_ with arguments _array_ and 0.

3.  ReturnIfAbrupt(_len_).

4.  Let _padding_ be the ElisionWidth of _Elision_; if _Elision_ is not
    present, use the numeric value zero.

5.  Perform Put(_array_, "LENGTH", ToUint32(_padding_+_len_), FALSE).

6.  Return _array_.

Array Comprehension

Syntax

ArrayComprehension~[Yield]~ :

[ Comprehension~[?Yield]~ ]

Comprehension~[Yield]~ :

ComprehensionFor~[?Yield]~ ComprehensionTail~[?Yield]~

ComprehensionTail~[Yield]~ :

AssignmentExpression~[In,\ ?Yield]~
ComprehensionFor~[?Yield]~ ComprehensionTail~[?Yield]~
ComprehensionIf~[?Yield]~ ComprehensionTail~[?Yield]~

ComprehensionFor~[Yield]~ :

FOR ( ForBinding~[?Yield]~ OF AssignmentExpression~[In,\ ?Yield]~ )

ComprehensionIf~[Yield]~ :

IF ( AssignmentExpression~[In,\ ?Yield]~ )

ForBinding~[Yield]~ :

BindingIdentifier~[?Yield]~
BindingPattern~[?Yield]~

Static Semantics: Early Errors

_ComprehensionFor_ : FOR ( _ForBinding_ OF _AssignmentExpression_ )

-   It is a Syntax Error if the BoundNames of _ForBinding_ contains
    "LET".

_ForBinding_ : _BindingPattern

-   It is a Syntax Error if the BoundNames of _BindingPattern_ contains
    any duplicate entries.

Runtime Semantics: BindingInitialization

  With arguments _value_ and _environment_.

See also: 12.1.4, 13.2.2.4, 13.2.3.5, 13.14.4.

NOTE UNDEFINED is passed for _environment_ to indicate that a PutValue
operation should be used to assign the initialization value. This is the
case for VAR statements and the formal parameter lists of some
non-strict functions (see 9.2.13). In those cases a lexical binding is
hoisted and preinitialized prior to evaluation of its initializer.

_ForBinding_ : _BindingPattern

1.  If Type(_value_) is not Object, then throw a TYPEERROR exception.

2.  Return the result of performing BindingInitialization for
    _BindingPattern_ passing _value_ and _environment_ as the arguments.

Runtime Semantics: ComprehensionEvaluation 

  With argument _accumulator_.

NOTE UNDEFINED is passed for _accumulator_ to indicate that a
comprehension component is being evaluated as part of a generator
comprehension. Otherwise, the value of _accumulator_ is the array object
into which the elements of an array comprehension are to be accumulated.

_Comprehension_ : _ComprehensionFor_ _ComprehensionTail

1.  Return the result of performing ComprehensionComponentEvaluation for
    _ComprehensionFor_ with arguments _ComprehensionTail_ and
    _accumulator_.

_ComprehensionTail_: _ComprehensionFor_ _ComprehensionTail

1.  Return the result of performing ComprehensionComponentEvaluation for
    _ComprehensionFor_ with arguments _ComprehensionTail_ and
    _accumulator_.

_ComprehensionTail_: _ComprehensionIf_ _ComprehensionTail

1.  Return the result of performing ComprehensionComponentEvaluation for
    _ComprehensionIf_ with arguments _ComprehensionTail_ and
    _accumulator_.

_ComprehensionTail_: _AssignmentExpression

1.  Let _valueRef_ be the result of evaluating _AssignmentExpression_.

2.  Let _value_ be GetValue(_valueRef_).

3.  ReturnIfAbrupt(_value_).

4.  If _accumulator_ is not UNDEFINED, then

    a.  Assert: this is part of an array comprehension.

    b.  Assert: _accumulator_ is an exotic array object so access to its
        LENGTH property should never fail.

    c.  Let _len_ be Get(_accumulator_, "LENGTH").

    d.  If _len_≥2^32^-1, then throw a RANGEERROR exception.

    e.  Let _putStatus_ be Put(_accumulator_, ToString(_len_), _value_,
        TRUE).

    f.  ReturnIfAbrupt(_putStatus_).

    g.  Increase _len_ by 1.

    h.  Let _putStatus_ be Put(_accumulator_, "LENGTH", _len_, TRUE).

    i.  ReturnIfAbrupt(_putStatus_).

    j.  Return NormalCompletion(UNDEFINED).

5.  Assert: _accumulator_ is UNDEFINED, so this is part of a generator
    comprehension.

6.  Let _yieldStatus_ be GeneratorYield(CreateIterResultObject(_value_,
    FALSE)).

7.  ReturnIfAbrupt(_yieldStatus_).

8.  Return NormalCompletion(UNDEFINED).

Runtime Semantics: ComprehensionComponentEvaluation 

  With arguments _tail_ and _accumulator_.

NOTE UNDEFINED is passed for _accumulator_ to indicate that a
comprehension component is being evaluated as part of a generator
comprehension. Otherwise, the value of _accumulator_ is the array object
into which the elements of an array comprehension are to be accumulated.

_ComprehensionFor_ : FOR ( _ForBinding_ OF _AssignmentExpression_ )

1.  Let _exprRef_ be the result of evaluating _AssignmentExpression_.

2.  Let _exprValue_ be GetValue(_exprRef_).

3.  4.  5.  6.  Let _keys_ be GetIterator(ToObject(_exprValue_)).

7.  ReturnIfAbrupt(_keys_).

8.  Let _oldEnv_ be the running execution context’s LexicalEnvironment.

9.  Repeat

    a.  Let _nextResult_ be IteratorStep(_keys_).

    b.  ReturnIfAbrupt(_nextResult_).

    c.  If _nextResult_ is FALSE, then return
        NormalCompletion(UNDEFINED).

    d.  Let _nextValue_ be IteratorValue(_nextResult_);

    e.  ReturnIfAbrupt(_nextValue_).

    f.  Let _forEnv_ be NewDeclarativeEnvironment(_oldEnv_).

    g.  For each element _name_ of the BoundNames of _ForBinding_ do

        i.  Call _forEnv_’s CreateMutableBinding concrete method with
            argument _name_.

        ii. Assert: The above call to CreateMutableBinding will never
            return an abrupt completion.

    h.  Let _status_ be the result of performing BindingInitialization
        for _ForBinding_ passing _nextValue_ and _forEnv_ as the
        arguments.

    i.  ReturnIfAbrupt(_status_).

    j.  Set the running execution context’s LexicalEnvironment to
        _forEnv_.

    k.  Let _continue_ be the result of performing
        ComprehensionEvaluation for _tail_ with argument _accumulator_.

    l.  Set the running execution context’s LexicalEnvironment to
        _oldEnv_.

    m.  ReturnIfAbrupt(_continue_).

_ComprehensionIf_ : IF ( _AssignmentExpression_ )

1.  Let _valueRef_ be the result of evaluating _AssignmentExpression_.

2.  Let _value_ be GetValue(_valueRef_).

3.  Let _boolValue_ be ToBoolean(_value_).

4.  ReturnIfAbrupt(_boolValue_).

5.  If _boolValue_ is TRUE, then

    a.  Return the result of performing ComprehensionEvaluation for
        _tail_ with argument _accumulator_.

6.  Else,

    a.  Return NormalCompletion(UNDEFINED).

Runtime Semantics: Evaluation

_ArrayComprehension_ : [ _Comprehension_ ]

1.  Let _array_ be ArrayCreate(0).

2.  Let _status_ be the result of performing ComprehensionEvaluation for
    _Comprehension_ with argument _array_.

3.  ReturnIfAbrupt(_status_).

4.  Return _array_.

_Comprehension_ : _ComprehensionFor_ _ComprehensionTail

1.  Return the result of performing ComprehensionEvaluation for this
    _Comprehension_ with argument UNDEFINED.

NOTE This action is only invoked for a _Comprehension_ that is part of a
_GeneratorComprehension_.

Object Initializer

NOTE 1 An object initializer is an expression describing the
initialization of an Object, written in a form resembling a literal. It
is a list of zero or more pairs of property names and associated values,
enclosed in curly braces. The values need not be literals; they are
evaluated each time the object initializer is evaluated.

Syntax

ObjectLiteral~[Yield]~ :

{ }
{ PropertyDefinitionList~[?Yield]~ }
{ PropertyDefinitionList~[?Yield]~ , }

PropertyDefinitionList~[Yield]~ :

PropertyDefinition~[?Yield]~
PropertyDefinitionList~[?Yield]~ , PropertyDefinition~[?Yield]~

PropertyDefinition~[Yield]~ :

IdentifierReference~[?Yield]~
CoverInitializedName~[?Yield]~
PropertyName~[?Yield]~ : AssignmentExpression~[In,\ ?Yield]~
MethodDefinition~[?Yield]~

PropertyName~[Yield,GeneratorParameter]~ :

LiteralPropertyName
[+GeneratorParameter] ComputedPropertyName
[~GeneratorParameter] ComputedPropertyName~[?Yield]~

LiteralPropertyName :

IdentifierName
StringLiteral
NumericLiteral

ComputedPropertyName~[Yield]~ :

[ AssignmentExpression~[In,\ ?Yield]~ ]

CoverInitializedName~[Yield]~ :

IdentifierReference~[?Yield]~ Initializer~[In,\ ?Yield]~

Initializer~[In,\ Yield]~ :

= AssignmentExpression~[?In,\ ?Yield]~

NOTE 2 _MethodDefinition_ is defined in 14.3.

NOTE 3 In certain contexts, _ObjectLiteral_ is used as a cover grammar
for a more restricted secondary grammar. The _CoverInitializedName_
production is necessary to fully cover these secondary grammars.
However, use of this production results in an early Syntax Error in
normal contexts where an actual _ObjectLiteral_ is expected.

Static Semantics: Early Errors

In addition to describing an actual object initializer the
_ObjectLiteral_ productions are also used as a cover grammar for
_ObjectAssignmentPattern_ (12.14.5). and may be recognized as part of a
_CoverParenthesizedExpressionAndArrowParameterList_. When
_ObjectLiteral_ appears in a context where _ObjectAssignmentPattern_ is
required the following Early Error rules are NOT applied. In addition,
they are not applied when initially parsing a
_CoverParenthesizedExpressionAndArrowParameterList.

-   1.  2.  

_PropertyDefinition_ : _CoverInitializedName

-   Always throw a Syntax Error if this production is present

NOTE This production exists so that _ObjectLiteral_ can serve as a cover
grammar for _ObjectAssignmentPattern_ (12.14.5). It cannot occur in an
actual object initializer.

Static Semantics: ComputedPropertyContains

  With parameter _symbol_.

See also: 14.3.2, 14.4.3, 14.5.5.

_PropertyName_ : _LiteralPropertyName

1.  Return FALSE.

_PropertyName_ : _ComputedPropertyName

1.  Return the result of _ComputedPropertyName_ Contains _symbol_.

Static Semantics: Contains

  With parameter _symbol_.

See also: 5.3, 12.3.1.1, 14.1.4, 14.2.3, 14.4.3, 14.5.4

_PropertyDefinition_ : _MethodDefinition

1.  If _symbol_ is _MethodDefinition_, return TRUE.

2.  Return the result of ComputedPropertyContains for _MethodDefinition
    with argument _symbol_.

NOTE Static semantic rules that depend upon substructure generally do
not look into function definitions.

_LiteralPropertyName_ : _IdentifierName

1.  If _symbol_ is a _ReservedWord_, return FALSE.

2.  If _symbol_ is an _Identifier_ and StringValue of _symbol_ is the
    same value as the StringValue of _IdentifierName_, return TRUE;

3.  Return FALSE.

Static Semantics: HasComputedPropertyKey

See also: 14.3.4, 14.4.5

_PropertyDefinitionList_ : _PropertyDefinitionList_ ,
_PropertyDefinition

1.  If HasComputedPropertyKey of _PropertyDefinitionList_ is TRUE, then
    return TRUE.

2.  Return HasComputedPropertyKey of _PropertyDefinition_.

_PropertyDefinition_ : _IdentifierReference

1.  Return FALSE.

_PropertyDefinition_ : _PropertyName_ : _AssignmentExpression

1.  Return IsComputedPropertyKey of _PropertyName_.

Static Semantics: IsComputedPropertyKey

_PropertyName_ : _LiteralPropertyName

1.  Return FALSE.

_PropertyName_ : _ComputedPropertyName

1.  Return TRUE.

Static Semantics: PropName

See also: 14.3.5, 14.4.9, 14.5.12

_PropertyDefinition_ : _IdentifierReference

1.  Return StringValue of _IdentifierReference_.

_PropertyDefinition_ : _PropertyName_ : _AssignmentExpression

1.  Return PropName of _PropertyName_.

_LiteralPropertyName_ : _IdentifierName

1.  Return StringValue of _IdentifierName_.

_LiteralPropertyName_ : _StringLiteral

1.  Return a String value whose code units are the SV of the
    _StringLiteral_.

_LiteralPropertyName_ : _NumericLiteral

1.  Let _nbr_ be the result of forming the value of the
    _NumericLiteral_.

2.  Return ToString(_nbr_).

_ComputedPropertyName_ : [ _AssignmentExpression_ ]

1.  Return empty.

Static Semantics: PropertyNameList

_PropertyDefinitionList_ : _PropertyDefinition

1.  If PropName of _PropertyDefinition_ is empty, return a new empty
    List.

2.  Return a new List containing PropName of _PropertyDefinition_.

_PropertyDefinitionList_ : _PropertyDefinitionList_ ,
_PropertyDefinition

1.  Let _list_ be PropertyNameList of _PropertyDefinitionList.

2.  If PropName of _PropertyDefinition_ is empty, return _list_.

3.  Append PropName of _PropertyDefinition_ to the end of _list_.

4.  Return _list_.

Runtime Semantics: Evaluation

_ObjectLiteral_ : { }

1.  Return ObjectCreate(%ObjectPrototype%).

_ObjectLiteral_ :

 { _PropertyDefinitionList_ }_
_ { _PropertyDefinitionList_ , }

1.  Let _obj_ be ObjectCreate(%ObjectPrototype%).

2.  Let _status_ be the result of performing
    PropertyDefinitionEvaluation of _PropertyDefinitionList_ with
    argument _obj_.

3.  ReturnIfAbrupt(_status_).

4.  Return _obj_.

1.  

1.  

_LiteralPropertyName_ : _IdentifierName

1.  Return StringValue of _IdentifierName_.

_LiteralPropertyName_ : _StringLiteral

1.  Return a String value whose code units are the SV of the
    _StringLiteral_.

_LiteralPropertyName_ : _NumericLiteral

1.  Let _nbr_ be the result of forming the value of the
    _NumericLiteral_.

2.  Return ToString(_nbr_).

_ComputedPropertyName_ : [ _AssignmentExpression_ ]

1.  Let _exprValue_ be the result of evaluating _AssignmentExpression_.

2.  Let _propName_ be GetValue(_exprValue_).

3.  ReturnIfAbrupt(_propName_).

4.  Return ToPropertyKey(_propName_).

Runtime Semantics: PropertyDefinitionEvaluation

  With parameter _object_.

See also: 14.3.9, 14.4.13, B.3.1

_PropertyDefinitionList_ : _PropertyDefinitionList_ ,
_PropertyDefinition

1.  Let _status_ be the result of performing
    PropertyDefinitionEvaluation of _PropertyDefinitionList_ with
    argument _object_.

2.  ReturnIfAbrupt(_status_).

3.  Return the result of performing PropertyDefinitionEvaluation of
    _PropertyDefinition_ with argument _object_.

4.  5.  6.  7.  

_PropertyDefinition_ : _IdentifierReference

1.  Let _propName_ be StringValue of _IdentifierReference_.

2.  Let _exprValue_ be the result of evaluating _IdentifierReference_.

3.  ReturnIfAbrupt(_exprValue_).

4.  Let _propValue_ be GetValue(_exprValue_).

5.  ReturnIfAbrupt(_propValue_).

6.  Let _desc_ be the Property Descriptor{[[Value]]: _propValue_,
    [[Writable]]: TRUE, [[Enumerable]]: TRUE, [[Configurable]]: TRUE}

7.  Return DefinePropertyOrThrow(_object_, _propName_, _desc_).

_PropertyDefinition_ : _PropertyName_ : _AssignmentExpression

1.  Let _propKey_ be the result of evaluating _PropertyName_.

2.  ReturnIfAbrupt(_propKey_).

3.  Let _exprValueRef_ be the result of evaluating
    _AssignmentExpression_.

4.  Let _propValue_ be GetValue(_exprValueRef_).

5.  ReturnIfAbrupt(_propValue_).

6.  If IsFunctionDefinition of _AssignmentExpression_ is TRUE, then

    a.  Assert: _propValue_ is an ECMAScript function object.

    b.  Let _referencesSuper_ be the value of _propValue_’s
        [[NeedsSuper]] internal slot.

    c.  Let _thisMode_ be the value of _propValue_’s [[ThisMode]]
        internal slot.

    d.  If _thisMode_ is not lexical and _referencesSuper_ is TRUE, then

        i.  If _propValue_’s [[HomeObject]] internal slot is UNDEFINED,
            then

            1.  Assert: _AssignmentExpression_ is not a class definition
                whose constructor references SUPER.

            2.  Set _propValue_’s [[HomeObject]] internal slot to
                _object_.

            3.  Set _propValue_’s [[MethodName]] internal slot to
                _propKey_.

    e.  If IsAnonymousFunctionDefinition(_AssignmentExpression_) is
        TRUE, then

        i.  SetFunctionName(_propValue_, _propKey_).

        ii. Assert: SetFunctionName will not return an abrupt
            completion.

7.  Let _desc_ be the Property Descriptor{[[Value]]: _propValue_,
    [[Writable]]: TRUE, [[Enumerable]]: TRUE, [[Configurable]]: TRUE}

8.  Return DefinePropertyOrThrow(_object_, _propKey_, _desc_).

_NOTE An alternative semantics for this production is given in B.3.1.

Function Defining Expressions

See 14.1 for _PrimaryExpression_ : _FunctionExpression_.

See 14.4 for _PrimaryExpression_ : _GeneratorExpression_.

See 14.5 for _PrimaryExpression_ : _ClassExpression_.

Generator Comprehensions

Syntax

GeneratorComprehension~[Yield]~ :

( Comprehension~[?Yield]~ )

NOTE The keyword YIELD may be used in _IdentifierReference_ contexts
within a _GeneratorComprehension_ contained in non-strict code. The
following early error rule ensures that a _GeneratorComprehension_ never
contains a _YieldExpression_.

Static Semantics: Early Errors

_GeneratorComprehension_ : ( _Comprehension_ )

-   It is a Syntax Error if _Comprehension_ Contains _YieldExpression_
    is TRUE.

Runtime Semantics: Evaluation

_GeneratorComprehension_ : ( _Comprehension_ )

1.  If _GeneratorComprehension_ is contained in strict mode code, then
    let _strict_ be TRUE; otherwise let _strict_ be FALSE.

2.  Let _scope_ be the LexicalEnvironment of the running execution
    context.

3.  Let _parameters_ be the production: _FormalParameters_ : [empty].

4.  Using _Comprehension_ from the production that is being evaluated,
    let _body_ be the supplemental syntactic grammar production:
    _GeneratorBody_ : _Comprehension_.

5.  Let _closure_ be GeneratorFunctionCreate(Arrow, _parameters_, _body,
    scope_, _strict_).

6.  Let _prototype_ be ObjectCreate(%GeneratorPrototype%).

7.  Perform MakeConstructor(_closure_, TRUE, and _prototype_).

8.  Let _iterator_ be the result of calling the [[Call]] internal method
    of _closure_ with UNDEFINED as _thisArgument_ and an empty List as
    _argumentsList_.

9.  Return _iterator_.

NOTE The GeneratorFunction object created in step 5 is not observable
from ECMAScript code so an implementation may choose to avoid its
allocation and initialization. In that case, other semantically
equivalent means must be used to allocate and initialize the _iterator_
object in step 8. In either case, the _prototype_ object created in step
6 must be created because it is potentially observable as the value of
the _iterator_ object’s [[Prototype]] internal slot. If _strict_ is
FALSE and the _Comprehesion_ contains any direct eval calls then any
VarScopedDeclaration bindings created by the evals are created in the
VariableEnvironment of the function called in step 8.

Regular Expression Literals

Syntax

See 11.8.4.

Static Semantics: Early Errors

_PrimaryExpression_ : _RegularExpressionLiteral

-   It is a Syntax Error if BodyText of _RegularExpressionLiteral_
    cannot be recognized using the goal symbol _Pattern_ of the
    ECMAScript RegExp grammar specified in 21.2.1_._

-   It is a Syntax Error if FlagText of _RegularExpressionLiteral_
    contains any code points other than "G", "I", "M", "U", or "Y", or
    if it contains the same code point more than once.

Runtime Semantics: Evaluation

_PrimaryExpression_ : _RegularExpressionLiteral

1.  Let _pattern_ be the string value consisting of the UTF-16Encoding
    of each code point of BodyText of _RegularExpressionLiteral_.

2.  Let _flags_ be the string value consisting of the UTF-16Encoding of
    each code point of FlagText of _RegularExpressionLiteral_.

3.  Return RegExpCreate(_pattern_, _flags_).

Template Literals 

Syntax

TemplateLiteral~[Yield]~ :

NoSubstitutionTemplate
TemplateHead _Expression_~[In,\ ?Yield]~ [Lexical goal
InputElementTemplateTail] TemplateSpans~[?Yield]~

TemplateSpans~[Yield]~ :

TemplateTail
TemplateMiddleList~[?Yield]~ [Lexical goal InputElementTemplateTail]
TemplateTail

TemplateMiddleList~[Yield]~ :

TemplateMiddle _Expression_~[In,\ ?Yield]~
TemplateMiddleList~[?Yield]~ [Lexical goal InputElementTemplateTail]
TemplateMiddle _Expression_~[In,\ ?Yield]~

Static Semantics

Static Semantics: TemplateStrings

  With parameter _raw_.

_TemplateLiteral_ : _NoSubstitutionTemplate

1.  If _raw_ is FALSE, then

    a.  Let _string_ be the TV of _NoSubstitutionTemplate_.

2.  Else,

    a.  Let _string_ be the TRV of _NoSubstitutionTemplate_.

3.  Return a List containing the single element, _string_.

_TemplateLiteral_ : _TemplateHead_ _Expression_ _TemplateSpans

1.  If _raw_ is FALSE, then

    a.  Let _head_ be the TV of _TemplateHead_.

2.  Else,

    a.  Let _head_ be the TRV of _TemplateHead_.

3.  Let _tail_ be TemplateStrings of _TemplateSpans_ with argument
    _raw_.

4.  Return a List containing _head_ followed by the element, in order of
    _tail_.

_TemplateSpans_ : _TemplateTail

1.  If _raw_ is FALSE, then

    a.  Let _tail_ be the TV of _TemplateTail_.

2.  Else,

    a.  Let _tail_ be the TRV of _TemplateTail_.

3.  Return a List containing the single element, _tail_.

_TemplateSpans_ : _TemplateMiddleList_ _TemplateTail

1.  Let _middle_ be TemplateStrings of _TemplateMiddleList_ with
    argument _raw_.

2.  If _raw_ is FALSE, then

    a.  Let _tail_ be the TV of _TemplateTail_.

3.  Else,

    a.  Let _tail_ be the TRV of _TemplateTail_.

4.  Return a List containing the elements, in order, of _middle
    followed by _tail_.

_TemplateMiddleList_ : _TemplateMiddle_ _Expression

1.  If _raw_ is FALSE, then

    a.  Let _string_ be the TV of _TemplateMiddle_.

2.  Else,

    a.  Let _string_ be the TRV of _TemplateMiddle_.

3.  Return a List containing the single element, _string_.

_TemplateMiddleList_ : _TemplateMiddleList_ _TemplateMiddle
_Expression

1.  Let _front_ be TemplateStrings of _TemplateMiddleList_ with argument
    _raw_.

2.  If _raw_ is FALSE, then

    a.  Let _last_ be the TV of _TemplateMiddle_.

3.  Else,

    a.  Let _last_ be the TRV of _TemplateMiddle_.

4.  Append _last_ as the last element of the List _front_.

5.  Return _front_.

Runtime Semantics

Runtime Semantics: ArgumentListEvaluation

See also: 12.3.6.1

_TemplateLiteral_ : _NoSubstitutionTemplate

1.  Let _siteObj_ be the result of the abstract operation
    GetTemplateCallSite passing this _TemplateLiteral_ production as the
    argument.

2.  Return a List containing the one element which is _siteObj_.

_TemplateLiteral_ : _TemplateHead Expression_ _TemplateSpans

1.  Let _siteObj_ be the result of the abstract operation
    GetTemplateCallSite passing this _TemplateLiteral_ production as the
    argument.

2.  Let _firstSub_ be the result of evaluating _Expression_.

3.  ReturnIfAbrupt(_firstSub_).

4.  Let _restSub_ be SubstitutionEvaluation of _TemplateSpans_.

5.  ReturnIfAbrupt(_restSub_).

6.  Assert: _restSub_ is a List.

7.  Return a List whose first element is _siteObj_, whose second
    elements is _firstSub_, and whose subsequent elements are the
    elements of _restSub_, in order. _restSub_ may contain no elements.

Runtime Semantics: GetTemplateCallSite 

The abstract operation GetTemplateCallSite is called with a grammar
production, _templateLiteral_, as an argument. It performs the following
steps:

1.  If a call site object for the source code corresponding to
    _templateLiteral_ has already been created (see step 12 below) by a
    previous call to this abstract operation, then

    a.  Return that call site object.

2.  Let _cookedStrings_ be TemplateStrings of _templateLiteral_ with
    argument FALSE.

3.  Let _rawStrings_ be TemplateStrings of _templateLiteral_ with
    argument TRUE.

4.  Let _count_ be the number of elements in the List _cookedStrings_.

5.  Let _siteObj_ be ArrayCreate(_count_).

6.  Let _rawObj_ be ArrayCreate(_count_).

7.  Let _index_ be 0.

8.  Repeat while _index_ < _count

    a.  Let _prop_ be ToString(_index_).

    b.  Let _cookedValue_ be the string value at 0-based position
        _index_ of the List _cookedStrings_.

    c.  Call the [[DefineOwnProperty]] internal method of _siteObj_ with
        arguments _prop_ and PropertyDescriptor{[[Value]]:
        _cookedValue_, [[Enumerable]]: TRUE, [[Writable]]: FALSE,
        [[Configurable]]: FALSE}_._

    d.  Let _rawValue_ be the string value at 0-based position _index_
        of the List _rawStrings_.

    e.  Call the [[DefineOwnProperty]] internal method of _rawObj_ with
        arguments _prop_ and PropertyDescriptor{[[Value]]: _rawValue_,
        [[Enumerable]]: TRUE, [[Writable]]: FALSE, [[Configurable]]:
        FALSE}_._

    f.  Let _index_ be _index_+1.

9.  Perform SetIntegrityLevel(_rawObj_, "FROZEN").

10. Call the [[DefineOwnProperty]] internal method of _siteObj_ with
    arguments "RAW" and PropertyDescriptor{[[Value]]: _rawObj_,
    [[Writable]]: FALSE, [[Enumerable]]: FALSE, [[Configurable]]:
    FALSE}_._

11. Perform SetIntegrityLevel(_siteObj_, "FROZEN").

12. Remember an association between the source code corresponding to
    _templateLiteral_ and _siteObj_ such that _siteObj_ can be retrieve
    in subsequent calls to this abstract operation.

13. Return _siteObj_.

NOTE 1 The creation of a call site object cannot result in an abrupt
completion.

NOTE 2 Each _TemplateLiteral_ in the program code is associated with a
unique Template call site object that is used in the evaluation of
tagged Templates (12.2.9.2.4). The call site objects are frozen and the
same call site object is used each time a specific tagged Template is
evaluated. Whether call site objects are created lazily upon first
evaluation of the _TemplateLiteral_ or eagerly prior to first evaluation
is an implementation choice that is not observable to ECMAScript code.

NOTE 3 Future editions of this specification may define additional
non-enumerable properties of call site objects.

Runtime Semantics: SubstitutionEvaluation

_TemplateSpans_ : _TemplateTail

1.  Return an empty List.

_TemplateSpans_ : _TemplateMiddleList_ _TemplateTail

1.  Return the result of SubstitutionEvaluation of _TemplateMiddleList_.

_TemplateMiddleList_ : _TemplateMiddle Expression

1.  Let _sub_ be the result of evaluating _Expression_.

2.  ReturnIfAbrupt(_sub_).

3.  Return a List containing only _sub_.

_TemplateMiddleList_ : _TemplateMiddleList_ _TemplateMiddle
_Expression

1.  Let _preceeding_ be the result of SubstitutionEvaluation of
    _TemplateMiddleList_ .

2.  ReturnIfAbrupt(_preceeding_).

3.  Let _next_ be the result of evaluating _Expression_.

4.  ReturnIfAbrupt(_next_).

5.  Append _next_ as the last element of the List _preceeding_.

6.  Return _preceeding_.

Runtime Semantics: Evaluation

_TemplateLiteral_ : _NoSubstitutionTemplate

1.  Return the string value whose elements are the TV of
    _NoSubstitutionTemplate_ as defined in 11.8.6.

_TemplateLiteral_ : _TemplateHead_ _Expression_ _TemplateSpans

1.  Let _head_ be the TV of _TemplateHead_ as defined in 11.8.6.

2.  Let _sub_ be the result of evaluating _Expression_.

3.  Let _middle_ be ToString(_sub_).

4.  ReturnIfAbrupt(_middle_).

5.  Let _tail_ be the result of evaluating _TemplateSpans_ .

6.  ReturnIfAbrupt(_tail_).

7.  Return the string value whose elements are the code units of _head
    followed by the elements of _middle_ followed by the elements of
    _tail_.

NOTE The string conversion semantics applied to the _Expression_ value
are like STRING.PROTOTYPE.CONCAT rather than the + operator.

_TemplateSpans_ : _TemplateTail

1.  Let _tail_ be the TV of _TemplateTail_ as defined in 11.8.6.

2.  Return the string whose elements are the code units of _tail_.

_TemplateSpans_ : _TemplateMiddleList_ _TemplateTail

1.  Let _head_ be the result of evaluating _TemplateMiddleList_.

2.  ReturnIfAbrupt(_head_).

3.  Let _tail_ be the TV of _TemplateTail_ as defined in 11.8.6.

4.  Return the string whose elements are the elements of _head_ followed
    by the elements of _tail_.

_TemplateMiddleList_ : _TemplateMiddle_ _Expression

1.  Let _head_ be the TV of _TemplateMiddle_ as defined in 11.8.6.

2.  Let _sub_ be the result of evaluating _Expression_.

3.  Let _middle_ be ToString(_sub_).

4.  ReturnIfAbrupt(_middle_).

5.  Return the sequence of code units consisting of the code units of
    _head_ followed by the elements of _middle_.

NOTE The string conversion semantics applied to the _Expression_ value
are like STRING.PROTOTYPE.CONCAT rather than the + operator.

_TemplateMiddleList_ : _TemplateMiddleList_ _TemplateMiddle
_Expression

1.  Let _rest_ be the result of evaluating _TemplateMiddleList_ .

2.  ReturnIfAbrupt(_rest_).

3.  Let _middle_ be the TV of _TemplateMiddle_ as defined in 11.8.6.

4.  Let _sub_ be the result of evaluating _Expression_.

5.  Let _last_ be ToString(_sub_).

6.  ReturnIfAbrupt(_last_).

7.  Return the sequence of code units consisting of the elements of
    _rest_ followed by the code units of _middle_ followed by the
    elements of _last_.

NOTE The string conversion semantics applied to the _Expression_ value
are like STRING.PROTOTYPE.CONCAT rather than the + operator.

The Grouping Operator

Static Semantics: Early Errors

_PrimaryExpression_ :
_CoverParenthesizedExpressionAndArrowParameterList

-   It is a Syntax Error if the lexical token sequence matched by
    _CoverParenthesizedExpressionAndArrowParameterList_ cannot be parsed
    with no tokens left over using _ParenthesizedExpression_ as the goal
    symbol.

-   All Early Errors rules for _ParenthesizedExpression_ and its derived
    productions also apply to CoveredParenthesizedExpression of
    _CoverParenthesizedExpressionAndArrowParameterList_.

Static Semantics: IsFunctionDefinition

See also: 12.2.0.2, 12.3.1.2, 12.4.2, 12.5.2, 12.6.1, 12.7.1, 12.8.1,
12.9.1, 12.10.1, 12.11.1, 12.12.1, 12.13.1, 12.14.2, 12.15.1, 14.1.11,
14.4.8, 14.5.8.

_ParenthesizedExpression_ : ( _Expression_ )

1.  Return IsFunctionDefinition of _Expression_.

Static Semantics: IsValidSimpleAssignmentTarget

See also: 12.2.0.3, 12.3.1.3, 12.4.3, 12.5.3, 12.6.2, 12.7.2, 12.8.2,
12.9.2, 12.10.2, 12.11.2, 12.12.2, 12.13.2, 12.14.3, 12.15.2.

_ParenthesizedExpression_ : ( _Expression_ )

1.  Return IsValidSimpleAssignmentTarget of _Expression_.

Runtime Semantics: Evaluation

_PrimaryExpression_ :
_CoverParenthesizedExpressionAndArrowParameterList

1.  Let _expr_ be CoveredParenthesizedExpression of
    _CoverParenthesizedExpressionAndArrowParameterList_.

2.  Return the result of evaluating _expr_.

_ParenthesizedExpression_ : ( _Expression_ )

1.  Return the result of evaluating _Expression_. This may be of type
    Reference.

NOTE This algorithm does not apply GetValue to the result of evaluating
_Expression_. The principal motivation for this is so that operators
such as DELETE and TYPEOF may be applied to parenthesized expressions.


Left-Hand-Side Expressions

Syntax

MemberExpression~[Yield]~ :

[Lexical goal InputElementRegExp] PrimaryExpression~[?Yield]~
MemberExpression~[?Yield]~ [ Expression~[In,\ ?Yield]~ ]
MemberExpression~[?Yield]~ . IdentifierName
MemberExpression~[?Yield]~ TemplateLiteral~[?Yield]~
SUPER [ Expression~[In,\ ?Yield]~ ]
SUPER . IdentifierName
NEW SUPER Arguments~[?Yield]~
NEW MemberExpression~[?Yield]~ Arguments~[?Yield]~

NewExpression~[Yield]~ :

MemberExpression~[?Yield]~
NEW NewExpression~[?Yield]~ ~
~NEW SUPER

CallExpression~[Yield]~ :

MemberExpression~[?Yield]~ Arguments~[?Yield]~
SUPER Arguments~[?Yield]~
CallExpression~[?Yield]~ Arguments~[?Yield]~
CallExpression~[?Yield]~ [ Expression~[In,\ ?Yield]~ ]
CallExpression~[?Yield]~ . IdentifierName
CallExpression~[?Yield]~ TemplateLiteral~[?Yield]~

Arguments~[Yield]~ :

( )
( ArgumentList~[?Yield]~ )

ArgumentList~[Yield]~ :

AssignmentExpression~[In,\ ?Yield]~
... AssignmentExpression~[In,\ ?Yield]~
ArgumentList~[?Yield]~ , AssignmentExpression~[In,\ ?Yield]~
ArgumentList~[?Yield]~ , ... AssignmentExpression~[In,\ ?Yield]~

LeftHandSideExpression~[Yield]~ :

NewExpression~[?Yield]~
CallExpression~[?Yield]~

Static Semantics

Static Semantics: Contains

  With parameter _symbol_.

See also: 5.3, 12.2.5.2, 14.1.4, 14.2.3, 14.4.3, 14.5.4

_MemberExpression_ : _MemberExpression_ . _IdentifierName

1.  If _MemberExpression_ Contains _symbol_ is TRUE, return TRUE.

2.  If _symbol_ is a _ReservedWord_, return FALSE.

3.  If _symbol_ is an _Identifier_ and StringValue of _symbol_ is the
    same value as the StringValue of _IdentifierName_, return TRUE;

4.  Return FALSE.

_MemberExpression_ : SUPER . _IdentifierName

1.  If _symbol_ is the _ReservedWord_ SUPER, return TRUE.

2.  If _symbol_ is a _ReservedWord_, return FALSE.

3.  If _symbol_ is an _Identifier_ and StringValue of _symbol_ is the
    same value as the StringValue of _IdentifierName_, return TRUE;

4.  Return FALSE.

1.  2.  3.  

1.  2.  3.  

_CallExpression_ : _CallExpression_ . _IdentifierName

1.  If _CallExpression_ Contains _symbol_ is TRUE, return TRUE.

2.  If _symbol_ is a _ReservedWord_, return FALSE.

3.  If _symbol_ is an _Identifier_ and StringValue of _symbol_ is the
    same value as the StringValue of _IdentifierName_, return TRUE;

4.  Return FALSE.

Static Semantics: IsFunctionDefinition

See also: 12.2.0.2, 12.2.10.2, 12.4.2, 12.5.2, 12.6.1, 12.7.1, 12.8.1,
12.9.1, 12.10.1, 12.11.1, 12.12.1, 12.13.1, 12.14.2, 12.15.1, 14.1.11,
14.4.8, 14.5.8.

MemberExpression :

MemberExpression [ Expression ]
MemberExpression . IdentifierName
MemberExpression TemplateLiteral
SUPER [ Expression ]
SUPER . IdentifierName
NEW SUPER Arguments
NEW MemberExpression Arguments

NewExpression :

NEW NewExpression
NEW SUPER

CallExpression :

MemberExpression Arguments
SUPER Arguments
CallExpression Arguments
CallExpression [ Expression ]
CallExpression. IdentifierName
CallExpression TemplateLiteral

1.  Return FALSE.

Static Semantics: IsIdentifierRef

See also: 12.2.0.3.

LeftHandSideExpression :

CallExpression

MemberExpression :

MemberExpression [ Expression ]
MemberExpression . IdentifierName
MemberExpression TemplateLiteral
SUPER [ Expression ]
SUPER . IdentifierName
NEW SUPER Arguments
NEW MemberExpression Arguments

NewExpression :

NEW NewExpression
NEW SUPER

1.  Return FALSE.

Static Semantics: IsValidSimpleAssignmentTarget

See also: 12.2.0.3, 12.2.10.3, 12.4.3, 12.5.3, 12.6.2, 12.7.2, 12.8.2,
12.9.2, 12.10.2, 12.11.2, 12.12.2, 12.13.2, 12.14.3, 12.15.2.

CallExpression :

CallExpression [ Expression ]
CallExpression . IdentifierName

MemberExpression :

MemberExpression [ Expression ]
MemberExpression . IdentifierName
SUPER [ Expression ]
SUPER . IdentifierName

1.  Return TRUE.

CallExpression :

MemberExpression Arguments
SUPER Arguments
CallExpression Arguments
CallExpression TemplateLiteral

NewExpression :

NEW NewExpression
NEW SUPER

MemberExpression :

MemberExpression TemplateLiteral
NEW SUPER Arguments
NEW MemberExpression Arguments

1.  Return FALSE.

Property Accessors

NOTE Properties are accessed by name, using either the dot notation:

MemberExpression . IdentifierName
CallExpression . IdentifierName

or the bracket notation:

MemberExpression [ Expression ]
CallExpression [ Expression ]

The dot notation is explained by the following syntactic conversion:

MemberExpression . IdentifierName

is identical in its behaviour to

MemberExpression [ <identifier-name-string> ]

and similarly

CallExpression . IdentifierName

is identical in its behaviour to

CallExpression [ <identifier-name-string> ]

where _<identifier-name-string>_ is a string literal containing the same
sequence of code units after processing of Unicode escape sequences as
the _IdentifierName_.

Runtime Semantics: Evaluation

_MemberExpression_ : _MemberExpression_ [ _Expression_ ]

1.  Let _baseReference_ be the result of evaluating _MemberExpression_.

2.  Let _baseValue_ be GetValue(_baseReference_).

3.  ReturnIfAbrupt(_baseValue_).

4.  Let _propertyNameReference_ be the result of evaluating
    _Expression_.

5.  Let _propertyNameValue_ be GetValue(_propertyNameReference_).

6.  ReturnIfAbrupt(_propertyNameValue_).

7.  Let _bv_ be CheckObjectCoercible(_baseValue_).

8.  ReturnIfAbrupt(_bv_).

9.  Let _propertyNameString_ be ToString(_propertyNameValue_).

10. If the code matched by the syntactic production that is being
    evaluated is strict mode code, let _strict_ be TRUE, else let
    _strict_ be FALSE.

11. Return a value of type Reference whose base value is _bv_ and whose
    referenced name is _propertyNameString_, and whose strict reference
    flag is _strict_.

_CallExpression_ : _CallExpression_ [ _Expression_ ]

Is evaluated in exactly the same manner as _MemberExpression_ :
_MemberExpression_ [ _Expression_ ] except that the contained
_CallExpression_ is evaluated in step 1.

The new Operator

Runtime Semantics: Evaluation

_NewExpression_ : NEW _NewExpression

1.  Let _ref_ be the result of evaluating _NewExpression_.

2.  Let _constructor_ be GetValue(_ref_).

3.  ReturnIfAbrupt(_constructor_).

4.  If IsConstructor(_constructor_) is FALSE, throw a TYPEERROR
    exception.

5.  Let _thisCall_ be this _NewExpression_.

6.  Let _tailCall_ be IsInTailPosition(_thisCall_). (See 14.6.1)

7.  If _tailCall_ is TRUE, then perform the PrepareForTailCall abstract
    operation.

8.  Let _result_ be the result of calling the [[Construct]] internal
    method on _constructor_ with an empty List as the argument.

9.  Assert: If _tailCall_ is TRUE, the above call of [[Construct]] will
    not return here, but instead evaluation will continue as if the
    following return has already occurred.

10. Return _result_.

_MemberExpression_ : NEW _MemberExpression_ _Arguments

1.  Let _ref_ be the result of evaluating _MemberExpression_.

2.  Let _constructor_ be GetValue(_ref_).

3.  ReturnIfAbrupt(_constructor_).

4.  Let _argList_ be the result of evaluating _Arguments_, producing a
    List of argument values (12.3.6).

5.  ReturnIfAbrupt(_argList_).

6.  If IsConstructor (_constructor_) is FALSE, throw a TYPEERROR
    exception.

7.  Let _thisCall_ be this _MemberExpression_.

8.  Let _tailCall_ be IsInTailPosition(_thisCall_). (See 14.6.1)

9.  If _tailCall_ is TRUE, then perform the PrepareForTailCall abstract
    operation.

10. Let _result_ be the result of calling the [[Construct]] internal
    method on _constructor_, passing _argList_ as the argument.

11. Assert: If _tailCall_ is TRUE, the above call of [[Construct]] will
    not return here, but instead evaluation will continue as if the
    following return has already occurred.

12. Return _result_.

Function Calls

Runtime Semantics: Evaluation

_CallExpression_ : _MemberExpression_ _Arguments

1.  Let _ref_ be the result of evaluating _MemberExpression_.

2.  If _MemberExpression_ consists solely of the _IdentifierName_ EVAL,
    then

    a.  check if direct eval

    b.  Return EvaluateCall(_ref_, _Arguments_, FALSE).

3.  Let _thisCall_ be this _CallExpression_.

4.  Let _tailCall_ be IsInTailPosition(_thisCall_). (See 14.6.1)

5.  Return EvaluateCall(_ref_, _Arguments_, _tailCall_).

_CallExpression_ : _CallExpression_ _Arguments

1.  Let _ref_ be the result of evaluating _CallExpression_.

2.  Let _thisCall_ be this _CallExpression

3.  Let _tailCall_ be IsInTailPosition(_thisCall_). (See 14.6.1)

4.  Return EvaluateCall(_ref_, _Arguments_, _tailCall_).

Runtime Semantics: EvaluateCall 

The abstract operation EvaluateCall takes as arguments a value _ref_,
and a syntactic grammar production _arguments_, and a Boolean argument
_tailPosition_. It performs the following steps:

1.  Let _func_ be GetValue(_ref_).

2.  ReturnIfAbrupt(_func_).

3.  Let _argList_ be ArgumentListEvaluation(_arguments_).

4.  ReturnIfAbrupt(_argList_).

5.  6.  If IsCallable(_func_) is FALSE, throw a TYPEERROR exception.

7.  If Type(_ref_) is Reference, then

    a.  If IsPropertyReference(_ref_) is TRUE, then

        i.  Let _thisValue_ be GetThisValue(_ref_).

    b.  Else, the base of _ref_ is an Environment Record

        i.  Let _thisValue_ be the result of calling the WithBaseObject
            concrete method of GetBase(_ref_).

8.  Else Type(_ref_) is not Reference,

    a.  Let _thisValue_ be UNDEFINED.

9.  If _tailPosition_ is TRUE, then perform the PrepareForTailCall
    abstract operation.

10. Let _result_ be the result of calling the [[Call]] internal method
    on _func_, passing _thisValue_ as the _thisArgument_ and _argList_
    as the _argumentsList_.

11. Assert: If _tailPosition_ is TRUE, the above call will not return
    here, but instead evaluation will continue as if the following
    return has already occurred.

12. Assert: If _result_ is not an abrupt completion then Type(_result_)
    is an ECMAScript language type

13. Return _result_.

The super Keyword

Static Semantics: Early Errors

MemberExpression :

SUPER [ Expression ]
SUPER . IdentifierName
NEW SUPER Arguments

_NewExpression_ : NEW SUPER

_CallExpression_ : SUPER _Arguments

-   It is a Syntax Error if the source code parsed with this production
    is global code that is not eval code.

-   It is a Syntax Error if the source code parsed with this production
    is eval code and the source code is not being processed by a direct
    call to eval that is contained in function code.

Runtime Semantics: Evaluation

_MemberExpression_ : SUPER [ _Expression_ ]

1.  Let _propertyNameReference_ be the result of evaluating
    _Expression_.

2.  Let _propertyNameValue_ be GetValue(_propertyNameReference_).

3.  Let _propertyKey_ be ToPropertyKey(_propertyNameValue_).

4.  If the code matched by the syntactic production that is being
    evaluated is strict mode code, let _strict_ be TRUE, else let
    _strict_ be FALSE.

5.  Return MakeSuperReference(_propertyKey_, _strict_).

_MemberExpression_ : SUPER . _IdentifierName

1.  Let _propertyKey_ be StringValue of _IdentifierName_.

2.  If the code matched by the syntactic production that is being
    evaluated is strict mode code, let _strict_ be TRUE, else let
    _strict_ be FALSE.

3.  Return MakeSuperReference(_propertyKey_, _strict_).

_MemberExpression_ : NEW SUPER _Arguments

1.  If the code matched by the syntactic production that is being
    evaluated is strict mode code, let _strict_ be TRUE, else let
    _strict_ be FALSE.

2.  Let _ref_ be MakeSuperReference(UNDEFINED, _strict_).

3.  Let _constructor_ be GetValue(_ref_).

4.  ReturnIfAbrupt(_constructor_).

5.  6.  Let _argList_ be the result of evaluating _Arguments_, producing
    a List of argument values (12.3.6).

7.  ReturnIfAbrupt(_argList_).

8.  a.  

9.  If IsConstructor (_constructor_) is FALSE, throw a TYPEERROR
    exception.

10. Let _thisCall_ be this _MemberExpression_.

11. Let _tailCall_ be IsInTailPosition(_thisCall_). (See 14.6.1)

12. If _tailCall_ is TRUE, then perform the PrepareForTailCall abstract
    operation.

13. Let _result_ be the result of calling the [[Construct]] internal
    method on _constructor_, passing _argList_ as the argument.

14. Assert: If _tailCall_ is TRUE, the above call of [[Construct]] will
    not return here, but instead evaluation will continue as if the
    following return has already occurred.

15. Return _result_.

_NewExpression_ : NEW SUPER

1.  If the code matched by the syntactic production that is being
    evaluated is strict mode code, let _strict_ be TRUE, else let
    _strict_ be FALSE.

2.  Let _ref_ be MakeSuperReference(UNDEFINED, _strict_).

3.  Let _constructor_ be GetValue(_ref_).

4.  ReturnIfAbrupt(_constructor_).

5.  Let _argList_ be a new empty List.

6.  ReturnIfAbrupt(_argList_).

7.  If IsConstructor (_constructor_) is FALSE, throw a TYPEERROR
    exception.

8.  Let _thisCall_ be this _NewExpression_.

9.  Let _tailCall_ be IsInTailPosition(_thisCall_). (See 14.6.1)

10. If _tailCall_ is TRUE, then perform the PrepareForTailCall abstract
    operation.

11. Let _result_ be the result of calling the [[Construct]] internal
    method on _constructor_, passing _argList_ as the argument.

12. Assert: If _tailCall_ is TRUE, the above call of [[Construct]] will
    not return here, but instead evaluation will continue as if the
    following return has already occurred.

13. Return _result_.

_CallExpression_ : SUPER _Arguments

1.  If the code matched by the syntactic production that is being
    evaluated is strict mode code, let _strict_ be TRUE, else let
    _strict_ be FALSE.

2.  Let _ref_ be MakeSuperReference(UNDEFINED, _strict_).

3.  ReturnIfAbrupt(_ref_).

4.  Let _thisCall_ be this _CallExpression_.

5.  Let _tailCall_ be IsInTailPosition(_thisCall_). (See 14.6.1)

6.  Return EvaluateCall(_ref_, _Arguments_, _tailCall_).

Runtime Semantics: MakeSuperReference(propertyKey, strict)

The abstract operation MakeSuperReference with arguments _propertyKey_
and _strict_ performs the following steps:

1.  Let _env_ be GetThisEnvironment( ).

2.  If the result of calling the HasSuperBinding concrete method of
    _env_ is FALSE, then throw a REFERENCEERROR exception.

3.  Let _actualThis_ be the result of calling the GetThisBinding
    concrete method of _env_.

4.  Let _baseValue_ be the result of calling the GetSuperBase concrete
    method of _env_.

5.  Let _bv_ be CheckObjectCoercible(_baseValue_).

6.  ReturnIfAbrupt(_bv_).

7.  If _propertyKey_ is UNDEFINED, then

    a.  Let _propertyKey_ be the result of calling the GetMethodName
        concrete method of _env_.

    b.  If _propertyKey_ is UNDEFINED, then throw a REFERENCEERROR
        exception.

8.  Return a value of type Reference that is a Super Reference whose
    base value is _bv_, whose referenced name is _propertyKey_, whose
    thisValue is _actualThis_, and whose strict reference flag is
    _strict_.

Argument Lists

NOTE The evaluation of an argument list produces a List of values (see
6.2.1).

Runtime Semantics: ArgumentListEvaluation

See also: 12.2.9.2.1

_Arguments_ : ( )

1.  Return an empty List.

_ArgumentList_ : _AssignmentExpression

1.  Let _ref_ be the result of evaluating _AssignmentExpression_.

2.  Let _arg_ be GetValue(_ref_).

3.  ReturnIfAbrupt(_arg_).

4.  Return a List whose sole item is _arg_.

_ArgumentList_ : ... _AssignmentExpression

1.  Let _list_ be an empty List.

2.  Let _spreadRef_ be the result of evaluating _AssignmentExpression_.

3.  Let _spreadObj_ be ToObject(GetValue(_spreadRef_)).

4.  5.  6.  Let _iterator_ be GetIterator(_spreadObj_).

7.  ReturnIfAbrupt(_iterator_).

8.  Repeat

    a.  Let _next_ be IteratorStep(_iterator_).

    b.  ReturnIfAbrupt(_next_).

    c.  If _next_ is FALSE, then return _list_.

    d.  Let _nextArg_ be IteratorValue(_next_).

    e.  ReturnIfAbrupt(_nextArg_).

    f.  Append _nextArg_ as the last element of _list_.

_ArgumentList_ : _ArgumentList_ , _AssignmentExpression

1.  Let _precedingArgs_ be the result of evaluating _ArgumentList_.

2.  ReturnIfAbrupt(_precedingArgs_).

3.  Let _ref_ be the result of evaluating _AssignmentExpression_.

4.  Let _arg_ be GetValue(_ref_).

5.  ReturnIfAbrupt(_arg_).

6.  Return a List whose length is one greater than the length of
    _precedingArgs_ and whose items are the items of _precedingArgs_, in
    order, followed at the end by _arg_ which is the last item of the
    new list.

_ArgumentList_ : _ArgumentList_ , ... _AssignmentExpression

1.  Let _precedingArgs_ be the result of evaluating _ArgumentList_.

2.  Let _spreadRef_ be the result of evaluating _AssignmentExpression_.

3.  4.  5.  6.  Let _iterator_ be
    GetIterator(ToObject(GetValue(_spreadRef_))).

7.  ReturnIfAbrupt(_iterator_).

8.  Repeat

    a.  Let _next_ be IteratorStep(_iterator_).

    b.  ReturnIfAbrupt(_next_).

    c.  If _next_ is FALSE, then return _precedingArgs_.

    d.  Let _nextArg_ be IteratorValue(_next_).

    e.  ReturnIfAbrupt(_nextArg_).

    f.  Append _nextArg_ as the last element of _precedingArgs_.

Tagged Templates

NOTE A tagged template is a function call where the arguments of the
call are derived from a _TemplateLiteral_ (12.2.9). The actual arguments
include a call site object (12.2.9.2.2) and the values produced by
evaluating the expressions embedded within the _TemplateLiteral_.

Runtime Semantics: Evaluation

_MemberExpression_ : _MemberExpression_ _TemplateLiteral

1.  Let _tagRef_ be the result of evaluating _MemberExpression_.

2.  Let _thisCall_ be this _MemberExpression_.

3.  Let _tailCall_ be IsInTailPosition(_thisCall_). (See 14.6.1)

4.  Return EvaluateCall(_tagRef_, _TemplateLiteral_, _tailCall_).

_CallExpression_ : _CallExpression_ _TemplateLiteral

1.  Let _tagRef_ be the result of evaluating _CallExpression_.

2.  Let _thisCall_ be this _CallExpression_.

3.  Let _tailCall_ be IsInTailPosition(_thisCall_). (See 14.6.1)

4.  Return EvaluateCall(_tagRef_, _TemplateLiteral_, _tailCall_).


Postfix Expressions

Syntax

PostfixExpression~[Yield]~ :

LeftHandSideExpression~[?Yield]~
LeftHandSideExpression~[?Yield]~ [no LineTerminator here] ++
LeftHandSideExpression~[?Yield]~ [no LineTerminator here] --

Static Semantics: Early Errors

PostfixExpression :

LeftHandSideExpression ++
LeftHandSideExpression --

-   It is an early Reference Error if IsValidSimpleAssignmentTarget of
    _LeftHandSideExpression_ is FALSE.

Static Semantics: IsFunctionDefinition

See also: 12.2.0.2, 12.2.10.2, 12.3.1.2, 12.5.2, 12.6.1, 12.7.1, 12.8.1,
12.9.1, 12.10.1, 12.11.1, 12.12.1, 12.13.1, 12.14.2, 12.15.1, 14.1.11,
14.4.8, 14.5.

PostfixExpression :

LeftHandSideExpression ++
LeftHandSideExpression --

1.  Return FALSE.

Static Semantics: IsValidSimpleAssignmentTarget

See also: 12.2.0.3, 12.2.10.3, 12.3.1.3, 12.5.3, 12.6.2, 12.7.2, 12.8.2,
12.9.2, 12.10.2, 12.11.2, 12.12.2, 12.13.2, 12.14.3, 12.15.2.

PostfixExpression :

LeftHandSideExpression ++
LeftHandSideExpression --

1.  Return FALSE.

Postfix Increment Operator

Runtime Semantics: Evaluation

_PostfixExpression_ : _LeftHandSideExpression_ ++

1.  Let _lhs_ be the result of evaluating _LeftHandSideExpression_.

2.  Let _oldValue_ be ToNumber(GetValue(_lhs_)).

3.  ReturnIfAbrupt(_oldValue_).

4.  Let _newValue_ be the result of adding the value 1 to _oldValue_,
    using the same rules as for the + operator (see 12.7.5).

5.  Let _status_ be PutValue(_lhs_, _newValue_).

6.  ReturnIfAbrupt(_status_).

7.  Return _oldValue_.

Postfix Decrement Operator

Runtime Semantics: Evaluation

_PostfixExpression_ : _LeftHandSideExpression_ --

1.  Let _lhs_ be the result of evaluating _LeftHandSideExpression_.

2.  Let _oldValue_ be ToNumber(GetValue(_lhs_)).

3.  ReturnIfAbrupt(_oldValue_).

4.  Let _newValue_ be the result of subtracting the value 1 from
    _oldValue_, using the same rules as for the - operator (12.7.5).

5.  Let _status_ be PutValue(_lhs_, _newValue_).

6.  ReturnIfAbrupt(_status_).

7.  Return _oldValue_.


Unary Operators

Syntax

UnaryExpression~[Yield]~ :

PostfixExpression~[?Yield]~
DELETE UnaryExpression~[?Yield]~
VOID UnaryExpression~[?Yield]~
TYPEOF UnaryExpression~[?Yield]~
++ UnaryExpression~[?Yield]~
-- UnaryExpression~[?Yield]~
+ UnaryExpression~[?Yield]~
- UnaryExpression~[?Yield]~
~ UnaryExpression~[?Yield]~
! UnaryExpression~[?Yield]~

Static Semantics: Early Errors

UnaryExpression :

++ UnaryExpression
-- UnaryExpression

-   It is an early Reference Error if IsValidSimpleAssignmentTarget of
    _UnaryExpression_ is FALSE.

Static Semantics: IsFunctionDefinition

See also: 12.2.0.2, 12.2.10.2, 12.3.1.2, 12.4.2, 12.6.1, 12.7.1, 12.8.1,
12.9.1, 12.10.1, 12.11.1, 12.12.1, 12.13.1, 12.14.2, 12.15.1, 14.1.11,
14.4.8, 14.5.8.

UnaryExpression :

DELETE UnaryExpression
VOID UnaryExpression
TYPEOF UnaryExpression
++ UnaryExpression
-- UnaryExpression
+ UnaryExpression
- UnaryExpression
~ UnaryExpression
! UnaryExpression

1.  Return FALSE.

Static Semantics: IsValidSimpleAssignmentTarget

See also: 12.2.0.3, 12.2.10.3, 12.3.1.3, 12.4.3, 12.6.2, 12.7.2, 12.8.2,
12.9.2, 12.10.2, 12.11.2, 12.12.2, 12.13.2, 12.14.3, 12.15.2.

UnaryExpression :

DELETE UnaryExpression
VOID UnaryExpression
TYPEOF UnaryExpression
++ UnaryExpression
-- UnaryExpression
+ UnaryExpression
- UnaryExpression
~ UnaryExpression
! UnaryExpression

1.  Return FALSE.

The delete Operator

Static Semantics: Early Errors

_UnaryExpression_ : DELETE _UnaryExpression

-   It is a Syntax Error if the _UnaryExpression_ is contained in strict
    code and the derived _UnaryExpression_ is _PrimaryExpression_ :
    _IdentifierReference._

-   It is a Syntax Error if the derived _UnaryExpression_ is
     _PrimaryExpression :
    CoverParenthesizedExpressionAndArrowParameterList
    _and derives a production that, if used in place of
    _UnaryExpression,_ would produce a Syntax Error according to these
    rules. This rule is recursively applied.

  NOTE The last rule means that expressions such as
   DELETE (((FOO)))
  produce early errors because of recursive application of the first
  rule.

Runtime Semantics: Evaluation

_UnaryExpression_ : DELETE _UnaryExpression

1.  Let _ref_ be the result of evaluating _UnaryExpression_.

2.  ReturnIfAbrupt(_ref_).

3.  If Type(_ref_) is not Reference, return TRUE.

4.  If IsUnresolvableReference(_ref_) is TRUE, then,

    a.  Assert: IsStrictReference(_ref_) is FALSE.

    b.  Return TRUE.

5.  If IsPropertyReference(_ref_) is TRUE, then

    a.  If IsSuperReference(_ref_), then throw a REFERENCEERROR
        exception.

    b.  Let _deleteStatus_ be the result of calling the [[Delete]]
        internal method on ToObject(GetBase(_ref)_), providing
        GetReferencedName(_ref_) as the argument.

    c.  ReturnIfAbrupt(_deleteStatus_).

    d.  If _deleteStatus_ is FALSE and IsStrictReference(_ref_) is TRUE,
        then throw a TYPEERROR exception.

    e.  Return _deleteStatus_.

6.  Else _ref_ is a Reference to an Environment Record binding,

    a.  Let _bindings_ be GetBase(_ref_).

    b.  Return the result of calling the DeleteBinding concrete method
        of _bindings_, providing GetReferencedName(_ref_) as the
        argument.

NOTE When a DELETE operator occurs within strict mode code, a
SYNTAXERROR exception is thrown if its _UnaryExpression_ is a direct
reference to a variable, function argument, or function name. In
addition, if a DELETE operator occurs within strict mode code and the
property to be deleted has the attribute { [[Configurable]]: FALSE }, a
TYPEERROR exception is thrown.

The void Operator

Runtime Semantics: Evaluation

_UnaryExpression_ : VOID _UnaryExpression

1.  Let _expr_ be the result of evaluating _UnaryExpression_.

2.  Let _status_ be GetValue(_expr_).

3.  ReturnIfAbrupt(_status_).

4.  Return UNDEFINED.

NOTE GetValue must be called even though its value is not used because
it may have observable side-effects.

The typeof Operator

Runtime Semantics: Evaluation

_UnaryExpression_ : TYPEOF _UnaryExpression

1.  Let _val_ be the result of evaluating _UnaryExpression_.

2.  If Type(_val_) is Reference, then

    a.  If IsUnresolvableReference(_val_) is TRUE, return "UNDEFINED".

    b.  Let _val_ be GetValue(_val_).

3.  ReturnIfAbrupt(_val_).

4.  Return a String according to Table 34.

Table 34 — typeof Operator Results

  -------------------------------------------------------------- ----------------------------------------------------------------------------------------------
  _TYPE OF val_                                                  _RESULT_
  Undefined                                                      "UNDEFINED"
  Null                                                           "OBJECT"
  Boolean                                                        "BOOLEAN"
  Number                                                         "NUMBER"
  String                                                         "STRING"
  Symbol                                                         "SYMBOL"
  Object (ordinary and does not implement [[Call]])              "OBJECT"
  Object (standard exotic and does not implement [[Call]])       "OBJECT"
  Object (implements [[Call]])                                   "FUNCTION"
  Object (non-standard exotic and does not implement [[Call]])   Implementation-defined. Must not be "UNDEFINED", "BOOLEAN", "NUMBER", "SYMBOL", or "STRING".
  -------------------------------------------------------------- ----------------------------------------------------------------------------------------------

NOTE Implementations are discouraged from defining new TYPEOF result
values for non-standard exotic objects. If possible "OBJECT"should be
used for such objects.

Prefix Increment Operator

Runtime Semantics: Evaluation

_UnaryExpression_ : ++ _UnaryExpression

1.  Let _expr_ be the result of evaluating _UnaryExpression_.

2.  Let _oldValue_ be ToNumber(GetValue(_expr_)).

3.  ReturnIfAbrupt(_oldValue_).

4.  Let _newValue_ be the result of adding the value 1 to _oldValue_,
    using the same rules as for the + operator (see 12.7.5).

5.  Let _status_ be PutValue(_expr_, _newValue_).

6.  ReturnIfAbrupt(_status_).

7.  Return _newValue_.

Prefix Decrement Operator

Runtime Semantics: Evaluation

_UnaryExpression_ : -- _UnaryExpression

1.  Let _expr_ be the result of evaluating _UnaryExpression_.

2.  Let _oldValue_ be ToNumber(GetValue(_expr_)).

3.  ReturnIfAbrupt(_oldValue_).

4.  Let _newValue_ be the result of subtracting the value 1 from
    _oldValue_, using the same rules as for the - operator (see 12.7.5).

5.  Let _status_ be PutValue(_expr_, _newValue_).

6.  ReturnIfAbrupt(_status_).

7.  Return _newValue_.

Unary + Operator

NOTE The unary + operator converts its operand to Number type.

Runtime Semantics: Evaluation

_UnaryExpression_ : + _UnaryExpression

1.  Let _expr_ be the result of evaluating _UnaryExpression_.

2.  Return ToNumber(GetValue(_expr_)).

Unary - Operator

NOTE The unary - operator converts its operand to Number type and then
negates it. Negating +0 produces −0, and negating −0 produces +0.

Runtime Semantics: Evaluation

_UnaryExpression_ : - _UnaryExpression

1.  Let _expr_ be the result of evaluating _UnaryExpression_.

2.  Let _oldValue_ be ToNumber(GetValue(_expr_)).

3.  ReturnIfAbrupt(_oldValue_).

4.  If _oldValue_ is NAN, return NAN.

5.  Return the result of negating _oldValue_; that is, compute a Number
    with the same magnitude but opposite sign.

Bitwise NOT Operator ( ~ )

Runtime Semantics: Evaluation

_UnaryExpression_ : ~ _UnaryExpression

1.  Let _expr_ be the result of evaluating _UnaryExpression_.

2.  Let _oldValue_ be ToInt32(GetValue(_expr_)).

3.  ReturnIfAbrupt(_oldValue_).

4.  Return the result of applying bitwise complement to _oldValue_. The
    result is a signed 32-bit integer.

Logical NOT Operator ( ! )

Runtime Semantics: Evaluation

_UnaryExpression_ : ! _UnaryExpression

1.  Let _expr_ be the result of evaluating _UnaryExpression_.

2.  Let _oldValue_ be ToBoolean(GetValue(_expr_)).

3.  ReturnIfAbrupt(_oldValue_).

4.  If _oldValue_ is TRUE, return FALSE.

5.  Return TRUE.


Multiplicative Operators

Syntax

MultiplicativeExpression~[Yield]~ :

UnaryExpression~[?Yield]~
MultiplicativeExpression~[?Yield]~ * UnaryExpression~[?Yield]~
MultiplicativeExpression~[?Yield]~ / UnaryExpression~[?Yield]~
MultiplicativeExpression~[?Yield]~ % UnaryExpression~[?Yield]~

Static Semantics: IsFunctionDefinition

See also: 12.2.0.2, 12.2.10.2, 12.3.1.2, 12.4.2, 12.5.2, 12.7.1, 12.8.1,
12.9.1, 12.10.1, 12.11.1, 12.12.1, 12.13.1, 12.14.2, 12.15.1, 14.1.11,
14.4.8, 14.5.8.

MultiplicativeExpression :

MultiplicativeExpression * UnaryExpression
MultiplicativeExpression / UnaryExpression
MultiplicativeExpression % UnaryExpression

1.  Return FALSE.

Static Semantics: IsValidSimpleAssignmentTarget

See also: 12.2.0.3, 12.2.10.3, 12.3.1.3, 12.4.3, 12.5.3, 12.7.2, 12.8.2,
12.9.2, 12.10.2, 12.11.2, 12.12.2, 12.13.2, 12.14.3, 12.15.2.

MultiplicativeExpression :

MultiplicativeExpression * UnaryExpression
MultiplicativeExpression / UnaryExpression
MultiplicativeExpression % UnaryExpression

1.  Return FALSE.

Runtime Semantics: Evaluation

The production _MultiplicativeExpression_ : _MultiplicativeExpression @
UnaryExpression_, where @ stands for one of the operators in the above
definitions, is evaluated as follows:

1.  Let _left_ be the result of evaluating _MultiplicativeExpression_.

2.  Let _leftValue_ be GetValue(_left_).

3.  ReturnIfAbrupt(_leftValue_).

4.  Let _right_ be the result of evaluating _UnaryExpression_.

5.  Let _rightValue_ be GetValue(_right_).

6.  Let _lnum_ be ToNumber(_leftValue_).

7.  ReturnIfAbrupt(_lnum_).

8.  Let _rnum_ be ToNumber(_rightValue_).

9.  ReturnIfAbrupt(_rnum_).

10. Return the result of applying the specified operation (*, /, or %)
    to _lnum_ and _rnum_. See the Notes below 12.6.3.1, 12.6.3.2,
    12.6.3.3.

Applying the * Operator

The * operator performs multiplication, producing the product of its
operands. Multiplication is commutative. Multiplication is not always
associative in ECMAScript, because of finite precision.

The result of a floating-point multiplication is governed by the rules
of IEEE 754 binary double-precision arithmetic:

-   If either operand is NAN, the result is NAN.

-   The sign of the result is positive if both operands have the same
      sign, negative if the operands have different signs.

-   Multiplication of an infinity by a zero results in NAN.

-   Multiplication of an infinity by an infinity results in an infinity.
      The sign is determined by the rule already stated above.

-   Multiplication of an infinity by a finite nonzero value results in a
      signed infinity. The sign is determined by the rule already stated
      above.

-   In the remaining cases, where neither an infinity nor NaN is
      involved, the product is computed and rounded to the nearest
      representable value using IEEE 754 round-to-nearest mode. If the
      magnitude is too large to represent, the result is then an
      infinity of appropriate sign. If the magnitude is too small to
      represent, the result is then a zero of appropriate sign. The
      ECMAScript language requires support of gradual underflow as
      defined by IEEE 754.

Applying the / Operator

The / operator performs division, producing the quotient of its
operands. The left operand is the dividend and the right operand is the
divisor. ECMAScript does not perform integer division. The operands and
result of all division operations are double-precision floating-point
numbers. The result of division is determined by the specification of
IEEE 754 arithmetic:

-   If either operand is NAN, the result is NAN.

-   The sign of the result is positive if both operands have the same
      sign, negative if the operands have different signs.

-   Division of an infinity by an infinity results in NAN.

-   Division of an infinity by a zero results in an infinity. The sign
      is determined by the rule already stated above.

-   Division of an infinity by a nonzero finite value results in a
      signed infinity. The sign is determined by the rule already stated
      above.

-   Division of a finite value by an infinity results in zero. The sign
      is determined by the rule already stated above.

-   Division of a zero by a zero results in NAN; division of zero by any
      other finite value results in zero, with the sign determined by
      the rule already stated above.

-   Division of a nonzero finite value by a zero results in a signed
      infinity. The sign is determined by the rule already stated above.

-   In the remaining cases, where neither an infinity, nor a zero, nor
      NAN is involved, the quotient is computed and rounded to the
      nearest representable value using IEEE 754 round-to-nearest mode.
      If the magnitude is too large to represent, the operation
      overflows; the result is then an infinity of appropriate sign. If
      the magnitude is too small to represent, the operation underflows
      and the result is a zero of the appropriate sign. The ECMAScript
      language requires support of gradual underflow as defined by IEEE
      754.

Applying the % Operator

The % operator yields the remainder of its operands from an implied
division; the left operand is the dividend and the right operand is the
divisor.

NOTE In C and C++, the remainder operator accepts only integral
operands; in ECMAScript, it also accepts floating-point operands.

The result of a floating-point remainder operation as computed by the %
operator is not the same as the “remainder” operation defined by IEEE
754. The IEEE 754 “remainder” operation computes the remainder from a
rounding division, not a truncating division, and so its behaviour is
not analogous to that of the usual integer remainder operator. Instead
the ECMAScript language defines % on floating-point operations to behave
in a manner analogous to that of the Java integer remainder operator;
this may be compared with the C library function fmod.

The result of an ECMAScript floating-point remainder operation is
determined by the rules of IEEE arithmetic:

-   If either operand is NAN, the result is NAN.

-   The sign of the result equals the sign of the dividend.

-   If the dividend is an infinity, or the divisor is a zero, or both,
      the result is NAN.

-   If the dividend is finite and the divisor is an infinity, the result
      equals the dividend.

-   If the dividend is a zero and the divisor is nonzero and finite, the
      result is the same as the dividend.

-   In the remaining cases, where neither an infinity, nor a zero, nor
      NAN is involved, the floating-point remainder r from a dividend n
      and a divisor d is defined by the mathematical relation r = n − (d
      × q) where q is an integer that is negative only if n/d is
      negative and positive only if n/d is positive, and whose magnitude
      is as large as possible without exceeding the magnitude of the
      true mathematical quotient of n and d. r is computed and rounded
      to the nearest representable value using IEEE 754 round-to-nearest
      mode.


Additive Operators

Syntax

AdditiveExpression~[Yield]~ :

MultiplicativeExpression~[?Yield]~
AdditiveExpression~[?Yield]~ + MultiplicativeExpression~[?Yield]~
AdditiveExpression~[?Yield]~ - MultiplicativeExpression~[?Yield]~

Static Semantics: IsFunctionDefinition

See also: 12.2.0.2, 12.2.10.2, 12.3.1.2, 12.4.2, 12.5.2, 12.6.1, 12.8.1,
12.9.1, 12.10.1, 12.11.1, 12.12.1, 12.13.1, 12.14.2, 12.15.1, 14.1.11,
14.4.8, 14.5.8.

AdditiveExpression :

AdditiveExpression + MultiplicativeExpression
AdditiveExpression - MultiplicativeExpression

1.  Return FALSE.

Static Semantics: IsValidSimpleAssignmentTarget

See also: 12.2.0.3, 12.2.10.3, 12.3.1.3, 12.4.3, 12.5.3, 12.6.2, 12.8.2,
12.9.2, 12.10.2, 12.11.2, 12.12.2, 12.13.2, 12.14.3, 12.15.2.

AdditiveExpression :

AdditiveExpression + MultiplicativeExpression
AdditiveExpression - MultiplicativeExpression

1.  Return FALSE.

The Addition operator ( + )

NOTE The addition operator either performs string concatenation or
numeric addition.

Runtime Semantics: Evaluation

_AdditiveExpression_ : _AdditiveExpression_ + _MultiplicativeExpression

1.  Let _lref_ be the result of evaluating _AdditiveExpression_.

2.  Let _lval_ be GetValue(_lref_).

3.  ReturnIfAbrupt(_lval_).

4.  Let _rref_ be the result of evaluating _MultiplicativeExpression_.

5.  Let _rval_ be GetValue(_rref_).

6.  ReturnIfAbrupt(_rval_).

7.  Let _lprim_ be ToPrimitive(_lval_).

8.  ReturnIfAbrupt(_lprim_).

9.  Let _rprim_ be ToPrimitive(_rval_).

10. ReturnIfAbrupt(_rprim_).

11. If Type(_lprim_) is String or Type(_rprim_) is String, then

    a.  If Type(_lprim_) is Symbol or Type(_rprim_) is Symbol, then
        throw a TYPEERROR exception.

    b.  Return the String that is the result of concatenating
        ToString(_lprim_) followed by ToString(_rprim_)

12. Let _lnum_ be ToNumber(_lprim_).

13. ReturnIfAbrupt(_lnum_).

14. Let _rnum_ be ToNumber(_rprim_).

15. ReturnIfAbrupt(_rnum_).

16. Return the result of applying the addition operation to _lnum_ and
    _rnum_. See the Note below 12.7.5.

NOTE 1 No hint is provided in the calls to ToPrimitive in steps 7 and 9.
All standard objects except Date objects handle the absence of a hint as
if the hint Number were given; Date objects handle the absence of a hint
as if the hint String were given. Exotic objects may handle the absence
of a hint in some other manner.

NOTE 2 Step 11 differs from step 5 of the Abstract Relational Comparison
algorithm (7.2.8), by using the logical-or operation instead of the
logical-and operation.

The Subtraction Operator ( - )

Runtime Semantics: Evaluation

_AdditiveExpression_ : _AdditiveExpression_ - _MultiplicativeExpression

1.  Let _lref_ be the result of evaluating _AdditiveExpression_.

2.  Let _lval_ be GetValue(_lref_).

3.  ReturnIfAbrupt(_lval_).

4.  Let _rref_ be the result of evaluating _MultiplicativeExpression_.

5.  Let _rval_ be GetValue(_rref_).

6.  ReturnIfAbrupt(_rval_).

7.  Let _lnum_ be ToNumber(_lval_).

8.  ReturnIfAbrupt(_lnum_).

9.  Let _rnum_ be ToNumber(_rval_).

10. ReturnIfAbrupt(_rnum_).

11. Return the result of applying the subtraction operation to _lnum
    and _rnum_. See the note below 12.7.5.

Applying the Additive Operators to Numbers

The + operator performs addition when applied to two operands of numeric
type, producing the sum of the operands. The - operator performs
subtraction, producing the difference of two numeric operands.

Addition is a commutative operation, but not always associative.

The result of an addition is determined using the rules of IEEE 754
binary double-precision arithmetic:

-   If either operand is NAN, the result is NAN.

-   The sum of two infinities of opposite sign is NAN.

-   The sum of two infinities of the same sign is the infinity of that
      sign.

-   The sum of an infinity and a finite value is equal to the infinite
      operand.

-   The sum of two negative zeroes is −0. The sum of two positive
      zeroes, or of two zeroes of opposite sign, is +0.

-   The sum of a zero and a nonzero finite value is equal to the nonzero
      operand.

-   The sum of two nonzero finite values of the same magnitude and
      opposite sign is +0.

-   In the remaining cases, where neither an infinity, nor a zero, nor
      NaN is involved, and the operands have the same sign or have
      different magnitudes, the sum is computed and rounded to the
      nearest representable value using IEEE 754 round-to-nearest mode.
      If the magnitude is too large to represent, the operation
      overflows and the result is then an infinity of appropriate sign.
      The ECMAScript language requires support of gradual underflow as
      defined by IEEE 754.

NOTE The - operator performs subtraction when applied to two operands of
numeric type, producing the difference of its operands; the left operand
is the minuend and the right operand is the subtrahend. Given numeric
operands _a_ and _b_, it is always the case that _a–b_ produces the same
result as _a +(–b)_.


Bitwise Shift Operators

Syntax

ShiftExpression~[Yield]~ :

AdditiveExpression~[?Yield]~
ShiftExpression~[?Yield]~ << AdditiveExpression~[?Yield]~
ShiftExpression~[?Yield]~ >> AdditiveExpression~[?Yield]~
ShiftExpression~[?Yield]~ >>> AdditiveExpression~[?Yield]~

Static Semantics: IsFunctionDefinition

See also: 12.2.0.2, 12.2.10.2, 12.3.1.2, 12.4.2, 12.5.2, 12.6.1, 12.7.1,
12.9.1, 12.10.1, 12.11.1, 12.12.1, 12.13.1, 12.14.2, 12.15.1, 14.1.11,
14.4.8, 14.5.8.

ShiftExpression :

ShiftExpression << AdditiveExpression
ShiftExpression >> AdditiveExpression
ShiftExpression >>> AdditiveExpression

1.  Return FALSE.

Static Semantics: IsValidSimpleAssignmentTarget

See also: 12.2.0.3, 12.2.10.3, 12.3.1.3, 12.4.3, 12.5.3, 12.6.2, 12.7.2,
12.9.2, 12.10.2, 12.11.2, 12.12.2, 12.13.2, 12.14.3, 12.15.2.

ShiftExpression :

ShiftExpression << AdditiveExpression
ShiftExpression >> AdditiveExpression
ShiftExpression >>> AdditiveExpression

1.  Return FALSE.

The Left Shift Operator ( << )

NOTE Performs a bitwise left shift operation on the left operand by the
amount specified by the right operand.

Runtime Semantics: Evaluation

_ShiftExpression_ : _ShiftExpression_ << _AdditiveExpression

1.  Let _lref_ be the result of evaluating _ShiftExpression_.

2.  Let _lval_ be GetValue(_lref_).

3.  ReturnIfAbrupt(_lval_).

4.  Let _rref_ be the result of evaluating _AdditiveExpression_.

5.  Let _rval_ be GetValue(_rref_).

6.  ReturnIfAbrupt(_rval_).

7.  Let _lnum_ be ToInt32(_lval_).

8.  ReturnIfAbrupt(_lnum_).

9.  Let _rnum_ be ToUint32(_rval_).

10. ReturnIfAbrupt(_rnum_).

11. Let _shiftCount_ be the result of masking out all but the least
    significant 5 bits of _rnum_, that is, compute _rnum_ & 0x1F.

12. Return the result of left shifting _lnum_ by _shiftCount_ bits. The
    result is a signed 32-bit integer.

The Signed Right Shift Operator ( >> )

NOTE Performs a sign-filling bitwise right shift operation on the left
operand by the amount specified by the right operand.

Runtime Semantics: Evaluation

_ShiftExpression_ : _ShiftExpression_ >> _AdditiveExpression

1.  Let _lref_ be the result of evaluating _ShiftExpression_.

2.  Let _lval_ be GetValue(_lref_).

3.  ReturnIfAbrupt(_lval_).

4.  Let _rref_ be the result of evaluating _AdditiveExpression_.

5.  Let _rval_ be GetValue(_rref_).

6.  ReturnIfAbrupt(_rval_).

7.  Let _lnum_ be ToInt32(_lval_).

8.  ReturnIfAbrupt(_lnum_).

9.  Let _rnum_ be ToUint32(_rval_).

10. ReturnIfAbrupt(_rnum_).

11. Let _shiftCount_ be the result of masking out all but the least
    significant 5 bits of _rnum_, that is, compute _rnum_ & 0x1F.

12. Return the result of performing a sign-extending right shift of
    _lnum_ by _shiftCount_ bits. The most significant bit is propagated.
    The result is a signed 32-bit integer.

The Unsigned Right Shift Operator ( >>> )

NOTE Performs a zero-filling bitwise right shift operation on the left
operand by the amount specified by the right operand.

Runtime Semantics: Evaluation

_ShiftExpression_ : _ShiftExpression_ >>> _AdditiveExpression

1.  Let _lref_ be the result of evaluating _ShiftExpression_.

2.  Let _lval_ be GetValue(_lref_).

3.  ReturnIfAbrupt(_lval_).

4.  Let _rref_ be the result of evaluating _AdditiveExpression_.

5.  Let _rval_ be GetValue(_rref_).

6.  ReturnIfAbrupt(_rval_).

7.  Let _lnum_ be ToUint32(_lval_).

8.  ReturnIfAbrupt(_lnum_).

9.  Let _rnum_ be ToUint32(_rval_).

10. ReturnIfAbrupt(_rnum_).

11. Let _shiftCount_ be the result of masking out all but the least
    significant 5 bits of _rnum_, that is, compute _rnum_ & 0x1F.

12. Return the result of performing a zero-filling right shift of _lnum
    by _shiftCount_ bits. Vacated bits are filled with zero. The result
    is an unsigned 32-bit integer.


Relational Operators

NOTE The result of evaluating a relational operator is always of type
Boolean, reflecting whether the relationship named by the operator holds
between its two operands.

Syntax

RelationalExpression~[In,\ Yield]~ :

ShiftExpression~[?Yield]~
RelationalExpression~[?In,\ ?Yield]~ < ShiftExpression~[?Yield]~
RelationalExpression~[?In,\ ?Yield]~ > ShiftExpression~[?Yield]~
RelationalExpression~[?In,\ ?Yield]~ <= ShiftExpression~[?\ Yield]~
RelationalExpression~[?In,\ ?Yield]~ >= ShiftExpression~[?Yield]~
RelationalExpression~[?In,\ ?Yield]~ INSTANCEOF
ShiftExpression~[?Yield]~
[+In] RelationalExpression~[In,\ ?Yield]~ IN ShiftExpression~[?Yield]~

NOTE The [In] grammar parameter is needed to avoid confusing the in
operator in a relational expression with the in operator in a for
statement.

Static Semantics: IsFunctionDefinition

See also: 12.2.0.2, 12.2.10.2, 12.3.1.2, 12.4.2, 12.5.2, 12.6.1, 12.7.1,
12.8.1, 12.10.1, 12.11.1, 12.12.1, 12.13.1, 12.14.2, 12.15.1, 14.1.11,
14.4.8, 14.5.8.

RelationalExpression :

RelationalExpression < ShiftExpression
RelationalExpression > ShiftExpression
RelationalExpression <= ShiftExpression
RelationalExpression >= ShiftExpression
RelationalExpression INSTANCEOF ShiftExpression
RelationalExpression IN ShiftExpression

1.  Return FALSE.

Static Semantics: IsValidSimpleAssignmentTarget

See also: 12.2.0.3, 12.2.10.3, 12.3.1.3, 12.4.3, 12.5.3, 12.6.2, 12.7.2,
12.8.2, 12.10.2, 12.11.2, 12.12.2, 12.13.2, 12.14.3, 12.15.2.

RelationalExpression :

RelationalExpression < ShiftExpression
RelationalExpression > ShiftExpression
RelationalExpression <= ShiftExpression
RelationalExpression >= ShiftExpression
RelationalExpression INSTANCEOF ShiftExpression
RelationalExpression IN ShiftExpression

1.  Return FALSE.

Runtime Semantics: Evaluation

_RelationalExpression_ : _RelationalExpression_ < _ShiftExpression

1.  Let _lref_ be the result of evaluating _RelationalExpression_.

2.  Let _lval_ be GetValue(_lref_).

3.  ReturnIfAbrupt(_lval_).

4.  Let _rref_ be the result of evaluating _ShiftExpression_.

5.  Let _rval_ be GetValue(_rref_).

6.  Let _r_ be the result of performing Abstract Relational Comparison
    _lval_ < _rval_. (see 7.2.8)

7.  ReturnIfAbrupt(_r_).

8.  If _r_ is UNDEFINED, return FALSE. Otherwise, return _r_.

_RelationalExpression_ : _RelationalExpression_ > _ShiftExpression

1.  Let _lref_ be the result of evaluating _RelationalExpression_.

2.  Let _lval_ be GetValue(_lref_).

3.  ReturnIfAbrupt(_lval_).

4.  Let _rref_ be the result of evaluating _ShiftExpression_.

5.  Let _rval_ be GetValue(_rref_).

6.  Let _r_ be the result of performing Abstract Relational Comparison
    _rval_ < _lval_ with _LeftFirst_ equal to FALSE.

7.  ReturnIfAbrupt(_r_).

8.  If _r_ is UNDEFINED, return FALSE. Otherwise, return _r_.

_RelationalExpression_ : _RelationalExpression_ <= _ShiftExpression

1.  Let _lref_ be the result of evaluating _RelationalExpression_.

2.  Let _lval_ be GetValue(_lref_).

3.  ReturnIfAbrupt(_lval_).

4.  Let _rref_ be the result of evaluating _ShiftExpression_.

5.  Let _rval_ be GetValue(_rref_).

6.  Let _r_ be the result of performing Abstract Relational Comparison
    _rval_ < _lval_ with _LeftFirst_ equal to FALSE.

7.  ReturnIfAbrupt(_r_).

8.  If _r_ is TRUE or UNDEFINED, return FALSE. Otherwise, return TRUE.

_RelationalExpression_ : _RelationalExpression_ >= _ShiftExpression

1.  Let _lref_ be the result of evaluating _RelationalExpression_.

2.  Let _lval_ be GetValue(_lref_).

3.  ReturnIfAbrupt(_lval_).

4.  Let _rref_ be the result of evaluating _ShiftExpression_.

5.  Let _rval_ be GetValue(_rref_).

6.  Let _r_ be the result of performing Abstract Relational Comparison
    _lval_ < _rval_.

7.  ReturnIfAbrupt(_r_).

8.  If _r_ is TRUE or UNDEFINED, return FALSE. Otherwise, return TRUE.

_RelationalExpression_ : _RelationalExpression_ INSTANCEOF
_ShiftExpression

1.  Let _lref_ be the result of evaluating _RelationalExpression_.

2.  Let _lval_ be GetValue(_lref_).

3.  ReturnIfAbrupt(_lval_).

4.  Let _rref_ be the result of evaluating _ShiftExpression_.

5.  Let _rval_ be GetValue(_rref_).

6.  ReturnIfAbrupt(_rval_).

7.  Return InstanceofOperator(_lval_, _rval_).

_RelationalExpression_ : _RelationalExpression_ IN _ShiftExpression

1.  Let _lref_ be the result of evaluating _RelationalExpression_.

2.  Let _lval_ be GetValue(_lref_).

3.  ReturnIfAbrupt(_lval_).

4.  Let _rref_ be the result of evaluating _ShiftExpression_.

5.  Let _rval_ be GetValue(_rref_).

6.  ReturnIfAbrupt(_rval_).

7.  If Type(_rval_) is not Object, throw a TYPEERROR exception.

8.  Return HasProperty(_rval_, ToPropertyKey(_lval_)).

Runtime Semantics: InstanceofOperator(O, C)

The abstract operation InstanceofOperator(_O_, _C_) implements the
generic algorithm for determining if an object _O_ inherits from the
inheritance path defined by constructor _C_. This abstract operation
performs the following steps:

1.  If Type(_C_) is not Object, throw a TYPEERROR exception.

2.  Let _instOfHandler_ be GetMethod(_C_,@@hasInstance).

3.  ReturnIfAbrupt(_instOfHandler_).

4.  If _instOfHandler_ is not UNDEFINED, then

    a.  Let _result_ be the result of calling the [[Call]] internal
        method of _instOfHandler_ passing _C_ as _thisArgument_ and a
        new List containing _O_ as _argumentsList_.

    b.  Return ToBoolean(_result_).

5.  If IsCallable(_C_) is FALSE, then throw a TYPEERROR exception.

6.  Return OrdinaryHasInstance(_C_, _O_).

NOTE Steps 5 and 6 provide compatibility with previous editions of
ECMAScript that did not use a @@hasInstance method to define the
INSTANCEOF operator semantics. If a function object does not define or
inherit @@hasInstance it uses the default INSTANCEOF semantics.


Equality Operators

NOTE The result of evaluating an equality operator is always of type
Boolean, reflecting whether the relationship named by the operator holds
between its two operands.

Syntax

EqualityExpression~[In,\ Yield]~ :

RelationalExpression~[?In,\ ?Yield]~
EqualityExpression~[?In,\ ?Yield]~ ==
RelationalExpression~[?In,\ ?Yield]~
EqualityExpression~[?In,\ ?Yield]~ !=
RelationalExpression~[?In,\ ?Yield]~
EqualityExpression~[?In,\ ?Yield]~ ===
RelationalExpression~[?In,\ ?Yield]~
EqualityExpression~[?In,\ ?Yield]~ !==
RelationalExpression~[?In,\ ?Yield]~

Static Semantics: IsFunctionDefinition

See also: 12.2.0.2, 12.2.10.2, 12.3.1.2, 12.4.2, 12.5.2, 12.6.1, 12.7.1,
12.8.1, 12.9.1, 12.11.1, 12.12.1, 12.13.1, 12.14.2, 12.15.1, 14.1.11,
14.4.8, 14.5.8.

EqualityExpression :

EqualityExpression == RelationalExpression
EqualityExpression != RelationalExpression
EqualityExpression === RelationalExpression
EqualityExpression !== RelationalExpression

1.  Return FALSE.

Static Semantics: IsValidSimpleAssignmentTarget

See also: 12.2.0.3, 12.2.10.3, 12.3.1.3, 12.4.3, 12.5.3, 12.6.2, 12.7.2,
12.8.2, 12.9.2, 12.11.2, 12.12.2, 12.13.2, 12.14.3, 12.15.2.

EqualityExpression :

EqualityExpression == RelationalExpression
EqualityExpression != RelationalExpression
EqualityExpression === RelationalExpression
EqualityExpression !== RelationalExpression

1.  Return FALSE.

Runtime Semantics: Evaluation

_EqualityExpression_ : _EqualityExpression_ == _RelationalExpression

1.  Let _lref_ be the result of evaluating _EqualityExpression_.

2.  Let _lval_ be GetValue(_lref_).

3.  ReturnIfAbrupt(_lval_).

4.  Let _rref_ be the result of evaluating _RelationalExpression_.

5.  Let _rval_ be GetValue(_rref_).

6.  ReturnIfAbrupt(_rval_).

7.  Return the result of performing Abstract Equality Comparison _rval
    == _lval_.

_EqualityExpression_ : _EqualityExpression_ != _RelationalExpression

1.  Let _lref_ be the result of evaluating _EqualityExpression_.

2.  Let _lval_ be GetValue(_lref_).

3.  ReturnIfAbrupt(_lval_).

4.  Let _rref_ be the result of evaluating _RelationalExpression_.

5.  Let _rval_ be GetValue(_rref_).

6.  ReturnIfAbrupt(_rval_).

7.  Let _r_ be the result of performing Abstract Equality Comparison
    _rval_ == _lval_.

8.  If _r_ is TRUE, return FALSE. Otherwise, return TRUE.

_EqualityExpression_ : _EqualityExpression_ === _RelationalExpression

1.  Let _lref_ be the result of evaluating _EqualityExpression_.

2.  Let _lval_ be GetValue(_lref_).

3.  ReturnIfAbrupt(_lval_)

4.  Let _rref_ be the result of evaluating _RelationalExpression_.

5.  Let _rval_ be GetValue(_rref_).

6.  ReturnIfAbrupt(_rval_).

7.  Return the result of performing Strict Equality Comparison _rval
    === _lval_.

_EqualityExpression_ : _EqualityExpression_ !== _RelationalExpression

1.  Let _lref_ be the result of evaluating _EqualityExpression_.

2.  Let _lval_ be GetValue(_lref_).

3.  ReturnIfAbrupt(_lval_).

4.  Let _rref_ be the result of evaluating _RelationalExpression_.

5.  Let _rval_ be GetValue(_rref_).

6.  ReturnIfAbrupt(_rval_).

7.  Let _r_ be the result of performing Strict Equality Comparison
    _rval_ === _lval_.

8.  If _r_ is TRUE, return FALSE. Otherwise, return TRUE.

NOTE 1 Given the above definition of equality:

-   String comparison can be forced by: "" + A == "" + B.

-   Numeric comparison can be forced by: +A == +B.

-   Boolean comparison can be forced by: !A == !B.

NOTE 2 The equality operators maintain the following invariants:

-   A != B is equivalent to !(A == B).

-   A == B is equivalent to B == A, except in the order of evaluation of
      A and B.

NOTE 3 The equality operator is not always transitive. For example,
there might be two distinct String objects, each representing the same
String value; each String object would be considered equal to the String
value by the == operator, but the two String objects would not be equal
to each other. For Example:

-   NEW STRING("A") == "A" and "A" == NEW STRING("A")are both TRUE.

-   NEW STRING("A") == NEW STRING("A") is FALSE.

NOTE 4 Comparison of Strings uses a simple equality test on sequences of
code unit values. There is no attempt to use the more complex,
semantically oriented definitions of character or string equality and
collating order defined in the Unicode specification. Therefore Strings
values that are canonically equal according to the Unicode standard
could test as unequal. In effect this algorithm assumes that both
Strings are already in normalized form.


Binary Bitwise Operators

Syntax

BitwiseANDExpression~[In,\ Yield]~ :

EqualityExpression~[?In,\ ?Yield]~
BitwiseANDExpression~[?In,\ ?Yield]~ &
EqualityExpression~[?In,\ ?Yield]~

BitwiseXORExpression~[In,\ Yield]~ :

BitwiseANDExpression~[?In,\ ?Yield]~
BitwiseXORExpression~[?In,\ ?Yield]~ ^
BitwiseANDExpression~[?In,\ ?Yield]~

BitwiseORExpression~[In,\ Yield]~ :

BitwiseXORExpression~[?In,\ ?Yield]~
BitwiseORExpression~[?In,\ ?Yield]~ |
BitwiseXORExpression~[?In,\ ?Yield]~

Static Semantics: IsFunctionDefinition

See also: 12.2.0.2, 12.2.10.2, 12.3.1.2, 12.4.2, 12.5.2, 12.6.1, 12.7.1,
12.8.1, 12.9.1, 12.10.1, 12.12.1, 12.13.1, 12.14.2, 12.15.1, 14.1.11,
14.4.8, 14.5.8.

_BitwiseANDExpression_ : _BitwiseANDExpression_ & _EqualityExpression

_BitwiseXORExpression_ : _BitwiseXORExpression_ ^ _BitwiseANDExpression

_BitwiseORExpression_ : _BitwiseORExpression_ | _BitwiseXORExpression

1.  Return FALSE.

Static Semantics: IsValidSimpleAssignmentTarget 

See also: 12.2.0.3, 12.2.10.3, 12.3.1.3, 12.4.3, 12.5.3, 12.6.2, 12.7.2,
12.8.2, 12.9.2, 12.10.2, 12.12.2, 12.13.2, 12.14.3, 12.15.2.

_BitwiseANDExpression_ : _BitwiseANDExpression_ & _EqualityExpression

_BitwiseXORExpression_ : _BitwiseXORExpression_ ^ _BitwiseANDExpression

_BitwiseORExpression_ : _BitwiseORExpression_ | _BitwiseXORExpression

1.  Return FALSE.

Runtime Semantics: Evaluation

The production _A_ : _A @ B_, where @ is one of the bitwise operators in
the productions above, is evaluated as follows:

1.  Let _lref_ be the result of evaluating _A_.

2.  Let _lval_ be GetValue(_lref_).

3.  ReturnIfAbrupt(_lval_).

4.  Let _rref_ be the result of evaluating _B_.

5.  Let _rval_ be GetValue(_rref_).

6.  ReturnIfAbrupt(_rval_).

7.  Let _lnum_ be ToInt32(_lval_).

8.  ReturnIfAbrupt(_lnum_).

9.  Let _rnum_ be ToInt32(_rval_).

10. ReturnIfAbrupt(_rnum_).

11. Return the result of applying the bitwise operator @ to _lnum_ and
    _rnum_. The result is a signed 32 bit integer.


Binary Logical Operators

Syntax

LogicalANDExpression~[In,\ Yield]~ :

BitwiseORExpression~[?In,\ ?Yield]~
LogicalANDExpression~[?In,\ ?Yield]~ &&
BitwiseORExpression~[?In,\ ?Yield]~

LogicalORExpression~[In,\ Yield]~ :

LogicalANDExpression~[?In,\ ?Yield]~
LogicalORExpression~[?In,\ ?Yield]~ ||
LogicalANDExpression~[?In,\ ?Yield]~

NOTE The value produced by a && or || operator is not necessarily of
type Boolean. The value produced will always be the value of one of the
two operand expressions.

Static Semantics: IsFunctionDefinition

See also: 12.2.0.2, 12.2.10.2, 12.3.1.2, 12.4.2, 12.5.2, 12.6.1, 12.7.1,
12.8.1, 12.9.1, 12.10.1, 12.11.1, 12.13.1, 12.14.2, 12.15.1, 14.1.11,
14.4.8, 14.5.8.

_LogicalANDExpression_ : _LogicalANDExpression_ && _BitwiseORExpression

_LogicalORExpression_ : _LogicalORExpression_ || _LogicalANDExpression

1.  Return FALSE.

Static Semantics: IsValidSimpleAssignmentTarget

See also: 12.2.0.3, 12.2.10.3, 12.3.1.3, 12.4.3, 12.5.3, 12.6.2, 12.7.2,
12.8.2, 12.9.2, 12.10.2, 12.11.2, 12.13.2, 12.14.3, 12.15.2.

_LogicalANDExpression_ : _LogicalANDExpression_ && _BitwiseORExpression

_LogicalORExpression_ : _LogicalORExpression_ || _LogicalANDExpression

1.  Return FALSE.

Runtime Semantics: Evaluation

_LogicalANDExpression_ : _LogicalANDExpression_ && _BitwiseORExpression

1.  Let _lref_ be the result of evaluating _LogicalANDExpression_.

2.  Let _lval_ be GetValue(_lref_).

3.  Let _lbool_ be ToBoolean(_lval_).

4.  ReturnIfAbrupt(_lbool_).

5.  If _lbool_ is FALSE, return _lval_.

6.  Let _rref_ be the result of evaluating _BitwiseORExpression_.

7.  Return GetValue(_rref_).

_LogicalORExpression_ : _LogicalORExpression_ || _LogicalANDExpression

1.  Let _lref_ be the result of evaluating _LogicalORExpression_.

2.  Let _lval_ be GetValue(_lref_).

3.  Let _lbool_ be ToBoolean(_lval_).

4.  ReturnIfAbrupt(_lbool_).

5.  If _lbool_ is TRUE, return _lval_.

6.  Let _rref_ be the result of evaluating _LogicalANDExpression_.

7.  Return GetValue(_rref_).


Conditional Operator ( ? : )

Syntax

ConditionalExpression~[In,\ Yield]~ :

LogicalORExpression~[?In,\ ?Yield]~
LogicalORExpression~[?In,?Yield]~ ? AssignmentExpression~[In,\ ?Yield]~
: AssignmentExpression~[?In,\ ?Yield]~

NOTE The grammar for a _ConditionalExpression_ in ECMAScript is slightly
different from that in C and Java, which each allow the second
subexpression to be an _Expression_ but restrict the third expression to
be a _ConditionalExpression_. The motivation for this difference in
ECMAScript is to allow an assignment expression to be governed by either
arm of a conditional and to eliminate the confusing and fairly useless
case of a comma expression as the centre expression.

Static Semantics: IsFunctionDefinition

See also: 12.2.0.2, 12.2.10.2, 12.3.1.2, 12.4.2, 12.5.2, 12.6.1, 12.7.1,
12.8.1, 12.9.1, 12.10.1, 12.11.1, 12.12.1, 12.14.2, 12.15.1, 14.1.11,
14.4.8, 14.5.8.

_ConditionalExpression_ : _LogicalORExpression_ ? _AssignmentExpression
: _AssignmentExpression_

1.  Return FALSE.

Static Semantics: IsValidSimpleAssignmentTarget

See also: 12.2.0.3, 12.2.10.3, 12.3.1.3, 12.4.3, 12.5.3, 12.6.2, 12.7.2,
12.8.2, 12.9.2, 12.10.2, 12.11.2, 12.12.2, 12.14.3, 12.15.2.

_ConditionalExpression_ : _LogicalORExpression_ ? _AssignmentExpression
: _AssignmentExpression_

1.  Return FALSE.

Runtime Semantics: Evaluation

_ConditionalExpression_ : _LogicalORExpression_ ? _AssignmentExpression
: _AssignmentExpression_

1.  Let _lref_ be the result of evaluating _LogicalORExpression_.

2.  Let _lval_ be ToBoolean(GetValue(_lref_)).

3.  ReturnIfAbrupt(_lval_).

4.  If _lval_ is TRUE, then

    a.  Let _trueRef_ be the result of evaluating the first
        _AssignmentExpression_.

    b.  Return GetValue(_trueRef_).

5.  Else

    a.  Let _falseRef_ be the result of evaluating the second
        _AssignmentExpression_.

    b.  Return GetValue(_falseRef_).


Assignment Operators

Syntax

AssignmentExpression~[In,\ Yield]~ :

ConditionalExpression~[?In,\ ?Yield]~
[+Yield] YieldExpression~[?In]~
ArrowFunction~[?In,\ ?Yield]~
LeftHandSideExpression~[?Yield]~ = AssignmentExpression~[?In,\ ?Yield]~
LeftHandSideExpression~[?Yield]~ AssignmentOperator
AssignmentExpression~[?In,\ ?Yield]~

AssignmentOperator : ONE OF

  ---- ---- ---- ---- ---- ----- ----- ------ ---- ---- ----
  *=   /=   %=   +=   -=   <<=   >>=   >>>=   &=   ^=   |=
  ---- ---- ---- ---- ---- ----- ----- ------ ---- ---- ----

Static Semantics: Early Errors

_AssignmentExpression_ : _LeftHandSideExpression_ =
_AssignmentExpression

-   It is a Syntax Error if _LeftHandSideExpression_ is either an
    _ObjectLiteral_ or an _ArrayLiteral_ and the lexical token sequence
    matched by _LeftHandSideExpression_ cannot be parsed with no tokens
    left over using _AssignmentPattern_ as the goal symbol.

-   If _LeftHandSideExpression_ is either an _ObjectLiteral_ or an
    _ArrayLiteral_ and if the lexical token sequence matched by
    _LeftHandSideExpression_ can be parsed with no tokens left over
    using _AssignmentPattern_ as the goal symbol then the following
    rules are not applied. Instead, the Early Error rules for
    _AssignmentPattern_ are used.

-   It is a Syntax Error if _LeftHandSideExpression_ is an
    _IdentifierReference_ that can be statically determined to always
    resolve to a declarative environment record binding and the resolved
    binding is an immutable binding.

-   It is an early Reference Error if _LeftHandSideExpression_ is
    neither an _ObjectLiteral_ nor an _ArrayLiteral_ and
    IsValidSimpleAssignmentTarget of _LeftHandSideExpression_ is FALSE.

_AssignmentExpression_ : _LeftHandSideExpression_ _AssignmentOperator
_AssignmentExpression

-   It is a Syntax Error if the _LeftHandSideExpression_ is an
    _IdentifierReference_ that can be statically determined to always
    resolve to a declarative environment record binding and the resolved
    binding is an immutable binding.

-   It is an early Reference Error if IsValidSimpleAssignmentTarget of
    _LeftHandSideExpression_ is FALSE.

Static Semantics: IsFunctionDefinition

See also: 12.2.0.2, 12.2.10.2, 12.3.1.2, 12.4.2, 12.5.2, 12.6.1, 12.7.1,
12.8.1, 12.9.1, 12.10.1, 12.11.1, 12.12.1, 12.13.1, 12.15.1, 14.1.11,
14.4.8, 14.5.8.

_AssignmentExpression_ : _ArrowFunction

1.  Return TRUE.

AssignmentExpression :

YieldExpression
LeftHandSideExpression = AssignmentExpression
LeftHandSideExpression AssignmentOperator AssignmentExpression

1.  Return FALSE.

Static Semantics: IsValidSimpleAssignmentTarget

See also: 12.2.0.3, 12.2.10.3, 12.3.1.3, 12.4.3, 12.5.3, 12.6.2, 12.7.2,
12.8.2, 12.9.2, 12.10.2, 12.11.2, 12.12.2, 12.13.2, 12.15.2.

AssignmentExpression :

YieldExpression
ArrowFunction
LeftHandSideExpression = AssignmentExpression
LeftHandSideExpression AssignmentOperator AssignmentExpression

1.  Return FALSE.

Runtime Semantics: Evaluation 

_AssignmentExpression_~[In,\ Yield]~ :
_LeftHandSideExpression_~[?Yield]~ =
_AssignmentExpression_~[?In,\ ?Yield]~

1.  If _LeftHandSideExpression_ is neither an _ObjectLiteral_ nor an
    _ArrayLiteral_ then

    a.  Let _lref_ be the result of evaluating _LeftHandSideExpression_.

    b.  ReturnIfAbrupt(_lref_).

    c.  Let _rref_ be the result of evaluating _AssignmentExpression_.

    d.  Let _rval_ be GetValue(_rref_).

    e.  If IsAnonymousFunctionDefinition(_AssignmentExpression_) and
        IsIdentifierRef of _LeftHandSideExpression_ are both TRUE, then

        i.  Let _hasNameProperty_ be HasOwnProperty(_rval_, "NAME").

        ii. ReturnIfAbrupt(_hasNameProperty_).

        iii. If _hasNameProperty_ is FALSE, then

            1.  SetFunctionName(_rval_, GetReferencedName(_lref_)).

            2.  Assert: SetFunctionName will not return an abrupt
                completion.

    f.  Let _status_ be PutValue(_lref_, _rval_).

    g.  ReturnIfAbrupt(_status_).

    h.  Return _rval_.

2.  Let _AssignmentPattern_ be the parse of the source code
    corresponding to _LeftHandSideExpression_ using
    _AssignmentPattern_~[?Yield]~ as the goal symbol.

3.  Let _rref_ be the result of evaluating _AssignmentExpression_.

4.  Let _rval_ be GetValue(_rref_).

5.  ReturnIfAbrupt(_rval_).

6.  If Type(_rval_) is not Object, then throw a TYPEERROR exception.

7.  Let _status_ be the result of performing
    DestructuringAssignmentEvaluation of _AssignmentPattern_ using
    _rval_ as the argument.

8.  ReturnIfAbrupt(_status_).

9.  Return _rval_.

_AssignmentExpression_ : _LeftHandSideExpression_ _AssignmentOperator
_AssignmentExpression

1.  Let _lref_ be the result of evaluating _LeftHandSideExpression_.

2.  Let _lval_ be GetValue(_lref_).

3.  ReturnIfAbrupt(_lval_).

4.  Let _rref_ be the result of evaluating _AssignmentExpression_.

5.  Let _rval_ be GetValue(_rref_).

6.  ReturnIfAbrupt(_rval_).

7.  Let _operator_ be the @ where _AssignmentOperator_ is @=

8.  Let _r_ be the result of applying operator @ to _lval_ and _rval_.

9.  Let _status_ be PutValue(_lref_, _r_).

10. ReturnIfAbrupt(_status_).

11. Return _r_.

NOTE When an assignment occurs within strict mode code, it is an runtime
error if _lref_ in step 1.f.of the first algorithm or step 9 of the
second algorithm it is an unresolvable reference. If it is, a
REFERENCEERROR exception is thrown. The _LeftHandSide_ also may not be a
reference to a data property with the attribute value
{[[Writable]]:FALSE}, to an accessor property with the attribute value
{[[Set]]:UNDEFINED}, nor to a non-existent property of an object for
which the IsExtensible predicate returns the value FALSE. In these cases
a TYPEERROR exception is thrown.

Destructuring Assignment

Supplemental Syntax

In certain circumstances when processing the production
_AssignmentExpression_ : _LeftHandSideExpression_ =
_AssignmentExpression_ the following grammar is used to refine the
interpretation of _LeftHandSideExpression_.

AssignmentPattern~[Yield]~ :

ObjectAssignmentPattern~[?Yield]~
ArrayAssignmentPattern~[?Yield]~

ObjectAssignmentPattern~[Yield]~ :

{ }
{ AssignmentPropertyList~[?Yield]~ }
{ AssignmentPropertyList~[?Yield]~ , }

ArrayAssignmentPattern~[Yield]~ :

[ Elision~opt~ AssignmentRestElement~[?Yield]opt~ ]
[ AssignmentElementList~[?Yield]~ ]
[ AssignmentElementList~[?Yield]~ , Elision~opt~
AssignmentRestElement~[?Yield]opt~ ]

AssignmentPropertyList~[Yield]~ :

AssignmentProperty~[?Yield]~
AssignmentPropertyList~[?Yield]~ , AssignmentProperty~[?Yield]~

AssignmentElementList~[Yield]~ :

AssignmentElisionElement~[?Yield]~
AssignmentElementList~[?Yield]~ , AssignmentElisionElement~[?Yield]~

AssignmentElisionElement~[Yield]~ :

Elision~opt~ AssignmentElement~[?Yield]~

AssignmentProperty~[Yield]~ :

IdentifierReference~[?Yield]~ Initializer~[In,?Yield]opt~
PropertyName : AssignmentElement~[?Yield]~

AssignmentElement~[Yield]~ :

DestructuringAssignmentTarget~[?Yield]~ Initializer~[In,?Yield]opt~

AssignmentRestElement~[Yield]~ :

... DestructuringAssignmentTarget~[?Yield]~

DestructuringAssignmentTarget~[Yield]~ :

LeftHandSideExpression~[?Yield]~

Static Semantics: Early Errors

_AssignmentProperty_ : _IdentifierReference Initializer_~opt~

-   It is a Syntax Error if IsValidSimpleAssignment of
    _IdentifierReference_ is FALSE.

-   It is a Syntax Error if _IdentifierReference_ statically resolves to
    a immutable binding_._

_AssignmentRestElement_ : ... _DestructuringAssignmentTarget

-   It is a Syntax Error if IsValidSimpleAssignmentTarget of
    _DestructuringAssignmentTarget_ is FALSE_._

_DestructuringAssignmentTarget_ : _LeftHandSideExpression

-   It is a Syntax Error if _LeftHandSideExpression_ is either an
    _ObjectLiteral_ or an _ArrayLiteral_ and if the lexical token
    sequence matched by _LeftHandSideExpression_ cannot be parsed with
    no tokens left over using _AssignmentPattern_ as the goal symbol.

-   It is a Syntax Error if _LeftHandSideExpression_ is neither an
    _ObjectLiteral_ nor an _ArrayLiteral_ and
    IsValidSimpleAssignmentTarget(_LeftHandSideExpression_) is FALSE.

-   It is a Syntax Error if _LeftHandSideExpression_ is an
    _IdentifierReference_ that can be statically determined to always
    resolve to a declarative environment record binding and the resolved
    binding is an immutable binding.

-   It is a Syntax Error if _LeftHandSideExpression_ is
    _CoverParenthesizedExpressionAndArrowParameterList :_ ( _Expression_
    )
    and _Expression_ derives a production that would produce a Syntax
    Error according to these rules if that production is substituted for
    _LeftHandSideExpression_. This rule is recursively applied.

  NOTE The last rule means that the other rules are applied even if
  multiple levels of nested parentheses surround _Expression_.

Runtime Semantics: DestructuringAssignmentEvaluation 

  with parameter _obj_

_ObjectAssignmentPattern_ : { }

1.  Return NormalCompletion(empty).

_ArrayAssignmentPattern_ : [ ]

1.  Let _iterator_ be GetIterator(_obj_).

2.  ReturnIfAbrupt(_iterator_).

3.  Return NormalCompletion(empty).

_ArrayAssignmentPattern_ : [ _Elision_ ]

1.  Let _iterator_ be GetIterator(_obj_).

2.  ReturnIfAbrupt(_iterator_).

3.  Return the result of performing
    IteratorDestructuringAssignmentEvaluation of _Elision_ with
    _iterator_ as the argument.

_ArrayAssignmentPattern_ : [ _Elision_~opt~ _AssignmentRestElement_ ]

1.  Let _iterator_ be GetIterator(_obj_).

2.  ReturnIfAbrupt(_iterator_).

3.  If _Elision_ is present, then

    a.  Let _status_ be the result of performing
        IteratorDestructuringAssignmentEvaluation of _Elision_ with
        _iterator_ as the argument.

    b.  ReturnIfAbrupt(_status_).

4.  Return the result of performing
    IteratorDestructuringAssignmentEvaluation of _AssignmentRestElement_
    with _iterator_ as the argument.

_ArrayAssignmentPattern_ : [ _AssignmentElementList_ ]

1.  Let _iterator_ be GetIterator(_obj_).

2.  ReturnIfAbrupt(_iterator_).

3.  Return the result of performing
    IteratorDestructuringAssignmentEvaluation of _AssignmentElementList_
    using _iterator_ as the argument.

_ArrayAssignmentPattern_ : [ _AssignmentElementList_ , _Elision_~opt~
_AssignmentRestElement~opt~_ ]

1.  Let _iterator_ be GetIterator(_obj_).

2.  ReturnIfAbrupt(_iterator_).

3.  Let _status_ be the result of performing
    IteratorDestructuringAssignmentEvaluation of _AssignmentElementList_
    using _iterator_ as the argument.

4.  ReturnIfAbrupt(_status_).

5.  If _Elision_ is present, then

    a.  Let _status_ be the result of performing
        IteratorDestructuringAssignmentEvaluation of _Elision_ with
        _iterator_ as the argument.

    b.  ReturnIfAbrupt(_status_).

6.  If _AssignmentRestElement_ is not present, then return _status_.

7.  Return the result of performing
    IteratorDestructuringAssignmentEvaluation of _AssignmentRestElement_
    with _iterator_ as the argument.

8.  

_AssignmentPropertyList_ : _AssignmentPropertyList_ ,
_AssignmentProperty

1.  Let _status_ be the result of performing
    DestructuringAssignmentEvaluation for _AssignmentPropertyList_ using
    _obj_ as the argument.

2.  ReturnIfAbrupt(_status_).

3.  Return the result of performing DestructuringAssignmentEvaluation
    for _AssignmentProperty_ using _obj_ as the argument.

_AssignmentProperty_ : _IdentifierReference Initializer_~opt~

1.  Let _P_ be StringValue of _IdentifierReference_.

2.  Let _v_ be Get(_obj_, _P_).

3.  ReturnIfAbrupt(_v_).

4.  If _Initializer_~opt~ is present and _v_ is UNDEFINED, then

    a.  Let _defaultValue_ be the result of evaluating _Initializer_.

    b.  Let _v_ be GetValue(_defaultValue_).

    c.  ReturnIfAbrupt(_v_).

5.  Let _lref_ be ResolveBinding(_P)_.

6.  Return PutValue(_lref_,_v_).

_AssignmentProperty_ : _PropertyName_ : _AssignmentElement

1.  Let _name_ be the result of evaluating _PropertyName_.

2.  ReturnIfAbrupt(_name_).

3.  Return the result of performing
    KeyedDestructuringAssignmentEvaluation of _AssignmentElement_ with
    _obj_ and _name_ as the arguments.

Runtime Semantics: IteratorDestructuringAssignmentEvaluation 

  with parameters _iterator_

_AssignmentElementList_ : _AssignmentElisionElement

1.  Return the result of performing
    IteratorDestructuringAssignmentEvaluation of
    _AssignmentElisionElement_ using _iterator_ as the _argument_.

_AssignmentElementList_ : _AssignmentElementList_ ,
_AssignmentElisionElement

1.  Let _status_ be the result of performing
    IteratorDestructuringAssignmentEvaluation of _AssignmentElementList_
    using _iterator_ as the _argument._

2.  ReturnIfAbrupt(_status_).

3.  Return the result of performing
    IteratorDestructuringAssignmentEvaluation of
    _AssignmentElisionElement_ using _iterator_ as the _argument_.

_AssignmentElisionElement_ : _AssignmentElement

1.  Return the result of performing
    IteratorDestructuringAssignmentEvaluation of _AssignmentElement_
    with _iterator_ as the argument.

_AssignmentElisionElement_ : _Elision_ _AssignmentElement

1.  Let _status_ be the result of performing
    IteratorDestructuringAssignmentEvaluation of _Elision_ with
    _iterator_ as the argument.

2.  ReturnIfAbrupt(_status_).

3.  Return the result of performing
    IteratorDestructuringAssignmentEvaluation of _AssignmentElement_
    with _iterator_ as the argument.

_Elision_ : ,

1.  Return IteratorStep(_iterator_).

_Elision_ : _Elision_ ,

1.  Let _status_ be the result of performing
    IteratorDestructuringAssignmentEvaluation of _Elision_ with
    _iterator_ as the argument.

2.  ReturnIfAbrupt(_status_).

3.  Return IteratorStep(_iterator_).

_AssignmentElement_~[Yield]~ : _DestructuringAssignmentTarget
_Initializer_~opt~

1.  If _DestructuringAssignmentTarget_ is neither an _ObjectLiteral_ nor
    an _ArrayLiteral_ then

    a.  Let _lref_ be the result of evaluating
        _DestructuringAssignmentTarget_.

    b.  ReturnIfAbrupt(_lref_).

2.  Let _next_ be IteratorStep(_iterator_).

3.  ReturnIfAbrupt(_next_).

4.  If _next_ is FALSE, then let _v_ be UNDEFINED

5.  Else

    a.  Let _v_ be IteratorValue(_next_).

    b.  ReturnIfAbrupt(_v_).

6.  If _Initializer_ is present and _v_ is UNDEFINED, then

    a.  Let _defaultValue_ be the result of evaluating _Initializer_.

    b.  Let _v_ be GetValue(_defaultValue_)

    c.  ReturnIfAbrupt(_v_).

7.  If _DestructuringAssignmentTarget_ is an _ObjectLiteral_ or an
    _ArrayLiteral_ then

    a.  Let _nestedAssignmentPattern_ be the parse of the source code
        corresponding to _DestructuringAssignmentTarget_ using either
        _AssignmentPattern_ or _AssignmentPattern_~[Yield]~ as the goal
        symbol depending upon whether this _AssignmentElement_ has the
        ~Yield~ parameter.

    b.  If Type(_v_) is not Object, then throw a TYPEERROR exception.

    c.  Return the result of performing
        DestructuringAssignmentEvaluation of _nestedAssignmentPattern_
        with _v_ as the argument.

8.  Return PutValue(_lref_,_v_).

NOTE Left to right evaluation order is maintained by evaluating a
_DestructuringAssignmentTarget_ that is not a destructuring pattern
prior to accessing the iterator or evaluating the _Initializer_.

_AssignmentRestElement_ : ... _DestructuringAssignmentTarget

1.  Let _lref_ be the result of evaluating
    _DestructuringAssignmentTarget_.

2.  ReturnIfAbrupt(_lref_).

3.  Let _A_ be ArrayCreate(0).

4.  Let _n_=0;

5.  Repeat

    a.  Let _next_ be IteratorStep(_iterator_).

    b.  ReturnIfAbrupt(_next_).

    c.  If _next_ is FALSE, then

        i.  Return PutValue(_lref_, _A_).

    d.  Let _nextValue_ be IteratorValue(_next_).

    e.  ReturnIfAbrupt(_nextValue_).

    f.  Let _defineStatus_ be CreateDataPropertyOrThrow(_A_,
        ToString(ToUint32(_n)_), _nextValue_).

    g.  ReturnIfAbrupt(_defineStatus_).

    h.  Increment _n_ by 1.

Runtime Semantics: KeyedDestructuringAssignmentEvaluation 

  with parameters _obj_ and _propertyName _

_AssignmentElement_ _~[Yield]~_ : _DestructuringAssignmentTarget
_Initializer_~opt~

1.  Let _v_ be Get(_obj_, _propertyName_).

2.  ReturnIfAbrupt(_v_).

3.  If _Initializer_ is present and _v_ is UNDEFINED, then

    a.  Let _defaultValue_ be the result of evaluating _Initializer_.

    b.  Let _v_ be GetValue(_defaultValue_)

    c.  ReturnIfAbrupt(_v_).

4.  If _DestructuringAssignmentTarget_ is an _ObjectLiteral_ or an
    _ArrayLiteral_ then

    a.  Let _AssignmentPattern_ be the parse of the source code
        corresponding to _DestructuringAssignmentTarget_ using either
        _AssignmentPattern_ or _AssignmentPattern_~[Yield]~ as the goal
        symbol depending upon whether this _AssignmentElement_ has the
        ~Yield~ parameter.

    b.  If Type(_v_) is not Object, then throw a TYPEERROR exception.

    c.  Return the result of performing
        DestructuringAssignmentEvaluation of _AssignmentPattern_ with
        _v_ as the argument.

5.  Let _lref_ be the result of evaluating
    _DestructuringAssignmentTarget_.

6.  Return PutValue(_lref_,_v_).


Comma Operator ( , )

Syntax

_Expression_~[In,\ Yield]~ :

_AssignmentExpression_~[?In,\ ?Yield]~
Expression~[?In,\ ?Yield]~ , AssignmentExpression~[?In,\ ?Yield]~

Static Semantics: IsFunctionDefinition

See also: 12.2.0.2, 12.2.10.2, 12.3.1.2, 12.4.2, 12.5.2, 12.6.1, 12.7.1,
12.8.1, 12.9.1, 12.10.1, 12.11.1, 12.12.1, 12.13.1, 12.14.2, 14.1.11,
14.4.8, 14.5.8.

_Expression_ _: Expression_ , _AssignmentExpression

1.  Return FALSE.

Static Semantics: IsValidSimpleAssignmentTarget

See also: 12.2.0.3, 12.2.10.3, 12.3.1.3, 12.4.3, 12.5.3, 12.6.2, 12.7.2,
12.8.2, 12.9.2, 12.10.2, 12.11.2, 12.12.2, 12.13.2, 12.14.3.

_Expression_ _: Expression_ , _AssignmentExpression

1.  Return FALSE.

Runtime Semantics: Evaluation

_Expression_ : _Expression_ , _AssignmentExpression

1.  Let _lref_ be the result of evaluating _Expression_.

2.  ReturnIfAbrupt(GetValue(_lref_))

3.  Let _rref_ be the result of evaluating _AssignmentExpression_.

4.  Return GetValue(_rref_).

NOTE GetValue must be called even though its value is not used because
it may have observable side-effects.



ECMASCRIPT LANGUAGE: STATEMENTS AND DECLARATIONS


Syntax

Statement~[Yield,\ Return]~ :

BlockStatement~[?Yield,\ ?Return]~
VariableStatement~[?Yield]~
EmptyStatement
ExpressionStatement~[?Yield]~
IfStatement~[?Yield,\ ?Return]~
BreakableStatement~[?Yield,\ ?Return]~
ContinueStatement~[?Yield]~
BreakStatement~[?Yield]~
[+Return] ReturnStatement~[?Yield]~
WithStatement~[?Yield,\ ?Return]~
LabelledStatement~[?Yield,\ ?Return]~
ThrowStatement~[?Yield]~
TryStatement~[?Yield,\ ?Return]~
DebuggerStatement

Declaration~[Yield,\ Default]~ :

FunctionDeclaration~[?Yield,?Default]~
GeneratorDeclaration~[?Yield,\ ?Default]~
ClassDeclaration~[?Yield,?Default]~
LexicalDeclaration~[In,\ ?Yield]~

BreakableStatement~[Yield,\ Return]~ :

IterationStatement~[?Yield,\ ?Return]~
SwitchStatement~[?Yield,\ ?Return]~


Statement Semantics

Static Semantics: VarDeclaredNames

See also: 13.1.8, 13.2.2.2, 13.5.2, 13.6.1.1, 13.6.2.1, 13.6.3.1,
13.6.4.3, , 13.11.4, 13.12.10, 13.14.2, 14.1.17, 14.2.13, 15.1.5,
15.2.0.13.

Statement :

EmptyStatement
ExpressionStatement
ContinueStatement
BreakStatement
ReturnStatement
ThrowStatement
DebuggerStatement

1.  Return a new empty List.

Static Semantics: VarScopedDeclarations

See also: 13.1.9, 13.2.2.3, 13.5.3, 13.6.1.2, 13.6.2.2, 13.6.3.3,
13.6.4.4, 13.10.3, 13.11.5, 13.12.11, 13.14.3, 14.1.18, 14.2.14, 15.1.6,
15.2.0.14.

Statement :

EmptyStatement
ExpressionStatement
ContinueStatement
BreakStatement
ReturnStatement
ThrowStatement
DebuggerStatement

1.  Return a new empty List.

Runtime Semantics: LabelledEvaluation

  With argument _labelSet_.

See also: 13.6.1.2, 13.6.2.2, 13.6.3.3, 13.6.4.6, 13.12.12.

_BreakableStatement_ : _IterationStatement

1.  Let _stmtResult_ be the result of performing LabelledEvaluation of
    _IterationStatement_ with argument _labelSet_.

2.  If _stmtResult_.[[type]] is break and _stmtResult_.[[target]] is
    empty, then

    a.  If _stmtResult_.[[value]] is empty, then let _stmtResult_ be
        NormalCompletion(UNDEFINED).

    b.  Else, let _stmtResult_ be
        NormalCompletion(_stmtResult_.[[value]])

3.  Return _stmtResult_.

_BreakableStatement_ : _SwitchStatement

1.  Let _stmtResult_ be the result of evaluating _SwitchStatement_.

2.  If _stmtResult_.[[type]] is break and _stmtResult_.[[target]] is
    empty, then

    a.  If _stmtResult_.[[value]] is empty, then let _stmtResult_ be
        NormalCompletion(UNDEFINED).

    b.  Else, let _stmtResult_ be
        NormalCompletion(_stmtResult_.[[value]])

3.  Return _stmtResult_.

NOTE A _BreakableStatement_ is one that can be exited via an unlabelled
_BreakStatement.

Runtime Semantics: Evaluation

BreakableStatement :

IterationStatement
SwitchStatement

1.  Let _newLabelSet_ be a new empty List.

2.  Return the result of performing LabelledEvaluation of this
    _BreakableStatement_ with argument _newLabelSet_.


Block

Syntax

BlockStatement~[Yield,\ Return]~ :

Block~[?Yield,\ ?Return]~

Block~[Yield,\ Return]~ :

{ StatementList~[?Yield,\ ?Return]opt~ }

StatementList~[Yield,\ Return]~ :

StatementListItem~[?Yield,\ ?Return]~
StatementList~[?Yield,\ ?Return]~ StatementListItem~[?Yield,\ ?Return]~

StatementListItem~[Yield,\ Return]~ :

Statement~[?Yield,\ ?Return]~
Declaration~[?Yield]~

Static Semantics: Early Errors

_Block_ : { _StatementList_ }

-   It is a Syntax Error if the LexicallyDeclaredNames of
    _StatementList_ contains any duplicate entries.

-   It is a Syntax Error if any element of the LexicallyDeclaredNames of
    _StatementList_ also occurs in the VarDeclaredNames of
    _StatementList_.

Static Semantics: LexicallyDeclaredNames

See also: 13.11.2, 13.12.4, 14.1.14, 14.2.10, 15.1.3, 15.2.0.10.

_Block_ : { }

1.  Return a new empty List.

_StatementList_ : _StatementList_ _StatementListItem

1.  Let _names_ be LexicallyDeclaredNames of _StatementList_.

2.  Append to _names_ the elements of the LexicallyDeclaredNames of
    _StatementListItem._

3.  Return _names_.

_StatementListItem_ : _Statement

1.  If _Statement_ is _Statement_ : _LabelledStatement_, then return
    LexicallyDeclaredNames of _Statement_.

2.  Return a new empty List.

_StatementListItem_ : _Declaration

1.  Return the BoundNames of _Declaration_.

Static Semantics: LexicallyScopedDeclarations

See also: 13.11.3, 13.12.5, 14.1.15, 14.2.11, 15.1.4, 15.2.0.11.

_StatementList_ : _StatementList_ _StatementListItem

1.  Let _declarations_ be LexicallyScopedDeclarations of
    _StatementList_.

2.  Append to _declarations_ the elements of the
    LexicallyScopedDeclarations of _StatementListItem._

3.  Return _declarations_.

_StatementListItem_ : _Statement

1.  If _Statement_ is _Statement_ : _LabelledStatement_, then return
    LexicallyScopedDeclarations of _Statement_.

2.  Return a new empty List.

_StatementListItem_ : _Declaration

1.  Return a new List containing _Declaration_.

Static Semantics: TopLevelLexicallyDeclaredNames

See also: 13.12.6.

_StatementList_ : _StatementList_ _StatementListItem

1.  Let _names_ be TopLevelLexicallyDeclaredNames of _StatementList_.

2.  Append to _names_ the elements of the TopLevelLexicallyDeclaredNames
    of _StatementListItem._

3.  Return _names_.

_StatementListItem_ : _Statement

1.  Return a new empty List.

_StatementListItem_ : _Declaration

1.  If _Declaration_ is _Declaration_ : _FunctionDeclaration_, then
    return a new empty List.

2.  If _Declaration_ is _Declaration_ : _GeneratorDeclaration_, then
    return a new empty List.

3.  Return the BoundNames of _Declaration_.

NOTE At the top level of a function, or script, function declarations
are treated like var declarations rather than like lexical declarations.

Static Semantics: TopLevelLexicallyScopedDeclarations

See also: 13.12.7.

_Block_ : { }

1.  Return a new empty List.

_StatementList_ : _StatementList_ _StatementListItem

1.  Let _declarations_ be TopLevelLexicallyScopedDeclarations of
    _StatementList_.

2.  Append to _declarations_ the elements of the
    TopLevelLexicallyScopedDeclarations of _StatementListItem._

3.  Return _declarations_.

_StatementListItem_ : _Statement

1.  Return a new empty List.

_StatementListItem_ : _Declaration

1.  If _Declaration_ is _Declaration_ : _FunctionDeclaration_, then
    return a new empty List.

2.  If _Declaration_ is _Declaration_ : _GeneratorDeclaration_, then
    return a new empty List.

3.  Return a new List containing _Declaration_.

Static Semantics: TopLevelVarDeclaredNames

See also: 13.12.8.

_Block_ : { }

1.  Return a new empty List.

_StatementList_ : _StatementList_ _StatementListItem

1.  Let _names_ be TopLevelVarDeclaredNames of _StatementList_.

2.  Append to _names_ the elements of the TopLevelVarDeclaredNames of
    _StatementListItem._

3.  Return _names_.

_StatementListItem_ : _Declaration

1.  If _Declaration_ is _Declaration_ : _FunctionDeclaration_, then
    return the LexicallyDeclaredNames of _Declaration_.

2.  If _Declaration_ is _Declaration_ : _GeneratorDeclaration_, then
    return the LexicallyDeclaredNames of _Declaration_.

3.  Return a new empty List.

_StatementListItem_ : _Statement

1.  If _Statement_ is _Statement_ : _LabelledStatement_, then return
    TopLevelVarDeclaredNames of _Statement_.

2.  Return VarDeclaredNames of _Statement_.

NOTE At the top level of a function or script, inner function
declarations are treated like var declarations.

Static Semantics: TopLevelVarScopedDeclarations

See also: 13.12.9.

_Block_ : { }

1.  Return a new empty List.

_StatementList_ : _StatementList_ _StatementListItem

1.  Let _declarations_ be TopLevelVarScopedDeclarations of
    _StatementList_.

2.  Append to _declarations_ the elements of the
    TopLevelVarScopedDeclarations of _StatementListItem._

3.  Return _declarations_.

_StatementListItem_ : _Statement

1.  If _Statement_ is _Statement_ : _LabelledStatement_, then
    TopLevelVarScopedDeclarations of _Statement_.

2.  Return VarScopedDeclarations of _Statement_.

3.  

_StatementListItem_ : _Declaration

1.  If _Declaration_ is _Declaration_ : _FunctionDeclaration_, then
    return a new List containing _FunctionDeclaration_.

2.  If _Declaration_ is _Declaration_ : _GeneratorDeclaration_, then
    return a new List containing _GeneratorDeclaration_.

3.  Return a new empty List.

Static Semantics: VarDeclaredNames

See also: 13.0.1, 13.2.2.2, 13.5.2, 13.6.1.1, 13.6.2.1, 13.6.3.1,
13.6.4.3, , 13.11.4, 13.12.10, 13.14.2, 14.1.17, 14.2.13, 15.1.5,
15.2.0.13.

_Block_ : { }

1.  Return a new empty List.

_StatementList_ : _StatementList_ _StatementListItem

1.  Let _names_ be VarDeclaredNames of _StatementList_.

2.  Append to _names_ the elements of the VarDeclaredNames of
    _StatementListItem._

3.  Return _names_.

_StatementListItem_ : _Declaration

1.  Return a new empty List.

Static Semantics: VarScopedDeclarations

See also: 13.0.2, 13.2.2.3, 13.5.3, 13.6.1.2, 13.6.2.2, 13.6.3.3,
13.6.4.4, 13.10.3, 13.11.5, 13.12.11, 13.14.3, 14.1.18, 14.2.14, 15.1.6,
15.2.0.14.

_Block_ : { }

1.  Return a new empty List.

_StatementList_ : _StatementList_ _StatementListItem

1.  Let _declarations_ be VarScopedDeclarations of _StatementList_.

2.  Append to _declarations_ the elements of the VarScopedDeclarations
    of _StatementListItem._

3.  Return _declarations_.

1.  2.  

_StatementListItem_ : _Declaration

1.  Return a new empty List.

Runtime Semantics: Evaluation

_Block_ : { }

1.  Return NormalCompletion(UNDEFINED).

_Block_ : { _StatementList_ }

1.  Let _oldEnv_ be the running execution context’s LexicalEnvironment.

2.  Let _blockEnv_ be NewDeclarativeEnvironment(_oldEnv_).

3.  Perform BlockDeclarationInstantiation(_StatementList_, _blockEnv_).

4.  Set the running execution context’s LexicalEnvironment to
    _blockEnv_.

5.  Let _blockValue_ be the result of evaluating _StatementList_.

6.  Set the running execution context’s LexicalEnvironment to _oldEnv_.

7.  If _blockValue_.[[type]] is normal and _blockValue_.[[value]] is
    empty, then

    a.  Return NormalCompletion(UNDEFINED).

8.  Return _blockValue_.

NOTE No matter how control leaves the _Block_ the LexicalEnvironment is
always restored to its former state.

_StatementList_ : _StatementList_ _StatementListItem

1.  Let _sl_ be the result of evaluating _StatementList_.

2.  ReturnIfAbrupt(_sl_).

3.  Let _s_ be the result of evaluating _StatementListItem_.

4.  If _s_.[[type]] is throw, return _s_.

5.  If _s_.[[value]] is empty, let _V_ = _sl_.[[value]], otherwise let
    _V_ = _s_.[[value]].

6.  Return Completion{[[type]]: _s_.[[type]], [[value]]: _V_,
    [[target]]: _s_.[[target]]}.

NOTE Steps 5 and 6 of the above algorithm ensure that the value of a
_StatementList_ is the value of the last value producing _Statement_ in
the _StatementList_. For example, the following calls to the EVAL
function all return the value 1:

  EVAL("1;;;;;")

  EVAL("1;{}")

  EVAL("1;VAR A;")

Runtime Semantics: BlockDeclarationInstantiation( code, env )

NOTE When a _Block_ or _CaseBlock_ production is evaluated a new
Declarative Environment Record is created and bindings for each block
scoped variable, constant, function, generator function, or class
declarated in the block are instantiated in the environment record.

BlockDeclarationInstantiation is performed as follows using arguments
_code_ and _env_. _code_ is the grammar production corresponding to the
body of the block. _env_ is the declarative environment record in which
bindings are to be created.

1.  Let _declarations_ be the LexicallyScopedDeclarations of _code_.

2.  Let _functionsToInitialize_ be an empty List.

3.  For each element _d_ in _declarations_ do

    a.  If _d_ is a _GeneratorDeclaration_ production or a
        _FunctionDeclaration_ production, then

        i.  Let _fn_ be the sole element of the BoundNames of _d_

        ii. Let _fo_ be the result of performing
            InstantiateFunctionObject for _d_ with argument _env_.

        iii. Call _env_’s InitializeBinding concrete method passing
            _fn_, and _fo_ as the arguments.

    b.  Else, for each element _dn_ of the BoundNames of _d_ do

        i.  If IsConstantDeclaration of _d_ is TRUE, then

            1.  Call _env_’s CreateImmutableBinding concrete method
                passing _dn_ as the argument.

        ii. Else,

            1.  Let _status_ be the result of calling _env_’s
                CreateMutableBinding concrete method passing _dn_ and
                FALSE as the arguments.

            2.  Assert: _status_ is never an abrupt completion.

    c.  i.  

4.  a.  b.  c.  


Declarations and the Variable Statement

Let and Const Declarations

NOTE LET and CONST declarations define variables that are scoped to the
running execution context’s LexicalEnvironment. The variables are
created when their containing Lexical Environment is instantiated but
may not be accessed in any way until the variable’s _LexicalBinding_ is
evaluated. A variable defined by a _LexicalBinding_ with an
_Initializer_ is assigned the value of its _Initializer_’s
_AssignmentExpression_ when the _LexicalBinding_ is evaluated, not when
the variable is created. If a _LexicalBinding_ in a LET declaration does
not have an _Initializer_ the variable is assigned the value UNDEFINED
when the _LexicalBinding_ is evaluated.

Syntax

LexicalDeclaration~[In,\ Yield]~ :

LetOrConst BindingList~[?In,\ ?Yield]~ ;

LetOrConst :

LET
CONST

BindingList~[In,\ Yield]~ :

LexicalBinding~[?In,\ ?Yield]~
BindingList~[?In,\ ?Yield]~ , LexicalBinding~[?In,\ ?Yield]~

LexicalBinding~[In,\ Yield]~ :

BindingIdentifier~[?Yield]~ Initializer~[?In,\ ?Yield]opt
~BindingPattern~[?Yield]~ Initializer~[?In,\ ?Yield]~

Static Semantics: Early Errors

_LexicalDeclaration_ : _LetOrConst_ _BindingList_ ;

-   It is a Syntax Error if the BoundNames of _BindingList_ contains
    "LET".

-   It is a Syntax Error if the BoundNames of _BindingList_ contains any
    duplicate entries.

_LexicalBinding_ : _BindingIdentifier_ _Initializer_~opt~

-   It is a Syntax Error if _Initializer_ is not present and
    IsConstantDeclaration of the _LexicalDeclaration_ containing this
    production is TRUE.

Static Semantics: BoundNames

See also:, 12.1.2, 13.6.4.2, 14.1.3, 14.2.2, 14.4.2, 14.5.2, 15.2.1.2,
15.2.2.1.

_LexicalDeclaration_ : _LetOrConst_ _BindingList_ ;

1.  Return the BoundNames of _BindingList_.

_BindingList_ : _BindingList_ , _LexicalBinding

1.  Let _names_ be the BoundNames of _BindingList_.

2.  Append to _names_ the elements of the BoundNames of
    _LexicalBinding._

3.  Return _names_.

_LexicalBinding_ : _BindingIdentifier_ _Initializer_~opt~

1.  Return the BoundNames of _BindingIdentifier_.

_LexicalBinding_ : _BindingPattern_ _Initializer

1.  Return the BoundNames of _BindingPattern_.

Static Semantics: IsConstantDeclaration

See also: 14.1.8, 14.4.5, 14.5.5.

_LexicalDeclaration_ : _LetOrConst_ _BindingList_ ;

1.  Return IsConstantDeclaration of _LetOrConst_.

_LetOrConst_ : LET

1.  Return FALSE.

_LetOrConst_ : CONST

1.  Return TRUE.

Runtime Semantics: Evaluation

_LexicalDeclaration_ : _LetOrConst_ _BindingList_ ;

1.  Let _next_ be the result of evaluating _BindingList_.

2.  ReturnIfAbrupt(_next_).

3.  Return NormalCompletion(empty).

_BindingList_ : _BindingList_ , _LexicalBinding

1.  Let _next_ be the result of evaluating _BindingList_.

2.  ReturnIfAbrupt(_next_).

3.  Return the result of evaluating _LexicalBinding_.

_LexicalBinding_ : _BindingIdentifier

1.  Let _env_ be the running execution context’s LexicalEnvironment.

2.  Return the result of performing BindingInitialization for
    _BindingIdentifier_ passing UNDEFINED and _env_ as the arguments.

NOTE A static semantics rule ensures that this form of _LexicalBinding_
never occurs in a CONST declaration.

_LexicalBinding_ : _BindingIdentifier_ _Initializer

1.  Let _rhs_ be the result of evaluating _Initializer_.

2.  Let _value_ be GetValue(_rhs_).

3.  ReturnIfAbrupt(_value_).

4.  If IsAnonymousFunctionDefinition(_Initializer_) is TRUE, then

    a.  Let _hasNameProperty_ be HasOwnProperty(_value_, "NAME").

    b.  ReturnIfAbrupt(_hasNameProperty_).

    c.  If _hasNameProperty_ is FALSE, then

        i.  SetFunctionName(_value_, StringValue(_BindingIdentifier_)).

        ii. Assert: SetFunctionName will not return an abrupt
            completion.

5.  Let _env_ be the running execution context’s LexicalEnvironment.

6.  Return the result of performing BindingInitialization for
    _BindingIdentifier_ passing _value_ and _env_ as the arguments.

_LexicalBinding_ : _BindingPattern_ _Initializer

1.  Let _rhs_ be the result of evaluating _Initializer_.

2.  Let _value_ be GetValue(_rhs_).

3.  ReturnIfAbrupt(_value_).

4.  If Type(_value_) is not Object, then throw a TYPEERROR exception.

5.  Let _env_ be the running execution context’s LexicalEnvironment.

6.  Return the result of performing BindingInitialization for
    _BindingPattern_ using _value_ and _env_ as the _arguments_.

Variable Statement

NOTE A VAR statement declares variables that are scoped to the running
execution context’s VariableEnvironment. Var variables are created when
their containing Lexical Environment is instantiated and are initialized
to UNDEFINED when created. Within the scope of any VariableEnvironemnt a
common _Identifier_ may appear in more than one _VariableDeclaration_
but those declarations collective define only one variable. A variable
defined by a _VariableDeclaration_ with an _Initializer_ is assigned the
value of its _Initializer_’s _AssignmentExpression_ when the
_VariableDeclaration_ is executed, not when the variable is created.

Syntax

VariableStatement~[Yield]~ :

VAR VariableDeclarationList~[In,\ ?Yield]~ ;

VariableDeclarationList~[In,\ Yield]~ :

VariableDeclaration~[?In,\ ?Yield]~
VariableDeclarationList~[?In,\ ?Yield]~ ,
VariableDeclaration~[?In,\ ?Yield]~

VariableDeclaration~[In,\ Yield]~ :

BindingIdentifier~[?Yield]~ Initializer~[?In,\ ?Yield]opt
~BindingPattern~[Yield]~ Initializer~[?In,\ ?Yield]~

Static Semantics: BoundNames

See also: 13.2.1.2, 12.1.2, 13.6.4.2, 14.1.3, 14.2.2, 14.4.2, 14.5.2,
15.2.1.2, 15.2.2.1.

_VariableDeclarationList_ : _VariableDeclarationList_ ,
_VariableDeclaration

1.  Let _names_ be BoundNames of _VariableDeclarationList_.

2.  Append to _names_ the elements of BoundNames of
    _VariableDeclaration._

3.  Return _names_.

_VariableDeclaration_ : _BindingIdentifier_ _Initializer_~opt~

1.  Return the BoundNames of _BindingIdentifier_.

_VariableDeclaration_ : _BindingPattern_ _Initializer

1.  Return the BoundNames of _BindingPattern_.

Static Semantics: VarDeclaredNames

See also: 13.0.1, 13.1.8, 13.5.2, 13.6.1.1, 13.6.2.1, 13.6.3.1,
13.6.4.3, , 13.11.4, 13.12.10, 13.14.2, 14.1.17, 14.2.13, 15.1.5,
15.2.0.13.

_VariableStatement_ : VAR _VariableDeclarationList

1.  Return BoundNames of _VariableDeclarationList.

Static Semantics: VarScopedDeclarations

See also: 13.0.2, 13.1.9, 13.5.3, 13.6.1.2, 13.6.2.2, 13.6.3.3,
13.6.4.4, 13.10.3, 13.11.5, 13.12.11, 13.14.3, 14.1.18, 14.2.14, 15.1.6,
15.2.0.14.

_VariableDeclarationList_ : _VariableDeclaration

1.  Return a new List containing _VariableDeclaration.

_VariableDeclarationList_ : _VariableDeclarationList_ ,
_VariableDeclaration

1.  Let _declarations_ be VarScopedDeclarations of
    _VariableDeclarationList_.

2.  Append _VariableDeclaration_ to _declarations.

3.  Return _declarations_.

Runtime Semantics: BindingInitialization

  With arguments _value_ and _environment_.

See also: 12.1.4, 12.2.4.2.2, 13.2.3.5, 13.14.4.

NOTE UNDEFINED is passed for _environment_ to indicate that a PutValue
operation should be used to assign the initialization value. This is the
case for VAR statements and the formal parameter lists of some
non-strict functions (see 9.2.13). In those cases a lexical binding is
hoisted and preinitialized prior to evaluation of its initializer.

_VariableDeclaration_ : _BindingIdentifier

1.  Return the result of performing BindingInitialization for
    _BindingIdentifier_ passing _value_ and UNDEFINED as the arguments.

_VariableDeclaration_ : _BindingIdentifier_ _Initializer

1.  Return the result of performing BindingInitialization for
    _BindingIdentifier_ passing _value_ and UNDEFINED as the arguments.

_VariableDeclaration_ : _BindingPattern_ _Initializer

1.  Return the result of performing BindingInitialization for
    _BindingPattern_ passing _value_ and UNDEFINED as the arguments.

RUNTIME Semantics: Evaluation

_VariableStatement_ : VAR _VariableDeclarationList_ ;

1.  Let _next_ be the result of evaluating _VariableDeclarationList_.

2.  ReturnIfAbrupt(_next_).

3.  Return NormalCompletion( empty).

_VariableDeclarationList_ : _VariableDeclarationList_ ,
_VariableDeclaration

1.  Let _next_ be the result of evaluating _VariableDeclarationList_.

2.  ReturnIfAbrupt(_next_).

3.  Return the result of evaluating _VariableDeclaration_.

_VariableDeclaration_ : _BindingIdentifier

1.  Return NormalCompletion(empty).

_VariableDeclaration_ : _BindingIdentifier_ _Initializer

1.  Let _rhs_ be the result of evaluating _Initializer_.

2.  Let _value_ be GetValue(_rhs_).

3.  ReturnIfAbrupt(_value_).

4.  If IsAnonymousFunctionDefinition(_Initializer_) is TRUE, then

    a.  Let _hasNameProperty_ be HasOwnProperty(_value_, "NAME").

    b.  ReturnIfAbrupt(_hasNameProperty_).

    c.  If _hasNameProperty_ is FALSE, then

        i.  Perform SetFunctionName(_value_,
            StringValue(_BindingIdentifier_)).

        ii. Assert: SetFunctionName will not return an abrupt
            completion.

5.  Return the result of performing BindingInitialization for
    _BindingIdentifier_ passing _value_ and UNDEFINED as the arguments.

NOTE If a _VariableDeclaration_ is nested within a with statement and
the _Identifier_ in the _VariableDeclaration_ is the same as a property
name of the binding object of the with statement’s object environment
record, then step 5 will assign _value_ to the property instead of
assigning to the VariableEnvironment binding of the _Identifier_.

_VariableDeclaration_ : _BindingPattern_ _Initializer

1.  Let _rhs_ be the result of evaluating _Initializer_.

2.  Let _rval_ be GetValue(_rhs_).

3.  ReturnIfAbrupt(_rval_).

4.  If Type(_rval_) is not Object, then throw a TYPEERROR exception.

5.  Return the result of performing BindingInitialization for
    _BindingPattern_ passing _rval_ and UNDEFINED as arguments.

Destructuring Binding Patterns

Syntax

BindingPattern~[Yield,GeneratorParameter]~ :

ObjectBindingPattern~[?Yield,?GeneratorParameter]~
ArrayBindingPattern~[?Yield,?GeneratorParameter]~

ObjectBindingPattern~[Yield,GeneratorParameter]~ :

{ }
{ BindingPropertyList~[?Yield,?GeneratorParameter]~ }
{ BindingPropertyList~[?Yield,?GeneratorParameter]~ , }

ArrayBindingPattern~[Yield,GeneratorParameter]~ :

[ Elision~opt~ BindingRestElement~[?Yield,\ ?GeneratorParameter]opt~ ]
[ BindingElementList~[?Yield,\ ?GeneratorParameter]~ ]
[ BindingElementList~[?Yield,\ ?GeneratorParameter]~ , Elision~opt~
BindingRestElement~[?Yield,\ ?GeneratorParameter]opt~ ]

BindingPropertyList~[Yield,GeneratorParameter]~ :

BindingProperty~[?Yield,\ ?GeneratorParameter]~
BindingPropertyList~[?Yield,\ ?GeneratorParameter]~ ,
BindingProperty~[?Yield,\ ?GeneratorParameter]~

BindingElementList~[Yield,GeneratorParameter]~ :

BindingElisionElement~[?Yield,\ ?GeneratorParameter]~
BindingElementList~[?Yield,\ ?GeneratorParameter]~ ,
BindingElisionElement~[?Yield,\ ?GeneratorParameter]~

BindingElisionElement~[Yield,GeneratorParameter]~ :

Elision~opt~ BindingElement~[?Yield,\ ?GeneratorParameter]~

BindingProperty~[Yield,GeneratorParameter]~ :

SingleNameBinding~[?Yield,\ ?GeneratorParameter]
~ PropertyName~[?Yield,\ ?GeneratorParameter]~ :
BindingElement~[?Yield,\ ?GeneratorParameter]~

BindingElement~[Yield,~ ~GeneratorParameter\ ]~ :

SingleNameBinding~[?Yield,\ ?GeneratorParameter]
~[+GeneratorParameter] BindingPattern~[?Yield,GeneratorParameter]~
Initializer~[In]opt~
[~GeneratorParameter] BindingPattern~[?Yield]~
Initializer~[In,\ ?Yield]opt~

SingleNameBinding~[Yield,GeneratorParameter]~ :

[+GeneratorParameter] BindingIdentifier~[Yield]~ Initializer~[In]opt~
[~GeneratorParameter] BindingIdentifier~[?Yield]~
Initializer~[In,\ ?Yield]opt~

BindingRestElement~[Yield,\ GeneratorParameter]~ :

[+GeneratorParameter]... BindingIdentifier~[Yield]~
[~GeneratorParameter] ... BindingIdentifier~[?Yield]~

Static Semantics: BoundNames

See also: 13.2.1.2, 13.2.2.1, 13.6.4.2, 14.1.3, 14.2.2, 14.4.2, 14.5.2,
15.2.1.2, 15.2.2.1.

_ObjectBindingPattern_ : { }

1.  Return an empty List.

_ArrayBindingPattern_ : [ _Elision_~opt~ ]

1.  Return an empty List.

_ArrayBindingPattern_ : [ _Elision_~opt~ _BindingRestElement_ ]

1.  Return the BoundNames of _BindingRestElement_.

_ArrayBindingPattern_ : [ _BindingElementList_ , _Elision_~opt~ ]

1.  Return the BoundNames of _BindingElementList_.

_ArrayBindingPattern_ : [ _BindingElementList_ , _Elision_~opt~
_BindingRestElement_ ]

1.  Let _names_ be BoundNames of _BindingElementList_.

2.  Append to _names_ the elements of BoundNames of
    _BindingRestElement._

3.  Return _names_.

_BindingPropertyList_ : _BindingPropertyList_ , _BindingProperty 

1.  Let _names_ be BoundNames of _BindingPropertyList_.

2.  Append to _names_ the elements of BoundNames of _BindingProperty.

3.  Return _names_.

_BindingElementList_ : _BindingElementList_ , _BindingElisionElement

1.  Let _names_ be BoundNames of _BindingElementList_.

2.  Append to _names_ the elements of BoundNames of
    _BindingElisionElement._

3.  Return _names_.

_BindingElisionElement_ : _Elision_~opt~ _BindingElement 

1.  Return BoundNames of _BindingElement_.

_BindingProperty_ : _PropertyName_ : _BindingElement

1.  Return the BoundNames of _BindingElement_.

_SingleNameBinding_ : _BindingIdentifier Initializer_~opt~

1.  Return the BoundNames of _BindingIdentifier_.

_BindingElement_ : _BindingPattern Initializer_~opt~

1.  Return the BoundNames of _BindingPattern_.

Static Semantics: ContainsExpression

See also: 14.1.5, 14.2.4.

_ObjectBindingPattern_ : { }

1.  Return FALSE.

_ArrayBindingPattern_ : [ _Elision_~opt~ ]

1.  Return FALSE.

_ArrayBindingPattern_ : [ _Elision_~opt~ _BindingRestElement_ ]

1.  Return FALSE.

_ArrayBindingPattern_ : [ _BindingElementList_ , _Elision_~opt~ ]

1.  Return ContainsExpression of _BindingElementList_.

_ArrayBindingPattern_ : [ _BindingElementList_ , _Elision_~opt~
_BindingRestElement_ ]

1.  Return ContainsExpression of _BindingElementList_.

_BindingPropertyList_ : _BindingPropertyList_ , _BindingProperty 

1.  Let _has_ be ContainsExpression of _BindingPropertyList_.

2.  If _has_ is TRUE, return TRUE_.

3.  Return ContainsExpression of _BindingProperty_.

_BindingElementList_ : _BindingElementList_ , _BindingElisionElement

1.  Let _has_ be ContainsExpression of _BindingElementList_.

2.  If _has_ is TRUE, return TRUE_.

3.  Return ContainsExpression of _BindingElisionElement_.

_BindingElisionElement_ : _Elision_~opt~ _BindingElement 

1.  Return ContainsExpression of _BindingElement_.

_BindingProperty_ : _PropertyName_ : _BindingElement

1.  Let _has_ be IsComputedPropertyKey of _PropertyName_.

2.  If _has_ is TRUE, return TRUE_.

3.  Return the ContainsExpression of _BindingElement_.

_BindingElement_ : _BindingPattern Initializer

1.  Return TRUE.

_SingleNameBinding_ : _BindingIdentifier 

1.  Return FALSE.

_SingleNameBinding_ : _BindingIdentifier Initializer

1.  Return TRUE.

Static Semantics: HasInitializer

See also: 13.2.3.3, 14.1.7, 14.2.7.

_BindingElement_ : _BindingPattern 

1.  Return FALSE.

_BindingElement_ : _BindingPattern Initializer

1.  Return TRUE.

_SingleNameBinding_ : _BindingIdentifier 

1.  Return FALSE.

_SingleNameBinding_ : _BindingIdentifier Initializer

1.  Return TRUE.

Static Semantics: IsSimpleParameterList

See also: 14.1.11, 14.2.8.

_BindingElement_ : _BindingPattern 

1.  Return FALSE.

_BindingElement_ : _BindingPattern Initializer

1.  Return FALSE.

_SingleNameBinding_ : _BindingIdentifier 

1.  Return TRUE.

_SingleNameBinding_ : _BindingIdentifier Initializer

1.  Return FALSE.

Runtime Semantics: BindingInitialization

  With parameters _value_ and _environment_.

See also: 12.1.4, 12.2.4.2.2, 13.2.2.4, 13.14.4.

NOTE When UNDEFINED is passed for _environment_ it indicates that a
PutValue operation should be used to assign the initialization value.
This is the case for formal parameter lists of non-strict functions. In
that case the formal parameter bindings are preinitialized in order to
deal with the possibility of multiple parameters with the same name.

_BindingPattern_ : _ObjectBindingPattern

1.  Assert: Type(_value_) is Object

2.  Return the result of performing BindingInitialization for
    _ObjectBindingPattern_ using _value_ and _environment_ as arguments.

_BindingPattern_ : _ArrayBindingPattern

1.  Assert: Type(_value_) is Object

2.  Let _iterator_ be GetIterator(_value_).

3.  ReturnIfAbrupt(_iterator_).

4.  Return the result of performing IteratorBindingInitialization for
    _ArrayBindingPattern_ using _iterator_, and _environment_ as
    arguments.

_ObjectBindingPattern_ : { }

1.  Return NormalCompletion(empty).

_BindingPropertyList_ : _BindingPropertyList_ , _BindingProperty 

1.  Let _status_ be the result of performing BindingInitialization for
    _BindingPropertyList_ using _value_ and _environment_ as arguments.

2.  ReturnIfAbrupt(_status_).

3.  Return the result of performing BindingInitialization for
    _BindingProperty_ using _value_ and _environment_ as arguments.

_BindingProperty_ : _SingleNameBinding

1.  Let _name_ be the string that is the only element of BoundNames of
    _SingleNameBinding_.

2.  Return the result of performing KeyedBindingInitialization for
    _SingleNameBinding_ using _value_, _environment_, and _name_ as the
    arguments.

_BindingProperty_ : _PropertyName_ : _BindingElement

1.  Let _P_ be the result of evaluating _PropertyName

2.  ReturnIfAbrupt(_P_).

3.  Return the result of performing KeyedBindingInitialization for
    _BindingElement_ using _value_, _environment_, and _P_ as arguments.

Runtime Semantics: IteratorBindingInitialization

  With parameters _iterator,_ and _environment_.

See also: 14.1.20, 14.2.15.

NOTE When UNDEFINED is passed for _environment_ it indicates that a
PutValue operation should be used to assign the initialization value.
This is the case for formal parameter lists of non-strict functions. In
that case the formal parameter bindings are preinitialized in order to
deal with the possibility of multiple parameters with the same name.

_ArrayBindingPattern_ : [ ]

1.  Return NormalCompletion(empty).

_ArrayBindingPattern_ : [ _Elision_ ]

1.  Return the result of performing
    IteratorDestructuringAssignmentEvaluation of _Elision_ with
    _iterator_ as the argument.

_ArrayBindingPattern_ : [ _Elision_~opt~ _BindingRestElement_ ]

1.  If _Elision_ is present, then

    a.  Let _status_ be the result of performing
        IteratorDestructuringAssignmentEvaluation of _Elision_ with
        _iterator_ as the argument.

    b.  ReturnIfAbrupt(_status_).

2.  Return the result of performing IteratorBindingInitialization for
    _BindingRestElement_ using _iterator_ and _environment_ as
    arguments.

_ArrayBindingPattern_ : [ _BindingElementList_ ]

1.  Return the result of performing IteratorBindingInitialization for
    _BindingElementList_ using _iterator_ and _environment_ as
    arguments.

_ArrayBindingPattern_ : [ _BindingElementList_ , ]

1.  Return the result of performing IteratorBindingInitialization for
    _BindingElementList_ using _iterator_ and _environment_ as
    arguments.

_ArrayBindingPattern_ : [ _BindingElementList_ , _Elision_ ]

1.  Let _status_ be the result of performing
    IteratorBindingInitialization for _BindingElementList_ using
    _iterator_ and _environment_ as arguments.

2.  ReturnIfAbrupt(_status_).

3.  Return the result of performing
    IteratorDestructuringAssignmentEvaluation of _Elision_ with
    _iterator_ as the argument.

_ArrayBindingPattern_ : [ _BindingElementList_ , _Elision_~opt~
_BindingRestElement_ ]

1.  Let _status_ be the result of performing
    IteratorBindingInitialization for _BindingElementList_ using
    _iterator_ and _environment_ as arguments.

2.  ReturnIfAbrupt(_status_).

3.  If _Elision_ is present, then

    a.  Let _status_ be the result of performing
        IteratorDestructuringAssignmentEvaluation of _Elision_ with
        _iterator_ as the argument.

    b.  ReturnIfAbrupt(_status_).

4.  Return the result of performing IteratorBindingInitialization for
    _BindingRestElement_ using _iterator_ and _environment_ as
    arguments.

_BindingElementList_ : _BindingElisionElement

1.  Return the result of performing IteratorBindingInitialization for
    _BindingElisionElement_ using _iterator_ and _environment_ as
    arguments.

_BindingElementList_ : _BindingElementList_ , _BindingElisionElement

1.  Let _status_ be the result of performing
    IteratorBindingInitialization for _BindingElementList_ using
    _iterator_ and _environment_ as arguments.

2.  ReturnIfAbrupt(_status_).

3.  Return the result of performing IteratorBindingInitialization for
    _BindingElisionElement_ using _iterator_ and _environment_ as
    arguments.

_BindingElisionElement_ : _BindingElement

1.  Return the result of performing IteratorBindingInitialization of
    _BindingElement_ with _iterator_ and _environment_ as the arguments.

_BindingElisionElement_ : _Elision_ _BindingElement

1.  Let _status_ be the result of performing
    IteratorDestructuringAssignmentEvaluation of _Elision_ with
    _iterator_ as the argument.

2.  ReturnIfAbrupt(_status_).

3.  Return the result of performing IteratorBindingInitialization of
    _BindingElement_ with _iterator_ and _environment_ as the arguments.

_BindingElement_ : _SingleNameBinding

1.  Return the result of performing IteratorBindingInitialization for
    _SingleNameBinding_ using _iterator_ and _environment_ as the
    arguments.

_SingleNameBinding_ : _BindingIdentifier Initializer_~opt~

1.  Let _next_ be IteratorStep(_iterator_).

2.  ReturnIfAbrupt(_next_).

3.  If _next_ is FALSE, then let _v_ be UNDEFINED

4.  Else

    a.  Let _v_ be IteratorValue(_next_).

    b.  ReturnIfAbrupt(_v_).

5.  If _Initializer_ is present and _v_ is UNDEFINED, then

    a.  Let _defaultValue_ be the result of evaluating _Initializer_.

    b.  Let _v_ be GetValue(_defaultValue_).

    c.  ReturnIfAbrupt(_v_).

    d.  If IsAnonymousFunctionDefinition(_Initializer_) is TRUE, then

        i.  Let _hasNameProperty_ be HasOwnProperty(_v_, "NAME").

        ii. ReturnIfAbrupt(_hasNameProperty_).

        iii. If _hasNameProperty_ is FALSE, then

            1.  SetFunctionName(_v_, StringValue(_BindingIdentifier_)).

            2.  Assert: SetFunctionName will not return an abrupt
                completion.

6.  Return the result of performing BindingInitialization for
    _BindingIdentifier_ passing _v_ and _environment_ as arguments.

_BindingElement_ : _BindingPattern Initializer_~opt~

1.  Let _next_ be IteratorStep(_iterator_).

2.  ReturnIfAbrupt(_next_).

3.  If _next_ is FALSE, then let _v_ be UNDEFINED

4.  Else

    a.  Let _v_ be IteratorValue(_next_).

    b.  ReturnIfAbrupt(_v_).

5.  If _Initializer_ is present and _v_ is UNDEFINED, then

    a.  Let _defaultValue_ be the result of evaluating _Initializer_.

    b.  Let _v_ be GetValue(_defaultValue_)

    c.  ReturnIfAbrupt(_v_).

6.  If Type(_v_) is not Object, then throw a TYPEERROR exception.

7.  Return the result of performing BindingInitialization of
    _BindingPattern_ with _v_ and _environment_ as the arguments.

_BindingRestElement_ : ... _BindingIdentifier

1.  Let _A_ be ArrayCreate(0).

2.  Let _n_=0.

3.  Repeat,

    a.  Let _next_ be IteratorStep(_iterator_).

    b.  ReturnIfAbrupt(_next_).

    c.  If _next_ is FALSE, then

        i.  Return the result of performing BindingInitialization for
            _BindingIdentifier_ using _A_ and _environment_ as
            arguments.

    d.  Let _nextValue_ be IteratorValue(_next_).

    e.  ReturnIfAbrupt(_nextValue_).

    f.  Let _defineStatus_ be CreateDataPropertyOrThrow(_A_,
        ToString(ToUint32(_n)_), _nextValue_).

    g.  ReturnIfAbrupt(_defineStatus_).

    h.  Increment _n_ by 1.

Runtime Semantics: KeyedBindingInitialization

  With parameters _obj_, _environment,_ and _propertyName_.

NOTE When UNDEFINED is passed for _environment_ it indicates that a
PutValue operation should be used to assign the initialization value.
This is the case for formal parameter lists of non-strict functions. In
that case the formal parameter bindings are preinitialized in order to
deal with the possibility of multiple parameters with the same name.

_BindingElement_ : _BindingPattern Initializer_~opt~

1.  Let _v_ be Get(_obj_, _propertyName_).

2.  ReturnIfAbrupt(_v_).

3.  If _Initializer_ is present and _v_ is UNDEFINED, then

    a.  Let _defaultValue_ be the result of evaluating _Initializer_.

    b.  Let _v_ be GetValue(_defaultValue_).

    c.  ReturnIfAbrupt(_v_).

4.  If Type(_v_) is not Object, then throw a TYPEERROR exception.

5.  Return the result of performing BindingInitialization for
    _BindingPattern_ passing _v_ and _environment_ as arguments.

_SingleNameBinding_ : _BindingIdentifier Initializer_~opt~

1.  Let _v_ be Get(_obj_, _propertyName_).

2.  ReturnIfAbrupt(_v_).

3.  If _Initializer_ is present and _v_ is UNDEFINED, then

    a.  Let _defaultValue_ be the result of evaluating _Initializer_.

    b.  Let _v_ be GetValue(_defaultValue_).

    c.  ReturnIfAbrupt(_v_).

    d.  If IsAnonymousFunctionDefinition(_Initializer_) is TRUE, then

        i.  Let _hasNameProperty_ be HasOwnProperty(_v_, "NAME").

        ii. ReturnIfAbrupt(_hasNameProperty_).

        iii. If _hasNameProperty_ is FALSE, then

            1.  SetFunctionName(_v_, StringValue(_BindingIdentifier_)).

            2.  Assert: SetFunctionName will not return an abrupt
                completion.

4.  Return the result of performing BindingInitialization for
    _BindingIdentifier_ passing _v_ and _environment_ as arguments.


Empty Statement

Syntax

EmptyStatement :

;

Runtime Semantics: Evaluation

_EmptyStatement_ : ;

1.  Return NormalCompletion(empty).


Expression Statement

Syntax

ExpressionStatement~[Yield]~ :

[lookahead ∉ {{, FUNCTION, CLASS, LET [ }] Expression~[In,\ ?Yield]~ ;

NOTE An _ExpressionStatement_ cannot start with an opening curly brace
because that might make it ambiguous with a _Block_. Also, an
_ExpressionStatement_ cannot start with the FUNCTION or CLASS keywords
because that would make it ambiguous with a _FunctionDeclaration_, a
_GeneratorDeclaration_, or a _ClassDeclaration_. An
_ExpressionStatement_ cannot start with the two token sequence LET [
because that would make it ambiguous with a LET _LexicalDeclaration_
whose first _LexicalBinding_ was an _ArrayBindingPattern_.

Runtime Semantics: Evaluation

_ExpressionStatement_ : _Expression_ ;

1.  Let _exprRef_ be the result of evaluating _Expression_.

2.  Return GetValue(_exprRef_).

3.  4.  


The if Statement

Syntax

IfStatement~[Yield,\ Return]~ :

IF ( Expression~[In,\ ?Yield]~ ) Statement~[?Yield,\ ?Return]~ ELSE
Statement~[?Yield,\ ?Return]~
IF ( Expression~[In,\ ?Yield]~ ) Statement~[?Yield,\ ?Return]~

Each ELSE for which the choice of associated IF is ambiguous shall be
associated with the nearest possible IF that would otherwise have no
corresponding ELSE.

Static Semantics: Early Errors

IfStatement :

IF ( Expression) Statement ELSE Statement
IF ( Expression ) Statement~[~

-   It is a Syntax Error if IsLabelledFunction(_Statement_) is TRUE for
    any occurrence of _Statement_ in these rules.

NOTE It is only necessary to apply this rule if the extension specified
in B.3.2 is inplemented.

Static Semantics: VarDeclaredNames

See also: 13.0.1, 13.1.8, 13.2.2.2, 13.6.1.1, 13.6.2.1, 13.6.3.1,
13.6.4.3, , 13.11.4, 13.12.10, 13.14.2, 14.1.17, 14.2.13, 15.1.5,
15.2.0.13.

_IfStatement_ : IF ( _Expression_ ) _Statement_ ELSE _Statement

1.  Let _names_ be VarDeclaredNames of the first _Statement_.

2.  Append to _names_ the elements of the VarDeclaredNames of the second
    _Statement._

3.  Return _names_.

_IfStatement_ : IF ( _Expression_ ) _Statement

1.  Return the VarDeclaredNames of _Statement_.

Static Semantics: VarScopedDeclarations

See also: 13.0.2, 13.1.9, 13.2.2.3, 13.6.1.2, 13.6.2.2, 13.6.3.3,
13.6.4.4, 13.10.3, 13.11.5, 13.12.11, 13.14.3, 14.1.18, 14.2.14, 15.1.6,
15.2.0.14.

_IfStatement_ : IF ( _Expression_ ) _Statement_ ELSE _Statement

1.  Let _declarations_ be VarScopedDeclarations of the first
    _Statement_.

2.  Append to _declarations_ the elements of the VarScopedDeclarations
    of the second _Statement._

3.  Return _declarations_.

_IfStatement_ : IF ( _Expression_ ) _Statement

1.  Return the VarDeclaredNames of _Statement_.

Runtime Semantics: Evaluation

_IfStatement_ : IF ( _Expression_ ) _Statement_ ELSE _Statement

1.  Let _exprRef_ be the result of evaluating _Expression_.

2.  Let _exprValue_ be ToBoolean(GetValue(_exprRef_)).

3.  ReturnIfAbrupt(_exprValue_).

4.  If _exprValue_ is TRUE, then

    a.  Let _stmtValue_ be the result of evaluating the first
        _Statement_.

5.  Else,

    a.  Let _stmtValue_ be the result of evaluating the second
        _Statement_.

6.  If _stmtValue_.[[type]] is normal and _stmtValue_.[[value]] is
    empty, then

    a.  Return NormalCompletion(UNDEFINED).

7.  Return _stmtValue_.

_IfStatement_ : IF ( _Expression_ ) _Statement

1.  Let _exprRef_ be the result of evaluating _Expression_.

2.  Let _exprValue_ be ToBoolean(GetValue(_exprRef_)).

3.  ReturnIfAbrupt(_exprValue_).

4.  If _exprValue_ is FALSE, then

    a.  Return NormalCompletion(UNDEFINED).

5.  Else,

    a.  Let _stmtValue_ be the result of evaluating _Statement_.

6.  If _stmtValue_.[[type]] is normal and _stmtValue_.[[value]] is
    empty, then

    a.  Return NormalCompletion(UNDEFINED).

7.  Return _stmtValue_.


Iteration Statements

Syntax

IterationStatement~[Yield,\ Return]~ :

  DO Statement~[?Yield,\ ?Return]~ WHILE ( Expression~[In,\ ?Yield]~ )
  ;~opt~

  WHILE ( Expression~[In,\ ?Yield]~ ) Statement~[?Yield,\ ?Return]~

  FOR ( [lookahead ∉ {LET [ }] Expression~[?Yield]opt~ ;
  Expression~[In,\ ?Yield]opt~ ; Expression~[In,\ ?Yield]opt~ )
  Statement~[?Yield,\ ?Return]~

  FOR ( VAR VariableDeclarationList~[?Yield]~;
  Expression~[In,\ ?Yield]opt~ ; Expression~[In,\ ?Yield]opt~ )
  Statement~[?Yield,\ ?Return]~

  FOR ( LexicalDeclaration~[?Yield]~ Expression~[In,\ ?Yield]opt~ ;
  Expression~[In,\ ?Yield]opt~ ) Statement~[?Yield,\ ?Return]~

  FOR ([lookahead ∉ {LET [ }] LeftHandSideExpression~[?Yield]~ IN
  Expression~[In,\ ?Yield]~ ) Statement~[?Yield,\ ?Return]~

  FOR ( VAR ForBinding~[?Yield]~ IN Expression~[In,\ ?Yield]~ )
  Statement~[?Yield,\ ?Return]~

  FOR ( ForDeclaration~[?Yield]~ IN Expression~[In,\ ?Yield]~ )
  Statement~[?Yield,\ ?Return]~

  FOR ([lookahead ≠ LET] LeftHandSideExpression~[?Yield]~ OF
  AssignmentExpression~[In,\ ?Yield]~ ) Statement~[?Yield, ?Return]~

  FOR ( VAR ForBinding~[?Yield]~ OF AssignmentExpression~[In,\ ?Yield]~
  ) Statement~[?Yield,\ ?Return]~

  FOR ( ForDeclaration~[?Yield]~ OF AssignmentExpression~[In,\ ?Yield]~
  ) Statement~[?Yield,\ ?Return]~

ForDeclaration~[Yield]~ :

LetOrConst ForBinding~[?Yield]~

NOTE 1 _ForBinding_ is defined in 12.2.4.2.

NOTE 2 A semicolon is not required after a DO-WHILE statement.

Semantics

Static Semantics: Early Errors

IterationStatement :

  DO Statement WHILE ( Expression ) ;~opt~

  WHILE ( Expression ) Statement

  FOR ( [lookahead ∉ {LET [ }] Expression~opt~ ; Expression~opt~ ;
  Expression~opt~ ) Statement

  FOR ( VAR VariableDeclarationList; Expression~opt~ ; Expression~opt~ )
  Statement

  FOR ( LexicalDeclaration Expression~opt~ ; Expression~opt~ ) Statement

  FOR ([lookahead ∉ {LET [ }] LeftHandSideExpression IN Expression)
  Statement

  FOR ( VAR ForBinding IN Expression ) Statement

  FOR ( ForDeclaration IN Expression) Statement

  FOR ([lookahead ≠ LET] LeftHandSideExpression OF AssignmentExpression
  ) Statement

  FOR ( VAR ForBinding OF AssignmentExpression ) Statement

  FOR ( ForDeclaration OF AssignmentExpression~[In,\ ?Yield]~ )
  Statement

-   It is a Syntax Error if IsLabelledFunction(_Statement_) is TRUE for
    any occurrence of _Statement_ in these rules.

NOTE It is only necessary to apply this rule if the extension specified
in B.3.2 is inplemented.

Runtime Semantics: LoopContinues(completion, labelSet) 

The abstract operation LoopContinues with arguments _completion_ and
_labelSet_ is defined by the following step:

1.  If _completion_.[[type]] is normal, then return TRUE.

2.  If _completion_.[[type]] is not continue, then return FALSE.

3.  If _completion_.[[target]] is empty, then return TRUE.

4.  If _completion_.[[target]] is an element of _labelSet_, then return
    TRUE.

5.  Return FALSE.

NOTE Within the _Statement_ part of an _IterationStatement_ a
_ContinueStatement_ may be used to begin a new iteration.

The do-while Statement

Static Semantics: VarDeclaredNames

See also: 13.0.1, 13.1.8, 13.2.2.2, 13.5.2, 13.6.2.1, 13.6.3.1,
13.6.4.3, , 13.11.4, 13.12.10, 13.14.2, 14.1.17, 14.2.13, 15.1.5,
15.2.0.13.

_IterationStatement_ : DO _Statement_ WHILE ( _Expression_ );~opt~

1.  Return the VarDeclaredNames of _Statement_.

Static Semantics: VarScopedDeclarations

See also: 13.0.2, 13.1.9, 13.2.2.3, 13.5.3, 13.6.2.2, 13.6.3.3,
13.6.4.4, 13.10.3, 13.11.5, 13.12.11, 13.14.3, 14.1.18, 14.2.14, 15.1.6,
15.2.0.14.

_IterationStatement_ : DO _Statement_ WHILE ( _Expression_ );~opt~

1.  Return the VarScopedDeclarations of _Statement_.

Runtime Semantics: LabelledEvaluation

  With argument _labelSet_.

See also: 13.0.2, 13.6.2.2, 13.6.3.3, 13.6.4.6, 13.12.12.

_IterationStatement_ : DO _Statement_ WHILE ( _Expression_ );~opt~

1.  Let _V_ = UNDEFINED.

2.  Repeat

    a.  Let _stmt_ be the result of evaluating _Statement_.

    b.  If LoopContinues (_stmt_,_labelSet_) is FALSE, return _stmt_.

    c.  If _stmt_.[[value]] is not empty, let _V_ = _stmt_.[[value]]_._

    d.  e.  Let _exprRef_ be the result of evaluating _Expression_.

    f.  Let _exprValue_ be ToBoolean(GetValue(_exprRef_)).

    g.  If _exprValue_ is FALSE, return NormalCompletion(_V_).

    h.  Else if _exprValue_ is not TRUE, then

        i.  Assert: _exprValue_ is an abrupt completion.

        ii. If LoopContinues (_exprValue_,_labelSet_) is FALSE, return
            _exprValue._

The while Statement

Static Semantics: VarDeclaredNames

See also: 13.0.1, 13.1.8, 13.2.2.2, 13.5.2, 13.6.1.1, 13.6.3.1,
13.6.4.3, , 13.11.4, 13.12.10, 13.14.2, 14.1.17, 14.2.13, 15.1.5,
15.2.0.13.

_IterationStatement_ : WHILE ( _Expression_ ) _Statement

1.  Return the VarDeclaredNames of _Statement_.

Static Semantics: VarScopedDeclarations

See also: 13.0.2, 13.1.9, 13.2.2.3, 13.5.3, 13.6.1.2, 13.6.3.3,
13.6.4.4, 13.10.3, 13.11.5, 13.12.11, 13.14.3, 14.1.18, 14.2.14, 15.1.6,
15.2.0.14.

_IterationStatement_ : WHILE ( _Expression_ ) _Statement

1.  Return the VarScopedDeclarations of _Statement_.

Runtime Semantics: LabelledEvaluation

  With argument _labelSet_.

See also: 13.0.2, 13.6.1.2, 13.6.3.3, 13.6.4.6, 13.12.12.

_IterationStatement_ : WHILE ( _Expression_ ) _Statement

1.  Let _V_ = UNDEFINED.

2.  Repeat

    a.  Let _exprRef_ be the result of evaluating _Expression_.

    b.  Let _exprValue_ be ToBoolean(GetValue(_exprRef_)).

    c.  If _exprValue_ is FALSE, return NormalCompletion(_V_).

    d.  If _exprValue_ is not TRUE, then

        i.  Assert: _exprValue_ is an abrupt completion.

        ii. If LoopContinues (_exprValue_,_labelSet_) is FALSE, return
            _exprValue._

    e.  Let _stmt_ be the result of evaluating _Statement_.

    f.  If LoopContinues (_stmt_,_labelSet_) is FALSE, return _stmt_.

    g.  If _stmt_.[[value]] is not empty, let _V_ = _stmt_.[[value]].

    h.  

The for Statement

Static Semantics: Early Errors

_IterationStatement_ : FOR ( _LexicalDeclaration_ _Expression_~opt~ ;
_Expression_~opt~ ) _Statement

-   It is a Syntax Error if any element of the BoundNames of
    _LexicalDeclaration_ also occurs in the VarDeclaredNames of
    _Statement_.

Static Semantics: VarDeclaredNames

See also: 13.0.1, 13.1.8, 13.2.2.2, 13.5.2, 13.6.1.1, 13.6.2.1,
13.6.4.3, , 13.11.4, 13.12.10, 13.14.2, 14.1.17, 14.2.13, 15.1.5,
15.2.0.13.

_IterationStatement_ : FOR ( _Expression_~opt~ ; _Expression_~opt~ ;
_Expression_~opt~ ) _Statement

1.  Return the VarDeclaredNames of _Statement_.

_IterationStatement_ : FOR ( VAR _VariableDeclarationList_ ;
_Expression_~opt~ ; _Expression_~opt~ ) _Statement

1.  Let _names_ be BoundNames of _VariableDeclarationList_.

2.  Append to _names_ the elements of the VarDeclaredNames of
    _Statement._

3.  Return _names_.

_IterationStatement_ : FOR ( _LexicalDeclaration_ _Expression_~opt~ ;
_Expression_~opt~ ) _Statement

1.  Return the VarDeclaredNames of _Statement_.

Static Semantics: VarScopedDeclarations

See also: 13.0.2, 13.1.9, 13.2.2.3, 13.5.3, 13.6.1.2, 13.6.2.2,
13.6.4.4, 13.10.3, 13.11.5, 13.12.11, 13.14.3, 14.1.18, 14.2.14, 15.1.6,
15.2.0.14.

_IterationStatement_ : FOR ( _Expression_~opt~ ; _Expression_~opt~ ;
_Expression_~opt~ ) _Statement

1.  Return the VarScopedDeclarations of _Statement_.

_IterationStatement_ : FOR ( VAR _VariableDeclarationList_ ;
_Expression_~opt~ ; _Expression_~opt~ ) _Statement

1.  Let _declarations_ be VarScopedDeclarations of
    _VariableDeclarationList_.

2.  Append to _declarations_ the elements of the VarScopedDeclarations
    of _Statement._

3.  Return _declarations_.

_IterationStatement_ : FOR ( _LexicalDeclaration_ _Expression_~opt~ ;
_Expression_~opt~ ) _Statement

1.  Return the VarScopedDeclarations of _Statement_.

Runtime Semantics: LabelledEvaluation

  With argument _labelSet_.

See also: 13.0.2, 13.6.1.2, 13.6.2.2, 13.6.4.6, 13.12.12.

_IterationStatement_ : FOR ( _Expression_~opt~ ; _Expression_~opt~ ;
_Expression_~opt~ ) _Statement

1.  If the first _Expression_ is present, then

    a.  Let _exprRef_ be the result of evaluating the first
        _Expression_.

    b.  Let _exprValue_ be GetValue(_exprRef_).

    c.  If LoopContinues(_exprValue_,_labelSet_) is FALSE, return
        _exprValue._

2.  Return the result of performing ForBodyEvaluation with the second
    _Expression_ as the _testExpr_ argument, the third _Expression_ as
    the _incrementExpr_ argument, _Statement_ as the _stmt_ argument, ()
    as the _perIterationBindings_, and with _labelSet_.

_IterationStatement_ : FOR ( VAR _VariableDeclarationList_ ;
_Expression_~opt~ ; _Expression_~opt~ ) _Statement

1.  Let _varDcl_ be the result of evaluating _VariableDeclarationList_.

2.  If LoopContinues(_varDcl_,_labelSet_) is FALSE, return _varDcl_.

3.  Return the result of performing ForBodyEvaluation with the first
    _Expression_ as the _testExpr_ argument, the second _Expression_ as
    the _incrementExpr_ argument, _Statement_ as the _stmt_ argument, ()
    as the _perIterationBindings_, and with _labelSet_.

_IterationStatement_ : FOR ( _LexicalDeclaration_ _Expression_~opt~ ;
_Expression_~opt~ ) _Statement

1.  Let _oldEnv_ be the running execution context’s LexicalEnvironment.

2.  Let _loopEnv_ be NewDeclarativeEnvironment(_oldEnv_).

3.  Let _isConst_ be the result of performing IsConstantDeclaration of
    _LexicalDeclaration_.

4.  Let _boundNames_ be the BoundNames of _LexicalDeclaration_.

5.  For each element _dn_ of _boundNames_ do

    a.  If _isConst_ is TRUE, then

        i.  Call _loopEnv_’s CreateImmutableBinding concrete method
            passing _dn_ as the argument.

    b.  Else,

        i.  Call _loopEnv_’s CreateMutableBinding concrete method
            passing _dn_ and FALSE as the arguments.

        ii. Assert: The above call to CreateMutableBinding will never
            return an abrupt completion.

6.  Set the running execution context’s LexicalEnvironment to _loopEnv_.

7.  Let _forDcl_ be the result of evaluating _LexicalDeclaration_.

8.  If LoopContinues(_forDcl_,_labelSet_) is FALSE, then

    a.  Set the running execution context’s LexicalEnvironment to
        _oldEnv_.

    b.  Return _forDcl_.

9.  If _isConst_ is FALSE, let _perIterationLets_ be _boundNames
    otherwise let _perIterationLets_ be ( ).

10. Let _bodyResult_ be the result of performing ForBodyEvaluation with
    the first _Expression_ as the _testExpr_ argument, the second
    _Expression_ as the _incrementExpr_ argument, _Statement_ as the
    _stmt_ argument, _perIterationLets_ as the _perIterationBindings_,
    and with _labelSet_.

11. Set the running execution context’s LexicalEnvironment to _oldEnv_.

12. Return _bodyResult_.

Runtime Semantics: ForBodyEvaluation 

The abstract operation ForBodyEvaluation with arguments _testExpr_,
_incrementExpr_, _stmt_, _perIterationBindings_, and _labelSet_ is
performed as follows:

1.  Let _V_ = UNDEFINED.

2.  Let _status_ be
    CreatePerIterationEnvironment(_perIterationBindings_).

3.  ReturnIfAbrupt(_status_).

4.  Repeat

    a.  If _testExpr_ is not [empty], then

        i.  Let _testExprRef_ be the result of evaluating _testExpr_.

        ii. Let _testExprValue_ be ToBoolean(GetValue(_testExprRef_))

        iii. If _testExprValue_ is FALSE, return NormalCompletion(_V_).

        iv. Else if LoopContinues (_testExprValue_,_labelSet_) is FALSE,
            return _testExprValue._

    b.  Let _result_ be the result of evaluating _stmt_.

    c.  If LoopContinues (_result_,_labelSet_) is FALSE, return _result_

    d.  If _result_.[[value]] is not empty, let _V_ =
        _result_.[[value]].

    e.  f.  Let _status_ be
        CreatePerIterationEnvironment(_perIterationBindings_).

    g.  ReturnIfAbrupt(_status_).

    h.  If _incrementExpr_ is not [empty], then

        i.  Let _incExprRef_ be the result of evaluating
            _incrementExpr_.

        ii. Let _incExprValue_ be GetValue(_incExprRef_).

        iii. If LoopContinues(_incExprValue_,_labelSet_) is FALSE,
            return _incExprValue._

Runtime Semantics: CreatePerIterationEnvironment 

The abstract operation CreatePerIterationEnvironment with argument
_perIterationBindings_ is performed as follows:

1.  If _perIterationBindings_ has any elements, then

    a.  Let _lastIterationEnv_ be the running execution context’s
        LexicalEnvironment.

    b.  Let _outer_ be _lastIterationEnv_’s outer environment reference.

    c.  Assert: _outer_ is not NULL.

    d.  Let _thisIterationEnv_ be NewDeclarativeEnvironment(_outer_).

    e.  For each element _bn_ of _perIterationBindings_ do,

        i.  Let _status_ be the result of calling _thisIterationEnv_’s
            CreateMutableBinding concrete method passing _bn_ and FALSE
            as the arguments.

        ii. Assert: _status_ is never an abrupt completion.

        iii. Let _lastValue_ be the result of calling
            _lastIterationEnv_’s GetBindingValue concrete method passing
            _bn_ and TRUE as the arguments.

        iv. ReturnIfAbrupt(_lastValue_).

        v.  Call the InitializeBinding concrete method of
            _thisIterationEnv_ passing _bn_ and _lastValue_ as the
            arguments.

    f.  Set the running execution context’s LexicalEnvironment to
        _thisIterationEnv._

2.  Return UNDEFINED

The for-in and for-of Statements

Static Semantics: Early Errors

_IterationStatement_ :

  FOR ( _LeftHandSideExpression_ IN _Expression_ ) _Statement_

  FOR ( _LeftHandSideExpression_ OF _AssignmentExpression_ ) _Statement_

-   It is a Syntax Error if _LeftHandSideExpression_ is either an
    _ObjectLiteral_ or an _ArrayLiteral_ and if the lexical token
    sequence matched by _LeftHandSideExpression_ cannot be parsed with
    no tokens left over using _AssignmentPattern_ as the goal symbol.

-   If _LeftHandSideExpression_ is either an _ObjectLiteral_ or an
    _ArrayLiteral_ and if the lexical token sequence matched by
    _LeftHandSideExpression_ can be parsed with no tokens left over
    using _AssignmentPattern_ as the goal symbol then the following
    rules are not applied. Instead, the Early Error rules for
    _AssignmentPattern_ are used.

-   It is a Syntax Error if _LeftHandSideExpression_ is a
    _IdentifierReference_ that can be statically determined to always
    resolve to a declarative environment record binding and the resolved
    binding is an immutable binding.

-   It is a Syntax Error if _LeftHandSideExpression_ is neither an
    _ObjectLiteral_ nor an _ArrayLiteral_ and
    IsValidSimpleAssignmentTarget of _LeftHandSideExpression_ is FALSE.

-   It is a Syntax Error if the _LeftHandSideExpression_ is
    _CoverParenthesizedExpressionAndArrowParameterList_ : ( _Expression_
    )
    and _Expression_ derives a production that would produce a Syntax
    Error according to these rules if that production is substituted for
    _LeftHandSideExpression_. This rule is recursively applied.

  NOTE The last rule means that the other rules are applied even if
  parentheses surround _Expression_.

_IterationStatement_ :

  FOR ( _ForDeclaration_ IN _Expression_ ) _Statement_

  FOR ( _ForDeclaration_ OF _AssignmentExpression_ ) _Statement_

-   It is a Syntax Error if the BoundNames of _ForDeclaration_ contains
    "LET".

-   It is a Syntax Error if any element of the BoundNames of
    _ForDeclaration_ also occurs in the VarDeclaredNames of _Statement_.

Static Semantics: BoundNames

See also: 13.2.1.2, 13.2.2.1, 12.1.2, 14.1.3, 14.2.2, 14.4.2, 14.5.2,
15.2.1.2, 15.2.2.1.

_ForDeclaration_ : _LetOrConst_ _ForBinding

1.  Return the BoundNames of _ForBinding_.

Static Semantics: VarDeclaredNames

See also: 13.0.1, 13.1.8, 13.2.2.2, 13.5.2, 13.6.1.1, 13.6.2.1,
13.6.3.1, , 13.11.4, 13.12.10, 13.14.2, 14.1.17, 14.2.13, 15.1.5,
15.2.0.13.

_IterationStatement_ : FOR ( _LeftHandSideExpression_ IN _Expression_ )
_Statement

1.  Return the VarDeclaredNames of _Statement_.

_IterationStatement_ : FOR ( VAR _ForBinding_ IN _Expression_ )
_Statement

1.  Let _names_ be the BoundNames of _ForBinding_.

2.  Append to _names_ the elements of the VarDeclaredNames of
    _Statement._

3.  Return _names.

_IterationStatement_ : FOR ( _ForDeclaration_ IN _Expression_ )
_Statement

1.  Return the VarDeclaredNames of _Statement_.

_IterationStatement_ : FOR ( _LeftHandSideExpression_ OF
_AssignmentExpression_ ) _Statement

1.  Return the VarDeclaredNames of _Statement_.

_IterationStatement_ : FOR ( VAR _ForBinding_ OF _AssignmentExpression
) _Statement_

1.  Let _names_ be the BoundNames of _ForBinding_.

2.  Append to _names_ the elements of the VarDeclaredNames of
    _Statement._

3.  Return _names.

_IterationStatement_ : FOR ( _ForDeclaration_ OF _AssignmentExpression
) _Statement_

1.  Return the VarDeclaredNames of _Statement_.

Static Semantics: VarScopedDeclarations

See also: 13.1.9, 13.2.2.3, 13.5.3, 13.6.1.2, 13.6.2.2, 13.6.3.3,
13.10.3, 13.11.5, 13.12.11, 13.14.3, 14.1.18, 14.2.14, 15.1.6,
15.2.0.14.

_IterationStatement_ : FOR ( _LeftHandSideExpression_ IN _Expression_ )
_Statement

1.  Return the VarScopedDeclarations of _Statement_.

_IterationStatement_ : FOR ( VAR _ForBinding_ IN _Expression_ )
_Statement

1.  Let _declarations_ be a List containing _ForBinding_.

2.  Append to _declarations_ the elements of the VarScopedDeclarations
    of _Statement._

3.  Return _declarations.

_IterationStatement_ : FOR ( _ForDeclaration_ IN _Expression_ )
_Statement

1.  Return the VarScopedDeclarations of _Statement_.

_IterationStatement_ : FOR ( _LeftHandSideExpression_ OF
_AssignmentExpression_ ) _Statement

1.  Return the VarScopedDeclarations of _Statement_.

_IterationStatement_ : FOR ( VAR _ForBinding_ OF _AssignmentExpression
) _Statement_

1.  Let _declarations_ be a List containing _ForBinding_.

2.  Append to _declarations_ the elements of the VarScopedDeclarations
    of _Statement._

3.  Return _declarations.

_IterationStatement_ : FOR ( _ForDeclaration_ OF _AssignmentExpression
) _Statement_

1.  Return the VarScopedDeclarations of _Statement_.

Runtime Semantics: BindingInstantiation

  With arguments _value_ and _environment_.

See also: 13.0.2, 13.6.1.2, 13.6.2.2, 13.6.3.3, 13.12.12.

_ForDeclaration_ : _LetOrConst_ _ForBinding

1.  For each element _name_ of the BoundNames of _ForBinding_ do

    a.  If IsConstantDeclaration of _LetOrConst_ is TRUE, then

        i.  Call _environment_’s CreateImmutableBinding concrete method
            with argument _name_.

    b.  Else,

        i.  Call _environment_’s CreateMutableBinding concrete method
            with argument _name_.

        ii. Assert: The above call to CreateMutableBinding will never
            return an abrupt completion.

2.  Return the result of performing BindingInitialization for
    _ForBinding_ passing _value_ and _environment_ as the arguments.

Runtime Semantics: LabelledEvaluation

  With argument _labelSet_.

See also: 13.0.2, 13.6.1.2, 13.6.2.2, 13.6.3.3, 13.12.12.

_IterationStatement_ : FOR ( _LeftHandSideExpression_ IN _Expression_ )
_Statement

1.  Let _keyResult_ be ForIn/OfExpressionEvaluation( ( ), _Expression_,
    enumerate, _labelSet_).

2.  ReturnIfAbrupt(_keyResult_).

3.  Return the result of performing ForIn/OfBodyEvaluation with
    _LeftHandSideExpression_, _Statement_, _keyResult_, assignment, and
    _labelSet_.

_IterationStatement_ : FOR ( VAR _ForBinding_ IN _Expression_ )
_Statement

1.  Let _keyResult_ be ForIn/OfExpressionEvaluation( ( ), _Expression_,
    enumerate, _labelSet_).

2.  ReturnIfAbrupt(_keyResult_).

3.  Return the result of performing ForIn/OfBodyEvaluation with
    _ForBinding_, _Statement_, _keyResult_, varBinding, and _labelSet_.

_IterationStatement_ : FOR ( _ForDeclaration_ IN _Expression_ )
_Statement

1.  Let _keyResult_ be the result of performing
    ForIn/OfExpressionEvaluation(BoundNames of _ForDeclaration_,
    _Expression_, enumerate, _labelSet_).

2.  ReturnIfAbrupt(_keyResult_).

3.  Return the result of performing ForIn/OfBodyEvaluation with
    _ForDeclaration_, _Statement_, _keyResult_, lexicalBinding, and
    _labelSet_.

_IterationStatement_ : FOR ( _LeftHandSideExpression_ OF
_AssignmentExpression_ ) _Statement

1.  Let _keyResult_ be the result of performing
    ForIn/OfExpressionEvaluation( ( ), _AssignmentExpression_, iterate,
    _labelSet_).

2.  ReturnIfAbrupt(_keyResult_).

3.  Return the result of performing ForIn/OfBodyEvaluation with
    _LeftHandSideExpression_, _Statement_, _keyResult_, assignment, and
    _labelSet_.

_IterationStatement_ : FOR ( VAR _ForBinding_ OF _AssignmentExpression
) _Statement_

1.  Let _keyResult_ be the result of performing
    ForIn/OfExpressionEvaluation( ( ), _AssignmentExpression_, iterate,
    _labelSet_).

2.  ReturnIfAbrupt(_keyResult_).

3.  Return the result of performing ForIn/OfBodyEvaluation with
    _ForBinding_, _Statement_, _keyResult_, varBinding, and _labelSet_.

_IterationStatement_ : FOR ( _ForDeclaration_ OF _AssignmentExpression
) _Statement_

1.  Let _keyResult_ be the result of performing
    ForIn/OfExpressionEvaluation( BoundNames of _ForDeclaration_,
    _AssignmentExpression_, iterate, _labelSet_).

2.  ReturnIfAbrupt(_keyResult_).

3.  Return the result of performing ForIn/OfBodyEvaluation with
    _ForDeclaration_, _Statement_, _keyResult_, lexicalBinding, and
    _labelSet_.

Runtime Semantics: ForIn/OfExpressionEvaluation Abstract Operation

The abstract operation ForIn/OfExpressionEvaluation is called with
arguments _TDZnames_, _expr_, _iterationKind_, and _labelSet_. The value
of _iterationKind_ is either ENUMERATE or ITERATE.

1.  Let _oldEnv_ be the running execution context’s LexicalEnvironment.

2.  If _TDZnames_ is not an empty List, then

    a.  Assert: _TDZnames_ has no duplicate entries.

    b.  Let _TDZ_ be NewDeclarativeEnvironment(_oldEnv_).

    c.  For each string _name_ in _TDZnames_, do

        i.  Let _status_ be the result of calling _TDZ_’s
            CreateMutableBinding concrete method passing _name_ and
            FALSE as the arguments.

        ii. Assert: _status_ is never an abrupt completion.

    d.  Set the running execution context’s LexicalEnvironment to _TDZ_.

3.  Let _exprRef_ be the result of evaluating the production that is
    _expr_.

4.  Set the running execution context’s LexicalEnvironment to _oldEnv_.

5.  Let _exprValue_ be GetValue(_exprRef_).

6.  If _exprValue_ is an abrupt completion,

    a.  If LoopContinues(_exprValue_,_labelSet_) is FALSE, then return
        _exprValue_.

    b.  Else, return Completion{[[type]]: break, [[value]]: empty,
        [[target]]: empty}.

7.  If _iterationKind_ is enumerate, then

    a.  If _exprValue_.[[value]] is NULL or UNDEFINED, then

        i.  Return Completion{[[type]]: break, [[value]]: empty,
            [[target]]: empty}.

8.  Let _obj_ be ToObject(_exprValue_).

9.  If _iterationKind_ is enumerate, then

    a.  Let _keys_ be the result of calling the [[Enumerate]] internal
        method of _obj_ with no arguments.

10. Else,

    a.  Assert: _iterationKind_ is iterate.

    b.  Let _keys_ be GetIterator(_obj_).

11. If _keys_ is an abrupt completion, then

    a.  If LoopContinues(_keys_,_labelSet_) is FALSE, then return
        _keys_.

    b.  Assert: _keys_.[[type]] is continue

    c.  Return Completion{[[type]]: break, [[value]]: empty, [[target]]:
        empty}.

12. Return _keys_.

Runtime Semantics: ForIn/OfBodyEvaluation 

The abstract operation ForIn/OfBodyEvaluation is called with arguments
_lhs_, _stmt,_ _iterator,_ _lhsKind_, and _labelSet._ The value of
_lhsKind_ is either ASSIGNMENT, VARBINDING or LEXICALBINDING.

1.  Let _oldEnv_ be the running execution context’s LexicalEnvironment.

2.  Let _V_ = UNDEFINED .

3.  Repeat

    a.  Let _nextResult_ be IteratorStep(_iterator_).

    b.  ReturnIfAbrupt(_nextResult_).

    c.  If _nextResult_ is FALSE, then return NormalCompletion(_V_).

    d.  Let _nextValue_ be IteratorValue(_nextResult_).

    e.  ReturnIfAbrupt(_nextValue_).

    f.  If _lhsKind_ is assignment, then

        i.  Assert: _lhs_ is a _LeftHandSideExpression_.

        ii. If _lhs_ is neither an _ObjectLiteral_ nor an _ArrayLiteral_
            then

            1.  Let _lhsRef_ be the result of evaluating _lhs_ ( it may
                be evaluated repeatedly).

            2.  Let _status_ be PutValue(_lhsRef_, _nextValue_).

        iii. Else

            1.  Let _assignmentPattern_ be the parse of the source code
                corresponding to _lhs_ using _AssignmentPattern_ as the
                goal symbol.

            2.  If Type(_nextValue_) is not Object, then throw a
                TYPEERROR exception.

            3.  Let _status_ be the result of performing
                DestructuringAssignmentEvaluation of _AssignmentPattern_
                using _nextValue_ as the argument.

    g.  Else if _lhsKind_ is varBinding, then

        i.  Assert: _lhs_ is a _ForBinding_.

        ii. Let _status_ be the result of performing
            BindingInitialization for _lhs_ passing _nextValue_ and
            UNDEFINED as the arguments.

    h.  Else,

        i.  Assert: _lhsKind_ is lexicalBinding.

        ii. Assert: _lhs_ is a _ForDeclaration_.

        iii. Let _iterationEnv_ be NewDeclarativeEnvironment(_oldEnv_).

        iv. Let _status_ be the result of performing
            BindingInstantiation for _lhs_ passing _nextValue_ and
            _iterationEnv_ as arguments.

        v.  Assert: _status_ is not an abrupt completion.

        vi. Set the running execution context’s LexicalEnvironment to
            _iterationEnv_.

    i.  If _status_.[[type]] is normal, then

        i.  Let _status_ be the result of evaluating _stmt_.

        ii. If _status_.[[type]] is normal and _status_.[[value]] is not
            empty, then

            1.  Let _V_ = _status_.[[value]].

    j.  Set the running execution context’s LexicalEnvironment to
        _oldEnv_.

    k.  If _status_ is an abrupt completion and
        LoopContinues(_status_,_labelSet_) is FALSE, then

        i.  If _status_.[[type]] is throw.

            1.  If HasProperty(_iterator_, "THROW") is TRUE, then

                a.  Let _innerResult_ be Invoke(_iterator_, "THROW",
                    (_status_.[[value]])).

                b.  ReturnIfAbrupt(_innerResult_).

        ii. Else if HasProperty(_iterator_, "RETURN") is TRUE, then

            1.  Let _innerResult_ be Invoke(_iterator_, "RETURN", ( )).

            2.  ReturnIfAbrupt(_innerResult_).

        i.  Return _status_.


The continue Statement

Syntax

ContinueStatement~[Yield]~ :

CONTINUE ;
CONTINUE [no LineTerminator here] _LabelIdentifier_~[?Yield]~ ;

Static Semantics: Early Errors

_ContinueStatement_ : CONTINUE ;

-   It is a Syntax Error if this production is not nested, directly or
    indirectly (but not crossing function boundaries), within an
    _IterationStatement_.

_ContinueStatement_ : CONTINUE _LabelIdentifier_ ;

-   It is a Syntax Error if this production is not nested, directly or
    indirectly (but not crossing function boundaries), within an
    _IterationStatement_.

-   It is a Syntax Error if StringValue(_LabelIdentifier_) does not
    appear in the enclosing IterationLabelSet of this
    _ContinueStatement_.

Runtime Semantics: Evaluation

_ContinueStatement_ : CONTINUE ;

1.  Return Completion{[[type]]: continue, [[value]]: empty, [[target]]:
    empty}.

_ContinueStatement_ : CONTINUE _LabelIdentifier_;

1.  Let _label_ be the StringValue of _LabelIdentifier_.

2.  Return Completion{[[type]]: continue, [[value]]: empty, [[target]]:
    _label_ }.


The break Statement

Syntax

BreakStatement~[Yield]~ :

BREAK ;
BREAK [no LineTerminator here] _LabelIdentifier_~[?Yield]~ ;

Static Semantics: Early Errors

_BreakStatement_ : BREAK ;

-   It is a Syntax Error if this production is not nested, directly or
    indirectly (but not crossing function boundaries), within an
    _IterationStatement_ or a _SwitchStatement_.

_BreakStatement_ : BREAK _LabelIdentifier_ ;

-   It is a Syntax Error if StringValue(_LabelIdentifier_) does not
    appear in the enclosing CurrentLabelSet of this _BreakStatement_.

Runtime Semantics: Evaluation

_BreakStatement_ : BREAK ;

1.  Return Completion{[[type]]: break, [[value]]: empty, [[target]]:
    empty}.

_BreakStatement_ : BREAK _LabelIdentifier_;

1.  Let _label_ be the StringValue of _LabelIdentifier_.

2.  Return Completion{[[type]]: break, [[value]]: empty, [[target]]:
    _label_ }.


The return Statement

Syntax

ReturnStatement~[Yield]~ :

RETURN ;
RETURN [no LineTerminator here] Expression~[In,\ ?Yield]~ ;

NOTE A RETURN statement causes a function to cease execution and return
a value to the caller. If _Expression_ is omitted, the return value is
UNDEFINED. Otherwise, the return value is the value of _Expression_.

Runtime Semantics: Evaluation

_ReturnStatement_ : RETURN ;

1.  Return Completion{[[type]]: return, [[value]]: UNDEFINED,
    [[target]]: empty}.

_ReturnStatement_ : RETURN _Expression_ ;

1.  Let _exprRef_ be the result of evaluating _Expression_.

2.  Let _exprValue_ be GetValue(_exprRef_).

3.  ReturnIfAbrupt(_exprValue_).

4.  Return Completion{[[type]]: return, [[value]]: _exprValue_,
    [[target]]: empty}.


The with Statement

Syntax

WithStatement~[Yield,\ Return]~ :

WITH ( Expression~[In,\ ?Yield]~ ) Statement~[?Yield,\ ?Return]~

NOTE The WITH statement adds an object environment record for a computed
object to the lexical environment of the running execution context. It
then executes a statement using this augmented lexical environment.
Finally, it restores the original lexical environment.

Static Semantics: Early Errors

_WithStatement_ : WITH ( _Expression_ ) _Statement

-   It is a Syntax Error if the code that matches this production is
    contained in strict code.

-   It is a Syntax Error if IsLabelledFunction(_Statement_) is TRUE.

NOTE It is only necessary to apply the second rule if the extension
specified in B.3.2 is inplemented.

Static Semantics: VarDeclaredNames

See also: 13.0.1, 13.1.8, 13.2.2.2, 13.5.2, 13.6.1.1, 13.6.2.1,
13.6.3.1, 13.6.4.3, 13.11.4, 13.12.10, 13.14.2, 14.1.17, 14.2.13,
15.1.5, 15.2.0.13.

_WithStatement_ : WITH ( _Expression_ ) _Statement

1.  Return the VarDeclaredNames of _Statement_.

Static Semantics: VarScopedDeclarations

See also: 13.0.2, 13.1.9, 13.2.2.3, 13.5.3, 13.6.1.2, 13.6.2.2,
13.6.3.3, 13.6.4.4, 13.11.5, 13.12.11, 13.14.3, 14.1.18, 14.2.14,
15.1.6, 15.2.0.14.

_WithStatement_ : WITH ( _Expression_ ) _Statement

1.  Return the VarScopedDeclarations of _Statement_.

Runtime Semantics: Evaluation

_WithStatement_ : WITH ( _Expression_ ) _Statement

1.  Let _val_ be the result of evaluating _Expression_.

2.  Let _obj_ be ToObject(GetValue(_val_)).

3.  ReturnIfAbrupt(_obj_).

4.  Let _oldEnv_ be the running execution context’s LexicalEnvironment.

5.  Let _newEnv_ be NewObjectEnvironment(_obj_, _oldEnv_).

6.  Set the _withEnvironment_ flag of _newEnv’s_ environment record to
    TRUE.

7.  Set the running execution context’s LexicalEnvironment to _newEnv_.

8.  Let _C_ be the result of evaluating _Statement_.

9.  Set the running execution context’s Lexical Environment to _oldEnv_.

10. Return _C_.

NOTE No matter how control leaves the embedded _Statement_, whether
normally or by some form of abrupt completion or exception, the
LexicalEnvironment is always restored to its former state.


The switch Statement

Syntax

SwitchStatement~[Yield,\ Return]~ :

SWITCH ( Expression~[In,\ ?Yield]~ ) CaseBlock~[?Yield,\ ?Return]~

CaseBlock~[Yield,\ Return]~ :

{ CaseClauses~[?Yield,\ ?Return]opt~ }
{ CaseClauses~[?Yield,\ ?Return]opt~ DefaultClause~[?Yield,\ ?Return]~
CaseClauses~[?Yield,\ ?Return]opt~ }

CaseClauses~[Yield,\ Return]~ :

CaseClause~[?Yield,\ ?Return]~
CaseClauses~[?Yield,\ ?Return]~ CaseClause~[?Yield,\ ?Return]~

CaseClause~[Yield,\ Return]~ :

CASE Expression~[In,\ ?Yield]~ : StatementList~[?Yield,\ ?Return]opt~

DefaultClause~[Yield,\ Return]~ :

DEFAULT : StatementList~[?Yield,\ ?Return]opt~

Static Semantics: Early Errors

_CaseBlock_ : { _CaseClauses_ }

-   It is a Syntax Error if the LexicallyDeclaredNames of _CaseClauses_
    contains any duplicate entries.

-   It is a Syntax Error if any element of the LexicallyDeclaredNames of
    _CaseClauses_ also occurs in the VarDeclaredNames of _CaseClauses_.

Static Semantics: LexicallyDeclaredNames

See also: 13.1.2, 13.12.4, 14.1.14, 14.2.10, 15.1.3, 15.2.0.10.

_CaseBlock_ : { }

1.  Return a new empty List.

_CaseBlock_ : { _CaseClauses_~opt~ _DefaultClause_ _CaseClauses_~opt~ }

1.  If the first _CaseClauses_ is present, let _names_ be the
    LexicallyDeclaredNames of the first _CaseClauses_.

2.  Else let _names_ be a new empty List.

3.  Append to _names_ the elements of the LexicallyDeclaredNames of the
    _DefaultClause._

4.  If the second _CaseClauses_ is not present, return _names_.

5.  Else return the result of appending to _names_ the elements of the
    LexicallyDeclaredNames of the second _CaseClauses_.

_CaseClauses_ : _CaseClauses_ _CaseClause

1.  Let _names_ be LexicallyDeclaredNames of _CaseClauses_.

2.  Append to _names_ the elements of the LexicallyDeclaredNames of
    _CaseClause._

3.  Return _names_.

_CaseClause_ : CASE _Expression_ : _StatementList_~opt~

1.  If the _StatementList_ is present, return the LexicallyDeclaredNames
    of _StatementList_.

2.  Else return a new empty List.

_DefaultClause_ : DEFAULT : _StatementList_~opt~

1.  If the _StatementList_ is present, return the LexicallyDeclaredNames
    of _StatementList_.

2.  Else return a new empty List.

Static Semantics: LexicallyScopedDeclarations

See also: 13.1.3, 13.12.5, 14.1.15, 14.2.11, 15.1.4, 15.2.0.11.

_CaseBlock_ : { }

1.  Return a new empty List.

_CaseBlock_ : { _CaseClauses_~opt~ _DefaultClause_ _CaseClauses_~opt~ }

1.  If the first _CaseClauses_ is present, let _declarations_ be the
    LexicallyScopedDeclarations of the first _CaseClauses_.

2.  Else let _declarations_ be a new empty List.

3.  Append to _declarations_ the elements of the
    LexicallyScopedDeclarations of the _DefaultClause._

4.  If the second _CaseClauses_ is not present, return _declarations_.

5.  Else return the result of appending to _declarations_ the elements
    of the LexicallyScopedDeclarations of the second _CaseClauses_.

_CaseClauses_ : _CaseClauses_ _CaseClause

1.  Let _declarations_ be LexicallyScopedDeclarations of _CaseClauses_.

2.  Append to _declarations_ the elements of the
    LexicallyScopedDeclarations of _CaseClause._

3.  Return _declarations_.

_CaseClause_ : CASE _Expression_ : _StatementList_~opt~

1.  If the _StatementList_ is present, return the
    LexicallyScopedDeclarations of _StatementList_.

2.  Else return a new empty List.

_DefaultClause_ : DEFAULT : _StatementList_~opt~

1.  If the _StatementList_ is present, return the
    LexicallyScopedDeclarations of _StatementList_.

2.  Else return a new empty List.

Static Semantics: VarDeclaredNames

See also: 13.0.1, 13.1.8, 13.2.2.2, 13.5.2, 13.6.1.1, 13.6.2.1,
13.6.3.1, 13.6.4.3, , 13.12.10, 13.14.2, 14.1.17, 14.2.13, 15.1.5,
15.2.0.13.

_SwitchStatement_ : SWITCH ( _Expression_ ) _CaseBlock

1.  Return the VarDeclaredNames of _CaseBlock_.

_CaseBlock_ : { }

1.  Return a new empty List.

_CaseBlock_ : { _CaseClauses_~opt~ _DefaultClause_ _CaseClauses_~opt~ }

1.  If the first _CaseClauses_ is present, let _names_ be the
    VarDeclaredNames of the first _CaseClauses_.

2.  Else let _names_ be a new empty List.

3.  Append to _names_ the elements of the VarDeclaredNames of the
    _DefaultClause._

4.  If the second _CaseClauses_ is not present, return _names_.

5.  Else return the result of appending to _names_ the elements of the
    VarDeclaredNames of the second _CaseClauses_.

_CaseClauses_ : _CaseClauses_ _CaseClause

1.  Let _names_ be VarDeclaredNames of _CaseClauses_.

2.  Append to _names_ the elements of the VarDeclaredNames of
    _CaseClause._

3.  Return _names_.

_CaseClause_ : CASE _Expression_ : _StatementList_~opt~

1.  If the _StatementList_ is present, return the VarDeclaredNames of
    _StatementList_.

2.  Else return a new empty List.

_DefaultClause_ : DEFAULT : _StatementList_~opt~

1.  If the _StatementList_ is present, return the VarDeclaredNames of
    _StatementList_.

2.  Else return a new empty List.

Static Semantics: VarScopedDeclarations

See also: 13.0.2, 13.1.9, 13.2.2.3, 13.5.3, 13.6.1.2, 13.6.2.2,
13.6.3.3, 13.6.4.4, 13.10.3, 13.12.11, 13.14.3, 14.1.18, 14.2.14,
15.1.6, 15.2.0.14.

_SwitchStatement_ : SWITCH ( _Expression_ ) _CaseBlock

1.  Return the VarScopedDeclarations of _CaseBlock_.

_CaseBlock_ : { }

1.  Return a new empty List.

_CaseBlock_ : { _CaseClauses_~opt~ _DefaultClause_ _CaseClauses_~opt~ }

1.  If the first _CaseClauses_ is present, let _declarations_ be the
    VarScopedDeclarations of the first _CaseClauses_.

2.  Else let _declarations_ be a new empty List.

3.  Append to _declarations_ the elements of the VarScopedDeclarations
    of the _DefaultClause._

4.  If the second _CaseClauses_ is not present, return _declarations_.

5.  Else return the result of appending to _declarations_ the elements
    of the VarScopedDeclarations of the second _CaseClauses_.

_CaseClauses_ : _CaseClauses_ _CaseClause

1.  Let _declarations_ be VarScopedDeclarations of _CaseClauses_.

2.  Append to _declarations_ the elements of the VarScopedDeclarations
    of _CaseClause._

3.  Return _declarations_.

_CaseClause_ : CASE _Expression_ : _StatementList_~opt~

1.  If the _StatementList_ is present, return the VarScopedDeclarations
    of _StatementList_.

2.  Else return a new empty List.

_DefaultClause_ : DEFAULT : _StatementList_~opt~

1.  If the _StatementList_ is present, return the VarScopedDeclarations
    of _StatementList_.

2.  Else return a new empty List.

Runtime Semantics: CaseBlockEvaluation

  With argument _input_.

_CaseBlock_ : { }

1.  Return NormalCompletion(UNDEFINED).

_CaseBlock_ : { _CaseClauses_ }

1.  Let _V_ = UNDEFINED.

2.  Let _A_ be the List of _CaseClause_ items in _CaseClauses_, in
    source text order.

3.  Let _searching_ be TRUE.

4.  Repeat, for each _CaseClause_, _C_, in _A

    a.  If _searching_ is TRUE, then

        i.  Let _clauseSelector_ be the result of CaseSelectorEvaluation
            of _C_.

        ii. ReturnIfAbrupt(_clauseSelector_).

        iii. Let _matched_ be the result of performing Strict Equality
            Comparison _input_ === _clauseSelector_.

        iv. If _matched_ is TRUE, then

            1.  Set _searching_ to FALSE.

            2.  If _C_ has a _StatementList_, then

                a.  Let _V_ be the result of evaluating _C_’s
                    _StatementList_.

                b.  ReturnIfAbrupt(_V_).

    b.  Else _searching_ is FALSE,

    c.  i.  If _C_ has a _StatementList_, then

            1.  Let _R_ be the result of evaluating _C_’s
                _StatementList_.

            2.  If _R_.[[value]] is not empty, then let _V_ =
                _R_.[[value]].

            3.  If _R_ is an abrupt completion, then return
                Completion{[[type]]: _R_.[[type]], [[value]]: _V_,
                [[target]]: _R_.[[target]]}.

5.  Return NormalCompletion(_V_).

_CaseBlock_ : { _CaseClauses_~opt~ _DefaultClause_ _CaseClauses_~opt~ }

1.  Let _V_ = UNDEFINED.

2.  Let _A_ be the list of _CaseClause_ items in the first
    _CaseClauses_, in source text order.

3.  Let _found_ be FALSE.

4.  Repeat letting _C_ be in order each _CaseClause_ in _A

    a.  If _found_ is FALSE, then

        i.  Let _clauseSelector_ be the result of CaseSelectorEvaluation
            of _C_.

        ii. If _clauseSelector_ is an abrupt completion, then

            1.  If _clauseSelector_.[[value]] is empty, then return
                Completion{[[type]]: _clauseSelector_.[[type]],
                [[value]]: UNDEFINED, [[target]]:
                _clauseSelector_.[[target]]}.

            2.  Else, return _clauseSelector_.

        iii. Let _found_ be the result of performing Strict Equality
            Comparison _input_ === _clauseSelector_.

    b.  If _found_ is TRUE, then

        i.  Let _R_ be the result of evaluating _CaseClause_ _C_.

        ii. If _R_.[[value]] is not empty, then let _V_ = _R_.[[value]].

        iii. If _R_ is an abrupt completion, then return
            Completion{[[type]]: _R_.[[type]], [[value]]: _V_,
            [[target]]: _R_.[[target]]}.

5.  Let _foundInB_ be FALSE.

6.  If _found_ is FALSE, then

    a.  Let _B_ be a new List containing the _CaseClause_ items in the
        second _CaseClauses_, in source text order.

    b.  Repeat, letting _C_ be in order each _CaseClause_ in _B_

        i.  If _foundInB_ is FALSE, then

            1.  Let _clauseSelector_ be the result of
                CaseSelectorEvaluation of _C_.

            2.  If _clauseSelector_ is an abrupt completion, then

                a.  If _clauseSelector_.[[value]] is empty, then return
                    Completion{[[type]]: _clauseSelector_.[[type]],
                    [[value]]: UNDEFINED, [[target]]:
                    _clauseSelector_.[[target]]}.

                b.  Else, return _clauseSelector_.

            3.  Let _foundInB_ be the result of performing Strict
                Equality Comparison _input_ === _clauseSelector_.

        ii. If _foundInB_ is TRUE, then

            1.  Let _R_ be the result of evaluating _CaseClause C_.

            2.  If _R_.[[value]] is not empty, then let _V_ =
                _R_.[[value]].

            3.  If _R_ is an abrupt completion, then return
                Completion{[[type]]: _R_.[[type]], [[value]]: _V_,
                [[target]]: _R_.[[target]]}.

7.  If _foundInB_ is TRUE, then return NormalCompletion(_V_).

8.  Let _R_ be the result of evaluating _DefaultClause_.

9.  If _R_.[[value]] is not empty, then let _V_ = _R_.[[value]].

10. If _R_ is an abrupt completion, then return Completion{[[type]]:
    _R_.[[type]], [[value]]: _V_, [[target]]: _R_.[[target]]}.

11. Let _B_ be a new List containing the _CaseClause_ items in the
    second _CaseClauses_, in source text order.

12. Repeat, letting _C_ be in order each _CaseClause_ in _B_ (NOTE this
    is another complete iteration of the second _CaseClauses_)

    a.  Let _R_ be the result of evaluating _CaseClause_ _C_.

    b.  If _R_.[[value]] is not empty, then let _V_ = _R_.[[value]].

    c.  If _R_ is an abrupt completion, then return Completion{[[type]]:
        _R_.[[type]], [[value]]: _V_, [[target]]: _R_.[[target]]}.

13. Return NormalCompletion(_V_).

Runtime Semantics: CaseSelectorEvaluation

_CaseClause_ : CASE _Expression_ : _StatementList_~opt~

1.  Let _exprRef_ be the result of evaluating _Expression_.

2.  Return GetValue(_exprRef_).

NOTE CaseSelectorEvaluation does not execute the associated
_StatementList_. It simply evaluates the _Expression_ and returns the
value, which the _CaseBlock_ algorithm uses to determine which
_StatementList_ to start executing.

Runtime Semantics: Evaluation

_SwitchStatement_ : SWITCH ( _Expression_ ) _CaseBlock

1.  Let _exprRef_ be the result of evaluating _Expression_.

2.  Let _switchValue_ be GetValue(_exprRef_).

3.  ReturnIfAbrupt(_switchValue_).

4.  Let _oldEnv_ be the running execution context’s LexicalEnvironment.

5.  Let _blockEnv_ be NewDeclarativeEnvironment(_oldEnv_).

6.  Perform BlockDeclarationInstantiation(_CaseBlock_, _blockEnv_).

7.  Let _R_ be the result of performing CaseBlockEvaluation of
    _CaseBlock_ with argument _switchValue_.

8.  Set the running execution context’s LexicalEnvironment to _oldEnv_.

9.  Return _R_.

NOTE No matter how control leaves the _SwitchStatement_ the
LexicalEnvironment is always restored to its former state.

_CaseClause_ : CASE _Expression_ :

1.  Return NormalCompletion(empty).

_CaseClause_ : CASE _Expression_ : _StatementList

1.  Return the result of evaluating _StatementList_.

_DefaultClause_ : DEFAULT :

1.  Return NormalCompletion(empty).

_DefaultClause_ : DEFAULT : _StatementList

1.  Return the result of evaluating _StatementList_.


Labelled Statements

Syntax

LabelledStatement~[Yield,\ Return]~ :

LabelIdentifier~[?Yield]~ : LabelledItem~[?Yield,\ ?Return]~

LabelledItem~[Yield,\ Return]~ :

Statement~[?Yield,\ ?Return]
~_FunctionDeclaration_~[?Yield]~

NOTE A _Statement_ may be prefixed by a label. Labelled statements are
only used in conjunction with labelled BREAK and CONTINUE statements.
ECMAScript has no GOTO statement. A _Statement_ can be part of a
_LabelledStatement_, which itself can be part of a _LabelledStatement_,
and so on. The labels introduced this way are collectively referred to
as the “current label set” when describing the semantics of individual
statements. A _LabelledStatement_ has no semantic meaning other than the
introduction of a label to a _label set_.

Static Semantics: Early Errors

_LabelledStatement_ : _LabelIdentifier_ : _LabelledItem

-   It is a Syntax Error if the immediately enclosing CurrentLabelSet
    contains the StringValue of _LabelIdentifier_.

_LabelledItem_ : _FunctionDeclaration

-   It is a Syntax Error if any source code matches this rule.

NOTE An alternative definition for this rule is provided in B.3.2.

Static Semantics: CurrentLabelSet

_LabelledStatement_ : _LabelIdentifier_ : _LabelledItem

1.  The CurrentLabelSet of this _LabelledStatement_ is a List that
    includes the StringValue of _LabelIdentifier_ and all elements of
    the immediately enclosing CurrentLabelSet.

Static Semantics: IsLabelledFunction ( stmt )

The abstract operation IsLabelledFunction with argument _stmt_ performs
the following steps:

1.  If _stmt_ is not a a _LabelledStatement_, then return FALSE.

2.  Let _item_ be the _LabelledItem_ compoenent of _stmt_.

3.  If _item_ is _LabeledItem_ : _FunctionDeclaration_, then return
    TRUE.

4.  Let _subStmt_ be the _Statement_ component of _stmt_.

5.  Return IsLabelledFunction(_subStmt_).

Static Semantics: LexicallyDeclaredNames

See also: 13.1.2, 13.11.2, 14.1.14, 14.2.10, 15.1.3, 15.2.0.10.

_LabelledStatement_ : _LabelIdentifier_ : _LabelledItem

1.  Return the LexicallyDeclaredNames of _LabelledItem_.

_LabelledItem_ : _Statement

1.  Return a new empty List.

_LabelledItem_ : _FunctionDeclaration

1.  Return LexicallyDeclaredNames of _FunctionDeclaration_.

Static Semantics: LexicallyScopedDeclarations

See also: 13.1.3, 13.11.3, 14.1.15, 14.2.11, 15.1.4, 15.2.0.11.

_LabelledStatement_ : _LabelIdentifier_ : _LabelledItem

1.  Return the LexicallyScopedDeclarations of _LabelledItem_.

_LabelledItem_ : _Statement

1.  Return a new empty List.

_LabelledItem_ : _FunctionDeclaration

1.  Return a new List containing _FunctionDeclaration_.

Static Semantics: TopLevelLexicallyDeclaredNames

See also: 13.1.4.

_LabelledStatement_ : _LabelIdentifier_ : _LabelledItem

1.  Return a new empty List.

Static Semantics: TopLevelLexicallyScopedDeclarations

See also: 13.1.5.

_LabelledStatement_ : _LabelIdentifier_ : _LabelledItem

1.  Return a new empty List.

Static Semantics: TopLevelVarDeclaredNames

See also: 13.1.6.

_LabelledStatement_ : _LabelIdentifier_ : _LabelledItem

1.  Return the TopLevelVarDeclaredNames of _LabelledItem_.

_LabelledItem_ : _Statement

1.  If _Statement_ is _Statement_ : _LabelledStatement_, then
    TopLevelVarDeclaredNames of _Statement_.

2.  Return VarDeclaredNames of _Statement_.

_LabelledItem_ : _FunctionDeclaration

1.  Return LexicallyDeclaredNames of _FunctionDeclaration_.

Static Semantics: TopLevelVarScopedDeclarations

See also: 13.1.7.

_LabelledStatement_ : _LabelIdentifier_ : _LabelledItem

1.  Return the TopLevelVarScopedDeclarations of _LabelledItem_.

_LabelledItem_ : _Statement

1.  If _Statement_ is _Statement_ : _LabelledStatement_, then
    TopLevelVarScopedDeclarations of _Statement_.

2.  Return VarScopedDeclarations of _Statement_.

_LabelledItem_ : _FunctionDeclaration

1.  Return a new List containing _FunctionDeclaration_.

Static Semantics: VarDeclaredNames

See also: 13.0.1, 13.1.8, 13.2.2.2, 13.5.2, 13.6.1.1, 13.6.2.1,
13.6.3.1, 13.6.4.3, , 13.11.4, 13.14.2, 14.1.17, 14.2.13, 15.1.5,
15.2.0.13.

_LabelledStatement_ : _LabelIdentifier_ : _LabelledItem

1.  Return the VarDeclaredNames of _LabelledItem_.

_LabelledItem_ : _FunctionDeclaration

1.  Return a new empty List.

Static Semantics: VarScopedDeclarations

See also: 13.0.2, 13.1.9, 13.2.2.3, 13.5.3, 13.6.1.2, 13.6.2.2,
13.6.3.3, 13.6.4.4, 13.10.3, 13.11.5, 13.14.3, 14.1.18, 14.2.14, 15.1.6,
15.2.0.14.

_LabelledStatement_ : _LabelIdentifier_ : _LabelledItem

1.  Return the VarScopedDeclarations of _LabelledItem_.

_LabelledItem_ : _FunctionDeclaration

1.  Return a new empty List.

Runtime Semantics: LabelledEvaluation

  With argument _labelSet_.

See also: 13.0.2, 13.6.1.2, 13.6.2.2, 13.6.3.3, 13.6.4.6.

_LabelledStatement_ : _LabelIdentifier_ : _LabelledItem

1.  Let _label_ be the StringValue of _LabelIdentifier_.

2.  Let _newLabelSet_ be a new List containing _label_ and the elements
    of _labelSet_.

3.  Return the result of performing LabelledEvaluation of
    _LabbelledItem_ with argument _newLabelSet_.

    1.  

_LabelledItem_: _Statement

1.  2.  If _stmt_ is either a _LabelledStatement_ or a
    _BreakableStatement_, then

    a.  Let _stmtResult_ be the result of performing LabelledEvaluation
        of _stmt_ with argument _labelSet_.

3.  Else,

    a.  Let _stmtResult_ be the result of evaluating _stmt_.

4.  If _stmtResult_.[[type]] is break and
    SameValue(_stmtResult_.[[target]], _label_), then

    a.  Let _result_ be NormalCompletion(_stmtResult_.[[value]]).

5.  Else,

    a.  Let _result_ be _stmtResult_.

6.  Return _result_.

_LabelledItem_: _FunctionDeclaration

1.  Return the result of evaluating _FunctionDeclaration_.

Runtime Semantics: Evaluation

_LabelledStatement_ : _LabelIdentifier_ : _LabelledItem

1.  Let _newLabelSet_ be a new empty List.

2.  Return the result of performing LabelledEvaluation of
    _LabelledItem_with argument _newLabelSet_.


The throw Statement

Syntax

ThrowStatement~[Yield]~ :

THROW [no LineTerminator here] Expression~[In,\ ?Yield]~ ;

Runtime Semantics: Evaluation

_ThrowStatement_ : THROW _Expression_ ;

1.  Let _exprRef_ be the result of evaluating _Expression_.

2.  Let _exprValue_ be GetValue(_exprRef_).

3.  ReturnIfAbrupt(_exprValue_).

4.  Return Completion{[[type]]: throw, [[value]]: _exprValue_,
    [[target]]: empty}.


The try Statement

Syntax

TryStatement~[Yield,\ Return]~ :

TRY Block~[?Yield,\ ?Return]~ Catch~[?Yield,\ ?Return]
~TRY Block~[?Yield,\ ?Return]~ Finally~[?Yield,\ ?Return]
~TRY Block~[?Yield,\ ?Return]~ Catch~[?Yield,\ ?Return]~
Finally~[?Yield,\ ?Return]~

Catch~[Yield,\ Return]~ :

CATCH ( CatchParameter~[?Yield]~ ) Block~[?Yield,\ ?Return]~

Finally~[Yield,\ Return]~ :

FINALLY Block~[?Yield,\ ?Return]~

CatchParameter~[Yield]~ :

BindingIdentifier~[?Yield]
~BindingPattern~[?Yield]~

NOTE The TRY statement encloses a block of code in which an exceptional
condition can occur, such as a runtime error or a THROW statement. The
CATCH clause provides the exception-handling code. When a catch clause
catches an exception, its _CatchParameter_ is bound to that exception.

Static Semantics: Early Errors

_Catch_ : CATCH ( _CatchParameter_ ) _Block

-   It is a Syntax Error if any element of the BoundNames of
    _CatchParameter_ also occurs in the LexicallyDeclaredNames of
    _Block_.

-   It is a Syntax Error if any element of the BoundNames of
    _CatchParameter_ also occurs in the VarDeclaredNames of _Block_.

NOTE An alternative static semantics for this production is given in
B.3.5.

Static Semantics: VarDeclaredNames

See also: 13.0.1, 13.1.8, 13.2.2.2, 13.5.2, 13.6.1.1, 13.6.2.1,
13.6.3.1, 13.6.4.3, , 13.11.4, 13.12.10, 14.1.17, 14.2.13, 15.1.5,
15.2.0.13.

_TryStatement_ : TRY _Block_ _Catch

1.  Let _names_ be VarDeclaredNames of _Block_.

2.  Append to _names_ the elements of the VarDeclaredNames of _Catch.

3.  Return _names_.

_TryStatement_ : TRY _Block_ _Finally

1.  Let _names_ be VarDeclaredNames of _Block_.

2.  Append to _names_ the elements of the VarDeclaredNames of _Finally.

3.  Return _names_.

_TryStatement_ : TRY _Block_ _Catch_ _Finally

1.  Let _names_ be VarDeclaredNames of _Block_.

2.  Append to _names_ the elements of the VarDeclaredNames of _Catch.

3.  Append to _names_ the elements of the VarDeclaredNames of _Finally.

4.  Return _names_.

_Catch_ : CATCH ( _CatchParameter_ ) _Block

1.  Return the VarDeclaredNames of _Block_.

Static Semantics: VarScopedDeclarations

See also: 13.0.2, 13.1.9, 13.2.2.3, 13.5.3, 13.6.1.2, 13.6.2.2,
13.6.3.3, 13.6.4.4, 13.10.3, 13.11.5, 13.12.11, 14.1.18, 14.2.14,
15.1.6, 15.2.0.14.

_TryStatement_ : TRY _Block_ _Catch

1.  Let _declarations_ be VarScopedDeclarations of _Block_.

2.  Append to _declarations_ the elements of the VarScopedDeclarations
    of _Catch._

3.  Return _declarations_.

_TryStatement_ : TRY _Block_ _Finally

1.  Let _declarations_ be VarScopedDeclarations of _Block_.

2.  Append to _declarations_ the elements of the VarScopedDeclarations
    of _Finally._

3.  Return _declarations_.

_TryStatement_ : TRY _Block_ _Catch_ _Finally

1.  Let _declarations_ be VarScopedDeclarations of _Block_.

2.  Append to _declarations_ the elements of the VarScopedDeclarations
    of _Catch._

3.  Append to _declarations_ the elements of the VarScopedDeclarations
    of _Finally._

4.  Return _declarations_.

_Catch_ : CATCH ( _CatchParameter_ ) _Block

1.  Return the VarScopedDeclarations of _Block_.

Runtime Semantics: BindingInitialization

  With arguments _value_ and _environment_.

NOTE UNDEFINED is passed for _environment_ to indicate that a PutValue
operation should be used to assign the initialization value. This is the
case for VAR statements and the formal parameter lists of some
non-strict functions (see 9.2.13). In those cases a lexical binding is
hoisted and preinitialized prior to evaluation of its initializer.

See also: 12.1.4, 12.2.4.2.2, 13.2.2.4, 13.2.3.5.

_CatchParameter_: _BindingPattern

1.  If Type(_value_) is not Object, then throw a TYPEERROR exception.

2.  Return the result of performing BindingInitialization for
    _BindingPattern_ passing _value_ and _environment_ as the arguments.

Runtime Semantics: CatchClauseEvaluation

with parameter _thrownValue_

_Catch_ : CATCH ( _CatchParameter_ ) _Block

1.  Let _oldEnv_ be the running execution context’s LexicalEnvironment.

2.  Let _catchEnv_ be NewDeclarativeEnvironment(_oldEnv_).

3.  For each element _argName_ of the BoundNames of _CatchParameter_, do

    a.  Call the CreateMutableBinding concrete method of _catchEnv_
        passing _argName_ as the argument.

    b.  Assert: The above call to CreateMutableBinding will never return
        an abrupt completion.

4.  Let _status_ be the result of performing BindingInitialization for
    _CatchParameter_ passing _thrownValue_ and _catchEnv_ as arguments.

5.  ReturnIfAbrupt(_status_).

6.  Set the running execution context’s LexicalEnvironment to
    _catchEnv_.

7.  Let _B_ be the result of evaluating _Block_.

8.  Set the running execution context’s LexicalEnvironment to _oldEnv_.

9.  Return _B_.

NOTE No matter how control leaves the _Block_ the LexicalEnvironment is
always restored to its former state.

Runtime Semantics: Evaluation

_TryStatement_ : TRY _Block_ _Catch

1.  Let _B_ be the result of evaluating _Block_.

2.  If _B_.[[type]] is not throw, return _B_.

3.  Return the result of performing CatchClauseEvaluation of _Catch
    with parameter _B_.[[value]].

_TryStatement_ : TRY _Block_ _Finally

1.  Let _B_ be the result of evaluating _Block_.

2.  Let _F_ be the result of evaluating _Finally_.

3.  If _F_.[[type]] is normal, return _B_.

4.  Return _F_.

_TryStatement_ : TRY _Block Catch Finally

1.  Let _B_ be the result of evaluating _Block_.

2.  If _B_.[[type]] is throw, then

    a.  Let _C_ be the result of performing CatchClauseEvaluation of
        _Catch_ with parameter _B_.[[value]].

3.  Else _B_.[[type]] is not throw,

    a.  Let _C_ be _B_.

4.  Let _F_ be the result of evaluating _Finally_.

5.  If _F_.[[type]] is normal, return _C_.

6.  Return _F_.


The debugger statement

Syntax

DebuggerStatement :

DEBUGGER ;

Runtime Semantics: Evaluation

NOTE Evaluating the _DebuggerStatement_ production may allow an
implementation to cause a breakpoint when run under a debugger. If a
debugger is not present or active this statement has no observable
effect.

_DebuggerStatement_ : DEBUGGER ;

1.  If an implementation defined debugging facility is available and
    enabled, then

    a.  Perform an implementation defined debugging action.

    b.  Let _result_ be an implementation defined Completion value.

2.  Else

    a.  Let _result_ be NormalCompletion(empty).

3.  Return _result.



ECMASCRIPT LANGUAGE: FUNCTIONS AND CLASSES 


NOTE Various ECMAScript language elements cause the creation of
ECMAScript function objects (9.1.14). Evaluation of such functions
starts with the execution of their [[Call]] internal method (9.2.2).


Function Definitions

Syntax

FunctionDeclaration~[Yield,\ Default]~ :

FUNCTION BindingIdentifier~[?Yield,\ ?Default]~ ( FormalParameters ) {
FunctionBody }

FunctionExpression :

FUNCTION BindingIdentifier~opt~ ( FormalParameters ) { FunctionBody }

StrictFormalParameters~[Yield,\ GeneratorParameter]~ :

FormalParameters~[?Yield,\ ?GeneratorParameter]~

FormalParameters~[Yield,GeneratorParameter]~ :

[empty]
FormalParameterList~[?Yield,\ ?GeneratorParameter]~

FormalParameterList~[Yield,GeneratorParameter]~ :

FunctionRestParameter~[?Yield]~
FormalsList~[?Yield,\ ?GeneratorParameter]~
FormalsList~[?Yield,\ ?GeneratorParameter]~,
FunctionRestParameter~[?Yield]~

FormalsList~[Yield,GeneratorParameter]~ :

FormalParameter~[?Yield,\ ?GeneratorParameter]~
FormalsList~[?Yield,\ ?GeneratorParameter]~ ,
FormalParameter~[?Yield,?GeneratorParameter]~

FunctionRestParameter~[Yield]~ :

BindingRestElement~[?Yield]~

FormalParameter~[Yield,GeneratorParameter]~ :

BindingElement~[?Yield,\ ?GeneratorParameter]~

FunctionBody~[Yield]~ :

FunctionStatementList~[?Yield]~

FunctionStatementList~[Yield]~ :

StatementList~[?Yield,\ Return]opt~

Directive Prologues and the Use Strict Directive

A Directive Prologue is the longest sequence of _ExpressionStatement_
productions occurring as the initial _StatementListItem_ productions of
a _FunctionBody_ or a _ScriptBody_ and where each _ExpressionStatement_
in the sequence consists entirely of a _StringLiteral_ token followed by
a semicolon. The semicolon may appear explicitly or may be inserted by
automatic semicolon insertion. A Directive Prologue may be an empty
sequence.

A Use Strict Directive is an _ExpressionStatement_ in a Directive
Prologue whose _StringLiteral_ is either the exact code unit sequences
"USE STRICT" or 'USE STRICT'. A Use Strict Directive may not contain an
_EscapeSequence_ or _LineContinuation_.

A Directive Prologue may contain more than one Use Strict Directive.
However, an implementation may issue a warning if this occurs.

NOTE The _ExpressionStatement_ productions of a Directive Prologue are
evaluated normally during evaluation of the containing production.
Implementations may define implementation specific meanings for
_ExpressionStatement_ productions which are not a Use Strict Directive
and which occur in a Directive Prologue. If an appropriate notification
mechanism exists, an implementation should issue a warning if it
encounters in a Directive Prologue an _ExpressionStatement_ that is not
a Use Strict Directive and which does not have a meaning defined by the
implementation.

Static Semantics: Early Errors

_FunctionDeclaration_ : FUNCTION _BindingIdentifier_ (
_FormalParameters_ ) { _FunctionBody_ }
and
_FunctionExpression_ : FUNCTION _BindingIdentifier_~opt~ (
_FormalParameters_ ) { _FunctionBody_ }

-   If the source code matching this production is strict code, the
    Early Error rules for _StrictFormalParameters_ : _FormalParameters_
    are applied.

-   If the source code matching this production is strict code, it is a
    Syntax Error if _BindingIdentifier_ is the the _IdentifierName_ EVAL
    or the _IdentifierName_ ARGUMENTS.

-   -   It is a Syntax Error if any element of the BoundNames of
    _FormalParameters_ also occurs in the LexicallyDeclaredNames of
    _FunctionBody_.

NOTE The LexicallyDeclaredNames of a _FunctionBody_ does not include
identifiers bound using var or function declarations.

_StrictFormalParameters_ : _FormalParameters

-   It is a Syntax Error if BoundNames of _FormalParameters_ contains
    any duplicate elements.

_FormalParameters_ : _FormalParameterList

-   It is a Syntax Error if IsSimpleParameterList of
    _FormalParameterList_ is FALSE and BoundNames of
    _FormalParameterList_ contains any duplicate elements.

NOTE Multiple occurrences of the same _Identifier_ in a
_FormalParamterList_ is only allowed for non-strict functions and
generator functions that have simple parameter lists.

_FunctionBody_ : _FunctionStatementList

-   It is a Syntax Error if the LexicallyDeclaredNames of
    _FunctionStatementList_ contains any duplicate entries.

-   It is a Syntax Error if any element of the LexicallyDeclaredNames of
    _FunctionStatementList_ also occurs in the VarDeclaredNames of
    _FunctionStatementList_.

Static Semantics: BoundNames

See also: 13.2.1.2, 13.2.2.1, 12.1.2, 13.6.4.2, 14.2.2, 14.4.2, 14.5.2,
15.2.1.2, 15.2.2.1.

_FunctionDeclaration_ : FUNCTION _BindingIdentifier_ (
_FormalParameters_ ) { _FunctionBody_ }

1.  Return the BoundNames of _BindingIdentifier_.

FormalParameters : [empty]

1.  Return an empty List.

FormalParameterList : FormalsList , FunctionRestParameter

1.  Let _names_ be BoundNames of _FormalsList_.

2.  Append to _names_ the BoundNames of _FunctionRestParameter.

3.  Return _names_.

_FormalsList_ : _FormalsList ,_ _FormalParameter

1.  Let _names_ be BoundNames of _FormalsList_.

2.  Append to _names_ the elements of BoundNames of _FormalParameter.

3.  Return _names_.

Static Semantics: Contains

  With parameter _symbol_.

See also: 5.3, 12.2.5.2, 12.3.1.1, 14.2.3, 14.4.3, 14.5.4

_FunctionDeclaration_ : FUNCTION _BindingIdentifier_ (
_FormalParameters_ ) { _FunctionBody_ }

1.  Return FALSE.

_FunctionExpression_ : FUNCTION _BindingIdentifier_~opt~ (
_FormalParameters_ ) { _FunctionBody_ }

1.  Return FALSE.

NOTE Static semantic rules that depend upon substructure generally do
not look into function definitions.

Static Semantics: ContainsExpression

See also: 13.2.3.2, 14.2.4.

FormalParameters : [empty]

1.  Return FALSE.

FormalParameterList : FunctionRestParameter

1.  Return FALSE.

FormalParameterList : FormalsList , FunctionRestParameter

1.  Return ContainsExpression of _FormalsList_.

_FormalsList_ : _FormalsList ,_ _FormalParameter

1.  If ContainsExpression of _FormalsList_ is TRUE, then return TRUE.

2.  Return ContainsExpression of _FormalParameter_.

Static Semantics: ExpectedArgumentCount

See also: 14.2.6, 14.3.2.

FormalParameters : [empty]

1.  Return 0.

FormalParameterList : FunctionRestParameter

1.  Return 0.

FormalParameterList : FormalsList , FunctionRestParameter

1.  Return the ExpectedArgumentCount of _FormalsList_.

NOTE The ExpectedArgumentCount of a _FormalParameterList_ is the number
of _FormalParameters_ to the left of either the rest parameter or the
first _FormalParameter_ with an Initializer. A _FormalParameter_ without
an initializer is allowed after the first parameter with an initializer
but such parameters are considered to be optional with UNDEFINED as
their default value.

_FormalsList_ : _FormalParameter

1.  If HasInitializer of _FormalParameter_ is TRUE return 

2.  Return 1.

_FormalsList_ : _FormalsList,_ _FormalParameter

1.  Let _count_ be the ExpectedArgumentCount of _FormalsList.

2.  If HasInitializer of _FormalsList_ is TRUE or HasInitializer of
    _FormalParameter_ is TRUE, then return _count_.

3.  Return _count_+1.

Static Semantics: HasInitializer

See also: 13.2.3.3, 14.2.7.

_FormalParameters_ : [empty]

1.  Return FALSE.

_FormalParameterList_ : _FunctionRestParameter

1.  Return FALSE.

_FormalParameterList_ : _FormalsList_ , _FunctionRestParameter

1.  If HasInitializer of _FormalsList_ is TRUE, then return TRUE.

2.  Return FALSE.

_FormalsList_ : _FormalsList ,_ _FormalParameter

1.  If HasInitializer of _FormalsList_ is TRUE, then return TRUE.

2.  Return HasInitializer of _FormalParameter_.

Static Semantics: HasName

See also: 14.2.8, 14.4.6, 14.5.6.

_FunctionExpression_ : FUNCTION ( _FormalParameters_ ) { _FunctionBody
}

1.  Return FALSE.

_FunctionExpression_ : FUNCTION _BindingIdentifier_ ( _FormalParameters
) { _FunctionBody_ }

1.  Return TRUE.

Static Semantics: IsAnonymousFunctionDefinition ( production) Abstract Operation

The abstract operation IsAnonymousFunctionDefinition determines if its
argument is a function definition that does not bind a name. The
argument _production_ is the result of parsing an _AssignmentExpression_
or _Initializer_. The following steps are taken:

1.  If IsFunctionDefinition of _production_ is FALSE, then return FALSE.

2.  Let _hasName_ be the result of HasName of _production_.

3.  If _hasName_ is TRUE, then return FALSE.

4.  Return TRUE.

Static Semantics: IsConstantDeclaration

See also: 13.2.1.3, 14.4.5, 14.5.5.

_FunctionDeclaration_ : FUNCTION _BindingIdentifier_ (
_FormalParameters_ ) { _FunctionBody_ }

1.  Return FALSE.

Static Semantics: IsFunctionDefinition

See also: 12.2.0.2, 12.2.10.2, 12.3.1.2, 12.4.2, 12.5.2, 12.6.1, 12.7.1,
12.8.1, 12.9.1, 12.10.1, 12.11.1, 12.12.1, 12.13.1, 12.14.2, 12.15.1,
14.4.8, 14.5.8.

_FunctionExpression_ : FUNCTION ( _FormalParameters_ ) { _FunctionBody
_}

1.  Return TRUE.

_FunctionExpression_ : FUNCTION _BindingIdentifier_ ( _FormalParameters
) { _FunctionBody_ }

1.  Return TRUE.

Static Semantics: IsSimpleParameterList

See also: 13.2.3.4, 14.2.8

FormalParameters : [empty]

1.  Return TRUE.

FormalParameterList : FunctionRestParameter

1.  Return FALSE.

FormalParameterList : FormalsList , FunctionRestParameter

1.  Return FALSE.

_FormalsList_ : _FormalsList ,_ _FormalParameter

1.  If IsSimpleParameterList of _FormalsList_ is FALSE, return FALSE.

2.  Return IsSimpleParameterList of _FormalParameter_.

_FormalParameter_ : _BindingElement

1.  Return IsSimpleParameterList of _BindingElement_.

Static Semantics: IsStrict

See also: 15.1.2, 15.2.0.7.

_FunctionStatementList_ : _StatementList_~opt~

1.  If this _FunctionStatementList_ is contained in strict code or if
    _StatementList_ is strict code, then return TRUE. Otherwise, return
    FALSE.

Static Semantics: LexicallyDeclaredNames

See also: 13.1.2, 13.11.2, 13.12.4, 14.2.10, 15.1.3, 15.2.0.10.

FunctionStatementList : [empty]

1.  Return an empty List.

FunctionStatementList : StatementList

1.  Return TopLevelLexicallyDeclaredNames of _StatementList_.

Static Semantics: LexicallyScopedDeclarations

See also: 13.1.3, 13.11.3, 13.12.5, 14.2.11, 15.1.4, 15.2.0.11.

FunctionStatementList : [empty]

1.  Return an empty List.

_FunctionStatementList_ : _StatementList

1.  Return the TopLevelLexicallyScopedDeclarations of _StatementList_.

Static Semantics: ReferencesSuper

See also: 14.2.12, 14.3.6, 14.4.10.

_FunctionDeclaration_ : FUNCTION _BindingIdentifier_ (
_FormalParameters_ ) { _FunctionBody_ }

1.  If _FormalParameters_ Contains SUPER is TRUE, then return TRUE.

2.  Return _FunctionBody_ Contains SUPER.

_FunctionExpression_ : FUNCTION _BindingIdentifier_~opt~ (
_FormalParameters_ ) { _FunctionBody_ }

1.  If _FormalParameters_ Contains SUPER is TRUE, then return TRUE.

2.  Return _FunctionBody_ Contains SUPER.

_FormalParameters_ : [empty]

1.  Return FALSE.

_FormalParameters_ : _FormalParameterList

1.  Return _FormalParameterList_ Contains SUPER.

_FunctionBody_ : _FunctionStatementList

1.  Return _FunctionStatementList_ Contains SUPER.

Static Semantics: VarDeclaredNames

See also: 13.0.1, 13.1.8, 13.2.2.2, 13.5.2, 13.6.1.1, 13.6.2.1,
13.6.3.1, 13.6.4.3, , 13.11.4, 13.12.10, 13.14.2, 14.2.13, 15.1.5,
15.2.0.13.

1.  

FunctionStatementList : [empty]

1.  Return an empty List.

FunctionStatementList : StatementList

1.  Return TopLevelVarDeclaredNames of _StatementList_.

Static Semantics: VarScopedDeclarations

See also: 13.0.2, 13.1.9, 13.2.2.3, 13.5.3, 13.6.1.2, 13.6.2.2,
13.6.3.3, 13.6.4.4, 13.10.3, 13.11.5, 13.12.11, 13.14.3, 14.2.14,
15.1.6, 15.2.0.14.

1.  

FunctionStatementList : [empty]

1.  Return an empty List.

_FunctionStatementList_ : _StatementList

1.  Return the TopLevelVarScopedDeclarations of _StatementList_.

Runtime Semantics: EvaluateBody

  With parameter _functionObject_.

See also: 14.2.16, 14.4.11.

_FunctionBody_ : _FunctionStatementList

1.  The code of this _FunctionBody_ is strict mode code if it is
    contained in strict mode code or if the Directive Prologue (14.1.1)
    of its _FunctionStatementList_ contains a Use Strict Directive or if
    any of the conditions in 10.2.1 apply. If the code of this
    _FunctionBody_ is strict mode code, _FunctionStatementList_ is
    evaluated in the following steps as strict mode code. Otherwise,
    _StatementList_ is evaluated in the following steps as non-strict
    mode code.

2.  Let _result_ be the result of evaluating _FunctionStatementList_.

3.  If _result_.[[type]] is return then return
    NormalCompletion(_result_.[[value]])

4.  ReturnIfAbrupt(_result_).

5.  Return NormalCompletion(UNDEFINED).

Runtime Semantics: IteratorBindingInitialization

  With parameters _iterator_ and _environment_.

NOTE When UNDEFINED is passed for _environment_ it indicates that a
PutValue operation should be used to assign the initialization value.
This is the case for formal parameter lists of non-strict functions. In
that case the formal parameter bindings are preinitialized in order to
deal with the possibility of multiple parameters with the same name.

See also: 13.2.3.6, 14.2.15.

FormalParameters : [empty]

1.  Return NormalCompletion(empty).

FormalParameterList : FormalsList , FunctionRestParameter

1.  Let _restIndex_ be the result of performing
    IteratorBindingInitialization for _FormalsList_ using _iterator_,
    and _environment_ as the arguments.

2.  ReturnIfAbrupt(_restIndex_).

3.  Return the result of performing IteratorBindingInitialization for
    _FunctionRestParameter_ using _iterator_ and _environment_ as the
    arguments.

FormalsList : FormalsList , FormalParameter

1.  Let _status_ be the result of performing
    IteratorBindingInitialization for _FormalsList_ using _iterator_ and
    _environment_ as the arguments.

2.  ReturnIfAbrupt(_status_).

3.  Return the result of performing IteratorBindingInitialization for
    _FormalParameter_ using _iterator_ and _environment_ as the
    arguments.

Runtime Semantics: InstantiateFunctionObject

  With parameter _scope_.

See also: 14.4.12.

_FunctionDeclaration_ : FUNCTION _BindingIdentifier_ (
_FormalParameters_ ) { _FunctionBody_ }

1.  If the _FunctionDeclaration_ is contained in strict code or if its
    _FunctionBody_ is strict code, then let _strict_ be TRUE. Otherwise
    let _strict_ be FALSE.

2.  Let _name_ be StringValue of _BindingIdentifier.

3.  Let _F_ be FunctionCreate(Normal, _FormalParameters_, _FunctionBody,
    scope_, _strict_).

4.  If ReferencesSuper of _FunctionDeclaration_ is TRUE, then

    a.  Perform MakeMethod(_F_, _name_, UNDEFINED).

5.  Perform MakeConstructor(_F_).

6.  SetFunctionName(_F_, _name_).

7.  Assert: SetFunctionName will not return an abrupt completion.

8.  Return _F_.

Runtime Semantics: Evaluation

_FunctionDeclaration_ : FUNCTION _BindingIdentifier_ (
_FormalParameters_ ) { _FunctionBody_ }

1.  Return NormalCompletion(empty)

_FunctionExpression_ : FUNCTION ( _FormalParameters_ ) { _FunctionBody
}

1.  If the _FunctionExpression_ is contained in strict code or if its
    _FunctionBody_ is strict code, then let _strict_ be TRUE. Otherwise
    let _strict_ be FALSE.

2.  Let _scope_ be the LexicalEnvironment of the running execution
    context.

3.  Let _closure_ be FunctionCreate(Normal, _FormalParameters_,
    _FunctionBody, scope_, _strict_).

4.  If ReferencesSuper of _FunctionExpression_ is TRUE, then

    a.  Perform MakeMethod(_closure_, UNDEFINED, UNDEFINED).

5.  Perform MakeConstructor(_closure_).

6.  Return _closure_.

_FunctionExpression_ : FUNCTION _BindingIdentifier_ ( _FormalParameters
) { _FunctionBody_ }

1.  If the _FunctionExpression_ is contained in strict code or if its
    _FunctionBody_ is strict code, then let _strict_ be TRUE. Otherwise
    let _strict_ be FALSE.

2.  Let _runningContext_ be the running execution context’s Lexical
    Environment.

3.  Let _funcEnv_ be NewDeclarativeEnvironment(_runningContext_ ).

4.  Let _envRec_ be _funcEnv’s_ environment record.

5.  Let _name_ be StringValue of _BindingIdentifier_.

6.  Call the CreateImmutableBinding concrete method of _envRec_ passing
    _name_ as the argument.

7.  Let _closure_ be FunctionCreate(Normal, _FormalParameters_,
    _FunctionBody, funcEnv_, _strict_).

8.  If ReferencesSuper of _FunctionExpression_ is TRUE, then

    a.  Perform MakeMethod(_closure_, _name_, UNDEFINED).

9.  Perform MakeConstructor(_closure_).

10. SetFunctionName(_closure_, _name_).

11. Assert: SetFunctionName will not return an abrupt completion.

12. Call the InitializeBinding concrete method of _envRec_ passing
    _name_ and _closure_ as the arguments.

13. Return NormalCompletion(_closure_).

NOTE 1 The _BindingIdentifier_ in a _FunctionExpression_ can be
referenced from inside the _FunctionExpression's_ _FunctionBody_ to
allow the function to call itself recursively. However, unlike in a
_FunctionDeclaration_, the _BindingIdentifier_ in a _FunctionExpression
cannot be referenced from and does not affect the scope enclosing the
_FunctionExpression_.

NOTE 2 A PROTOTYPE property is automatically created for every function
defined using a _FunctionDeclaration_ or _FunctionExpression_, to allow
for the possibility that the function will be used as a constructor.

FunctionStatementList : [empty]

1.  Return NormalCompletion(UNDEFINED).


Arrow Function Definitions

Syntax

_ArrowFunction_~[In,\ Yield]~ :

_ArrowParameters_~[?Yield]~ [no LineTerminator here] =>
_ConciseBody_~[?In]~

_ArrowParameters_~[Yield]~ :

_BindingIdentifier_~[?Yield]~
CoverParenthesizedExpressionAndArrowParameterList~[?Yield]~

ConciseBody~[In]~ :

[lookahead ≠ {] AssignmentExpression~[?In]~
{ FunctionBody }

Supplemental Syntax

When the production

_ArrowParameters_~[Yield]~ :
_CoverParenthesizedExpressionAndArrowParameterList_~[?Yield]~

is recognized the following grammar is used to refine the interpretation
of

_CoverParenthesizedExpressionAndArrowParameterList_:

ArrowFormalParameters~[Yield,\ GeneratorParameter]~ :

( StrictFormalParameters~[?Yield,\ ?GeneratorParameter]~ )

Static Semantics: Early Errors

_ArrowFunction_ : _ArrowParameters_ => _ConciseBody

-   

-   It is a Syntax Error if any element of the BoundNames of
    _ArrowParameters_ also occurs in the LexicallyDeclaredNames of
    _ConciseBody_.

_ArrowParameters_~[Yield]~ :
_CoverParenthesizedExpressionAndArrowParameterList_~[?Yield]~

-   If the ~[Yield]~ grammar parameter is present on _ArrowParameters_,
    it is a Syntax Error if the lexical token sequence matched by
    _CoverParenthesizedExpressionAndArrowParameterList_~[?Yield]~ cannot
    be parsed with no tokens left over using
    _ArrowFormalParameters_~[Yield,\ GeneratorParameter]~ as the goal
    symbol.

-   If the ~[Yield]~ grammar parameter is not present on
    _ArrowParameters_, it is a Syntax Error if the lexical token
    sequence matched by
    _CoverParenthesizedExpressionAndArrowParameterList_~[?Yield]~ cannot
    be parsed with no tokens left over using _ArrowFormalParameters_ as
    the goal symbol.

-   All early errors rules for _ArrowFormalParameters_ and its derived
    productions also apply to CoveredFormalsList of
    _CoverParenthesizedExpressionAndArrowParameterList_~[?Yield]~.

Static Semantics: BoundNames

See also: 13.2.1.2, 13.2.2.1, 12.1.2, 13.6.4.2, 14.1.3, 14.4.2, 14.5.2,
15.2.1.2, 15.2.2.1.

_ArrowParameters_~[Yield]~ :
_CoverParenthesizedExpressionAndArrowParameterList_~[?Yield]~

1.  Let _formals_ be CoveredFormalsList of
    _CoverParenthesizedExpressionAndArrowParameterList_~[?Yield]~.

2.  Return the BoundNames of _formals_.

Static Semantics: Contains

  With parameter _symbol_.

See also: 5.3, 12.2.5.2, 12.3.1.1, 14.1.4, 14.4.3, 14.5.4

_ArrowFunction_ : _ArrowParameters_ => _ConciseBody

1.  If _symbol_ is neither SUPER nor THIS, then return FALSE.

2.  If _ArrowParameters_ Contains _symbol_ is TRUE, return TRUE;

3.  Return _ConciseBody_ Contains _symbol_ .

NOTE Normally, Contains does not look inside most function forms
However, Contains is used to detect THIS and SUPER usage within an
_ArrowFunction_.

_ArrowParameters_~[Yield]~ :
_CoverParenthesizedExpressionAndArrowParameterList_~[?Yield]~

1.  Let _formals_ be CoveredFormalsList of
    _CoverParenthesizedExpressionAndArrowParameterList_~[?Yield]~.

2.  Return _formals_ Contains _symbol_.

Static Semantics: ContainsExpression

See also: 13.2.3.2, 14.1.5.

_ArrowParameters_ : _BindingIdentifier

1.  Return FALSE.

_ArrowParameters_~[Yield]~ :
_CoverParenthesizedExpressionAndArrowParameterList_~[?Yield]~

1.  Let _formals_ be CoveredFormalsList of
    _CoverParenthesizedExpressionAndArrowParameterList_~[?Yield]~.

2.  Return the ContainsExpression of _formals_.

Static Semantics: CoveredFormalsList

_ArrowParameters_ : _BindingIdentifier

1.  Return _BindingIdentifier_.

CoverParenthesizedExpressionAndArrowParameterList~[Yield]~:

( Expression )
( )
( ... BindingIdentifier )
( Expression , ... BindingIdentifier )

1.  If the ~[Yield]~ grammar parameter is present for
    _CoverParenthesizedExpressionAndArrowParameterList_~[Yield]~ return
    the result of parsing the lexical token stream matched by
    _CoverParenthesizedExpressionAndArrowParameterList_~[Yield]~ using
    _ArrowFormalParameters_~[Yield,\ GeneratorParameter]~ as the goal
    symbol.

2.  If the ~[Yield]~ grammar parameter is not present for
    _CoverParenthesizedExpressionAndArrowParameterList_~[Yield]~ return
    the result of parsing the lexical token stream matched by
    _CoverParenthesizedExpressionAndArrowParameterList_ using
    _ArrowFormalParameters_ as the goal symbol.

Static Semantics: ExpectedArgumentCount

See also: 14.1.5, 14.3.2.

_ArrowParameters_ : _BindingIdentifier

1.  Return 1.

_ArrowParameters_~[Yield]~ :
_CoverParenthesizedExpressionAndArrowParameterList_~[?Yield]~

1.  Let _formals_ be CoveredFormalsList of
    _CoverParenthesizedExpressionAndArrowParameterList_~[?Yield]~.

2.  Return the ExpectedArgumentCount of _formals_.

Static Semantics: HasInitializer

See also: 13.2.3.3, 14.1.7.

_ArrowParameters_ : _BindingIdentifier

1.  Return FALSE.

_ArrowParameters_ : _CoverParenthesizedExpressionAndArrowParameterList

1.  Let _formals_ be CoveredFormalsList of
    _CoverParenthesizedExpressionAndArrowParameterList_.

2.  Return the HasInitializer of _formals_.

Static Semantics: HasName

See also: 14.1.8, 14.4.6, 14.5.6.

_ArrowFunction_ : _ArrowParameters_ => _ConciseBody

1.  Return FALSE.

Static Semantics: IsSimpleParameterList

See also: 13.2.3.4, 14.1.11.

_ArrowParameters_ : _BindingIdentifier

1.  Return TRUE.

_ArrowParameters_~[Yield]~ :
_CoverParenthesizedExpressionAndArrowParameterList_~[?Yield]~

1.  Let _formals_ be CoveredFormalsList of
    _CoverParenthesizedExpressionAndArrowParameterList_~[?Yield]~.

2.  Return the IsSimpleParameterList of _formals_.

Static Semantics: LexicallyDeclaredNames

See also: 13.1.2, 13.11.2, 13.12.4, 14.1.14, 15.1.3, 15.2.0.10.

_ConciseBody_ : _AssignmentExpression

1.  Return an empty List.

Static Semantics: LexicallyScopedDeclarations

See also: 13.1.3, 13.11.3, 13.12.5, 14.1.15, 15.1.4, 15.2.0.11.

_ConciseBody_ : _AssignmentExpression

1.  Return an empty List.

Static Semantics: ReferencesSuper

See also: 14.1.16, 14.3.6, 14.4.10.

_ArrowFunction_ : _ArrowParameters_ => _ConciseBody

1.  Return FALSE.

NOTE ReferencesSuper is used to determine whether a function requires
its own super bindings. This is never the case for Arrow Functions.

Static Semantics: VarDeclaredNames

See also: 13.0.1, 13.1.8, 13.2.2.2, 13.5.2, 13.6.1.1, 13.6.2.1,
13.6.3.1, 13.6.4.3, , 13.11.4, 13.12.10, 13.14.2, 14.1.17, 15.1.5,
15.2.0.13.

_ConciseBody_ : _AssignmentExpression

1.  Return an empty List.

Static Semantics: VarScopedDeclarations

See also: 13.0.2, 13.1.9, 13.2.2.3, 13.5.3, 13.6.1.2, 13.6.2.2,
13.6.3.3, 13.6.4.4, 13.10.3, 13.11.5, 13.12.11, 13.14.3, 14.1.18,
15.1.6, 15.2.0.14.

_ConciseBody_ : _AssignmentExpression

1.  Return an empty List.

Runtime Semantics: IteratorBindingInitialization

  With parameters _iterator_ and _environment_.

See also: 13.2.3.6, 14.1.20.

NOTE When UNDEFINED is passed for _environment_ it indicates that a
PutValue operation should be used to assign the initialization value.
This is the case for formal parameter lists of non-strict functions. In
that case the formal parameter bindings are preinitialized in order to
deal with the possibility of multiple parameters with the same name.

_ArrowParameters_ : _BindingIdentifier

1.  Let _next_ be IteratorStep(_iterator_).

2.  ReturnIfAbrupt(_next_).

3.  If _next_ is FALSE, then let _v_ be UNDEFINED

4.  Else

    a.  Let _v_ be IteratorValue(_next_).

    b.  ReturnIfAbrupt(_v_).

5.  Return the result of performing BindingInitialization for
    _BindingIdentifier_ using _v_ and _environment_ as the arguments.

_ArrowParameters_~[Yield]~ :
_CoverParenthesizedExpressionAndArrowParameterList_~[?Yield]~

1.  Let _formals_ be CoveredFormalsList of
    _CoverParenthesizedExpressionAndArrowParameterList_~[?Yield]~.

2.  Return the result of performing IteratorBindingInitialization of
    _formals_ with arguments _iterator_ and _environment_.

Runtime Semantics: EvaluateBody

  With parameter _functionObject_.

See also: 14.1.19, 14.4.11.

_ConciseBody_ : _AssignmentExpression

1.  The code of this _ConciseBody_ is strict mode code if it is
    contained in strict mode code or if any of the conditions in 10.2.1
    apply. If the code of this _ConciseBody_ is strict mode code,
    _AssignmentExpression_ is evaluated in the following steps as strict
    mode code. Otherwise, _AssignmentExpression_ is evaluated in the
    following steps as non-strict mode code.

2.  Let _exprRef_ be the result of evaluating _AssignmentExpression_.

3.  Let _exprValue_ be GetValue(_exprRef_).

4.  If _exprValue_.[[type]] is return then return
    NormalCompletion(_exprValue_.[[value]]).

5.  ReturnIfAbrupt(_exprValue_).

6.  Return NormalCompletion(_exprValue_).

NOTE In the absence of extensions to this specification, the test in
step 4 will never be TRUE.

Runtime Semantics: Evaluation

_ArrowFunction_~[Yield]~ : _ArrowParameters_~[?Yield]~ => _ConciseBody

1.  If the code of this _ArrowFunction_ is contained in strict mode code
    or if any of the conditions in 10.2.1 apply, then let _strict_ be
    TRUE. Otherwise let _strict_ be FALSE.

2.  Let _scope_ be the LexicalEnvironment of the running execution
    context.

3.  Let _parameters_ be CoveredFormalsList of
    _ArrowParameters_~[?Yield]~.

4.  Let _closure_ be FunctionCreate(Arrow, _parameters_, _ConciseBody,
    scope_, _strict_).

5.  Return _closure_.

NOTE Any reference to ARGUMENTS, SUPER, or THIS within an
_ArrowFunction_ are resoved to their bindings in the lexically enclosing
function. Even though an _ArrowFunction_ may contain references to
SUPER, the function object created in step 4 is not made into a method
by performing MakeMethod. An _ArrowFunction_ that references SUPER is
always contained within a non-_ArrowFunction_ and the necessary state to
implement SUPER is accessible via the _scope_ that is captured by the
function object of the _ArrowFunction_.


Method Definitions

Syntax

MethodDefinition~[Yield]~ :

PropertyName~[?Yield]~ ( StrictFormalParameters ) { FunctionBody }
GeneratorMethod~[?Yield]~
GET PropertyName~[?Yield]~ ( ) { FunctionBody }
SET PropertyName~[?Yield]~ ( PropertySetParameterList ) { FunctionBody }

PropertySetParameterList :

FormalParameter

Static Semantics: Early Errors

_MethodDefinition_ : _PropertyName_ ( _StrictFormalParameters_ ) {
_FunctionBody_ }

-   -   It is a Syntax Error if any element of the BoundNames of
    _StrictFormalParameters_ also occurs in the LexicallyDeclaredNames
    of _FunctionBody_.

_MethodDefinition_ : SET _PropertyName_ ( _PropertySetParameterList_ ) {
_FunctionBody_ }

-   -   -   It is a Syntax Error if BoundNames of
    _PropertySetParameterList_ contains any duplicate elements.

-   It is a Syntax Error if any element of the BoundNames of
    _PropertySetParameterList_ also occurs in the LexicallyDeclaredNames
    of _FunctionBody_.

Static Semantics: ComputedPropertyContains

  With parameter _symbol_.

See also: 12.2.5.2, 14.4.3, 14.5.5.

MethodDefinition :

PropertyName ( StrictFormalParameters ) { FunctionBody }
GET PropertyName ( ) { FunctionBody }
SET PropertyName ( PropertySetParameterList ) { FunctionBody }

1.  Return the result of ComputedPropertyContains for _PropertyName
    with argument _symbol_.

Static Semantics: ExpectedArgumentCount

See also: 14.1.5, 14.2.6.

_PropertySetParameterList_ : _FormalParameter 

1.  If HasInitializer of _FormalParameter_ is TRUE return 

2.  Return 1.

Static Semantics: HasComputedPropertyKey

SEE ALSO: 12.2.5.4, 14.4.5

MethodDefinition :

PropertyName ( StrictFormalParameters ) { FunctionBody }
GET PropertyName ( ) { FunctionBody }
SET PropertyName ( PropertySetParameterList ) { FunctionBody }

1.  Return HasComputedPropertyKey of _PropertyName_.

Static Semantics: PropName

SEE ALSO: 12.2.5.6, 14.4.9, 14.5.12

MethodDefinition :

PropertyName ( StrictFormalParameters ) { FunctionBody }
GET PropertyName ( ) { FunctionBody }
SET PropertyName ( PropertySetParameterList ) { FunctionBody }

1.  Return PropName of _PropertyName_.

Static Semantics: ReferencesSuper

See also: 14.1.16, 14.2.12, 14.4.10.

MethodDefinition : PropertyName ( StrictFormalParameters ) {
FunctionBody }

1.  If _StrictFormalParameters_ Contains SUPER is TRUE, then return
    TRUE.

2.  Return _FunctionBody_ Contains SUPER.

_MethodDefinition_ : GET _PropertyName_ ( ) { _FunctionBody_ }

1.  Return _FunctionBody_ Contains SUPER.

_MethodDefinition_ : SET _PropertyName_ ( _PropertySetParameterList_ ) {
_FunctionBody_ }

1.  If _PropertySetParameterList_ Contains SUPER is TRUE, then return
    TRUE.

2.  Return _FunctionBody_ Contains SUPER.

Static Semantics: SpecialMethod

_MethodDefinition_ : _PropertyName_ ( _StrictFormalParameters_ ) {
_FunctionBody_ }

1.  Return FALSE.

MethodDefinition :

GeneratorMethod
GET PropertyName ( ) { FunctionBody }
SET PropertyName ( PropertySetParameterList ) { FunctionBody }

1.  Return TRUE.

Runtime Semantics: DefineMethod

  With parameters _object_ and optional parameter _functionPrototype_.

_MethodDefinition_ : _PropertyName_ ( _StrictFormalParameters_ ) {
_FunctionBody_ }

1.  Let _propKey_ be the result of evaluating _PropertyName_.

2.  ReturnIfAbrupt(_propKey_).

3.  Let _strict_ be IsStrict of _FunctionBody_.

4.  Let _scope_ be the running execution context’s LexicalEnvironment.

5.  Let _closure_ be FunctionCreate(Method, _StrictFormalParameters_,
    _FunctionBody, scope_, _strict_). If _functionPrototype_ was passed
    as a parameter then pass its value as the _functionPrototype_
    optional argument of FunctionCreate.

6.  If ReferencesSuper of _MethodDefinition_ is TRUE, then

    a.  Perform MakeMethod(_closure_, _propKey_, _object_).

7.  Return the Record{[[key]]: _propKey_, [[closure]]: _closure_}.

Runtime Semantics: PropertyDefinitionEvaluation

  With parameter _object_.

See also: 12.2.5.9, 14.4.13, B.3.1

_MethodDefinition_ : _PropertyName_ ( _StrictFormalParameters_ ) {
_FunctionBody_ }

1.  Let _methodDef_ be the result of DefineMethod of this
    _MethodDefinition_ with argument _object_.

2.  ReturnIfAbrupt(_methodDef_).

3.  SetFunctionName(_methodDef_.[[closure]], _methodDef_.[[key]]).

4.  Assert: SetFunctionName will not return an abrupt completion.

5.  6.  Return CreateDataPropertyOrThrow(_object_, _methodDef_.[[key]],
    _methodDef_.[[closure]]).

_MethodDefinition_ : _GeneratorMethod

See 14.4.

_MethodDefinition_ : GET _PropertyName_ ( ) { _FunctionBody_ }

1.  Let _propKey_ be the result of evaluating _PropertyName_.

2.  ReturnIfAbrupt(_propKey_).

3.  Let _strict_ be IsStrict of _FunctionBody_.

4.  Let _scope_ be the running execution context’s LexicalEnvironment.

5.  Let _formalParameterList_ be the production _FormalParameters_ :
    [empty]

6.  Let _closure_ be FunctionCreate(Method, _formalParameterList_,
    _FunctionBody, scope_, _strict_).

7.  If ReferencesSuper of _MethodDefinition_ is TRUE, then

    a.  Perform MakeMethod(_closure_, _propKey_, _object_).

8.  SetFunctionName(_closure_, _propKey_, "GET").

9.  Assert: SetFunctionName will not return an abrupt completion.

10. Let _desc_ be the PropertyDescriptor{[[Get]]: _closure_,
    [[Enumerable]]: TRUE, [[Configurable]]: TRUE}

11. Return DefinePropertyOrThrow(_object_, _propKey_, _desc_).

_MethodDefinition_ : SET _PropertyName_ ( _PropertySetParameterList_ ) {
_FunctionBody_}

1.  Let _propKey_ be the result of evaluating _PropertyName_.

2.  ReturnIfAbrupt(_propKey_).

3.  Let _strict_ be IsStrict of _FunctionBody_.

4.  Let _scope_ be the running execution context’s LexicalEnvironment.

5.  Let _closure_ be FunctionCreate(Method, _PropertySetParameterList_,
    _FunctionBody, scope_, _strict_).

6.  If ReferencesSuper of _MethodDefinition_ is TRUE, then

    a.  Perform MakeMethod(_closure_, _propKey_, _object_).

7.  SetFunctionName(_closure_, _propKey_, "SET").

8.  Assert: SetFunctionName will not return an abrupt completion.

9.  Let _desc_ be the PropertyDescriptor{[[Set]]: _closure_,
    [[Enumerable]]: TRUE, [[Configurable]]: TRUE}

10. Return DefinePropertyOrThrow(_object_, _propKey_, _desc_).


Generator Function Definitions

Syntax

GeneratorMethod~[Yield]~ :

* PropertyName~[?Yield]~
(StrictFormalParameters~[Yield,GeneratorParameter]~ ) {
FunctionBody~[Yield]~ }

GeneratorDeclaration~[Yield,\ Default]~ :

  FUNCTION * BindingIdentifier~[?Yield,\ ?Default]~ (
  FormalParameters~[Yield,GeneratorParameter]~ ) { FunctionBody~[Yield]~
  }

GeneratorExpression :

FUNCTION * BindingIdentifier~[Yield]opt~ (
FormalParameters~[Yield,GeneratorParameter]~ ) { FunctionBody~[Yield]~ }

YieldExpression~[In]~ :

YIELD
YIELD [no LineTerminator here] [Lexical goal InputElementRegExp]
AssignmentExpression~[?In,\ Yield]~
YIELD [no LineTerminator here] * [Lexical goal InputElementRegExp]
AssignmentExpression~[?In,\ Yield]~

NOTE _YieldExpression_ cannot be used within the _FormalParameters_ of a
generator function because any expressions that are part of
_FormalParameters_ are evaluate before the resulting generator object is
in a resumable state.

Supplemental Syntax

The following productions are used as an aid in specifying the semantics
of certain ECMAScript language features. They are not used when parsing
ECMAScript source code.

GeneratorBody :

FunctionBody
Comprehension

NOTE: Abstract operations relating to generator objects are defined in
25.3.3.

Static Semantics: Early Errors

_GeneratorMethod_ : * _PropertyName_ ( _StrictFormalParameters_ ) {
_FunctionBody_ }

-   -   It is a Syntax Error if any element of the BoundNames of
    _StrictFormalParameters_ also occurs in the LexicallyDeclaredNames
    of _FunctionBody_.

_GeneratorDeclaration_ : FUNCTION * _BindingIdentifier_ (
_FormalParameters_ ) { _FunctionBody_ }
and
_GeneratorExpression_ : FUNCTION * _BindingIdentifier_~opt~ (
_FormalParameters_ ) { _FunctionBody_ }

-   -   If the source code matching this production is strict code, the
    Early Error rules for _StrictFormalParameters_ : _FormalParameters_
    are applied.

-   If the source code matching this production is strict code, it is a
    Syntax Error if _BindingIdentifier_ is the the _IdentifierName_ EVAL
    or the _IdentifierName_ ARGUMENTS.

-   -   It is a Syntax Error if any element of the BoundNames of
    _FormalParameters_ also occurs in the LexicallyDeclaredNames of
    _FunctionBody_.

Static Semantics: BoundNames

See also: 13.2.1.2, 13.2.2.1, 12.1.2, 13.6.4.2, 14.1.3, 14.2.2, 14.5.2,
15.2.1.2, 15.2.2.1.

_GeneratorDeclaration_ : FUNCTION * _BindingIdentifier_ (
_FormalParameters_ ) { _FunctionBody_ }

1.  Return the BoundNames of _BindingIdentifier_.

Static Semantics: ComputedPropertyContains

  With parameter _symbol_.

See also: 12.2.5.2, 14.3.2, 14.5.5.

_GeneratorMethod_ : * _PropertyName_ ( _StrictFormalParameters_ ) {
_FunctionBody_ }

1.  Return the result of ComputedPropertyContains for _PropertyName
    with argument _symbol_.

Static Semantics: Contains

  With parameter _symbol_.

See also: 5.3, 12.2.5.2, 12.3.1.1, 14.1.4, 14.2.3, 14.5.4

_GeneratorDeclaration_ : FUNCTION * _BindingIdentifier_ (
_FormalParameters_ ) { _FunctionBody_ }

1.  Return FALSE.

_GeneratorExpression_ : FUNCTION * _BindingIdentifier_~opt~ (
_FormalParameters_ ) { _FunctionBody_ }

1.  Return FALSE.

NOTE Static semantic rules that depend upon substructure generally do
not look into function definitions.

Static Semantics: HasComputedPropertyKey

SEE ALSO: 12.2.5.4, 14.3.4

_GeneratorMethod_ : * _PropertyName_ ( _StrictFormalParameters_ ) {
_FunctionBody_ }

1.  Return IsComputedPropertyKey of _PropertyName_.

Static Semantics: HasName

See also: 14.1.8, 14.2.8, 14.5.6.

_GeneratorExpression_ : FUNCTION * ( _FormalParameters_ ) {
_FunctionBody_ }

1.  Return FALSE.

_GeneratorExpression_ : FUNCTION * _BindingIdentifier_ (
_FormalParameters_ ) { _FunctionBody_ }

1.  Return TRUE.

Static Semantics: IsConstantDeclaration

See also: 13.2.1.3, 14.1.8, 14.5.5.

_GeneratorDeclaration_ : FUNCTION * _BindingIdentifier_ (
_FormalParameters_ ) { _FunctionBody_ }

1.  Return FALSE.

Static Semantics: IsFunctionDefinition

See also: 12.2.0.2, 12.2.10.2, 12.3.1.2, 12.4.2, 12.5.2, 12.6.1, 12.7.1,
12.8.1, 12.9.1, 12.10.1, 12.11.1, 12.12.1, 12.13.1, 12.14.2, 12.15.1,
14.1.11, 14.5.8.

_GeneratorExpression_ : FUNCTION * ( _FormalParameters_ ) {
_FunctionBody_ }

1.  Return TRUE.

_GeneratorExpression_ : FUNCTION * _BindingIdentifier_ (
_FormalParameters_ ) { _FunctionBody_ }

1.  Return TRUE.

1.  

Static Semantics: PropName

SEE ALSO: 12.2.5.6, 14.3.5, 14.5.12

_GeneratorMethod_ : * _PropertyName_ ( _StrictFormalParameters_ ) {
_FunctionBody_ }

1.  Return PropName of _PropertyName_.

Static Semantics: ReferencesSuper

See also: 14.1.16, 14.2.12, 14.3.6.

_GeneratorDeclaration_ : FUNCTION * _BindingIdentifier_ (
_FormalParameters_ ) { _FunctionBody_ }

1.  If _FormalParameters_ Contains SUPER is TRUE, then return TRUE.

2.  Return _FunctionBody_ Contains SUPER.

_GeneratorExpression_ : FUNCTION * _BindingIdentifier_~opt~ (
_FormalParameters_ ) { _FunctionBody_ }

1.  If _FormalParameters_ Contains SUPER is TRUE, then return TRUE.

2.  Return _FunctionBody_ Contains SUPER.

GeneratorMethod : * PropertyName ( StrictFormalParameters ) {
FunctionBody }

1.  If _StrictFormalParameters_ Contains SUPER is TRUE, then return
    TRUE.

2.  Return _FunctionBody_ Contains SUPER.

1.  

1.  

Runtime Semantics: EvaluateBody

  With parameter _functionObject_.

See also: 14.1.19, 14.2.16.

_GeneratorBody_ : _FunctionBody

1.  Assert: A Function Environment Record containing a THIS binding has
    already been activated.

2.  Let _env_ be GetThisEnvironment( ).

3.  Let _G_ be the result of calling the GetThisBinding concrete method
    of _env_.

4.  If Type(_G_) is not Object or if Type(_G_) is Object and _G_ does
    not have a [[GeneratorState]] internal slot or if Type(_G_) is
    Object and _G_ has a [[GeneratorState]] internal slot and the value
    of _G’s_ [[GeneratorState]] internal slot is not UNDEFINED, then

    a.  Let _newG_ be OrdinaryCreateFromConstructor(_functionObject_,
        "%GENERATORPROTOTYPE%", ( [[GeneratorState]],
        [[GeneratorContext]]) ).

    b.  ReturnIfAbrupt(_newG_).

    c.  Let _G_ be _newG._

5.  Return GeneratorStart(_G_, _FunctionBody_).

_GeneratorBody_ : _Comprehension

1.  Let _G_ be ObjectCreate(%GeneratorPrototype%, ( [[GeneratorState]],
    [[GeneratorContext]]) ).

2.  ReturnIfAbrupt(_G_).

3.  Assert: the value of _G’s_ [[GeneratorState]] internal slot is
    UNDEFINED.

4.  Let _startStatus_ be GeneratorStart(_G_, _Comprehension_).

5.  ReturnIfAbrupt(_startStatus_).

6.  Return _G_.

Runtime Semantics: InstantiateFunctionObject

  With parameter _scope_.

See also: 14.1.21.

_GeneratorDeclaration_ : FUNCTION * _BindingIdentifier_ (
_FormalParameters_ ) { _FunctionBody_ }

1.  If the _GeneratorDeclaration_ is contained in strict code or if its
    _FunctionBody_ is strict code, then let _strict_ be TRUE. Otherwise
    let _strict_ be FALSE.

2.  Let _name_ be StringValue of _BindingIdentifier.

3.  Using _FunctionBody_ from the production that is being evaluated,
    let _body_ be the supplemental syntactic grammar production:
    _GeneratorBody_ : _FunctionBody_.

4.  Let _F_ be GeneratorFunctionCreate(Normal, _FormalParameters_,
    _body, scope_, _strict_).

5.  If ReferencesSuper of _GeneratorDeclaration_ is TRUE, then

    a.  Perform MakeMethod(_F_, _name_, UNDEFINED).

6.  Let _prototype_ be ObjectCreate(%GeneratorPrototype%).

7.  Perform MakeConstructor(_F_, TRUE, _prototype_).

8.  SetFunctionName(_F_, _name_).

9.  Assert: SetFunctionName will not return an abrupt completion.

10. Return _F_.

Runtime Semantics: PropertyDefinitionEvaluation

  With parameter _object_.

See also: 12.2.5.9, 14.3.9, B.3.1

_GeneratorMethod_ : * _PropertyName_ ( _StrictFormalParameters_ ) {
_FunctionBody_ }

1.  Let _propKey_ be the result of evaluating _PropertyName_.

2.  ReturnIfAbrupt(_propKey_).

3.  Let _strict_ be IsStrict of _FunctionBody_.

4.  Let _scope_ be the running execution context’s LexicalEnvironment.

5.  Using _FunctionBody_ from the production that is being evaluated,
    let _body_ be the supplemental syntactic grammar production:
    _GeneratorBody_ : _FunctionBody_.

6.  Let _closure_ be GeneratorFunctionCreate(Method,
    _StrictFormalParameters_, _body, scope_, _strict_).

7.  If ReferencesSuper of _GeneratorMethod_ is TRUE, then

    a.  Perform MakeMethod(_closure_, _propKey_, _object_).

8.  Let _prototype_ be ObjectCreate(%GeneratorPrototype%).

9.  Perform MakeConstructor(_closure_, TRUE, _prototype_).

10. SetFunctionName(_closure_, _propKey_).

11. Assert: SetFunctionName will not return an abrupt completion.

12. 13. Return CreateDataPropertyOrThrow(_object_, _propKey_,
    _closure_).

Runtime Semantics: Evaluation

_GeneratorDeclaration_ : FUNCTION * _BindingIdentifier_ (
_FormalParameters_ ) { _FunctionBody_ }

1.  Return NormalCompletion(empty)

_GeneratorExpression_ : FUNCTION * ( _FormalParameters_ ) {
_FunctionBody_ }

1.  Let _strict_ be IsStrict of _FunctionBody_.

2.  Using _FunctionBody_ from the production that is being evaluated,
    let _body_ be the supplemental syntactic grammar production:
    _GeneratorBody_ : _FunctionBody_.

3.  Let _scope_ be the LexicalEnvironment of the running execution
    context.

4.  Let _closure_ be GeneratorFunctionCreate(Normal, _FormalParameters_,
    _body, scope_, _strict_).

5.  If ReferencesSuper of _GeneratorExpression_ is TRUE, then

    a.  Perform MakeMethod(_closure_, UNDEFINED, UNDEFINED).

6.  Let _prototype_ be ObjectCreate(%GeneratorPrototype%).

7.  Perform MakeConstructor(_closure_, TRUE, _prototype_).

8.  Return _closure_.

_GeneratorExpression_ : FUNCTION * _BindingIdentifier_ (
_FormalParameters_ ) { _FunctionBody_ }

1.  Let _strict_ be IsStrict of _FunctionBody_.

2.  Using _FunctionBody_ from the production that is being evaluated,
    let _body_ be the supplemental syntactic grammar production:
    _GeneratorBody_ : _FunctionBody_.

3.  Let _runningContext_ be the running execution context’s Lexical
    Environment.

4.  Let _funcEnv_ be NewDeclarativeEnvironment(_runningContext_).

5.  Let _envRec_ be _funcEnv’s_ environment record.

6.  Let _name_ be StringValue of _BindingIdentifier_.

7.  Call the CreateImmutableBinding concrete method of _envRec_ passing
    _name_ as the argument.

8.  Let _closure_ be GeneratorFunctionCreate(Normal, _FormalParameters_,
    _body, funcEnv_, _strict_).

9.  If ReferencesSuper of _GeneratorExpression_ is TRUE, then

    a.  Perform MakeMethod(_closure_, _name_, UNDEFINED).

10. Let _prototype_ be ObjectCreate(%GeneratorPrototype%).

11. Perform MakeConstructor (_closure_, TRUE, _prototype_).

1.  SetFunctionName(_closure_, _name_).

1.  Assert: SetFunctionName will not return an abrupt completion.

2.  Call the InitializeBinding concrete method of _envRec_ passing
    _name_ and _closure_ as the arguments.

3.  Return _closure_.

NOTE 1 The _BindingIdentifier_ in a _GeneratorExpression_ can be
referenced from inside the _GeneratorExpression's_ _FunctionBody_ to
allow the generator code to call itself recursively. However, unlike in
a _GeneratorDeclaration_, the _BindingIdentifier_ in a
_GeneratorExpression_ cannot be referenced from and does not affect the
scope enclosing the _GeneratorExpression_.

_YieldExpression_ : YIELD

1.  Return GeneratorYield(CreateIterResultObject(UNDEFINED, FALSE)).

_YieldExpression_ : YIELD _AssignmentExpression 

1.  Let _exprRef_ be the result of evaluating _AssignmentExpression_.

2.  Let _value_ be GetValue(_exprRef_).

3.  ReturnIfAbrupt(_value_).

4.  Return GeneratorYield(CreateIterResultObject(_value_, FALSE)).

_YieldExpression_ : YIELD * _AssignmentExpression

1.  Let _exprRef_ be the result of evaluating _AssignmentExpression_.

2.  Let _value_ be GetValue(_exprRef_).

3.  4.  Let _iterator_ be GetIterator(ToObject(_value_)).

5.  ReturnIfAbrupt(_iterator_)_.

6.  Let _received_ be NormalCompletion(UNDEFINED).

7.  Repeat

    a.  If _received_.[[type]] is normal, then

        i.  Let _innerResult_ be IteratorNext(_iterator_,
            _received_.[[value]]).

        ii. ReturnIfAbrupt(_innerResult_).

    b.  Else

        i.  Assert: _received_.[[type]] is throw.

        ii. If HasProperty(_iterator_, "THROW") is TRUE, then

            1.  Let _innerResult_ be Invoke(_iterator_, "THROW",
                (_received_.[[value]])).

            2.  ReturnIfAbrupt(_innerResult_).

            3.  If Type(_innerResult_) is not Object, then throw a
                TYPEERROR exception.

        iii. Else, return _received._

    c.  Let _done_ be IteratorComplete(_innerResult_).

    d.  ReturnIfAbrupt(_done_).

    e.  If _done_ is TRUE, then

        i.  Return IteratorValue (_innerResult_).

    f.  Let _received_ be GeneratorYield(_innerResult_).


Class Definitions

Syntax

ClassDeclaration~[Yield,\ Default]~ :

CLASS BindingIdentifier~[?Yield,\ ?Default]~ ClassTail~[?Yield]~

ClassExpression~[Yield,GeneratorParameter]~ :

CLASS BindingIdentifier~[?Yield]opt~
ClassTail~[?Yield,?GeneratorParameter]~

ClassTail~[Yield,GeneratorParameter]~ :

[~GeneratorParameter] ClassHeritage~[?Yield]opt~ {
ClassBody~[?Yield]opt~ }
[+GeneratorParameter] ClassHeritage~opt~ { ClassBody~opt~ }

ClassHeritage~[Yield]~ :

EXTENDS LeftHandSideExpression~[?Yield]~

ClassBody~[Yield]~ :

ClassElementList~[?Yield]~

ClassElementList~[Yield]~ :

ClassElement~[?Yield]~
ClassElementList~[?Yield]~ ClassElement~[?Yield]~

ClassElement~[Yield]~ :

MethodDefinition~[?Yield]~
STATIC MethodDefinition~[?Yield]~
;

NOTE A _ClassBody_ is always strict code.

Static Semantics: Early Errors

_ClassDeclaration_ : CLASS _BindingIdentifier_ _ClassTail

_ClassExpression_: CLASS _BindingIdentifier_ _ClassTail

-   It is a Syntax Error if the StringValue of _BindingIdentifier_ is
    "LET".

_ClassBody_ : _ClassElementList

-   It is a Syntax Error if PrototypePropertyNameList of
    _ClassElementList_ contains more than one occurrence of
    "CONSTRUCTOR".

-   

_ClassElement_ : _MethodDefinition

-   It is a Syntax Error if PropName of _MethodDefinition_ is
    "CONSTRUCTOR" and SpecialMethod of _MethodDefinition_ is TRUE_._

_ClassElement_ : STATIC _MethodDefinition

-   It is a Syntax Error if PropName of _MethodDefinition_ is
    "PROTOTYPE"_._

Static Semantics: BoundNames

See also: 13.2.1.2, 13.2.2.1, 12.1.2, 13.6.4.2, 14.1.3, 14.2.2, 14.4.2,
15.2.1.2, 15.2.2.1.

_ClassDeclaration_ : CLASS _BindingIdentifier_ _ClassTail

1.  Return the BoundNames of _BindingIdentifier_.

Static Semantics: ConstructorMethod

_ClassElementList_ : _ClassElement

1.  If _ClassElement_ is the production _ClassElement_ : ; then, return
    empty.

2.  If IsStatic of _ClassElement_ is TRUE, return empty.

3.  If PropName of _ClassElement_ is not "CONSTRUCTOR", return empty.

4.  Return _ClassElement_.

_ClassElementList_ : _ClassElementList_ _ClassElement

1.  Let _head_ be ConstructorMethod of _ClassElementList.

2.  If _head_ is not empty, return _head_.

3.  If _ClassElement_ is the production _ClassElement_ : ; then, return
    empty.

4.  If IsStatic of _ClassElement_ is TRUE, return empty.

5.  If PropName of _ClassElement_ is not "CONSTRUCTOR", return empty.

6.  Return _ClassElement_.

NOTE Early Error rules ensure that there is only one method definition
named "CONSTRUCTOR" and that it is not an accessor property or generator
definition.

Static Semantics: Contains

  With parameter _symbol_.

See also: 5.3, 12.2.5.2, 12.3.1.1, 14.1.4, 14.2.3, 14.4.3

_ClassTail_ : _ClassHeritage_~opt~ { _ClassBody_ }

1.  If _symbol_ is _ClassBody_, return TRUE.

2.  If _symbol_ is _ClassHeritage_, then

    a.  If _ClassHeritage_ is present, return TRUE otherwise return
        FALSE.

3.  Let _inHeritage_ be _ClassHeritage_ Contains _symbol_.

4.  If _inHeritage_ is TRUE, then return TRUE.

5.  Return the result of ComputedPropertyContains for _ClassBody_ with
    argument _symbol_.

NOTE Static semantic rules that depend upon substructure generally do
not look into class bodies except for _PropertyName_ productions.

Static Semantics: ComputedPropertyContains

  With parameter _symbol_.

See also: 12.2.5.2, 14.3.2, 14.4.3.

_ClassElementList_ : _ClassElementList_ _ClassElement

1.  Let _inList_ be the result of ComputedPropertyContains for
    _ClassElementList_ with argument _symbol._

2.  If _inList_ is TRUE, then return TRUE.

3.  Return the result of ComputedPropertyContains for _ClassElement
    with argument _symbol_.

_ClassElement_ : _MethodDefinition

1.  Return the result of ComputedPropertyContains for _MethodDefinition
    with argument _symbol_.

_ClassElement_ : STATIC _MethodDefinition

1.  Return the result of ComputedPropertyContains for _MethodDefinition
    with argument _symbol_.

_ClassElement_ : ;

1.  Return FALSE.

Static Semantics: HasName

See also: 14.1.8, 14.2.8, 14.4.6.

_ClassExpression_ : CLASS _ClassTail

1.  Return FALSE.

_ClassExpression_ : CLASS _BindingIdentifier_ _ClassTail

1.  Return TRUE.

Static Semantics: IsConstantDeclaration

See also: 13.2.1.3, 14.1.8, 14.4.5.

_ClassDeclaration_ : CLASS _BindingIdentifier_ _ClassTail

1.  Return FALSE.

Static Semantics: IsFunctionDefinition

See also: 12.2.0.2, 12.2.10.2, 12.3.1.2, 12.4.2, 12.5.2, 12.6.1, 12.7.1,
12.8.1, 12.9.1, 12.10.1, 12.11.1, 12.12.1, 12.13.1, 12.14.2, 12.15.1,
14.1.11, 14.4.8.

_ClassExpression_ : CLASS _ClassTail

1.  Return TRUE.

_ClassExpression_ : CLASS _BindingIdentifier_ _ClassTail

1.  Return TRUE.

Static Semantics: IsStatic

_ClassElement_ : _MethodDefinition

1.  Return FALSE.

_ClassElement_ : STATIC _MethodDefinition

1.  Return TRUE.

_ClassElement_ : ;

1.  Return FALSE.

1.  

Static Semantics: NonConstructorMethodDefinitions

_ClassElementList_ : _ClassElement

1.  If _ClassElement_ is the production _ClassElement_ : ; then, return
    a new empty List.

2.  3.  4.  If IsStatic of _ClassElement_ is FALSE and PropName of
    _ClassElement_ is "CONSTRUCTOR", return a new empty List.

5.  Return a List containing _ClassElement_.

_ClassElementList_ : _ClassElementList_ _ClassElement

1.  Let _list_ be NonConstructorMethodDefinitions of _ClassElementList.

2.  If _ClassElement_ is the production _ClassElement_ : ; then, return
    _list_.

3.  If IsStatic of _ClassElement_ is FALSE

4.  and PropName of _ClassElement_ is "CONSTRUCTOR", return _list_.

5.  Append _ClassElement_ to the end of _list_.

6.  Return _list_.

Static Semantics: PrototypePropertyNameList

_ClassElementList_ : _ClassElement

1.  If PropName of _ClassElement_ is empty, return a new empty List.

2.  If IsStatic of _ClassElement_ is TRUE, return a new empty List.

3.  Return a List containing PropName of _ClassElement_.

_ClassElementList_ : _ClassElementList_ _ClassElement

1.  Let _list_ be PrototypePropertyNameList of _ClassElementList.

2.  If PropName of _ClassElement_ is empty, return _list_.

3.  If IsStatic of _ClassElement_ is TRUE, return _list_.

4.  Append PropName of _ClassElement_ to the end of _list_.

5.  Return _list_.

Static Semantics: PropName

SEE ALSO: 12.2.5.6, 14.3.5, 14.4.9

_ClassElement_ : ;

1.  Return empty.

Static Semantics: StaticPropertyNameList

_ClassElementList_ : _ClassElement

1.  If PropName of _ClassElement_ is empty, return a new empty List.

2.  If IsStatic of _ClassElement_ is FALSE, return a new empty List.

3.  Return a List containing PropName of _ClassElement_.

_ClassElementList_ : _ClassElementList_ _ClassElement

1.  Let _list_ be StaticPropertyNameList of _ClassElementList.

2.  If PropName of _ClassElement_ is empty, return _list_.

3.  If IsStatic of _ClassElement_ is FALSE, return _list_.

4.  Append PropName of _ClassElement_ to the end of _list_.

5.  Return _list_.

1.  2.  3.  

1.  2.  3.  4.  5.  

1.  

Runtime Semantics: ClassDefinitionEvaluation

  With parameter _className_.

_ClassTail_ : _ClassHeritage_~opt~ { _ClassBody_~opt~ }

1.  If _ClassHeritage_~opt~ is not present, then

    a.  Let _protoParent_ be the intrinsic object %ObjectPrototype%.

    b.  Let _constructorParent_ be the intrinsic object
        %FunctionPrototype%.

2.  Else

    a.  Let _superclass_ be the result of evaluating _ClassHeritage_.

    b.  ReturnIfAbrupt(_superclass_).

    c.  If _superclass_ is NULL, then

        i.  Let _protoParent_ be NULL.

        ii. Let _constructorParent_ be the intrinsic object
            %FunctionPrototype%.

    d.  Else if IsConstructor(_superclass_) is FALSE, then throw a
        TYPEERROR exception.

    e.  Else

        i.  Let _protoParent_ be Get(_superclass_, "PROTOTYPE").

        ii. ReturnIfAbrupt(_protoParent_).

        iii. If Type(_protoParent_) is neither Object nor Null, throw a
            TYPEERROR exception.

        iv. Let _constructorParent_ be _superclass_.

3.  Let _proto_ be ObjectCreate(_protoParent_).

4.  Let _lex_ be the LexicalEnvironment of the running execution
    context.

5.  If _className_ is not UNDEFINED, then

    a.  Let _scope_ be NewDeclarativeEnvironment(_lex_).

    b.  Let _envRec_ be _scope’s_ environment record.

    c.  Call the CreateImmutableBinding concrete method of _envRec_
        passing _className_ as the argument.

    d.  Set the running execution context’s LexicalEnvironment to
        _scope_.

6.  If _ClassBody_~opt~ is not present, then let _constructor_ be empty.

7.  Else, let _constructor_ be ConstructorMethod of _ClassBody_.

8.  If _constructor_ is empty, then

    a.  If _ClassHeritage_~opt~ is present, then

        i.  Let _constructor_ be the result of parsing the String
            "CONSTRUCTOR(... ARGS){ SUPER (...ARGS);}" using the
            syntactic grammar with the goal symbol _MethodDefinition._

    b.  Else,

        i.  Let _constructor_ be the result of parsing the String
            "CONSTRUCTOR( ){ }" using the syntactic grammar with the
            goal symbol _MethodDefinition._

9.  Let _strict_ be TRUE.

10. Let _constructorInfo_ be the result of performing DefineMethod for
    _constructor_ with arguments _proto_ and _constructorParent_ as the
    optional _functionPrototype_ argument.

11. Let _F_ be _constructorInfo_.[[closure]]

12. Perform the abstract operation MakeConstructor with argument _F_ and
    FALSE as the optional _writablePrototype_ argument and _proto_ as
    the optional _prototype_ argument.

13. Let _desc_ be the PropertyDescriptor{[[Value]]: _F_, [[Writable]]:
    TRUE, [[Enumerable]]: FALSE, [[Configurable]]: TRUE}.

14. Call the [[DefineOwnProperty]] internal method of _proto_ with
    arguments "CONSTRUCTOR" and _desc._

15. If _ClassBody_~opt~ is not present, then let _methods_ be a new
    empty List.

16. Else, let _methods_ be NonConstructorMethodDefinitions of
    _ClassBody_.

17. For each _ClassElement_ _m_ in order from _methods

    a.  If IsStatic of _m_ is FALSE, then

        i.  Let _status_ be the result of performing
            PropertyDefinitionEvaluation for _m_ with argument _proto_.

    b.  Else,

        i.  ii. iii. Let _status_ be the result of performing
            PropertyDefinitionEvaluation for _m_ with argument _F_.

    c.  If _status_ is an abrupt completion, then

        i.  Set the running execution context’s LexicalEnvironment to
            _lex_.

        ii. Return _status_.

18. Set the running execution context’s LexicalEnvironment to _lex_.

19. If _className_ is not UNDEFINED, then

    a.  Call the InitializeBinding concrete method of _envRec_ passing
        _className_ and _F_ as the arguments.

20. Return _F_.

Runtime Semantics: Evaluation

_ClassDeclaration_ : CLASS _BindingIdentifier_ _ClassTail

1.  Let _className_ be StringValue(_BindingIdentifier_).

2.  Let _value_ be the result of ClassDefinitionEvaluation of
    _ClassTail_ with argument _className_

3.  ReturnIfAbrupt(_value_).

4.  Let _hasNameProperty_ be HasOwnProperty(_value_, "NAME").

5.  ReturnIfAbrupt(_hasNameProperty_).

6.  If _hasNameProperty_ is FALSE, then

    a.  Perform SetFunctionName(_value_, _className_).

    b.  Assert: SetFunctionName will not return an abrupt completion.

7.  Let _env_ be the running execution context’s LexicalEnvironment.

8.  Let _status_ be the result of performing BindingInitialization for
    _BindingIdentifier_ passing _value_ and _env_ as the arguments.

9.  ReturnIfAbrupt(_status_).

10. Return NormalCompletion(empty).

_ClassExpression_ : CLASS _BindingIdentifier_~opt~ _ClassTail

1.  If _BindingIdentifier_~opt~ is not present, then let _className_ be
    UNDEFINED.

2.  Else, let _className_ be StringValue(_BindingIdentifier_).

3.  Let _value_ be the result of ClassDefinitionEvaluation of
    _ClassTail_ with argument _className_.

4.  ReturnIfAbrupt(_value_).

5.  If _className_ is not UNDEFINED, then

    a.  Let _hasNameProperty_ be HasOwnProperty(_value_, "NAME").

    b.  ReturnIfAbrupt(_hasNameProperty_).

    c.  If _hasNameProperty_ is FALSE, then

        i.  Perform SetFunctionName(_value_, _className_).

        ii. Assert: SetFunctionName will not return an abrupt
            completion.

6.  Return NormalCompletion(_value_).

NOTE If the class definition included a "NAME" static method then that
method is not over-written with a "NAME" data property for the class
name.


Tail Position Calls

Static Semantics: IsInTailPosition(nonterminal) Abstract Operation

The abstract operation IsInTailPosition with argument _nonterminal_
performs the following steps:

1.  Assert: _nonterminal_ is a parsed grammar production.

2.  If the source code matching _nonterminal_ is not strict code, then
    return FALSE.

3.  If _nonterminal_ is not contained within a _FunctionBody_ or
    _ConciseBody_, then return FALSE.

4.  Let _body_ be the _FunctionBody_ or _ConciseBody_ that most closely
    contains _nonterminal_.

5.  If _body_ is the _FunctionBody_ of a _GeneratorMethod_,
    _GeneratorDeclaration_, or a _GeneratorExpression_, then return
    FALSE.

6.  Return the result of HasProductionInTailPosition of _body_ with
    argument _nonterminal_.

NOTE Tail Position calls are only defined in strict mode code because of
a common non-standard language extension (see 9.2.8) that enables
observation of the chain of caller contexts.

Static Semantics: HasProductionInTailPosition

  With parameter _nonterminal_.

NOTE _nonterminal_ is a parsed grammar production that represent a
specific range of source code. When the following algorithms compare
_nonterminal_ to other grammar symbols they are testing whether the same
source code was matched by both symbols.

Statement Rules

_ConciseBody_ : _AssignmentExpression

1.  Return HasProductionInTailPosition of _AssignmentExpression_ with
    argument _nonterminal_.

_StatementList_ : _StatementList StatementListItem

1.  Let _has_ be HasProductionInTailPosition of _StatementList_ with
    argument _nonterminal_.

2.  If _has_ is TRUE, then return TRUE.

3.  Return HasProductionInTailPosition of _StatementListItem_ with
    argument _nonterminal_.

_FunctionStatementList_ : [empty]

_StatementListItem_ : _Declaration

Statement :

VariableStatement
EmptyStatement
ExpressionStatement
ContinueStatement
BreakStatement
ThrowStatement
DebuggerStatement

_Block_ : { }

_ReturnStatement_ : RETURN ;

_CaseBlock_ : { }

1.  Return FALSE.

_IfStatement_ : IF ( _Expression_ ) _Statement_ ELSE _Statement

1.  Let _has_ be HasProductionInTailPosition of the first _Statement
    with argument _nonterminal_.

2.  If _has_ is TRUE, then return TRUE.

3.  Return HasProductionInTailPosition of the second _Statement_ with
    argument _nonterminal_.

_IfStatement_ : IF ( _Expression_ ) _Statement 

IterationStatement :

DO Statement WHILE ( Expression ) ;~opt~
WHILE ( Expression ) Statement
FOR (Expression~opt~ ; Expression~opt~ ; Expression~opt~ ) Statement
FOR ( VAR VariableDeclarationList ; Expression~opt~ ; Expression~opt~ )
Statement
FOR ( LexicalDeclaration Expression~opt~ ; Expression~opt~ ) Statement
FOR ( LeftHandSideExpression IN Expression ) Statement
FOR ( VAR ForBinding IN Expression ) Statement
FOR ( ForDeclaration IN Expression ) Statement
FOR ( LeftHandSideExpression OF AssignmentExpression ) Statement
FOR ( VAR ForBinding OF AssignmentExpression ) Statement
FOR ( ForDeclaration OF AssignmentExpression ) Statement

_WithStatement_ : WITH ( _Expression_ ) _Statement

LabelledStatement :

LabelIdentifier : Statement

1.  Return HasProductionInTailPosition of _Statement_ with argument
    _nonterminal_.

_ReturnStatement_ : RETURN _Expression_;

1.  Return HasProductionInTailPosition of _Expression_ with argument
    _nonterminal_.

_SwitchStatement_ : SWITCH ( _Expression_ ) _CaseBlock

1.  Return HasProductionInTailPosition of _CaseBlock_ with argument
    _nonterminal_.

_CaseBlock_ : { _CaseClauses_~opt~ _DefaultClause CaseClauses_~opt~ }

1.  Let _has_ be FALSE.

2.  If the first _CaseClauses_ is present, let _has_ be
    HasProductionInTailPosition of the first _CaseClauses_ with argument
    _nonterminal_.

3.  If _has_ is TRUE, then return TRUE.

4.  Let _has_ be HasProductionInTailPosition of the _DefaultClause_ with
    argument _nonterminal_.

5.  If _has_ is TRUE, then return TRUE.

6.  If the second _CaseClauses_ is present, let _has_ be
    HasProductionInTailPosition of the second _CaseClauses_ with
    argument _nonterminal_.

7.  Return _has_.

_CaseClauses_ : _CaseClauses CaseClause

1.  Let _has_ be HasProductionInTailPosition of _CaseClauses_ with
    argument _nonterminal_.

2.  If _has_ is TRUE, then return TRUE.

3.  Return HasProductionInTailPosition of _CaseClause_ with argument
    _nonterminal_.

_CaseClause_ : CASE _Expression_ : _StatementList_~opt~

_DefaultClause_ : DEFAULT : _StatementList_~opt~

1.  If _StatementList_ is present, return HasProductionInTailPosition of
    _StatementList_ with argument _nonterminal_.

2.  Return FALSE.

_TryStatement_ : TRY _Block_ _Catch

1.  Return HasProductionInTailPosition of _Catch_ with argument
    _nonterminal_.

_TryStatement_ : TRY _Block_ _Finally

_TryStatement_ : TRY _Block_ _Catch_ _Finally

1.  Return HasProductionInTailPosition of _Finally_ with argument
    _nonterminal_.

_Catch_ : CATCH ( _CatchParameter_ ) _Block

1.  Return HasProductionInTailPosition of _Block_ with argument
    _nonterminal_.

Expression Rules

NOTE A potential tail position call that is immediately followed by
return GetValue of the call result is also a possible tail position
call. Functional calls cannot return reference values, so such a
GetValue operation will always returns the same value as the actual
function call result.

AssignmentExpression :

YieldExpression
ArrowFunction
LeftHandSideExpression = AssignmentExpression
LeftHandSideExpression AssignmentOperator AssignmentExpression

BitwiseANDExpression : BitwiseANDExpression & EqualityExpression

BitwiseXORExpression : BitwiseXORExpression ^ BitwiseANDExpression

BitwiseORExpression : BitwiseORExpression | BitwiseXORExpression

EqualityExpression :

EqualityExpression == RelationalExpression
EqualityExpression != RelationalExpression
EqualityExpression === RelationalExpression
EqualityExpression !== RelationalExpression

RelationalExpression :

RelationalExpression < ShiftExpression
RelationalExpression > ShiftExpression
RelationalExpression <= ShiftExpression
RelationalExpression >= ShiftExpression
RelationalExpression INSTANCEOF ShiftExpression
RelationalExpression IN ShiftExpression

ShiftExpression :

ShiftExpression << AdditiveExpression
ShiftExpression >> AdditiveExpression
ShiftExpression >>> AdditiveExpression

AdditiveExpression :

AdditiveExpression + MultiplicativeExpression
AdditiveExpression - MultiplicativeExpression

MultiplicativeExpression :

MultiplicativeExpression * UnaryExpression
MultiplicativeExpression / UnaryExpression
MultiplicativeExpression % UnaryExpression

UnaryExpression :

DELETE UnaryExpression
VOID UnaryExpression
TYPEOF UnaryExpression
++ UnaryExpression
-- UnaryExpression
+ UnaryExpression
- UnaryExpression
~ UnaryExpression
! UnaryExpression

PostfixExpression :

LeftHandSideExpression ++
LeftHandSideExpression --

CallExpression :

CallExpression [ Expression ]
CallExpression . IdentifierName

MemberExpression :

MemberExpression [ Expression ]
MemberExpression . IdentifierName
SUPER [ Expression ]
SUPER . IdentifierName

PrimaryExpression :

THIS
IdentifierReference
Literal
ArrayInitializer
ObjectLiteral
FunctionExpression
ClassExpression
GeneratorExpression
GeneratorComprehension
RegularExpressionLiteral
TemplateLiteral

1.  Return FALSE.

_Expression_ :

_AssignmentExpression
Expression , AssignmentExpression

1.  Return HasProductionInTailPosition of _AssignmentExpression_ with
    argument _nonterminal_.

_ConditionalExpression_ : _LogicalORExpression_ ? _AssignmentExpression
: _AssignmentExpression_

1.  Let _has_ be HasProductionInTailPosition of the first
    _AssignmentExpression_ with argument _nonterminal_.

2.  If _has_ is TRUE, then return TRUE.

3.  Return HasProductionInTailPosition of the second
    _AssignmentExpression_ with argument _nonterminal_.

_LogicalANDExpression_ : _LogicalANDExpression_ && _BitwiseORExpression

1.  Return HasProductionInTailPosition of _BitwiseORExpression_ with
    argument _nonterminal_.

_LogicalORExpression_ : _LogicalORExpression_ || _LogicalANDExpression

1.  Return HasProductionInTailPosition of _LogicalANDExpression_ with
    argument _nonterminal_.

CallExpression :

MemberExpression Arguments
SUPER Arguments
CallExpression Arguments
CallExpression TemplateLiteral

1.  If this _CallExpression_ is _nonterminal_, then return TRUE.

2.  Return FALSE.

MemberExpression :

MemberExpression TemplateLiteral
NEW SUPER Arguments
NEW MemberExpression Arguments

1.  If this _MemberExpression_ is _nonterminal_, then return TRUE.

2.  Return FALSE.

NewExpression :

NEW NewExpression
NEW SUPER

1.  If this _NewExpression_ is _nonterminal_, then return TRUE.

2.  Return FALSE.

_PrimaryExpression_ :
_CoverParenthesizedExpressionAndArrowParameterList

1.  Let _expr_ be CoveredParenthesizedExpression of
    _CoverParenthesizedExpressionAndArrowParameterList_.

2.  Return HasProductionInTailPosition of _expr_ with argument
    _nonterminal_.

ParenthesizedExpression :

( Expression )

1.  Return HasProductionInTailPosition of _Expression_ with argument
    _nonterminal_.

Runtime Semantics: PrepareForTailCall ( )

The abstract operation PrepareForTailCall performs the following steps:

1.  Let _leafContext_ be the running execution context.

2.  Suspend _leafContext_.

3.  Pop _leafContext_ from the execution context context stack. The
    execution context now on the top of the stack becomes the running
    execution context.

4.  Assert: _leafContext_ has no further use. It will never be activated
    as the running execution context.

A tail position call must either release any transient internal
resources associated with the currently executing function execution
context before invoking the target function or reuse those resources in
support of the target function.

NOTE 1 For example, a tail position call should only grow an
implementation’s activation record stack by the amount that the size of
the target function’s activation record exceeds the size of the calling
function’s activation record. If the target function’s activation record
is smaller, then the total size of the stack should decrease.



ECMASCRIPT LANGUAGE: SCRIPTS AND MODULES


Scripts

Syntax

Script :

ScriptBody~opt~

ScriptBody :

StatementList

Static Semantics: Early Errors

_ScriptBody_ : _StatementList

-   It is a Syntax Error if the LexicallyDeclaredNames of
    _StatementList_ contains any duplicate entries.

-   It is a Syntax Error if any element of the LexicallyDeclaredNames of
    _StatementList_ also occurs in the VarDeclaredNames of
    _StatementList_.

-   It is a Syntax Error if _StatementList_ Contains SUPER.

NOTE Additional error conditions relating to conflicting or duplicate
declarations are checked during module linking prior to evaluation of a
_Script_. If any such errors are detected the _Script_ is not evaluated.

Static Semantics: IsStrict

See also: 14.1.13, 15.2.0.7.

_ScriptBody_ : _StatementList

1.  If this _ScriptBody_ is contained in strict code or if
    _StatementList_ is strict code, then return TRUE. Otherwise, return
    FALSE.

Static Semantics: LexicallyDeclaredNames

See also: 13.1.2, 13.11.2, 13.12.4, 14.1.14, 14.2.10, 15.2.0.10.

_ScriptBody_ : _StatementList

1.  Return TopLevelLexicallyDeclaredNames of _StatementList_.

NOTE At the top level of a _Script_, function declarations are treated
like var declarations rather than like lexical declarations.

Static Semantics: LexicallyScopedDeclarations

See also: 13.1.3, 13.11.3, 13.12.5, 14.1.15, 14.2.11, 15.2.0.11.

_ScriptBody_ : _StatementList

1.  Return TopLevelLexicallyScopedDeclarations of _StatementList_.

Static Semantics: VarDeclaredNames

See also: 13.0.1, 13.1.8, 13.2.2.2, 13.5.2, 13.6.1.1, 13.6.2.1,
13.6.3.1, 13.6.4.3, , 13.11.4, 13.12.10, 13.14.2, 14.1.17, 14.2.13,
15.2.0.13.

_ScriptBody_ : _StatementList

1.  Return TopLevelVarDeclaredNames of _StatementList_.

Static Semantics: VarScopedDeclarations

See also: 13.0.2, 13.1.9, 13.2.2.3, 13.5.3, 13.6.1.2, 13.6.2.2,
13.6.3.3, 13.6.4.4, 13.10.3, 13.11.5, 13.12.11, 13.14.3, 14.1.18,
14.2.14, 15.2.0.14.

_ScriptBody_ : _StatementList

1.  Return TopLevelVarScopedDeclarations of _StatementList_.

Runtime Semantics: ScriptEvaluation

  With argument _realm_ and _deletableBindings_.

_Script_ : _ScriptBody_~opt~

1.  The code of this _Script_ is strict mode code if the Directive
    Prologue (14.1.1) of its _ScriptBody_ contains a Use Strict
    Directive or if any of the conditions of 10.2.1 apply. If the code
    of this _Script_ is strict mode code, _ScriptBody_ is evaluated in
    the following steps as strict mode code. Otherwise _ScriptBody_ is
    evaluated in the following steps as non-strict mode code.

2.  If _ScriptBody_ is not present, return NormalCompletion(empty).

3.  Let _globalEnv_ be _realm_.[[globalEnv]].

4.  Let _status_ be GlobalDeclarationInstantiation(_ScriptBody_,
    _globalEnv_, and _deletableBindings_).

5.  ReturnIfAbrupt(_status_).

6.  Let _scriptCxt_ be a new ECMAScript code execution context.

7.  Set the Function of _scriptCxt_ to NULL.

8.  Set the Realm of _scriptCxt_ to _realm_.

9.  Set the VariableEnvironment of _scriptCxt_ to _globalEnv_.

10. Set the LexicalEnvironment of _scriptCxt_ to _globalEnv_.

11. If there is a currently running execution context, suspend it.

12. Push _scriptCxt_ on to the execution context stack; _scriptCxt_ is
    now the running execution context.

13. Let _result_ be the result of evaluating _ScriptBody_.

14. Suspend _scriptCxt_ and remove it from the execution context stack.

15. Assert: the execution context stack is not empty.

16. Resume the context that is now on the top of the execution context
    stack as the running execution context.

17. Return _result_.

NOTE The processes for initiating the evaluation of a _Script_ and for
dealing with the result of such an evaluation are defined by an
ECMAScript implementation and not by this specification.

Runtime Semantics: GlobalDeclarationInstantiation

NOTE When an execution context is established for evaluating scripts,
declarations are instantiated in the current global environment. Each
global binding declared in the code is instantiated.

GlobalDeclarationInstantiation is performed as follows using arguments
_script_, _env_, and _deletableBindings_. _script_ is the _ScriptBody
that for which the execution context is being established. _env_ is the
global environment record in which bindings are to be created.
_deletableBindings_ is TRUE if the bindings that are created should be
deletable.

1.  Let _strict_ be IsStrict of _script_.

2.  Let _lexNames_ be the LexicallyDeclaredNames of _script_.

3.  Let _varNames_ be the VarDeclaredNames of _script_.

4.  For each _name_ in _lexNames_, do

    a.  If the result of calling _env’s_ HasVarDeclaration concrete
        method passing _name_ as the argument is TRUE, throw a
        SYNTAXERROR exception.

    b.  If the result of calling _env’s_ HasLexicalDeclaration concrete
        method passing _name_ as the argument is TRUE, throw a
        SYNTAXERROR exception.

5.  For each _name_ in _varNames_, do

    a.  If the result of calling _env’s_ HasLexicalDeclaration concrete
        method passing _name_ as the argument is TRUE, throw a
        SYNTAXERROR exception.

6.  Let _varDeclarations_ be the VarScopedDeclarations of _script_.

7.  Let _functionsToInitialize_ be an empty List.

8.  Let _declaredFunctionNames_ be an empty List.

9.  For each _d_ in _varDeclarations_, in reverse list order do

    a.  If _d_ is neither a _VariableDeclaration_ or a _ForBinding_,
        then

        i.  Assert: _d_ is either a _FunctionDeclaration_ or a
            _GeneratorDeclaration_.

        ii. NOTE If there are multiple _FunctionDeclarations_ for the
            same name, the last declaration is used.

        iii. Let _fn_ be the sole element of the BoundNames of _d._

        iv. If _fn_ is not an element of _declaredFunctionNames_, then

            1.  Let _fnDefinable_ be the result of calling _env’s_
                CanDeclareGlobalFunction concrete method passing _fn_ as
                the argument.

            2.  If _fnDefinable_ is FALSE, throw TYPEERROR exception.

            3.  Append _fn_ to _declaredFunctionNames_.

            4.  Insert _d_ as the first element of
                _functionsToInitialize_.

10. Let _declaredVarNames_ be an empty List.

11. For each _d_ in _varDeclarations_, do

    a.  If _d_ is a _VariableDeclaration_ or a _ForBinding_ then

        i.  For each String _vn_ in the BoundNames of _d_, do

            1.  If _vn_ is not an element of _declaredFunctionNames_,
                then

                a.  Let _vnDefinable_ be the result of calling _env’s_
                    CanDeclareGlobalVar concrete method passing _vn_ as
                    the argument.

                b.  If _vnDefinable_ is FALSE, throw TYPEERROR
                    exception.

                c.  If _vn_ is not an element of _declaredVarNames_,
                    then

                    i.  Append _vn_ to _declaredVarNames_.

12. NOTE: No abnormal terminations occur after this algorithm step if
    the global object is an ordinary object. However, if the global
    object is a Proxy exotic object it may exhibit behaviours that cause
    abnormal terminations in some of the following steps.

13. Let _lexDeclarations_ be the LexicallyScopedDeclarations of
    _script_.

14. For each element _d_ in _lexDeclarations_ do

    a.  NOTE Lexically declarated names are only instantiated here but
        not initialized.

    b.  For each element _dn_ of the BoundNames of _d_ do

        i.  If IsConstantDeclaration of _d_ is TRUE, then

            1.  Let _status_ be the result of calling _env_’s
                CreateImmutableBinding concrete method passing _dn_ as
                the argument.

        ii. Else,

            1.  Let _status_ be the result of calling _env_’s
                CreateMutableBinding concrete method passing _dn_ and
                FALSE as the arguments.

        iii. ReturnIfAbrupt(_status_).

15. For each production _f_ in _functionsToInitialize_, do

    a.  Let _fn_ be the sole element of the BoundNames of _f._

    b.  Let _fo_ be the result of performing InstantiateFunctionObject
        for _f_ with argument _env_.

    c.  Let _status_ be the result of calling _env_’s
        CreateGlobalFunctionBinding concrete method passing _fn_, _fo_,
        and _deletableBindings_ as the arguments.

    d.  ReturnIfAbrupt(_status_).

16. For each String _vn_ in _declaredVarNames_, in list order do

    a.  Let _status_ be the result of calling _env’s_
        CreateGlobalVarBinding concrete method passing _vn_ and
        _deletableBindings_ as the argument.

    b.  ReturnIfAbrupt(_status_).

17. 18. a.  b.  i.  1.  

        ii. 1.  

        iii. 

    c.  i.  ii. iii. iv. 

19. Return NormalCompletion(empty)

NOTE Early errors specified in 15.1.1 prevent name conflicts between
function/var declarations and let/const/class declarations as well as
redeclaration of let/const/class bindings for declaration contained
within a single _Script_. However, such conflicts and redeclarations
that span more than one _Script_ are detected as runtime errors during
GlobalDeclarationInstantiation. If any such errors are detected, no
bindings are instantiated for the script. However, if the global object
is defined using Proxy exotic objects then the runtime tests for
conflicting declarations may be unreliable resulting in an abrupt
completion and some global declarations not being instantiated. If this
occurs, the code for the _Script_ is not evaluated.

Unlike explicit var or function declarations, properties that are
directly created on the global object result in global bindings that may
be shadowed by let/const/class declarations.

Runtime Semantics: ScriptEvaluationJob ( source )

The job ScriptEvaluationJob with parameter _source_ parses, validates,
and evaluates the _Script_ represented by _source_.

1.  Assert: _source_ is a _SourceCharacter_ sequence (see 10).

2.  3.  Parse _source_ using _Script_ as the goal symbol and analyze the
    parse result for any Early Error conditions. If the parse was
    successful and no early errors were found, then let _script_ the
    resulting parse tree. Otherwise, let _script_ be an indication of
    one or more parsing errors and/or early errors. Parsing and early
    error detection may be interweaved in an implementation dependent
    manner. If more than one parse or early error is present, the number
    and ordering of reported errors is implementation dependent but at
    least one error must be reported.

4.  If _script_ is an error indication, then

    a.  Report or log the error(s) in an implementation dependent
        manner.

    b.  Let _status_ be NormalCompletion(UNDEFINED).

5.  Else,

    a.  b.  c.  d.  Let _realm_ be the running execution context’s
        Realm.

    e.  Let _status_ be the result of ScriptEvaluation of _script_ with
        arguments _realm_ and FALSE.

6.  NextJob _status_.

NOTE An implementation may parse a _Script_ and analyze it for Early
Error conditions prior to the execution of the ScriptEvaluationJob for
that _Script_. However, the reporting of any errors must be deferred
until the ScriptEvaluationJob is actually executed.


Modules

Syntax

Module :

ModuleBody~opt~

ModuleBody :

ModuleItemList

ModuleItemList :

ModuleItem
ModuleItemList ModuleItem

ModuleItem :

ImportDeclaration
ExportDeclaration
StatementListItem

Module Static Semantics

Static Semantics: Early Errors

_ModuleBody_ : _ModuleItemList

-   It is a Syntax Error if the LexicallyDeclaredNames of
    _ModuleItemList_ contains any duplicate entries.

-   It is a Syntax Error if the ExportedBindings of _ModuleItemList_
    contains any duplicate entries.

-   It is a Syntax Error if any element of the LexicallyDeclaredNames of
    _ModuleItemList_ also occurs in the VarDeclaredNames of
    _ModuleItemList_.

-   It is a Syntax Error if _ModuleItemList_ Contains SUPER.

NOTE Additional error conditions relating to conflicting or duplicate
declarations are checked during module linking prior to evaluation of a
_Module_. If any such errors are detected the _Module_ is not evaluated.

Static Semantics: DeclaredNames

_Module_ : [empty]

1.  Return a new empty List.

_Module_ : _ModuleBody

1.  Let _names_ be LexicallyDeclaredNames of _ModuleBody_.

2.  Append to _names_ the elements of the VarDeclaratedNames of
    _ModuleBody._

3.  Return _names_.

Static Semantics: ExportedBindings

See also:15.2.2.2.

_ModuleItemList_ : [empty]

1.  Return a new empty List.

_ModuleItemList_ : _ModuleItemList_ _ModuleItem

1.  Let _names_ be ExportedBindings of _ModuleItemList_.

2.  Append to _names_ the elements of the ExportedBindings of
    _ModuleItem._

3.  Return _names_.

ModuleItem :

ImportDeclaration
StatementListItem

1.  Return a new empty List.

Static Semantics: ExportEntries

See also:15.2.2.3.

_ModuleItemList_ : [empty]

1.  Return a new empty List.

_ModuleItemList_ : _ModuleItemList_ _ModuleItem

1.  Let _entries_ be ExportEntries of _ModuleItemList_.

2.  Append to _entries_ the elements of the ExportEntries of
    _ModuleItem._

3.  Return _entries_.

ModuleItem :

ImportDeclaration
StatementListItem

1.  Return a new empty List.

Static Semantics: ImportedBindings

_ModuleItemList_ : [empty]

1.  Return a new empty List.

_ModuleItemList_ : _ModuleItemList_ _ModuleItem

1.  Let _names_ be ImportedBindings of _ModuleItemList_.

2.  Append to _names_ the elements of the ImportedBindings of
    _ModuleItem._

3.  Return _names_.

_ModuleItem_ : _ImportDeclaration

1.  Return the BoundNames of _ImportDeclaration_.

ModuleItem :

ExportDeclaration
StatementListItem

1.  Return a new empty List.

Static Semantics: ImportEntries

See also:15.2.1.3.

_ModuleItemList_ : [empty]

1.  Return a new empty List.

_ModuleItemList_ : _ModuleItemList_ _ModuleItem

1.  Let _entries_ be ImportEntries of _ModuleItemList_.

2.  Append to _entries_ the elements of the ImportEntries of
    _ModuleItem._

3.  Return _entries_.

ModuleItem :

ExportDeclaration
StatementListItem

1.  Return a new empty List.

Static Semantics: IsStrict

See also: 14.1.13, 15.1.2.

_ModuleBody_ : _ModuleItemList

1.  Return TRUE.

Static Semantics: KnownExportEntries

_ModuleBody_ : _ModuleItemList

1.  Let _allExports_ be ExportEntries of _ModuleItemList_.

2.  Return a new List containing all the entries of _allEntries_ whose
    [[ImportName]] field is not all.

Static Semantics: ModuleRequests

See also: 15.2.1.5, 15.2.2.5.

_ModuleItemList_ : [empty]

1.  Return a new empty List.

_ModuleItemList_ : _ModuleItem

1.  Return ModuleRequests of _ModuleItem_.

_ModuleItemList_ : _ModuleItemList_ _ModuleItem

1.  Let _moduleNames_ be ModuleRequests of _ModuleItemList_.

2.  Let _additionalNames_ be ModuleRequests of _ModuleItem.

3.  Append to _moduleNames_ each element of _additionalNames_ that is
    not already an element of _moduleNames._

4.  Return _moduleNames_.

_ModuleItem_ : _StatementListItem

1.  Return a new empty List.

Static Semantics: LexicallyDeclaredNames

See also: 13.1.2, 13.11.2, 13.12.4, 14.1.14, 14.2.10, 15.1.3.

_ModuleItemList_ : [empty]

1.  Return a new empty List.

_ModuleItemList_ : _ModuleItemList_ _ModuleItem

1.  Let _names_ be LexicallyDeclaredNames of _ModuleItemList_.

2.  Append to _names_ the elements of the LexicallyDeclaredNames of
    _ModuleItem._

3.  Return _names_.

_ModuleItem_ : _ImportDeclaration

1.  Return the BoundNames of _ImportDeclaration_.

_ModuleItem_ : _ExportDeclaration

1.  If _ExportDeclaration_ is EXPORT _VariableStatement_; then return a
    new empty List.

2.  Return the BoundNames of _ExportDeclaration_.

_ModuleItem_ : _StatementListItem

1.  Return LexicallyDeclaredNames of _StatementListItem_.

NOTE At the top level of a _Module_, function declarations are treated
like lexical declarations rather than like var declarations.

Static Semantics: LexicallyScopedDeclarations

See also: 13.1.3, 13.11.3, 13.12.5, 14.1.15, 14.2.11, 15.1.4.

_ModuleItemList_ : [empty]

1.  Return a new empty List.

_ModuleItemList_ : _ModuleItemList_ _ModuleItem

1.  Let _declarations_ be LexicallyScopedDeclarations of
    _ModuleItemList_.

2.  Append to _declarations_ the elements of the
    LexicallyScopedDeclarations of _ModuleItem._

3.  Return _declarations_.

_ModuleItem_ : _ImportDeclaration

1.  If the BoundNames of _ImportDeclarations_ is empty, then return an
    empty List.

2.  Return a new List containing _ImportDeclaration_.

_ModuleItem_ : _ExportDeclaration

1.  If _ExportDeclaration_ is EXPORT _Declaration_; then return a new
    List containing _Declaration_.

2.  Return a new empty List.

Static Semantics: UnknownExportEntries

_ModuleBody_ : _ModuleItemList

1.  Let _allExports_ be ExportEntries of _ModuleItemList_.

2.  Return a new List containing all the entries of _allEntries_ whose
    [[ImportName]] field is all.

Static Semantics: VarDeclaredNames

See also: 13.0.1, 13.1.8, 13.2.2.2, 13.5.2, 13.6.1.1, 13.6.2.1,
13.6.3.1, 13.6.4.3, , 13.11.4, 13.12.10, 13.14.2, 14.1.17, 14.2.13,
15.1.5,.

_ModuleItemList_ : _ModuleItemList_ _ModuleItem

1.  Let _names_ be VarDeclaredNames of _ModuleItemList_.

2.  Append to _names_ the elements of the VarDeclaredNames of
    _ModuleItem._

3.  Return _names_.

_ModuleItem_ : _ImportDeclaration

1.  Return an empty List.

_ModuleItem_ : _ExportDeclaration

1.  If _ExportDeclaration_ is EXPORT _VariableStatement_; then return
    BoundNames of _ExportDeclaration_.

2.  Return a new empty List.

Static Semantics: VarScopedDeclarations

See also: 13.0.2, 13.1.9, 13.2.2.3, 13.5.3, 13.6.1.2, 13.6.2.2,
13.6.3.3, 13.6.4.4, 13.10.3, 13.11.5, 13.12.11, 13.14.3, 14.1.18,
14.2.14, 15.1.6.

_ModuleItemList_ : [empty]

1.  Return a new empty List.

_ModuleItemList_ : _ModuleItemList_ _ModuleItem

1.  Let _declarations_ be VarScopedDeclarations of _ModuleItemList_.

2.  Append to _declarations_ the elements of the VarScopedDeclarations
    of _ModuleItem._

3.  Return _declarations_.

_ModuleItem_ : _ImportDeclaration

1.  Return a new empty List.

_ModuleItem_ : _ExportDeclaration

1.  If _ExportDeclaration_ is EXPORT _VariableStatement_; then return
    VarScopedDeclarations of _VariableStatement_.

2.  Return a new empty List.

Runtime Semantics: ModuleDeclarationInstantiation( code, env )

TO DO

1.  Let _declarations_ be the LexicallyScopedDeclarations of _code_.

2.  Let _functionsToInitialize_ be an empty List.

3.  For each element _d_ in _declarations_ do

    a.  For each element _dn_ of the BoundNames of _d_ do

        i.  If IsConstantDeclaration of _d_ is TRUE, then

            1.  Call _env_’s CreateImmutableBinding concrete method
                passing _dn_ as the argument.

        ii. Else,

            1.  Let _status_ be the result of calling _env_’s
                CreateMutableBinding concrete method passing _dn_ and
                FALSE as the arguments.

            2.  Assert: _status_ is never an abrupt completion.

    b.  If _d_ is a _GeneratorDeclaration_ production or a
        _FunctionDeclaration_ production, then

        i.  Append _d_ to _functionsToInitialize_.

4.  For each production _f_ in _functionsToInitialize_, in list order do

    a.  Let _fn_ be the sole element of the BoundNames of _f._

    b.  Let _fo_ be the result of performing InstantiateFunctionObject
        for _f_ with argument _env_.

    c.  Call _env_’s InitializeBinding concrete method passing _fn_, and
        _fo_ as the arguments.

Imports

Syntax

ImportDeclaration :

ModuleImport
IMPORT ImportClause FromClause ;
IMPORT ModuleSpecifier ;

ModuleImport :

MODULE [no LineTerminator here] ImportedBinding FromClause ;

FromClause :

FROM ModuleSpecifier

ImportClause :

ImportedBinding
ImportedBinding , NamedImports
NamedImports

NamedImports :

{ }
{ ImportsList }
{ ImportsList , }

ImportsList :

ImportSpecifier
ImportsList , ImportSpecifier

ImportSpecifier :

ImportedBinding
IdentifierName AS ImportedBinding

ModuleSpecifier :

StringLiteral

ImportedBinding :

BindingIdentifier

Static Semantics: Early Errors

_ModuleItem_ : _ImportDeclaration

-   It is a Syntax Error if the BoundNames of _ImportDeclaration_
    contains any duplicate entries.

Static Semantics: BoundNames

See also: 13.2.1.2, 13.2.2.1, 12.1.2, 13.6.4.2, 14.1.3, 14.2.2, 14.4.2,
14.5.2, 15.2.2.1.

_ImportDeclaration_ : IMPORT _ImportClause_ _FromClause_ ;

1.  Return the BoundNames of _ImportClause_.

_ImportDeclaration_ : IMPORT _ModuleSpecifier_ ;

1.  Return a new empty List.

_ModuleImport_ : MODULE _ImportedBinding_ _FromClause_ ;

1.  Return the BoundNames of _ImportedBinding_.

_ImportClause_ : _ImportedBinding_ , _NamedImports

1.  Let _names_ be the BoundNames of _ImportedBinding_.

2.  Append to _names_ the elements of the BoundNames of _NamedImports_.

3.  Return _names_.

_NamedImports_ : { }

1.  Return a new empty List.

_ImportsList_ : _ImportsList_ , _ImportSpecifier

1.  Let _names_ be the BoundNames of _ImportsList_.

2.  Append to _names_ the elements of the BoundNames of
    _ImportSpecifier_.

3.  Return _names_.

_ImportSpecifier_ : _IdentifierName_ AS _ImportedBinding

1.  Return the BoundNames of _ImportedBinding_.

Static Semantics: ImportEntries

See also:15.2.0.6.

_ImportDeclaration_ : IMPORT _ImportClause_ _FromClause_ ;

1.  Let _module_ be the sole element of ModuleRequests of _FromClause_.

2.  Return ImportEntriesForModule of _ImportClause_ with argument
    _module_.

_ImportDeclaration_ : IMPORT _ModuleSpecifier_ ;

1.  Return a new empty List.

_ModuleImport_ : MODULE _ImportedBinding_ _FromClause_ ;

1.  Let _module_ be ModuleRequests of _FromClause_.

2.  Let _localName_ be the StringValue of _ImportedBinding_.

3.  Let _entry_ be the Record {[[ModuleRequest]]: _module_,
    [[ImportName]]: "DEFAULT", [[LocalName]]: _localName_ }.

4.  Return a new List containing _entry_.

Static Semantics: ImportEntriesForModule

  With parameter _module_.

_ImportClause_ : _ImportedBinding

1.  Let _localName_ be the StringValue of _ImportedBinding_.

2.  Let _defaultEntry_ be the Record {[[ModuleRequest]]: _module_,
    [[ImportName]]: "DEFAULT", [[LocalName]]: _localName_ }.

3.  Return a new List containing _defaultEntry.

_ImportClause_ : _ImportedBinding_ , _NamedImports

1.  Let _localName_ be the StringValue of _ImportedBinding_.

2.  Let _defaultEntry_ be the Record {[[ModuleRequest]]: _module_,
    [[ImportName]]: "DEFAULT", [[LocalName]]: _localName_ }.

3.  Let _entries_ be a new List containing _defaultEntry.

4.  Append to _entries_ the elements of the ImportEntriesForModule of
    _NamedImports_ with argument _module_.

5.  Return _entries_.

_NamedImports_ : { }

1.  Return a new empty List.

_ImportsList_ : _ImportsList_ , _ImportSpecifier

1.  Let _specs_ be the ImportEntriesForModule of _ImportsList_ with
    argument _module_.

2.  Append to _specs_ the elements of the ImportEntriesForModule of
    _ImportSpecifier_ with argument _module_.

3.  Return _specs_.

_ImportSpecifier_ : _ImportedBinding

1.  Let _localName_ be the StringValue of _ImportedBinding_.

2.  Let _entry_ be the Record {[[ModuleRequest]]: _module_,
    [[ImportName]]: _localName_ , [[LocalName]]: _localName_ }.

3.  Return a new List containing _entry_.

_ImportSpecifier_ : _IdentifierName_ AS _ImportedBinding

1.  Let _importName_ be the StringValue of _IdentifierName_.

2.  Let _localName_ be the StringValue of _ImportedBinding_.

3.  Let _entry_ be the Record {[[ModuleRequest]]: _module_,
    [[ImportName]]: _importName_, [[LocalName]]: _localName_ }.

4.  Return a new List containing _entry_.

Static Semantics: ModuleRequests

See also: 15.2.0.9, 15.2.2.5.

_ImportDeclaration_ : IMPORT _ImportClause_ _FromClause_ ;

1.  Return ModuleRequests of _FromClause_.

_ModuleImport_ : MODULE _ImportedBinding_ _FromClause_ ;

1.  Return ModuleRequests of _FromClause_.

_ModuleSpecifier_ : _StringLiteral

1.  Return a List containing the StringValue of _StringLiteral_.

Runtime Semantics: Module Objects

_ModuleImport_ : MODULE _ImportedBinding FromClause_ ;

An _ModuleImport_ imports a module and introduces a single binding
within the containing module environment. The value of such a binding as
a Module object.

A Module object is an exotic object whose own properties corresponding
corresponding to the ExportedBindings of the module identifed by the
_ModuleImport_ _FromClause_. Each property name is the StringValue of
the corresponding exported binding. These are the only properties of an
Module object. Each one is a read-only property with attributes
{[[Configurable]]: FALSE, [[Enumerable]]: TRUE}. Module objects are not
extensible.

TO DO

Needs to decide whether a module object is an ordinary or an exotic
object. Whether properties are accessor or defined via [[Get]], etc.

Exports

Syntax

ExportDeclaration :

EXPORT * FromClause ;
EXPORT ExportClause~[NoReference]~ FromClause ;
EXPORT ExportClause ;
EXPORT VariableStatement
EXPORT Declaration~[Default]~
EXPORT DEFAULT AssignmentExpression~[In]~ ;

ExportClause~[NoReference]~ :

{ }
{ ExportsList~[?NoReference]~ }
{ ExportsList~[?NoReference]~ , }

ExportsList~[NoReference]~ :

ExportSpecifier~[?NoReference]~
ExportsList~[?NoReference]~ , ExportSpecifier~[?NoReference]~

ExportSpecifier~[NoReference]~ :

[~NoReference] IdentifierReference
[~NoReference] IdentifierReference AS IdentifierName
[+NoReference] IdentifierName
[+NoReference] IdentifierName AS IdentifierName

NOTE _ExportSpecifier_ is used to export bindings from the enclosing
module _Module_. _ExportSpecifier_~[NoReference]~ is used to export
bindings from a referenced _Module_. In that case _IdentifierReference_
restrictions are not applied to the naming of the items to be exported
because they are not used to create local bindings.

Static Semantics: BoundNames

See also: 13.2.1.2, 13.2.2.1, 12.1.2, 13.6.4.2, 14.1.3, 14.2.2, 14.4.2,
14.5.2, 15.2.1.2.

ExportDeclaration :

EXPORT * FromClause ;
EXPORT ExportClause FromClause ;
EXPORT ExportClause ;

1.  Return a new empty List.

_ExportDeclaration_ : EXPORT _VariableStatement_ ;

1.  Return the BoundNames of _VariableStatement_.

_ExportDeclaration_ : EXPORT _Declaration_;

1.  Return the BoundNames of _Declaration_.

_ExportDeclaration_ : EXPORT DEFAULT _AssignmentExpression_;

1.  Return a List containing "DEFAULT".

Static Semantics: ExportedBindings

See also:15.2.0.2.

_ExportDeclaration_ : EXPORT * _FromClause_ ;

1.  Return a new empty List.

ExportDeclaration :

EXPORT ExportClause FromClause ;
EXPORT ExportClause ;

1.  Return the ExportedBindings of this _ExportClause_.

ExportDeclaration :

EXPORT VariableStatement
EXPORT Declaration~[Default]~

1.  Return the BoundNames of this _ExportDeclaration_.

_ExportDeclaration_ : EXPORT DEFAULT _AssignmentExpression_;

1.  Return a List containing "DEFAULT".

_ExportClause_ : { }

1.  Return a new empty List.

_ExportsList_ : _ExportsList_, _ExportSpecifier

1.  Let _names_ be the ExportedBindings of _ExportsList_.

2.  Append to _names_ the elements of the ExportedBindings of
    _ExportSpecifier_.

3.  Return _names_.

1.  

_ExportSpecifier_ : _IdentifierReference

1.  Return a List containing the StringValue of _IdentifierReference_.

_ExportSpecifier_ : _IdentifierReference_ AS _IdentifierName

1.  Return a List containing the StringValue of _IdentifierName_.

_ExportSpecifier_ : _IdentifierName

1.  Return a List containing the StringValue of _IdentifierName_.

_ExportSpecifier_ : _IdentifierName_ AS _IdentifierName

1.  Return a List containing the StringValue of the second
    _IdentifierName_.

Static Semantics: ExportEntries

See also:15.2.0.4.

ExportDeclaration : EXPORT * FromClause ;

1.  Let _module_ be the sole element of ModuleRequests of _FromClause_.

2.  Let _entry_ be the Record {[[ModuleRequest]]: _module_,
    [[ImportName]]: all, [[LocalName]]: NULL, [[ExportName]]: NULL }.

3.  Return a new List containing _entry_.

ExportDeclaration : EXPORT ExportClause FromClause ;

1.  Let _module_ be the sole element of ModuleRequests of _FromClause_.

2.  Return ExportEntriesForModule of _ExportClause_ with argument
    _module_.

ExportDeclaration : EXPORT ExportClause ;

1.  2.  Return ExportEntriesForModule of _ExportClause_ with argument
    NULL.

ExportDeclaration : EXPORT VariableStatement;

1.  Let _entries_ be a new empty List.

2.  Let _names_ be the BoundNames of _VariableStatement_.

3.  Repeat for each _name_ in _names, 

    a.  Append to _entries_ the Record {[[ModuleRequest]]: NULL,
        [[ImportName]]: NULL, [[LocalName]]: _name_, [[ExportName]]:
        _name_ }.

4.  Return _entries_.

ExportDeclaration : EXPORT Declaration;

1.  Let _entries_ be a new empty List.

2.  Let _names_ be the BoundNames of _Declaration_.

3.  Repeat for each _name_ in _names, 

    a.  Append to _entries_ the Record {[[ModuleRequest]]: NULL,
        [[ImportName]]: NULL, [[LocalName]]: _name_, [[ExportName]]:
        _name_ }.

4.  Return _entries_.

_ExportDeclaration_ : EXPORT DEFAULT _AssignmentExpression_;

1.  Let _entry_ be the Record {[[ModuleRequest]]: NULL, [[ImportName]]:
    NULL, [[LocalName]]: "DEFAULT", [[ExportName]]: "DEFAULT"}.

2.  Return a new List containing _entry_.

Static Semantics: ExportEntriesForModule

  With parameter _module_.

_ExportClause_ : { }

1.  Return a new empty List.

_ExportsList_ : _ExportsList_ , _ExportSpecifier

1.  Let _specs_ be the ExportEntriesForModule of _ExportsList_ with
    argument _module_.

2.  Append to _specs_ the elements of the ExportEntriesForModule of
    _ExportSpecifier_ with argument _module_.

3.  Return _specs_.

_ExportSpecifier_ : _IdentifierReference

1.  Let _localName_ be the StringValue of _IdentifierReference_.

2.  Return a new List containing the Record {[[ModuleRequest]]:
    _module_, [[ImportName]]: NULL, [[LocalName]]: _localName_,
    [[ExportName]]: _localName_ }.

_ExportSpecifier_ : _IdentifierReference_ AS _IdentifierName

1.  Let _localName_ be the StringValue of _IdentifierReference_.

2.  Let _exportName_ be the StringValue of _IdentifierName_.

3.  Return a new List containing the Record {[[ModuleRequest]]:
    _module_, [[ImportName]]: NULL, [[LocalName]]: _localName_,
    [[ExportName]]: _exportName_ }.

_ExportSpecifier_ : _IdentifierName

1.  Let _sourceName_ be the StringValue of _IdentifierName_.

2.  Return a new List containing the Record {[[ModuleRequest]]:
    _module_, [[ImportName]]: _sourceName_, [[LocalName]]: NULL,
    [[ExportName]]: _sourceName_ }.

_ExportSpecifier_ : _IdentifierName_ AS _IdentifierName

1.  Let _sourceName_ be the StringValue of the first _IdentifierName_.

2.  Let _exportName_ be the StringValue of the second _IdentifierName_.

3.  Return a new List containing the Record {[[ModuleRequest]]:
    _module_, [[ImportName]]: _sourceName_, [[LocalName]]: NULL,
    [[ExportName]]: _exportName_ }.

Static Semantics: ModuleRequests

See also: 15.2.0.9, 15.2.1.5.

_ExportDeclaration_ : EXPORT _ExportClause_ _FromClause_ ;

1.  Return the ModuleRequests of _FromClause_.

ExportDeclaration :

EXPORT ExportClause ;
EXPORT VariableStatement
EXPORT Declaration
EXPORT DEFAULT AssignmentExpression ;

1.  Return a new empty List.

Runtime Semantics: Loader State

Loader Records and Loader Objects

Loader Records contain the state of a of distinct module loading
context. Each Loader Record has the fields defined in Table 35. Loader
objects (26.3) are ECMAScript objects that permit ECMAScript code to
define and manage module loading contexts.

Table 35 — Loader Record Fields

  -------------- -------------------------------------------------------------------------------------------- -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  _FIELD NAME_   _VALUE TYPE_                                                                                 _MEANING_

  [[Realm]]      Realm Record                                                                                 The Realm associated with the loader. All scripts and modules evaluated by this loader run in the scope of the global object associated with this Realm.

  [[Modules]]    List of                                                                                      Normalized names bound to fully linked Module records. The list can contain modules whose code has not yet been evaluated. However, except for the case of cyclic imports, such modules are not exposed to user code.
                                                                                                              
                 Record {[[Name]], [[Module]]} where [[Name]] is a String and [[Module]] is a Module Record   

  [[Loads]]      List of Load Record                                                                          Outstanding asynchronous module load requests that have been made to this loader.

  [[LoaderObj]   Object or Undefined                                                                          The Loader object (26.3) that reflects this Loader Record.
  -------------- -------------------------------------------------------------------------------------------- -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

CreateLoaderRecord(realm, object) Abstract Operation

The abstract operation CreateLoaderRecord creates and returns a new
Loader Record. The argument _realm_ is the Realm record that will be
associated with Loader. The argument _object_ is the either UNDEFINED or
the Loader object that will reflect this Loader record.

The following steps are taken:

1.  Let _loader_ be a new Loader Record.

2.  Set _loader_.[[Realm]] to _realm_.

3.  Set _loader_.[[Modules]] to a new empty List.

4.  Set _loader_.[[Loads]] to a new empty List.

5.  Set _loader_.[[LoaderObj]] to _object_.

6.  Return _loader_.

Load Records and LoadRequest Objects

The Load Record represents an attempt to locate, fetch, translate, and
parse a single module.

Each Load Record has the fields defined in Table 36:

Table 36 — Load Record Fields

  ------------------ -------------------------------------------------- -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  _FIELD NAME_       _VALUE TYPE_                                       _MEANING_
  [[Status]]         One of: "LOADING", "LOADED", "LINKED", "FAILED".   The current state of this Load request.
  [[Name]]           String | UNDEFINED                                 The normalized name of the module being loaded, or UNDEFINED if loading an anonymous module.
  [[LinkSets]]       List of LinkSet Record                             A List of all LinkSets that require this Load request to succeed. There is a many-to-many relation between Load records and LinkSets. A single IMPORT() call can have a large dependency tree, involving many Load records. Many IMPORT() calls, if they depend on the same module, can be waiting for a single Load to complete.
  [[Metadata]]       Object                                             An object passed to each loader hook which hooks may use for any purpose.
  [[Address]]        Object | UNDEFINED                                 The result of the locate hook.
  [[Source]]         String | UNDEFINED                                 The result of the translate hook.
  [[Kind]]           One of: UNDEFINED, dynamic, declarative            Once the Load reaches the "LOADED" state, either declarative or dynamic. If the instantiate hook returned UNDEFINED, the module is declarative, and _load_.[[Body]] contains a Module parse. Otherwise, the instantiate hook returned a ModuleFactory object and [[Execute]] contains the .execute callable object.
  [[Body]]           UNDEFINED or a parse result                        If [[Kind]] is DECLARATIVE, the parse of a _Module_ production. Otherwise UNDEFINED.
  [[Execute]]                                                           If [[Kind]] is DYNAMIC, the value of FACTORY.EXECUTE. Otherwise UNDEFINED.
  [[Dependencies]]   Undefined or List of Records                       If [[Status]] is not "LOADING", a List of pairs. Each pair consists of two strings: a module name as it appears in a module, import, or export from declaration in _load_.[[Body]], and the corresponding normalized module name.
  [[GroupIndex]]     Number                                             Largerest Dependency group count
  [[Exception]]                                                         If [[Status]] is "failed", the exception value that was thrown, causing the load to fail. Otherwise, null.
  [[Module]]                                                            The Module object produced by this load, or UNDEFINED.
  ------------------ -------------------------------------------------- -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

A LoadRequest object is an ordinary Object, inheriting from
OBJECT.PROTOTYPE with own data properties whose values corresponding
certain fields of a corresonding Load Record. A LoadRequest object is
created when the value of those fields need to be passed to an
ECMAScript function. Every LoadRequest object has NAME, and METADATA
properties corresponding to the [[Name]] and [[Metadata]] fields of a
Load Record. A LoadRequest object may also have ADDRESS and SOURCE
properties corresponding to the [[Address]] and [[Source]] fields of a
Load record.

CreateLoad(name) Abstract Operation

The abstract operation CreateLoad creates and returns a new Load Record.
The argument _name_ is either UNDEFINED, indicating an anonymous module,
or a normalized module name.

The following steps are taken:

1.  Let _load_ be a new Load Record.

2.  Set _load_.[[Status]] to "LOADING".

3.  Set _load_.[[Name]] to _name_.

4.  Set _load_.[[LinkSets]] to a new empty List.

5.  Set _load_.[[Metadata]] to _metadata
    ObjectCreate(%ObjectPrototype%).

6.  Set all other fields of _load_ to UNDEFINED.

7.  Return _load_.

CreateLoadRequestObject(name, metadata, address, source) Abstract Operation

The abstract operation CreateLoadRequestObject performed with arguments
_name_, _metadata_, and optional arguments _address_ and _source
returns a new LoadRequest Object. It performs the following steps:

1.  Let _obj_ be ObjectCreate(%ObjectPrototype%, ()).

2.  Assert: The following operations will never result in abrupt
    completions.

3.  Perform CreateDataProperty (_obj_, "NAME", _name_).

4.  Perform CreateDataProperty (_obj_, "METADATA", _metadata_).

5.  If _address_ was passed, then perform CreateDataProperty (_obj_,
    "ADDRESS", _address_).

6.  If _source_ was passed, then perform CreateDataProperty (_obj_,
    "SOURCE", _source_).

7.  Return _obj_.

Runtime Semantics: Module Loading

LoadModule(loader, name, options) Abstract Operation

The following steps are taken:

1.  Assert: _loader_ is a Loader record.

2.  Let _name_ be ToString(_name_).

3.  ReturnIfAbrupt(_name_).

4.  Let _address_ be GetOption(_options_, "ADDRESS").

5.  ReturnIfAbrupt(_address_).

6.  If _address_ is UNDEFINED, let _step_ be "LOCATE".

7.  Else, let _step_ be "FETCH".

8.  Let _metadata_ be ObjectCreate(%ObjectPrototype%).

9.  Return PromiseOfStartLoadPartwayThrough( _step_, _loader_, _name_,
    _metadata_, _source_, _address_).

RequestLoad(loader, request, refererName, refererAddress) Abstract Operation

The RequestLoad abstract operation normalizes the given module name,
_request_, and returns a Promise object that resolves to the value of a
Load object for the given module.

The _loader_ argument is a Loader record.

_request_ is the (non-normalized) name of the module to be imported, as
it appears in the import-declaration or as the argument to LOADER.LOAD()
or LOADER.IMPORT().

_refererName_ and _refererAddress_ provide information about the context
of the IMPORT() call or import-declaration. This information is passed
to all the _loader_ hooks.

If the requested module is already in the _loader_'s module registry,
RequestLoad returns a Promise object for a Load with the [[Status]]
field set to "LINKED". If the requested module is loading or loaded but
not yet linked, RequestLoad returns a Promise object for an existing
Load object from _loader_.[[Loads]]. Otherwise, RequestLoad starts
loading the module and returns a Promise object for a new Load Record.

The following steps are taken:

1.  Let _F_ be a new anonymous function as defined by CallNormalize.

2.  Set _F_’s [[Loader]] internal slot to _loader_.

3.  Set _F_’s [[Request]] internal slot to _request_.

4.  Set _F_’s [[RefererName]] internal slot to _refererName_.

5.  Set _F_’s [[RefererAddress]] internal slot to _refererAddress_.

6.  Let _p_ be PromiseNew(_F_).

7.  Let _G_ be a new built-in function as defined by GetOrCreateLoad.

8.  Set _G_’s [[Loader]] internal slot to _loader_.

9.  Return PromiseThen(_p_, _G_).

CallNormalize(resolve, reject) Functions

A CallNormalize function is an anonymous built-in function that calls a
_loader_'s normalize hook.

Each CallNormalize function has internal slots [[Loader]], [[Request]],
[[RefererName]], and [[RefererAddress]].

When a CallNormalize function _F_ is called with arguments _resolve_ and
_reject_, the following steps are taken:

1.  Let _loader_ be the value of _F_’s [[Loader]] internal slot.

2.  Let _request_ be _F_’s [[Request]] internal slot.

3.  Let _refererName_ be the value of _F_’s [[RefererName]] internal
    slot.

4.  Let _refererAddress_ be the value of _F_’s [[RefererAddress]]
    internal slot.

5.  Let _loaderObj_ be _loader_.[[LoaderObj]].

6.  Let _normalizeHook_ be Get(_loaderObj_, "NORMALIZE").

7.  Let _name_ be the result of calling the [[Call]] internal method of
    _normalizeHook_ passing _loaderObj_ and (_request_, _refererName_,
    _refererAddress_) as arguments.

8.  ReturnIfAbrupt(_name_).

9.  Return the result of calling the [[Call]] internal method of
    _resolve_ passing UNDEFINED and (_name_) as arguments.

GetOrCreateLoad(name) Functions

A GetOrCreateLoad function is an anonymous function that gets or creates
a Load Record for a given module _name_.

Each GetOrCreateLoad function has a [[Loader]] internal slot.

When a GetOrCreateLoad function _F_ is called with argument _name_, the
following steps are taken:

1.  Let _loader_ be _F_’s [[Loader]] internal slot.

2.  Let _name_ be ToString(_name_).

3.  ReturnIfAbrupt(_name_).

4.  Let _modules_ be the value of _loaderRecord._[[Modules]],

5.  Repeat for each Record {[[key]], [[value]]} _p_ that is an element
    of _loader_.[[Modules], do

    a.  If SameValue(_p_.[[key]], _name_) is TRUE, then

        i.  Let _existingModule_ be the [[value]] field of that Record.

        ii. Let _load_ be CreateLoad(_name_).

        iii. Set _load_.[[Status]] to "LINKED".

        iv. Set _load_.[[Module]] to _existingModule_.

        v.  Return _load_.

6.  Repeat for each Record _load_ that is an element of
    _loader_.[[Loads]], do

    a.  If SameValue(_load_.[[Name]], _name_) is TRUE, then

        i.  Assert: _load_.status is either "LOADING" or "LOADED".

        ii. Return _load_.

7.  Let _load_ be CreateLoad(_name_).

8.  Append _load_ to the end of the List _loader_.[[Loads]].

9.  Call ProceedToLocate(_loader_, _load_).

10. Return _load_.

ProceedToLocate(loader, load, p) Abstract Operation

The ProceedToLocate abstract operation continues the asynchronous
loading process at the LOCATE hook.

ProceedToLocate performs the following steps:

1.  Let _p_ be PromiseOf(UNDEFINED).

2.  Let _F_ be a new built-in function object as defined in CallLocate.

3.  Set _F_’s [[Loader]] internal slot to _loader_.

4.  Set _F_’s [[Load]] internal slot to _load_.

5.  Let _p_ be PromiseThen(_p_, _F_).

6.  Return ProceedToFetch(_loader_, _load_, _p_).

CallLocate Functions

A CallLocate function is an anonymous built-in function that calls the
LOCATE loader hook. Each CallLocate function has [[Loader]] and [[Load]]
internal slots.

When a CallLocate function _F_ is called, the following steps are taken:

1.  Let _loader_ be the value of _F_’s [[Loader]] internal slot.

2.  Let _load_ be the value of _F_’s [[Load]] internal slot.

3.  Let _loaderObj_ be _loader_.[[LoaderObj]].

4.  Let _hook_ be Get(_loaderObj_, "LOCATE").

5.  ReturnIfAbrupt(_hook_).

6.  If IsCallable(_hook_) is FALSE, throw a TYPEERROR exception.

7.  Let _obj_ be CreateLoadRequestObject(_load_.[[Name]],
    _load_.[[Metadata]]).

8.  Return the result of calling the [[Call]] internal method of _hook
    with _loaderObj_ and (_obj_) as arguments.

ProceedToFetch(loader, load, p) Abstract Operation

The ProceedToFetch abstract operation continues the asynchronous loading
process at the FETCH hook by performing the following steps:

1.  Let _F_ be a new built-in function object as defined in CallFetch.

2.  Set _F_’s [[Loader]] internal slot to _loader_.

3.  Set _F_’s [[Load]] internal slot to _load_.

4.  Set _F_’s [[AddressPromise]] internal slot to _p_.

5.  Let _p_ be PromiseThen(_p_, _F_).

6.  Return ProceedToTranslate(_loader_, _load_, _p_).

CallFetch(address) Functions

A CallFetch function is an anonymous built-in function that calls the
FETCH loader hook. Each CallFetch function has [[Loader]] and [[Load]]
internal slots.

When a CallFetch function _F_ is called with argument _address_, the
following steps are taken:

1.  Let _loader_ be the value of _F_’s [[Loader]] internal slot.

2.  Let _load_ be the value of _F_’s [[Load]] internal slot.

3.  If _load_.[[LinkSets]] is an empty List, return UNDEFINED.

4.  Set _load_.[[Address]] to _address_.

5.  Let _loaderObj_ be _loader_.[[LoaderObj]].

6.  Let _hook_ be Get(_loaderObj_, "FETCH").

7.  ReturnIfAbrupt(_hook_).

8.  If IsCallable(_hook_) is false, throw a TYPEERROR exception.

9.  Let _obj_ be CreateLoadRequestObject(_load_.[[Name]],
    _load_.[[Metadata]], _address_).

10. Return the result of calling the [[Call]] internal method of _hook
    with _loaderObj_ and (_obj_) as arguments.

ProceedToTranslate(loader, load, p) Abstract Operation

The ProceedToTranslate abstract operation continues the asynchronous
loading process at the TRANSLATE hook hook by performing performs the
following steps:

1.  Let _F_ be a new function object as defined in CallTranslate.

2.  Set _F_’s [[Loader]] internal slot to _loader_.

3.  Set _F_’s [[Load]] internal slot to _load_.

4.  Let _p_ be PromiseThen(_p_, _F_).

5.  Let _F_ be a new function object as defined in CallInstantiate.

6.  Set _F_’s [[Loader]] internal slot to _loader_.

7.  Set _F_’s [[Load]] to internal slot _load_.

8.  Let _p_ be PromiseThen(_p_, _F_).

9.  Let _F_ be a new function object as defined in InstantiateSucceeded.

10. Set _F_’s [[Loader]] to internal slot _loader_.

11. Set _F_’s [[Load]] to internal slot _load_.

12. Let _p_ be PromiseThen(_p_, _F_).

13. Let _F_ be a new function object as defined in LoadFailed.

14. Set _F_’s [[Load]] internal slot to _load_.

15. Return PromiseCatch(_p_, _F_).

CallTranslate Functions

A CallTranslate function is an anonymous built-in function that calls
the TRANSLATE loader hook. Each CallTranslate function has [[Loader]]
and [[Load]] internal slots.

When a CallTranslate function _F_ is called with argument _source_, the
following steps are taken:

1.  Let _loader_ be the value of _F_’s [[Loader]] internal slot.

2.  Let _load_ be the value of _F_’s [[Load]] internal slot.

3.  If _load_.[[LinkSets]] is an empty List, return UNDEFINED.

4.  Let _loaderObj_ be _loader_.[[LoaderObj]].

5.  Let _hook_ be Get(_loaderObj_, "TRANSLATE").

6.  ReturnIfAbrupt(_hook_).

7.  If IsCallable(_hook_) is false, throw a TYPEERROR exception.

8.  Let _obj_ be CreateLoadRequestObject(_load_.[[Name]],
    _load_.[[Metadata]], _load_.[[Address]], _source_).

9.  Return the result of calling the [[Call]] internal method of _hook
    with _loaderObj_ and (_obj_) as arguments.

CallInstantiate Functions

A CallInstantiate function is an anonymous built-in function that calls
the INSTANTIATE _loader_ _hook_. Each CallInstantiate function has
[[Loader]] and [[Load]] internal slots.

When a CallInstantiate function _F_ is called with argument _source_,
the following steps are taken:

1.  Let _loader_ be the value of _F_’s [[Loader]] internal slot.

2.  Let _load_ be the value of _F_’s [[Load]] internal slot.

3.  If _load_.[[LinkSets]] is an empty List, return UNDEFINED.

4.  Set _load_.[[Source]] to _source_.

5.  Let _loaderObj_ be _loader_.[[LoaderObj]].

6.  Let _hook_ be Get(_loaderObj_, "INSTANTIATE").

7.  ReturnIfAbrupt(_hook_).

8.  If IsCallable(_hook_) is FALSE, throw a TYPEERROR exception.

9.  Let _obj_ be CreateLoadRequestObject(_load_.[[Name]],
    _load_.[[Metadata]], _load_.[[Address]], _source_).

10. Return the result of calling the [[Call]] internal method of _hook
    with _loaderObj_ and (_obj_) as arguments.

InstantiateSucceeded(instantiateResult) Functions

An InstantiateSucceeded function is an anonymous function that handles
the result of the INSTANTIATE hook.

Each InstantiateSucceeded function has [[Loader]] and [[Load]] internal
slots.

When an InstantiateSucceeded function _F_ is called with argument
_instantiateResult_, the following steps are taken:

1.  Let _loader_ be the value of _F_’s [[Loader]] internal slot.

2.  Let _load_ be the value of _F_’s [[Load]] internal slot.

3.  If _load_.[[LinkSets]] is an empty List, return UNDEFINED.

4.  If _instantiateResult_ is UNDEFINED, then

    a.  Let _body_ be the result of parsing _load_.[[Source]],
        interpreted as UTF-16 encoded Unicode text as described in
        10.1.1, using _Module_ as the goal symbol. Throw a SYNTAXERROR
        exception if the parse fails or if any static semantics errors
        are detected.

    b.  Set _load_.[[Body]] to _body_.

    c.  Set _load_.[[Kind]] to declarative.

    d.  Let _depsList_ be the ModuleRequests of _body_.

5.  Else if Type(_instantiateResult_) is Object, then

    a.  Let _deps_ be Get(_instantiateResult_, "DEPS").

    b.  ReturnIfAbrupt(_deps_).

    c.  If _deps_ is undefined, then let _depsList_ be a new empty List.

    d.  Else,

        i.  Let _depsList_ be IterableToArray(_deps_).

        ii. ReturnIfAbrupt(_depsList_).

    e.  Let _execute_ be Get(_instantiateResult_, "EXECUTE").

    f.  ReturnIfAbrupt(_execute_).

    g.  Set _load_.[[Execute]] to _execute_.

    h.  Set _load_.[[Kind]] to dynamic.

6.  Else,

    a.  Throw a TYPEERROR exception.

7.  Return ProcessLoadDependencies(_load_, _loader_, _depsList_).

LoadFailed Functions

A LoadFailed function is an anonymous function that marks a Load Record
as having failed. All LinkSets that depend on the Load also fail.

Each LoadFailed function has a [[Load]] internal slot.

When a LoadFailed function _F_ is called with argument _exc_, the
following steps are taken:

1.  Let _load_ be the value of _F_’s [[Load]] internal slot.

2.  Assert: _load_.[[Status]] is "LOADING".

3.  Set _load_.[[Status]] to `"failed".

4.  Set _load_.[[Exception]] to _exc_.

5.  Let _linkSets_ be a copy of the List _load_.[[LinkSets]].

6.  For each _linkSet_ in _linkSets_, in the order in which the LinkSet
    Records were created,

    a.  Call LinkSetFailed(_linkSet_, _exc_).

7.  Assert: _load_.[[LinkSets]] is empty.

ProcessLoadDependencies(load, loader, depsList) Abstract Operation

The ProcessLoadDependencies abstract operation is called after one
module has nearly finished loading. It starts new loads as needed to
_load_ the module's dependencies.

ProcessLoadDependencies also arranges for LoadSucceeded to be called.

The following steps are taken:

1.  Let _refererName_ be _load_.[[Name]].

2.  Set _load_.[[Dependencies]] to a new empty List.

3.  Let _loadPromises_ be a new empty List.

4.  For each _request_ in _depsList_, do

    a.  Let _p_ be RequestLoad(_loader_, _request_, _refererName_,
        _load_.[[Address]]).

    b.  Let _F_ be a new built-in function as defined by
        AddDependencyLoad.

    c.  Set the [[Load]] internal slot of _F_ to _load_.

    d.  Set the [[Request]] internal slot of _F_ to _request_.

    e.  Let _p_ be PromiseThen(_p_, _F_).

    f.  Append _p_ as the last element of _loadPromises_.

5.  Let _p_ be PromiseAll(_loadPromises_).

6.  Let _F_ be a new built-in function as defined by LoadSucceeded.

7.  Set the [[Load]] internal slot of _F_ to _load_.

8.  Return PromiseThen(_p_, _F_).

AddDependencyLoad(depLoad) Functions

An AddDependencyLoad function is an anonymous function that adds a Load
Record for a dependency to any LinkSets associated with the parent Load.

Each AddDependencyLoad function has [[ParentLoad]] and [[Request]]
internal slots.

When an AddDependencyLoad function _F_ is called with argument
_depLoad_, the following steps are taken:

1.  Let _parentLoad_ be the value of _F_’s [[ParentLoad]] internal slot.

2.  Let _request_ be the value of _F_’s [[Request]] internal slot.

3.  Assert: There is no Record in the List _parentLoad_.[[Dependencies]]
    whose [[key]] field is equal to _request_.

4.  Append the Record {[[key]]: _request_, [[value]]:
    _depLoad_.[[Name]]} to the end of the List
    _parentLoad_.[[Dependencies]].

5.  If _depLoad_.[[Status]] is not "LINKED", then

    a.  Let _linkSets_ be a copy of the List _parentLoad_.[[LinkSets]].

    b.  For each _linkSet_ in _linkSets_, do

        i.  Call AddLoadToLinkSet(_linkSet_, _depLoad_).

LoadSucceeded Functions

A LoadSucceeded function is an anonymous function that transitions a
Load Record from "LOADING" to "LOADED" and notifies all associated
LinkSet Records of the change. This function concludes the loader
pipeline. It is called after all a newly loaded module's dependencies
are successfully processed.

Each LoadSucceeded function has a [[Load]] internal slot.

When a LoadSucceeded function _F_ is called, the following steps are
taken:

1.  Let _load_ be the value of _F_’s [[Load]] internal slot.

2.  Assert: _load_.[[Status]] is "LOADING".

3.  Set _load_.[[Status]] to "LOADED".

4.  Let _linkSets_ be a copy of _load_.[[LinkSets]].

5.  For each _linkSet_ in _linkSets_ in List order, do

    a.  Call UpdateLinkSetOnLoad(_linkSet_, _load_).

PromiseOfStartLoadPartwayThrough (step, loader, name, metadata, source, address)

1.  Let _F_ be a new anonymous function object as defined in
    AsyncStartLoadPartwayThrough.

2.  Let _state_ be the Record { [[Step]]: _step_, [[Loader]]: _loader_,
    [[ModuleName]]: _name_, [[ModuleMetadata]]: _metadata_,
    [[ModuleSource]]: _source_, [[ModuleAddress]]: _address_}.

3.  Set _F_’s [[StepState]] internal slot to _state_.

4.  Return PromiseNew(_F_).

AsyncStartLoadPartwayThrough Functions

An AsyncStartLoadPartwayThrough function is an anonymous function that
is used as a Promise executor. When called it creates a new Load Record
and populates it with some information provided by the caller, so that
loading can proceed from either the LOCATE hook, the FETCH hook, or the
TRANSLATE hook. This functionality is used to implement builtin methods
like REFLECT.LOADER.PROTOTYPE.LOAD, which permits the user to specify
both the normalized module _name_ and the _address_.

Each AsyncStartLoadPartwayThrough function has internal slots
[[StepState]].

When an AsyncStartLoadPartwayThrough function _F_ is called with
arguments _resolve_ and _reject_, the following steps are taken:

1.  Let _state_ be the value of _F_’s [[StepState]] internal slot.

2.  Let _loader_ be _state_.[[Loader]].

3.  Let _name_ be _state_.[[ModuleName]].

4.  Let _step_ be _state_.[[Step]].

5.  6.  Repeat for each Record {[[key]], [[value]]} _p_ that is an
    element of _loader_.[[Modules], do

    a.  If SameValue(_p_.[[key]], _name_) is TRUE, then throw a
        TYPEERROR exception.

7.  Repeat for element _load_ of _loader_.[[Modules], do

    a.  If SameValue(_load_.[[Name]], _name_) is TRUE, then throw a
        TYPEERROR exception.

8.  Let _load_ be CreateLoad(_name_).

9.  Set _load_.[[Metadata]] to _state_.[[ModuleMetadata]].

10. Let _linkSet_ be CreateLinkSet(_loader,_ _load_).

11. Append _load_ to the end of _loader_.[[Loads]].

12. Call the [[Call]] internal method of _resolve_ with arguments
    UNDEFINED and (_linkSet_.[[Done]]).

13. If _step_ is "LOCATE",

    a.  Call ProceedToLocate(_loader_, _load_).

14. Else if _step_ is "FETCH",

    a.  Let _addressPromise_ be PromiseOf(_state_.[[ModuleAddress]]).

    b.  Call ProceedToFetch(_loader_, _load_, _addressPromise_).

15. Else,

    a.  Assert: _step_ is "TRANSLATE".

    b.  Set _load_.[[Address]] to _state_.[[ModuleAddress]].

    c.  Let _sourcePromise_ be PromiseOf(_state_.[[ModuleSource]]).

    d.  Call ProceedToTranslate(_loader_, _load_, _sourcePromise_).

Runtime Semantics: Module Linking 

ModuleLinkage Record

A ModuleLinkage Record contains the state needed to link a specific
module.

Each LinkSet Record has the fields defined in Table 37.

Table 37 — ModuleLinkage Record Fields

  -------------------------- ---------------- ------------------------------------
  _FIELD NAME_               _VALUE TYPE_     _MEANING_
  [[Body]]                   a parse result   The parse of a _Module_ production
  [[BoundNames]]                              
  [[KnownExportEntries]]                      
  [[KnownExportEntries]]                      
  [[ExportDefinitions]]                       
  [[Exports]]                                 
  [[Dependenies]]                             
  [[UnlinkedDependencies]]                    
  [[ImportedEntries]]                         
  [[ImportedDefinitions]]                     
  [[Evaluated]]                               
  [[LinkErrors]]                              
  [[Environment]]                             
  -------------------------- ---------------- ------------------------------------

CreateModuleLinkageRecord (loader, body) Abstract Operation

The abstract operation CreateModuleLinkageRecord with arguments _loader_
and _body_ performs the following steps:

1.  Assert: _body_ is a _Modulebody_ parse.

2.  Let _M_ be a new object with [[Prototype]] NULL.

3.  Set _M_.[[Body]] to _body_.

4.  Set _M_.[[BoundNames]] to DeclaredNames of _body_.

5.  Set _M_.[[KnownExportEntries]] to KnownExportEntries of _body_.

6.  Set _M_.[[UnknownExportEntries]] to UnknownExportEntries of _body_.

7.  Set _M_.[[ExportDefinitions]] to UNDEFINED.

8.  Set _M_.[[Exports]] to UNDEFINED.

9.  Set _M_.[[Dependencies]] to UNDEFINED.

10. Set _M_.[[UnlinkedDependencies]] to UNDEFINED.

11. Set _M_.[[ImportEntries]] to ImportEntries of _body_.

12. Set _M_.[[ImportDefinitions]] to UNDEFINED.

13. Set _M_.[[LinkErrors]] to a new empty List.

14. Let _realm_ be _loader_.[[Realm]].

15. Let _globalEnv_ be _realm_.[[_globalEnv_]].

16. Let _env_ be NewModuleEnvironment(_globalEnv_).

17. Set _M_.[[Environment]] to _env_.

18. Return _M_.

LookupExport ( M, exportName )

The abstract operation LookupExport with arguments _M_ and _exportName_
performs the following:

1.  If _M_.[[Exports]] does not contain a record _export_ such that
    _export_.[[ExportName]] is equal to _exportName_, then return
    UNDEFINED.

2.  Let _export_ be the record in _M_.[[Exports]] such that
    _export_.[[ExportName]] is equal to _exportName_.

3.  Return _export_.[[Binding]].

LookupModuleDependency ( M, requestName )

The abstract operation LookupModuleDependency with arguments _M_ and
_requestName_ performs the following steps:

1.  Assert: _M_ is a ModuleLinkage Record.

2.  If _requestName_ is NULL then return _M_.

3.  Let _pair_ be the record in _M_.[[Dependencies]] such that
    _pair_.[[Key]] is equal to _requestName_.

4.  Return _pair_.[[Module]].

LinkSet Records

A LinkSet Record represents a call to LOADER.DEFINE(), .LOAD(),
.MODULE(), or .IMPORT().

Each LinkSet Record has the fields defined in Table 38.

Table 38 — LinkSet Record Fields

  -------------- --------------------- -----------------------------------------------------------------------------------------------------
  _FIELD NAME_   _VALUE TYPE_          _MEANING_
  [[Loader]]     Loader Record         The Loader record that created this LinkSet.
  [[Loads]]      List of Load Record   A List of the Load Records that must finish loading before the modules can be linked and evaluated.
  [[Done]]       Promise Object        The Promise that becomes fulfilled when all dependencies are loaded and linked together.
  [[Resolve]]    Function Object       Function used to resolve [[Done]].
  [[Reject]]     Function Object       Function used to reject [[Done]].
  -------------- --------------------- -----------------------------------------------------------------------------------------------------

CreateLinkSet(loader, startingLoad) Abstract Operation

The CreateLinkSet abstract operation creates a new LinkSet record by
performing the following steps:

1.  Assert: _loader_ is a Loader Record.

2.  If _loader_ does not have all of the internal properties of a Loader
    Instance, throw a TypeError exception.

3.  Let _promiseCapability_ be PromiseBuiltinCapability().

4.  ReturnIfAbrupt(_promiseCapability_).

5.  Let _linkSet_ be LinkSet {[[Loader]]: _loader_, [[Loads]]: ( ),
    [[Done]]: _promiseCapability_.[[Promise]], [[Resolve]]:
    _promiseCapability_.[[Resolve]], [[Reject]]:
    _promiseCapability_.[[Reject]] }.

6.  Perform AddLoadToLinkSet(_linkSet_, _startingLoad_).

7.  Return _linkSet_.

AddLoadToLinkSet(linkSet, load) Abstract Operation

The AddLoadToLinkSet abstract operation associates a LinkSet Record with
a Load Record and each of its currently known dependencies, indicating
that the LinkSet cannot be linked until those Loads have finished
successfully.

The following steps are taken:

1.  Assert: _load_.[[Status]] is either "LOADING" or "LOADED".

2.  Let _loader_ be _linkSet_.[[Loader]].

3.  If _load_ is not already an element of the List _linkSet_.[[Loads]],

    a.  Append _load_ to the end of the List _linkSet_.[[Loads]].

    b.  Append _linkSet_ to the end of the List _load_.[[LinkSets]].

    c.  If _load_.[[Status]] is "LOADED", then

        i.  Repeat for each _r_ that is a Record {[[Name]],
            [[NormalizedName]]} in _load_.[[Dependencies]],

            1.  If there is no element of _loader_.[[Modules]] whose
                [[key]] field is equal to _name_,

                a.  If there is an element of _loader_.[[Loads]] whose
                    [[Name]] field is equal to _name_,

                    i.  Let _depLoad_ be that Load Record.

                    ii. Perform AddLoadToLinkSet(_linkSet_, _depLoad_).

UpdateLinkSetOnLoad(linkSet, load) Abstract Operation

The UpdateLinkSetOnLoad abstract operation is called immediately after a
Load successfully finishes, after starting Loads for any dependencies
that were not already loading, loaded, or in the module registry.

This operation determines whether _linkSet_ is ready to link, and if so,
calls Link.

The following steps are taken:

1.  Assert: _load_ is an element of _linkSet_.[[Loads]].

2.  Assert: _load_.[[Status]] is either "LOADED" or "LINKED".

3.  Repeat for each _element_ in _linkSet_.[[Loads]],

    a.  If _element_.[[Status]] is "LOADING", then return.

4.  Assert: All Loads in _linkSet_.[[Loads]] have finished loading.

5.  Let _startingLoad_ be the first element of the List
    _linkSet_.[[Loads]].

6.  Let _status_ be Link(_linkSet_.[[Loads]], _linkSet_.[[Loader]]).

7.  If _status_ is an abrupt completion, then

    a.  Return LinkSetFailed(_linkSet_, _status_.[[value]]).

8.  Assert: _linkSet_.[[Loads]] is an empty List.

9.  Call the [[Call]] internal method of _linkSet_.[[Resolve]] passing
    UNDEFINED and (_startingLoad_) as arguments.

10. Assert: The call performed by step 9 completed normally.

LinkSetFailed(linkSet, exc) Abstract Operation

The LinkSetFailed abstract operation is called when a LinkSet fails. It
detaches the given LinkSet Record from all Load Records and rejects the
_linkSet_.[[Done]] Promise.

The following steps are taken:

1.  Let _loader_ be _linkSet_.[[Loader]].

2.  Let _loads_ be a copy of the List _linkSet_.[[Loads]].

3.  For each _load_ in _loads_,

    a.  Assert: _linkSet_ is an element of the List _load_.[[LinkSets]].

    b.  Remove _linkSet_ from the List _load_.[[LinkSets]].

    c.  If _load_.[[LinkSets]] is empty and _load_ is an element of
        _loader_.[[Loads]], then

        i.  Remove _load_ from the List _loader_.[[Loads]].

4.  Return the result of calling [[Call]] internal method of
    _linkSet_.[[Reject]] passing UNDEFINED and (_exc_) as arguments.

5.  Assert: The call performed by step 4 completed normally.

FinishLoad(loader, load) Abstract Operation

The FinishLoad Abstract Operation removes a completed Load Record from
all LinkSets and commits the newly loaded Module to the registry. It
performs the following steps:

1.  Let _name_ be _load_.[[Name]].

2.  If _name_ is not UNDEFINED, then

    a.  Assert: There is no Record {[[key]], [[value]]} _p_ that is an
        element of _loader_.[[Modules]], such that
        SameValue(_p_.[[key]], _load_.[[Name]]) is TRUE.

    b.  Append the Record {[[key]]: _load_.[[Name]], [[value]]:
        _load_.[[Module]]} as the last element of _loader_.[[Modules]].

3.  If _load_ is an element of the List _loader_.[[Loads]], then

    a.  Remove _load_ from the List _loader_.[[Loads]].

4.  For each _linkSet_ in _load_.[[LinkSets]],

    a.  Remove _load_ from _linkSet_.[[Loads]].

5.  Remove all elements from the List _load_.[[LinkSets]].

Module Linking Groups

A load record _load_~1~ has a _LINKAGE DEPENDENCY_ on a load record
_load_~2~ if _load_~2~ is contained in
_load_~1~.[[UnlinkedDependencies]] or there exists a load record _load
in _load_~1~.[[UnlinkedDependencies]] such that _load_ has a linkage
dependency on _load_~2~.

The _LINKAGE GRAPH_ of a List, _list,_ of load records is the set of
load records _load_ such that some load record in _list_ has a linkage
dependency on _load_.

A _DEPENDENCY CHAIN_ from _load_~1~ to _load_~2~ is a List of load
records demonstrating the transitive linkage dependency from _load_~1~
to _load_~2~.

A _DEPENDENCY CYCLE_ is a dependency chain whose first and last
elements’ [[Name]] fields have the same value.

A dependency chain is _CYCLIC_ if it contains a subsequence that is a
dependency cycle. A dependency chain is _ACYCLIC_ if it is not cyclic.

A dependency chain is _MIXED_ if there are two elements with distinct
values for their [[Kind]] fields. A _DEPENDENCY GROUP TRANSITION_ of
kind _kind_ is a two-element subsequence _load_~1~, _load_~2~ of a
dependency chain such that _load_~1~.[[Kind]] is not equal to _kind_ and
_load_~2~.[[Kind]] is equal to _kind_.

The _DEPENDENCY GROUP COUNT_ of a dependency chain with first element
_load_~1~ is the number of distinct dependency group transitions of kind
_load_~1~.[[Kind]].

LinkageGroups ( start )

The abstract operation LinkageGroups with argument _start_ performs the
following steps:

1.  Assert: _start_ is a List of LinkSet Records.

2.  Let _G_ be the linkage graph of _start_.

3.  If there are any mixed dependency cycles in _G_, throw a SYNTAXERROR
    exception.

4.  For each _load_ in _G_, do

    a.  Let _n_ be the largest dependency group count of all acyclic
        dependency chains in _G_ starting from _load_.

    b.  Set _load_.[[GroupIndex]] to _n_.

5.  Let _declarativeGroupCount_ be the largest [[GroupIndex]] of any
    _load_ in _G_ such that _load_.[[Kind]] is declarative.

6.  Let _declarativeGroups_ be a new List of length
    _declarativeGroupCount_ where each element is a new empty List.

7.  Let _dynamicGroupCount_ be the largest [[GroupIndex]] of any _load
    in _G_ such that _load_.[[Kind]] is dynamic.

8.  Let _dynamicGroups_ be a new List of length _dynamicGroupCount
    where each element is a new empty List.

9.  Let _visited_ be a new empty List.

10. For each _load_ in _start_, do

    a.  Perform BuildLinkageGroups(_load_, _declarativeGroups_,
        _dynamicGroups_, and _visited_).

11. If any _load_ in the first element of _declarativeGroups_ has a
    dependency on a load record of [[Kind]] dynamic, then

    a.  Let _groups_ be a List constructed by interleaving the elements
        of _dynamicGroups_ and _declarativeGroups_, starting with the
        former.

12. Else,

    a.  let _groups_ be a List constructed by interleaving the elements
        of _declarativeGroups_ and _dynamicGroups_, starting with the
        former.

13. Return _groups_.

BuildLinkageGroups ( load, declarativeGroups, dynamicGroups, visited )

The abstract operation BuildLinkageGroups with arguments _load_,
_declarativeGroups_, and _dynamicGroups_ performs the following steps:

1.  If _visited_ contains an element whose [[Name]] is equal to
    _load_.[[Name]], then return.

2.  Add _load_ to _visited_.

3.  For each _dep_ of _load_.[[UnlinkedDependencies]], do

    a.  Call the BuildLinkageGroups abstract operation passing _dep_,
        _declarativeGroups_, _dynamicGroups_, and _visited_ as
        arguments.

4.  Let _i_ be _load_.[[GroupIndex]].

5.  If _load_.[[Kind]] is declarative let _groups_ be
    _declarativeGroups_; otherwise let _groups_ be _dynamicGroups_.

6.  Let _group_ be the _i_th element of _groups_.

7.  Add _load_ to _group_.

Link ( start, loader )

The abstract operation Link with argument _start_ performs the following
steps:

1.  Let _groups_ be LinkageGroups(_start_).

2.  For each _group_ in _groups_:

    a.  If the [[Kind]] of each element of _group_ is declarative, then
        perform LinkDeclarativeModules(_group_, _loader_).

    b.  Else, perform LinkDynamicModules(_group_, _loader_).

LinkDeclarativeModules ( loads, loader )

The abstract operation LinkDeclarativeModules with arguments _loads_ and
_loader_ performs the following steps:

1.  Let _unlinked_ be a new empty List.

2.  For each _load_ in _loads_, do

    a.  If _load_.[[Status]] is not LINKED, then

        i.  Let _module_ be CreateModuleLinkageRecord (_loader_,
            _load_.[[Body]]).

        ii. Let _pair_ be the record {[[Module]]: _module_, [[Load]]:
            _load_}.

        iii. Add _pair_ to _unlinked_.

3.  For each _pair_ in _unlinked_, do

    a.  Let _resolvedDeps_ be a new empty List.

    b.  Let _unlinkedDeps_ be a new empty List.

    c.  For each element _dep_ in _pair_.[[Load]].[[Dependencies]], do

        i.  Let _requestName_ be _dep_.[[Key]].

        ii. Let _normalizedName_ be _dep_.[[Value]].

        iii. If _loads_ contains a record _load_ such that
            SameValue(_load_.[[Name]], _normalizedName_) is TRUE, then

            1.  If _load_.[[Status]] is LINKED, then

                a.  Let _resolvedDep_ be the record {[[Key]]:
                    _requestName_, [[Value]]: _load_.[[Module]]}.

                b.  Add _resolvedDep_ to _resolvedDeps_.

            2.  Else,

                a.  Let _otherPair_ be the record in _unlinked_ such
                    that SameValue(_otherPair_.[[Load]].[[Name]],
                    _normalizedName_) is TRUE.

                b.  Add the record {[[Key]]: _requestName_, [[Value]]:
                    _otherPair_.[[Module]]} to _resolvedDeps_.

                c.  Add _otherPair_.[[Load]] to _unlinkedDeps_.

        iv. Else,

            1.  Let _module_ be LoaderRegistryLookup(_loader_,
                _normalizedName_).

            2.  If _module_ is NULL then

                a.  Let _error_ be a new REFERENCEERROR exception.

                b.  Add _error_ to _pair_.[[Module]].[[LinkErrors]].

            3.  Else, add the record {[[Key]]: _requestName_, [[Value]]:
                _module_} to _resolvedDeps._

    d.  Set _pair_.[[Module]].[[Dependencies]] to _resolvedDeps_.

    e.  Set _pair_.[[Module]].[[UnlinkedDependencies]] to
        _unlinkedDeps_.

4.  For each _pair_ in _unlinked_, do

    a.  Perform ResolveExportEntries(_pair_.[[Module]], ( ) ).

    b.  Perform ResolveExports(_pair_.[[Module]]).

5.  For each _pair_ in _unlinked_, do

    a.  Perform ResolveImportEntries(_pair_.[[Module]]).

    b.  Perform LinkImports(_pair_.[[Module]]).

6.  If there exists a _pair_ in _unlinked_ such that
    _pair_.[[Module]].[[LinkErrors]] is not empty, choose one of the
    link errors and throw it.

7.  For each _pair_ in _unlinked_, do

    a.  Set _pair_.[[Load]].[[Module]] to _pair_.[[Module]].

    b.  Set _pair_.[[Load]].[[Status]] to LINKED.

    c.  Let _r_ be FinishLoad(_loader_, _pair_.[[Load]]).

    d.  ReturnIfAbrupt(_r_).

LinkImports ( M )

The abstract operation LinkImports with argument _M_ performs the
following steps:

1.  Let _envRec_ be _M_.[[Environment]].

2.  Let _defs_ be _M_.[[ImportDefinitions]].

3.  For each _def_ in _defs_, do

    a.  If _def_.[[ImportName]] is MODULE, then the following steps are
        taken:

        i.  Call the CreateImmutableBinding concrete method of _envRec_
            passing _def_.[[LocalName]] as the argument.

        ii. Call the InitializeImmutableBinding concrete method of
            _envRec_ passing _def_.[[LocalName]] and _def_.[[Module]] as
            the arguments.

    b.  Otherwise, the following steps are taken:

        i.  Let _binding_ be ResolveExport(_def_.[[Module]],
            _def_.[[ImportName]], ( )).

        ii. If _binding_ is UNDEFINED, then the following steps are
            taken:

            1.  Let _error_ be a new Reference Error.

            2.  Add _error_ to _M_.[[LinkErrors]].

        iii. Otherwise, call the CreateImportBinding concrete method of
            _envRec_ passing _def_.[[LocalName]] and _binding_ as the
            arguments.

LinkDynamicModules ( loads, loader )

The abstract operation LinkDynamicModules with arguments _loads_ and
_loader_ performs the following steps:

1.  For each _load_ in _loads_, do

    a.  Let _exec_ be _load_.[[Execute]].

    b.  Let _module_ be the result of calling the [[Call]] internal
        method of _exec_ with UNDEFINED as the THIS value and with no
        arguments.

    c.  ReturnIfAbrupt(_module_).

    d.  If _module_ does not have all the internal data properties of a
        Module Instance Object, then throw a TYPEERROR exception.

    e.  Set _load_.[[Module]] to _module_.

    f.  Set _load_.[[Status]] to LINKED.

    g.  Let _r_ be FinishLoad(_loader_, _load_).

    h.  ReturnIfAbrupt(_r_).

ResolveExportEntries ( M, visited )

The abstract operation ResolveExportEntries with arguments _M_ and
_visited_ performs the following steps:

1.  If _M_.[[ExportDefinitions]] is not UNDEFINED, then return
    _M_.[[ExportDefinitions]].

2.  Let _defs_ be a new empty List.

3.  Let _boundNames_ be _M_.[[BoundNames]].

4.  For each _entry_ in _M_.[[KnownExportEntries]], do

    a.  Let _modReq_ be _entry_.[[ModuleRequest]].

    b.  Let _otherMod_ be LookupModuleDependency(_M_, _modReq_).

    c.  If _entry_.[[Module]] is NULL and _entry_.[[LocalName]] is not
        NULL and _boundNames_ does not contain _entry_.[[LocalName]],
        then the following steps are taken:

        i.  Let _error_ be a new Reference Error.

        ii. Add _error_ to _M_.[[LinkErrors]].

    d.  Add the record {[[Module]]: _otherMod_, [[ImportName]]:
        _entry_.[[ImportName]], [[LocalName]]: _entry_.[[LocalName]],
        [[ExportName]]: _entry_.[[ExportName]], [[Explicit]]: TRUE} to
        _defs_.

5.  For each _modReq_ in _M_.[[UnknownExportEntries]], do

    a.  Let _otherMod_ be LookupModuleDependency( _M_, _modReq_).

    b.  If _otherMod_ is in _visited_, then the following steps are
        taken:

        i.  Let _error_ be a new Syntax Error.

        ii. Add _error_ to _M_.[[LinkErrors]].

    c.  Otherwise the following steps are taken:

        i.  Add _otherMod_ to _visited_.

        ii. Let _otherDefs_ be ResolveExportEntries(_otherMod_,
            _visited_ ).

        iii. For each _def_ of _otherDefs_, do

            1.  Add the record {[[Module]]: _otherMod_, [[ImportName]]:
                _def_.[[ExportName]], [[LocalName]]: NULL,
                [[ExportName]]: _def_.[[ExportName]], [[Explicit]]:
                FALSE} to _defs_.

6.  Set _M_.[[ExportDefinitions]] to _defs_.

7.  Return _defs_.

ResolveExports ( M )

The abstract operation ResolveExports with argument _M_ performs the
following steps:

1.  For each _def_ in _M_.[[ExportDefinitions]], do

    a.  Perform ResolveExport(_M_, _def_.[[ExportName]], ( )).

ResolveExport ( M, exportName, visited )

The abstract operation ResolveExport with arguments _M_, _exportName_,
and _visited_ performs the following steps:

1.  Let _exports_ be _M_.[[Exports]].

2.  If _exports_ has a record _export_ such that _export_.[[ExportName]]
    is equal to _exportName_, return _export_.[[Binding]].

3.  Let _ref_ be {[[Module]]: _M_, [[ExportName]]: _exportName_}.

4.  If _visited_ contains a record equal to _ref_ then the following
    steps are taken:

    a.  Let _error_ be a new Syntax Error.

    b.  Add _error_ to _M_.[[LinkErrors]].

    c.  Return _error_.

5.  Let _defs_ be _M_.[[ExportDefinitions]].

6.  Let _overlappingDefs_ be the List of records _def_ in _defs_ such
    that _def_.[[ExportName]] is equal to _exportName_.

7.  If _overlappingDefs_ is empty, then the following steps are taken:

    a.  Let _error_ be a new Reference Error.

    b.  Add _error_ to _M_.[[LinkErrors]].

    c.  Return _error_.

8.  If _overlappingDefs_ has more than one record _def_ such that
    _def_.[[Explicit]] is TRUE, or if it has length greater than 1 but
    contains no records _def_ such that _def_.[[Explicit]] is TRUE, then
    the following steps are taken:

    a.  Let _error_ be a new Syntax Error.

    b.  Add _error_ to _M_.[[LinkErrors]].

    c.  Return _error_.

9.  Let _def_ be the unique record in _overlappingDefs_ such that
    _def_.[[Explicit]] is TRUE, or if there is no such record let _def_
    be the unique record in _overlappingDefs_.

10. If _def_.[[LocalName]] is not NULL, then the following steps are
    taken:

    a.  Let _binding_ be the record {[[Module]]: _M_, [[LocalName]]:
        _def_.[[LocalName]]}.

    b.  Let _export_ be the record {[[ExportName]]: _exportName_,
        [[Binding]]: _binding_}.

    c.  Add _export_ to _exports_.

    d.  Return _binding_.

11. Add _ref_ to _visited_.

12. Let _binding_ be ResolveExport(_def_.[[Module]],
    _def_.[[ImportName]], _visited_).

13. Return _binding_.

ResolveImportEntries ( M )

The abstract operation ResolveImportEntries called with argument _M_
performs the following steps:

1.  Let _entries_ be _M_.[[ImportEntries]].

2.  Let _defs_ be a new empty List.

3.  For each _entry_ in _entries_, do

    a.  Let _modReq_ be _entry_.[[ModuleRequest]].

    b.  Let _otherMod_ be LookupModuleDependency(_M_, _modReq_).

    c.  Add the record {[[Module]]: _otherMod_, [[ImportName]]:
        _entry_.[[ImportName]], [[LocalName]]: _entry_.[[LocalName]]} to
        _defs_.

4.  Return _defs_.

Runtime Semantics: Module Evaluation

Module bodies are evaluated on demand, as late as possible. The loader
uses the function ENSUREEVALUATED, defined below, to run scripts. The
loader always calls ENSUREEVALUATED before returning a Module object to
user code.

There is one way a module can be exposed to script before its body has
been evaluated. In the case of an import cycle, whichever module is
evaluated first can observe the others before they are evaluated. Simply
put, we have to start somewhere: one of the modules in the cycle must
run before the others.

EvaluateLoadedModule(load) Functions

An EvaluateLoadedModule function is an anonymous built-in function that
is used by REFLECT.LOADER.PROTOTYPE.MODULE and
REFLECT.LOADER.PROTOTYPE.IMPORT to ensure that a module has been
evaluated before it is passed to script code.

Each EvaluateLoadedModule function has a [[Loader]] internal slot.

When a EvaluateLoadedModule function _F_ is called with argument _load_,
the following steps are taken:

1.  Let _loader_ be _F_.[[Loader]].

2.  Assert: _load_.[[Status]] is "LINKED".

3.  Let _module_ be _load_.[[Module]].

4.  Let _result_ be EnsureEvaluated(_module_, (), _loader_).

5.  ReturnIfAbrupt(_result_).

6.  Return _module_.

EnsureEvaluated(mod, seen, loader) Abstract Operation

The abstract operation EnsureEvaluated walks the dependency graph of the
module _mod_, evaluating any module bodies that have not already been
evaluated (including, finally, _mod_ itself). Modules are evaluated in
depth-first, left-to-right, post order, stopping at cycles.

_mod_ and its dependencies must already be linked.

The List _seen_ is used to detect cycles. _mod_ must not already be in
the List _seen_.

On success, _mod_ and all its dependencies, transitively, will have
started to evaluate exactly once.

EnsureEvaluated performs the following steps:

1.  If _mod_.[[Evaluated]] is TRUE, return UNDEFINED.

2.  Append _mod_ as the last element of _seen_.

3.  TODO: Create the module environment for _mod

4.  Let _deps_ be _mod_.[[Dependencies]].

5.  For each _pair_ in _deps_, in List order,

    a.  Let _dep_ be _pair_.[[value]].

    b.  If _dep_ is not an element of _seen_, then

        i.  Call EnsureEvaluated with the arguments _dep_, _seen_, and
            _loader_.

6.  If _mod_.[[Evaluated]] is TRUE, return UNDEFINED.

7.  Set _mod_.[[Evaluated]] to TRUE.

8.  If _mod_.[[Body]] is UNDEFINED, then return UNDEFINED.

9.  Let _status_ be ModuleDeclarationInstantiation(_mod_.[[Body]],
    _mod_.[[Environment]]).

10. Let _initContext_ be a new ECMAScript code execution context.

11. Set _initContext_'s Realm to _loader_.[[Realm]].

12. Set _initContext_'s VariableEnvironment to _mod_.[[Environment]].

13. Set _initContext_'s LexicalEnvironment to _mod_.[[Environment]].

14. If there is a currently running execution context, suspend it.

15. Push _initContext_ on to the execution context stack; _initContext
    is now the running execution context.

16. Let _r_ be the result of evaluating _mod_.[[Body]].

17. Suspend _initContext_ and remove it from the execution context
    stack.

18. Resume the context, if any, that is now on the top of the execution
    context stack as the running execution context.

19. Return _r_.



ERROR HANDLING AND LANGUAGE EXTENSIONS


An implementation must report most errors at the time the relevant
ECMAScript language construct is evaluated. An _early error_ is an error
that can be detected and reported prior to the evaluation of any
construct in the _Script_ containing the error. The presense of an early
error prevents the evaluation of the construct. An implementation must
report early errors in a _Script_ as part of the ScriptEvaluationJob for
that _Script_. Early errors in a _Module_ are reported at the point when
the _Module_ would be evaluated and the _Module_ is never initialized.
Early errors in EVAL code are reported at the time EVAL is called and
prevent evaluation of the EVAL code. All errors that are not early
errors are runtime errors.

An implementation must report as an early error any occurrence of a
condition that is listed in a “Static Semantics: Early Errors” subclause
of this specification.

An implementation shall not treat other kinds of errors as early errors
even if the compiler can prove that a construct cannot execute without
error under any circumstances. An implementation may issue an early
warning in such a case, but it should not report the error until the
relevant construct is actually executed.

An implementation shall report all errors as specified, except for the
following:

-   An implementation may extend _Script_ syntax, _Module_ syntax, and
    regular expression pattern or flag syntax. To permit this, all
    operations (such as calling EVAL, using a regular expression
    literal, or using the FUNCTION or REGEXP constructor) that are
    allowed to throw SYNTAXERROR are permitted to exhibit
    implementation-defined behaviour instead of throwing SYNTAXERROR
    when they encounter an implementation-defined extension to the
    script syntax or regular expression pattern or flag syntax.

-   An implementation may provide additional types, values, objects,
    properties, and functions beyond those described in this
    specification. This may cause constructs (such as looking up a
    variable in the global scope) to have implementation-defined
    behaviour instead of throwing an error (such as REFERENCEERROR).

An implementation may define behaviour other than throwing RANGEERROR
for TOFIXED, TOEXPONENTIAL, and TOPRECISION when the _fractionDigits_ or
_precision_ argument is outside the specified range.



ECMASCRIPT STANDARD BUILT-IN OBJECTS 


There are certain built-in objects available whenever an ECMAScript
_Script_ begins execution. One, the global object, is part of the
lexical environment of the executing program. Others are accessible as
initial properties of the global object or indirectly as properties of
accessible built-in objects.

Unless specified otherwise, a built-in object that is callable as a
function is a Built-in Function object with the characteristics
described in 9.3. Unless specified otherwise, the [[Extensible]]
internal slot of a built-in object initially has the value TRUE. Every
built-in Function object has a [[Realm]] internal slot whose value is
the code Realm for which the object was initially created.

Many built-in objects are functions: they can be invoked with arguments.
Some of them furthermore are constructors: they are functions intended
for use with the NEW operator. For each built-in function, this
specification describes the arguments required by that function and
properties of the Function object. For each built-in constructor, this
specification furthermore describes properties of the prototype object
of that constructor and properties of specific object instances returned
by a NEW expression that invokes that constructor.

Unless otherwise specified in the description of a particular function,
if a built-in function or constructor is given fewer arguments than the
function is specified to require, the function or constructor shall
behave exactly as if it had been given sufficient additional arguments,
each such argument being the UNDEFINED value. Such missing arguments are
considered to be “not present” and may be identified in that manner by
specification algorithms.

Unless otherwise specified in the description of a particular function,
if a built-in function or constructor described is given more arguments
than the function is specified to allow, the extra arguments are
evaluated by the call and then ignored by the function. However, an
implementation may define implementation specific behaviour relating to
such arguments as long as the behaviour is not the throwing of a
TYPEERROR exception that is predicated simply on the presence of an
extra argument.

NOTE Implementations that add additional capabilities to the set of
built-in functions are encouraged to do so by adding new functions
rather than adding new parameters to existing functions.

Unless otherwise specified every built-in function and every built-in
constructor has the Function prototype object, which is the initial
value of the expression FUNCTION.PROTOTYPE (19.2.3), as the value of its
[[Prototype]] internal slot.

Unless otherwise specified every built-in prototype object has the
Object prototype object, which is the initial value of the expression
OBJECT.PROTOTYPE (19.1.3), as the value of its [[Prototype]] internal
slot, except the Object prototype object itself.

Built-in function objects that are not identified as constructors do not
implement the [[Construct]] internal method unless otherwise specified
in the description of a particular function.

Unless otherwise specified, every built-in function defined in clauses
18 through 26 are created as if by calling the CreateBuiltinFunction
abstract operation (9.3.1).

Every built-in Function object, including constructors, has a LENGTH
property whose value is an integer. Unless otherwise specified, this
value is equal to the largest number of named arguments shown in the
subclause headings for the function description, including optional
parameters. However, rest parameters shown using the form “...name” are
not included in the default argument count.

NOTE For example, the Function object that is the initial value of the
slice property of the String prototype object is described under the
subclause heading “String.prototype.slice (start, end)” which shows the
two named arguments start and end; therefore the value of the length
property of that Function object is 2.

Unless otherwise specified, the LENGTH property of a built-in Function
object has the attributes { [[Writable]]: FALSE, [[Enumerable]]: FALSE,
[[Configurable]]: TRUE }.

Every built-in Function object, including constructors, that is not
identified as an anonymous function has a NAME property whose value is a
String. Unless otherwise specified, this value is the name that is given
to the function in this specification. For functions that are specified
as properties of objects, the name value is the property name string
used to access the function. Functions that are specified as get or set
accessor functions of built-in properties have "GET " or "SET "
prepended to the property name string. The value of the NAME property is
explicitly specified for each built-in functions whose property key is a
symbol value.

Unless otherwise specified, the NAME property of a built-in Function
object, if it exists, has the attributes { [[Writable]]: FALSE,
[[Enumerable]]: FALSE, [[Configurable]]: TRUE }.

Every other data property described in clauses 18 through 26 has the
attributes { [[Writable]]: TRUE, [[Enumerable]]: FALSE,
[[Configurable]]: TRUE } unless otherwise specified.

Every accessor property described in clauses 18 through 26 has the
attributes {[[Enumerable]]: FALSE, [[Configurable]]: TRUE } unless
otherwise specified. If only a get accessor function is described, the
set accessor function is the default value, UNDEFINED. If only a set
accessor is function is described the get accessor is the default value,
UNDEFINED.



THE GLOBAL OBJECT 


The unique _global object_ is created before control enters any
execution context.

The global object does not have a [[Construct]] internal method; it is
not possible to use the global object as a constructor with the NEW
operator.

The global object does not have a [[Call]] internal method; it is not
possible to invoke the global object as a function.

The value of the [[Prototype]] internal slot of the global object is
implementation-dependent.

In addition to the properties defined in this specification the global
object may have additional host defined properties. This may include a
property whose value is the global object itself; for example, in the
HTML document object model the WINDOW property of the global object is
the global object itself.


Value Properties of the Global Object

Infinity

The value of INFINITY is +∞ (see 6.1.6). This property has the
attributes { [[Writable]]: FALSE, [[Enumerable]]: FALSE,
[[Configurable]]: FALSE }.

NaN

The value of NAN is NAN (see 6.1.6). This property has the attributes {
[[Writable]]: FALSE, [[Enumerable]]: FALSE, [[Configurable]]: FALSE }.

undefined

The value of UNDEFINED is UNDEFINED (see 6.1.1). This property has the
attributes { [[Writable]]: FALSE, [[Enumerable]]: FALSE,
[[Configurable]]: FALSE }.


Function Properties of the Global Object

eval (x)

When the EVAL function is called with one argument _x_, the following
steps are taken:

1.  If Type(_x_) is not String, return _x_.

2.  Let _script_ be the ECMAScript code that is the result of parsing
    _x_, interpreted as UTF-16 encoded Unicode text as described in
    10.1.1_,_ for the goal symbol _Script_. If the parse fails or any
    early errors are detected, throw a SYNTAXERROR exception (but see
    also clause 16).

3.  If _script_ Contains _ScriptBody_ is FALSE, return UNDEFINED.

4.  Let _strictScript_ be IsStrict of _script_.

5.  If this is a direct call to eval (18.2.1.1), let _direct_ be TRUE,
    otherwise let _direct_ be FALSE.

6.  If _direct_ is TRUE and the code that made the direct call to eval
    is strict code, then let _strictCaller_ be TRUE_._ Otherwise, let
    _strictCaller_ be FALSE_._

7.  Let _ctx_ be the running execution context. If _direct_ is TRUE
    _ctx_ will be the execution context that performed the direct eval.
    If _direct_ is FALSE _ctx_ will be the execution context for the
    invocation of the eval function.

8.  Let _evalRealm_ be _ctx’s_ Realm.

9.  If _direct_ is FALSE and _strictScript_ is FALSE, then

    a.  Return the result of ScriptEvaluation for _script_ with
        arguments _evalRealm_ and TRUE.

10. If _direct_ is TRUE, _strictScript_ is FALSE, _strictCaller_ is
    FALSE, and _ctx’s_ LexicalEnvironment is the same as
    _evalRealm_.[[globalEnv]], then

    a.  Return the result of ScriptEvaluation for _script_ with
        arguments _evalRealm_ and TRUE.

11. If _direct_ is TRUE, then

    a.  If the code that made the direct call to eval is function code
        and ValidInFunction of _script_ is FALSE, then throw a
        SYNTAXERROR exception.

    b.  If the code that made the direct call to eval is module code and
        ValidInModule of _script_ is FALSE, then throw a SYNTAXERROR
        exception.

12. If _direct_ is TRUE, then

    a.  Let _lexEnv_ be _ctx’s_ LexicalEnvironment.

    b.  Let _varEnv_ be _ctx’s_ VariableEnvironment.

13. Else,

    a.  Let _lexEnv_ be _evalRealm_.[[globalEnv]].

    b.  Let _varEnv_ be _evalRealm_.[[globalEnv]].

14. If _strictScript_ is TRUE or if _direct_ is TRUE and _strictCaller
    is TRUE , then

    a.  Let _strictVarEnv_ be NewDeclarativeEnvironment(_lexEnv_).

    b.  Let _lexEnv_ be _strictVarEnv_.

    c.  Let _varEnv_ be _strictVarEnv_.

15. Let _status_ be the result of performing Eval Declaration
    Instantiation as described in 18.2.1.2 with _script_, _varEnv_, and
    _lexEnv_.

16. ReturnIfAbrupt(_status_).

17. Let _evalCxt_ be a new ECMAScript code execution context.

18. Set the _evalCxt’s_ Realm to _evalRealm_.

19. Set the _evalCxt’s_ VariableEnvironment to _varEnv_.

20. Set the _evalCxt’s_ LexicalEnvironment to _lexEnv_.

21. If there is a currently running execution context, suspend it.

22. Push _evalCxt_ on to the execution context stack; _evalCxt_ is now
    the running execution context.

23. Let _result_ be the result of evaluating _script_.

24. Suspend _evalCxt_ and remove it from the execution context stack.

25. Resume the context that is now on the top of the execution context
    stack as the running execution context.

26. Return _result_.

NOTE The eval code cannot instantiate variable or function bindings in
the variable environment of the calling context that invoked the eval if
either the code of the calling context or the eval code is strict code.
Instead such bindings are instantiated in a new VariableEnvironment that
is only accessible to the eval code.

Direct Call to Eval

A direct call to the eval function is one that is expressed as a
_CallExpression_ that meets all of the following conditions:

-   The Reference that is the result of evaluating the MemberExpression
    in the CallExpression will always have an environment record as its
    base value and its referenced name is "eval".

-   -   The result of calling the abstract operation GetValue with that
    Reference as the argument is the standard built-in function defined
    in 18.2.1.

Eval Declaration Instantiation

isFinite (number)

Returns FALSE if the argument coerces to NAN, +∞, or −∞, and otherwise
returns TRUE.

1.  Let _num_ be ToNumber(_number_).

2.  ReturnIfAbrupt(_num_).

3.  If _num_ is NAN, +∞, or −∞, return FALSE.

4.  Otherwise, return TRUE.

isNaN (number)

Returns TRUE if the argument coerces to NAN, and otherwise returns
FALSE.

1.  Let _num_ be ToNumber(_number_).

2.  ReturnIfAbrupt(_num_).

3.  If _num_ is NAN, return TRUE.

4.  Otherwise, return FALSE.

NOTE A reliable way for ECMAScript code to test if a value X is a NAN is
an expression of the form X !== X. The result will be TRUE if and only
if X is a NAN.

parseFloat (string)

The PARSEFLOAT function produces a Number value dictated by
interpretation of the contents of the _string_ argument as a decimal
literal.

When the PARSEFLOAT function is called, the following steps are taken:

1.  Let _inputString_ be ToString(_string_).

2.  ReturnIfAbrupt(_inputString_).

3.  Let _trimmedString_ be a substring of _inputString_ consisting of
    the leftmost code unit that is not a _StrWhiteSpaceChar_ and all
    code units to the right of that code unit. (In other words, remove
    leading white space.) If _inputString_ does not contain any such
    code units, let _trimmedString_ be the empty string.

4.  If neither _trimmedString_ nor any prefix of _trimmedString
    satisfies the syntax of a _StrDecimalLiteral_ (see 7.1.3.1), return
    NAN.

5.  Let _numberString_ be the longest prefix of _trimmedString_, which
    might be _trimmedString_ itself, that satisfies the syntax of a
    _StrDecimalLiteral_.

6.  Return the Number value for the MV of _numberString_.

NOTE PARSEFLOAT may interpret only a leading portion of _string_ as a
Number value; it ignores any code units that cannot be interpreted as
part of the notation of an decimal literal, and no indication is given
that any such code units were ignored.

parseInt (string , radix)

The PARSEINT function produces an integer value dictated by
interpretation of the contents of the _string_ argument according to the
specified _radix_. Leading white space in _string_ is ignored. If
_radix_ is UNDEFINED or 0, it is assumed to be 10 except when the number
begins with the code unit pairs 0X or 0X, in which case a radix of 16 is
assumed. If _radix_ is 16, the number may also optionally begin with the
code unit pairs 0X or 0X.

When the PARSEINT function is called, the following steps are taken:

1.  Let _inputString_ be ToString(_string_).

2.  ReturnIfAbrupt(_string_).

3.  Let _S_ be a newly created substring of _inputString_ consisting of
    the first code unit that is not a _StrWhiteSpaceChar_ and all code
    unit following that code unit. (In other words, remove leading white
    space.) If _inputString_ does not contain any such code unit, let
    _S_ be the empty string.

4.  Let _sign_ be 1.

5.  If _S_ is not empty and the first code unit of _S_ is U+002D
    (HYPHEN-MINUS), let _sign_ be −1.

6.  If _S_ is not empty and the first code unit of _S_ is U+002B (PLUS
    SIGN) or U+002D (HYPHEN-MINUS), then remove the first code unit from
    _S_.

7.  Let _R_ = ToInt32(_radix_).

8.  ReturnIfAbrupt(_R_).

9.  Let _stripPrefix_ be TRUE.

10. If _R_ ≠ 0, then

    a.  If _R_ < 2 or _R_ > 36, then return NAN.

    b.  If _R_ ≠ 16, let _stripPrefix_ be FALSE.

11. Else _R_ = 0,

    a.  Let _R_ = 10.

12. If _stripPrefix_ is TRUE, then

    a.  If the length of _S_ is at least 2 and the first two code units
        of _S_ are either “0X” or “0X”, then remove the first two code
        units from _S_ and let _R_ = 16.

13. If _S_ contains any code units that is not a radix-_R_ digit, then
    let _Z_ be the substring of _S_ consisting of all code units before
    the first such code unit; otherwise, let _Z_ be _S_.

14. If _Z_ is empty, return NAN.

15. Let _mathInt_ be the mathematical integer value that is represented
    by _Z_ in radix-_R_ notation, using the letters A-Z and A-Z for
    digits with values 10 through 35. (However, if _R_ is 10 and _Z_
    contains more than 20 significant digits, every significant digit
    after the 20th may be replaced by a 0 digit, at the option of the
    implementation; and if _R_ is not 2, 4, 8, 10, 16, or 32, then
    _mathInt_ may be an implementation-dependent approximation to the
    mathematical integer value that is represented by _Z_ in radix-_R_
    notation.)

16. Let _number_ be the Number value for _mathInt_.

17. Return _sign_ × _number_.

NOTE PARSEINT may interpret only a leading portion of _string_ as an
integer value; it ignores any code units that cannot be interpreted as
part of the notation of an integer, and no indication is given that any
such code units were ignored.

URI Handling Functions 

Uniform Resource Identifiers, or URIs, are Strings that identify
resources (e.g. web pages or files) and transport protocols by which to
access them (e.g. HTTP or FTP) on the Internet. The ECMAScript language
itself does not provide any support for using URIs except for functions
that encode and decode URIs as described in 18.2.6.2, 18.2.6.3, 18.2.6.4
and 18.2.6.5

NOTE Many implementations of ECMAScript provide additional functions and
methods that manipulate web pages; these functions are beyond the scope
of this standard.

URI Syntax and Semantics

A URI is composed of a sequence of components separated by component
separators. The general form is:

_Scheme_ : _First_ / _Second_ ; _Third_ ? _Fourth

where the italicized names represent components and “:”, “/”, “;” and
“?” are reserved for use as separators. The ENCODEURI and DECODEURI
functions are intended to work with complete URIs; they assume that any
reserved code units in the URI are intended to have special meaning and
so are not encoded. The ENCODEURICOMPONENT and DECODEURICOMPONENT
functions are intended to work with the individual component parts of a
URI; they assume that any reserved codce units represent text and so
must be encoded so that they are not interpreted as reserved code units
when the component is part of a complete URI.

The following lexical grammar specifies the form of encoded URIs.

Syntax

uri :::

uriCharacters~opt~

uriCharacters :::

uriCharacter uriCharacters~opt~

uriCharacter :::

uriReserved
uriUnescaped
uriEscaped

uriReserved ::: ONE OF

; / ? : @ & = + $ ,

uriUnescaped :::

uriAlpha
DecimalDigit
uriMark

uriEscaped :::

% HexDigit HexDigit

uriAlpha ::: ONE OF

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

uriMark ::: ONE OF

- _ . ! ~ * ' ( )

NOTE The above syntax is based upon RFC 2396 and does not reflect
changes introduced by the more recent RFC 3986.

RUNTIME SEMANTICS

When a code unit to be included in a URI is not listed above or is not
intended to have the special meaning sometimes given to the reserved
code units, that code unit must be encoded. The code unit is transformed
into its UTF-8 encoding, with surrogate pairs first converted from
UTF-16 to the corresponding code point value. (Note that for code units
in the range [0,127] this results in a single octet with the same
value.) The resulting sequence of octets is then transformed into a
String with each octet represented by an escape sequence of the form
“%xx”.

Runtime Semantics: Encode Abstract Operation

The encoding and escaping process is described by the abstract operation
Encode taking two String arguments _string_ and _unescapedSet_.

1.  Let _strLen_ be the number of code units in _string_.

2.  Let _R_ be the empty String.

3.  Let _k_ be 0.

4.  Repeat

    a.  If _k_ equals _strLen_, return _R_.

    b.  Let _C_ be the code unit at position _k_ within _string_.

    c.  If _C_ is in _unescapedSet_, then

        i.  Let _S_ be a String containing only the code unit _C_.

        ii. Let _R_ be a new String value computed by concatenating the
            previous value of _R_ and _S_.

    d.  Else _C_ is not in _unescapedSet_,

        i.  If the code unit value of _C_ is not less than 0xDC00 and
            not greater than 0xDFFF, throw a URIERROR exception.

        ii. If the code unit value of _C_ is less than 0xD800 or greater
            than 0xDBFF, then

            1.  Let _V_ be the code unit value of _C_.

        iii. Else,

            1.  Increase _k_ by 1.

            2.  If _k_ equals _strLen_, throw a URIERROR exception.

            3.  Let _kChar_ be the code unit value of the code unit at
                position _k_ within _string_.

            4.  If _kChar_ is less than 0xDC00 or greater than 0xDFFF,
                throw a URIERROR exception.

            5.  Let _V_ be (((the code unit value of _C_) – 0xD800) ×
                0x400 + (_kChar_ – 0xDC00) + 0x10000).

        iv. Let _Octets_ be the array of octets resulting by applying
            the UTF-8 transformation to _V_, and let _L_ be the array
            size.

        v.  Let _j_ be 0.

        vi. Repeat, while _j_ < _L_

            1.  Let _jOctet_ be the value at position _j_ within
                _Octets_.

            2.  Let _S_ be a String containing three code units “%_XY_”
                where _XY_ are two uppercase hexadecimal digits encoding
                the value of _jOctet_.

            3.  Let _R_ be a new String value computed by concatenating
                the previous value of _R_ and _S_.

            4.  Increase _j_ by 1.

    e.  Increase _k_ by 1.

Runtime Semantics: Decode Abstract Operation

The unescaping and decoding process is described by the abstract
operation Decode taking two String arguments _string_ and _reservedSet_.

1.  Let _strLen_ be the number of code units in _string_.

2.  Let _R_ be the empty String.

3.  Let _k_ be 0.

4.  Repeat

    a.  If _k_ equals _strLen_, return _R_.

    b.  Let _C_ be the code unit at position _k_ within _string_.

    c.  If _C_ is not ‘%’, then

        i.  Let _S_ be the String containing only the code unit _C_.

    d.  Else _C_ is ‘%’,

        i.  Let _start_ be _k_.

        ii. If _k_ + 2 is greater than or equal to _strLen_, throw a
            URIERROR exception.

        iii. If the code units at position (_k_+1) and (_k_ + 2) within
            _string_ do not represent hexadecimal digits, throw a
            URIERROR exception.

        iv. Let _B_ be the 8-bit value represented by the two
            hexadecimal digits at position (_k_ + 1) and (_k_ + 2).

        v.  Increment _k_ by 2.

        vi. If the most significant bit in _B_ is 0, then

            1.  Let _C_ be the code unit with code unit value _B_.

            2.  If _C_ is not in _reservedSet_, then

                a.  Let _S_ be the String containing only the code unit
                    _C_.

            3.  Else _C_ is in _reservedSet_,

                a.  Let _S_ be the substring of _string_ from position
                    _start_ to position _k_ included.

        vii. Else the most significant bit in _B_ is 1,

            1.  Let _n_ be the smallest nonnegative integer such that
                (_B_ << _n_) & 0x80 is equal to 0.

            2.  If _n_ equals 1 or _n_ is greater than 4, throw a
                URIERROR exception.

            3.  Let _Octets_ be an array of 8-bit integers of size _n_.

            4.  Put _B_ into _Octets_ at position 0.

            5.  If _k_ + (3 × (_n_ – 1)) is greater than or equal to
                _strLen_, throw a URIERROR exception.

            6.  Let _j_ be 1.

            7.  Repeat, while _j_ < _n_

                a.  Increment _k_ by 1.

                b.  If the code unit at position _k_ within _string_ is
                    not "%", throw a URIERROR exception.

                c.  If the code units at position (_k_ +1) and (_k_ + 2)
                    within _string_ do not represent hexadecimal digits,
                    throw a URIERROR exception.

                d.  Let _B_ be the 8-bit value represented by the two
                    hexadecimal digits at position (_k_ + 1) and (_k_ +
                    2).

                e.  If the two most significant bits in _B_ are not 10,
                    throw a URIERROR exception.

                f.  Increment _k_ by 2.

                g.  Put _B_ into _Octets_ at position _j_.

                h.  Increment _j_ by 1.

            8.  Let _V_ be the value obtained by applying the UTF-8
                transformation to _Octets_, that is, from an array of
                octets into a 21-bit value. If _Octets_ does not contain
                a valid UTF-8 encoding of a Unicode code point throw a
                URIERROR exception.

            9.  If _V_ < 0x10000, then

                a.  Let _C_ be the code unit _V_.

                b.  If _C_ is not in _reservedSet_, then

                    i.  Let _S_ be the String containing only the code
                        unit _C_.

                c.  Else _C_ is in _reservedSet_,

                    i.  Let _S_ be the substring of _string_ from
                        position _start_ to position _k_ included.

            10. Else _V_ ≥ 0x10000,

                a.  Let _L_ be (((_V_ – 0x10000) & 0x3FF) + 0xDC00).

                b.  Let _H_ be ((((_V_ – 0x10000) >> 10) & 0x3FF) +
                    0xD800).

                c.  Let _S_ be the String containing the two code units
                    _H_ and _L_.

    e.  Let _R_ be a new String value computed by concatenating the
        previous value of _R_ and _S_.

    f.  Increase _k_ by 1.

NOTE This syntax of Uniform Resource Identifiers is based upon RFC 2396
and does not reflect the more recent RFC 3986 which replaces RFC 2396. A
formal description and implementation of UTF-8 is given in RFC 3629.

In UTF-8, characters are encoded using sequences of 1 to 6 octets. The
only octet of a "sequence" of one has the higher-order bit set to 0, the
remaining 7 bits being used to encode the character value. In a sequence
of n octets, n>1, the initial octet has the n higher-order bits set to
1, followed by a bit set to 0. The remaining bits of that octet contain
bits from the value of the character to be encoded. The following octets
all have the higher-order bit set to 1 and the following bit set to 0,
leaving 6 bits in each to contain bits from the character to be encoded.
The possible UTF-8 encodings of ECMAScript characters are specified in
Table 39.

Table 39 — UTF-8 Encodings

  ------------------- --------------------- --------------- --------------- --------------- ---------------
  _CODE UNIT VALUE_   _REPRESENTATION_      _1^ST^ OCTET_   _2^ND^ OCTET_   _3^RD^ OCTET_   _4^TH^ OCTET_

  0X0000 - 0X007F     00000000 0_zzzzzzz_   0_zzzzzzz_                                      

  0X0080 - 0X07FF     00000_yyy yyzzzzzz_   110_yyyyy_      10_zzzzzz_                      

  0X0800 - 0XD7FF     _xxxxyyyy yyzzzzzz_   1110_xxxx_      10_yyyyyy_      10_zzzzzz_      

  0XD800 - 0XDBFF     110110_vv vvwwwwxx_   11110_uuu_      10_uuwwww_      10_xxyyyy_      10_zzzzzz_
                                                                                            
  _followed by_       _followed by_                                                         
                                                                                            
  0XDC00 – 0XDFFF     110111_yy yyzzzzzz_                                                   

  0XD800 - 0XDBFF     _causes_ URIERROR                                                     
                                                                                            
  _not followed by_                                                                         
                                                                                            
  0XDC00 – 0XDFFF                                                                           

  0XDC00 – 0XDFFF     _causes_ URIERROR                                                     

  0XE000 - 0XFFFF     _xxxxyyyy yyzzzzzz_   1110_xxxx_      10_yyyyyy_      10_zzzzzz_      
  ------------------- --------------------- --------------- --------------- --------------- ---------------

Where

_uuuuu_ = _vvvv_ + 

to account for the addition of 0x10000 as in Surrogates, section 3.7, of
the Unicode Standard.

The range of code unit values 0xD800-0xDFFF is used to encode surrogate
pairs; the above transformation combines a UTF-16 surrogate pair into a
UTF-32 representation and encodes the resulting 21-bit value in UTF-8.
Decoding reconstructs the surrogate pair.

RFC 3629 prohibits the decoding of invalid UTF-8 octet sequences. For
example, the invalid sequence C0 80 must not decode into the code unit
U+0000. Implementations of the Decode algorithm are required to throw a
URIERROR when encountering such invalid sequences.

decodeURI (encodedURI)

The DECODEURI function computes a new version of a URI in which each
escape sequence and UTF-8 encoding of the sort that might be introduced
by the ENCODEURI function is replaced with the UTF-16 encoding of the
code points that it represents. Escape sequences that could not have
been introduced by ENCODEURI are not replaced.

When the DECODEURI function is called with one argument _encodedURI_,
the following steps are taken:

1.  Let _uriString_ be ToString(_encodedURI_).

2.  ReturnIfAbrupt(_uriString_).

3.  Let _reservedURISet_ be a String containing one instance of each
    code unit valid in _uriReserved_ plus “#”.

4.  Return the result of calling Decode(_uriString_, _reservedURISet_)

NOTE The code point “#” is not decoded from escape sequences even though
it is not a reserved URI code point.

 decodeURIComponent (encodedURIComponent)

The DECODEURICOMPONENT function computes a new version of a URI in which
each escape sequence and UTF-8 encoding of the sort that might be
introduced by the ENCODEURICOMPONENT function is replaced with the
UTF-16 encoding of the code points that it represents.

When the DECODEURICOMPONENT function is called with one argument
_encodedURIComponent_, the following steps are taken:

1.  Let _componentString_ be ToString(_encodedURIComponent_).

2.  ReturnIfAbrupt(_componentString_).

3.  Let _reservedURIComponentSet_ be the empty String.

4.  Return Decode(_componentString_, _reservedURIComponentSet_)

encodeURI (uri)

The ENCODEURI function computes a new version of an UTF-16 encoded URI
in which each instance of certain code points is replaced by one, two,
three, or four escape sequences representing the UTF-8 encoding of the
code points.

When the ENCODEURI function is called with one argument _uri_, the
following steps are taken:

1.  Let _uriString_ be ToString(_uri_).

2.  ReturnIfAbrupt(_uriString_).

3.  Let _unescapedURISet_ be a String containing one instance of each
    code unit valid in _uriReserved_ and _uriUnescaped_ plus "#".

4.  Return Encode(_uriString_, _unescapedURISet_)

NOTE The code point "#" is not encoded to an escape sequence even though
it is not a reserved or unescaped URI code point.

encodeURIComponent (uriComponent)

The ENCODEURICOMPONENT function computes a new version of an UTF-16
encoded URI in which each instance of certain code points is replaced by
one, two, three, or four escape sequences representing the UTF-8
encoding of the code point.

When the ENCODEURICOMPONENT function is called with one argument
_uriComponent_, the following steps are taken:

1.  Let _componentString_ be ToString(_uriComponent_).

2.  ReturnIfAbrupt(_componentString_).

3.  Let _unescapedURIComponentSet_ be a String containing one instance
    of each code unit valid in _uriUnescaped_.

4.  Return Encode(_componentString_, _unescapedURIComponentSet_)


Constructor Properties of the Global Object

Array ( . . . )

See 22.1.1.

ArrayBuffer ( . . . )

See 24.1.2.

Boolean ( . . . )

See 19.3.1.

DataView ( . . . )

See 24.2.2.

Date ( . . . )

See 20.3.2.

Error ( . . . )

See 19.5.1.

EvalError ( . . . )

See 19.5.5.1.

Float32Array ( . . . )

See 22.2.4.

Float64Array ( . . . )

See 22.2.4.

Function ( . . . )

See 19.2.1.

Int8Array ( . . . )

See 22.2.4.

Int16Array ( . . . )

See 22.2.4.

Int32Array ( . . . )

See 22.2.4.

Map ( . . . )

See 23.1.1.

Number ( . . . )

See 20.1.1.

Object ( . . . )

See 19.1.1.

RangeError ( . . . )

See 19.5.5.2.

ReferenceError ( . . . )

See 19.5.5.3.

RegExp ( . . . )

See 21.2.4.

Set ( . . . )

See 23.2.1.

String ( . . . )

See 21.1.1.

Symbol ( . . . )

See 19.4.1.

SyntaxError ( . . . )

See 19.5.5.4.

TypeError ( . . . )

See 19.5.5.5.

Uint8Array ( . . . )

See 22.2.4.

Uint8ClampedArray ( . . . )

See 22.2.4.

Uint16Array ( . . . )

See 22.2.4.

Uint32Array ( . . . )

See 22.2.4.

URIError ( . . . )

See 19.5.5.6.

WeakMap ( . . . )

See 23.3.1.

WeakSet ( . . . )

See 23.4.


Other Properties of the Global Object

JSON

See 24.3.

Math

See 20.2.

Proxy ( . . . )

See 26.5.1.

Reflect

See 26.1.

System

See 26.4.



FUNDAMENTAL OBJECTS 


Object Objects

The Object Constructor

The Object constructor is the %Object% intrinsic object and the initial
value of the OBJECT property of the global object. When OBJECT is called
as a function rather than as a constructor, it performs a type
conversion.

The OBJECT constructor is designed to be subclassable. It may be used as
the value of an EXTENDS clause of a class declaration.

NOTE Subclass constructors that inherit from the Object constructor
typically should not include a SUPER call to OBJECT as it performs no
initialization action on its THIS value and does not return its THIS
value as its value.

Object ( [ value ] )

When OBJECT function is called with optional argument _value_, the
following steps are taken:

1.  If _value_ is NULL, UNDEFINED or not supplied, return
    ObjectCreate(%ObjectPrototype%).

2.  Return ToObject(_value_).

new Object ( ...argumentsList )

When OBJECT is called as part of a new expression , it creates a new
object:

1.  Let _F_ be the OBJECT function object on which the NEW operator was
    applied.

2.  Let _argumentsList_ be the _argumentsList_ argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of calling the [[Call]] internal method of _F_,
    providing UNDEFINED and _argumentsList_ as the arguments.

The above steps defined the [[Construct]] internal method of the Object
constructor. Object may not be implemented as an ECMAScript function
object because this definition differs from the definition of
[[Construct]] used by ECMAScript function objects.

Properties of the Object Constructor

The value of the [[Prototype]] internal slot of the Object constructor
is the standard built-in Function prototype object.

Besides the LENGTH property (whose value is 1), the Object constructor
has the following properties:

Object.assign ( target, ...sources )

The ASSIGN function is used to copy the values of all of the enumerable
own properties from one or more source objects to a _target_ object.
When the ASSIGN function is called, the following steps are taken:

1.  Let _to_ be ToObject(_target_).

2.  ReturnIfAbrupt(_to_).

3.  If fewer than two arguments were passed, then return _to_.

4.  Let _sources_ be the List of argument values starting with the
    second argument.

5.  For each element _nextSource_ of _sources_, in ascending index
    order,

    a.  Let _from_ be ToObject(_nextSource_).

    b.  ReturnIfAbrupt(_from_).

    c.  Let _keysArray_ be the result of calling the [[OwnPropertyKeys]]
        internal method of _nextSource_.

    d.  ReturnIfAbrupt(_keysArray_).

    e.  Let _lenValue_ be Get(_keysArray_, "LENGTH").

    f.  Let _len_ be ToLength(_lenValue_).

    g.  ReturnIfAbrupt(_len_).

    h.  Let _nextIndex_ be 0.

    i.  j.  Let _pendingException_ be UNDEFINED.

    k.  Repeat while _nextIndex_ _< len_,

        i.  ii. iii. iv. v.  Let _nextKey_ be Get(_keysArray_,
            ToString(_nextIndex_)).

        vi. ReturnIfAbrupt(_nextKey_).

        vii. Let _desc_ be the result of calling the [[GetOwnProperty]]
            internal method of _from_ with argument _nextKey_.

        viii. If _desc_ is an abrupt completion, then

            1.  If _pendingException_ is UNDEFINED, then set
                _pendingException_ to _desc_.

        ix. Else if _desc_ is not UNDEFINED and _desc_.[[Enumerable]] is
            TRUE, then

            1.  Let _propValue_ be Get(_from_, _nextKey_).

            2.  If _propValue_ is an abrupt completion, then

                a.  If _pendingException_ is UNDEFINED, then set
                    _pendingException_ to _propValue_.

            3.  else

                a.  Let _status_ be Put(_to_, _nextKey_, _propValue_,
                    TRUE);

                b.  If _status_ is an abrupt completion, then

                    i.  If _pendingException_ is UNDEFINED, then set
                        _pendingException_ to _status_.

        x.  Increment _nextIndex_ by 1.

    l.  If _pendingException_ is not UNDEFINED, then return
        _pendingException_.

6.  Return _to_.

The LENGTH property of the ASSIGN method is 2.

Object.create ( O [ , Properties ] )

The CREATE function creates a new object with a specified prototype.
When the CREATE function is called, the following steps are taken:

1.  If Type(_O_) is not Object or Null throw a TYPEERROR exception.

2.  Let _obj_ be ObjectCreate(_O_).

3.  If the argument _Properties_ is present and not UNDEFINED, then

    a.  Return the result of the abstract operation
        ObjectDefineProperties(_obj_, _Properties_).

4.  Return _obj_.

Object.defineProperties ( O, Properties )

The DEFINEPROPERTIES function is used to add own properties and/or
update the attributes of existing own properties of an object. When the
DEFINEPROPERTIES function is called, the following steps are taken:

1.  Return the result of the abstract operation ObjectDefineProperties
    with arguments _O_ and _Properties_.

Runtime Semantics: ObjectDefineProperties Abstract Operation

The abstract operation ObjectDefineProperties with arguments _O_ and
_Properties_ performs the following steps:

1.  If Type(_O_) is not Object throw a TYPEERROR exception.

2.  Let _props_ be ToObject(_Properties_).

3.  Let _names_ be a List containing the keys of each enumerable own
    property of _props._

4.  Let _keysArray_ be the result of calling the [[OwnPropertyKeys]]
    internal method of _props_.

5.  ReturnIfAbrupt(_keysArray_).

6.  Let _lenValue_ be Get(_keysArray_, "LENGTH").

7.  Let _len_ be ToLength(_lenValue_).

8.  ReturnIfAbrupt(_len_).

9.  Let _nextIndex_ be 0.

10. Let _descriptors_ be an empty List.

11. Repeat while _nextIndex_ _< len_,

    a.  Let _nextKey_ be Get(_keysArray_, ToString(_nextIndex_)).

    b.  ReturnIfAbrupt(_nextKey_).

    c.  Increment _nextIndex_ by 1.

    d.  Let _propDesc_ be the result of calling the [[GetOwnProperty]]
        internal method of _props_ with argument _nextKey_.

    e.  ReturnIfAbrupt(_propDesc_).

    f.  If _propDesc_ is not UNDEFINED and _propDesc_.[[Enumerable]] is
        TRUE, then

        i.  Let _descObj_ be the result of Get( _props_, _nextKey_).

        ii. ReturnIfAbrupt(_descObj_).

        iii. Let _desc_ be the result of calling ToPropertyDescriptor
            with _descObj_ as the argument.

        iv. ReturnIfAbrupt(_desc_).

        v.  Append the pair (a two element List) consisting of _nextKey_
            and _desc_ to the end of _descriptors_.

12. Let _pendingException_ be UNDEFINED.

13. For each _pair_ from _descriptors_ in list order,

    a.  Let _P_ be the first element of _pair_.

    b.  Let _desc_ be the second element of _pair_.

    c.  Let _status_ be the result of DefinePropertyOrThrow(_O_,_P_,
        _desc_).

    d.  If _status_ is an abrupt completion then,

        i.  If _pendingException_ is UNDEFINED, then set
            _pendingException_ to _status_.

14. ReturnIfAbrupt(_pendingException_).

15. Return _O_.

NOTE An exception in defining an individual property in step 13 does not
terminate the process of defining other properties. All valid property
definitions are processed.

Object.defineProperty ( O, P, Attributes )

The DEFINEPROPERTY function is used to add an own property and/or update
the attributes of an existing own property of an object. When the
DEFINEPROPERTY function is called, the following steps are taken:

1.  If Type(_O_) is not Object throw a TYPEERROR exception.

2.  Let _key_ be ToPropertyKey(_P_).

3.  ReturnIfAbrupt(_key_).

4.  Let _desc_ be the result of calling
    ToPropertyDescriptor(_Attributes_).

5.  ReturnIfAbrupt(_desc_).

6.  Let _success_ be the result of DefinePropertyOrThrow(_O,key_,
    _desc_).

7.  ReturnIfAbrupt(_success_).

8.  Return _O_.

Object.freeze ( O )

When the FREEZE function is called, the following steps are taken:

1.  If Type(_O_) is not Object, return _O_.

2.  Let _status_ be the result of SetIntegrityLevel( _O_, "FROZEN").

3.  ReturnIfAbrupt(_status_).

4.  If _status_ is FALSE, throw a TYPEERROR exception.

5.  Return _O_.

Object.getOwnPropertyDescriptor ( O, P ) 

When the GETOWNPROPERTYDESCRIPTOR function is called, the following
steps are taken:

1.  Let _obj_ be ToObject(_O_).

2.  ReturnIfAbrupt(_obj_).

3.  Let _key_ be ToPropertyKey(_P_).

4.  ReturnIfAbrupt(_key_).

5.  Let _desc_ be the result of calling the [[GetOwnProperty]] internal
    method of _obj_ with argument _key_.

6.  ReturnIfAbrupt(_desc_).

7.  Return the result of calling FromPropertyDescriptor(_desc_).

Object.getOwnPropertyNames ( O )

When the GETOWNPROPERTYNAMES function is called, the following steps are
taken:

1.  Return GetOwnPropertyKeys(_O_, String).

Object.getOwnPropertySymbols ( O )

When the GETOWNPROPERTYSYMBOLS function is called with argument _O_, the
following steps are taken:

1.  Return GetOwnPropertyKeys(_O_, Symbol).

GetOwnPropertyKeys ( O, Type ) Abstract Operation

The abstract operation GetOwnPropertyKeys is called with arguments _O_
and _Type_ where _O_ is an Object and _Type_ is one of the ECMAScript
specification types String or Symbol. The following steps are taken:

1.  Let _obj_ be ToObject(_O_).

2.  ReturnIfAbrupt(_obj_).

3.  Let _keysArray_ be the result of calling the [[OwnPropertyKeys]]
    internal method of _obj_.

4.  ReturnIfAbrupt(_keysArray_).

5.  Let _lenValue_ be Get(_keysArray_, "LENGTH").

6.  Let _len_ be ToLength(_lenValue_).

7.  ReturnIfAbrupt(_len_).

8.  Let _nextIndex_ be 0.

9.  Let _nameList_ be a new empty List.

10. 11. Repeat while _nextIndex_ _< len_,

    a.  Let _nextKey_ be Get(_keysArray_, ToString(_nextIndex_)).

    b.  c.  d.  e.  f.  ReturnIfAbrupt(_nextKey_).

    g.  If Type(_nextKey_) is _Type_, then

        i.  Append _nextKey_ as the last element of _nameList_.

    h.  Increment _nextIndex_ by 1.

12. Return CreateArrayFromList(_nameList_).

Object.getPrototypeOf ( O )

When the GETPROTOTYPEOF function is called with argument _O_, the
following steps are taken:

1.  Let _obj_ be ToObject(_O_).

2.  ReturnIfAbrupt(_obj_).

3.  Return the result of calling the [[GetPrototypeOf]] internal method
    of _obj_.

Object.is ( value1, value2 )

When the IS function is called with arguments _value1_ and _value2_ the
following steps are taken:

1.  Return SameValue(_value1_, _value2_).

Object.isExtensible ( O )

When the ISEXTENSIBLE function is called with argument _O_, the
following steps are taken:

1.  If Type(_O_) is not Object, return FALSE.

2.  Return the result of IsExtensible(_O_).

Object.isFrozen ( O )

When the ISFROZEN function is called with argument _O_, the following
steps are taken:

1.  If Type(_O_) is not Object, return TRUE.

2.  Return TestIntegrityLevel(_O_, "FROZEN").

Object.isSealed ( O )

When the ISSEALED function is called with argument _O_, the following
steps are taken:

1.  If Type(_O_) is not Object, return TRUE.

2.  Return TestIntegrityLevel(_O_, "SEALED").

Object.keys ( O )

When the KEYS function is called with argument _O_, the following steps
are taken:

1.  Let _obj_ be ToObject(_O_).

2.  ReturnIfAbrupt(_obj_).

3.  Let _keysArray_ be the result of calling the [[OwnPropertyKeys]]
    internal method of _obj_.

4.  ReturnIfAbrupt(_keysArray_).

5.  Let _lenValue_ be Get(_keysArray_, "LENGTH").

6.  Let _len_ be ToLength(_lenValue_).

7.  ReturnIfAbrupt(_len_).

8.  Let _nextIndex_ be 0.

9.  Let _nameList_ be a new empty List.

10. 11. Repeat while _nextIndex_ _< len_,

    a.  Let _nextKey_ be Get(_keysArray_, ToString(_nextIndex_)).

    b.  c.  d.  e.  f.  ReturnIfAbrupt(_nextKey_).

    g.  If Type(_nextKey_) is String, then

        i.  Let _desc_ be the result of calling the [[GetOwnProperty]]
            internal method of _O_ with argument _nextKey_.

        ii. ReturnIfAbrupt(_desc_).

        iii. If _desc_ is not UNDEFINED and _desc_.[[Enumerable]] is
            TRUE, then

            1.  Append _nextKey_ as the last element of _nameList_.

    h.  Increment _nextIndex_ by 1.

12. Return CreateArrayFromList(_nameList_).

If an implementation defines a specific order of enumeration for the
for-in statement, the same order must be used for the elements of the
array returned in step 11.

Object.preventExtensions ( O )

When the PREVENTEXTENSIONS function is called, the following steps are
taken:

1.  If Type(_O_) is not Object, return _O_.

2.  Let _status_ be the result of calling the [[PreventExtensions]]
    internal method of _O_.

3.  ReturnIfAbrupt(_status_).

4.  If _status_ is FALSE, throw a TYPEERROR exception.

5.  Return _O_.

Object.prototype

The initial value of OBJECT.PROTOTYPE is the standard built-in Object
prototype object (19.1.3).

This property has the attributes {[[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Object.seal ( O )

When the SEAL function is called, the following steps are taken:

1.  If Type(_O_) is not Object, return _O_.

2.  Let _status_ be the result of SetIntegrityLevel( _O_, "SEALED").

3.  ReturnIfAbrupt(_status_).

4.  If _status_ is FALSE, throw a TYPEERROR exception.

5.  Return _O_.

Object.setPrototypeOf ( O, proto )

When the SETPROTOTYPEOF function is called with arguments _O_ and proto,
the following steps are taken:

1.  Let _O_ be CheckObjectCoercible(_O_)_.

2.  ReturnIfAbrupt(_O_).

3.  If Type(_proto_) is neither Object nor Null, then throw a TYPEERROR
    exception.

4.  If Type(_O_) is not Object, then return _O_.

5.  Let _status_ be the result of calling the [[SetPrototypeOf]]
    internal method of _O_ with argument _proto_.

6.  ReturnIfAbrupt(_status_).

7.  If _status_ is FALSE, then throw a TYPEERROR exception.

8.  Return _O_.

Properties of the Object Prototype Object

The Object prototype object is an ordinary object.

The value of the [[Prototype]] internal slot of the Object prototype
object is NULL and the initial value of the [[Extensible]] internal slot
is TRUE.

Object.prototype.constructor

The initial value of OBJECT.PROTOTYPE.CONSTRUCTOR is the standard
built-in OBJECT constructor.

Object.prototype.hasOwnProperty ( V )

When the HASOWNPROPERTY method is called with argument _V_, the
following steps are taken:

1.  Let _P_ be ToPropertyKey(_V_).

2.  ReturnIfAbrupt(_P_).

3.  Let _O_ be the result of calling ToObject passing the THIS value as
    the argument.

4.  ReturnIfAbrupt(_O_).

5.  Return the result of HasOwnProperty(_O_, _P_).

NOTE The ordering of steps 1 and 3 is chosen to ensure that any
exception that would have been thrown by step 1 in previous editions of
this specification will continue to be thrown even if the THIS value is
UNDEFINED or NULL.

Object.prototype.isPrototypeOf ( V )

When the ISPROTOTYPEOF method is called with argument _V_, the following
steps are taken:

1.  If _V_ is not an object, return FALSE.

2.  Let _O_ be the result of calling ToObject passing the THIS value as
    the argument.

3.  ReturnIfAbrupt(_O_).

4.  Repeat

    a.  Let _V_ be the result of calling the [[GetPrototypeOf]] internal
        method of _V_ with no arguments.

    b.  if _V_ is NULL, return FALSE

    c.  If SameValue(_O_, _V_) is TRUE, then return TRUE.

NOTE The ordering of steps 1 and 2 preserves the behaviour specified by
previous editions of this specification for the case where V is not an
object and the THIS value is UNDEFINED or null.

Object.prototype.propertyIsEnumerable ( V )

When the PROPERTYISENUMERABLE method is called with argument _V_, the
following steps are taken:

1.  Let _P_ be ToPropertyKey(_V_).

2.  ReturnIfAbrupt(_P_).

3.  Let _O_ be the result of calling ToObject passing the THIS value as
    the argument.

4.  ReturnIfAbrupt(_O_).

5.  Let _desc_ be the result of calling the [[GetOwnProperty]] internal
    method of _O_ passing _P_ as the argument.

6.  ReturnIfAbrupt(_desc_).

7.  If _desc_ is UNDEFINED, return FALSE.

8.  Return the value of _desc_.[[Enumerable]].

NOTE 1 This method does not consider objects in the prototype chain.

NOTE 2 The ordering of steps 1 and 3 is chosen to ensure that any
exception that would have been thrown by step 1 in previous editions of
this specification will continue to be thrown even if the THIS value is
UNDEFINED or NULL.

Object.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] )

When the TOLOCALESTRING method is called, the following steps are taken:

1.  Let _O_ be the THIS value.

2.  Return the result of Invoke(_O_, "TOSTRING").

The the optional parameters to this method are not used but may be
passed by inplementations that include ECMA-402 support. Implementations
that do not include ECMA-402 support must not use those parameters
position.

NOTE 1 This method provides a generic TOLOCALESTRING implementation for
objects that have no locale-specific TOSTRING behaviour. ARRAY, NUMBER,
DATE, and TYPED ARRAYS provide their own locale-sensitive TOLOCALESTRING
methods.

NOTE 2 ECMA-402 intentionally does not provide an alternative to this
default implementation.

Object.prototype.toString ( )

When the TOSTRING method is called, the following steps are taken:

1.  If the THIS value is UNDEFINED, return "[OBJECT UNDEFINED]".

2.  If the THIS value is NULL, return "[OBJECT NULL]".

3.  Let _O_ be the result of calling ToObject passing the THIS value as
    the argument.

4.  If _O_ is an exotic Array object, then let _builtinTag_ be "ARRAY".

5.  Else, if _O_ is an exotic String object, then let _builtinTag_ be
    "STRING".

6.  7.  Else, if _O_ has an [[ParameterMap]] internal slot, then let
    _builtinTag_ be "ARGUMENTS".

8.  Else, if _O_ has a [[Call]] internal method, then let _builtinTag
    be "FUNCTION".

9.  Else, if _O_ has an [[ErrorData]] internal slot, then let
    _builtinTag_ be "ERROR".

10. Else, if _O_ has a [[BooleanData]] internal slot, then let
    _builtinTag_ be "BOOLEAN".

11. Else, if _O_ has a [[NumberData]] internal slot, then let
    _builtinTag_ be "NUMBER".

12. Else, if _O_ has a [[DateValue]] internal slot, then let
    _builtinTag_ be "DATE".

13. Else, if _O_ has a [[RegExpMatcher]] internal slot, then let
    _builtinTag_ be "REGEXP".

14. Else, let _builtinTag_ be "OBJECT".

15. Let _hasTag_ be the result of HasProperty(_O_, @@toStringTag).

16. ReturnIfAbrupt(_hasTag_).

17. If _hasTag_ is FALSE, then let _tag_ be _builtinTag_.

18. Else,

    a.  Let _tag_ be the result of Get(_O_, @@toStringTag).

    b.  If _tag_ is an abrupt completion, let _tag_ be
        NormalCompletion("???").

    c.  Let _tag_ be _tag_.[[value]].

    d.  If Type(_tag_) is not String, let _tag_ be "???".

    e.  If _tag_ is any of "ARGUMENTS", "ARRAY", "BOOLEAN", "DATE",
        "ERROR", "FUNCTION", "NUMBER", "REGEXP", or "STRING" and
        SameValue(_tag_, _builtinTag_) is FALSE, then let _tag_ be the
        string value "~" concatenated with the current value of _tag_.

19. Return the String value that is the result of concatenating the
    three Strings "[OBJECT ", _tag_, and "]".

NOTE Historically, this function was occasionally used to access the
string value of the [[Class]] internal slot that was used in previous
editions of this specification as a nominal type tag for various
built-in objects. The above definition of TOSTRING preserves
compatability for legacy code that uses TOSTRING as a reliable test for
those specific kinds of built-in objects. It does not provide a reliable
type testing mechanism for other kinds of built-in or program defined
objects. In addition, programs can use @@toStringTag in ways that will
invalidate the reliability of such legacy type tests.

Object.prototype.valueOf ( )

When the VALUEOF method is called, the following steps are taken:

1.  Let _O_ be the result of calling ToObject passing the THIS value as
    the argument.

2.  Return _O_.

Properties of Object Instances

Object instances have no special properties beyond those inherited from
the Object prototype object.


Function Objects

The Function Constructor

The Function constructor is the %Function% intrinsic object and the
initial value of the FUNCTION property of the global object. When
FUNCTION is called as a function rather than as a constructor, it
creates and initializes a new Function object. Thus the function call
FUNCTION(…) is equivalent to the object creation expression NEW
FUNCTION(…) with the same arguments. However, if the THIS value passed
in the call is an Object with a [[Code]] internal slot whose value is
UNDEFINED, it initializes the THIS value using the argument values. This
permits FUNCTION to be used both as factory method and to perform
constructor instance initialization.

FUNCTION may be subclassed and subclass constructors may perform a SUPER
invocation of the FUNCTION constructor to initialize subclass instances.
However, all syntactic forms for defining function objects create
instances of FUNCTION. There is no syntactic means to create instances
of FUNCTION subclasses except for the built-in Generator Function
subclass.

Function ( p1, p2, … , pn, body )

The last argument specifies the body (executable code) of a function;
any preceding arguments specify formal parameters.

When the FUNCTION function is called with some arguments _p1_, _p2_, … ,
_pn_, _body_ (where _n_ might be 0, that is, there are no “_p_”
arguments, and where _body_ might also not be provided), the following
steps are taken:

1.  Let _argCount_ be the total number of arguments passed to this
    function invocation.

2.  Let _P_ be the empty String.

3.  If _argCount_ = 0, let _bodyText_ be the empty String.

4.  Else if _argCount_ = 1, let _bodyText_ be that argument.

5.  Else _argCount_ > 1,

    a.  Let _firstArg_ be the first argument.

    b.  Let _P_ be ToString(_firstArg_).

    c.  ReturnIfAbrupt(_P_).

    d.  Let _k_ be 2.

    e.  Repeat, while _k_ < _argCount_

        i.  Let _nextArg_ be the _k_’th argument.

        ii. Let _nextArgString_ be ToString(_nextArg_).

        iii. ReturnIfAbrupt(_nextArgString_).

        iv. Let _P_ be the result of concatenating the previous value of
            _P_, the String "," (a comma), and _nextArgString_.

        v.  Increase _k_ by 1.

    f.  Let _bodyText_ be the _k_’th argument.

6.  Let _bodyText_ be ToString(_bodyText_).

7.  ReturnIfAbrupt(_bodyText_).

8.  Let _parameters_ be the result of parsing _P_, interpreted as UTF-
    encoded Unicode text as described in 10.1.1_,_ using
    _FormalParameters_ as the goal symbol. Throw a SYNTAXERROR exception
    if the parse fails.

9.  Let _body_ be the result of parsing _bodyText_, interpreted as
    UTF-16 encoded Unicode text as described in 10.1.1_,_ using
    _FunctionBody_ as the goal symbol. Throw a SYNTAXERROR exception if
    the parse fails or if any static semantics errors are detected.

10. 11. If any element of the BoundNames of _parameters_ also occurs in
    the LexicallyDeclaredNames of _body_, then throw a SYNTAXERROR
    exception.

12. If _bodyText_ is strict mode code (see 10.2.1) then let _strict_ be
    TRUE, else let _strict_ be FALSE.

13. Let _scope_ be the Global Environment.

14. Let _F_ be the THIS value.

15. If Type(_F_) is not Object or if _F_ does not have a [[Code]]
    internal slot or if the value of [[Code]] is not UNDEFINED, then

    a.  Let _C_ be the active function object.

    b.  Let _proto_ be the result of GetPrototypeFromConstructor(_C_,
        "%FUNCTIONPROTOTYPE%").

    c.  ReturnIfAbrupt(_proto_).

    d.  Let _F_ be FunctionAllocate(_C_, _strict_).

    e.  ReturnIfAbrupt(_F_).

16. 17. If the value of _F’s_ [[FunctionKind]] internal slot is not
    "NORMAL", then throw a TYPEERROR exception.

18. Let _isExtensible_ be IsExtensible(_F_).

19. ReturnIfAbrupt(_isExtensible_).

20. If _isExtensible_ is FALSE, then throw a TYPEERROR exception.

21. 22. Let _status_ be FunctionInitialize(_F_, Normal, _strict_,
    _parameters_, _body,_ _scope_).

23. ReturnIfAbrupt(_status_).

24. If ReferencesSuper of _body_ is TRUE or ReferencesSuper of
    _parameters_ is TRUE, then

    a.  Perform MakeMethod(_F_, UNDEFINED, UNDEFINED).

25. Let _status_ be the result of MakeConstructor with argument _F_.

26. ReturnIfAbrupt(_status_).

27. Let _hasName_ be HasOwnProperty(_F_, "NAME").

28. ReturnIfAbrupt(_hasName_).

29. If _hasName_ is FALSE, then

    a.  Let _status_ be SetFunctionName(_F_, "ANONYMOUS").

    b.  ReturnIfAbrupt(_status_).

30. Return _F_.

The LENGTH property of the FUNTION function is 1 (see 19.2.2.1).

NOTE 1 A PROTOTYPE property is automatically created for every function
created using the FUNCTION constructor, to provide for the possibility
that the function will be used as a constructor.

NOTE 2 It is permissible but not necessary to have one argument for each
formal parameter to be specified. For example, all three of the
following expressions produce the same result:

  new Function("a", "b", "c", "return a+b+c")

  new Function("a, b, c", "return a+b+c")

  new Function("a,b", "c", "return a+b+c")

new Function ( ...argumentsList )

When FUNCTION is called as part of a NEW expression, it initializes the
newly created object.

1.  Let _F_ be the FUNCTION function object on which the NEW operator
    was applied.

2.  Let _argumentsList_ be the _argumentsList_ argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of Construct (_F_, _argumentsList_).

If FUNCTION is implemented as an ECMAScript function object, its
[[Construct]] internal method will perform the above steps.

Properties of the Function Constructor

The Function constructor is itself a built-in Function object. The value
of the [[Prototype]] internal slot of the Function constructor is
%FunctionPrototype%, the intrinsic Function prototype object (19.2.3).

The value of the [[Extensible]] internal slot of the Function
constructor is TRUE.

The Function constructor has the following properties:

Function.length

This is a data property with a value of 1. This property has the
attributes { [[Writable]]: FALSE, [[Enumerable]]: FALSE,
[[Configurable]]: TRUE }.

Function.prototype

The value of FUNCTION.PROTOTYPE is %FunctionPrototype%, the intrinsic
Function prototype object (19.2.3).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Function[ @@create ] ( )

The @@create method of an object _F_ performs the following steps:

1.  Let _F_ be the THIS value.

2.  Let _proto_ be the result of GetPrototypeFromConstructor(_F_,
    "%FUNCTIONPROTOTYPE%").

3.  ReturnIfAbrupt(_proto_).

4.  Return FunctionAllocate(_proto_, FALSE).

5.  

The value of the NAME property of this function is "[SYMBOL.CREATE]".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

NOTE The Function @@CREATE function passes FALSE as the _strict_
parameter to FunctionAllocate. This causes the allocated ECMAScript
function object to have the internal methods of a non-strict constructor
function. The FUNCTION constructor may reset the functions [[Strict]]
internal slot to TRUE. It is up to the implementation whether this also
changes the internal methods.

Properties of the Function Prototype Object

The Function prototype object is itself a Built-in Function object. When
invoked, it accepts any arguments and returns UNDEFINED.

NOTE The Function prototype object is specified to be a function object
to ensure compatibility with ECMAScript code that was created prior to
the 6^th^ Edition of this specification.

The value of the [[Prototype]] internal slot of the Function prototype
object is the intrinsic object %ObjectPrototype% (19.1.3). The initial
value of the [[Extensible]] internal slot of the Function prototype
object is TRUE.

The Function prototype object does not have a PROTOTYPE property.

The value of The LENGTH property of the Function prototype object is 0.

The value of the NAME property of the Function prototype object is the
empty String.

Function.prototype.apply ( thisArg, argArray )

When the APPLY method is called on an object _func_ with arguments
_thisArg_ and _argArray_, the following steps are taken:

1.  If IsCallable(_func_) is FALSE, then throw a TYPEERROR exception.

2.  If _argArray_ is NULL or UNDEFINED, then

    a.  Return the result of calling the [[Call]] internal method of
        _func_, providing _thisArg_ as _thisArgument_ and an empty List
        of arguments as _argumentsList_.

3.  Let _argList_ be the result of CreateListFromArrayLike(_argArray_).

4.  ReturnIfAbrupt(_argList_ ).

5.  Perform PrepareForTailCall().

6.  Return the result of calling the [[Call]] internal method of _func_,
    providing _thisArg_ as _thisArgument_ and _argList_ as
    _argumentsList_.

The LENGTH property of the APPLY method is 2.

NOTE The thisArg value is passed without modification as the THIS value.
This is a change from Edition 3, where an UNDEFINED or NULL thisArg is
replaced with the global object and ToObject is applied to all other
values and that result is passed as the THIS value. Even though the
thisArg is passed without modification, non-strict mode functions still
perform these transfromations upon entry to the function.

NOTE If _func_ is an arrow function or a bound found then the _thisArg_
will be ignored by the function [[Call]] in step 6.

Function.prototype.bind ( thisArg , ...args)

When the BIND is called with argument _thisArg_ and zero or more _args_,
it performs the following steps:

1.  Let _Target_ be the THIS value.

2.  If IsCallable(_Target_) is FALSE, throw a TYPEERROR exception.

3.  Let _args_ be a new (possibly empty) List consisting of all of the
    argument values provided after _thisArg_ in order.

4.  Let _F_ be BoundFunctionCreate(_Target_, _thisArg_, _args_).

5.  Let _targetRealm_ be GetFunctionRealm(_Target_).

6.  Perform AddRestrictedFunctionProperties(_F_, _targetRealm_).

7.  Let _targetHasLength_ be HasOwnProperty(_Target_, "LENGTH").

8.  ReturnIfAbrupt(_targetHasLength_).

9.  If _targetHasLength_ is TRUE, then

    a.  Let _targetLen_ be Get(_Target_, "LENGTH").

    b.  ReturnIfAbrupt(_targetLen_).

    c.  If Type(_targetLen_) is not Number, then let _L_ be 0.

    d.  Else,

        i.  Let _L_ be the larger of 0 and the result of _targetLen_
            minus the number of elements of _A_.

10. Else let _L_ be 0.

11. Let _status_ be DefinePropertyOrThrow(_F_, "LENGTH",
    PropertyDescriptor {[[Value]]: _L_, [[Writable]]: FALSE,
    [[Enumerable]]: FALSE, [[Configurable]]: TRUE}.

12. ReturnIfAbrupt(_status_).

13. Let _targetName_ be Get(_Target_, "NAME").

14. ReturnIfAbrupt(_targetName_).

15. If Type(_targetName_) is not String, then let _targetName_ be the
    empty string.

16. 17. Let _status_ be SetFunctionName(_F_, _targetName_, "NAME").

18. ReturnIfAbrupt(_status_).

19. 20. Return _F_.

The LENGTH property of the BIND method is 1.

NOTE 1 Function objects created using FUNCTION.PROTOTYPE.BIND are exotic
objects. They also do not have a PROTOTYPE property.

NOTE 2 If _Target_ is an arrow function or a bound found then the
_thisArg_ passed to this method will not be used by subsequent calls to
_F_.

Function.prototype.call (thisArg , ...args)

When the CALL method is called on an object _func_ with argument,
_thisArg_ and zero or more _args_, the following steps are taken:

1.  If IsCallable(_func_) is FALSE, then throw a TYPEERROR exception.

2.  Let _argList_ be an empty List.

3.  If this method was called with more than one argument then in left
    to right order starting with _the second argument_ append each
    argument as the last element of _argList_

4.  Perform PrepareForTailCall().

5.  Return the result of calling the [[Call]] internal method of _func_,
    providing _thisArg_ as _thisArgument_ and _argList_ as
    _argumentsList_.

The LENGTH property of the CALL method is 1.

NOTE 1 The thisArg value is passed without modification as the THIS
value. This is a change from Edition 3, where an UNDEFINED or NULL
thisArg is replaced with the global object and ToObject is applied to
all other values and that result is passed as the THIS value. Even
though the thisArg is passed without modification, non-strict mode
functions still perform these transfromations upon entry to the
function.

NOTE 2 If _func_ is an arrow function or a bound found then the
_thisArg_ will be ignored by the function [[Call]] in step 5.

Function.prototype.constructor

The initial value of FUNCTION.PROTOTYPE.CONSTRUCTOR is the intrinsic
object %Function%.

.Function.prototype.toMethod (newHome [ , methodName ] )

When the TOMETHOD method is called on an object _func_ with argument
_newHome_ and optional argument _methodName_ the following steps are
taken:

1.  If Type(_newHome_) is not Object, then throw a TYPEERROR exception.

2.  If _func_ is an ECMAScript function object or an exotic Built-in
    function object, then

    a.  b.  c.  If _methodName_ is not UNDEFINED, then

        i.  Let _methodName_ be ToPropertyKey(_methodName_).

        ii. ReturnIfAbrupt(_methodName_).

    d.  Return CloneMethod(_func_, _newHome_, _methodName_).

3.  a.  

4.  If _func_ is a Bound Function exotic object, then return
    BoundFunctionClone(_func_).

5.  If _func_ is any other exotic function object that supports the
    equivalent of the CloneMethod abstract operation, then return an
    appropriately cloned object.

6.  Throw a TYPEERROR exception.

The LENGTH property of the TOMETHOD method is 1.

Function.prototype.toString ( )

An implementation-dependent String source code representation of the
THIS object is returned. This representation has the syntax of a
_FunctionDeclaration_ _FunctionExpression_, _GeneratorDeclaration,
GeneratorExpession, ClassDeclaration_, _ClassExpression_,
_ArrowFunction_, _MethodDefinition_, or _GeneratorMethod_ depending upon
the actual characteristics of the object. In particular that the use and
placement of white space, line terminators, and semicolons within the
representation String is implementation-dependent.

If the object was defined using ECMAScript code and the returned string
representation is in the form of a _FunctionDeclaration_
_FunctionExpression_, _GeneratorDeclaration, GeneratorExpession,
ClassDeclaration_, _ClassExpression_, or _ArrowFunction_ then the
representation must be such that if the string is evaluated, using EVAL
in a lexical context that is equivalent to the lexical context used to
create the original object, it will result in a new functionally
equivalent object. The returned source code must not mention freely any
variables that were not mentioned freely by the original function’s
source code, even if these “extra” names were originally in scope. If
the implementation cannot produce a source code string that meets these
criteria then it must return a string for which EVAL will throw a
SYNTAXERROR exception.

The TOSTRING function is not generic; it throws a TYPEERROR exception if
its THIS value does not have a [[Call]] internal method. Therefore, it
cannot be transferred to other kinds of objects for use as a method.

Function.prototype[ @@create ] ( )

The @@create method of an object _F_ performs the following steps:

1.  Return the result of calling OrdinaryCreateFromConstructor(_F_,
    "%OBJECTPROTOTYPE%").

The value of the NAME property of this function is "[SYMBOL.CREATE]".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

NOTE This is the default @@create method that is inherited by all
ordinary constructor functions that do not explicitly over-ride it.

Function.prototype[@@hasInstance] ( V )

When the @@hasInstance method of an object _F_ is called with value _V_,
the following steps are taken:

1.  Let _F_ be the THIS value.

2.  Return the result of OrdinaryHasInstance(_F_, _V_).

The value of the NAME property of this function is
"[SYMBOL.HASINSTANCE]".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

NOTE This is the default implementation of @@HASINSTANCE that most
functions inherit. @@HASINSTANCE is called by the INSTANCEOF operator to
deterimine whether a value is an instance of a specific constructor. An
expression such as

V INSTANCEOF F

evaluates as

F[@@HASINSTANCE](V)

A constructor function can control which objects are recognized as its
instances by INSTANCEOF by exposing a different @@HASINSTANCE method on
the function.

This property is non-writable and non-configurable to prevent tampering
that could be used to globally expose the target function of a bound
function.

Function Instances

Every function instance is an ECMAScript function object and has the
internal slots listed in Table 26.

Function instances that correspond to strict mode functions and function
instances created using the FUNCTION.PROTOTYPE.BIND METHOD (19.2.3.2)
have properties named CALLER and ARGUMENTS that throw a TYPEERROR
exception. An ECMAScript implementation must not associate any
implementation specific behaviour with accesses of these properties from
strict mode function code.

The Function instances have the following properties:

length

The value of the LENGTH property is an integer that indicates the
typical number of arguments expected by the function. However, the
language permits the function to be invoked with some other number of
arguments. The behaviour of a function when invoked on a number of
arguments other than the number specified by its LENGTH property depends
on the function. This property has the attributes { [[Writable]]: FALSE,
[[Enumerable]]: FALSE, [[Configurable]]: TRUE }.

name

The value of the NAME property is an String that is descriptive of the
function. The name has no semantic significance but is typically a
variable or property name that is used to refer to the function at its
point of definition in ECMAScript code. This property has the attributes
{ [[Writable]]: FALSE, [[Enumerable]]: FALSE, [[Configurable]]: TRUE }.

Anonymous functions objects that do not have a contextual name
associated with them by this specification do not have a NAME own
property but inherit the NAME property of %FunctionPrototype%.

prototype

Function instances that can be used as a constructor have a PROTOTYPE
property. Whenever such a function instance is created another ordinary
object is also created and is the initial value of the function’s
PROTOTYPE property. Unless otherwise specified, the value of the
prototype property is used to initialize the [[Prototype]] internal slot
of a newly created ordinary object before the Function object is invoked
as a constructor for that newly created object.

This property has the attributes { [[Writable]]: TRUE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

NOTE Function objects created using FUNCTION.PROTOTYPE.BIND, or by
evaluating a _MethodDefinition_ (that is not a _GeneratorMethod_) or an
_ArrowFunction_ grammar production do not have a PROTOTYPE property.


Boolean Objects

The Boolean Constructor 

The Boolean constructor is the %Boolean% intrinsic object and the
initial value of the BOOLEAN property of the global object. When BOOLEAN
is called as a function rather than as a constructor, it performs a type
conversion. However, if the THIS value passed in the call is an Object
with an uninitialized [[BooleanData]] internal slot, it initializes the
THIS value using the argument value. This permits BOOLEAN to be used
both to perform type conversion and to perform constructor instance
initialization.

The BOOLEAN constructor is designed to be subclassable. It may be used
as the value of an EXTENDS clause of a class declaration. Subclass
constructors that intended to inherit the specified BOOLEAN behaviour
must include a SUPER call to the BOOLEAN constructor to initialize the
[[BooleanData]] state of subclass instances.

 Boolean ( value )

When BOOLEAN is called with argument _value_, the following steps are
taken:

1.  Let _O_ be the THIS value.

2.  Let _b_ be ToBoolean(_value_).

3.  If Type(_O_) is Object and _O_ has a [[BooleanData]] internal slot
    and the value of [[BooleanData]] is UNDEFINED, then

    a.  Set the value of _O’s_ [[BooleanData]] internal slot to _b_.

    b.  Return _O_.

4.  Return _b_.

new Boolean ( ...argumentsList )

When BOOLEAN is called as part of a new expression , it initializes a
newly created object:

1.  Let _F_ be the BOOLEAN function object on which the NEW operator was
    applied.

2.  Let _argumentsList_ be the _argumentsList_ argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of Construct (_F_, _argumentsList_).

If BOOLEAN is implemented as an ECMAScript function object, its
[[Construct]] internal method will perform the above steps.

Properties of the Boolean Constructor

The value of the [[Prototype]] internal slot of the Boolean constructor
is the Function prototype object (19.2.3).

Besides the LENGTH property (whose value is 1), the Boolean constructor
has the following properties:

Boolean.prototype

The initial value of BOOLEAN.PROTOTYPE is the Boolean prototype object
(19.3.3).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Boolean[ @@create ] ( )

The @@create method of an object _F_ performs the following steps:

1.  Let _F_ be the THIS value.

2.  Let _obj_ be the result of calling
    OrdinaryCreateFromConstructor(_F_, "%BOOLEANPROTOTYPE%", (
    [[BooleanData]]) ).

3.  Return _obj_.

The value of the NAME property of this function is "[SYMBOL.CREATE]".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

NOTE [[BooleanData]] is initially assigned the value UNDEFINED as a flag
to indicate that the instance has not yet been initialized by the
Boolean constructor. This flag value is never directly exposed to
ECMAScript code; hence implementations may choose to encode the flag in
some other manner.

Properties of the Boolean Prototype Object

The Boolean prototype object is an ordinary object. It is not a Boolean
instance and does not have a [[BooleanData]] internal slot.

The value of the [[Prototype]] internal slot of the Boolean prototype
object is the standard built-in Object prototype object (19.1.3).

The abstract operation thisBooleanValue(_value_) performs the following
steps:

1.  If Type(_value_) is Boolean, return _value_.

2.  If Type(_value)_ is Object and _value_ has a [[BooleanData]]
    internal slot, then

    a.  Let _b_ be the value of _value’s_ [[BooleanData]] internal slot.

    b.  If _b_ is not UNDEFINED, then return _b_.

3.  Throw a TYPEERROR exception.

Boolean.prototype.constructor

The initial value of BOOLEAN.PROTOTYPE.CONSTRUCTOR is the built-in
BOOLEAN constructor.

Boolean.prototype.toString ( )

The following steps are taken:

1.  Let _b_ be thisBooleanValue(THIS value).

2.  ReturnIfAbrupt(_b_).

3.  If _b_ is TRUE, then return "TRUE"; else return "FALSE".

Boolean.prototype.valueOf ( )

The following steps are taken:

1.  Return thisBooleanValue(THIS value).

Properties of Boolean Instances

Boolean instances are ordinary objects that inherit properties from the
Boolean prototype object. Boolean instances have a [[BooleanData]]
internal slot. The [[BooleanData]] internal slot is the Boolean value
represented by this Boolean object.


Symbol Objects

The Symbol Constructor class

The Symbol constructor is the %Symbol% intrinsic object and the initial
value of the SYMBOL property of the global object. When SYMBOL is called
as a function rather than as a constructor, it returns a new Symbol
value.

The SYMBOL constructor is not intended to be used with the NEW operator
or to be subclassed. It may be used as the value of an EXTENDS clause of
a class declaration but a SUPER call to the SYMBOL constructor will not
initialize the state of subclass instances.

 Symbol ( [ description ] )

When SYMBOL is called with optional argument _description_, the
following steps are taken:

1.  If _description_ is UNDEFINED, then let _descString_ be UNDEFINED.

2.  Else, let _descString_ be ToString(_description_).

3.  ReturnIfAbrupt(_descString_).

4.  Return a new unique Symbol value whose [[Description]] value is
    _descString_.

new Symbol ( ...argumentsList )

When SYMBOL is called as part of a new expression , it initializes a
newly created object:

1.  Let _F_ be the SYMBOL function object on which the NEW operator was
    applied.

2.  Let _argumentsList_ be the _argumentsList_ argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of Construct (_F_, _argumentsList_).

If SYMBOL is implemented as an ECMAScript function object, its
[[Construct]] internal method will perform the above steps.

NOTE Symbol has ordinary [[Construct]] behaviour but the definition of
its @@create method causes NEW SYMBOL to throw a TYPEERROR exception.

Properties of the Symbol Constructor

The value of the [[Prototype]] internal slot of the Symbol constructor
is the Function prototype object (19.2.3).

Besides the LENGTH property (whose value is 1), the Symbol constructor
has the following properties:

Symbol.create

The initial value of SYMBOL.CREATE is the well known symbol @@create
(Table 1).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Symbol.for ( key )

When SYMBOL.FOR is called with argument _key_ it performs the following
steps:

1.  Let _stringKey_ be ToString(_key_).

2.  ReturnIfAbrupt(_stringKey)_.

3.  For each element _e_ of the GlobalSymbolRegistry List,

    a.  If SameValue(_e_.[[key]], _stringKey_) is TRUE, then return
        _e_.[[symbol]].

4.  Assert: GlobalSymbolRegistry does not currently contain an entry for
    _stringKey_.

5.  Let _newSymbol_ be a new unique Symbol value whose [[Description]]
    is _stringKey_.

6.  Append the record { [[key]]: _stringKey_, [[symbol]]: _newSymbol_ }
    to the GlobalSymbolRegistry List.

7.  Return _newSymbol_.

The GlobalSymbolRegistry is a List that is globally available. It is
shared by all Code Realms. Prior to the evaluation of any ECMAScript
code it is initialized as an empty List. Elements of the
GlobalSymbolRegistry are Records with the structure defined in Table 40.

Table 40 — GlobalSymbolRegistry Record Fields

  -------------- ---------- --------------------------------------------------
  _FIELD NAME_   _VALUE_    _USAGE_
  [[key]]        A String   A string key used to globally identify a Symbol.
  [[symbol]]     A Symbol   A symbol that can be retrieved from any Realm.
  -------------- ---------- --------------------------------------------------

Symbol.hasInstance

The initial value of SYMBOL.HASINSTANCE is the well known symbol
@@hasInstance (Table 1).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Symbol.isConcatSpreadable

The initial value of SYMBOL.ISCONCATSPREADABLE is the well known symbol
@@isConcatSpreadable (Table 1).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Symbol.isRegExp

The initial value of SYMBOL.ISREGEXP is the well known symbol @@isRegExp
(Table 1).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Symbol.iterator

The initial value of SYMBOL.ITERATOR is the well known symbol @@iterator
(Table 1).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Symbol.keyFor ( sym )

When SYMBOL.KEYFOR is called with argument _sym_ it performs the
following steps:

1.  If Type(_sym_) is not Symbol, then throw a TYPEERROR exception.

2.  For each element _e_ of the GlobalSymbolRegistry List (see
    19.4.2.2),

    a.  If SameValue(_e_.[[symbol]], _sym_) is TRUE, then return
        _e_.[[key]].

3.  Assert: GlobalSymbolRegistry does not currently contain an entry for
    _sym_.

4.  Return UNDEFINED.

Symbol.prototype

The initial value of SYMBOL.PROTOTYPE is the Symbol prototype object
(19.4.3).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Symbol.toPrimitive

The initial value of SYMBOL.TOPRIMITIVE is the well known symbol
@@toPrimitive (Table 1).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Symbol.toStringTag

The initial value of SYMBOL.TOSTRINGTAG is the well known symbol
@@toStringTag (Table 1).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Symbol.unscopables

The initial value of SYMBOL.unscopables is the well known symbol
@@unscopables (Table 1).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Symbol[ @@create ] ( )

The @@create method of a Symbol object _F_ performs the following steps:

1.  Throw a TYPEERROR exception.

The value of the NAME property of this function is "[SYMBOL.CREATE]".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Properties of the Symbol Prototype Object

The Symbol prototype object is an ordinary object. It is not a Symbol
instance and does not have a [[SymbolData]] internal slot.

The value of the [[Prototype]] internal slot of the Symbol prototype
object is the standard built-in Object prototype object (19.1.3).

Symbol.prototype.constructor

The initial value of SYMBOL.PROTOTYPE.CONSTRUCTOR is the built-in SYMBOL
constructor.

Symbol.prototype.toString ( )

The following steps are taken:

1.  Let _s_ be the THIS value.

2.  If Type(_s_) is Symbol, then let _sym_ be _s_.

3.  Else,

    a.  If _s_ does not have a [[SymbolData]] internal slot, then throw
        a TYPEERROR exception.

    b.  Let _sym_ be the value of _s’s_ [[SymbolData]] internal slot.

4.  Let _desc_ be the value of _sym’s_ [[Description]] attribute.

5.  If _desc_ is UNDEFINED, then let _desc_ be the empty string.

6.  Assert: Type(_desc_) is String.

7.  Let _result_ be the result of concatenating the strings "SYMBOL(",
    _desc_, and ")".

8.  Return _result_.

Symbol.prototype.valueOf ( )

The following steps are taken:

1.  Let _s_ be the THIS value.

2.  If Type(_s_) is Symbol, then return _s_.

3.  If _s_ does not have a [[SymbolData]] internal slot, then throw a
    TYPEERROR exception.

4.  Return the value of _s’s_ [[SymbolData]] internal slot.

Symbol.prototype [ @@toPrimitive ] ( hint ) 

This function is called by ECMAScript language operators to convert an
object to a primitive value. The allowed values for _hint_ are
"DEFAULT", "NUMBER", and "STRING". Implicit conversion of Symbol objects
to primitive values is not allowed.

When the @@TOPRIMITIVE method is called with argument _hint_, the
following steps are taken:

1.  Let _s_ be the THIS value.

2.  If Type(_s_) is Symbol, then return _s_.

3.  If _s_ does not have a [[SymbolData]] internal slot, then throw a
    TYPEERROR exception.

4.  Return the value of _s’s_ [[SymbolData]] internal slot.

1.  

The value of the NAME property of this function is
"[SYMBOL.TOPRIMITIVE]".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Symbol.prototype [ @@toStringTag ]

The initial value of the @@toStringTag property is the string value
"SYMBOL".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Properties of Symbol Instances

Symbol instances are ordinary objects that inherit properties from the
Symbol prototype object. Symbol instances have a [[SymbolData]] internal
slot. The [[SymbolData]] internal slot is the Symbol value represented
by this Symbol object.


Error Objects

Instances of Error objects are thrown as exceptions when runtime errors
occur. The Error objects may also serve as base objects for user-defined
exception classes.

The Error Constructor 

The Error constructor is the %Error% intrinsic object and the initial
value of the ERROR property of the global object. When ERROR is called
as a function rather than as a constructor, it creates and initializes a
new Error object. Thus the function call ERROR(…) is equivalent to the
object creation expression NEW ERROR(…) with the same arguments.
However, if the THIS value passed in the call is an Object with an
uninitialized [[ErrorData]] internal slot, it initializes the THIS value
using the argument value rather than creating a new object. This permits
ERROR to be used both as factory method and to perform constructor
instance initialization.

The ERROR constructor is designed to be subclassable. It may be used as
the value of an EXTENDS clause of a class declaration. Subclass
constructors that intended to inherit the specified ERROR behaviour
should include a SUPER call to the ERROR constructor to initialize
subclass instances.

Error ( message )

When the ERROR function is called with argument _message_ the following
steps are taken:

1.  Let _func_ be the active function object.

2.  Let _O_ be the THIS value.

3.  If Type(_O_) is not Object or Type(_O_) is Object and _O_ does not
    have an [[ErrorData]] internal slot or Type(_O_) is Object and _O_
    has an [[ErrorData]] internal slot and the value of [[ErrorData]] is
    not UNDEFINED, then

    a.  Let _O_ be the result of calling
        OrdinaryCreateFromConstructor(_func_, "%ERRORPROTOTYPE%",
        ( [[ErrorData]]) ).

    b.  ReturnIfAbrupt(_O_).

4.  Assert: Type(_O_) is Object.

5.  Set the value of _O’s_ [[ErrorData]] internal slot to any value
    other than UNDEFINED.

6.  If _message_ is not UNDEFINED, then

    a.  Let _msg_ be ToString(_message_).

    b.  ReturnIfAbrupt(_msg_).

    c.  Let _msgDesc_ be the PropertyDescriptor{[[Value]]: _msg_,
        [[Writable]]: TRUE, [[Enumerable]]: FALSE, [[Configurable]]:
        TRUE}.

    d.  Let _status_ be the result of DefinePropertyOrThrow(_O_,
        "MESSAGE", _msgDesc_).

    e.  ReturnIfAbrupt(_status_).

7.  Return _O_.

new Error ( ...argumentsList )

When ERROR called as part of a new expression with argument list
_argumentsList_ it performs the following steps:

1.  Let _F_ be the ERROR function object on which the NEW operator was
    applied.

2.  Let _argumentsList_ be the _argumentsList_ argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of Construct (_F_, _argumentsList_).

If ERROR is implemented as an ECMAScript function object, its
[[Construct]] internal method will perform the above steps.

Properties of the Error Constructor

The value of the [[Prototype]] internal slot of the Error constructor is
the Function prototype object (19.2.3).

Besides the LENGTH property (whose value is 1), the Error constructor
has the following properties:

Error.prototype

The initial value of ERROR.PROTOTYPE is the Error prototype object
(19.5.3).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Error[ @@create ] ( )

The @@create method of an object _F_ performs the following steps:

1.  Let _F_ be the THIS value.

2.  Let _obj_ be the result of calling
    OrdinaryCreateFromConstructor(_F_, "%ERRORPROTOTYPE%", (
    [[ErrorData]]) ).

3.  Return _obj_.

The value of the NAME property of this function is "[SYMBOL.CREATE]".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

NOTE [[ErrorData]] is initially assigned the value UNDEFINED as a flag
to indicate that the instance has not yet been initialized by the Error
constructor. This flag value is never directly exposed to ECMAScript
code; hence implementations may choose to encode the flag in some other
manner.

Properties of the Error Prototype Object

The Error prototype object is an ordinary object. It is not an Error
instance and does not have an [[ErrorData]] internal slot.

The value of the [[Prototype]] internal slot of the Error prototype
object is the standard built-in Object prototype object (19.1.3).

Error.prototype.constructor

The initial value of ERROR.PROTOTYPE.CONSTRUCTOR is the built-in ERROR
constructor.

Error.prototype.message

The initial value of ERROR.PROTOTYPE.MESSAGE is the empty String.

Error.prototype.name

The initial value of ERROR.PROTOTYPE.NAME is "ERROR".

Error.prototype.toString ( )

The following steps are taken:

1.  Let _O_ be the THIS value.

2.  If Type(_O_) is not Object, throw a TYPEERROR exception.

3.  Let _name_ be the result of Get(_O_, "NAME").

4.  ReturnIfAbrupt(_name_).

5.  If _name_ is UNDEFINED, then let _name_ be "ERROR"; else let _name
    be ToString(_name_).

6.  Let _msg_ be the result of Get(_O_, "MESSAGE").

7.  ReturnIfAbrupt(_msg_).

8.  If _msg_ is UNDEFINED, then let _msg_ be the empty String; else let
    _msg_ be ToString(_msg_).

9.  If _name_ is the empty String, return _msg_.

10. If _msg_ is the empty String, return _name_.

11. Return the result of concatenating _name_, the code unit U+003A
    (COLON), the code unit U+0020 (SPACE), and _msg_.

Properties of Error Instances

Error instances are ordinary objects that inherit properties from the
Error prototype object and have an [[ErrorData]] internal slot whose
initial value is UNDEFINED. The only specified uses of [[ErrorData]] is
to flag whether or not an Error instance has been initialized by the
Error constructor and to identify them as Error objects within
OBJECT.PROTOTYPE.TOSTRING.

Native Error Types Used in This Standard

A new instance of one of the _NativeError_ objects below is thrown when
a runtime error is detected. All of these objects share the same
structure, as described in 19.5.6.

EvalError

This exception is not currently used within this specification. This
object remains for compatibility with previous editions of this
specification.

RangeError

Indicates a value that is not in the set or range of allowable values.
See 15.4.2.2, 15.4.5.1, 15.7.4.2, 15.7.4.5, 15.7.4.6, 15.7.4.7, and
15.9.5.43.

ReferenceError

Indicate that an invalid reference value has been detected. See 8.9.1,
8.9.2, 10.2.1, 10.2.1.1.4, 10.2.1.2.4, and 11.13.1.

SyntaxError

Indicates that a parsing error has occurred. See 11.1.5, 11.3.1, 11.3.2,
11.4.1, 11.4.4, 11.4.5, 11.13.1, 11.13.2, 12.2.1, 12.10.1, 12.14.1,
13.1, 15.1.2.1, 15.3.2.1, 15.10.2.2, 15.10.2.5, 15.10.2.9, 15.10.2.15,
15.10.2.19, 15.10.4.1, and 15.12.2.

TypeError

Indicates the actual type of an operand is different than the expected
type. See 8.6.2, 8.9.2, 8.10.5, 8.12.5, 8.12.7, 8.12.8, 8.12.9, 9.9,
9.10, 10.2.1, 10.2.1.1.3, 10.6, 11.2.2, 11.2.3, 11.4.1, 11.8.6, 11.8.7,
11.3.1, 13.2, 13.2.3, 15, 15.2.3.2, 15.2.3.3, 15.2.3.4, 15.2.3.5,
15.2.3.6, 15.2.3.7, 15.2.3.8, 15.2.3.9, 15.2.3.10, 15.2.3.11, 15.2.3.12,
15.2.3.13, 15.2.3.14, 15.2.4.3, 15.3.3.2, 15.3.3.3, 15.3.3.4, 15.3.3.5,
15.3.3.5.2, 15.3.3.5.3, 15.3.4, 15.3.4.3, 15.3.4.4, 15.4.3.3, 15.4.3.11,
15.4.3.16, 15.4.3.17, 15.4.3.18, 15.4.3.19, 15.4.3.20, 15.4.3.21,
15.4.3.22, 15.4.5.1, 15.5.4.2, 15.5.4.3, 15.6.4.2, 15.6.4.3, 15.7.4,
15.7.4.2, 15.7.4.4, 15.9.5, 15.9.5.44, 15.10.4.1, 15.10.6, 15.11.4.4 and
15.12.3.

URIError

Indicates that one of the global URI handling functions was used in a
way that is incompatible with its definition. See 15.1.3.

_NativeError_ Object Structure

When an ECMAScript implementation detects a runtime error, it throws a
new instance of one of the _NativeError_ objects defined in 19.5.5. Each
of these objects has the structure described below, differing only in
the name used as the constructor name instead of _NativeError_, in the
NAME property of the prototype object, and in the implementation-defined
MESSAGE property of the prototype object.

For each error object, references to _NativeError_ in the definition
should be replaced with the appropriate error object name from 19.5.5.

_NativeError_ Constructors 

When a _NativeError_ constructor is called as a function rather than as
a constructor, it creates and initializes a new object. A call of the
object as a function is equivalent to calling it as a constructor with
the same arguments. However, if the THIS value passed in the call is an
Object with an uninitialized [[ErrorData]] internal slot, it initializes
the THIS value using the argument value. This permits a _NativeError_ to
be used both as factory method and to perform constructor instance
initialization.

The _NativeError_ constructor is designed to be subclassable. It may be
used as the value of an EXTENDS clause of a class declaration. Subclass
constructors that intended to inherit the specified _NativeError_
behaviour should include a SUPER call to the _NativeError_ constructor
to initialize subclass instances.

NativeError ( message )

When a _NativeError_ function is called with argument _message_ the
following steps are taken:

1.  Let _func_ be the active function object.

2.  Let _O_ be the THIS value.

3.  If Type(_O_) is not Object or Type(_O_) is Object and _O_ does not
    have an [[ErrorData]] internal slot or Type(_O_) is Object and _O_
    has an [[ErrorData]] internal slot and the value of [[ErrorData]] is
    not UNDEFINED, then

    a.  Let _O_ be the result of calling
        OrdinaryCreateFromConstructor(_func_,
        "%_NATIVEERROR_PROTOTYPE%", ( [[ErrorData]]) ).

    b.  ReturnIfAbrupt(_O_).

4.  Assert: Type(_O_) is Object.

5.  Set the value of _O’s_ [[ErrorData]] internal slot to any value
    other than UNDEFINED.

6.  If _message_ is not UNDEFINED, then

    a.  Let _msg_ be ToString(_message_).

    b.  Let _msgDesc_ be the PropertyDescriptor{[[Value]]: _msg_,
        [[Writable]]: TRUE, [[Enumerable]]: FALSE, [[Configurable]]:
        TRUE}.

    c.  Let _status_ be the result of DefinePropertyOrThrow(_O_,
        "MESSAGE", _msgDesc_).

    d.  ReturnIfAbrupt(_status_).

7.  Return _O_.

The actual value of the string passed in step 3.a is either
"%EVALERRORPROTOTYPE%", "%RANGEERRORPROTOTYPE%",
"%REFERENCEERRORPROTOTYPE%", "%SYNTAXERRORPROTOTYPE%",
"%TYPEERRORPROTOTYPE%", or "%URIERRORPROTOTYPE%" corresponding to which
_NativeError_ constructor is being defined.

new _NativeError_ ( ...argumentsList )

When a _NativeError_ constructor is called as part of a new expression
with argument list _argumentsList_ it performs the following steps:

1.  Let _F_ be this _NativeError_ function object on which the NEW
    operator was applied.

2.  Let _argumentsList_ be the _argumentsList_ argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of Construct (_F_, _argumentsList_).

If a _NativeError_ constructor is implemented as an ECMAScript function
object, its [[Construct]] internal method will perform the above steps.

Properties of the _NativeError_ Constructors

The value of the [[Prototype]] internal slot of a _NativeError_
constructor is the Error constructor object (19.5.1).

Besides the LENGTH property (whose value is 1), each _NativeError_
constructor has the following properties:

NativeError.prototype

The initial value of _NATIVEERROR_.PROTOTYPE is a _NativeError_
prototype object (19.5.6.3). Each _NativeError_ constructor has a
separate prototype object.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

_NativeError_ [ @@create ] ( )

The @@create method of an object _F_ performs the following steps:

1.  Let _F_ be the THIS value.

2.  Let _obj_ be OrdinaryCreateFromConstructor(_F_,
    _NativeErrorPrototype_, ([[ErrorData]]) ).

3.  Return _obj_.

The actual value passed as _NativeErrorPrototype_ in step 2 is either
"%EVALERRORPROTOTYPE%", "%RANGEERRORPROTOTYPE%",
"%REFERENCEERRORPROTOTYPE%", "%SYNTAXERRORPROTOTYPE%",
"%TYPEERRORPROTOTYPE%", or "%URIERRORPROTOTYPE%" corresponding to which
_NativeError_ constructor is being defined.

The value of the NAME property of this function is "[SYMBOL.CREATE]".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

NOTE [[ErrorData]] is initially assigned the value UNDEFINED as a flag
to indicate that the instance has not yet been initialized by the
_NativeError_ constructor. This flag value is never directly exposed to
ECMAScript code; hence implementations may choose to encode the flag in
some other manner.

Properties of the _NativeError_ Prototype Objects

Each _NativeError_ prototype object is an ordinary object. It is not an
Error instance and does not have an [[ErrorData]] internal slot.

The value of the [[Prototype]] internal slot of each _NativeError_
prototype object is the standard built-in Error prototype object
(19.5.3).

_NativeError_.prototype.constructor

The initial value of the CONSTRUCTOR property of the prototype for a
given _NativeError_ constructor is the _NativeError_ constructor
function itself (19.5.6.1).

 _NativeError_.prototype.message

The initial value of the MESSAGE property of the prototype for a given
_NativeError_ constructor is the empty String.

 _NativeError_.prototype.name

The initial value of the NAME property of the prototype for a given
_NativeError_ constructor is a string consisting of the name of the
constructor (the name used instead of _NativeError_).

Properties of _NativeError_ Instances

_NativeError_ instances are ordinary objects that inherit properties
from their _NativeError_ prototype object and have an [[ErrorData]]
internal slot whose initial value is UNDEFINED. The only specified use
of [[ErrorData]] is to flag whether or not an Error or _NativeError_
instance has been initialized by its constructor.



NUMBERS AND DATES 


Number Objects

The Number Constructor 

The Number constructor is the %Number% intrinsic object and the initial
value of the NUMBER property of the global object. When NUMBER is called
as a function rather than as a constructor, it performs a type
conversion. However, if the THIS value passed in the call is an Object
with an uninitialized [[NumberData]] internal slot, it initializes the
THIS value using the argument value. This permits NUMBER to be used both
to perform type conversion and to perform constructor instance
initialization.

The NUMBER constructor is designed to be subclassable. It may be used as
the value of an EXTENDS clause of a class declaration. Subclass
constructors that intended to inherit the specified NUMBER behaviour
must include a SUPER call to the NUMBER constructor to initialize the
[[NumberData]] state of subclass instances.

Number ( [ value ] )

When NUMBER is called with argument _number_, the following steps are
taken:

1.  Let _O_ be the THIS value.

2.  If no arguments were passed to this function invocation, then let
    _n_ be +0.

3.  Else, let _n_ be ToNumber(_value_).

4.  ReturnIfAbrupt(_n_).

5.  If Type(_O_) is Object and _O_ has a [[NumberData]] internal slot
    and the value of [[NumberData]] is UNDEFINED, then

    a.  Set the value of _O’s_ [[NumberData]] internal slot to _n_.

    b.  Return _O_.

6.  Return _n_.

new Number ( ...argumentsList )

When NUMBER is called as part of a new expression with argument list
_argumentsList_it performs the following steps:

1.  Let _F_ be the NUMBER function object on which the NEW operator was
    applied.

2.  Let _argumentsList_ be the _argumentsList_ argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return Construct (_F_, _argumentsList_).

If NUMBER is implemented as an ECMAScript function object, its
[[Construct]] internal method will perform the above steps.

Properties of the Number Constructor

The value of the [[Prototype]] internal slot of the Number constructor
is the Function prototype object (19.2.3).

Besides the LENGTH property (whose value is 1), the Number constructor
has the following properties:

Number.EPSILON

The value of Number.EPSILON is the difference between 1 and the smallest
value greater than 1 that is representable as a Number value, which is
approximately 2.2204460492503130808472633361816 x 10‍^−‍16^.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Number.isFinite ( number )

When the NUMBER.ISFINITE is called with one argument _number_, the
following steps are taken:

1.  If Type(_number_) is not Number, return FALSE.

2.  If _number_ is NAN, +∞, or −∞, return FALSE.

3.  Otherwise, return TRUE.

Number.isInteger ( number )

When the NUMBER.ISINTEGER is called with one argument _number_, the
following steps are taken:

1.  If Type(_number_) is not Number, return FALSE.

2.  If _number_ is NAN, +∞, or −∞, return FALSE.

3.  Let _integer_ be ToInteger(_number_).

4.  If _integer_ is not equal to _number_, return FALSE.

5.  Otherwise, return TRUE.

Number.isNaN ( number )

When the NUMBER.ISNAN is called with one argument _number_, the
following steps are taken:

1.  If Type(_number_) is not Number, return FALSE.

2.  If _number_ is NAN, return TRUE.

3.  Otherwise, return FALSE.

NOTE This function differs from the global isNaN function (18.2.3) is
that it does not convert its argument to a Number before determining
whether it is NaN.

Number.isSafeInteger ( number )

When the NUMBER.ISSAFEINTEGER is called with one argument _number_, the
following steps are taken:

1.  If Type(_number_) is not Number, return FALSE.

2.  If _number_ is NAN, +∞, or −∞, return FALSE.

3.  Let _integer_ be ToInteger(_number_).

4.  If _integer_ is not equal to _number_, return FALSE.

5.  If abs(_integer_) ≤ 2^53^−1, then return TRUE.

6.  Otherwise, return FALSE.

Number.MAX_SAFE_INTEGER

The value of Number.MAX_SAFE_INTEGER is 9007199254740991 (2^53^−1).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

 Number.MAX_VALUE

The value of NUMBER.MAX_VALUE is the largest positive finite value of
the Number type, which is approximately 1.7976931348623157 × 10^308^.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Number.NaN

The value of NUMBER.NAN is NAN.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Number.NEGATIVE_INFINITY

The value of Number.NEGATIVE_INFINITY is −∞.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Number.MIN_SAFE_INTEGER

The value of Number.MIN_SAFE_INTEGER is −9007199254740991 (−(2^53^−1)).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Number.MIN_VALUE

The value of NUMBER.MIN_VALUE is the smallest positive value of the
Number type, which is approximately 5 × 10^−324^.

In the IEEE-764 double precision binary representation, the smallest
possible value is a denormalized number. If an implementation does not
support denormalized values, the value of NUMBER.MIN_VALUE must be the
smallest non-zero positive value that can actually be represented by the
implementation.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Number.parseFloat ( string )

The value of the NUMBER.PARSEFLOAT data property is the same built-in
function object that is the value of the PARSEFLOAT property of the
global object defined in 18.2.4.

Number.parseInt ( string, radix )

The value of the NUMBER.PARSEINT data property is the same built-in
function object that is the value of the PARSEINT property of the global
object defined in 18.2.5.

Number.POSITIVE_INFINITY

The value of Number.POSITIVE_INFINITY is +∞.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Number.prototype

The initial value of NUMBER.PROTOTYPE is the Number prototype object
(20.1.3).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Number[ @@create ] ( )

The @@create method of an object _F_ performs the following steps:

1.  Let _F_ be the THIS value.

2.  Let _obj_ be OrdinaryCreateFromConstructor(_F_, "%NUMBERPROTOTYPE%",
    ( [[NumberData]])).

3.  Return _obj_.

The value of the NAME property of this function is "[SYMBOL.CREATE]".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

NOTE [[NumberData]] is initially assigned the value UNDEFINED as a flag
to indicate that the instance has not yet been initialized by the Number
constructor. This flag value is never directly exposed to ECMAScript
code; hence implementations may choose to encode the flag in some other
manner.

Properties of the Number Prototype Object

The Number prototype object is an ordinary object. It is not a Number
instance and does not have a [[NumberData]] internal slot.

The value of the [[Prototype]] internal slot of the Number prototype
object is the standard built-in Object prototype object (19.1.3).

Unless explicitly stated otherwise, the methods of the Number prototype
object defined below are not generic and the THIS value passed to them
must be either a Number value or an object that has a [[NumberData]]
internal slot that has been initialized to a Number value.

The abstract operation thisNumberValue(_value_) performs the following
steps:

1.  If Type(_value_) is Number, return _value_.

2.  If Type(_value)_ is Object and _value_ has a [[NumberData]] internal
    slot, then

    a.  Let _n_ be the value of _value’s_ [[NumberData]] internal slot.

    b.  If _n_ is not UNDEFINED, then return _n_.

3.  Throw a TYPEERROR exception.

The phrase “this Number value” within the specification of a method
refers to the result returned by calling the abstract operation
thisNumberValue with the THIS value of the method invocation passed as
the argument.

Number.prototype.constructor

The initial value of NUMBER.PROTOTYPE.CONSTRUCTOR is the built-in NUMBER
constructor.

Number.prototype.toExponential ( fractionDigits )

Return a String containing this Number value represented in decimal
exponential notation with one digit before the significand's decimal
point and _fractionDigits_ digits after the significand's decimal point.
If _fractionDigits_ is UNDEFINED, include as many significand digits as
necessary to uniquely specify the Number (just like in ToString except
that in this case the Number is always output in exponential notation).
Specifically, perform the following steps:

1.  Let _x_ be thisNumberValue(THIS value).

2.  ReturnIfAbrupt(_x_).

3.  Let _f_ be ToInteger(_fractionDigits_).

4.  Assert: _f_ is 0, when _fractionDigits_ is UNDEFINED.

5.  ReturnIfAbrupt(_f_).

6.  If _x_ is NAN, return the String "NAN".

7.  Let _s_ be the empty String.

8.  If _x_ _<_ 0, then

    a.  Let _s_ be "-".

    b.  Let _x_ = –_x_.

9.  If _x_ = +∞, then

    a.  Return the concatenation of the Strings _s_ and "INFINITY".

10. If _f_ < 0 or _f_ > 20, throw a RANGEERROR exception.

11. If _x_ = 0, then

    a.  Let _m_ be the String consisting of _f_+1 occurrences of the
        code unit 0x0030.

    b.  Let _e_ = 0.

12. Else _x_ ≠ 0,

    a.  If _fractionDigits_ is not UNDEFINED, then

        i.  Let _e_ and _n_ be integers such that 10_^f^_ ≤ _n_ <
            10^_f_+1^ and for which the exact mathematical value of _n_
            × 10^_e_–_f_^ – _x_ is as close to zero as possible. If
            there are two such sets of _e_ and _n_, pick the _e_ and _n_
            for which _n_ × 10^_e_–_f_^ is larger.

    b.  Else _fractionDigits_ is UNDEFINED,

        i.  Let _e_, _n_, and _f_ be integers such that _f_ ≥ 0, 10_^f^_
            ≤ _n_ < 10^_f_+1^, the number value for n × 10^_e_–_f_^ is
            _x_, and _f_ is as small as possible. Note that the decimal
            representation of _n_ has _f_+1 digits, _n_ is not divisible
            by 10, and the least significant digit of _n_ is not
            necessarily uniquely determined by these criteria.

    c.  Let _m_ be the String consisting of the digits of the decimal
        representation of _n_ (in order, with no leading zeroes).

13. If _f_ ≠ 0, then

    a.  Let _a_ be the first element of _m_, and let _b_ be the
        remaining _f_ elements of _m_.

    b.  Let _m_ be the concatenation of the three Strings _a_, ".", and
        _b_.

14. If _e_ = 0, then

    a.  Let _c_ = "+".

    b.  Let _d_ = "0".

15. Else

    a.  If _e_ > 0, then let _c_ = "+".

    b.  Else _e_ ≤ 0,

        i.  Let _c_ = "-".

        ii. Let _e_ = –_e_.

    c.  Let _d_ be the String consisting of the digits of the decimal
        representation of _e_ (in order, with no leading zeroes).

16. Let _m_ be the concatenation of the four Strings _m_, "E", _c_, and
    _d_.

17. Return the concatenation of the Strings _s_ and _m_.

The LENGTH property of the TOEXPONENTIAL method is 1.

If the TOEXPONENTIAL method is called with more than one argument, then
the behaviour is undefined (see clause 17).

An implementation is permitted to extend the behaviour of TOEXPONENTIAL
for values of _fractionDigits_ less than 0 or greater than 20. In this
case TOEXPONENTIAL would not necessarily throw RANGEERROR for such
values.

NOTE For implementations that provide more accurate conversions than
required by the rules above, it is recommended that the following
alternative version of step 12.b.i be used as a guideline:

i.  Let _e_, _n_, and _f_ be integers such that _f_ ≥ 0, 10_^f^_ ≤ n <
    10^_f_+1^, the number value for n × 10^_e_–_f_^ is x, and _f_ is as
    small as possible. If there are multiple possibilities for _n_,
    choose the value of _n_ for which _n_ × 10^_e_–_f_^ is closest in
    value to _x_. If there are two such possible values of _n_, choose
    the one that is even.

Number.prototype.toFixed ( fractionDigits )

Note TOFIXED returns a String containing this Number value represented
in decimal fixed-point notation with _fractionDigits_ digits after the
decimal point. If _fractionDigits_ is UNDEFINED, 0 is assumed.

The following steps are performed:

1.  Let _x_ be thisNumberValue(THIS value).

2.  ReturnIfAbrupt(_x_).

3.  Let _f_ be ToInteger(_fractionDigits_). (If _fractionDigits_ is
    UNDEFINED, this step produces the value 0).

4.  ReturnIfAbrupt(_f_).

5.  If _f_ < 0 or _f_ > 20, throw a RANGEERROR exception.

6.  If _x_ is NAN, return the String "NAN".

7.  Let _s_ be the empty String.

8.  If _x_ < 0, then

    a.  Let _s_ be "-".

    b.  Let _x_ = –_x_.

9.  If _x_ ≥ 10^21^, then

    a.  Let _m_ = ToString(_x_).

10. Else _x_ < 10^21^,

    a.  Let _n_ be an integer for which the exact mathematical value of
        _n_ ÷ 10^f^ – _x_ is as close to zero as possible. If there are
        two such _n_, pick the larger _n_.

    b.  If _n_ = 0, let _m_ be the String "0". Otherwise, let _m_ be the
        String consisting of the digits of the decimal representation of
        _n_ (in order, with no leading zeroes).

    c.  If _f_ ≠ 0, then

        i.  Let _k_ be the number of elements in _m_.

        ii. If _k_ ≤ _f_, then

            1.  Let _z_ be the String consisting of _f_+1–_k_
                occurrences of the code unit 0x0030.

            2.  Let _m_ be the concatenation of Strings _z_ and _m_.

            3.  Let _k_ = _f_ + 1.

        iii. Let _a_ be the first _k_–_f_ elements of _m_, and let _b_
            be the remaining _f_ elements of _m_.

        iv. Let _m_ be the concatenation of the three Strings _a_, ".",
            and _b_.

11. Return the concatenation of the Strings _s_ and _m_.

The LENGTH property of the TOFIXED method is 1.

If the TOFIXED method is called with more than one argument, then the
behaviour is undefined (see clause 17).

An implementation is permitted to extend the behaviour of TOFIXED for
values of _fractionDigits_ less than 0 or greater than 20. In this case
TOFIXED would not necessarily throw RANGEERROR for such values.

NOTE The output of TOFIXED may be more precise than TOSTRING for some
values because toString only prints enough significant digits to
distinguish the number from adjacent number values. For example,

(1000000000000000128).TOSTRING() returns "1000000000000000100",
while (1000000000000000128).TOFIXED(0) returns "1000000000000000128".

Number.prototype.toLocaleString( [ reserved1 [ , reserved2 ] ])

An ECMAScript implementation that includes the ECMA-402
Internationalization API must implement the
NUMBER.PROTOTYPE.TOLOCALESTRING method as specified in the ECMA-402
specification. If an ECMAScript implementation does not include the
ECMA-402 API the following specification of the TOLOCALESTRING method is
used.

Produces a String value that represents this Number value formatted
according to the conventions of the host environment’s current locale.
This function is implementation-dependent, and it is permissible, but
not encouraged, for it to return the same thing as TOSTRING.

The meanings of the optional parameters to this method are defined in
the ECMA-402 specification; implementations that do not include ECMA-402
support must not use those parameter positions for anything else.

The LENGTH property of the TOLOCALESTRING method is 0.

Number.prototype.toPrecision ( precision )

Return a String containing this Number value represented either in
decimal exponential notation with one digit before the significand's
decimal point and _precision_–1 digits after the significand's decimal
point or in decimal fixed notation with _precision_ significant digits.
If _precision_ is UNDEFINED, call ToString (7.1.12) instead.
Specifically, perform the following steps:

1.  Let _x_ be thisNumberValue(THIS value).

2.  ReturnIfAbrupt(_x_).

3.  If _precision_ is UNDEFINED, return ToString(_x_).

4.  Let _p_ be ToInteger(_precision_).

5.  ReturnIfAbrupt(_p_).

6.  If _x_ is NAN, return the String "NAN".

7.  Let _s_ be the empty String.

8.  If _x_ < 0, then

    a.  Let _s_ be code unit U+002B (PLUS SIGN).

    b.  Let _x_ = –_x_.

9.  If _x_ = +∞, then

    a.  Return the String that is the concatenation of _s_ and
        "INFINITY".

10. If _p_ < 1 or _p_ > 21, throw a RANGEERROR exception.

11. If _x_ = 0, then

    a.  Let _m_ be the String consisting of _p_ occurrences of the code
        unit U+0030 (DIGIT ZERO).

    b.  Let _e_ = 0.

12. Else _x_ ≠ 0,

    a.  Let _e_ and _n_ be integers such that 10^_p_–1^ ≤ _n_ < 10_^p^_
        and for which the exact mathematical value of _n_ ×
        10^_e_–_p_+1^ – _x_ is as close to zero as possible. If there
        are two such sets of _e_ and _n_, pick the _e_ and _n_ for which
        _n_ × 10^_e_–_p_+1^ is larger.

    b.  Let _m_ be the String consisting of the digits of the decimal
        representation of _n_ (in order, with no leading zeroes).

    c.  If _e_ < –6 or _e_ ≥ _p_, then

        i.  Assert: _e_ ≠ 0

        ii. Let _a_ be the first element of _m_, and let _b_ be the
            remaining _p_–1 elements of _m_.

        iii. Let _m_ be the concatenation of _a_, code unit U+002E (FULL
            STOP), and _b_.

        iv. If _e_ > 0, then

            1.  Let _c_ be code unit U+002B (PLUS SIGN).

        v.  Else _e_ < 0,

            1.  Let _c_ be code unit U+002D (HYPHEN-MINUS).

            2.  Let _e_ = –_e_.

        vi. Let _d_ be the String consisting of the digits of the
            decimal representation of _e_ (in order, with no leading
            zeroes).

        vii. Return the concatenation of _s_, _m_, code unit U+0065
            (LATIN SMALL LETTER E), _c_, and _d_.

13. If _e_ = _p_–1, then return the concatenation of the Strings _s_ and
    _m_.

14. If _e_ ≥ 0, then

    a.  Let _m_ be the concatenation of the first _e_+1 elements of _m_,
        the code unit U+002E (FULL STOP), and the remaining _p_– (_e_+1)
        elements of _m_.

15. Else _e_ < 0,

    a.  Let _m_ be the String fromed by the concatenation of code unit
        U+0030 (DIGIT ZERO), code unit U+002E (FULL STOP), –(_e_+1)
        occurrences of code unit U+0030 (DIGIT ZERO), and the String
        _m_.

16. Return the String that is the concatenation of _s_ and _m_.

The LENGTH property of the TOPRECISION method is 1.

If the TOPRECISION method is called with more than one argument, then
the behaviour is undefined (see clause 17).

An implementation is permitted to extend the behaviour of TOPRECISION
for values of _precision_ less than 1 or greater than 21. In this case
TOPRECISION would not necessarily throw RANGEERROR for such values.

 Number.prototype.toString ( [ radix ] )

NOTE The optional _radix_ should be an integer value in the inclusive
range 2 to 36. If _radix_ not present or is UNDEFINED the Number 10 is
used as the value of _radix_.

The following steps are performed:

1.  Let _x_ be thisNumberValue(THIS value).

2.  ReturnIfAbrupt(_x_).

3.  If _radix_ is not present, then let _radixNumber_ be 10.

4.  Else if _radix_ is UNDEFINED, then let _radixNumber_ be 10.

5.  Else let _radixNumber_ be ToInteger(_radix_).

6.  ReturnIfAbrupt(_radixNumber_).

7.  If _radixNumber_ < 2 or _radixNumber_ > 36, then throw a RANGEERROR
    exception.

8.  If _radixNumber_ = 10, then return ToString(_x_).

9.  Return the String representation of this Number value using the
    radix specified by _radixNumber_. Letters A-Z are used for digits
    with values 10 through 35. The precise algorithm is
    implementation-dependent, however the algorithm should be a
    generalization of that specified in 7.1.12.1.

The TOSTRING function is not generic; it throws a TYPEERROR exception if
its THIS value is not a Number or a Number object. Therefore, it cannot
be transferred to other kinds of objects for use as a method.

Number.prototype.valueOf ( )

1.  Let _x_ be thisNumberValue(THIS value).

2.  Return _x_.

Properties of Number Instances

Number instances are ordinary objects that inherit properties from the
Number prototype object. Number instances also have a [[NumberData]]
internal slot. The [[NumberData]] internal slot is the Number value
represented by this Number object.


The Math Object

The Math object is a single ordinary object.

The value of the [[Prototype]] internal slot of the Math object is the
standard built-in Object prototype object (19.1.3).

The Math is not a function object. It does not have a [[Construct]]
internal method; it is not possible to use the Math object as a
constructor with the NEW operator. The Math object also does not have a
[[Call]] internal method; it is not possible to invoke the Math object
as a function.

NOTE In this specification, the phrase “the Number value for _x_” has a
technical meaning defined in 6.1.6.

Value Properties of the Math Object

Math.E

The Number value for _e_, the base of the natural logarithms, which is
approximately 2.7182818284590452354.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

 Math.LN10

The Number value for the natural logarithm of 10, which is approximately
2.302585092994046.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Math.LOG10E

The Number value for the base-10 logarithm of _e_, the base of the
natural logarithms; this value is approximately 0.4342944819032518.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

NOTE The value of MATH.LOG10E is approximately the reciprocal of the
value of MATH.LN10.

Math.LN2

The Number value for the natural logarithm of 2, which is approximately
0.6931471805599453.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Math.LOG2E

The Number value for the base-2 logarithm of _e_, the base of the
natural logarithms; this value is approximately 1.4426950408889634.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

NOTE The value of MATH.LOG2E is approximately the reciprocal of the
value of MATH.LN2.

Math.PI

The Number value for π, the ratio of the circumference of a circle to
its diameter, which is approximately 3.1415926535897932.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Math.SQRT1_2

The Number value for the square root of ½, which is approximately
0.7071067811865476.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

NOTE The value of MATH.SQRT1_2 is approximately the reciprocal of the
value of MATH.SQRT2.

Math.SQRT2

The Number value for the square root of 2, which is approximately
1.4142135623730951.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Math [ @@toStringTag ]

The initial value of the @@toStringTag property is the string value
"MATH".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Function Properties of the Math Object

Each of the following MATH object functions applies the ToNumber
abstract operation to each of its arguments (in left-to-right order if
there is more than one). If ToNumber returns an abrupt completion, that
Completion Record is immediately returned. Otherwise, the function
performs a computation on the resulting Number value(s). The value
returned by each function is a Number.

In the function descriptions below, the symbols NaN, −0, +0, −∞ and +∞
refer to the Number values described in 6.1.6.

NOTE The behaviour of the functions ACOS, ACOSH, ASIN, ASINH, ATAN,
ATANH, ATAN2, CBRT, COS, COSH, EXP, HYPOT, LOG,LOG1P, LOG2, LOG10, POW,
SIN, SINH, SQRT, TAN, and TANH is not precisely specified here except to
require specific results for certain argument values that represent
boundary cases of interest. For other argument values, these functions
are intended to compute approximations to the results of familiar
mathematical functions, but some latitude is allowed in the choice of
approximation algorithms. The general intent is that an implementer
should be able to use the same mathematical library for ECMAScript on a
given hardware platform that is available to C programmers on that
platform.

Although the choice of algorithms is left to the implementation, it is
recommended (but not specified by this standard) that implementations
use the approximation algorithms for IEEE 754 arithmetic contained in
FDLIBM, the freely distributable mathematical library from Sun
Microsystems (http://www.netlib.org/fdlibm).

Math.abs ( x )

Returns the absolute value of _x_; the result has the same magnitude as
_x_ but has positive sign.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is −0, the result is +0.

-   If _x_ is −∞, the result is +∞.

Math.acos ( x )

Returns an implementation-dependent approximation to the arc cosine of
_x_. The result is expressed in radians and ranges from +0 to +π.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is greater than 1, the result is NaN.

-   If _x_ is less than −1, the result is NaN.

-   If _x_ is exactly 1, the result is +0.

Math.acosh( x )

Returns an implementation-dependent approximation to the inverse
hyperbolic cosine of _x_.

-   If _x_ is NaN, the result is NaN.

-   If x is less than 1, the result is NaN.

-   If x is 1, the result is +0.

-   If _x_ is +∞, the result is +∞.

Math.asin ( x )

Returns an implementation-dependent approximation to the arc sine of
_x_. The result is expressed in radians and ranges from −π/2 to +π/2.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is greater than 1, the result is NaN.

-   If _x_ is less than –1, the result is NaN.

-   If _x_ is +0, the result is +0.

-   If _x_ is −0, the result is −0.

Math.asinh( x )

Returns an implementation-dependent approximation to the inverse
hyperbolic sine of _x_.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is +0, the result is +0.

-   If _x_ is −0, the result is −0.

-   If _x_ is +∞, the result is +∞.

-   If x is −∞, the result is −∞.

Math.atan ( x )

Returns an implementation-dependent approximation to the arc tangent of
_x_. The result is expressed in radians and ranges from −π/2 to +π/2.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is +0, the result is +0.

-   If _x_ is −0, the result is −0.

-   If _x_ is +∞, the result is an implementation-dependent
      approximation to +π/2.

-   If _x_ is −∞, the result is an implementation-dependent
      approximation to −π/2.

Math.atanh( x )

Returns an implementation-dependent approximation to the inverse
hyperbolic tangent of _x_.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is less than −1, the result is NaN.

-   If _x_ is greater than 1, the result is NaN.

-   If _x_ is −1, the result is −∞.

-   If _x_ is +1, the result is +∞.

-   If _x_ is +0, the result is +0.

-   If _x_ is −0, the result is −0.

Math.atan2 ( y, x )

Returns an implementation-dependent approximation to the arc tangent of
the quotient _y_/_x_ of the arguments _y_ and _x_, where the signs of
_y_ and _x_ are used to determine the quadrant of the result. Note that
it is intentional and traditional for the two-argument arc tangent
function that the argument named _y_ be first and the argument named _x_
be second. The result is expressed in radians and ranges from −π to +π.

-   If either _x_ or _y_ is NaN, the result is NaN.

-   If _y_>0 and _x_ is +0, the result is an implementation-dependent
      approximation to +π/2.

-   If _y_>0 and _x_ is −0, the result is an implementation-dependent
      approximation to +π/2.

-   If _y_ is +0 and _x_>0, the result is +0.

-   If _y_ is +0 and _x_ is +0, the result is +0.

-   If _y_ is +0 and _x_ is −0, the result is an
      implementation-dependent approximation to +π.

-   If _y_ is +0 and _x_<0, the result is an implementation-dependent
      approximation to +π.

-   If _y_ is −0 and _x_>0, the result is −0.

-   If _y_ is −0 and _x_ is +0, the result is −0.

-   If _y_ is −0 and _x_ is −0, the result is an
      implementation-dependent approximation to −π.

-   If _y_ is −0 and _x_<0, the result is an implementation-dependent
      approximation to −π.

-   If _y_<0 and _x_ is +0, the result is an implementation-dependent
      approximation to −π/2.

-   If _y_<0 and _x_ is −0, the result is an implementation-dependent
      approximation to −π/2.

-   If _y_>0 and _y_ is finite and _x_ is +∞, the result is +0.

-   If _y_>0 and _y_ is finite and _x_ is −∞, the result if an
      implementation-dependent approximation to +π.

-   If _y_<0 and _y_ is finite and _x_ is +∞, the result is −0.

-   If _y_<0 and _y_ is finite and _x_ is −∞, the result is an
      implementation-dependent approximation to −π.

-   If _y_ is +∞ and _x_ is finite, the result is an
      implementation-dependent approximation to +π/2.

-   If _y_ is −∞ and _x_ is finite, the result is an
      implementation-dependent approximation to −π/2.

-   If _y_ is +∞ and _x_ is +∞, the result is an
      implementation-dependent approximation to +π/4.

-   If _y_ is +∞ and _x_ is −∞, the result is an
      implementation-dependent approximation to +3π/4.

-   If _y_ is −∞ and _x_ is +∞, the result is an
      implementation-dependent approximation to −π/4.

-   If _y_ is −∞ and _x_ is −∞, the result is an
      implementation-dependent approximation to −3π/4.

Math.cbrt ( x )

Returns an implementation-dependent approximation to the cube root of
_x_.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is +0, the result is +0.

-   If _x_ is −0, the result is −0.

-   If _x_ is +∞, the result is +∞.

-   If _x_ is −∞, the result is −∞.

Math.ceil ( x )

Returns the smallest (closest to −∞) Number value that is not less than
_x_ and is equal to a mathematical integer. If _x_ is already an
integer, the result is _x_.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is +0, the result is +0.

-   If _x_ is −0, the result is −0.

-   If _x_ is +∞, the result is +∞.

-   If _x_ is −∞, the result is −∞.

-   If _x_ is less than 0 but greater than -1, the result is −0.

The value of MATH.CEIL(X) is the same as the value of -MATH.FLOOR(-X).

Math.clz32 ( x )

When MATH.CLZ32 is called with one argument _x_, the following steps are
taken:

1.  Let _n_ be ToUint32(_x_).

2.  ReturnIfAbrupt(_n_).

3.  Let _p_ be the number of leading zero bits in the 32-bit binary
    representation of _n_.

4.  Return _p_.

NOTE If _n_ is 0, _p_ will be 32. If the most significant bit of the
32-bit binary encoding of _n_ is 1, _p_ will be 0.

Math.cos ( x )

Returns an implementation-dependent approximation to the cosine of _x_.
The argument is expressed in radians.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is +0, the result is 1.

-   If _x_ is −0, the result is 1.

-   If _x_ is +∞, the result is NaN.

-   If _x_ is −∞, the result is NaN.

Math.cosh ( x )

Returns an implementation-dependent approximation to the hyperbolic
cosine of _x_.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is +0, the result is 1.

-   If _x_ is −0, the result is 1.

-   If _x_ is +∞, the result is +∞.

-   If _x_ is −∞, the result is +∞.

NOTE The value of cosh(x) is the same as _(exp(x) + exp(-x))/2_.

Math.exp ( x )

Returns an implementation-dependent approximation to the exponential
function of _x_ (_e_ raised to the power of _x_, where _e_ is the base
of the natural logarithms).

-   If _x_ is NaN, the result is NaN.

-   If _x_ is +0, the result is 1.

-   If _x_ is −0, the result is 1.

-   If _x_ is +∞, the result is +∞.

-   If _x_ is −∞, the result is +0.

Math.expm1 ( x )

Returns an implementation-dependent approximation to subtracting 1 from
the exponential function of _x_ (_e_ raised to the power of _x_, where
_e_ is the base of the natural logarithms). The result is computed in a
way that is accurate even when the value of x is close 0.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is +0, the result is +0.

-   If _x_ is −0, the result is −0.

-   If _x_ is +∞, the result is +∞.

-   If _x_ is −∞, the result is −1.

Math.floor ( x )

Returns the greatest (closest to +∞) Number value that is not greater
than _x_ and is equal to a mathematical integer. If _x_ is already an
integer, the result is _x_.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is +0, the result is +0.

-   If _x_ is −0, the result is −0.

-   If _x_ is +∞, the result is +∞.

-   If _x_ is −∞, the result is −∞.

-   If _x_ is greater than 0 but less than 1, the result is +0.

NOTE The value of MATH.FLOOR(X) is the same as the value of
-MATH.CEIL(-X).

Math.fround ( x )

When MATH.FROUND is called with argument _x_ the following steps are
taken:

1.  If _x_ is NaN, return NaN.

2.  If _x_ is one of +0, −0, +∞, −∞, then return _x_.

3.  Let _x32_ be the result of converting _x_ to a value in
    IEEE-754-2008 binary32 format using roundTiesToEven.

4.  Let _x64_ be the result of converting _x32_ to a value in
    IEEE-754-2008 binary64 format.

5.  Return the ECMAScript Number value corresponding to _x64_.

Math.hypot ( value1 , value2 , …values )

MATH.HYPOT returns an implementation-dependent approximation of the
square root of the sum of squares of its arguments.

-   If no arguments are passed, the result is +0.

-   If any argument is +∞, the result is +∞.

-   If any argument is −∞, the result is +∞.

-   If no argument is +∞ or −∞, and any argument is NaN, the result is
      NaN.

-   If all arguments are either +0 or −0, the result is +0.

The length property of the HYPOT function is 2.

NOTE Implementations should take care to avoid the loss of precision
from overflows and underflows that are prone to occur in naive
implementations when this function is called with more than two
arguments.

Math.imul ( x, y )

When the MATH.IMUL is called with arguments _x_ and _y_ the following
steps are taken:

1.  Let _a_ be ToUint32(_x_).

2.  ReturnIfAbrupt(_a_).

3.  Let _b_ be ToUint32(_y_).

4.  ReturnIfAbrupt(_b_).

5.  Let _product_ be (_a_ × _b_) modulo 2^32^.

6.  If _product_ ≥ 2^31^, return _product_ − 2^32^, otherwise return
    _product_.

Math.log ( x )

Returns an implementation-dependent approximation to the natural
logarithm of _x_.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is less than 0, the result is NaN.

-   If _x_ is +0 or −0, the result is −∞.

-   If _x_ is 1, the result is +0.

-   If _x_ is +∞, the result is +∞.

Math.log1p ( x )

Returns an implementation-dependent approximation to the natural
logarithm of 1 + _x_. The result is computed in a way that is accurate
even when the value of x is close to zero.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is less than -1, the result is NaN.

-   If x is -1, the result is -∞.

-   If _x_ is +0, the result is +0.

-   If _x_ is −0, the result is −0.

-   If _x_ is +∞, the result is +∞.

Math.log10 ( x )

Returns an implementation-dependent approximation to the base 10
logarithm of _x_.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is less than 0, the result is NaN.

-   If _x_ is +0, the result is −∞.

-   If _x_ is −0, the result is −∞.

-   If _x_ is 1, the result is +0.

-   If _x_ is +∞, the result is +∞.

Math.log2 ( x )

Returns an implementation-dependent approximation to the base 2
logarithm of _x_.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is less than 0, the result is NaN.

-   If _x_ is +0, the result is −∞.

-   If _x_ is −0, the result is −∞.

-   If _x_ is 1, the result is +0.

-   If _x_ is +∞, the result is +∞.

Math.max ( value1, value2 , …values )

Given zero or more arguments, calls ToNumber on each of the arguments
and returns the largest of the resulting values.

-   If no arguments are given, the result is −∞.

-   If any value is NaN, the result is NaN.

-   The comparison of values to determine the largest value is done
      using the Abstract Relational Comparison algorithm (7.2.8) except
      that +0 is considered to be larger than −0.

The LENGTH property of the MAX method is 2.

Math.min ( value1, value2 , …values )

Given zero or more arguments, calls ToNumber on each of the arguments
and returns the smallest of the resulting values.

-   If no arguments are given, the result is +∞.

-   If any value is NaN, the result is NaN.

-   The comparison of values to determine the smallest value is done
      using the Abstract Relational Comparison algorithm (7.2.8) except
      that +0 is considered to be larger than −0.

The LENGTH property of the MIN method is 2.

Math.pow ( x, y )

Returns an implementation-dependent approximation to the result of
raising _x_ to the power _y_.

-   If _y_ is NaN, the result is NaN.

-   If _y_ is +0, the result is 1, even if _x_ is NaN.

-   If _y_ is −0, the result is 1, even if _x_ is NaN.

-   If _x_ is NaN and _y_ is nonzero, the result is NaN.

-   If abs(_x_)>1 and _y_ is +∞, the result is +∞.

-   If abs(_x_)>1 and _y_ is −∞, the result is +0.

-   If abs(_x_) is 1 and _y_ is +∞, the result is NaN.

-   If abs(_x_) is 1 and _y_ is −∞, the result is NaN.

-   If abs(_x_)<1 and _y_ is +∞, the result is +0.

-   If abs(_x_)<1 and _y_ is −∞, the result is +∞.

-   If _x_ is +∞ and _y_>0, the result is +∞.

-   If _x_ is +∞ and _y_<0, the result is +0.

-   If _x_ is −∞ and _y_>0 and _y_ is an odd integer, the result is −∞.

-   If _x_ is −∞ and _y_>0 and _y_ is not an odd integer, the result
      is +∞.

-   If _x_ is −∞ and _y_<0 and _y_ is an odd integer, the result is −0.

-   If _x_ is −∞ and _y_<0 and _y_ is not an odd integer, the result
      is +0.

-   If _x_ is +0 and _y_>0, the result is +0.

-   If _x_ is +0 and _y_<0, the result is +∞.

-   If _x_ is −0 and _y_>0 and _y_ is an odd integer, the result is −0.

-   If _x_ is −0 and _y_>0 and _y_ is not an odd integer, the result
      is +0.

-   If _x_ is −0 and _y_<0 and _y_ is an odd integer, the result is −∞.

-   If _x_ is −0 and _y_<0 and _y_ is not an odd integer, the result
      is +∞.

-   If _x_<0 and _x_ is finite and _y_ is finite and _y_ is not an
      integer, the result is NaN.

Math.random ( )

Returns a Number value with positive sign, greater than or equal to 0
but less than 1, chosen randomly or pseudo randomly with approximately
uniform distribution over that range, using an implementation-dependent
algorithm or strategy. This function takes no arguments.

Each MATH.RANDOM function created for distinct code Realms must produce
a distinct sequence of values from successive calls.

Math.round ( x )

Returns the Number value that is closest to _x_ and is equal to a
mathematical integer. If two integer Number values are equally close to
_x_, then the result is the Number value that is closer to +∞. If _x_ is
already an integer, the result is _x_.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is +0, the result is +0.

-   If _x_ is −0, the result is −0.

-   If _x_ is +∞, the result is +∞.

-   If _x_ is −∞, the result is −∞.

-   If _x_ is greater than 0 but less than 0.5, the result is +0.

-   If _x_ is less than 0 but greater than or equal to -0.5, the result
      is −0.

NOTE 1 MATH.ROUND(3.5) returns 4, but MATH.ROUND(–3.5) returns –3.

NOTE 2 The value of MATH.ROUND(X) is not always the same as the value of
MATH.FLOOR(X+0.5). When X is −0 or is less than 0 but greater than or
equal to -0.5, MATH.ROUND(X) returns −0, but MATH.FLOOR(X+0.5)
returns +0. MATH.ROUND(X) may also differ from the value of
MATH.FLOOR(X+0.5)because of internal rounding when computing X+0.5.

Math.sign(x)

Returns the sign of the x, indicating whether x is positive, negative or
zero.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is −0, the result is −0.

-   If _x_ is +0, the result is +0.

-   If _x_ is negative and not −0, the result is −1.

-   If _x_ is positive and not +0, the result is +1.

Math.sin ( x )

Returns an implementation-dependent approximation to the sine of _x_.
The argument is expressed in radians.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is +0, the result is +0.

-   If _x_ is −0, the result is −0.

-   If _x_ is +∞ or −∞, the result is NaN.

Math.sinh( x )

Returns an implementation-dependent approximation to the hyperbolic sine
of _x_.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is +0, the result is +0.

-   If _x_ is −0, the result is −0.

-   If _x_ is +∞, the result is +∞.

-   If x is −∞, the result is −∞.

NOTE The value of sinh(x) is the same as _(exp(x) - exp(-x))/2_.

Math.sqrt ( x )

Returns an implementation-dependent approximation to the square root of
_x_.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is less than 0, the result is NaN.

-   If _x_ is +0, the result is +0.

-   If _x_ is −0, the result is −0.

-   If _x_ is +∞, the result is +∞.

Math.tan ( x )

Returns an implementation-dependent approximation to the tangent of _x_.
The argument is expressed in radians.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is +0, the result is +0.

-   If _x_ is −0, the result is −0.

-   If _x_ is +∞ or −∞, the result is NaN.

Math.tanh ( x )

Returns an implementation-dependent approximation to the hyperbolic
tangent of _x_.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is +0, the result is +0.

-   If _x_ is −0, the result is −0.

-   If _x_ is +∞, the result is +1.

-   If _x_ is −∞, the result is -1.

NOTE The value of tanh(x) is the same as _(exp(x) - exp(-x))/(exp(x) +
exp(-x))_.

Math.trunc ( x )

Returns the integral part of the number _x_, removing any fractional
digits. If _x_ is already an integer, the result is _x_.

-   If _x_ is NaN, the result is NaN.

-   If _x_ is −0, the result is −0.

-   If _x_ is +0, the result is +0.

-   If _x_ is +∞, the result is +∞.

-   If x is −∞, the result is −∞.

-   If _x_ is greater than 0 but less than 1, the result is +0.

-   If _x_ is less than 0 but greater than −1, the result is −0.


Date Objects

Overview of Date Objects and Definitions of Abstract Operations

The following functions are abstract operations that operate on time
values (defined in 20.3.1.1). Note that, in every case, if any argument
to one of these functions is NAN, the result will be NAN.

Time Values and Time Range

A Date object contains a Number indicating a particular instant in time
to within a millisecond. Such a Number is called a _time value_. A time
value may also be NAN, indicating that the Date object does not
represent a specific instant of time.

Time is measured in ECMAScript in milliseconds since 01 January, 1970
UTC. In time values leap seconds are ignored. It is assumed that there
are exactly 86,400,000 milliseconds per day. ECMAScript Number values
can represent all integers from –9,007,199,254,740,992 to
9,007,199,254,740,992; this range suffices to measure times to
millisecond precision for any instant that is within approximately
285,616 years, either forward or backward, from 01 January, 1970 UTC.

The actual range of times supported by ECMAScript Date objects is
slightly smaller: exactly –100,000,000 days to 100,000,000 days measured
relative to midnight at the beginning of 01 January, 1970 UTC. This
gives a range of 8,640,000,000,000,000 milliseconds to either side of 01
January, 1970 UTC.

The exact moment of midnight at the beginning of 01 January, 1970 UTC is
represented by the value +0.

Day Number and Time within Day

A given time value _t_ belongs to day number

Day(_t_) = floor(_t_ / msPerDay)

where the number of milliseconds per day is

msPerDay = 86400000

The remainder is called the time within the day:

TimeWithinDay(_t_) = _t_ modulo msPerDay

Year Number

ECMAScript uses an extrapolated Gregorian system to map a day number to
a year number and to determine the month and date within that year. In
this system, leap years are precisely those which are (divisible by 4)
and ((not divisible by 100) or (divisible by 400)). The number of days
in year number _y_ is therefore defined by

  DaysInYear(_y_) = 365 if (_y_ modulo 4) ≠ 0
  = 366 if (_y_ modulo 4) = 0 and (_y_ modulo 100) ≠ 0
  = 365 if (_y_ modulo 100) = 0 and (_y_ modulo 400) ≠ 0
  = 366 if (_y_ modulo 400) = 0

All non-leap years have 365 days with the usual number of days per month
and leap years have an extra day in February. The day number of the
first day of year _y_ is given by:

DayFromYear(_y_) = 365 × (_y_−1970) + floor((_y_−1969)/4) −
floor((_y_−1901)/100) + floor((_y_−1601)/400)

The time value of the start of a year is:

TimeFromYear(_y_) = msPerDay × DayFromYear(_y_)

A time value determines a year by:

YearFromTime(_t_) = the largest integer _y_ (closest to positive
infinity) such that TimeFromYear(_y_) ≤ _t_

The leap-year function is 1 for a time within a leap year and otherwise
is zero:

  InLeapYear(_t_) = 0 if DaysInYear(YearFromTime(_t_)) = 365
  = 1 if DaysInYear(YearFromTime_(t_)) = 366

Month Number

Months are identified by an integer in the range 0 to 11, inclusive. The
mapping MonthFromTime(_t_) from a time value _t_ to a month number is
defined by:

MonthFromTime(_t_) = 0 if 0 ≤ DayWithinYear(_t_) < 31
 = 1 if 31 ≤ DayWithinYear (_t_) < 59+InLeapYear(_t_)
 = 2 if 59+InLeapYear(_t_) ≤ DayWithinYear (_t_) < 90+InLeapYear(_t_)
 = 3 if 90+InLeapYear(_t_) ≤ DayWithinYear (_t_) < 120+InLeapYear(_t_)
 = 4 if 120+InLeapYear(_t_) ≤ DayWithinYear (_t_) < 151+InLeapYear(_t_)
 = 5 if 151+InLeapYear(_t_) ≤ DayWithinYear (_t_) < 181+InLeapYear(_t_)
 = 6 if 181+InLeapYear(_t_) ≤ DayWithinYear (_t_) < 212+InLeapYear(_t_)
 = 7 if 212+InLeapYear(_t_) ≤ DayWithinYear (_t_) < 243+InLeapYear(_t_)
 = 8 if 243+InLeapYear(_t_) ≤ DayWithinYear (_t_) < 273+InLeapYear(_t_)
 = 9 if 273+InLeapYear(_t_) ≤ DayWithinYear (_t_) < 304+InLeapYear(_t_)
 = 10 if 304+InLeapYear(_t_) ≤ DayWithinYear (_t_) < 334+InLeapYear(_t_)
 = 11 if 334+InLeapYear(_t_) ≤ DayWithinYear (_t_) < 365+InLeapYear(_t_)

where

DayWithinYear(_t_) = Day(_t_)−DayFromYear(YearFromTime(_t)_)

A month value of 0 specifies January; 1 specifies February; 2 specifies
March; 3 specifies April; 4 specifies May; 5 specifies June; 6 specifies
July; 7 specifies August; 8 specifies September; 9 specifies October; 10
specifies November; and 11 specifies December. Note that
MonthFromTime(0) = 0, corresponding to Thursday, 01 January, 1970.

Date Number

A date number is identified by an integer in the range 1 through 31,
inclusive. The mapping DateFromTime(_t_) from a time value _t_ to a
month number is defined by:

  DateFromTime(_t_) = DayWithinYear(_t_)+1 if MonthFromTime(_t_)=0
   = DayWithinYear(_t_)−30 if MonthFromTime(_t_)=1
   = DayWithinYear(_t_)−58−InLeapYear(_t_) if MonthFromTime(_t_)=2
   = DayWithinYear(_t_)−89−InLeapYear(_t_) if MonthFromTime(_t_)=3
   = DayWithinYear(_t_)−119−InLeapYear(_t_) if MonthFromTime(_t_)=4
   = DayWithinYear(_t_)−150−InLeapYear(_t_) if MonthFromTime(_t_)=5
   = DayWithinYear(_t_)−180−InLeapYear(_t_) if MonthFromTime(_t_)=6
   = DayWithinYear(_t_)−211−InLeapYear(_t_) if MonthFromTime(_t_)=7
   = DayWithinYear(_t_)−242−InLeapYear(_t_) if MonthFromTime(_t_)=8
   = DayWithinYear(_t_)−272−InLeapYear(_t_) if MonthFromTime(_t_)=9
   = DayWithinYear(_t_)−303−InLeapYear(_t_) if MonthFromTime(_t_)=10
   = DayWithinYear(_t_)−333−InLeapYear(_t_) if MonthFromTime(_t_)=11

Week Day

The weekday for a particular time value _t_ is defined as

WeekDay(_t_) = (Day(_t_) + 4) modulo 7

A weekday value of 0 specifies Sunday; 1 specifies Monday; 2 specifies
Tuesday; 3 specifies Wednesday; 4 specifies Thursday; 5 specifies
Friday; and 6 specifies Saturday. Note that WeekDay(0) = 4,
corresponding to Thursday, 01 January, 1970.

Local Time Zone Adjustment

An implementation of ECMAScript is expected to determine the local time
zone adjustment. The local time zone adjustment is a value LocalTZA
measured in milliseconds which when added to UTC represents the local
_standard_ time. Daylight saving time is _not_ reflected by LocalTZA.

NOTE It is recommended that implementations use the time zone
information of the IANA Time Zone Database.

Daylight Saving Time Adjustment

An implementation dependent algorithm using best available information
on time zones to determine the local daylight saving time adjustment
DaylightSavingTA(_t_), measured in milliseconds. An implementation of
ECMAScript is expected to make its best effort to determine the local
daylight saving time adjustment.

 Local Time

Conversion from UTC to local time is defined by

LocalTime(_t_) = _t_ + LocalTZA + DaylightSavingTA(_t_)

Conversion from local time to UTC is defined by

UTC(_t_) = _t_ – LocalTZA – DaylightSavingTA(_t_ – LocalTZA)

NOTE UTC(LocalTime(_t_)) is not necessarily always equal to _t_.

Hours, Minutes, Second, and Milliseconds

The following functions are useful in decomposing time values:

HourFromTime(_t_) = floor(_t_ / msPerHour) modulo HoursPerDay

MinFromTime(_t_) = floor(_t_ / msPerMinute) modulo MinutesPerHour

SecFromTime(_t_) = floor(_t_ / msPerSecond) modulo SecondsPerMinute

msFromTime(_t_) = _t_ modulo msPerSecond

where

HoursPerDay = 24

MinutesPerHour = 60

SecondsPerMinute = 60

msPerSecond = 1000

msPerMinute = 60000 = msPerSecond × SecondsPerMinute

msPerHour = 3600000 = msPerMinute × MinutesPerHour

MakeTime (hour, min, sec, ms)

The operator MakeTime calculates a number of milliseconds from its four
arguments, which must be ECMAScript Number values. This operator
functions as follows:

1.  If _hour_ is not finite or _min_ is not finite or _sec_ is not
    finite or _ms_ is not finite, return NAN.

2.  Let _h_ be ToInteger(_hour_).

3.  Let _m_ be ToInteger(_min_).

4.  Let _s_ be ToInteger(_sec_).

5.  Let _milli_ be ToInteger(_ms_).

6.  Let _t_ be _h_ * msPerHour + _m_ * msPerMinute + _s_ * msPerSecond +
    _milli_, performing the arithmetic according to IEEE 754 rules (that
    is, as if using the ECMAScript operators * and +).

7.  Return _t_.

MakeDay (year, month, date)

The operator MakeDay calculates a number of days from its three
arguments, which must be ECMAScript Number values. This operator
functions as follows:

1.  If _year_ is not finite or _month_ is not finite or _date_ is not
    finite, return NAN.

2.  Let _y_ be ToInteger(_year_).

3.  Let _m_ be ToInteger(_month_).

4.  Let _dt_ be ToInteger(_date_).

5.  Let _ym_ be _y_ + floor(_m_ /12).

6.  Let _mn_ be _m_ modulo 12.

7.  Find a value _t_ such that YearFromTime(_t_) is _ym_ and
    MonthFromTime(_t_) is _mn_ and DateFromTime(_t_) is 1; but if this
    is not possible (because some argument is out of range), return NAN.

8.  Return Day(_t_) + _dt_ − 1.

MakeDate (day, time)

The operator MakeDate calculates a number of milliseconds from its two
arguments, which must be ECMAScript Number values. This operator
functions as follows:

1.  If _day_ is not finite or _time_ is not finite, return NAN.

2.  Return _day_ × msPerDay + _time_.

TimeClip (time)

The operator TimeClip calculates a number of milliseconds from its
argument, which must be an ECMAScript Number value. This operator
functions as follows:

1.  If _time_ is not finite, return NAN.

2.  If abs(_time_) > 8.64 × 10^15^, return NAN.

3.  Return ToInteger(_time_) + (+0). (Adding a positive zero converts −
    to +0.)

NOTE The point of step 3 is that an implementation is permitted a choice
of internal representations of time values, for example as a 64-bit
signed integer or as a 64-bit floating-point value. Depending on the
implementation, this internal representation may or may not distinguish
−0 and +0.

Date Time String Format

ECMAScript defines a string interchange format for date-times based upon
a simplification of the ISO 8601 Extended Format. The format is as
follows: YYYY-MM-DDTHH:MM:SS.SSS_Z_

Where the fields are as follows:

This format includes date-only forms:

  YYYY
  YYYY-MM
  YYYY-MM-DD

It also includes “date-time” forms that consist of one of the above
date-only forms immediately followed by one of the following time forms
with an optional time zone offset appended:

  THH:MM
  THH:MM:SS
  THH:MM:SS.SSS

All numbers must be base 10. If the MM or DD fields are absent “01” is
used as the value. If the HH, MM, or SS fields are absent “00” is used
as the value and the value of an absent SSS field is “000”. If the time
zone offset is absent, the date-time is interpreted as a local time.

Illegal values (out-of-bounds as well as syntax errors) in a format
string means that the format string is not a valid instance of this
format.

NOTE 1 As every day both starts and ends with midnight, the two
notations 00:00 and 24:00 are available to distinguish the two midnights
that can be associated with one date. This means that the following two
notations refer to exactly the same point in time: 1995-02-04T24:00 and
1995-02-05T00:

NOTE 2 There exists no international standard that specifies
abbreviations for civil time zones like CET, EST, etc. and sometimes the
same abbreviation is even used for two very different time zones. For
this reason, ISO 8601 and this format specifies numeric representations
of date and time.

Extended years

ECMAScript requires the ability to specify 6 digit years (extended
years); approximately 285,426 years, either forward or backward, from 01
January, 1970 UTC. To represent years before 0 or after 9999, ISO 8601
permits the expansion of the year representation, but only by prior
agreement between the sender and the receiver. In the simplified
ECMAScript format such an expanded year representation shall have 2
extra year digits and is always prefixed with a + or – sign. The year 0
is considered positive and hence prefixed with a + sign.

NOTE Examples of extended years:

  -283457-03-21T15:00:59.008Z 283458 B.C.
  -000001-01-01T00:00:00Z 2 B.C.
  +000000-01-01T00:00:00Z 1 B.C.
  +000001-01-01T00:00:00Z 1 A.D.
  +001970-01-01T00:00:00Z 1970 A.D.
  +002009-12-15T00:00:00Z 2009 A.D.
  +287396-10-12T08:59:00.992Z 287396 A.D.

The Date Constructor 

The Date constructor is the %Date% intrinsic object and the initial
value of the DATE property of the global object. When DATE is called as
a function rather than as a constructor, it returns a String
representing the current time (UTC). However, if the THIS value passed
in the call is an Object with an uninitialized [[DateValue]] internal
slot, DATE initializes the THIS object using the argument value. This
permits DATE to be used both as a function for creating data strings and
to perform constructor instance initialization.

The DATE constructor is designed to be subclassable. It may be used as
the value of an EXTENDS clause of a class declaration. Subclass
constructors that intended to inherit the specified DATE behaviour must
include a SUPER call to the DATE constructor to initialize the
[[DateValue]] state of subclass instances.

Date ( year, month [, date [ , hours [ , minutes [ , seconds [ , ms ] ] ] ] ] )

This description applies only if the Date constructor is called with at
least two arguments.

When the DATE function is called the following steps are taken:

1.  Let _numberOfArgs_ be the number of arguments passed to this
    function call.

2.  Assert: _numberOfArgs_ ≥ 2.

3.  Let _O_ be the THIS value.

4.  If Type(_O_) is Object and _O_ has a [[DateValue]] internal slot and
    the value of [[DateValue]] is UNDEFINED, then

    a.  Let _y_ be ToNumber(_year_).

    b.  ReturnIfAbrupt(_year_).

    c.  Let _m_ be ToNumber(_month_).

    d.  ReturnIfAbrupt(_month_).

    e.  If _date_ is supplied then let _dt_ be ToNumber(_date_); else
        let _dt_ be 1.

    f.  ReturnIfAbrupt(_dt_).

    g.  If _hours_ is supplied then let _h_ be ToNumber(_hours_); else
        let _h_ be 0.

    h.  ReturnIfAbrupt(_h_).

    i.  If _minutes_ is supplied then let _min_ be ToNumber(_minutes_);
        else let _min_ be 0.

    j.  ReturnIfAbrupt(_min_).

    k.  If _seconds_ is supplied then let _s_ be ToNumber(_seconds_);
        else let _s_ be 0.

    l.  ReturnIfAbrupt(_s_).

    m.  If _ms_ is supplied then let _milli_ be ToNumber(_ms_); else let
        _milli_ be 0.

    n.  ReturnIfAbrupt(_milli_).

    o.  If _y_ is not NAN and 0 ≤ ToInteger(_y_) ≤ 99, then let _yr_
        be 1900+ToInteger(_y_); otherwise, let _yr_ be _y_.

    p.  Let _finalDate_ be MakeDate(MakeDay(_yr_, _m_, _dt_),
        MakeTime(_h_, _min_, _s_, _milli_)).

    q.  Set the [[DateValue]] internal slot of _O_ to
        TimeClip(UTC(_finalDate_)).

    r.  Return _O_.

5.  Else,

    a.  Let _now_ be the Number that is the time value (UTC) identifying
        the current time.

    b.  Return ToDateString (_now_).

 Date ( value )

This description applies only if the Date constructor is called with
exactly one argument.

When the DATE function is called the following steps are taken:

1.  Let _numberOfArgs_ be the number of arguments passed to this
    function call.

2.  Assert: _numberOfArgs_ = 1.

3.  Let _O_ be the THIS value.

4.  If Type(_O_) is Object and _O_ has a [[DateValue]] internal slot and
    the value of [[DateValue]] is UNDEFINED, then

    a.  If Type(_value_) is Object and _value_ has a [[DateValue]]
        internal slot, then

        i.  Let _tv_ be thisTimeValue(_value_).

    b.  Else,

        i.  Let _v_ be ToPrimitive(_value_).

        ii. If Type(_v_) is String, then

            1.  Let _tv_ be the result of parsing _v_ as a date, in
                exactly the same manner as for the PARSE method
                (20.3.3.2). If the parse resulted in an abrupt
                completion, _tv_ is the Completion Record.

        iii. Else,

            1.  Let _tv_ be ToNumber(_v_).

    c.  ReturnIfAbrupt(_tv_).

    d.  Set the [[DateValue]] internal slot of _O_ to TimeClip(_tv_).

    e.  Return _O_.

5.  Else,

    a.  Let _now_ be the Number that is the time value (UTC) identifying
        the current time.

    b.  Return ToDateString (_now_).

Date ( )

This description applies only if the Date constructor is called with no
arguments.

When the DATE function is called the following steps are taken:

1.  Let _numberOfArgs_ be the number of arguments passed to this
    function call.

2.  Assert: _numberOfArgs_ = 0.

3.  Let _O_ be the THIS value.

4.  If Type(_O_) is Object and _O_ has a [[DateValue]] internal slot and
    the value of [[DateValue]] is UNDEFINED, then

    a.  Set the [[DateValue]] internal slot of _O_ to the time value
        (UTC) identifying the current time.

    b.  Return _O_.

5.  Else,

    a.  Let _now_ be the Number that is the time value (UTC) identifying
        the current time.

    b.  Return ToDateString (_now_).

new Date ( ...argumentsList )

When DATE is called as part of a new expression with argument list
_argumentsList_ it performs the following steps:

1.  Let _F_ be the DATE function object on which the NEW operator was
    applied.

2.  Let _argumentsList_ be the _argumentsList_ argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return Construct (_F_, _argumentsList_).

If DATE is implemented as an ECMAScript function object, its
[[Construct]] internal method will perform the above steps.

Properties of the Date Constructor

The value of the [[Prototype]] internal slot of the Date constructor is
the Function prototype object (19.2.3).

Besides the LENGTH property (whose value is 7), the Date constructor has
the following properties:

Date.now ( )

The NOW function return a Number value that is the time value
designating the UTC date and time of the occurrence of the call to NOW.

Date.parse ( string )

The PARSE function applies the ToString operator to its argument. If
ToString results in an abrupt completion the Completion Record is
immediately returned. Otherwise, PARSE interprets the resulting String
as a date and time; it returns a Number, the UTC time value
corresponding to the date and time. The String may be interpreted as a
local time, a UTC time, or a time in some other time zone, depending on
the contents of the String. The function first attempts to parse the
format of the String according to the rules (including extended years)
called out in Date Time String Format (20.3.1.15). If the String does
not conform to that format the function may fall back to any
implementation-specific heuristics or implementation-specific date
formats. Unrecognizable Strings or dates containing illegal element
values in the format String shall cause DATE.PARSE to return NAN.

If _x_ is any Date object whose milliseconds amount is zero within a
particular implementation of ECMAScript, then all of the following
expressions should produce the same numeric value in that
implementation, if all the properties referenced have their initial
values:

  _X_.VALUEOF()

  DATE.PARSE(_X_.TOSTRING())

  DATE.PARSE(_X_.TOUTCSTRING())

  DATE.PARSE(_X_.TOISOSTRING())

However, the expression

  DATE.PARSE(_X_.TOLOCALESTRING())

is not required to produce the same Number value as the preceding three
expressions and, in general, the value produced by DATE.PARSE is
implementation-dependent when given any String value that does not
conform to the Date Time String Format (20.3.1.15) and that could not be
produced in that implementation by the TOSTRING or TOUTCSTRING method.

Date.prototype

The initial value of DATE.PROTOTYPE is the built-in Date prototype
object (20.3.4).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Date.UTC ( year, month [ , date [ , hours [ , minutes [ , seconds [ , ms ] ] ] ] ] )

When the UTC function is called with fewer than two arguments, the
behaviour is implementation-dependent. When the UTC function is called
with two to seven arguments, it computes the date from _year_, _month_
and (optionally) _date_, _hours_, _minutes_, _seconds_ and _ms_. The
following steps are taken:

1.  Let _y_ be ToNumber(_year_).

2.  ReturnIfAbrupt(_y_).

3.  Let _m_ be ToNumber(_month_).

4.  ReturnIfAbrupt(_m_).

5.  If _date_ is supplied then let _dt_ be ToNumber(_date_); else let
    _dt_ be 1.

6.  ReturnIfAbrupt(_dt_).

7.  If _hours_ is supplied then let _h_ be ToNumber(_hours_); else let
    _h_ be 0.

8.  ReturnIfAbrupt(_h_).

9.  If _minutes_ is supplied then let _min_ be ToNumber(_minutes_); else
    let _min_ be 0.

10. ReturnIfAbrupt(_min_).

11. If _seconds_ is supplied then let _s_ be ToNumber(_seconds_); else
    let _s_ be 0.

12. ReturnIfAbrupt(_s_).

13. If _ms_ is supplied then let _milli_ be ToNumber(_ms_); else let
    _milli_ be 0.

14. ReturnIfAbrupt(_milli_).

15. If _y_ is not NAN and 0 ≤ ToInteger(_y_) ≤ 99, then let _yr
    be 1900+ToInteger(_y_); otherwise, let _yr_ be _y_.

16. Return TimeClip(MakeDate(MakeDay(_yr_, _m_, _dt_), MakeTime(_h_,
    _min_, _s_, _milli_))).

The LENGTH property of the UTC function is 7.

NOTE The UTC function differs from the Date constructor in two ways: it
returns a time value as a Number, rather than creating a Date object,
and it interprets the arguments in UTC rather than as local time.

Date[ @@create ] ( )

The @@create method of an object _F_ performs the following steps:

1.  Let _obj_ be OrdinaryCreateFromConstructor(_F_, "%DATEPROTOTYPE%", (
    [[DateValue]])).

2.  Return _obj_.

The value of the NAME property of this function is "[SYMBOL.CREATE]".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

NOTE [[DateValue]] is initially assigned the value UNDEFINED as a flag
to indicate that the instance has not yet been initialized by the Date
constructor. This flag value is never directly exposed to ECMAScript
code; hence implementations may choose to encode the flag in some other
manner.

Properties of the Date Prototype Object

The Date prototype object is itself an ordinary object. It is not a Date
instance and does not have a [[DateValue]] internal slot.

The value of the [[Prototype]] internal slot of the Date prototype
object is the standard built-in Object prototype object (20.3.4).

Unless explicitly defined otherwise, the methods of the Date prototype
object defined below are not generic and the THIS value passed to them
must be an object that has a [[DateValue]] internal slot that has been
initialized to a time value.

The abstract operation thisTimeValue(_value_) performs the following
steps:

1.  If Type(_value)_ is Object and _value_ has a [[DateValue]] internal
    slot, then

    a.  Let _n_ be the value of _value’s_ [[DateValue]] internal slot.

    b.  If _n_ is not UNDEFINED, then return _n_.

2.  Throw a TYPEERROR exception.

In following descriptions of functions that are properties of the Date
prototype object, the phrase “this Date object” refers to the object
that is the THIS value for the invocation of the function. If the Type
of the THIS value is not Object, a TYPEERROR exception is thrown. The
phrase “this time value” within the specification of a method refers to
the result returned by calling the abstract operation thisTimeValue with
the THIS value of the method invocation passed as the argument.

Date.prototype.constructor

The initial value of DATE.PROTOTYPE.CONSTRUCTOR is the built-in DATE
constructor.

Date.prototype.getDate ( )

1.  Let _t_ be this time value.

2.  ReturnIfAbrupt(_t_).

3.  If _t_ is NAN, return NAN.

4.  Return DateFromTime(LocalTime(_t_)).

Date.prototype.getDay ( )

1.  Let _t_ be this time value.

2.  ReturnIfAbrupt(_t_).

3.  If _t_ is NAN, return NAN.

4.  Return WeekDay(LocalTime(_t_)).

Date.prototype.getFullYear ( )

1.  Let _t_ be this time value.

2.  ReturnIfAbrupt(_t_).

3.  If _t_ is NAN, return NAN.

4.  Return YearFromTime(LocalTime(_t_)).

Date.prototype.getHours ( )

1.  Let _t_ be this time value.

2.  ReturnIfAbrupt(_t_).

3.  If _t_ is NAN, return NAN.

4.  Return HourFromTime(LocalTime(_t_)).

Date.prototype.getMilliseconds ( )

1.  Let _t_ be this time value.

2.  ReturnIfAbrupt(_t_).

3.  If _t_ is NAN, return NAN.

4.  Return msFromTime(LocalTime(_t_)).

Date.prototype.getMinutes ( )

1.  Let _t_ be this time value.

2.  ReturnIfAbrupt(_t_).

3.  If _t_ is NAN, return NAN.

4.  Return MinFromTime(LocalTime(_t_)).

Date.prototype.getMonth ( )

1.  Let _t_ be this time value.

2.  ReturnIfAbrupt(_t_).

3.  If _t_ is NAN, return NAN.

4.  Return MonthFromTime(LocalTime(_t_)).

Date.prototype.getSeconds ( )

1.  Let _t_ be this time value.

2.  ReturnIfAbrupt(_t_).

3.  If _t_ is NAN, return NAN.

4.  Return SecFromTime(LocalTime(_t_)).

Date.prototype.getTime ( )

1.  Return this time value.

Date.prototype.getTimezoneOffset ( )

Returns the difference between local time and UTC time in minutes.

1.  Let _t_ be this time value.

2.  ReturnIfAbrupt(_t_).

3.  If _t_ is NAN, return NAN.

4.  Return (_t_ − LocalTime(_t_)) / msPerMinute.

Date.prototype.getUTCDate ( )

1.  Let _t_ be this time value.

2.  ReturnIfAbrupt(_t_).

3.  If _t_ is NAN, return NAN.

4.  Return DateFromTime(_t_).

Date.prototype.getUTCDay ( )

1.  Let _t_ be this time value.

2.  ReturnIfAbrupt(_t_).

3.  If _t_ is NAN, return NAN.

4.  Return WeekDay(_t_).

Date.prototype.getUTCFullYear ( )

1.  Let _t_ be this time value.

2.  ReturnIfAbrupt(_t_).

3.  If _t_ is NAN, return NAN.

4.  Return YearFromTime(_t_).

Date.prototype.getUTCHours ( )

1.  Let _t_ be this time value.

2.  ReturnIfAbrupt(_t_).

3.  If _t_ is NAN, return NAN.

4.  Return HourFromTime(_t_).

Date.prototype.getUTCMilliseconds ( )

1.  Let _t_ be this time value.

2.  ReturnIfAbrupt(_t_).

3.  If _t_ is NAN, return NAN.

4.  Return msFromTime(_t_).

Date.prototype.getUTCMinutes ( )

1.  Let _t_ be this time value.

2.  ReturnIfAbrupt(_t_).

3.  If _t_ is NAN, return NAN.

4.  Return MinFromTime(_t_).

Date.prototype.getUTCMonth ( )

1.  Let _t_ be this time value.

2.  ReturnIfAbrupt(_t_).

3.  If _t_ is NAN, return NAN.

4.  Return MonthFromTime(_t_).

Date.prototype.getUTCSeconds ( )

1.  Let _t_ be this time value.

2.  ReturnIfAbrupt(_t_).

3.  If _t_ is NAN, return NAN.

4.  Return SecFromTime(_t_).

Date.prototype.setDate ( date )

1.  Let _t_ be the result of LocalTime(this time value).

2.  Let _dt_ be ToNumber(_date_).

3.  ReturnIfAbrupt(_dt_).

4.  Let _newDate_ be MakeDate(MakeDay(YearFromTime(_t_),
    MonthFromTime(_t_), _dt_), TimeWithinDay(_t_)).

5.  Let _u_ be TimeClip(UTC(_newDate_)).

6.  Set the [[DateValue]] internal slot of this Date object to _u_.

7.  Return _u_.

Date.prototype.setFullYear ( year [ , month [ , date ] ] )

1.  Let _t_ be the result of LocalTime(this time value); but if this
    time value is NAN, let _t_ be +0.

2.  Let _y_ be ToNumber(_year_).

3.  ReturnIfAbrupt(_y_).

4.  If _month_ is not specified, then let _m_ be MonthFromTime(_t_);
    otherwise, let _m_ be ToNumber(_month_).

5.  ReturnIfAbrupt(_m_).

6.  If _date_ is not specified, then let _dt_ be DateFromTime(_t_);
    otherwise, let _dt_ be ToNumber(_date_).

7.  ReturnIfAbrupt(_dt_).

8.  Let _newDate_ be MakeDate(MakeDay(_y_, _m_, _dt_),
    TimeWithinDay(_t_)).

9.  Let _u_ be TimeClip(UTC(_newDate_)).

10. Set the [[DateValue]] internal slot of this Date object to _u_.

11. Return _u_.

The LENGTH property of the SETFULLYEAR method is 3.

NOTE If _month_ is not specified, this method behaves as if _month_ were
specified with the value GETMONTH(). If _date_ is not specified, it
behaves as if _date_ were specified with the value GETDATE().

Date.prototype.setHours ( hour [ , min [ , sec [ , ms ] ] ] )

1.  Let _t_ be the result of LocalTime(this time value).

2.  Let _h_ be ToNumber(_hour_).

3.  ReturnIfAbrupt(_h_).

4.  If _min_ is not specified, then let _m_ be MinFromTime(_t_);
    otherwise, let _m_ be ToNumber(_min_).

5.  ReturnIfAbrupt(_m_).

6.  If _sec_ is not specified, then let _s_ be SecFromTime(_t_);
    otherwise, let _s_ be ToNumber(_sec_).

7.  ReturnIfAbrupt(_s_).

8.  If _ms_ is not specified, then let _milli_ be msFromTime(_t_);
    otherwise, let _milli_ be ToNumber(_ms_).

9.  ReturnIfAbrupt(_milli_).

10. Let _date_ be MakeDate(Day(_t_), MakeTime(_h_, _m_, _s_, _milli_)).

11. Let _u_ be TimeClip(UTC(_date_)).

12. Set the [[DateValue]] internal slot of this Date object to _u_.

13. Return _u_.

The LENGTH property of the SETHOURS method is 4.

NOTE If _min_ is not specified, this method behaves as if _min_ were
specified with the value GETMINUTES(). If _sec_ is not specified, it
behaves as if _sec_ were specified with the value GETSECONDS(). If _ms_
is not specified, it behaves as if _ms_ were specified with the value
GETMILLISECONDS().

Date.prototype.setMilliseconds ( ms )

1.  Let _t_ be the result of LocalTime(this time value).

2.  Let _ms_ be ToNumber(_ms_).

3.  ReturnIfAbrupt(_ms_).

4.  Let _time_ be MakeTime(HourFromTime(_t_), MinFromTime(_t_),
    SecFromTime(_t_), _ms_).

5.  Let _u_ be TimeClip(UTC(MakeDate(Day(_t_), _time_))).

6.  Set the [[DateValue]] internal slot of this Date object to _u_.

7.  Return _u_.

Date.prototype.setMinutes ( min [ , sec [ , ms ] ] )

1.  Let _t_ be the result of LocalTime(this time value).

2.  Let _m_ be ToNumber(_min_).

3.  ReturnIfAbrupt(_m_).

4.  If _sec_ is not specified, then let _s_ be SecFromTime(_t_);
    otherwise, let _s_ be ToNumber(_sec_).

5.  ReturnIfAbrupt(_s_).

6.  If _ms_ is not specified, then let _milli_ be msFromTime(_t_);
    otherwise, let _milli_ be ToNumber(_ms_).

7.  ReturnIfAbrupt(_milli_).

8.  Let _date_ be MakeDate(Day(_t_), MakeTime(HourFromTime(_t_), _m_,
    _s_, _milli_)).

9.  Let _u_ be TimeClip(UTC(_date_)).

10. Set the [[DateValue]] internal slot of this Date object to _u_.

11. Return _u_.

The LENGTH property of the SETMINUTES method is 3.

NOTE If _sec_ is not specified, this method behaves as if _sec_ were
specified with the value GETSECONDS(). If _ms_ is not specified, this
behaves as if _ms_ were specified with the value GETMILLISECONDS().

Date.prototype.setMonth ( month [ , date ] )

1.  Let _t_ be the result of LocalTime(this time value).

2.  Let _m_ be ToNumber(_month_).

3.  ReturnIfAbrupt(_m_).

4.  If _date_ is not specified, then let _dt_ be DateFromTime(_t_);
    otherwise, let _dt_ be ToNumber(_date_).

5.  ReturnIfAbrupt(_dt_).

6.  Let _newDate_ be MakeDate(MakeDay(YearFromTime(_t_), _m_, _dt_),
    TimeWithinDay(_t_)).

7.  Let _u_ be TimeClip(UTC(_newDate_)).

8.  Set the [[DateValue]] internal slot of this Date object to _u_.

9.  Return _u_.

The LENGTH property of the SETMONTH method is 2.

NOTE If _date_ is not specified, this method behaves as if _date_ were
specified with the value GETDATE().

Date.prototype.setSeconds ( sec [ , ms ] )

1.  Let _t_ be the result of LocalTime(this time value).

2.  Let _s_ be ToNumber(_sec_).

3.  ReturnIfAbrupt(_s_).

4.  If _ms_ is not specified, then let _milli_ be msFromTime(_t_);
    otherwise, let _milli_ be ToNumber(_ms_).

5.  ReturnIfAbrupt(_milli_).

6.  Let _date_ be MakeDate(Day(_t_), MakeTime(HourFromTime(_t_),
    MinFromTime(_t_), _s_, _milli_)).

7.  Let _u_ be TimeClip(UTC(_date_)).

8.  Set the [[DateValue]] internal slot of this Date object to _u_.

9.  Return _u_.

The LENGTH property of the SETSECONDS method is 2.

NOTE If _ms_ is not specified, this method behaves as if _ms_ were
specified with the value GETMILLISECONDS().

Date.prototype.setTime ( time )

1.  Let _t_ be ToNumber(_time_).

2.  ReturnIfAbrupt(_t_).

3.  Let _v_ be TimeClip(_t_).

4.  5.  Set the [[DateValue]] internal slot of this Date object to _v_.

6.  Return _v_.

Date.prototype.setUTCDate ( date )

1.  Let _t_ be this time value.

2.  ReturnIfAbrupt(_t_).

3.  Let _dt_ be ToNumber(_date_).

4.  ReturnIfAbrupt(_dt_).

5.  Let _newDate_ be MakeDate(MakeDay(YearFromTime(_t_),
    MonthFromTime(_t_), _dt_), TimeWithinDay(_t_)).

6.  Let _v_ be TimeClip(_newDate_).

7.  Set the [[DateValue]] internal slot of this Date object to _v_.

8.  Return _v_.

Date.prototype.setUTCFullYear ( year [ , month [ , date ] ] )

1.  Let _t_ be this time value; but if this time value is NAN, let _t
    be +0.

2.  ReturnIfAbrupt(_t_).

3.  Let _y_ be ToNumber(_year_).

4.  ReturnIfAbrupt(_y_).

5.  If _month_ is not specified, then let _m_ be MonthFromTime(_t_);
    otherwise, let _m_ be ToNumber(_month_).

6.  ReturnIfAbrupt(_m_).

7.  If _date_ is not specified, then let _dt_ be DateFromTime(_t_);
    otherwise, let _dt_ be ToNumber(_date_).

8.  ReturnIfAbrupt(_dt_).

9.  Let _newDate_ be MakeDate(MakeDay(_y_, _m_, _dt_),
    TimeWithinDay(_t_)).

10. Let _v_ be TimeClip(_newDate_).

11. Set the [[DateValue]] internal slot of this Date object to _v_.

12. Return _v_.

The LENGTH property of the SETUTCFULLYEAR method is 3.

NOTE If _month_ is not specified, this method behaves as if _month_ were
specified with the value GETUTCMONTH(). If _date_ is not specified, it
behaves as if _date_ were specified with the value GETUTCDATE().

Date.prototype.setUTCHours ( hour [ , min [ , sec [ , ms ] ] ] )

1.  Let _t_ be this time value.

2.  ReturnIfAbrupt(_t_).

3.  Let _h_ be ToNumber(_hour_).

4.  ReturnIfAbrupt(_h_).

5.  If _min_ is not specified, then let _m_ be MinFromTime(_t_);
    otherwise, let _m_ be ToNumber(_min_).

6.  ReturnIfAbrupt(_m_).

7.  If _sec_ is not specified, then let _s_ be SecFromTime(_t_);
    otherwise, let _s_ be ToNumber(_sec_).

8.  ReturnIfAbrupt(_s_).

9.  If _ms_ is not specified, then let _milli_ be msFromTime(_t_);
    otherwise, let _milli_ be ToNumber(_ms_).

10. ReturnIfAbrupt(_milli_).

11. Let _newDate_ be MakeDate(Day(_t_), MakeTime(_h_, _m_, _s_,
    _milli_)).

12. Let _v_ be TimeClip(_newDate_).

13. Set the [[DateValue]] internal slot of this Date object to _v_.

14. Return _v_.

The LENGTH property of the SETUTCHOURS method is 4.

NOTE If _min_ is not specified, this method behaves as if _min_ were
specified with the value GETUTCMINUTES(). If _sec_ is not specified, it
behaves as if _sec_ were specified with the value GETUTCSECONDS(). If
_ms_ is not specified, it behaves as if _ms_ were specified with the
value GETUTCMILLISECONDS().

Date.prototype.setUTCMilliseconds ( ms )

1.  Let _t_ be this time value.

2.  ReturnIfAbrupt(_t_).

3.  Let _milli_ be ToNumber(_ms_).

4.  ReturnIfAbrupt(_milli_).

5.  Let _time_ be MakeTime(HourFromTime(_t_), MinFromTime(_t_),
    SecFromTime(_t_), _milli_).

6.  Let _v_ be TimeClip(MakeDate(Day(_t_), _time_)).

7.  Set the [[DateValue]] internal slot of this Date object to _v_.

8.  Return _v_.

Date.prototype.setUTCMinutes ( min [ , sec [, ms ] ] )

1.  Let _t_ be this time value.

2.  ReturnIfAbrupt(_t_).

3.  Let _m_ be ToNumber(_min_).

4.  If _sec_ is not specified, then let _s_ be SecFromTime(_t_);
    otherwise, let _s_ be ToNumber(_sec_).

5.  If _ms_ is not specified, then let _milli_ be msFromTime(_t_);
    otherwise, let _milli_ be ToNumber(_ms_).

6.  Let _date_ be MakeDate(Day(_t_), MakeTime(HourFromTime(_t_), _m_,
    _s_, _milli_)).

7.  Let _v_ be TimeClip(_date_).

8.  Set the [[DateValue]] internal slot of this Date object to _v_.

9.  Return _v_.

The LENGTH property of the SETUTCMINUTES method is 3.

NOTE If _sec_ is not specified, this method behaves as if _sec_ were
specified with the value GETUTCSECONDS(). If _ms_ is not specified, it
function behaves as if _ms_ were specified with the value return by
GETUTCMILLISECONDS().

Date.prototype.setUTCMonth ( month [ , date ] )

1.  Let _t_ be this time value.

2.  ReturnIfAbrupt(_t_).

3.  Let _m_ be ToNumber(_month_).

4.  If _date_ is not specified, then let _dt_ be DateFromTime(_t_);
    otherwise, let _dt_ be ToNumber(_date_).

5.  Let _newDate_ be MakeDate(MakeDay(YearFromTime(_t_), _m_, _dt_),
    TimeWithinDay(_t_)).

6.  Let _v_ be TimeClip(_newDate_).

7.  Set the [[DateValue]] internal slot of this Date object to _v_.

8.  Return _v_.

The LENGTH property of the SETUTCMONTH method is 2.

NOTE If _date_ is not specified, this method behaves as if _date_ were
specified with the value GETUTCDATE().

Date.prototype.setUTCSeconds ( sec [ , ms ] )

1.  Let _t_ be this time value.

2.  ReturnIfAbrupt(_t_).

3.  Let _s_ be ToNumber(_sec_).

4.  If _ms_ is not specified, then let _milli_ be msFromTime(_t_);
    otherwise, let _milli_ be ToNumber(_ms_).

5.  Let _date_ be MakeDate(Day(_t_), MakeTime(HourFromTime(_t_),
    MinFromTime(_t_), _s_, _milli_)).

6.  Let _v_ be TimeClip(_date_).

7.  Set the [[DateValue]] internal slot of this Date object to _v_.

8.  Return _v_.

The LENGTH property of the SETUTCSECONDS method is 2.

NOTE If _ms_ is not specified, this methold behaves as if _ms_ were
specified with the value GETUTCMILLISECONDS().

Date.prototype.toDateString ( )

This function returns a String value. The contents of the String are
implementation-dependent, but are intended to represent the “date”
portion of the Date in the current time zone in a convenient,
human-readable form.

Date.prototype.toISOString ( )

This function returns a String value representing the instance in time
corresponding to this time value. The format of the String is the Date
Time string format defined in 20.3.1.15. All fields are present in the
String. The time zone is always UTC, denoted by the suffix Z. If this
time value is not a finite Number or if the year is not a value that can
be represented in that format (if necessary using extended year format),
a RANGEERROR exception is thrown.

Date.prototype.toJSON ( key )

This function provides a String representation of a Date object for use
by JSON.STRINGIFY (24.3.2).

When the TOJSON method is called with argument _key_, the following
steps are taken:

1.  Let _O_ be the result of calling ToObject, giving it the THIS value
    as its argument.

2.  Let _tv_ be ToPrimitive(_O_, hint Number).

3.  ReturnIfAbrupt(_tv_).

4.  If Type(_tv_) is Number and _tv_ is not finite, return NULL.

5.  Return Invoke(_O_, "TOISOSTRING").

6.  7.  8.  

NOTE 1 The argument is ignored.

NOTE 2 The TOJSON function is intentionally generic; it does not require
that its THIS value be a Date object. Therefore, it can be transferred
to other kinds of objects for use as a method. However, it does require
that any such object have a TOISOSTRING method.

Date.prototype.toLocaleDateString ( [ reserved1 [ , reserved2 ] ] )

An ECMAScript implementation that includes the ECMA-402
Internationalization API must implement the
DATE.PROTOTYPE.TOLOCALEDATESTRING method as specified in the ECMA-402
specification. If an ECMAScript implementation does not include the
ECMA-402 API the following specification of the TOLOCALEDATESTRING
method is used.

This function returns a String value. The contents of the String are
implementation-dependent, but are intended to represent the “date”
portion of the Date in the current time zone in a convenient,
human-readable form that corresponds to the conventions of the host
environment’s current locale.

The meaning of the optional parameters to this method are defined in the
ECMA-402 specification; implementations that do not include ECMA-402
support must not use those parameter positions for anything else.

The LENGTH property of the TOLOCALEDATESTRING method is 0.

Date.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] )

An ECMAScript implementation that includes the ECMA-402
Internationalization API must implement the
DATE.PROTOTYPE.TOLOCALESTRING method as specified in the ECMA-402
specification. If an ECMAScript implementation does not include the
ECMA-402 API the following specification of the TOLOCALESTRING method is
used.

This function returns a String value. The contents of the String are
implementation-dependent, but are intended to represent the Date in the
current time zone in a convenient, human-readable form that corresponds
to the conventions of the host environment’s current locale.

The meaning of the optional parameters to this method are defined in the
ECMA-402 specification; implementations that do not include ECMA-402
support must not use those parameter positions for anything else.

The LENGTH property of the TOLOCALESTRING method is 0.

Date.prototype.toLocaleTimeString ( [ reserved1 [ , reserved2 ] ] )

An ECMAScript implementation that includes the ECMA-402
Internationalization API must implement the
DATE.PROTOTYPE.TOLOCALETIMESTRING method as specified in the ECMA-402
specification. If an ECMAScript implementation does not include the
ECMA-402 API the following specification of the TOLOCALESTRING method is
used.

This function returns a String value. The contents of the String are
implementation-dependent, but are intended to represent the “time”
portion of the Date in the current time zone in a convenient,
human-readable form that corresponds to the conventions of the host
environment’s current locale.

The meaning of the optional parameters to this method are defined in the
ECMA-402 specification; implementations that do not include ECMA-402
support must not use those parameter positions for anything else.

The LENGTH property of the TOLOCALETIMESTRING method is 0.

Date.prototype.toString ( )

The following steps are performed:

1.  Let _Q_ be this Date object.

2.  If Type(_O)_ is Object and _O_ does not have a [[DateValue]]
    internal slot, then

    a.  Let _tv_ be NaN.

3.  Else,

    a.  Let _tv_ be this time value.

4.  Return ToDateString(_tv)_.

NOTE For any Date object _d_ whose milliseconds amount is zero, the
result of Date.parse(_d_.toString()) is equal to _d_.valueOf(). See
20.3.3.2.

Runtime Semantics: ToDateString(tv) Abstract Operation

1.  Assert: Type(_tv_) is Number.

2.  If _tv_ is NaN, then return "INVALID DATE".

3.  Return an implementation-dependent String value that represents _tv
    as a date and time in the current time zone using a convenient,
    human-readable form.

Date.prototype.toTimeString ( )

This function returns a String value. The contents of the String are
implementation-dependent, but are intended to represent the “time”
portion of the Date in the current time zone in a convenient,
human-readable form.

 Date.prototype.toUTCString ( )

This function returns a String value. The contents of the String are
implementation-dependent, but are intended to represent this time value
in a convenient, human-readable form in UTC.

NOTE The intent is to produce a String representation of a date that is
more readable than the format specified in 20.3.1.15. It is not
essential that the chosen format be unambiguous or easily machine
parsable. If an implementation does not have a preferred human-readable
format it is recommended to use the format defined in 20.3.1.15 but with
a space rather than a “T” used to separate the date and time elements.

Date.prototype.valueOf ( )

The VALUEOF function returns a Number, which is this time value.

Date.prototype [ @@toPrimitive ] ( hint ) 

This function is called by ECMAScript language operators to convert an
object to a primitive value. The allowed values for _hint_ are
"DEFAULT", "NUMBER", and "STRING". Date objects, are unique among
built-in ECMAScript object in that they treat "DEFAULT" as being
equivalent to "STRING", All other built-in ECMAScript objects treat
"DEFAULT" as being equivalent to "NUMBER".

When the @@TOPRIMITIVE method is called with argument _hint_, the
following steps are taken:

1.  Let _O_ be the THIS value.

2.  If Type(_O_) is not Object, then throw a TYPEERROR exception.

3.  If _hint_ is the string value "STRING" or the string value "DEFAULT"
    , then

    a.  Let _tryFirst_ be "STRING".

4.  Else if _hint_ is the string value "NUMBER", then

    a.  Let _tryFirst_ be "NUMBER".

5.  Else, throw a TYPEERROR exception.

6.  Return the result of OrdinaryToPrimitive(_O_, _tryFirst_).

The value of the NAME property of this function is
"[SYMBOL.TOPRIMITIVE]".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Properties of Date Instances

Date instances are ordinary objects that inherit properties from the
Date prototype object. Date instances also have a [[DateValue]] internal
slot. The [[DateValue]] internal slot is the time value represented by
this Date object.



 TEXT PROCESSING 


String Objects

The String Constructor 

The String constructor is the %String% intrinsic object and the initial
value of the STRING property of the global object. When STRING is called
as a function rather than as a constructor, it performs a type
conversion. However, if the THIS value passed in the call is an Object
with an uninitialized [[StringData]] internal slot, it initializes the
THIS value using the argument value. This permits STRING to be used both
to perform type conversion and to perform constructor instance
initialization.

The STRING constructor is designed to be subclassable. It may be used as
the value of an EXTENDS clause of a class declaration. Subclass
constructors that intended to inherit the specified STRING behaviour
must include a SUPER call to the STRING constructor to initialize the
[[StringData]] state of subclass instances.

String ( value )

When STRING is called with argument _value_, the following steps are
taken:

1.  Let _O_ be the THIS value.

2.  If no arguments were passed to this function invocation, then let
    _s_ be "".

3.  Else, let _s_ be ToString(_value_).

4.  ReturnIfAbrupt(_s_).

5.  If Type(_O_) is Object and _O_ has a [[StringData]] internal slot
    and the value of [[StringData]] is UNDEFINED, then

    a.  Let _extensible_ be IsExtensible(_O_).

    b.  ReturnIfAbrupt(_extensible_).

    c.  If _extensible_ is FALSE, then throw a TYPEERROR exception.

    d.  Let _length_ be the number of code unit elements in _s._

    e.  Let _status_ be the result of DefinePropertyOrThrow(_O_,
        "LENGTH", PropertyDescriptor{[[Value]]: _length_, [[Writable]]:
        FALSE, [[Enumerable]]: FALSE, [[Configurable]]: FALSE }).

    f.  ReturnIfAbrupt(_status_).

    g.  Set the value of _O’s_ [[StringData]] internal slot to _s_.

    h.  Return _O_.

6.  Return _s_.

The LENGTH property of the STRING function is 1.

new String ( ...argumentsList )

When STRING is called as part of a new expression , it initializes a
newly created exotic String object:

1.  Let _F_ be the STRING function object on which the NEW operator was
    applied.

2.  Let _argumentsList_ be the _argumentsList_ argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of Construct (_F_, _argumentsList_).

If STRING is implemented as an ECMAScript function object, its
[[Construct]] internal method will perform the above steps.

Properties of the String Constructor

The value of the [[Prototype]] internal slot of the String constructor
is the standard built-in Function prototype object (19.2.3).

Besides the LENGTH property (whose value is 1), the String constructor
has the following properties:

String.fromCharCode ( ...codeUnits )

The STRING.FROMCHARCODE function may be called with any number of
arguments which form the rest parameter _codeUnits_. The following steps
are taken:

1.  Let _codeUnits_ is be a List containing the arguments passed to this
    function.

2.  Let _length_ be the number of elements in _codeUnits_.

3.  Let _elements_ be a new List.

4.  Let _nextIndex_ be 0.

5.  Repeat while _nextIndex_ < _length

    a.  Let _next_ be _codeUnits_[_nextIndex_].

    b.  Let _nextCU_ be ToUint16(_next_).

    c.  ReturnIfAbrupt(_nextCU_).

    d.  Append _nextCU_ to the end of _elements_.

    e.  Let _nextIndex_ be _nextIndex_ + 1.

6.  Return the String value whose elements are, in order, the elements
    in the List _elements_. If _length_ is 0, the empty string is
    returned.

The LENGTH property of the FROMCHARCODE function is 1.

String.fromCodePoint ( ...codePoints )

The STRING.FROMCODEPOINT function may be called with any number of
arguments which form the rest parameter _codePoints_. The following
steps are taken:

1.  Let _codePoints_ be a List containing the arguments passed to this
    function.

2.  Let _length_ be number of elements in _codePoints_.

3.  Let _elements_ be a new List.

4.  Let _nextIndex_ be 0.

5.  Repeat while _nextIndex_ < _length

    a.  Let _next_ be _codePoints_[_nextIndex_].

    b.  Let _nextCP_ be ToNumber(_next_).

    c.  ReturnIfAbrupt(_nextCP_).

    d.  If SameValue(_nextCP_, ToInteger(_nextCP_)) is FALSE, then throw
        a RANGEERROR exception.

    e.  If _nextCP_ < 0 or _nextCP_ > 0x10FFFF, then throw a RANGEERROR
        exception.

    f.  Append the elements of the UTF-16Encoding (10.1.1) of _nextCP_
        to the end of _elements_.

    g.  Let _nextIndex_ be _nextIndex_ + 1.

6.  Return the String value whose elements are, in order, the elements
    in the List _elements_. If _length_ is 0, the empty string is
    returned.

The LENGTH property of the FROMCODEPOINT function is 1.

String.prototype

The initial value of STRING.PROTOTYPE is the standard built-in String
prototype object (21.1.3).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

String.raw ( callSite , ...substitutions )

The STRING.RAW function may be called with a variable number of
arguments. The first argument is _callSite_ and the remainder of the
arguments form the List _substitutions_. The following steps are taken:

1.  Let _substitutions_ be a List consisting of all of the arguments
    passed to this function, starting with the second argument. If fewer
    than two arguments were passed, the List is empty.

2.  Let _numberOfSubstitutions_ be the number of elements in
    _substitutions_.

3.  Let _cooked_ be ToObject(_callSite_).

4.  ReturnIfAbrupt(_cooked_).

5.  Let _rawValue_ be the result of Get(_cooked_, "RAW").

6.  Let _raw_ be ToObject(_rawValue_).

7.  ReturnIfAbrupt(_raw_).

8.  Let _len_ be the result of Get(_raw_, "LENGTH").

9.  Let _literalSegments_ be ToLength(_len_).

10. ReturnIfAbrupt(_literalSegments_).

11. If _literalSegments_ ≤ 0, then return the empty string.

12. Let _stringElements_ be a new List.

13. Let _nextIndex_ be 0.

14. Repeat

    a.  Let _nextKey_ be ToString(_nextIndex_).

    b.  Let _next_ be the result of Get(_raw_, _nextKey_).

    c.  Let _nextSeg_ be ToString(_next_).

    d.  ReturnIfAbrupt(_nextSeg_).

    e.  Append in order the code unit elements of _nextSeg_ to the end
        of _stringElements_.

    f.  If _nextIndex_ + 1 = _literalSegments_, then

        i.  Return the string value whose elements are, in order, the
            elements in the List _stringElements_. If _stringElements_
            has no elements, the empty string is returned.

    g.  If _nextIndex<_ _numberOfSubstitutions_, then let _next_ be
        _substitutions_[_nextIndex_].

    h.  Else, let _next_ is the empty String.

    i.  Let _nextSub_ be ToString(_next_).

    j.  ReturnIfAbrupt(_nextSub_).

    k.  Append in order the code unit elements of _nextSub_ to the end
        of _stringElements_.

    l.  Let _nextIndex_ be _nextIndex_ + 1.

The LENGTH property of the RAW function is 1.

NOTE String.raw is intended for use as a tag function of a Tagged
Template String (12.3.7). When called as such the first argument will be
a well formed template call site object and the rest parameter will
contain the substitution values.

String[ @@create ] ( )

The @@create method of an object _F_ performs the following steps:

1.  Let _F_ be the THIS value.

2.  Let _proto_ be the result of GetPrototypeFromConstructor(_F_,
    "%STRINGPROTOTYPE%").

3.  ReturnIfAbrupt(_proto_).

4.  Let _obj_ be the result of calling StringCreate (_proto_).

5.  Return _obj_.

The value of the NAME property of this function is "[SYMBOL.CREATE]".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

NOTE [[StringData]] is initially assigned the value UNDEFINED as a flag
to indicate that the instance has not yet been initialized by the String
constructor. This flag value is never directly exposed to ECMAScript
code; hence implementations may choose to encode the flag in some other
manner.

Properties of the String Prototype Object

The String prototype object is itself an ordinary object. It is not a
String instance and does not have a [[StringData]] internal slot.

The value of the [[Prototype]] internal slot of the String prototype
object is the standard built-in Object prototype object (19.1.3).

Unless explicitly stated otherwise, the methods of the String prototype
object defined below are not generic and the THIS value passed to them
must be either a String value or an object that has a [[StringData]]
internal slot that has been initialized to a String value.

The abstract operation thisStringValue(_value_) performs the following
steps:

1.  If Type(_value_) is String, return _value_.

2.  If Type(_value)_ is Object and _value_ has a [[StringData]] internal
    slot, then

    a.  Let _s_ be the value of _value’s_ [[StringData]] internal slot.

    b.  If _s_ is not UNDEFINED, then return _s_.

3.  Throw a TYPEERROR exception.

The phrase “this String value” within the specification of a method
refers to the result returned by calling the abstract operation
thisStringValue with the THIS value of the method invocation passed as
the argument.

String.prototype.charAt ( pos )

NOTE Returns a single element String containing the code unit at element
position _pos_ in the String value resulting from converting this object
to a String. If there is no element at that position, the result is the
empty String. The result is a String value, not a String object.

If _pos_ is a value of Number type that is an integer, then the result
of X.CHARAT(_pos_) is equal to the result of X.SUBSTRING(_pos_,
_pos_+1).

When the CHARAT method is called with one argument _pos_, the following
steps are taken:

1.  Let _O_ be CheckObjectCoercible(THIS value).

2.  Let _S_ be ToString(_O_).

3.  ReturnIfAbrupt(_S_).

4.  Let _position_ be ToInteger(_pos_).

5.  ReturnIfAbrupt(_position_).

6.  Let _size_ be the number of elements in _S_.

7.  If _position_ < 0 or _position_ ≥ _size_, return the empty String.

8.  Return a String of length 1, containing one code unit from _S_,
    namely the code unit at position _position_, where the first
    (leftmost) code unit in _S_ is considered to be at position 0, the
    next one at position 1, and so on.

NOTE The CHARAT function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

String.prototype.charCodeAt ( pos )

NOTE Returns a Number (a nonnegative integer less than 2^16^) that is
the code unit value of the string element at position _pos_ in the
String resulting from converting this object to a String. If there is no
element at that position, the result is NAN.

When the CHARCODEAT method is called with one argument _pos_, the
following steps are taken:

1.  Let _O_ be CheckObjectCoercible(THIS value).

2.  Let _S_ be ToString(_O_).

3.  ReturnIfAbrupt(_S_).

4.  Let _position_ be ToInteger(_pos_).

5.  ReturnIfAbrupt(_position_).

6.  Let _size_ be the number of elements in _S_.

7.  If _position_ < 0 or _position_ ≥ _size_, return NAN.

8.  Return a value of Number type, whose value is the code unit value of
    the element at position _position_ in the String _S_, where the
    first (leftmost) element in _S_ is considered to be at position 0,
    the next one at position 1, and so on.

NOTE The CHARCODEAT function is intentionally generic; it does not
require that its THIS value be a String object. Therefore it can be
transferred to other kinds of objects for use as a method.

String.prototype.codePointAt ( pos )

NOTE Returns a nonnegative integer Number less than 1114112 (0x110000)
that is the UTF-16 encoded code point value starting at the string
element at position _pos_ in the String resulting from converting this
object to a String. If there is no element at that position, the result
is UNDEFINED. If a valid UTF-16 surrogate pair does not begin at _pos_,
the result is the code unit at _pos_.

When the CODEPOINTAT method is called with one argument _pos_, the
following steps are taken:

1.  Let _O_ be CheckObjectCoercible(THIS value).

2.  Let _S_ be ToString(_O_).

3.  ReturnIfAbrupt(_S_).

4.  Let _position_ be ToInteger(_pos_).

5.  ReturnIfAbrupt(_position_).

6.  Let _size_ be the number of elements in _S_.

7.  If _position_ < 0 or _position_ ≥ _size_, return UNDEFINED.

8.  Let _first_ be the code unit value of the element at index
    _position_ in the String _S_.

9.  If _first_ < 0xD800 or _first_ > 0xDBFF or _position_+1 = _size_,
    then return _first_.

10. Let _second_ be the code unit value of the element at index
    _position_+1 in the String _S_.

11. If _second_ < 0xDC00 or _second_ > 0xDFFF, then return _first_.

12. Return ((_first_ – 0xD800) × 1024) + (_second_ – 0xDC00) + 0x10000.

NOTE The CODEPOINTAT function is intentionally generic; it does not
require that its THIS value be a String object. Therefore it can be
transferred to other kinds of objects for use as a method.

String.prototype.concat ( ...args )

NOTE When the CONCAT method is called it returns a String consisting of
the string elements of this object (converted to a String) followed by
the string elements of each of the arguments converted to a String. The
result is a String value, not a String object.

When the CONCAT method is called with zero or more arguments the
following steps are taken:

1.  2.  Let _O_ be CheckObjectCoercible(THIS value).

3.  Let _S_ be ToString(_O_).

4.  ReturnIfAbrupt(_S_).

5.  Let _args_ be a List whose elements are the arguments passed to this
    function.

6.  Let _R_ be _S_.

7.  Repeat, while _args_ is not empty

    a.  Remove the first element from _args_ and let _next_ be the value
        of that element.

    b.  Let _nextString_ be ToString(_next_)

    c.  ReturnIfAbrupt(_nextString_).

    d.  Let _R_ be the String value consisting of the string elements in
        the previous value of _R_ followed by the string elements of
        _nextString_.

8.  Return _R_.

The LENGTH property of the CONCAT method is 1.

NOTE The CONCAT function is intentionally generic; it does not require
that its THIS value be a String object. Therefore it can be transferred
to other kinds of objects for use as a method.

String.prototype.constructor

The initial value of STRING.PROTOTYPE.CONSTRUCTOR is the built-in STRING
constructor.

String.prototype.contains ( searchString [ , position ] )

The CONTAINS method takes two arguments, _searchString_ and _position_,
and performs the following steps:

1.  Let _O_ be CheckObjectCoercible(THIS value).

2.  Let _S_ be ToString(_O_).

3.  ReturnIfAbrupt(_S_).

4.  If Type(_searchString_) is Object, then

    a.  Let _isRegExp_ be HasProperty(_searchString_, @@isRegExp).

    b.  If _isRegExp_ is TRUE, then throw a TYPEERROR exception.

5.  Let _searchStr_ be ToString(_searchString_).

6.  ReturnIfAbrupt(_searchStr_).

7.  Let _pos_ be ToInteger(_position_). (If _position_ is UNDEFINED,
    this step produces the value 0).

8.  ReturnIfAbrupt(_pos_).

9.  Let _len_ be the number of elements in _S_.

10. Let _start_ be min(max(_pos_, 0), _len_).

11. Let _searchLen_ be the number of elements in _searchStr_.

12. If there exists any integer _k_ not smaller than _start_ such that
    _k_ + _searchLen_ is not greater than _len_, and for all nonnegative
    integers _j_ less than _searchLen_, the code unit at position
    _k_+_j_ of _S_ is the same as the code unit at position _j_ of
    _searchStr,_ return TRUE; but if there is no such integer _k_,
    return FALSE.

The LENGTH property of the CONTAINS method is 1.

NOTE 1 If _searchString_ appears as a substring of the result of
converting this object to a String, at one or more positions that are
greater than or equal to _position_, then return TRUE; otherwise,
returns FALSE. If _position_ is UNDEFINED, 0 is assumed, so as to search
all of the String.

NOTE 2 Throwing an exception if the first argument is a RegExp is
specified in order to allow future editions to define extensions that
allow such argument values.

NOTE 3 The CONTAINS function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

String.prototype.endsWith ( searchString [ , endPosition] )

The following steps are taken:

1.  Let _O_ be CheckObjectCoercible(THIS value).

2.  Let _S_ be ToString(_O_).

3.  ReturnIfAbrupt(_S_).

4.  If Type(_searchString_) is Object, then

    a.  Let _isRegExp_ be HasProperty(_searchString_, @@isRegExp).

    b.  If _isRegExp_ is TRUE, then throw a TYPEERROR exception.

5.  Let _searchStr_ be ToString(_searchString_).

6.  ReturnIfAbrupt(_searchStr_).

7.  Let _len_ be the number of elements in _S_.

8.  If _endPosition_ is UNDEFINED, let _pos_ be _len_, else let _pos_ be
    ToInteger(_endPosition_).

9.  ReturnIfAbrupt(_pos_).

10. Let _end_ be min(max(_pos_, 0), _len_).

11. Let _searchLength_ be the number of elements in _searchStr_.

12. Let _start_ be _end_ - _searchLength_.

13. If _start_ is less than 0, return FALSE_.

14. If the _searchLength_ sequence of elements of _S_ starting at
    _start_ is the same as the full element sequence of _searchStr_,
    return TRUE.

15. Otherwise, return FALSE.

The LENGTH property of the ENDSWITH method is 1.

NOTE 1 Returns TRUE if the sequence of elements of _searchString_
converted to a String is the same as the corresponding elements of this
object (converted to a String) starting at _endPosition_ – length(this).
Otherwise returns FALSE.

NOTE 2 Throwing an exception if the first argument is a RegExp is
specified in order to allow future editions to define extends that allow
such argument values.

NOTE 3 The ENDSWITH function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

String.prototype.indexOf ( searchString [ , position ] )

NOTE If _searchString_ appears as a substring of the result of
converting this object to a String, at one or more positions that are
greater than or equal to _position_, then the index of the smallest such
position is returned; otherwise, 1 is returned. If _position_ is
UNDEFINED, 0 is assumed, so as to search all of the String.

The INDEXOF method takes two arguments, _searchString_ and _position_,
and performs the following steps:

1.  Let _O_ be CheckObjectCoercible(THIS value).

2.  Let _S_ be ToString(_O_).

3.  ReturnIfAbrupt(_S_).

4.  Let _searchStr_ be ToString(_searchString_).

5.  ReturnIfAbrupt(_searchString_).

6.  Let _pos_ be ToInteger(_position_). (If _position_ is UNDEFINED,
    this step produces the value 0).

7.  ReturnIfAbrupt(_pos_).

8.  Let _len_ be the number of elements in _S_.

9.  Let _start_ be min(max(_pos_, 0), _len_).

10. Let _searchLen_ be the number of elements in _searchStr_.

11. Return the smallest possible integer _k_ not smaller than _start
    such that _k_+ _searchLen_ is not greater than _len_, and for all
    nonnegative integers _j_ less than _searchLen_, the code unit at
    position _k_+_j_ of _S_ is the same as the code unit at position _j_
    of _searchStr_; but if there is no such integer _k_, then return the
    value -1.

The LENGTH property of the INDEXOF method is 1.

NOTE The INDEXOF function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

String.prototype.lastIndexOf ( searchString [ , position ] )

NOTE If _searchString_ appears as a substring of the result of
converting this object to a String at one or more positions that are
smaller than or equal to _position_, then the index of the greatest such
position is returned; otherwise, 1 is returned. If _position_ is
UNDEFINED, the length of the String value is assumed, so as to search
all of the String.

The LASTINDEXOF method takes two arguments, _searchString_ and
_position_, and performs the following steps:

1.  Let _O_ be CheckObjectCoercible(THIS value).

2.  Let _S_ be ToString(_O_).

3.  ReturnIfAbrupt(_S_).

4.  Let _searchStr_ be ToString(_searchString_).

5.  ReturnIfAbrupt(_searchString_).

6.  Let _numPos_ be ToNumber(_position_). (If _position_ is UNDEFINED,
    this step produces the value NAN).

7.  ReturnIfAbrupt(_numPos_).

8.  If _numPos_ is NAN, let _pos_ be +∞; otherwise, let _pos_ be
    ToInteger(_numPos_).

9.  Let _len_ be the number of elements in _S_.

10. Let _start_ be min(max(_pos_, 0), _len_).

11. Let _searchLen_ be the number of elements in _searchStr_.

12. Return the largest possible nonnegative integer _k_ not larger than
    _start_ such that _k_+ _searchLen_ is not greater than _len_, and
    for all nonnegative integers _j_ less than _searchLen_, the code
    unit at position _k_+_j_ of _S_ is the same as the code unit at
    position _j_ of _searchStr_; but if there is no such integer _k_,
    then return the value -1.

The LENGTH property of the LASTINDEXOF method is 1.

NOTE The LASTINDEXOF function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

String.prototype.localeCompare ( that [, reserved1 [ , reserved2 ] ] )

An ECMAScript implementation that includes the ECMA-402
Internationalization API must implement the LOCALECOMPARE method as
specified in the ECMA-402 specification. If an ECMAScript implementation
does not include the ECMA-402 API the following specification of the
LOCALECOMPARE method is used.

When the LOCALECOMPARE method is called with argument _that_, it returns
a Number other than NAN that represents the result of a locale-sensitive
String comparison of the THIS value (converted to a String) with _that_
(converted to a String). The two Strings are _S_ and _That_. The two
Strings are compared in an implementation-defined fashion. The result is
intended to order String values in the sort order specified by the
system default locale, and will be negative, zero, or positive,
depending on whether _S_ comes before _That_ in the sort order, the
Strings are equal, or _S_ comes after _That_ in the sort order,
respectively.

Before perform the comparisons the following steps are performed to
prepare the Strings:

1.  Let _O_ be CheckObjectCoercible(THIS value).

2.  Let _S_ be ToString(_O_).

3.  ReturnIfAbrupt(_S_).

4.  Let _That_ be ToString(_that_).

5.  ReturnIfAbrupt(_That_).

The meaning of the optional second and third parameters to this method
are defined in the ECMA-402 specification; implementations that do not
include ECMA-402 support must not assign any other interpretation to
those parameter positions.

The LOCALECOMPARE method, if considered as a function of two arguments
THIS and _that_, is a consistent comparison function (as defined in
22.1.3.24) on the set of all Strings.

The actual return values are implementation-defined to permit
implementers to encode additional information in the value, but the
function is required to define a total ordering on all Strings. If the
implementation performs language-sensitive comparisions it must return 0
when comparing Strings that are considered canonically equivalent by the
Unicode standard.

If no language-sensitive comparison at all is available from the host
environment, this function may perform a bitwise comparison.

The LENGTH property of the LOCALECOMPARE method is 1.

NOTE 1 The LOCALECOMPARE method itself is not directly suitable as an
argument to ARRAY.PROTOTYPE.SORT because the latter requires a function
of two arguments.

NOTE 2 This function is intended to rely on whatever language-sensitive
comparison functionality is available to the ECMAScript environment from
the host environment, and to compare according to the rules of the host
environment’s current locale. This function must treat Strings that are
canonically equivalent according to the Unicode standard as identical.
It is also recommended that this function not honour Unicode
compatibility equivalences or decompositions. For a definition and
discussion of canonical equivalence see the Unicode Standard, chapters 2
and 3, as well as Unicode Annex #15, Unicode Normalization Forms and
Unicode Technical Note #5 Canonical Equivalence in Applications. Also
see Unicode Technical Stardard #10, Unicode Collation Algorithm.

NOTE 3 The LOCALECOMPARE function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

String.prototype.match ( regexp )

When the MATCH method is called with argument _regexp_, the following
steps are taken:

1.  Let _O_ be CheckObjectCoercible(THIS value).

2.  Let _S_ be ToString(_O_).

3.  ReturnIfAbrupt(_S_).

4.  If Type(_regexp_) is Object and HasProperty(_regexp_, @@isRegExp) is
    TRUE, then let _rx_ be _regexp_;

5.  Else, let _rx_ be the result of the abstract operation RegExpCreate
    (21.2.3.3) with arguments _regexp_ and UNDEFINED.

6.  ReturnIfAbrupt(_rx_).

7.  Return the result of Invoke(_rx_, "MATCH", ( _S_ )). _.

NOTE The MATCH function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

String.prototype.normalize ( [ form ] )

When the NORMALIZE method is called with one argument _form_, the
following steps are taken:

1.  Let _O_ be CheckObjectCoercible(THIS value).

2.  Let _S_ be ToString(_O_).

3.  ReturnIfAbrupt(_S_).

4.  If _form_ is not provided or _form_ is UNDEFINED let _form_ be
    "NFC".

5.  Let _f_ be ToString(_form_).

6.  ReturnIfAbrupt(_f_).

7.  If _f_ is not one of "NFC", "NFD", "NFKC", or "NFKD", then throw a
    RANGEERROR Exception.

8.  Let _ns_ be the String value is the result of normalizing _S_ into
    the normalization form named by _f_ as specified in __Unicode
    Standard Annex #15, Unicode__ __Normalization Forms__.

9.  Return _ns_.

The LENGTH property of the NORMALIZE method is 0.

NOTE The NORMALIZE function is intentionally generic; it does not
require that its THIS value be a String object. Therefore it can be
transferred to other kinds of objects for use as a method.

String.prototype.repeat ( count )

The following steps are taken:

1.  Let _O_ be CheckObjectCoercible(THIS value).

2.  Let _S_ be ToString(_O_).

3.  ReturnIfAbrupt(_S_).

4.  Let _n_ be the result of calling ToInteger(_count_).

5.  ReturnIfAbrupt(_n_).

6.  If _n_ < 0, then throw a RANGEERROR exception.

7.  If _n_ is +∞, then throw a RANGEERROR exception.

8.  Let _T_ be a String value that is made from _n_ copies of _S
    appended together. If _n_ is 0, _T_ is the empty String.

9.  Return _T_.

NOTE 1 This method creates a String consisting of the string elements of
this object (converted to String) repeated _count_ times.

NOTE 2 The REPEAT function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

String.prototype.replace (searchValue, replaceValue )

When the REPLACE method is called with arguments _searchValue_ and
_replaceValue_ the following steps are taken:

1.  Let _O_ be CheckObjectCoercible(THIS value).

2.  Let _string_ be ToString(_O_).

3.  ReturnIfAbrupt(_string_).

4.  If Type(_searchValue_) is Object and HasProperty(_searchValue_,
    @@isRegExp) is TRUE, then

    a.  Return Invoke(_searchValue_, "REPLACE", (_string_,
        _replaceValue_)).

5.  Let _searchString_ be ToString(_searchValue_).

6.  ReturnIfAbrupt(_searchString_).

7.  Let _functionalReplace_ be IsCallable(_replaceValue_).

8.  If _functionReplace_ is FALSE, then

    a.  Let _replaceValue_ be ToString(_replaceValue_).

    b.  ReturnIfAbrupt(_replaceValue_).

9.  Search _string_ for the first occurrence of _searchString_ and let
    _pos_ be the index position within _string_ of the first code unit
    of the matched substring and let _matched_ be _searchString_. If no
    occurrences of _searchString_ were found, return _string_.

10. If _functionalReplace_ is TRUE, then

    a.  Let _replValue_ be the result of calling the [[Call]] internal
        method of _replaceValue_ passing UNDEFINED as the THIS value and
        a List containing _matched_, _pos_, and _string_ as the argument
        list.

    b.  Let _replStr_ be ToString(_replValue_).

    c.  ReturnIfAbrupt(_replStr_).

11. Else,

    a.  Let _captures_ be an empty List.

    b.  c.  d.  Let _replStr_ be GetReplaceSubstitution(_matched_,
        _string_, _pos_, _captures_, _replaceValue_).

12. Let _tailPos_ be _pos_ + the number of code units in _matched_.

13. Let _newString_ be the String formed by concatenating the first
    _pos_ code units of _string_, _replStr_, and the trailing substring
    of _string_ starting at index _tailPos_. If _pos_ is 0, the first
    element of the concatenation will be the empty String.

14. Return _newString_.

NOTE The REPLACE function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

Runtime Semantics: GetReplaceSubstitution Abstract Operation

The abstract operation GetReplaceSubstitution(_matched_, _string_,
_position_, _captures_, _replacement_) performs the following steps:

1.  Assert: Type(_matched_) is String.

2.  Let _matchLength_ be the number of code units in _matched_.

3.  Assert: Type(_string_) is String.

4.  Let _stringLength_ be the number of code units in _string_.

5.  Assert: _position_ is a nonnegative integer.

6.  Assert: _position_ ≤ _stringLength_.

7.  Assert: _captures_ is a possibly empty List of Strings.

8.  Assert:Type( _replacement_) is String

9.  Let _tailPos_ be _position_ + _matchLength_.

10. Let _m_ be the number of elements in _captures_.

11. Let _result_ be a String value derived from _replacement_ by copying
    code unit elements from _replacement_ to _result_ while performing
    replacements as specified in Table 41. These $ replacements are done
    left-to-right, and, once such a replacement is performed, the new
    replacement text is not subject to further replacements.

12. Return _result_.

Table 41 — Replacement Text Symbol Substitutions

  --------------------- ------------------------------------------------------------------------- ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  Code units            Unicode Characters                                                        Replacement text

  0x0024, 0x0024        $$                                                                        $

  0x0024, 0x0026        $&                                                                        _matched_

  0x0024, 0x0060        $`                                                                        If _position_ is 0, the replacement is the empty String. Otherwise the replacement is the substring of _string_ that starts at index 0 and whose last code point is at index _position_ -1.

  0x0024, 0x0027        $'                                                                        If _tailPos_ ≥ _stringLength_, the replacement is the empty String. Otherwise the replacement is the substring of _string_ that starts at index _tailPos_ and continues to the end of _string_.

  0x0024, N where       $N where                                                                  The _n_^th^ element of _captures_, where _n_ is a single digit in the range 1 to 9. If _n_≤_m_ and the _n_th element of _captures_ is UNDEFINED, use the empty String instead. If _n_>_m_, the result is implementation-defined.
  0x0031 ≤ N ≤ 0x0039   N is one of 1 2 3 4 5 6 7 8 9 and $N is not followed by a decimal digit   

  0x0024, N, N where    $NN where                                                                 The _nn_^th^ element of _captures_, where _nn_ is a two-digit decimal number in the range 01 to 99. If _nn_≤_m_ and the _nn_^th^ element of _captures_ is UNDEFINED, use the empty String instead. If _nn_ is 00 or _nn_>_m_, the result is implementation-defined.
  0x0030 ≤ N ≤ 0x0039   N is one of 0 1 2 3 4 5 6 7 8 9                                           

  0x0024                $ in any context that does not match any of the above.                    $
  --------------------- ------------------------------------------------------------------------- ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

String.prototype.search ( regexp )

When the search method is called with argument _regexp_, the following
steps are taken:

1.  Let _O_ be CheckObjectCoercible(THIS value).

2.  Let _string_ be ToString(_O_).

3.  ReturnIfAbrupt(_string_).

4.  If Type(_regexp_) is Object and HasProperty(_regexp_, @@isRegExp) is
    TRUE , then,

    a.  Let _rx_ be _regexp_;

5.  Else,

    a.  Let _rx_ be the result of the abstract operation RegExpCreate
        (21.2.3.3) with arguments _regexp_ and UNDEFINED.

6.  ReturnIfAbrupt(_rx_).

7.  Return the result of Invoke(_rx_, "SEARCH", (_string_)).

NOTE The SEARCH function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

String.prototype.slice ( start, end )

The SLICE method takes two arguments, _start_ and _end_, and returns a
substring of the result of converting this object to a String, starting
from element position _start_ and running to, but not including, element
position _end_ (or through the end of the String if _end_ is UNDEFINED).
If _start_ is negative, it is treated as _sourceLength_+_start_ where
_sourceLength_ is the length of the String. If _end_ is negative, it is
treated as _sourceLength_+_end_ where _sourceLength_ is the length of
the String. The result is a String value, not a String object. The
following steps are taken:

1.  Let _O_ be CheckObjectCoercible(THIS value).

2.  Let _S_ be ToString(_O_).

3.  ReturnIfAbrupt(_S_).

4.  Let _len_ be the number of elements in _S_.

5.  Let _intStart_ be ToInteger(_start_).

6.  If _end_ is UNDEFINED, let _intEnd_ be _len_; else let _intEnd_ be
    ToInteger(_end_).

7.  If _intStart_ is negative, let _from_ be max(_len_ + _intStart_,0);
    else let _from_ be min(_intStart_, _len_).

8.  If _intEnd_ is negative, let _to_ be max(_len_ + _intEnd_,0); else
    let _to_ be min(_intEnd_, _len_).

9.  Let _span_ be max(_to_ – _from_,0).

10. Return a String value containing _span_ consecutive elements from
    _S_ beginning with the element at position _from_.

The LENGTH property of the SLICE method is 2.

NOTE The SLICE function is intentionally generic; it does not require
that its THIS value be a String object. Therefore it can be transferred
to other kinds of objects for use as a method.

String.prototype.split ( separator, limit )

Returns an Array object into which substrings of the result of
converting this object to a String have been stored. The substrings are
determined by searching from left to right for occurrences of
_separator_; these occurrences are not part of any substring in the
returned array, but serve to divide up the String value. The value of
_separator_ may be a String of any length or it may be a RegExp object.

When the SPLIT method is called, the following steps are taken:

1.  Let _O_ be CheckObjectCoercible(THIS value).

2.  ReturnIfAbrupt(_O_).

3.  If Type(_separator_) is Object and HasProperty(_separator_,
    @@isRegExp) is TRUE , then,

    a.  Return the result of Invoke(_separator_, "SPLIT", (_O_,
        _limit_))

4.  Let _S_ be ToString(_O_).

5.  ReturnIfAbrupt(_S_).

6.  Let _A_ be the result of the abstract operation ArrayCreate with
    argument 0.

7.  Let _lengthA_ be 0.

8.  If _limit_ is UNDEFINED, let _lim_ = 2^53^–1; else let _lim_ =
    ToLength(_limit_).

9.  Let _s_ be the number of elements in _S_.

10. Let _p_ = 0.

11. Let _R_ be ToString(_separator_).

12. ReturnIfAbrupt(_R_).

13. If _lim_ = 0, return _A_.

14. If _separator_ is UNDEFINED, then

    a.  Call CreateDataProperty(_A_, "0", _S_).

    b.  Assert: The above call will never result in an abrupt
        completion.

    c.  Return _A_.

15. If _s_ = 0, then

    a.  Let _z_ be the result of SplitMatch(_S_, 0, _R_).

    b.  If _z_ is not FALSE, return _A_.

    c.  Call CreateDataProperty(_A_, "0", _S_).

    d.  Assert: The above call will never result in an abrupt
        completion.

    e.  Return _A_.

16. Let _q_ = _p_.

17. Repeat, while _q_ ≠ _s

    a.  Let _e_ be the result of SplitMatch(_S, q, R_).

    b.  If _e_ is FALSE, then let _q_ = _q_+1.

    c.  Else _e_ is an integer index into _S_,

        i.  If _e_ = _p_, then let _q_ = _q_+1.

        ii. Else _e_ ≠ _p_,

            1.  Let _T_ be a String value equal to the substring of _S_
                consisting of the code units at positions _p_
                (inclusive) through _q_ (exclusive).

            2.  Call CreateDataProperty(_A_, ToString(_lengthA_), _T_).

            3.  Assert: The above call will never result in an abrupt
                completion.

            4.  Increment _lengthA_ by 1.

            5.  If _lengthA_ = _lim_, return _A_.

            6.  Let _p_ = _e_.

            7.  Let _q_ = _p_.

18. Let _T_ be a String value equal to the substring of _S_ consisting
    of the code units at positions _p_ (inclusive) through _s_
    (exclusive).

19. Call CreateDataProperty(_A_, ToString(_lengthA_), _T_).

20. Assert: The above call will never result in an abrupt completion.

21. Return _A_.

NOTE The value of _separator_ may be an empty String, an empty regular
expression, or a regular expression that can match an empty String. In
this case, _separator_ does not match the empty substring at the
beginning or end of the input String, nor does it match the empty
substring at the end of the previous separator match. (For example, if
_separator_ is the empty String, the String is split up into individual
code unit elements; the length of the result array equals the length of
the String, and each substring contains one code unit.) If _separator_
is a regular expression, only the first match at a given position of the
THIS String is considered, even if backtracking could yield a
non-empty-substring match at that position. (For example,
"AB".SPLIT(/A*?/) evaluates to the array ["A","B"], while
"AB".SPLIT(/A*/) evaluates to the array["","B"].)

If the THIS object is (or converts to) the empty String, the result
depends on whether _separator_ can match the empty String. If it can,
the result array contains no elements. Otherwise, the result array
contains one element, which is the empty String.

If _separator_ is a regular expression that contains capturing
parentheses, then each time _separator_ is matched the results
(including any UNDEFINED results) of the capturing parentheses are
spliced into the output array. For example,

"A<B>BOLD</B>AND<CODE>CODED</CODE>".SPLIT(/<(\/)?([^<>]+)>/)

evaluates to the array

["A", UNDEFINED, "B", "BOLD", "/", "B", "AND", UNDEFINED,
 "CODE", "CODED", "/", "CODE", ""]

If _separator_ is UNDEFINED, then the result array contains just one
String, which is the THIS value (converted to a String). If _limit_ is
not UNDEFINED, then the output array is truncated so that it contains no
more than _limit_ elements.

Runtime Semantics: SplitMatch Abstract Operation

The abstract operation SplitMatch takes three parameters, a String _S_,
an integer _q_, and a String _R_, and performs the following in order to
return either FALSE or the end index of a match:

1.  Type(_R_) must be String. Let _r_ be the number of code units in
    _R_.

2.  Let _s_ be the number of code units in _S_.

3.  If _q_+_r_ > _s_ then return FALSE.

4.  If there exists an integer _i_ between 0 (inclusive) and _r
    (exclusive) such that the code unit at position _q_+_i_ of _S_ is
    different from the code unit at position _i_ of _R_, then return
    FALSE.

5.  Return _q_+_r_.

The LENGTH property of the SPLIT method is 2.

NOTE The SPLIT function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

String.prototype.startsWith ( searchString [, position ] )

The following steps are taken:

1.  Let _O_ be CheckObjectCoercible(THIS value).

2.  Let _S_ be ToString(_O_).

3.  ReturnIfAbrupt(_S_).

4.  5.  6.  7.  If Type(_searchString_) is Object, then

    a.  Let _isRegExp_ be HasProperty(_searchString_, @@isRegExp).

    b.  If _isRegExp_ is TRUE, then throw a TYPEERROR exception.

8.  Let _searchStr_ be ToString(_searchString_).

9.  ReturnIfAbrupt(_searchString_)..

10. 11. 12. Let _pos_ be ToInteger(_position_). (If _position_ is
    UNDEFINED, this step produces the value 0).

13. ReturnIfAbrupt(_pos_).

14. Let _len_ be the number of elements in _S_.

15. Let _start_ be min(max(_pos_, 0), _len_).

16. Let _searchLength_ be the number of elements in _searchStr_.

17. If _searchLength+start_ is greater than _len_, return FALSE_.

18. If the _searchLength_ sequence of elements of _S_ starting at
    _start_ is the same as the full element sequence of _searchStr_,
    return TRUE.

19. Otherwise, return FALSE.

The LENGTH property of the STARTSWITH method is 1.

NOTE 1 This method returns TRUE if the sequence of elements of
_searchString_ converted to a String is the same as the corresponding
elements of this object (converted to a String) starting at _position_.
Otherwise returns FALSE.

NOTE 2 Throwing an exception if the first argument is a RegExp is
specified in order to allow future editions to define extends that allow
such argument values.

NOTE 3 The STARTSWITH function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

String.prototype.substring ( start, end )

The SUBSTRING method takes two arguments, _start_ and _end_, and returns
a substring of the result of converting this object to a String,
starting from element position _start_ and running to, but not
including, element position _end_ of the String (or through the end of
the String is _end_ is UNDEFINED). The result is a String value, not a
String object.

If either argument is NAN or negative, it is replaced with zero; if
either argument is larger than the length of the String, it is replaced
with the length of the String.

If _start_ is larger than _end_, they are swapped.

The following steps are taken:

1.  Let _O_ be CheckObjectCoercible(THIS value).

2.  Let _S_ be ToString(_O_).

3.  ReturnIfAbrupt(_S_).

4.  Let _len_ be the number of elements in _S_.

5.  Let _intStart_ be ToInteger(_start_).

6.  If _end_ is UNDEFINED, let _intEnd_ be _len_; else let _intEnd_ be
    ToInteger(_end_).

7.  Let _finalStart_ be min(max(_intStart_, 0), _len_).

8.  Let _finalEnd_ be min(max(_intEnd_, 0), _len_).

9.  Let _from_ be min(_finalStart_, _finalEnd_).

10. Let _to_ be max(_finalStart_, _finalEnd_).

11. Return a String whose length is _to_ - _from_, containing code units
    from _S_, namely the code units with indices _from_ through _to_ −1,
    in ascending order.

The LENGTH property of the SUBSTRING method is 2.

NOTE The SUBSTRING function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

String.prototype.toLocaleLowerCase ( )

This function interprets a string value as a sequence of code points, as
described in 6.1.4.

This function works exactly the same as TOLOWERCASE except that its
result is intended to yield the correct result for the host
environment’s current locale, rather than a locale-independent result.
There will only be a difference in the few cases (such as Turkish) where
the rules for that language conflict with the regular Unicode case
mappings.

NOTE 1 The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that implementations
do not use this parameter position for anything else.

NOTE 2 The TOLOCALELOWERCASE function is intentionally generic; it does
not require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

String.prototype.toLocaleUpperCase ( )

This function interprets a string value as a sequence of code points, as
described in 6.1.4.

This function works exactly the same as TOUPPERCASE except that its
result is intended to yield the correct result for the host
environment’s current locale, rather than a locale-independent result.
There will only be a difference in the few cases (such as Turkish) where
the rules for that language conflict with the regular Unicode case
mappings.

NOTE 1 The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that implementations
do not use this parameter position for anything else.

NOTE 2 The TOLOCALEUPPERCASE function is intentionally generic; it does
not require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

String.prototype.toLowerCase ( )

This function interprets a string value as a sequence of code points, as
described in 6.1.4. The following steps are taken:

1.  Let _O_ be CheckObjectCoercible(THIS value).

2.  Let _S_ be ToString(_O_).

3.  ReturnIfAbrupt(_S_).

4.  Let _cpList_ be a List containing in order the code points as
    defined in 6.1.4 of _S_, starting at the first element of _S_.

5.  For each code point _c_ in _cpList_, if the Unicode Character
    Database provides a language insensitive lower case equivalent of
    _c_ then replace _c_ in _cpList_ with that equivalent code point(s).

6.  Let _cuList_ be a new List.

7.  For each code point _c_ in _cpList_, in order, append to _cuList
    the elements of the UTF-16Encoding (10.1.1) of _c_.

8.  Let _L_ be a String whose elements are, in order, the elements of
    _cuList_ .

9.  Return _L_.

The result must be derived according to the locale-insensitive case
mappings in the Unicode Character Database (this explicitly includes not
only the UnicodeData.txt file, but also all locale-insensitive mappings
in the SpecialCasings.txt file that accompanies it).

NOTE 1 The case mapping of some code points may produce multiple code
points . In this case the result String may not be the same length as
the source String. Because both TOUPPERCASE and TOLOWERCASE have
context-sensitive behaviour, the functions are not symmetrical. In other
words, S.TOUPPERCASE().TOLOWERCASE() is not necessarily equal to
S.TOLOWERCASE().

NOTE 2 The TOLOWERCASE function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

String.prototype.toString ( )

When the TOSTRING method is called, the following steps are taken:

1.  Let _s_ be thisStringValue(THIS value).

2.  Return _s_.

NOTE For a String object, the TOSTRING method happens to return the same
thing as the VALUEOF method.

String.prototype.toUpperCase ( )

This function interprets a string value as a sequence of code points, as
described in 6.1.4.

This function behaves in exactly the same way as
STRING.PROTOTYPE.TOLOWERCASE, except that code points are mapped to
their _uppercase_ equivalents as specified in the Unicode Character
Database.

NOTE The TOUPPERCASE function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

String.prototype.trim ( )

This function interprets a string value as a sequence of code points, as
described in 6.1.4.

The following steps are taken:

1.  Let _O_ be CheckObjectCoercible(THIS value).

2.  Let _S_ be ToString(_O_).

3.  ReturnIfAbrupt(_S_).

4.  Let _T_ be a String value that is a copy of _S_ with both leading
    and trailing white space removed. The definition of white space is
    the union of _WhiteSpace_ and _LineTerminator_. When determining
    whether a Unicode code point is in Unicode general category “Zs”,
    code unit sequences are interpreted as UTF-16 encoded code point
    sequences as specified in 6.1.4.

5.  Return _T_.

NOTE The TRIM function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

String.prototype.valueOf ( )

When the VALUEOF method is called, the following steps are taken:

1.  Let _s_ be thisStringValue(THIS value).

2.  Return _s_.

String.prototype [ @@iterator ]( )

When the @@iterator method is called it returns an Iterator object
(25.1.2) that iterates over the code points of a String value, returning
each code point as a String value. The following steps are taken:

The following steps are taken:

1.  Let _O_ be CheckObjectCoercible(THIS value).

2.  Let _S_ be ToString(_O_).

3.  ReturnIfAbrupt(_S_).

4.  Return CreateStringIterator(_S_).

The value of the NAME property of this function is "[SYMBOL.ITERATOR]".

Properties of String Instances

String instances are String exotic objects and have the internal methods
specified for such objects. String instances inherit properties from the
String prototype object. String instances also have a [[StringData]]
internal slot.

String instances have a LENGTH property, and a set of enumerable
properties with integer indexed names.

length

The number of elements in the String value represented by this String
object.

Once a String object is initialized, this property is unchanging. It has
the attributes { [[Writable]]: FALSE, [[Enumerable]]: FALSE,
[[Configurable]]: FALSE }.

String Iterator Objects 

An String Iterator is an object, that represents a specific iteration
over some specific String instance object. There is not a named
constructor for String Iterator objects. Instead, String iterator
objects are created by calling certain methods of String instance
objects.

CreateStringIterator Abstract Operation

Several methods of String objects return Iterator objects. The abstract
operation CreateStringIterator with argument _string_ is used to create
such iterator objects. It performs the following steps:

1.  Assert: Type(_string_) is String.

2.  3.  Let _iterator_ be the result of
    ObjectCreate(%StringIteratorPrototype%, ([[IteratedString]],
    [[StringIteratorNextIndex]] )).

4.  Set _iterator’s_ [[IteratedString]] internal slot to _string_.

5.  Set _iterator’s_ [[StringIteratorNextIndex]] internal slot to 0.

6.  Return _iterator_.

The %StringIteratorPrototype% Object

All String Iterator Objects inherit properties from the
%StringIteratorPrototype% intrinsic object. The
%StringIteratorPrototype% object is an ordinary object and its
[[Prototype]] internal slot is the %ObjectPrototype% intrinsic object.
In addition, %StringIteratorPrototype% has the following properties:

%StringIteratorPrototype%.next ( )

1.  Let _O_ be the THIS value.

2.  If Type(_O_) is not Object, throw a TYPEERROR exception.

3.  If _O_ does not have all of the internal slots of an String Iterator
    Instance (21.1.5.3), throw a TYPEERROR exception.

4.  Let _s_ be the value of the [[IteratedString]] internal slot of _O_.

5.  If _s_ is UNDEFINED, then return CreateIterResultObject(UNDEFINED,
    TRUE).

6.  Let _position_ be the value of the [[StringIteratorNextIndex]]
    internal slot of _O_.

7.  Let _len_ be the number of elements in _s_.

8.  If _position_ ≥ _len_, then

    a.  Set the value of the [[IteratedString]] internal slot of _O_ to
        UNDEFINED.

    b.  Return CreateIterResultObject(UNDEFINED, TRUE).

9.  Let _first_ be the code unit value of the element at index
    _position_ in _s_.

10. If _first_ < 0xD800 or _first_ > 0xDBFF or _position_+1 = _len_,
    then let _resultString_ be the string consisting of the single code
    unit _first_.

11. Else,

    a.  Let _second_ be the code unit value of the element at index
        _position_+1 in the String _S_.

    b.  If _second_ < 0xDC00 or _second_ > 0xDFFF, then let
        _resultString_ be the string consisting of the single code unit
        _first_.

    c.  Else, let _resultString_ be the string consisting of the code
        unit _first_ followed by the code unit _second_.

12. Let _resultSize_ be the number of code units in _resultString_.

13. Set the value of the [[StringIteratorNextIndex]] internal slot of
    _O_ to _position_+ _resultSize_.

14. Return CreateIterResultObject(_resultString_, FALSE).

%StringIteratorPrototype% [ @@iterator ] ( )

The following steps are taken:

1.  Return the THIS value.

The value of the NAME property of this function is "[SYMBOL.ITERATOR]".

%StringIteratorPrototype% [ @@toStringTag ]

The initial value of the @@toStringTag property is the string value
"STRING ITERATOR".

Properties of String Iterator Instances

String Iterator instances are ordinary objects that inherit properties
from the %StringIteratorPrototype% intrinsic object. String Iterator
instances are initially created with the internal slots listed in Table
44.

Table 42 — Internal Slots of String Iterator Instances

  ----------------------------- ------------------------------------------------------------------------------
  INTERNAL SLOT                 DESCRIPTION
  [[IteratedString]]            The String value whose elements are being iterated.
  [[StringIteratorNextIndex]]   The integer index of the next string index to be examined by this iteration.
  ----------------------------- ------------------------------------------------------------------------------


RegExp (Regular Expression) Objects

A RegExp object contains a regular expression and the associated flags.

NOTE The form and functionality of regular expressions is modelled after
the regular expression facility in the Perl 5 programming language.

Patterns

The REGEXP constructor applies the following grammar to the input
pattern String. An error occurs if the grammar cannot interpret the
String as an expansion of _Pattern_.

Syntax

Pattern~[U]~ ::

Disjunction~[?U]~

Disjunction~[U]~ ::

Alternative~[?U]~
 Alternative~[?U]~ | Disjunction~[?U]~

Alternative~[U]~ ::

[empty]
Alternative~[?U]~ Term~[?U]~

Term~[U]~ ::

Assertion~[?U]~
Atom~[?U]~
Atom~[?U]~ Quantifier

Assertion~[U]~ ::

^
$
\ B
\ B
( ? = Disjunction~[?U]~ )
( ? ! Disjunction~[?U]~ )

Quantifier ::

QuantifierPrefix
QuantifierPrefix ?

QuantifierPrefix ::

*
+
?
{ DecimalDigits }
{ DecimalDigits , }
{ DecimalDigits , DecimalDigits }

Atom~[U]~ ::

PatternCharacter
.
\ AtomEscape~[?U]~
CharacterClass~[?U]~
( Disjunction~[?U]~ )
( ? : Disjunction~[?U]~ )

SyntaxCharacter :: ONE OF

^ $ \ . * + ? ( ) [ ] { } |

PatternCharacter ::

SourceCharacter BUT NOT SyntaxCharacter

AtomEscape~[U]~ ::

DecimalEscape
CharacterEscape~[?U]~
CharacterClassEscape

CharacterEscape~[U]~ ::

ControlEscape
C ControlLetter
HexEscapeSequence
RegExpUnicodeEscapeSequence~[?U]~
IdentityEscape~[?U]~

ControlEscape :: ONE OF

F N R T V

ControlLetter :: ONE OF

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

RegExpUnicodeEscapeSequence~[U]~ ::

[+U] U LeadSurrogate \U TrailSurrogate
U _Hex4Digits_
[+U] U{ HexDigits }

LeadSurrogate ::

Hex4Digits [match only if the CV of Hex4Digits is in the inclusive range
0xD800 to 0xDBFF]

TrailSurrogate ::

Hex4Digits [match only if the CV of Hex4Digits is in the inclusive range
0xDC00 to 0xDFFF]

IdentityEscape~[U]~ ::

[+U] SyntaxCharacter
[~U] SourceCharacter BUT NOT IdentifierPart
[~U] <ZWJ>
[~U] <ZWNJ>

DecimalEscape ::

DecimalIntegerLiteral [lookahead ∉ DecimalDigit]

CharacterClassEscape :: ONE OF

D D S S W W

CharacterClass~[U]~ ::

[ [lookahead ∉ {^}] ClassRanges~[?U]~ ]
[ ^ ClassRanges~[?U]~ ]

ClassRanges~[U]~ ::

[empty]
NonemptyClassRanges~[?U]~

NonemptyClassRanges~[U]~ ::

ClassAtom~[?U]~
ClassAtom~[?U]~ NonemptyClassRangesNoDash~[?U]~
ClassAtom~[?U]~ - ClassAtom~[?U]~ ClassRanges~[?U]~

NonemptyClassRangesNoDash~[U]~ ::

ClassAtom~[?U]~
ClassAtomNoDash~[?U]~ NonemptyClassRangesNoDash~[?U]~
ClassAtomNoDash~[?U]~ - ClassAtom~[?U]~ ClassRanges~[?U]~

ClassAtom~[U]~ ::

-
ClassAtomNoDash~[?U]~

ClassAtomNoDash~[U]~ ::

SourceCharacter BUT NOT ONE OF \ OR ] OR -
\ ClassEscape~[?U]~

ClassEscape~[U]~ ::

DecimalEscape
B
CharacterEscape~[?U]~
CharacterClassEscape

Pattern Semantics

A regular expression pattern is converted into an internal procedure
using the process described below. An implementation is encouraged to
use more efficient algorithms than the ones listed below, as long as the
results are the same. The internal procedure is used as the value of a
RegExp object’s [[RegExpMatcher]] internal slot.

A _Pattern_ is either a BMP pattern or a Unicode pattern depending upon
whether or not its associated flags contain an "U". A BMP pattern
matches against a String interpreted as consisting of a sequence of
16-bit values that are Unicode code points in the range of the Basic
Multilingual Plane. A Unicode pattern matches against a String
interpreted as consisting of Unicode code points encoded using UTF-16.
In the context of describing the behaviour of a BMP pattern “character”
means a single 16-bit Unicode BMP code point. In the context of
describing the behaviour of a Unicode pattern “character” means a UTF-16
encoded code point. In either context, “character value” means the
numeric value of the code unit or code point.

The semantics of _Pattern_ is defined as if a _Pattern_ was a List of
_SourceCharacter_ values where each _SourceCharacter_ corresponds to a
Unicode code point. If a BMP pattern contains a non-BMP
_SourceCharacter_ the entire pattern is encoded using UTF-16 and the
individual code units of that encoding are used as the elements of the
List.

NOTE For example, consider a pattern expressed in source code as the
single non-BMP character U+1D11E (MUSICAL SYMBOL G CLEF). Interpreted as
a Unicode pattern, it would be a single element (character) List
consisting of the single code point 0x1D11E. However, interpreted as a
BMP pattern, it is first UTF-16 encoded to produce a two element List
consisting of the code units 0xD834 and 0xDD1E.

Patterns are passed to the RegExp constructor as ECMAScript string
values in which non-BMP characters are UTF-16 encoded. For example, the
single character MUSICAL SYMBOL G CLEF pattern, expressed as a string
value, is a String of length 2 whose elements were the code units 0xD834
and 0xDD1E. So no further translation of the string would be necessary
to process it as a BMP pattern consisting of two pattern characters.
However, to process it as a Unicode pattern the string value must
treated as if it was UTF-16 decoded into a List consisting of a single
pattern character, the code point U+1D11E.

An implementation may not actually perform such translations to or from
UTF-16, but the semantics of this specification requires that the result
of pattern matching be as if such translations were performed.

Notation

The descriptions below use the following variables:

-   _Input_ is a List consisting of all of the characters, in order, of
      the String being matched by the regular expression pattern. Each
      character is either a code unit or a code point, depending upon
      the kind of pattern involved. The notation _input_[_n_] means the
      _n^th^_ character of _input_, where _n_ can range between 0
      (inclusive) and _InputLength_ (exclusive).

-   _InputLength_ is the number of characters in _Input_.

-   _NcapturingParens_ is the total number of left capturing parentheses
      (i.e. the total number of times the _Atom_ :: ( _Disjunction_ )
      production is expanded) in the pattern. A left capturing
      parenthesis is any ( pattern character that is matched by the (
      terminal of the _Atom_ :: ( _Disjunction_ ) production.

-   _IgnoreCase_ is TRUE if the RegExp object's [[OriginalFlags]]
      internal slot contains "I" and otherwise is FALSE.

-   _Multiline_ is TRUE if the RegExp object’s [[OriginalFlags]]
      internal slot contains "M" and otherwise is FALSE.

-   _Unicode_ is TRUE if the RegExp object’s [[OriginalFlags]] internal
      slot contains "U" and otherwise is FALSE.

Furthermore, the descriptions below use the following internal data
structures:

-   A _CharSet_ is a mathematical set of characters, either code units
      or code points depending up the state of the _Unicode_ flag. “All
      characters” means either all code unit values or all code point
      values also depending upon the state if _Unicode_.

-   A _State_ is an ordered pair (_endIndex_, _captures_) where
      _endIndex_ is an integer and _captures_ is a List of
      _NcapturingParens_ values. _States_ are used to represent partial
      match states in the regular expression matching algorithms. The
      _endIndex_ is one plus the index of the last input character
      matched so far by the pattern, while _captures_ holds the results
      of capturing parentheses. The _n^th^_ element of _captures_ is
      either a List that represents the value obtained by the _n^th^_
      set of capturing parentheses or UNDEFINED if the _n^th^_ set of
      capturing parentheses hasn’t been reached yet. Due to
      backtracking, many _States_ may be in use at any time during the
      matching process.

-   A _MatchResult_ is either a _State_ or the special token FAILURE
      that indicates that the match failed.

-   A _Continuation_ procedure is an internal closure (i.e. an internal
      procedure with some arguments already bound to values) that takes
      one _State_ argument and returns a _MatchResult_ result. If an
      internal closure references variables which are bound in the
      function that creates the closure, the closure uses the values
      that these variables had at the time the closure was created. The
      _Continuation_ attempts to match the remaining portion (specified
      by the closure's already-bound arguments) of the pattern against
      _Input_, starting at the intermediate state given by its _State_
      argument. If the match succeeds, the _Continuation_ returns the
      final _State_ that it reached; if the match fails, the
      _Continuation_ returns FAILURE.

-   A _Matcher_ procedure is an internal closure that takes two
      arguments — a _State_ and a _Continuation_ — and returns a
      _MatchResult_ result. A _Matcher_ attempts to match a middle
      subpattern (specified by the closure's already-bound arguments) of
      the pattern against _Input_, starting at the intermediate state
      given by its _State_ argument. The _Continuation_ argument should
      be a closure that matches the rest of the pattern. After matching
      the subpattern of a pattern to obtain a new _State_, the _Matcher_
      then calls _Continuation_ on that new _State_ to test if the rest
      of the pattern can match as well. If it can, the _Matcher_ returns
      the _State_ returned by _Continuation_; if not, the _Matcher_ may
      try different choices at its choice points, repeatedly calling
      _Continuation_ until it either succeeds or all possibilities have
      been exhausted.

-   An _AssertionTester_ procedure is an internal closure that takes a
      _State_ argument and returns a Boolean result. The assertion
      tester tests a specific condition (specified by the closure's
      already-bound arguments) against the current place in _Input_ and
      returns TRUE if the condition matched or FALSE if not.

-   An _EscapeValue_ is either a character or an integer. An
      _EscapeValue_ is used to denote the interpretation of a
      _DecimalEscape_ escape sequence: a character _ch_ means that the
      escape sequence is interpreted as the character _ch_, while an
      integer _n_ means that the escape sequence is interpreted as a
      backreference to the _n_^th^ set of capturing parentheses.

Pattern

The production _Pattern_ :: _Disjunction_ evaluates as follows:

1.  Evaluate _Disjunction_ to obtain a Matcher _m_.

2.  Return an internal closure that takes two arguments, a String _str
    and an integer _index_, and performs the following:

    1.  If _Unicode_ is TRUE, then let _Input_ be a List consisting of
        the sequence of code points of _str_ interpreted as a UTF-16
        encoded Unicode string. Otherwise, let _Input_ be a List
        consisting of the sequence of code units that are the elements
        of _str_. _Input_ will be used throughout the algorithms in
        21.2.2. Each element of _Input_ is considered to be a character.

    2.  Let _listIndex_ be the index into _Input_ of the character that
        was obtained from element _index_ of _str_.

    3.  Let _InputLength_ be the number of characters contained in
        _Input_. This variable will be used throughout the algorithms in
        21.2.2.

    4.  Let _c_ be a Continuation that always returns its State argument
        as a successful MatchResult.

    5.  Let _cap_ be a List of _NcapturingParens_ UNDEFINED values,
        indexed 1 through _NcapturingParens_.

    6.  Let _x_ be the State (_listIndex_, _cap_).

    7.  Call _m_(_x_, _c_) and return its result.

NOTE A Pattern evaluates ("compiles") to an internal procedure value.
REGEXP.PROTOTYPE.EXEC and other methods can then apply this procedure to
a String and an offset within the String to determine whether the
pattern would match starting at exactly that offset within the String,
and, if it does match, what the values of the capturing parentheses
would be. The algorithms in 21.2.2 are designed so that compiling a
pattern may throw a SYNTAXERROR exception; on the other hand, once the
pattern is successfully compiled, applying its result internal procedure
to find a match in a String cannot throw an exception (except for any
host-defined exceptions that can occur anywhere such as out-of-memory).

Disjunction

The production _Disjunction_ :: _Alternative_ evaluates by evaluating
_Alternative_ to obtain a Matcher and returning that Matcher.

The production _Disjunction_ :: _Alternative_ | _Disjunction_ evaluates
as follows:

1.  Evaluate _Alternative_ to obtain a Matcher _m1_.

2.  Evaluate _Disjunction_ to obtain a Matcher _m2_.

3.  Return an internal Matcher closure that takes two arguments, a State
    _x_ and a Continuation _c_, and performs the following:

    1.  Call _m1_(_x_, _c_) and let _r_ be its result.

    2.  If _r_ isn't FAILURE, return _r_.

    3.  Call _m2_(_x_, _c_) and return its result.

NOTE The | regular expression operator separates two alternatives. The
pattern first tries to match the left _Alternative_ (followed by the
sequel of the regular expression); if it fails, it tries to match the
right _Disjunction_ (followed by the sequel of the regular expression).
If the left _Alternative_, the right _Disjunction_, and the sequel all
have choice points, all choices in the sequel are tried before moving on
to the next choice in the left _Alternative_. If choices in the left
_Alternative_ are exhausted, the right _Disjunction_ is tried instead of
the left _Alternative_. Any capturing parentheses inside a portion of
the pattern skipped by | produce UNDEFINED values instead of Strings.
Thus, for example,

  /a|ab/.exec("abc")

returns the result "A" and not "AB". Moreover,

  /((a)|(ab))((c)|(bc))/.exec("abc")

returns the array

  ["abc", "a", "a", undefined, "bc", undefined, "bc"]

and not

  ["abc", "ab", undefined, "ab", "c", "c", undefined]

Alternative

The production _Alternative_ :: [empty] evaluates by returning a Matcher
that takes two arguments, a State _x_ and a Continuation _c_, and
returns the result of calling _c_(_x_).

The production _Alternative_ :: _Alternative_ _Term_ evaluates as
follows:

1.  Evaluate _Alternative_ to obtain a Matcher _m1_.

2.  Evaluate _Term_ to obtain a Matcher _m2_.

3.  Return an internal Matcher closure that takes two arguments, a State
    _x_ and a Continuation _c_, and performs the following:

    1.  Create a Continuation _d_ that takes a State argument _y_ and
        returns the result of calling _m2_(_y_, _c_).

    2.  Call _m1_(_x_, _d_) and return its result.

NOTE Consecutive _Terms_ try to simultaneously match consecutive
portions of _Input_. If the left _Alternative_, the right _Term_, and
the sequel of the regular expression all have choice points, all choices
in the sequel are tried before moving on to the next choice in the right
_Term_, and all choices in the right _Term_ are tried before moving on
to the next choice in the left _Alternative_.

Term

The production _Term_ :: _Assertion_ evaluates by returning an internal
Matcher closure that takes two arguments, a State _x_ and a Continuation
_c_, and performs the following:

1.  Evaluate _Assertion_ to obtain an AssertionTester _t_.

2.  Call _t_(_x_) and let _r_ be the resulting Boolean value.

3.  If _r_ is FALSE, return FAILURE.

4.  Call _c_(_x_) and return its result.

The production _Term_ :: _Atom_ evaluates as follows:

1.  Return the Matcher that is the result of evaluating _Atom_.

The production _Term_ :: _Atom_ _Quantifier_ evaluates as follows:

1.  Evaluate _Atom_ to obtain a Matcher _m_.

2.  Evaluate _Quantifier_ to obtain the three results: an integer _min_,
    an integer (or ∞) _max_, and Boolean _greedy_.

3.  If _max_ is finite and less than _min_, then throw a SYNTAXERROR
    exception.

4.  Let _parenIndex_ be the number of left capturing parentheses in the
    entire regular expression that occur to the left of this production
    expansion's _Term_. This is the total number of times the _Atom_ ::
    ( _Disjunction_ ) production is expanded prior to this production's
    _Term_ plus the total number of _Atom_ :: ( _Disjunction_ )
    productions enclosing this _Term_.

5.  Let _parenCount_ be the number of left capturing parentheses in the
    expansion of this production's _Atom_. This is the total number of
    _Atom_ :: ( _Disjunction_ ) productions enclosed by this
    production's _Atom_.

6.  Return an internal Matcher closure that takes two arguments, a State
    _x_ and a Continuation _c_, and performs the following:

    1.  Call RepeatMatcher(_m_, _min_, _max_, _greedy_, _x_, _c_,
        _parenIndex_, _parenCount_) and return its result.

Runtime Semantics: RepeatMatcher Abstract Operation

The abstract operation RepeatMatcher takes eight parameters, a Matcher
_m_, an integer _min_, an integer (or ∞) _max_, a Boolean _greedy_, a
State _x_, a Continuation _c_, an integer _parenIndex_, and an integer
_parenCount_, and performs the following:

1.  If _max_ is zero, then call _c_(_x_) and return its result.

2.  Create an internal Continuation closure _d_ that takes one State
    argument _y_ and performs the following:

    1.  If _min_ is zero and _y_'s _endIndex_ is equal to _x_'s
        _endIndex_, then return FAILURE.

    2.  If _min_ is zero then let _min2_ be zero; otherwise let _min2_
        be _min_–1.

    3.  If _max_ is ∞, then let _max2_ be ∞; otherwise let _max2_ be
        _max_–1.

    4.  Call RepeatMatcher(_m_, _min2_, _max2_, _greedy_, _y_, _c_,
        _parenIndex_, _parenCount_) and return its result.

3.  Let _cap_ be a fresh copy of _x_'s _captures_ List.

4.  For every integer _k_ that satisfies _parenIndex_ < _k_ and _k_ ≤
    _parenIndex_+_parenCount_, set _cap_[_k_] to UNDEFINED.

5.  Let _e_ be _x_'s _endIndex_.

6.  Let _xr_ be the State (_e_, _cap_).

7.  If _min_ is not zero, then call _m_(_xr_, _d_) and return its
    result.

8.  If _greedy_ is FALSE, then

    a.  Call _c_(_x_) and let _z_ be its result.

    b.  If _z_ is not FAILURE, return _z_.

    c.  Call _m_(_xr_, _d_) and return its result.

9.  Call _m_(_xr_, _d_) and let _z_ be its result.

10. If _z_ is not FAILURE, return _z_.

11. Call _c_(_x_) and return its result.

NOTE 1 An _Atom_ followed by a _Quantifier_ is repeated the number of
times specified by the _Quantifier_. A _Quantifier_ can be non-greedy,
in which case the _Atom_ pattern is repeated as few times as possible
while still matching the sequel, or it can be greedy, in which case the
_Atom_ pattern is repeated as many times as possible while still
matching the sequel. The _Atom_ pattern is repeated rather than the
input character sequence that it matches, so different repetitions of
the _Atom_ can match different input substrings.

NOTE 2 If the _Atom_ and the sequel of the regular expression all have
choice points, the _Atom_ is first matched as many (or as few, if
non-greedy) times as possible. All choices in the sequel are tried
before moving on to the next choice in the last repetition of _Atom_.
All choices in the last (n^th^) repetition of _Atom_ are tried before
moving on to the next choice in the next-to-last (n–1)^st^ repetition of
_Atom_; at which point it may turn out that more or fewer repetitions of
_Atom_ are now possible; these are exhausted (again, starting with
either as few or as many as possible) before moving on to the next
choice in the (n-1)^st^ repetition of _Atom_ and so on.

Compare

  /a[a-z]{2,4}/.exec("abcdefghi")

which returns "ABCDE" with

  /a[a-z]{2,4}?/.exec("abcdefghi")

which returns "ABC".

Consider also

  /(aa|aabaac|ba|b|c)*/.exec("aabaac")

which, by the choice point ordering above, returns the array

  ["aaba", "ba"]

and not any of:

  ["aabaac", "aabaac"]

  ["aabaac", "c"]

The above ordering of choice points can be used to write a regular
expression that calculates the greatest common divisor of two numbers
(represented in unary notation). The following example calculates the
gcd of 10 and 15:

  "aaaaaaaaaa,aaaaaaaaaaaaaaa".replace(/^(a+)\1*,\1+$/,"$1")

which returns the gcd in unary notation "AAAAA".

NOTE 3 Step 5 of the RepeatMatcher clears _Atom's_ captures each time
_Atom_ is repeated. We can see its behaviour in the regular expression

  /(z)((a+)?(b+)?(c))*/.exec("zaacbbbcac")

which returns the array

  ["zaacbbbcac", "z", "ac", "a", undefined, "c"]

and not

  ["zaacbbbcac", "z", "ac", "a", "bbb", "c"]

because each iteration of the outermost * clears all captured Strings
contained in the quantified _Atom_, which in this case includes capture
Strings numbered 2, 3, 4, and 5.

NOTE 4 Step 1 of the RepeatMatcher's _d_ closure states that, once the
minimum number of repetitions has been satisfied, any more expansions of
_Atom_ that match the empty character sequence are not considered for
further repetitions. This prevents the regular expression engine from
falling into an infinite loop on patterns such as:

  /(a*)*/.exec("b")

or the slightly more complicated:

  /(a*)b\1+/.exec("baaaac")

which returns the array

  ["b", ""]

Assertion

The production _Assertion_ :: ^ evaluates by returning an internal
AssertionTester closure that takes a State argument _x_ and performs the
following:

1.  Let _e_ be _x_'s _endIndex_.

2.  If _e_ is zero, return TRUE.

3.  If _Multiline_ is FALSE, return FALSE.

4.  If the character _Input_[_e_–1] is one of _LineTerminator_, return
    TRUE.

5.  Return FALSE.

NOTE Even when the Y flag is used with a pattern, ^ always matches only
at the beginning of _Input_, or (if _Multiline_ is TRUE) at the
beginning of a line.

The production _Assertion_ :: $ evaluates by returning an internal
AssertionTester closure that takes a State argument _x_ and performs the
following:

1.  Let _e_ be _x_'s _endIndex_.

2.  If _e_ is equal to _InputLength_, return TRUE.

3.  If _Multiline_ is FALSE, return FALSE.

4.  If the character _Input_[_e_] is one of _LineTerminator_, return
    TRUE.

5.  Return FALSE.

The production _Assertion_ :: \ B evaluates by returning an internal
AssertionTester closure that takes a State argument _x_ and performs the
following:

1.  Let _e_ be _x_'s _endIndex_.

2.  Call IsWordChar(_e_–1) and let _a_ be the Boolean result.

3.  Call IsWordChar(_e_) and let _b_ be the Boolean result.

4.  If _a_ is TRUE and _b_ is FALSE, return TRUE.

5.  If _a_ is FALSE and _b_ is TRUE, return TRUE.

6.  Return FALSE.

The production _Assertion_ :: \ B evaluates by returning an internal
AssertionTester closure that takes a State argument _x_ and performs the
following:

1.  Let _e_ be _x_'s _endIndex_.

2.  Call IsWordChar(_e_–1) and let _a_ be the Boolean result.

3.  Call IsWordChar(_e_) and let _b_ be the Boolean result.

4.  If _a_ is TRUE and _b_ is FALSE, return FALSE.

5.  If _a_ is FALSE and _b_ is TRUE, return FALSE.

6.  Return TRUE.

The production _Assertion_ :: ( ? = _Disjunction_ ) evaluates as
follows:

1.  Evaluate _Disjunction_ to obtain a Matcher _m_.

2.  Return an internal Matcher closure that takes two arguments, a State
    _x_ and a Continuation _c_, and performs the following steps:

    1.  Let _d_ be a Continuation that always returns its State argument
        as a successful MatchResult.

    2.  Call _m_(_x_, _d_) and let _r_ be its result.

    3.  If _r_ is FAILURE, return FAILURE.

    4.  Let _y_ be _r_'s State.

    5.  Let _cap_ be _y_'s _captures_ List.

    6.  Let _xe_ be _x_'s _endIndex_.

    7.  Let _z_ be the State (_xe_, _cap_).

    8.  Call _c_(_z_) and return its result.

The production _Assertion_ :: ( ? ! _Disjunction_ ) evaluates as
follows:

1.  Evaluate _Disjunction_ to obtain a Matcher _m_.

2.  Return an internal Matcher closure that takes two arguments, a State
    _x_ and a Continuation _c_, and performs the following steps:

    1.  Let _d_ be a Continuation that always returns its State argument
        as a successful MatchResult.

    2.  Call _m_(_x_, _d_) and let _r_ be its result.

    3.  If _r_ isn't FAILURE, return FAILURE.

    4.  Call _c_(_x_) and return its result.

Runtime Semantics: IsWordChar Abstract Operation

The abstract operation IsWordChar takes an integer parameter _e_ and
performs the following:

1.  If _e_ is –1 or _e_ is _InputLength_, return FALSE.

2.  Let _c_ be the character _Input_[_e_].

3.  If _c_ is one of the sixty-three characters below, return TRUE.

  --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
  a   b   c   d   e   f   g   h   i   j   k   l   m   n   o   p   q   r   s   t   u   v   w   x   y   z
  A   B   C   D   E   F   G   H   I   J   K   L   M   N   O   P   Q   R   S   T   U   V   W   X   Y   Z
  0   1   2   3   4   5   6   7   8   9   _                                                           
  --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---

1.  Return FALSE.

Quantifier

The production _Quantifier_ :: _QuantifierPrefix_ evaluates as follows:

1.  Evaluate _QuantifierPrefix_ to obtain the two results: an integer
    _min_ and an integer (or ∞) _max_.

2.  Return the three results _min_, _max_, and TRUE.

The production _Quantifier_ :: _QuantifierPrefix_ ? evaluates as
follows:

1.  Evaluate _QuantifierPrefix_ to obtain the two results: an integer
    _min_ and an integer (or ∞) _max_.

2.  Return the three results _min_, _max_, and FALSE.

The production _QuantifierPrefix_ :: * evaluates as follows:

1.  Return the two results 0 and ∞.

The production _QuantifierPrefix_ :: + evaluates as follows:

1.  Return the two results 1 and ∞.

The production _QuantifierPrefix_ :: ? evaluates as follows:

1.  Return the two results 0 and 1.

The production _QuantifierPrefix_ :: { _DecimalDigits_ } evaluates as
follows:

1.  Let _i_ be the MV of _DecimalDigits_ (see 11.8.3).

2.  Return the two results _i_ and _i_.

The production _QuantifierPrefix_ :: { _DecimalDigits_ , } evaluates as
follows:

1.  Let _i_ be the MV of _DecimalDigits_.

2.  Return the two results _i_ and ∞.

The production _QuantifierPrefix_ :: { _DecimalDigits_ , _DecimalDigits_
} evaluates as follows:

1.  Let _i_ be the MV of the first _DecimalDigits_.

2.  Let _j_ be the MV of the second _DecimalDigits_.

3.  Return the two results _i_ and _j_.

Atom

The production _Atom_ :: _PatternCharacter_ evaluates as follows:

1.  Let _ch_ be the character matched by _PatternCharacter_.

2.  Let _A_ be a one-element CharSet containing the character _ch_.

3.  Call CharacterSetMatcher(_A_, FALSE) and return its Matcher result.

The production _Atom_ :: . evaluates as follows:

1.  Let _A_ be the set of all characters except _LineTerminator_.

2.  Call CharacterSetMatcher(_A_, FALSE) and return its Matcher result.

The production _Atom_ :: \ _AtomEscape_ evaluates as follows:

1.  Return the Matcher that is the result of evaluating _AtomEscape_.

The production _Atom_ :: _CharacterClass_ evaluates as follows:

1.  Evaluate _CharacterClass_ to obtain a CharSet _A_ and a Boolean
    _invert_.

2.  Call CharacterSetMatcher(_A_, _invert_) and return its Matcher
    result.

The production _Atom_ :: ( _Disjunction_ ) evaluates as follows:

1.  Evaluate _Disjunction_ to obtain a Matcher _m_.

2.  Let _parenIndex_ be the number of left capturing parentheses in the
    entire regular expression that occur to the left of this production
    expansion's initial left parenthesis. This is the total number of
    times the _Atom_ :: ( _Disjunction _) production is expanded prior
    to this production's _Atom_ plus the total number of
    _Atom_ :: ( _Disjunction_ ) productions enclosing this _Atom_.

3.  Return an internal Matcher closure that takes two arguments, a State
    _x_ and a Continuation _c_, and performs the following steps:

    1.  Create an internal Continuation closure _d_ that takes one State
        argument _y_ and performs the following steps:

1.  Let _cap_ be a fresh copy of _y_'s _captures_ List.

2.  Let _xe_ be _x_'s _endIndex_.

3.  Let _ye_ be _y_'s _endIndex_.

4.  Let _s_ be a fresh List whose characters are the characters of
    _Input_ at positions _xe_ (inclusive) through _ye_ (exclusive).

5.  Set _cap_[_parenIndex_+1] to _s_.

6.  Let _z_ be the State (_ye_, _cap_).

7.  Call _c_(_z_) and return its result.

    1.  Call _m_(_x_, _d_) and return its result.

The production _Atom_ :: ( ? : _Disjunction_ ) evaluates as follows:

1.  Return the Matcher that is the result of evaluating _Disjunction_.

Runtime Semantics: CharacterSetMatcher Abstract Operation

The abstract operation CharacterSetMatcher takes two arguments, a
CharSet _A_ and a Boolean flag _invert_, and performs the following:

1.  Return an internal Matcher closure that takes two arguments, a State
    _x_ and a Continuation _c_, and performs the following steps:

    1.  Let _e_ be _x_'s _endIndex_.

    2.  If _e_ is _InputLength_, return FAILURE.

    3.  Let _ch_ be the character _Input_[_e_].

    4.  Let _cc_ be the result of Canonicalize(_ch_).

    5.  If _invert_ is FALSE, then

        a.  If there does not exist a member _a_ of set _A_ such that
            Canonicalize(_a_) is _cc_, return FAILURE.

    6.  Else _invert_ is TRUE,

        a.  If there exists a member _a_ of set _A_ such that
            Canonicalize(_a_) is _cc_, return FAILURE.

    7.  Let _cap_ be _x_'s _captures_ List.

    8.  Let _y_ be the State (_e_+1, _cap_).

    9.  Call _c_(_y_) and return its result.

Runtime Semantics: Canonicalize Abstract Operation

The abstract operation Canonicalize takes a character parameter _ch_ and
performs the following steps:

1.  If _IgnoreCase_ is FALSE, return _ch_.

2.  If _Unicode_ is TRUE,

    a.  If the file CaseFolding.txt of the Unicode Character Database
        provides a simple or common case folding mapping for _ch_, then
        return

    b.  the result of applying that mapping to _ch_.

    c.  Else, return _ch._

3.  Else,

    a.  Assert: _ch_ is a UTF-16 code unit.

    b.  Let _s_ be the ECMAScript String value consisting of the single
        code unit _ch_.

    c.  Let _u_ be the same result produced as if by performing the
        algorithm for STRING.PROTOTYPE.TOUPPERCASE using _s_ as the THIS
        value.

    d.  ReturnIfAbrupt(_u_).

    e.  Assert: _u_ is a String value.

    f.  If _u_ does not consist of a single code unit, then return _ch_.

    g.  Let _cu_ be _u_’s single code unit element.

    h.  If _ch_'s code unit value ≥ 128 and _cu_'s code unit value <
        128, then return _ch_.

    i.  Return _cu_.

NOTE 1 Parentheses of the form ( _Disjunction_ ) serve both to group the
components of the _Disjunction_ pattern together and to save the result
of the match. The result can be used either in a backreference (\
followed by a nonzero decimal number), referenced in a replace String,
or returned as part of an array from the regular expression matching
internal procedure. To inhibit the capturing behaviour of parentheses,
use the form (?: _Disjunction_ ) instead.

NOTE 2 The form (?= _Disjunction_ ) specifies a zero-width positive
lookahead. In order for it to succeed, the pattern inside _Disjunction_
must match at the current position, but the current position is not
advanced before matching the sequel. If _Disjunction_ can match at the
current position in several ways, only the first one is tried. Unlike
other regular expression operators, there is no backtracking into a (?=
form (this unusual behaviour is inherited from Perl). This only matters
when the _Disjunction_ contains capturing parentheses and the sequel of
the pattern contains backreferences to those captures.

For example,

  /(?=(a+))/.exec("baaabac")

matches the empty String immediately after the first B and therefore
returns the array:

  ["", "aaa"]

To illustrate the lack of backtracking into the lookahead, consider:

  /(?=(a+))a*b\1/.exec("baaabac")

This expression returns

  ["aba", "a"]

and not:

  ["aaaba", "a"]

NOTE 3 The form (?! _Disjunction_ ) specifies a zero-width negative
lookahead. In order for it to succeed, the pattern inside _Disjunction_
must fail to match at the current position. The current position is not
advanced before matching the sequel. _Disjunction_ can contain capturing
parentheses, but backreferences to them only make sense from within
_Disjunction_ itself. Backreferences to these capturing parentheses from
elsewhere in the pattern always return UNDEFINED because the negative
lookahead must fail for the pattern to succeed. For example,

  /(.*?)a(?!(a+)b\2c)\2(.*)/.exec("baaabaac")

looks for an A not immediately followed by some positive number n of
A's, a B, another n A's (specified by the first \2) and a C. The second
\2 is outside the negative lookahead, so it matches against UNDEFINED
and therefore always succeeds. The whole expression returns the array:

  ["baaabaac", "ba", undefined, "abaac"]

NOTE 4 In case-insignificant matches when _Unicode_ is TRUE, all
characters are implicitly case-folded using the simple mapping provided
by the Unicode standard immediately before they are compared. The simple
mapping always maps to a single code point, so it does not map, for
example, "SS" (U+00DF) to "SS". It may however map a code point outside
the Basic Latin range to a character within, for example, “ſ” (U+017F)
to “s”. Such characters are not mapped if _Unicode_ is FALSE. This
prevents Unicode code points such as U+017F and U+212A from matching
regular expressions such as /[AZ]/I, but they will match /[AZ]/UI.

AtomEscape

The production _AtomEscape_ :: _DecimalEscape_ evaluates as follows:

1.  Evaluate _DecimalEscape_ to obtain an EscapeValue _E_.

2.  If _E_ is a character, then

    a.  Let _ch_ be _E_'s character.

    b.  Let _A_ be a one-element CharSet containing the character _ch_.

    c.  Call CharacterSetMatcher(_A_, FALSE) and return its Matcher
        result.

3.  Assert: _E_ must be an integer.

4.  Let _n_ be that integer.

5.  If _n_=0 or _n_>_NcapturingParens_ then throw a SYNTAXERROR
    exception.

6.  Return an internal Matcher closure that takes two arguments, a State
    _x_ and a Continuation _c_, and performs the following steps:

    1.  Let _cap_ be _x_'s _captures_ List.

    2.  Let _s_ be _cap_[_n_].

    3.  If _s_ is UNDEFINED, then call _c_(_x_) and return its result.

    4.  Let _e_ be _x_'s _endIndex_.

    5.  Let _len_ be _s_'s length.

    6.  Let _f_ be _e_+_len_.

    7.  If _f_>_InputLength_, return FAILURE.

    8.  If there exists an integer _i_ between 0 (inclusive) and _len_
        (exclusive) such that Canonicalize(_s_[_i_]) is not the same
        character value as Canonicalize(_Input_ [_e_+_i_]), then return
        FAILURE.

    9.  Let _y_ be the State (_f_, _cap_).

    10. Call _c_(_y_) and return its result.

The production _AtomEscape_ :: _CharacterEscape_ evaluates as follows:

1.  Evaluate _CharacterEscape_ to obtain a character _ch_.

2.  Let _A_ be a one-element CharSet containing the character _ch_.

3.  Call CharacterSetMatcher(_A_, FALSE) and return its Matcher result.

The production _AtomEscape_ :: _CharacterClassEscape_ evaluates as
follows:

1.  Evaluate _CharacterClassEscape_ to obtain a CharSet _A_.

2.  Call CharacterSetMatcher(_A_, FALSE) and return its Matcher result.

NOTE An escape sequence of the form \ followed by a nonzero decimal
number _n_ matches the result of the _n_th set of capturing parentheses
(see 21.2.2.11). It is an error if the regular expression has fewer than
_n_ capturing parentheses. If the regular expression has _n_ or more
capturing parentheses but the _n_th one is UNDEFINED because it has not
captured anything, then the backreference always succeeds.

CharacterEscape

The production _CharacterEscape_ :: _ControlEscape_ evaluates by
returning the character according to Table 43.

Table 43 — ControlEscape Character Values

  ----------------- ------------------- -------------- ---------------------- ----------
  _CONTROLESCAPE_   _CHARACTER VALUE_   _CODE POINT_   _UNICODE NAME_         _SYMBOL_
  T                 9                   U+0009         CHARACTER TABULATION   <HT>
  N                 10                  U+000A         LINE FEED              <LF>
  V                 11                  U+000B         LINE TABULATION        <VT>
  F                 12                  U+000C         FORM FEED              <FF>
  R                 13                  U+000D         CARRIAGE RETURN        <CR>
  ----------------- ------------------- -------------- ---------------------- ----------

The production _CharacterEscape_ :: C _ControlLetter_ evaluates as
follows:

1.  Let _ch_ be the character matched by _ControlLetter_.

2.  Let _i_ be _ch_'s character value.

3.  Let _j_ be the remainder of dividing _i_ by 32.

4.  Return the character whose character value is _j_.

The production _CharacterEscape_ :: _HexEscapeSequence_ evaluates as
follows:

1.  Return the character whose code is the CV of _HexEscapeSequence_.

The production _CharacterEscape_ :: _RegExpUnicodeEscapeSequence_
evaluates as follows:

1.  Return the result of evaluating _RegExpUnicodeEscapeSequence_.

The production _CharacterEscape_ :: _IdentityEscape_ evaluates as
follows:

1.  Return the character matched by _IdentityEscape_.

The production _RegExpUnicodeEscapeSequence_ :: U _LeadSurrogate_ \U
_TrailSurrogate_ evaluates as follows:

1.  Let _lead_ be the result of evaluating _LeadSurrogate_.

2.  Let _trail_ be the result of evaluating _TrailSurrogate_.

3.  Let _cp_ be UTF16Decode(_lead_, _trail_).

4.  Return the character whose character value is _cp_.

The production _RegExpUnicodeEscapeSequence_ :: U _Hex4Digits_ evaluates
as follows:

1.  Return the character whose code is the CV of _Hex4Digits_.

The production _RegExpUnicodeEscapeSequence_ :: U{ _HexDigits_}
evaluates as follows:

1.  Return the character whose code is the MV of _HexDigits_.

The production _LeadSurrogate_ :: _Hex4Digits_ evaluates as follows:

1.  Return the character whose code is the CV of _Hex4Digits_.

The production _TrailSurrogate_ :: _Hex4Digits_ evaluates as follows:

1.  Return the character whose code is the CV of _Hex4Digits_.

DecimalEscape

The production _DecimalEscape_ :: _DecimalIntegerLiteral_ evaluates as
follows:

1.  Let _i_ be the MV of _DecimalIntegerLiteral_.

2.  If _i_ is zero, return the EscapeValue consisting of the character
    U+0000 (NULL).

3.  Return the EscapeValue consisting of the integer _i_.

The definition of “the MV of _DecimalIntegerLiteral_” is in 11.8.3.

NOTE If \ is followed by a decimal number _n_ whose first digit is not
0, then the escape sequence is considered to be a backreference. It is
an error if _n_ is greater than the total number of left capturing
parentheses in the entire regular expression. \0 represents the <NUL>
character and cannot be followed by a decimal digit.

CharacterClassEscape

The production _CharacterClassEscape_ :: D evaluates by returning the
ten-element set of characters containing the characters 0 through 9
inclusive.

The production _CharacterClassEscape_ :: D evaluates by returning the
set of all characters not included in the set returned by
_CharacterClassEscape_ :: D.

The production _CharacterClassEscape_ :: S evaluates by returning the
set of characters containing the characters that are on the right-hand
side of the _WhiteSpace_ (11.2) or _LineTerminator_ (11.3) productions.

The production _CharacterClassEscape_ :: S evaluates by returning the
set of all characters not included in the set returned by
_CharacterClassEscape_ :: S.

The production _CharacterClassEscape_ :: W evaluates by returning the
set of characters containing the sixty-three characters:

  --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
  a   b   c   d   e   f   g   h   i   j   k   l   m   n   o   p   q   r   s   t   u   v   w   x   y   z
  A   B   C   D   E   F   G   H   I   J   K   L   M   N   O   P   Q   R   S   T   U   V   W   X   Y   Z
  0   1   2   3   4   5   6   7   8   9   _                                                           
  --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---

The production _CharacterClassEscape_ :: W evaluates by returning the
set of all characters not included in the set returned by
_CharacterClassEscape_ :: W.

CharacterClass

The production _CharacterClass_ :: [ _ClassRanges_ ] evaluates by
evaluating _ClassRanges_ to obtain a CharSet and returning that CharSet
and the Boolean FALSE.

The production _CharacterClass_ :: [ ^ _ClassRanges_ ] evaluates by
evaluating _ClassRanges_ to obtain a CharSet and returning that CharSet
and the Boolean TRUE.

ClassRanges

The production _ClassRanges_ :: [empty] evaluates by returning the empty
CharSet.

The production _ClassRanges_ :: _NonemptyClassRanges_ evaluates by
evaluating _NonemptyClassRanges_ to obtain a CharSet and returning that
CharSet.

NonemptyClassRanges

The production _NonemptyClassRanges_ :: _ClassAtom_ evaluates as
follows:

1.  Return the CharSet that is the result of evaluating _ClassAtom_.

The production _NonemptyClassRanges_ :: _ClassAtom_
_NonemptyClassRangesNoDash_ evaluates as follows:

1.  Evaluate _ClassAtom_ to obtain a CharSet _A_.

2.  Evaluate _NonemptyClassRangesNoDash_ to obtain a CharSet _B_.

3.  Return the union of CharSets _A_ and _B_.

The production _NonemptyClassRanges_ :: _ClassAtom_ - _ClassAtom_
_ClassRanges_ evaluates as follows:

1.  Evaluate the first _ClassAtom_ to obtain a CharSet _A_.

2.  Evaluate the second _ClassAtom_ to obtain a CharSet _B_.

3.  Evaluate _ClassRanges_ to obtain a CharSet _C_.

4.  Call CharacterRange(_A_, _B_) and let _D_ be the resulting CharSet.

5.  Return the union of CharSets _D_ and _C_.

Runtime Semantics: CharacterRange Abstract Operation

The abstract operation CharacterRange takes two CharSet parameters _A_
and _B_ and performs the following:

1.  If _A_ does not contain exactly one character or _B_ does not
    contain exactly one character then throw a SYNTAXERROR exception.

2.  Let _a_ be the one character in CharSet _A_.

3.  Let _b_ be the one character in CharSet _B_.

4.  Let _i_ be the character value of character _a_.

5.  Let _j_ be the character value of character _b_.

6.  If _i_ > _j_ then throw a SYNTAXERROR exception.

7.  Return the set containing all characters numbered _i_ through _j_,
    inclusive.

NonemptyClassRangesNoDash

The production _NonemptyClassRangesNoDash_ :: _ClassAtom_ evaluates as
follows:

1.  Return the CharSet that is the result of evaluating _ClassAtom_.

The production _NonemptyClassRangesNoDash_ :: _ClassAtomNoDash_
_NonemptyClassRangesNoDash_ evaluates as follows:

1.  Evaluate _ClassAtomNoDash_ to obtain a CharSet _A_.

2.  Evaluate _NonemptyClassRangesNoDash_ to obtain a CharSet _B_.

3.  Return the union of CharSets _A_ and _B_.

The production _NonemptyClassRangesNoDash_ :: _ClassAtomNoDash_ -
_ClassAtom_ _ClassRanges_ evaluates as follows:

1.  Evaluate _ClassAtomNoDash_ to obtain a CharSet _A_.

2.  Evaluate _ClassAtom_ to obtain a CharSet _B_.

3.  Evaluate _ClassRanges_ to obtain a CharSet _C_.

4.  Call CharacterRange(_A_, _B_) and let _D_ be the resulting CharSet.

5.  Return the union of CharSets _D_ and _C_.

NOTE 1 _ClassRanges_ can expand into single _ClassAtoms_ and/or ranges
of two _ClassAtoms_ separated by dashes. In the latter case the
_ClassRanges_ includes all characters between the first _ClassAtom_ and
the second _ClassAtom_, inclusive; an error occurs if either _ClassAtom_
does not represent a single character (for example, if one is \W) or if
the first _ClassAtom's_ character value is greater than the second
_ClassAtom's_ character value.

NOTE 2 Even if the pattern ignores case, the case of the two ends of a
range is significant in determining which characters belong to the
range. Thus, for example, the pattern /[E-F]/I matches only the letters
E, F, E, and F, while the pattern /[E-F]/I matches all upper and
lower-case letters in the Unicode Basic Latin block as well as the
symbols [, \, ], ^, _, and `.

NOTE 3 A - character can be treated literally or it can denote a range.
It is treated literally if it is the first or last character of
_ClassRanges_, the beginning or end limit of a range specification, or
immediately follows a range specification.

ClassAtom

The production _ClassAtom_ :: - evaluates by returning the CharSet
containing the one character -.

The production _ClassAtom_ :: _ClassAtomNoDash_ evaluates by evaluating
_ClassAtomNoDash_ to obtain a CharSet and returning that CharSet.

ClassAtomNoDash

The production _ClassAtomNoDash_ :: _SourceCharacter_ BUT NOT ONE OF \
OR ] OR - evaluates as follows:

1.  Return the CharSet containing the character matched by
    _SourceCharacter_.

The production _ClassAtomNoDash_ :: \ _ClassEscape_ evaluates as
follows:

1.  Return the CharSet that is the result of evaluating _ClassEscape_.

ClassEscape

The production _ClassEscape_ :: _DecimalEscape_ evaluates as follows:

1.  Evaluate _DecimalEscape_ to obtain an EscapeValue _E_.

2.  If _E_ is not a character then throw a SYNTAXERROR exception.

3.  Let _ch_ be _E_'s character.

4.  Return the one-element CharSet containing the character _ch_.

The production _ClassEscape_ :: B evaluates as follows:

1.  Return the CharSet containing the single character <BS> U+
    (BACKSPACE).

The production _ClassEscape_ :: _CharacterEscape_ evaluates as follows:

1.  Return the CharSet containing the single character that is the
    result of evaluating _CharacterEscape_.

The production _ClassEscape_ :: _CharacterClassEscape_ evaluates as
follows:

1.  Return the CharSet that is the result of evaluating
    _CharacterClassEscape_.

NOTE A _ClassAtom_ can use any of the escape sequences that are allowed
in the rest of the regular expression except for \B, \B, and
backreferences. Inside a _CharacterClass_, \B means the backspace
character, while \B and backreferences raise errors. Using a
backreference inside a _ClassAtom_ causes an error.

The RegExp Constructor 

The RegExp constructor is the %RegExp% intrinsic object and the initial
value of the REGEXP property of the global object. When REGEXP is called
as a function rather than as a constructor, it creates and initializes a
new RegExp object. Thus the function call REGEXP(…) is equivalent to the
object creation expression NEW REGEXP(…) with the same arguments.
However, if the THIS value passed in the call is an Object with a
[[RegExpMatcher]] internal slot whose value is UNDEFINED, it initializes
the THIS value using the argument values. This permits REGEXP to be used
both as factory method and to perform constructor instance
initialization.

The REGEXP constructor is designed to be subclassable. It may be used as
the value of an EXTENDS clause of a class declaration. Subclass
constructors that intended to inherit the specified REGEXP behaviour
must include a SUPER call to the REGEXP constructor to initialize
subclass instances.

RegExp ( pattern, flags )

The following steps are taken:

1.  Let _func_ be the active function object.

2.  Let _O_ be the THIS value.

3.  If Type(_O_) is not Object or Type(_O_) is Object and _O_ does not
    have a [[RegExpMatcher]] internal slot or Type(_O_) is Object and
    _O_ has a [[RegExpMatcher]] internal slot and the value of
    [[RegExpMatcher]] is not UNDEFINED, then

    a.  If Type(_pattern_) is Object and _O_ has a [[RegExpMatcher]]
        internal slot and _flags_ is UNDEFINED, then

        i.  Return _pattern_;

    b.  Let _O_ be the result of calling the abstract operation
        RegExpAlloc with argument _func_.

    c.  ReturnIfAbrupt(_O_).

4.  If Type(_pattern_) is Object and _pattern_ has a [[RegExpMatcher]]
    internal slot, then

    a.  If the value of _pattern’s_ [[RegExpMatcher]] internal slot is
        UNDEFINED, then throw a TYPEERROR exception.

    b.  If _flags_ is not UNDEFINED, then throw a TYPEERROR exception.

    c.  Let _P_ be the value of _pattern’s_ [[OriginalSource]] internal
        slot.

    d.  Let _F_ be the value of _pattern’s_ [[OriginalFlags]] internal
        slot.

5.  Else,

    a.  Let _P_ be _pattern_.

    b.  Let _F_ be _flags_.

6.  Return the result of the abstract operation RegExpInitialize with
    arguments _O,_ _P_, and _F_.

NOTE If pattern is supplied using a _StringLiteral_, the usual escape
sequence substitutions are performed before the String is processed by
RegExp. If pattern must contain an escape sequence to be recognized by
RegExp, any backslash \ code points must be escaped within the
_StringLiteral_ to prevent them being removed when the contents of the
_StringLiteral_ are formed.

new RegExp( ...argumentsList )

When REGEXP is called as part of a new expression with argument list
_argumentsList_ it performs the following steps:

1.  Let _F_ be the REGEXP function object on which the NEW operator was
    applied.

2.  Let _argumentsList_ be the _argumentsList_ argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of Construct (_F_, _argumentsList_).

If REGEXP is implemented as an ECMAScript function object, its
[[Construct]] internal method will perform the above steps.

Abstract Operations for the RegExp Constructor

Runtime Semantics: RegExpAlloc Abstract Operation

When the abstract operation RegExpAlloc with argument _constructor_ is
called, the following steps are taken:

1.  Let _obj_ be the result of calling
    OrdinaryCreateFromConstructor(_constructor_, "%REGEXPPROTOTYPE%", (
    [[RegExpMatcher]], [[OriginalSource]], [[OriginalFlags]])).

2.  Let _status_ be the result of DefinePropertyOrThrow(_obj_,
    "LASTINDEX", PropertyDescriptor {[[Writable]]: TRUE,
    [[Enumberable]]: FALSE, [[Configurable]]: FALSE}).

3.  ReturnIfAbrupt(_status_).

4.  Return _obj_.

NOTE [[RegExpMatcher]] is initially assigned the value UNDEFINED as a
flag to indicate that the instance has not yet been initialized by the
REGEXP constructor. This flag value is never directly exposed to
ECMAScript code; hence implementations may choose to encode the flag in
some other manner.

Runtime Semantics: RegExpInitialize Abstract Operation

When the abstract operation RegExpInitialize with arguments _obj,_
_pattern_, and _flags_ is called, the following steps are taken:

1.  If _pattern_ is UNDEFINED, then let _P_ be the empty String.

2.  Else, let _P_ be ToString(_pattern_).

3.  ReturnIfAbrupt(_P_).

4.  If _flags_ is UNDEFINED, then let _F_ be the empty String.

5.  Else, let _F_ be ToString(_flags_).

6.  ReturnIfAbrupt(_F_).

7.  If _F_ contains any code unit other than "G", "I", "M", "U", or "Y"
    or if it contains the same code unit more than once, then throw a
    SYNTAXERROR exception.

8.  If _F_ contains "U" then let _BMP_ be FALSE, else let _BMP_ be TRUE.

9.  If _BMP_ is TRUE, then

    a.  Parse _P_ interpreted as UTF-16 encoded Unicode code points
        using the grammars in 21.2.1. The goal symbol for the parse is
        _Pattern_.Throw a SYNTAXERROR exception if _P_ did not conform
        to the grammar or if any code point of _P_ were not matched by
        the parse.

    b.  Let _patternCharacters_ be a List whose elements are the code
        unit elements of _P._

10. Else

    a.  Parse _P_ interpreted as UTF-16 encoded Unicode code points
        using the grammars in 21.2.1. The goal symbol for the parse is
        _Pattern_~[U]~. Throw a SYNTAXERROR exception if _P_ did not
        conform to the grammar or if any code point of _P_ were not
        matched by the parse.

    b.  Let _patternCharacters_ be a List whose elements are the code
        points of _P_ interpreted as sequence of UTF-16 encoded Unicode
        code points_._

11. Set the value of _obj’s_ [[OriginalSource]] internal slot to _P_.

12. Set the value of _obj’s_ [[OriginalFlags]] internal slot to _F_.

13. Set _obj’s_ [[RegExpMatcher]] internal slot to the internal
    procedure that evaluates the above parse of _P_ by applying the
    semantics provided in 21.2.2 using _patternCharacters_ as the
    pattern’s List of _SourceCharacter_ values and _F_ as the flag
    parameters.

14. Let _putStatus_ be the result of Put(_obj_, "LASTINDEX", 0, TRUE).

15. ReturnIfAbrupt(_putStatus_).

16. Return _obj_.

Runtime Semantics: RegExpCreate Abstract Operation

When the abstract operation RegExpCreate with arguments _P_ and _F_ is
called, the following steps are taken:

1.  Let _obj_ be the result of calling the abstract operation
    RegExpAlloc with argument %RegExp%.

2.  ReturnIfAbrupt(_obj_).

3.  Return the result of the abstract operation RegExpInitialize with
    arguments _obj,_ _P_, and _F_ .

Runtime Semantics: EscapeRegExpPattern Abstract Operation

When the abstract operation EscapeRegExpPattern with arguments _P_ and
_F_ is called, the following occurs:

1.  Let _S_ be a String in the form of a _Pattern_ (_Pattern_~[U]~ if
    _F_ contains "U") equivalent to _P_ interpreted as UTF-16 encoded
    Unicode code points, in which certain code points are escaped as
    described below. _S_ may or may not be identical to _P_; however,
    the internal procedure that would result from evaluating _S_ as a
    _Pattern_ (_Pattern_~[U]~ if _F_ contains "U") must behave
    identically to the internal procedure given by the constructed
    object's [[RegExpMatcher]] internal slot. Multiple calls to this
    abstract operation using the same values for _P_ and _F_ must
    produce identical results.

2.  The code points / or any _LineTerminator_ occurring in the pattern
    shall be escaped in _S_ as necessary to ensure that the String value
    formed by concatenating the Strings "/", _S_, "/", and _F_ can be
    parsed (in an appropriate lexical context) as a
    _RegularExpressionLiteral_ that behaves identically to the
    constructed regular expression. For example, if _P_ is "/", then _S_
    could be "\/" or "\U002F", among other possibilities, but not "/",
    because /// followed by _F_ would be parsed as a _SingleLineComment_
    rather than a _RegularExpressionLiteral_. If _P_ is the empty
    String, this specification can be met by letting _S_ be "(?:)".

3.  Return _S_.

Properties of the RegExp Constructor

The value of the [[Prototype]] internal slot of the RegExp constructor
is the standard built-in Function prototype object (19.2.3).

Besides the LENGTH property (whose value is 2), the RegExp constructor
has the following properties:

RegExp.prototype

The initial value of REGEXP.PROTOTYPE is the RegExp prototype object
(21.2.5).

This property shall have the attributes { [[Writable]]: FALSE,
[[Enumerable]]: FALSE, [[Configurable]]: FALSE }.

RegExp[ @@create ] ( )

The @@create method of an object _F_ performs the following:

1.  Return the result of calling the abstract operation RegExpAlloc with
    argument _F_.

The value of the NAME property of this function is "[SYMBOL.CREATE]".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Properties of the RegExp Prototype Object

The RegExp prototype object is an ordinary object. It is not a RegExp
instance and does not have a [[RegExpMatcher]] internal slot or any of
the other internal slots of RegExp instance objects.

The value of the [[Prototype]] internal slot of the RegExp prototype
object is the standard built-in Object prototype object (19.1.3).

The RegExp prototype object does not have a VALUEOF property of its own;
however, it inherits the VALUEOF property from the Object prototype
object.

RegExp.prototype.constructor

The initial value of REGEXP.PROTOTYPE.CONSTRUCTOR is the standard
built-in REGEXP constructor.

RegExp.prototype.exec ( string )

Performs a regular expression match of _string_ against the regular
expression and returns an Array object containing the results of the
match, or NULL if _string_ did not match.

The String ToString(_string_) is searched for an occurrence of the
regular expression pattern as follows:

1.  Let _R_ be the THIS value.

2.  If Type(_R)_ is not Object, then throw a TYPEERROR exception.

3.  If _R_ does not have a [[RegExpMatcher]] internal slot, then throw a
    TYPEERROR exception.

4.  If the value of _R’s_ [[RegExpMatcher]] internal slot is UNDEFINED,
    then throw a TYPEERROR exception.

5.  6.  7.  Let _S_ be ToString(_string_)

8.  ReturnIfAbrupt(_S_).

9.  Return RegExpBuiltinExec(_R_, _S_).

Runtime Semantics: RegExpExec ( R, S ) Abstract Operation

The abstract operation RegExpExec with arguments _R_ and _S_ performs
the following steps:

1.  Assert: Type(_R)_ is Object.

2.  Assert: Type(_S_) is String.

3.  Let _exec_ be Get(_R_, "EXEC").

4.  ReturnIfAbrupt(_exec_).

5.  If IsCallable(_exec_) is TRUE, then

    a.  Let _result_ be the result of calling the [[Call]] internal
        method of _exec_ with arguments _R_, and (_S_).

    b.  ReturnIfAbrupt(_result_).

    c.  If Type(_result_) is neither Object or Null, then throw a
        TYPEERROR exception.

    d.  Return(_result_).

6.  If _R_ does not have a [[RegExpMatcher]] internal slot, then throw a
    TYPEERROR exception.

7.  If the value of _R’s_ [[RegExpMatcher]] internal slot is UNDEFINED,
    then throw a TYPEERROR exception.

8.  Return RegExpBuiltinExec(_R_, _S_).

NOTE If a callable EXEC property is not found this algorithm falls back
to attempting to use the built-in RegExp matching algoritm. This
provides compatable behaviour for code written for prior editions where
most built-in algorithms that use regular expressions did not perform a
dynamic property lookup of EXEC.

Runtime Semantics: RegExpBuiltinExec ( R, S ) Abstract Operation

The abstract operation RegExpBuiltinExec with arguments _R_ and _S_
performs the following steps:

1.  Assert: _R_ is an initialized RegExp instance.

2.  Assert: Type(_S_) is String.

3.  4.  5.  Let _length_ be the number of code units in _S_.

6.  7.  8.  Let _lastIndex_ be Get(_R_,"LASTINDEX").

9.  Let _i_ be ToInteger(_lastIndex_).

10. ReturnIfAbrupt(_i_).

11. Let _global_ be ToBoolean(Get(_R_, "GLOBAL")).

12. ReturnIfAbrupt(_global_).

13. Let _sticky_ be ToBoolean(Get(_R_, "STICKY")).

14. ReturnIfAbrupt(_sticky_).

15. If _global_ is FALSE and _sticky_ is FALSE, then let _i_ = 0.

16. Let _matcher_ be the value of _R’s_ [[RegExpMatcher]] internal slot.

17. Let _flags_ be the value of _R’s_ [[OriginalFlags]] internal slot.

18. If _flags_ contains "U" then let _fullUnicode_ be TRUE, else let
    _fullUnicode_ be FALSE.

19. Let _matchSucceeded_ be FALSE.

20. Repeat, while _matchSucceeded_ is FALSE

    a.  If _i_ < 0 or _i_ > _length_, then

        i.  ii. Let _putStatus_ be Put(_R_, "LASTINDEX", 0, TRUE).

        iii. ReturnIfAbrupt(_putStatus_).

        iv. Return NULL.

    b.  Let _r_ be the result of calling _matcher_ with arguments _S_
        and _i_.

    c.  If _r_ is FAILURE, then

        i.  If _sticky_ is TRUE, then

            1.  2.  Let _putStatus_ be Put(_R_, "LASTINDEX", 0, TRUE).

            3.  ReturnIfAbrupt(_putStatus_).

            4.  Return NULL.

        ii. Let _i_ = _i_+1.

    d.  else

        i.  Assert: _r_ is a State.

        ii. Set _matchSucceeded_ to TRUE.

21. Let _e_ be _r_'s _endIndex_ value.

22. If _fullUnicode_ is TRUE, then

    a.  _e_ is an index into the _Input_ character list, derived from
        _S_, matched by _matcher_. Let _eUTF_ be the smallest index into
        _S_ that corresponds to the character at element _e_ of _Input_.
        If _e_ isgreater than the length of _Input_, then _eUTF_ is 1 +
        the number of code units in _S. _

    b.  Let _e_ be _eUTF_.

23. If _global_ is TRUE or _sticky_ is TRUE,

    a.  Let _putStatus_ be the result of Put(_R_, "LASTINDEX", _e_,
        TRUE).

    b.  ReturnIfAbrupt(_putStatus_).

24. Let _n_ be the length of _r_'s _captures_ List. (This is the same
    value as 21.2.2.1's _NcapturingParens_.)

25. Let _A_ be the result of the abstract operation ArrayCreate(_n_ +
    1).

26. Assert: The value of _A_’s "LENGTH" property is _n_ + 1.

27. Let _matchIndex_ be _i_.

28. Assert: The following CreateDataProperty calls will not result in an
    abrupt completion.

29. Perform CreateDataProperty(_A_, "INDEX", _matchIndex_).

30. Perform CreateDataProperty(_A_, "INPUT", _S_).

31. 32. Let _matchedSubstr_ be the matched substring (i.e. the portion
    of _S_ between offset _i_ inclusive and offset _e_ exclusive).

33. Perform CreateDataProperty(_A_, "0", _matchedSubstr_).

34. For each integer _i_ such that _i_ > 0 and _i_ ≤ _n

    a.  Let _captureI_ be _i_^th^ element of _r_'s _captures_ List.

    b.  If _captureI_ is UNDEFINED, then let _capturedValue_ be
        UNDEFINED.

    c.  Else If _fullUnicode_ is TRUE,

        i.  Assert: _captureI_ is a List of code points.

        ii. Let _capturedValue_ be a string whose elements are the
            UTF-16Encoding (10.1.1) of the code points of _capture._

    d.  Else, _fullUnicode_ is FALSE,

        i.  Assert: _captureI_ is a List of code units.

        ii. Let _capturedValue_ be a string whose elements are the code
            units of _captureI._

    e.  Perform CreateDataProperty(_A_, ToString(_i_) ,
        _capturedValue_).

35. Return _A_.

get RegExp.prototype.global 

REGEXP.PROTOTYPE.GLOBAL is an accessor property whose set accessor
function is UNDEFINED. Its get accessor function performs the following
steps:

1.  Let _R_ be the THIS value.

2.  If Type(_R)_ is not Object, then throw a TYPEERROR exception.

3.  If _R_ does not have an [[OriginalFlags]] internal slot throw a
    TYPEERROR exception.

4.  Let _flags_ be the value of _R’s_ [[OriginalFlags]] internal slot.

5.  If _flags_ is UNDEFINED, then throw a TYPEERROR exception.

6.  If _flags_ contains the code unit "G", then return TRUE.

7.  Return FALSE.

get RegExp.prototype.ignoreCase 

REGEXP.PROTOTYPE.IGNORECASE is an accessor property whose set accessor
function is UNDEFINED. Its get accessor function performs the following
steps:

1.  Let _R_ be the THIS value.

2.  If Type(_R)_ is not Object, then throw a TYPEERROR exception.

3.  If _R_ does not have an [[OriginalFlags]] internal slot throw a
    TYPEERROR exception.

4.  Let _flags_ be the value of _R’s_ [[OriginalFlags]] internal slot.

5.  If _flags_ is UNDEFINED, then throw a TYPEERROR exception.

6.  If _flags_ contains the code unit "I", then return TRUE.

7.  Return FALSE.

RegExp.prototype.match ( string )

When the MATCH method is called with argument _string_, the following
steps are taken:

1.  Let _rx_ be the THIS value.

2.  If Type(_rx)_ is not Object, then throw a TYPEERROR exception.

3.  4.  5.  Let _S_ be ToString(_string_)

6.  ReturnIfAbrupt(_S_).

7.  Let _global_ be ToBoolean(Get(_rx_, "GLOBAL")).

8.  ReturnIfAbrupt(_global_).

9.  If _global_ is not TRUE, then

    a.  Return the result of RegExpExec(_rx_, _S_).

10. Else _global_ is TRUE,

    a.  Let _putStatus_ be Put(_rx_, "LASTINDEX", 0, TRUE).

    b.  ReturnIfAbrupt(_putStatus_).

    c.  Let _A_ be ArrayCreate(0).

    d.  Let _previousLastIndex_ be 0.

    e.  Let _n_ be 0.

    f.  g.  Repeat,

        i.  Let _result_ be RegExpExec(_rx_, _S_).

        ii. ReturnIfAbrupt(_result_).

        iii. If _result_ is NULL, then

            1.  If _n_=0, then return NULL.

            2.  Else, return _A_.

        iv. Else _result_ is not NULL,

            1.  Let _thisIndex_ be ToInteger(Get(_rx_, "LASTINDEX")).

            2.  ReturnIfAbrupt(_thisIndex_).

            3.  If _thisIndex_ = _previousLastIndex_ then

                a.  Let _putStatus_ be Put(_rx_, "LASTINDEX",
                    _thisIndex_+1, TRUE).

                b.  ReturnIfAbrupt(_putStatus_).

                c.  Set _previousLastIndex_ to _thisIndex_+1.

            4.  Else,

                a.  Set _previousLastIndex_ to _thisIndex_.

            5.  Let _matchStr_ be Get(_result_, "0").

            6.  Let _defineStatus_ be CreateDataPropertyOrThrow(_A_,
                ToString(_n_), _matchStr_).

            7.  ReturnIfAbrupt(_defineStatus_).

            8.  Increment _n_.

    h.  i.  

get RegExp.prototype.multiline 

REGEXP.PROTOTYPE.MULTILINE is an accessor property whose set accessor
function is UNDEFINED. Its get accessor function performs the following
steps:

1.  Let _R_ be the THIS value.

2.  If Type(_R)_ is not Object, then throw a TYPEERROR exception.

3.  If _R_ does not have an [[OriginalFlags]] internal slot throw a
    TYPEERROR exception.

4.  Let _flags_ be the value of _R’s_ [[OriginalFlags]] internal slot.

5.  If _flags_ is UNDEFINED, then throw a TYPEERROR exception.

6.  If _flags_ contains the code unit "M", then return TRUE.

7.  Return FALSE.

RegExp.prototype.replace ( string, replaceValue )

When the REPLACE method is called with arguments _string_ and
_replaceValue_ the following steps are taken:

1.  Let _rx_ be the THIS value.

2.  If Type(_rx)_ is not Object, then throw a TYPEERROR exception.

3.  4.  5.  6.  Let _S_ be ToString(_string_).

7.  ReturnIfAbrupt(_S_).

8.  Let _lengthS_ be the number of code unit elements in _S_.

9.  Let _functionalReplace_ be IsCallable(_replaceValue_).

10. If _functionReplace_ is FALSE, then

    a.  Let _replaceValue_ be ToString(_replaceValue_).

    b.  ReturnIfAbrupt(_replaceValue_).

11. Let _global_ be ToBoolean(Get(_rx_, "GLOBAL")).

12. ReturnIfAbrupt(_global_).

13. 14. 15. If _global_ is TRUE, then

    a.  Let _putStatus_ be Put(_rx_, "LASTINDEX", 0, TRUE).

    b.  ReturnIfAbrupt(_putStatus_).

16. Let _previousLastIndex_ be 0.

17. Let _results_ be a new empty List.

18. Let _done_ be FALSE.

19. Repeat, while _done_ is FALSE

    a.  Let _result_ be RegExpExec(_rx_, _S_).

    b.  ReturnIfAbrupt(_result_).

    c.  If _result_ is NULL, then set _done_ to TRUE.

    d.  Else _result_ is not NULL,

        i.  If _global_ is FALSE, then set _done_ to TRUE.

        ii. Else,

            1.  Let _thisIndex_ be ToInteger(Get(_rx_, "LASTINDEX")).

            2.  ReturnIfAbrupt(_thisIndex_).

            3.  If _thisIndex_ = _previousLastIndex_ then

                a.  Let _putStatus_ be Put(_rx_, "LASTINDEX",
                    _thisIndex_+1, TRUE).

                b.  ReturnIfAbrupt(_putStatus_).

                c.  Set _previousLastIndex_ to _thisIndex_+1.

            4.  Else,

                a.  Set _previousLastIndex_ to _thisIndex_.

    e.  If _result_ is not NULL, then append _result_ to the end of
        _results_.

20. Let _accumulatedResult_ be the empty String value.

21. Let _nextSourcePosition_ be 0.

22. 23. Repeat, for each _result_ in _results_,

    a.  Let _nCaptures_ be ToLength(Get(_result_, "LENGTH").

    b.  ReturnIfAbrupt(_nCaptures_).

    c.  Let _nCaptures_ be max(_nCaptues_ − 1, 0).

24. a.  Let _matched_ be ToString(Get(_result_, "0")).

    b.  ReturnIfAbrupt(_matched_).

    c.  Let _matchLength_ be the number of code units in _matched_.

    d.  Let _position_ be ToInteger(Get(_result_, "INDEX")).

    e.  ReturnIfAbrupt(_position_).

    f.  Let _position_ be max(min(_position_, _lengthS_), 0).

    g.  Let _n_ be 1.

    h.  Let _captures_ be an empty List.

    i.  Repeat while _n_ ≤ _nCaptures_

        i.  Let _capN_ be Get(_result_, ToString(_n_)).

        ii. If Type(_capN_) is not Undefined, then let _capN_ be
            ToString(_capN_).

        iii. ReturnIfAbrupt(_capN_).

        iv. Append _capN_ as the last element of _captures._

        v.  Let _n_ be _n_+1

    j.  If _functionalReplace_ is TRUE, then

        i.  Let _replacerArgs_ be the List (_matched_).

        ii. Append in list order the elements of _captures_ to the end
            of the List _replacerArgs_.

        iii. Append _position_ and _S_ as the last two elements of
            _replacerArgs._

        iv. Let _replValue_ be the result of calling the [[Call]]
            internal method of _replaceValue_ passing UNDEFINED as the
            THIS value and _replacerArgs_ as the argument list.

        v.  Let _replacement_ be ToString(_replValue_).

    k.  Else,

        i.  Let _replacement_ be GetReplaceSubstitution(_matched_, _S_,
            _position_, _captures_, _replaceValue_).

    l.  ReturnIfAbrupt(_replacement_).

    m.  If _position_ ≥ _nextSourcePosition_, then

        i.  NOTE _position_ should not normally move backwards. If it
            does, it is in indication of a ill-behaving RegExp subclass
            or use of an access triggered side-effect to change the
            global flag or other characteristics of _rx._ In such cases,
            the corresponding substitution is ignored.

        ii. iii. iv. Let _accumulatedResult_ be the String formed by
            concatenating the code units of the current value of
            _accumulatedResult_ with the substring of _S_ consisting of
            the code units from _nextSourcePosition_ (inclusive) up to
            _position_ (exclusive) and with the code units of
            _replacement_.

        v.  Let _nextSourcePosition_ be _position_ + _matchLength_.

25. If _nextSourcePosition_ ≥ _lengthS_, then return
    _accumulatedResult_.

26. Return the String formed by concatenating the code units of
    _accumulatedResult_ with the substring of _S_ consisting of the code
    units from _nextSourcePosition_ (inclusive) up through the final
    code unit of _S_ (inclusive).

RegExp.prototype.search ( string )

When the search method is called with argument _string_, the following
steps are taken:

1.  Let _rx_ be the THIS value.

2.  If Type(_rx)_ is not Object, then throw a TYPEERROR exception.

3.  4.  5.  Let _s_ be ToString(_string_).

6.  ReturnIfAbrupt(_s_).

7.  Let _previousLastIndex_ be Get(_rx_, "LASTINDEX").

8.  ReturnIfAbrupt(_previousLastIndex_).

9.  Let _status_ be Put(_rx_, "LASTINDEX", 0, TRUE)

10. ReturnIfAbrupt(_status_)

11. Let _result_ be RegExpExec(_rx_, _s_).

12. ReturnIfAbrupt(_result_).

13. Let _status_ be Put(_rx_, "LASTINDEX", _previousLastIndex_, TRUE)

14. ReturnIfAbrupt(_status_)

15. If _result_ is NULL, return –1.

16. Return Get(_result_, "INDEX").

NOTE The LASTINDEX and GLOBAL properties of this RegExp object are
ignored when performing the search. The LASTINDEX property is left
unchanged.

get RegExp.prototype.source 

REGEXP.PROTOTYPE.SOURCE is an accessor property whose set accessor
function is UNDEFINED. Its get accessor function performs the following
steps:

1.  Let _R_ be the THIS value.

2.  If Type(_R)_ is not Object, then throw a TYPEERROR exception.

3.  If _R_ does not have an [[OriginalSource]] internal slot throw a
    TYPEERROR exception.

4.  If _R_ does not have an [[OriginalFlags]] internal slot throw a
    TYPEERROR exception.

5.  Let _src_ be the value of _R’s_ [[OriginalSource]] internal slot.

6.  Let _flags_ be the value of _R’s_ [[OriginalFlags]] internal slot.

7.  If either _src_ or _flags_ is UNDEFINED, then throw a TYPEERROR
    exception.

8.  Return EscapeRegExpPattern(_src_, _flags_).

RegExp.prototype.split ( string, limit )

NOTE Returns an Array object into which substrings of the result of
converting _string_ to a String have been stored. The substrings are
determined by searching from left to right for matches of the THIS value
regular expression; these occurrences are not part of any substring in
the returned array, but serve to divide up the String value.

The THIS value may be an empty regular expression or a regular
expression that can match an empty String. In this case, regular
expression does not match the empty substring at the beginning or end of
the input String, nor does it match the empty substring at the end of
the previous separator match. (For example, if the regular expression
matches the empty String, the String is split up into individual code
unit elements; the length of the result array equals the length of the
String, and each substring contains one code unit.) Only the first match
at a given position of the THIS String is considered, even if
backtracking could yield a non-empty-substring match at that position.
(For example, /A*?/.SPLIT("AB") evaluates to the array ["A","B"], while
/A*/.SPLIT("AB") evaluates to the array["","B"].)

If the _string_ is (or converts to) the empty String, the result depends
on whether the regular expression can match the empty String. If it can,
the result array contains no elements. Otherwise, the result array
contains one element, which is the empty String.

If the regular expression that contains capturing parentheses, then each
time _separator_ is matched the results (including any UNDEFINED
results) of the capturing parentheses are spliced into the output array.
For example,

/<(\/)?([^<>]+)>/.split("A<B>bold</B>and<CODE>coded</CODE>")

evaluates to the array

["A", undefined, "B", "bold", "/", "B", "and", undefined,"CODE",
"coded", "/", "CODE", ""]

If _limit_ is not UNDEFINED, then the output array is truncated so that
it contains no more than _limit_ elements.

When the SPLIT method is called, the following steps are taken:

1.  Let _rx_ be the THIS value.

2.  If Type(_rx)_ is not Object, then throw a TYPEERROR exception.

3.  If _rx_ does not have a [[RegExpMatcher]] internal slot, then throw
    a TYPEERROR exception.

4.  If the value of _rx’s_ [[RegExpMatcher]] internal slot is UNDEFINED,
    then throw a TYPEERROR exception.

5.  Let _matcher_ be the value of _rx’s_ [[RegExpMatcher]] internal
    slot.

6.  Let _S_ be ToString(_string_).

7.  ReturnIfAbrupt(_S_).

8.  Let _A_ be the result of the abstract operation ArrayCreate with
    argument 0.

9.  ReturnIfAbrupt(_A_).

10. Let _lengthA_ be 0.

11. If _limit_ is UNDEFINED, let _lim_ = 2^53^–1; else let _lim_ =
    ToLength(_limit_).

12. Let _s_ be the number of elements in _S_.

13. Let _p_ = 0.

14. If _lim_ = 0, return _A_.

15. If _s_ = 0, then

    a.  Let _z_ be the result of calling the _matcher_ with arguments
        _S_ and 0.

    b.  ReturnIfAbrupt(_z_).

    c.  If _z_ is not FAILURE, return _A_.

    d.  Assert: The following call will never result in an abrupt
        completion.

    e.  Call CreateDataProperty(_A_, "0", _S_).

    f.  Return _A_.

16. Let _q_ = _p_.

17. Repeat, while _q_ ≠ _s

    a.  Let _z_ be the result of calling the _matcher_ with arguments
        _S_ and _q_

    b.  ReturnIfAbrupt(_z_).

    c.  If _z_ is FAILURE, then let _q_ = _q_+1.

    d.  Else _z_ is not FAILURE,

        i.  _z_ must be a State. Let _e_ be _z_'s _endIndex_ and let
            _cap_ be _z_'s _captures_ List.

        ii. If _e_ = _p_, then let _q_ = _q_+1.

        iii. Else _e_ ≠ _p_,

            1.  Let _T_ be a String value equal to the substring of _S_
                consisting of the elements at positions _p_ (inclusive)
                through _q_ (exclusive).

            2.  Assert: The following call will never result in an
                abrupt completion.

            3.  Call CreateDataProperty(_A_, ToString(_lengthA_), _T_).

            4.  If _lengthA_ = _lim_, return _A_.

            5.  Let _p_ = _e_.

            6.  Let _i_ = 0.

            7.  Repeat, while _i_ is not equal to the number of elements
                in _cap_.

                a.  Let _i_ = _i_+1.

                b.  Assert: The following call will never result in an
                    abrupt completion.

                c.  Call CreateDataProperty(_A_, ToString(_lengthA_),
                    _cap_[_i_]).

                d.  Increment _lengthA_ by 1.

                e.  If _lengthA_ = _lim_, return _A_.

            8.  Let _q_ = _p_.

18. Let _T_ be a String value equal to the substring of _S_ consisting
    of the elements at positions _p_ (inclusive) through _s_
    (exclusive).

19. Assert: The following call will never result in an abrupt
    completion.

20. Call CreateDataProperty(_A_, ToString(_lengthA_), _T_ ).

21. Return _A_.

The LENGTH property of the SPLIT method is 2.

NOTE 1 The SPLIT method ignores the value of the GLOBAL property of this
RegExp object.

get RegExp.prototype.sticky 

REGEXP.PROTOTYPE.STICKY is an accessor property whose set accessor
function is UNDEFINED. Its get accessor function performs the following
steps:

1.  Let _R_ be the THIS value.

2.  If Type(_R)_ is not Object, then throw a TYPEERROR exception.

3.  If _R_ does not have an [[OriginalFlags]] internal slot throw a
    TYPEERROR exception.

4.  Let _flags_ be the value of _R’s_ [[OriginalFlags]] internal slot.

5.  If _flags_ is UNDEFINED, then throw a TYPEERROR exception.

6.  If _flags_ contains the code unit "Y", then return TRUE.

7.  Return FALSE.

RegExp.prototype.test( S )

The following steps are taken:

1.  Let _R_ be the THIS value.

2.  If Type(_R)_ is not Object, then throw a TYPEERROR exception.

3.  Let _string_ be ToString(_S_).

4.  ReturnIfAbrupt(_string_).

5.  Let _match_ be RegExpExec(_R_, _string_).

6.  ReturnIfAbrupt(_match_).

7.  If _match_ is not NULL, then return TRUE; else return FALSE.

RegExp.prototype.toString ( )

1.  Let _R_ be the THIS value.

2.  If Type(_R)_ is not Object, then throw a TYPEERROR exception.

3.  If _R_ does not have a [[RegExpMatcher]] internal slot, then throw a
    TYPEERROR exception.

4.  If the value of _R’s_ [[RegExpMatcher]] internal slot is UNDEFINED,
    then throw a TYPEERROR exception.

5.  Let _pattern_ be ToString(Get(_R_, "SOURCE")).

6.  ReturnIfAbrupt(_pattern_).

7.  Let _result_ be the String value formed by concatenating "/",
    _pattern_, and "/".

8.  Let _global_ be ToBoolean(Get(_R_, "GLOBAL")).

9.  ReturnIfAbrupt(_global_).

10. If _global_ is TRUE, then append "G" as the last code unit of
    _result_.

11. Let _ignoreCase_ be ToBoolean(Get(_R_, "IGNORECASE")).

12. ReturnIfAbrupt(_ignoreCase_).

13. If _ignoreCase_ is TRUE, then append "I" as the last code unit of
    _result_.

14. Let _multiline_ be ToBoolean(Get(_R_, "MULTILINE")).

15. ReturnIfAbrupt(_multiline_).

16. If _multiline_ is TRUE, then append "M" as the last code unit of
    _result_.

17. Let _unicode_ be ToBoolean(Get(_R_, "UNICODE")).

18. ReturnIfAbrupt(_unicode_).

19. If _unicode_ is TRUE, then append "U" as the last code unit of
    _result_.

20. Let _sticky_ be ToBoolean(Get(_R_, "STICKY")).

21. ReturnIfAbrupt(_sticky_).

22. If _sticky_ is TRUE, then append "Y" as the last code unit of
    _result_.

23. Return _result_.

NOTE The returned String has the form of a _RegularExpressionLiteral_
that evaluates to another RegExp object with the same behaviour as this
object.

get RegExp.prototype.unicode 

REGEXP.PROTOTYPE.UNICODE is an accessor property whose set accessor
function is UNDEFINED. Its get accessor function performs the following
steps:

1.  Let _R_ be the THIS value.

2.  If Type(_R)_ is not Object, then throw a TYPEERROR exception.

3.  If _R_ does not have an [[OriginalFlags]] internal slot throw a
    TYPEERROR exception.

4.  Let _flags_ be the value of _R’s_ [[OriginalFlags]] internal slot.

5.  If _flags_ is UNDEFINED, then throw a TYPEERROR exception.

6.  If _flags_ contains the code unit "U", then return TRUE.

7.  Return FALSE.

RegExp.prototype [ @@isRegExp ]

The initial value of the @@isRegExp property is TRUE.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

NOTE The @@isRegExp property is used by STRING.PROTOTYPE methods to
identify objects that have the basic behaviour of regular expressions.
The absence of a @@isRegExp property or the existence of such a property
whose value is NULL indicates that the object should is not intended to
be used as regular expression object.

Properties of RegExp Instances

RegExp instances are ordinary objects that inherit properties from the
RegExp prototype object. RegExp instances have internal slots
[[RegExpMatcher]], [[OriginalSource]], and [[OriginalFlags]]. The value
of the [[RegExpMatcher]] internal slot is an implementation dependent
representation of the _Pattern_ of the RegExp object.

NOTE Prior to the 6^th^ Edition, REGEXP instances were specified as
having the own data properties SOURCE, GLOBAL, IGNORECASE, and
MULTILINE. Those properties are now specified as accessor properties of
RegExp.prototype.

RegExp instances also have the following property:

lastIndex

The value of the LASTINDEX property specifies the String position at
which to start the next match. It is coerced to an integer when used
(see 21.2.5.2). This property shall have the attributes { [[Writable]]:
TRUE, [[Enumerable]]: FALSE, [[Configurable]]: FALSE }.



INDEXED COLLECTIONS 


Array Objects

Array objects are exotic objects that give special treatment to a
certain class of property names. See 9.4.1.4 for a definition of this
special treatment.

An Array object, _O_, is said to be _sparse_ if the following algorithm
returns TRUE:

1.  Let _len_ be Get(_O_, "LENGTH").

2.  For each integer _i_ in the range 0≤_i_<ToUint32(_len_)

    a.  Let _elem_ be the result of calling the [[GetOwnProperty]]
        internal method of _O_ with argument ToString(_i_).

    b.  If _elem_ is UNDEFINED, return TRUE.

3.  Return FALSE.

The Array Constructor

The Array constructor is the %Array% intrinsic object and the initial
value of the ARRAY property of the global object. When ARRAY is called
as a function rather than as a constructor, it creates and initializes a
new Array object. Thus the function call ARRAY(…) is equivalent to the
object creation expression NEW ARRAY(…) with the same arguments.
However, if the THIS value passed in the call is an Object with an
[[ArrayInitializationState]] internal slot whose value is UNDEFINED, it
initializes the THIS value using the argument values. This permits ARRAY
to be used both as factory method and to perform constructor instance
initialization.

The ARRAY constructor is designed to be subclassable. It may be used as
the value of an EXTENDS clause of a class declaration. Subclass
constructors that intended to inherit the specified ARRAY behaviour must
include a SUPER call to the ARRAY constructor to initialize subclass
instances.

The LENGTH property of the ARRAY constructor function is 1.

Array ( )

This description applies if and only if the Array constructor is called
with no arguments.

1.  Let _numberOfArgs_ be the number of arguments passed to this
    function call.

2.  Assert: _numberOfArgs_ = 0.

3.  Let _O_ be the THIS value.

4.  If Type(_O_) is Object and _O_ has an [[ArrayInitializationState]]
    internal slot and the value of [[ArrayInitializationState]] is
    FALSE, then

    a.  Set the value of _O’s_ [[ArrayInitializationState]] internal
        slot to TRUE.

    b.  Let _array_ be _O_.

5.  Else,

    a.  Let _F_ be the active function.

    b.  Let _proto_ be GetPrototypeFromConstructor(_F_,
        "%ARRAYPROTOTYPE%").

    c.  ReturnIfAbrupt(_proto_).

    d.  Let _array_ be ArrayCreate(0, _proto_).

6.  ReturnIfAbrupt(_array_).

7.  Let _putStatus_ be Put(_array_, "LENGTH", 0, TRUE).

8.  ReturnIfAbrupt(_putStatus_).

9.  Return _array_.

Array (len)

This description applies if and only if the Array constructor is called
with exactly one argument.

1.  Let _numberOfArgs_ be the number of arguments passed to this
    function call.

2.  Assert: _numberOfArgs_ = 1.

3.  Let _O_ be the THIS value.

4.  If Type(_O_) is Object and _O_ has an [[ArrayInitializationState]]
    internal slot and the value of [[ArrayInitializationState]] is
    FALSE, then

    a.  Set the value of _O’s_ [[ArrayInitializationState]] internal
        slot to TRUE.

    b.  Let _array_ be _O_.

5.  Else,

    a.  Let _F_ be the active function.

    b.  Let _proto_ be GetPrototypeFromConstructor(_F_,
        "%ARRAYPROTOTYPE%").

    c.  ReturnIfAbrupt(_proto_).

    d.  Let _array_ be ArrayCreate(0, _proto_).

6.  ReturnIfAbrupt(_array_).

7.  If Type(_len_) is not Number, then

    a.  Let _defineStatus_ be CreateDataPropertyOrThrow(_array_, "0",
        _len_).

    b.  ReturnIfAbrupt(_defineStatus_).

    c.  Let _intLen_ be 1.

8.  Else,

    a.  Let _intLen_ be ToUint32(_len_).

    b.  If _intLen_ ≠ _len_, then throw a RANGEERROR exception.

9.  Let _putStatus_ be Put(_array_, "LENGTH", _intLen_, TRUE).

10. ReturnIfAbrupt(_putStatus_).

11. Return _array_.

Array (...items )

This description applies if and only if the Array constructor is called
with at least two arguments.

When the ARRAY function is called the following steps are taken:

1.  Let _numberOfArgs_ be the number of arguments passed to this
    function call.

2.  Assert: _numberOfArgs_ ≥ 2.

3.  Let _O_ be the THIS value.

4.  If Type(_O_) is Object and _O_ has an [[ArrayInitializationState]]
    internal slot and the value of [[ArrayInitializationState]] is
    FALSE, then

    a.  Set the value of _O’s_ [[ArrayInitializationState]] internal
        slot to TRUE.

    b.  Let _array_ be _O_.

5.  Else,

    a.  Let _F_ be the active function.

    b.  Let _proto_ be GetPrototypeFromConstructor(_F_,
        "%ARRAYPROTOTYPE%").

    c.  ReturnIfAbrupt(_proto_).

    d.  Let _array_ be ArrayCreate(_numberOfArgs_, _proto_).

6.  ReturnIfAbrupt(_array_).

7.  Let _k_ be 0.

8.  Let _items_ be a zero-origined List containing the argument items in
    order.

9.  Repeat, while _k_ < _numberOfArgs

    a.  Let _Pk_ be ToString(_k_).

    b.  Let _itemK_ be _k_^th^ element of _items_.

    c.  Let _defineStatus_ be CreateDataPropertyOrThrow(_array_, _Pk_,
        _itemK_).

    d.  ReturnIfAbrupt(_defineStatus_).

    e.  Increase _k_ by 1.

10. Let _putStatus_ be Put(_array_, "LENGTH", _numberOfArgs_, TRUE).

11. ReturnIfAbrupt(_putStatus_).

12. Return _array_.

new Array ( ... argumentsList)

When ARRAY is called as part of a NEW expression, it initializes a newly
created object.

1.  Let _F_ be the ARRAY function object on which the NEW operator was
    applied.

2.  Let _argumentsList_ be the _argumentsList_ argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of Construct (_F_, _argumentsList_).

If ARRAY is implemented as an ECMAScript function object, its
[[Construct]] internal method will perform the above steps.

Properties of the Array Constructor

The value of the [[Prototype]] internal slot of the Array constructor is
the Function prototype object (19.2.3).

Besides the LENGTH property (whose value is 1), the Array constructor
has the following properties:

Array.from ( arrayLike [ , mapfn [ , thisArg ] ] )

When the FROM method is called with argument _arrayLike_ and optional
arguments _mapfn_ and _thisArg_ the following steps are taken:

1.  Let _C_ be the THIS value.

2.  Let _items_ be ToObject(_arrayLike_).

3.  ReturnIfAbrupt(_items_).

4.  If _mapfn_ is UNDEFINED, then let _mapping_ be FALSE.

5.  else

    a.  If IsCallable(_mapfn_) is FALSE, throw a TYPEERROR exception.

    b.  If _thisArg_ was supplied, let _T_ be _thisArg_; else let _T_ be
        UNDEFINED.

    c.  Let _mapping_ be TRUE

6.  Let _usingIterator_ be CheckIterable(_items_).

7.  ReturnIfAbrupt(_usingIterator_).

8.  If _usingIterator_ is not UNDEFINED, then

    a.  If IsConstructor(_C_) is TRUE, then

        i.  Let _A_ be the result of calling the [[Construct]] internal
            method of _C_ with an empty argument list.

    b.  Else,

        i.  Let _A_ be ArrayCreate(0).

    c.  ReturnIfAbrupt(_A_).

    d.  Let _iterator_ be GetIterator(_items_, _usingIterator_).

    e.  ReturnIfAbrupt(_iterator_).

    f.  Let _k_ be 0.

    g.  Repeat

        i.  Let _Pk_ be ToString(_k_).

        ii. Let _next_ be IteratorStep(_iterator_).

        iii. ReturnIfAbrupt(_next_).

        iv. If _next_ is FALSE, then

            1.  Let _putStatus_ be Put(_A_, "LENGTH", _k_, TRUE).

            2.  ReturnIfAbrupt(_putStatus_).

            3.  Return _A_.

        v.  Let _nextValue_ be IteratorValue(_next_).

        vi. ReturnIfAbrupt(_nextValue_).

        vii. If _mapping_ is TRUE, then

            1.  Let _mappedValue_ be the result of calling the [[Call]]
                internal method of _mapfn_ with _T_ as _thisArgument_
                and (_nextValue_, _k_) as _argumentsList_.

            2.  ReturnIfAbrupt(_mappedValue_).

        viii. Else, let _mappedValue_ be _nextValue_.

        ix. Let _defineStatus_ be CreateDataPropertyOrThrow(_A_, _Pk_,
            _mappedValue_).

        x.  ReturnIfAbrupt(_defineStatus_).

        xi. Increase _k_ by 1.

9.  Assert: _items_ is not an Iterator so assume it is an array-like
    object.

10. Let _lenValue_ be Get(_items_, "LENGTH").

11. Let _len_ be ToLength(_lenValue_).

12. ReturnIfAbrupt(_len_).

13. If IsConstructor(_C_) is TRUE, then

    a.  Let _A_ be the result of calling the [[Construct]] internal
        method of _C_ with an argument list containing the single item
        _len_.

14. Else,

    a.  Let _A_ be ArrayCreate(_len_).

15. ReturnIfAbrupt(_A_).

16. Let _k_ be 0.

17. Repeat, while _k_ < _len

    a.  Let _Pk_ be ToString(_k_).

    b.  Let _kValue_ be Get(_items_, _Pk_).

    c.  ReturnIfAbrupt(_kValue_).

    d.  If _mapping_ is TRUE, then

        i.  Let _mappedValue_ be the result of calling the [[Call]]
            internal method of _mapfn_ with _T_ as _thisArgument_ and
            (_kValue_, _k_) as _argumentsList_.

        ii. ReturnIfAbrupt(_mappedValue_).

    e.  Else, let _mappedValue_ be _kValue_.

    f.  Let _defineStatus_ be CreateDataPropertyOrThrow(_A_, _Pk_,
        _mappedValue_).

    g.  ReturnIfAbrupt(_defineStatus_).

    h.  Increase _k_ by 1.

18. Let _putStatus_ be Put(_A_, "LENGTH", _len_, TRUE).

19. ReturnIfAbrupt(_putStatus_).

20. Return _A_.

The LENGTH property of the FROM method is 1.

NOTE The FROM function is an intentionally generic factory method; it
does not require that its THIS value be the Array constructor. Therefore
it can be transferred to or inherited by any other constructors that may
be called with a single numeric argument.

Array.isArray ( arg )

The ISARRAY function takes one argument _arg_, and performs the
following:

1.  If Type(_arg_) is not Object, return FALSE.

2.  If _arg_ is an exotic Array object, then return TRUE.

3.  Return FALSE.

Array.of ( ...items )

When the OF method is called with any number of arguments, the following
steps are taken:

1.  Let _len_ be the actual number of arguments passed to this function.

2.  Let _items_ be the List of arguments passed to this function.

3.  4.  Let _C_ be the THIS value.

5.  If IsConstructor(_C_) is TRUE, then

    a.  Let _A_ be the result of calling the [[Construct]] internal
        method of _C_ with an argument list containing the single item
        _len_.

6.  Else,

    a.  Let _A_ be ArrayCreate(_len_).

7.  ReturnIfAbrupt(_A_).

8.  Let _k_ be 0.

9.  Repeat, while _k_ < _len

    a.  b.  Let _kValue_ be element _k_ of _items_.

    c.  Let _Pk_ be ToString(_k_).

    d.  Let _defineStatus_ be CreateDataPropertyOrThrow(_A_,_Pk_,
        _kValue_.[[value]]).

    e.  ReturnIfAbrupt(_defineStatus_).

    f.  Increase _k_ by 1.

10. Let _putStatus_ be Put(_A_, "LENGTH", _len_, TRUE).

11. ReturnIfAbrupt(_putStatus_).

12. Return _A_.

The LENGTH property of the OF method is 0.

NOTE 1 The _items_ argument is assumed to be a well-formed rest argument
value.

NOTE 2 The OF function is an intentionally generic factory method; it
does not require that its THIS value be the Array constructor. Therefore
it can be transferred to or inherited by other constructors that may be
called with a single numeric argument.

Array.prototype

The value of ARRAY.PROTOTYPE is %ArrayPrototype%, the intrinsic Array
prototype object (22.1.3).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Array[ @@create ] ( )

The @@create method of an object _F_ performs the following steps:

1.  Let _F_ be the THIS value.

2.  Let _proto_ be GetPrototypeFromConstructor(_F_, "%ARRAYPROTOTYPE%").

3.  ReturnIfAbrupt(_proto_).

4.  Let _obj_ be ArrayCreate(UNDEFINED, _proto_).

5.  Return _obj_.

The value of the NAME property of this function is "[SYMBOL.CREATE]".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

NOTE 1 Passing UNDEFINED as the first argument to ArrayCreate causes the
[[ArrayInitializationState]] internal slot of the array to be initially
assigned the value FALSE. This is a flag used to indicate that the
instance has not yet been initialized by the ARRAY constructor. This
flag value is never directly exposed to ECMAScript code; hence
implementations may choose to encode the flag in any unobservable
manner.

NOTE 2 The Array @@CREATE function is intentionally generic; it does not
require that its THIS value be the Array constructor object. It can be
transferred to other constructor functions for use as a @@CREATE method.
When used with other constructors, this function will create an exotic
Array object whose [[Prototype]] value is obtained from the associated
constructor.

Properties of the Array Prototype Object

The value of the [[Prototype]] internal slot of the Array prototype
object is the intrinsic object %ObjectPrototype%.

The Array prototype object is itself an ordinary object. It is not an
Array instance and does not have a LENGTH property .

NOTE The Array prototype object does not have a VALUEOF property of its
own; however, it inherits the VALUEOF property from the standard
built-in Object prototype Object.

Array.prototype.concat ( ...arguments )

When the CONCAT method is called with zero or more arguments, it returns
an array containing the array elements of the object followed by the
array elements of each argument in order.

The following steps are taken:

1.  Let _O_ be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(_O_).

3.  Let _A_ be UNDEFINED.

4.  If _O_ is an exotic Array object, then

    a.  Let _C_ be Get(_O_, "CONSTRUCTOR").

    b.  ReturnIfAbrupt(_C_).

    c.  If IsConstructor(_C_) is TRUE, then

        i.  Let _thisRealm_ be the running execution context’s Realm.

        ii. If SameValue(_thisRealm_ and GetFunctionRealm(_C_)) is TRUE,
            then

            1.  Let _A_ be the result of calling the [[Construct]]
                internal method of _C_ with argument (0).

5.  If _A_ is UNDEFINED, then

    a.  Let _A_ be ArrayCreate(0).

6.  ReturnIfAbrupt(_A_).

7.  Let _n_ be 0.

8.  Let _items_ be a List whose first element is _O_ and whose
    subsequent elements are, in left to right order, the arguments that
    were passed to this function invocation.

9.  Repeat, while _items_ is not empty

    a.  Remove the first element from _items_ and let _E_ be the value
        of the element.

    b.  Let _spreadable_ be IsConcatSpreadable(_E_).

    c.  ReturnIfAbrupt(_spreadable_).

    d.  If _spreadable_ is TRUE, then

        i.  Let _k_ be 0.

        ii. Let _lenVal_ be Get(_E_, "LENGTH").

        iii. Let _len_ be ToLength(_lenVal_).

        iv. ReturnIfAbrupt(_len_).

        v.  Repeat, while _k_ < _len_

            1.  Let _P_ be ToString(_k_).

            2.  Let _exists_ be HasProperty(_E_, _P_).

            3.  ReturnIfAbrupt(_exists_).

            4.  If _exists_ is TRUE, then

                a.  Let _subElement_ be Get(_E_, _P_).

                b.  ReturnIfAbrupt(_subElement_).

                c.  Let _status_ be CreateDataPropertyOrThrow (_A_,
                    ToString(_n_), _subElement_).

                d.  ReturnIfAbrupt(_status_).

            5.  Increase _n_ by 1.

            6.  Increase _k_ by 1.

    e.  Else _E_ is added as a single item rather than spread,

        i.  Let _status_ be CreateDataPropertyOrThrow (_A_,
            ToString(_n_), _E_).

        ii. ReturnIfAbrupt(_status_).

        iii. Increase _n_ by 1.

10. Let _putStatus_ be Put(_A_, "LENGTH", _n_, TRUE).

11. ReturnIfAbrupt(_putStatus_).

12. Return _A_.

The LENGTH property of the CONCAT method is 1.

NOTE 1 The explicit setting of the LENGTH property in step 10 is
necessary to ensure that its value is correct in situations where the
trailing elements of the result Array are not present.

NOTE 2 The CONCAT function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method.

IsConcatSpreadable ( O ) Abstract Operation

The abstract operation IsConcatSpreadable with argument _O_ performs the
following steps:

1.  If Type(_O_) is not Object, then return FALSE.

2.  Let _spreadable_ be Get(_O_, @@isConcatSpreadable).

3.  ReturnIfAbrupt(_spreadable_).

4.  If _spreadable_ is not UNDEFINED, then return
    ToBoolean(_spreadable_).

5.  If _O_ is an exotic Array object, then return TRUE.

6.  Return FALSE.

Array.prototype.constructor

The initial value of ARRAY.PROTOTYPE.CONSTRUCTOR is the standard
built-in ARRAY constructor.

Array.prototype.copyWithin (target, start [ , end ] )

The COPYWITHIN method takes up to three arguments _target_, _start_ and
_end_.

NOTE The _end_ argument is optional with the length of the THIS object
as its default value. If _target_ is negative, it is treated as
_length_+_target_ where _length_ is the length of the array. If _start
is negative, it is treated as _length_+_start_. If _end_ is negative, it
is treated as _length_+_end_.

The following steps are taken:

1.  Let _O_ be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(_O_).

3.  Let _lenVal_ be Get(_O_, "LENGTH").

4.  Let _len_ be ToLength(_lenVal_).

5.  ReturnIfAbrupt(_len_).

6.  Let _relativeTarget_ be ToInteger(_target_).

7.  ReturnIfAbrupt(_relativeTarget_).

8.  If _relativeTarget_ is negative, let _to_ be max((_len_ +
    _relativeTarget_),0); else let _to_ be min(_relativeTarget_, _len_).

9.  Let _relativeStart_ be ToInteger(_start_).

10. ReturnIfAbrupt(_relativeStart_).

11. If _relativeStart_ is negative, let _from_ be max((_len_ +
    _relativeStart_),0); else let _from_ be min(_relativeStart_, _len_).

12. If _end_ is UNDEFINED, let _relativeEnd_ be _len_; else let
    _relativeEnd_ be ToInteger(_end_).

13. ReturnIfAbrupt(_relativeEnd_).

14. If _relativeEnd_ is negative, let _final_ be max((_len_ +
    _relativeEnd_),0); else let _final_ be min(_relativeEnd_, _len_).

15. Let _count_ be min(_final_-_from_, _len_-_to_).

16. If _from_<_to_ and _to_<_from_+_count

    a.  Let _direction_ = -1.

    b.  Let _from_ = _from_ + _count_ -1.

    c.  Let _to_ = _to_ + _count_ -1.

17. Else,

    a.  Let _direction_ = 1.

18. Repeat, while _count_ > 

    a.  Let _fromKey_ be ToString(_from_).

    b.  Let _toKey_ be ToString(_to_).

    c.  Let _fromPresent_ be HasProperty(_O_, _fromKey_).

    d.  ReturnIfAbrupt(_fromPresent_).

    e.  If _fromPresent_ is TRUE, then

        i.  Let _fromVal_ be Get(_O_, _fromKey_).

        ii. ReturnIfAbrupt(_fromVal_).

        iii. Let _putStatus_ be Put(_O_, _toKey_, _fromVal_, TRUE).

        iv. ReturnIfAbrupt(_putStatus_).

    f.  Else _fromPresent_ is FALSE,

        i.  Let _deleteStatus_ be DeletePropertyOrThrow(_O_, _toKey_).

        ii. ReturnIfAbrupt(_deleteStatus_).

    g.  Let _from_ be _from_ + _direction_.

    h.  Let _to_ be _to_ + _direction_.

    i.  Let _count_ be _count_ − 1.

19. Return _O_.

The LENGTH property of the COPYWITHIN method is 2.

NOTE 1 The COPYWITHIN function is intentionally generic; it does not
require that its THIS value be an Array object. Therefore it can be
transferred to other kinds of objects for use as a method.

Array.prototype.entries ( )

The following steps are taken:

1.  Let _O_ be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(_O_).

3.  Return CreateArrayIterator(_O_, "KEY+VALUE").

Array.prototype.every ( callbackfn [ , thisArg] )

NOTE _callbackfn_ should be a function that accepts three arguments and
returns a value that is coercible to the Boolean value TRUE or FALSE.
EVERY calls _callbackfn_ once for each element present in the array, in
ascending order, until it finds one where _callbackfn_ returns FALSE. If
such an element is found, EVERY immediately returns FALSE. Otherwise, if
_callbackfn_ returned TRUE for all elements, EVERY will return TRUE.
_callbackfn_ is called only for elements of the array which actually
exist; it is not called for missing elements of the array.

If a _thisArg_ parameter is provided, it will be used as the THIS value
for each invocation of _callbackfn_. If it is not provided, UNDEFINED is
used instead.

_callbackfn_ is called with three arguments: the value of the element,
the index of the element, and the object being traversed.

EVERY does not directly mutate the object on which it is called but the
object may be mutated by the calls to _callbackfn_.

The range of elements processed by EVERY is set before the first call to
_callbackfn_. Elements which are appended to the array after the call to
EVERY begins will not be visited by _callbackfn_. If existing elements
of the array are changed, their value as passed to _callbackfn_ will be
the value at the time EVERY visits them; elements that are deleted after
the call to EVERY begins and before being visited are not visited. EVERY
acts like the "for all" quantifier in mathematics. In particular, for an
empty array, it returns TRUE.

When the EVERY method is called with one or two arguments, the following
steps are taken:

1.  Let _O_ be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(_O_).

3.  Let _lenValue_ be Get(_O_, "LENGTH")

4.  Let _len_ be ToLength(_lenValue_).

5.  ReturnIfAbrupt(_len_).

6.  If IsCallable(_callbackfn_) is FALSE, throw a TYPEERROR exception.

7.  If _thisArg_ was supplied, let _T_ be _thisArg_; else let _T_ be
    UNDEFINED.

8.  Let _k_ be 0.

9.  Repeat, while _k_ < _len

    a.  Let _Pk_ be ToString(_k_).

    b.  Let _kPresent_ be HasProperty(_O_, _Pk_).

    c.  ReturnIfAbrupt(_kPresent_).

    d.  If _kPresent_ is TRUE, then

        i.  Let _kValue_ be Get(_O_, _Pk_).

        ii. ReturnIfAbrupt(_kValue_).

        iii. Let _testResult_ be the result of calling the [[Call]]
            internal method of _callbackfn_ with _T_ as _thisArgument_
            and a List containing _kValue_, _k_, and _O_ as
            _argumentsList_.

        iv. ReturnIfAbrupt(_testResult_).

        v.  If ToBoolean(_testResult)_ is FALSE, return FALSE.

    e.  Increase _k_ by 1.

10. Return TRUE.

The LENGTH property of the EVERY method is 1.

NOTE The EVERY function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method.

Array.prototype.fill (value [ , start [ , end ] ] )

The FILL method takes up to three arguments _value_, _start_ and _end_.

NOTE The _start_ and _end_ arguments are optional with default values of
0 and the length of the THIS object. If _start_ is negative, it is
treated as _length_+_start_ where _length_ is the length of the array.
If _end_ is negative, it is treated as _length_+_end_.

The following steps are taken:

1.  Let _O_ be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(_O_).

3.  Let _lenVal_ be Get(_O_, "LENGTH").

4.  Let _len_ be ToLength(_lenVal_).

5.  ReturnIfAbrupt(_len_).

6.  Let _relativeStart_ be ToInteger(_start_).

7.  ReturnIfAbrupt(_relativeStart_).

8.  If _relativeStart_ is negative, let _k_ be max((_len_ +
    _relativeStart_),0); else let _k_ be min(_relativeStart_, _len_).

9.  If _end_ is UNDEFINED, let _relativeEnd_ be _len_; else let
    _relativeEnd_ be ToInteger(_end_).

10. ReturnIfAbrupt(_relativeEnd_).

11. If _relativeEnd_ is negative, let _final_ be max((_len_ +
    _relativeEnd_),0); else let _final_ be min(_relativeEnd_, _len_).

12. Repeat, while _k_ < _final

    a.  Let _Pk_ be ToString(_k_).

    b.  Let _putStatus_ be Put(_O_, _Pk_, _value_, TRUE).

    c.  ReturnIfAbrupt(_putStatus_).

    d.  Increase _k_ by 1.

13. Return _O_.

The LENGTH property of the FILL method is 1.

NOTE 1 The FILL function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method.

Array.prototype.filter ( callbackfn [ , thisArg ] )

NOTE _callbackfn_ should be a function that accepts three arguments and
returns a value that is coercible to the Boolean value TRUE or FALSE.
FILTER calls _callbackfn_ once for each element in the array, in
ascending order, and constructs a new array of all the values for which
_callbackfn_ returns TRUE. _callbackfn_ is called only for elements of
the array which actually exist; it is not called for missing elements of
the array.

If a _thisArg_ parameter is provided, it will be used as the THIS value
for each invocation of _callbackfn_. If it is not provided, UNDEFINED is
used instead.

_callbackfn_ is called with three arguments: the value of the element,
the index of the element, and the object being traversed.

FILTER does not directly mutate the object on which it is called but the
object may be mutated by the calls to _callbackfn_.

The range of elements processed by FILTER is set before the first call
to _callbackfn_. Elements which are appended to the array after the call
to FILTER begins will not be visited by _callbackfn_. If existing
elements of the array are changed their value as passed to _callbackfn_
will be the value at the time FILTER visits them; elements that are
deleted after the call to FILTER begins and before being visited are not
visited.

When the FILTER method is called with one or two arguments, the
following steps are taken:

1.  Let _O_ be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(_O_).

3.  Let _lenValue_ be Get(_O_, "LENGTH").

4.  Let _len_ be ToLength(_lenValue_).

5.  ReturnIfAbrupt(_len_).

6.  If IsCallable(_callbackfn_) is FALSE, throw a TYPEERROR exception.

7.  If _thisArg_ was supplied, let _T_ be _thisArg_; else let _T_ be
    UNDEFINED.

8.  Let _A_ be UNDEFINED.

9.  If _O_ is an exotic Array object, then

    a.  Let _C_ be Get(_O_, "CONSTRUCTOR").

    b.  ReturnIfAbrupt(_C_).

    c.  If IsConstructor(_C_) is TRUE, then

        i.  Let _thisRealm_ be the running execution context’s Realm.

        ii. If SameValue(_thisRealm_ and GetFunctionRealm(_C_)) is TRUE,
            then

            1.  Let _A_ be the result of calling the [[Construct]]
                internal method of _C_ with an argument list containing
                the single item 0.

10. If _A_ is UNDEFINED, then

    a.  Let _A_ be ArrayCreate(0).

11. ReturnIfAbrupt(_A_).

12. Let _k_ be 0.

13. Let _to_ be 0.

14. Repeat, while _k_ < _len

    a.  Let _Pk_ be ToString(_k_).

    b.  Let _kPresent_ be HasProperty(_O_, _Pk_).

    c.  ReturnIfAbrupt(_kPresent_).

    d.  If _kPresent_ is TRUE, then

        i.  Let _kValue_ be Get(_O_, _Pk_).

        ii. ReturnIfAbrupt(_kValue_).

        iii. Let _selected_ be the result of calling the [[Call]]
            internal method of _callbackfn_ with _T_ as _thisArgument_
            and a List containing _kValue_, _k_, and _O_ as
            _argumentsList_.

        iv. ReturnIfAbrupt(_selected_).

        v.  If ToBoolean(_selected_) is TRUE, then

            1.  Let _status_ be CreateDataPropertyOrThrow (_A_,
                ToString(_to_), _kValue_).

            2.  ReturnIfAbrupt(_status_).

            3.  Increase _to_ by 1.

    e.  Increase _k_ by 1.

15. Return _A_.

The LENGTH property of the FILTER method is 1.

NOTE The FILTER function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method.

Array.prototype.find ( predicate [ , thisArg ] )

NOTE _predicate_ should be a function that accepts three arguments and
returns a value that is coercible to the Boolean value TRUE or FALSE.
FIND calls _predicate_ once for each element present in the array, in
ascending order, until it finds one where _predicate_ returns TRUE. If
such an element is found, FIND immediately returns that element value.
Otherwise, FIND returns UNDEFINED. _predicate_ is called only for
elements of the array which actually exist; it is not called for missing
elements of the array.

If a _thisArg_ parameter is provided, it will be used as the THIS value
for each invocation of _predicate_. If it is not provided, UNDEFINED is
used instead.

_predicate_ is called with three arguments: the value of the element,
the index of the element, and the object being traversed.

FIND does not directly mutate the object on which it is called but the
object may be mutated by the calls to _predicate_.

The range of elements processed by FIND is set before the first call to
_callbackfn_. Elements that are appended to the array after the call to
FIND begins will not be visited by _callbackfn_. If existing elements of
the array are changed, their value as passed to _predicate_ will be the
value at the time that FIND visits them; elements that are deleted after
the call to FIND begins and before being visited are not visited.

When the FIND method is called with one or two arguments, the following
steps are taken:

1.  Let _O_ be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(_O_).

3.  Let _lenValue_ be Get(_O_, "LENGTH").

4.  Let _len_ be ToLength(_lenValue_).

5.  ReturnIfAbrupt(_len_).

6.  If IsCallable(_predicate_) is FALSE, throw a TYPEERROR exception.

7.  If _thisArg_ was supplied, let _T_ be _thisArg_; else let _T_ be
    UNDEFINED.

8.  Let _k_ be 0.

9.  Repeat, while _k_ < _len

    a.  Let _Pk_ be ToString(_k_).

    b.  Let _kPresent_ be HasProperty(_O_, _Pk_).

    c.  ReturnIfAbrupt(_kPresent_).

    d.  If _kPresent_ is TRUE, then

        i.  Let _kValue_ be Get(_O_, _Pk_).

        ii. ReturnIfAbrupt(_kValue_).

        iii. Let _testResult_ be the result of calling the [[Call]]
            internal method of _predicate_ with _T_ as _thisArgument_
            and a List containing _kValue_, _k_, and _O_ as
            _argumentsList_.

        iv. ReturnIfAbrupt(_testResult_).

        v.  If ToBoolean(_testResult)_ is TRUE, return _kValue_.

    e.  Increase _k_ by 1.

10. Return UNDEFINED.

The LENGTH property of the FIND method is 1.

NOTE The FIND function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method.

Array.prototype.findIndex ( predicate [ , thisArg ] )

NOTE _predicate_ should be a function that accepts three arguments and
returns a value that is coercible to the Boolean value TRUE or FALSE.
FINDINDEX calls _predicate_ once for each element present in the array,
in ascending order, until it finds one where _predicate_ returns TRUE.
If such an element is found, FINDINDEX immediately returns the index of
that element value. Otherwise, FINDINDEX returns -1. _predicate_ is
called only for elements of the array which actually exist; it is not
called for missing elements of the array.

If a _thisArg_ parameter is provided, it will be used as the THIS value
for each invocation of _predicate_. If it is not provided, UNDEFINED is
used instead.

_predicate_ is called with three arguments: the value of the element,
the index of the element, and the object being traversed.

FINDINDEX does not directly mutate the object on which it is called but
the object may be mutated by the calls to _predicate_.

The range of elements processed by FINDINDEX is set before the first
call to _callbackfn_. Elements that are appended to the array after the
call to FINDINDEX begins will not be visited by _callbackfn_. If
existing elements of the array are changed, their value as passed to
_predicate_ will be the value at the time that FINDINDEX visits them;
elements that are deleted after the call to FINDINDEX begins and before
being visited are not visited.

When the FINDINDEX method is called with one or two arguments, the
following steps are taken:

1.  Let _O_ be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(_O_).

3.  Let _lenValue_ be Get(_O_, "LENGTH").

4.  Let _len_ be ToLength(_lenValue_).

5.  ReturnIfAbrupt(_len_).

6.  If IsCallable(_predicate_) is FALSE, throw a TYPEERROR exception.

7.  If _thisArg_ was supplied, let _T_ be _thisArg_; else let _T_ be
    UNDEFINED.

8.  Let _k_ be 0.

9.  Repeat, while _k_ < _len

    a.  Let _Pk_ be ToString(_k_).

    b.  Let _kPresent_ be HasProperty(_O_, _Pk_).

    c.  ReturnIfAbrupt(_kPresent_).

    d.  If _kPresent_ is TRUE, then

        i.  Let _kValue_ be Get(_O_, _Pk_).

        ii. ReturnIfAbrupt(_kValue_).

        iii. Let _testResult_ be the result of calling the [[Call]]
            internal method of _predicate_ with _T_ as _thisArgument_
            and a List containing _kValue_, _k_, and _O_ as
            _argumentsList_.

        iv. ReturnIfAbrupt(_testResult_).

        v.  If ToBoolean(_testResult)_ is TRUE, return _k_.

    e.  Increase _k_ by 1.

10. Return -1.

The LENGTH property of the FINDINDEX method is 1.

NOTE The FINDINDEX function is intentionally generic; it does not
require that its THIS value be an Array object. Therefore it can be
transferred to other kinds of objects for use as a method.

Array.prototype.forEach ( callbackfn [ , thisArg ] )

NOTE _callbackfn_ should be a function that accepts three arguments.
FOREACH calls _callbackfn_ once for each element present in the array,
in ascending order. _callbackfn_ is called only for elements of the
array which actually exist; it is not called for missing elements of the
array.

If a _thisArg_ parameter is provided, it will be used as the THIS value
for each invocation of _callbackfn_. If it is not provided, UNDEFINED is
used instead.

_callbackfn_ is called with three arguments: the value of the element,
the index of the element, and the object being traversed.

FOREACH does not directly mutate the object on which it is called but
the object may be mutated by the calls to _callbackfn_.

The range of elements processed by FOREACH is set before the first call
to _callbackfn_. Elements which are appended to the array after the call
to FOREACH begins will not be visited by _callbackfn_. If existing
elements of the array are changed, their value as passed to callback
will be the value at the time FOREACH visits them; elements that are
deleted after the call to FOREACH begins and before being visited are
not visited.

When the FOREACH method is called with one or two arguments, the
following steps are taken:

1.  Let _O_ be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(_O_).

3.  Let _lenValue_ be Get(_O_, "LENGTH").

4.  Let _len_ be ToLength(_lenValue_).

5.  ReturnIfAbrupt(_len_).

6.  If IsCallable(_callbackfn_) is FALSE, throw a TYPEERROR exception.

7.  If _thisArg_ was supplied, let _T_ be _thisArg_; else let _T_ be
    UNDEFINED.

8.  Let _k_ be 0.

9.  Repeat, while _k_ < _len

    a.  Let _Pk_ be ToString(_k_).

    b.  Let _kPresent_ be HasProperty(_O_, _Pk_).

    c.  ReturnIfAbrupt(_kPresent_).

    d.  If _kPresent_ is TRUE, then

        i.  Let _kValue_ be Get(_O_, _Pk_).

        ii. ReturnIfAbrupt(_kValue_).

        iii. Let _funcResult_ be the result of calling the [[Call]]
            internal method of _callbackfn_ with _T_ as _thisArgument_
            and a List containing _kValue_, _k_, and _O_ as
            _argumentsList_.

        iv. ReturnIfAbrupt(_funcResult_).

    e.  Increase _k_ by 1.

10. Return UNDEFINED.

The LENGTH property of the FOREACH method is 1.

NOTE The FOREACH function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method.

Array.prototype.indexOf ( searchElement [ , fromIndex ] )

NOTE INDEXOF compares _searchElement_ to the elements of the array, in
ascending order, using the Strict Equality Comparison algorithm
(7.2.11), and if found at one or more positions, returns the index of
the first such position; otherwise, −1is returned.

The optional second argument _fromIndex_ defaults to 0 (i.e. the whole
array is searched). If it is greater than or equal to the length of the
array, −1is returned, i.e. the array will not be searched. If it is
negative, it is used as the offset from the end of the array to compute
_fromIndex_. If the computed index is less than 0, the whole array will
be searched.

When the INDEXOF method is called with one or two arguments, the
following steps are taken:

1.  Let _O_ be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(_O_).

3.  Let _lenValue_ be Get(_O_, "LENGTH")

4.  Let _len_ be ToLength(_lenValue_).

5.  ReturnIfAbrupt(_len_).

6.  If _len_ is 0, return −1.

7.  If argument _fromIndex_ was passed let _n_ be
    ToInteger(_fromIndex_); else let _n_ be 0.

8.  ReturnIfAbrupt(_n_).

9.  If _n_ ≥ _len_, return −1.

10. If _n_ ≥ 0, then

    a.  Let _k_ be _n_.

11. Else _n_<0,

    a.  Let _k_ be _len_ - abs(_n_).

    b.  If _k_ < 0, then let _k_ be 0.

12. Repeat, while _k_<_len

    a.  Let _kPresent_ be HasProperty(_O_, ToString(_k_)).

    b.  ReturnIfAbrupt(_kPresent_).

    c.  If _kPresent_ is TRUE, then

        i.  Let _elementK_ be the result of Get(_O_, ToString(_k_)).

        ii. ReturnIfAbrupt(_elementK_).

        iii. Let _same_ be the result of performing Strict Equality
            Comparison _searchElement_ === _elementK_.

        iv. If _same_ is TRUE, return _k_.

    d.  Increase _k_ by 1.

13. Return -1.

The LENGTH property of the INDEXOF method is 1.

NOTE The INDEXOF function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method.

Array.prototype.join (separator)

NOTE The elements of the array are converted to Strings, and these
Strings are then concatenated, separated by occurrences of the
_separator_. If no separator is provided, a single comma is used as the
separator.

The JOIN method takes one argument, _separator_, and performs the
following steps:

1.  Let _O_ be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(_O_).

3.  Let _lenVal_ be the result of Get(_O_, "LENGTH").

4.  Let _len_ be ToLength(_lenVal_).

5.  ReturnIfAbrupt(_len_).

6.  If _separator_ is UNDEFINED, let _separator_ be the single-element
    String ",".

7.  Let _sep_ be ToString(_separator_).

8.  If _len_ is zero, return the empty String.

9.  Let _element0_ be the result of Get(_O_, "0").

10. If _element0_ is UNDEFINED or NULL, let _R_ be the empty String;
    otherwise, let _R_ be ToString(_element0_).

11. ReturnIfAbrupt(_R_).

12. Let _k_ be 1.

13. Repeat, while _k_ < _len

    a.  Let _S_ be the String value produced by concatenating _R_ and
        _sep_.

    b.  Let _element_ be Get(_O_, ToString(_k_)).

    c.  If _element_ is UNDEFINED or NULL, then let _next_ be the empty
        String; otherwise, let _next_ be ToString(_element_).

    d.  ReturnIfAbrupt(_next_).

    e.  Let _R_ be a String value produced by concatenating _S_ and
        _next_.

    f.  Increase _k_ by 1.

14. Return _R_.

The LENGTH property of the JOIN method is 1.

NOTE The JOIN function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore, it can be transferred
to other kinds of objects for use as a method.

Array.prototype.keys ( )

The following steps are taken:

1.  Let _O_ be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(_O_).

3.  Return CreateArrayIterator(_O_, "KEY").

Array.prototype.lastIndexOf ( searchElement [ , fromIndex ] )

NOTE LASTINDEXOF compares _searchElement_ to the elements of the array
in descending order using the Strict Equality Comparison algorithm
(7.2.11), and if found at one or more positions, returns the index of
the last such position; otherwise, −1is returned.

The optional second argument _fromIndex_ defaults to the array's length
minus one (i.e. the whole array is searched). If it is greater than or
equal to the length of the array, the whole array will be searched. If
it is negative, it is used as the offset from the end of the array to
compute _fromIndex_. If the computed index is less than 0, −1is
returned.

When the LASTINDEXOF method is called with one or two arguments, the
following steps are taken:

1.  Let _O_ be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(_O_).

3.  Let _lenValue_ be Get(_O_, "LENGTH")

4.  Let _len_ be ToLength(_lenValue_).

5.  ReturnIfAbrupt(_len_).

6.  If _len_ is 0, return -1.

7.  If argument _fromIndex_ was passed let _n_ be
    ToInteger(_fromIndex_); else let _n_ be _len_-1.

8.  ReturnIfAbrupt(_n_).

9.  If _n_ ≥ 0, then let _k_ be min(_n_, _len_ – 1).

10. Else _n_ < 0,

    a.  Let _k_ be _len_ - abs(_n_).

11. Repeat, while _k_≥ 

    a.  Let _kPresent_ be HasProperty(_O_, ToString(_k_)).

    b.  ReturnIfAbrupt(_kPresent_).

    c.  If _kPresent_ is TRUE, then

        i.  Let _elementK_ be Get(_O_, ToString(_k_)).

        ii. ReturnIfAbrupt(_elementK_).

        iii. Let _same_ be the result of performing Strict Equality
            Comparison
            _searchElement_ === _elementK_.

        iv. If _same_ is TRUE, return _k_.

    d.  Decrease _k_ by 1.

12. Return -1.

The LENGTH property of the LASTINDEXOF method is 1.

NOTE The LASTINDEXOF function is intentionally generic; it does not
require that its THIS value be an Array object. Therefore it can be
transferred to other kinds of objects for use as a method.

Array.prototype.map ( callbackfn [ , thisArg ] )

NOTE _callbackfn_ should be a function that accepts three arguments. MAP
calls _callbackfn_ once for each element in the array, in ascending
order, and constructs a new Array from the results. _callbackfn_ is
called only for elements of the array which actually exist; it is not
called for missing elements of the array.

If a _thisArg_ parameter is provided, it will be used as the THIS value
for each invocation of _callbackfn_. If it is not provided, UNDEFINED is
used instead.

_callbackfn_ is called with three arguments: the value of the element,
the index of the element, and the object being traversed.

MAP does not directly mutate the object on which it is called but the
object may be mutated by the calls to _callbackfn_.

The range of elements processed by MAP is set before the first call to
_callbackfn_. Elements which are appended to the array after the call to
MAP begins will not be visited by _callbackfn_. If existing elements of
the array are changed, their value as passed to _callbackfn_ will be the
value at the time MAP visits them; elements that are deleted after the
call to MAP begins and before being visited are not visited.

When the MAP method is called with one or two arguments, the following
steps are taken:

1.  Let _O_ be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(_O_).

3.  Let _lenValue_ be Get(_O_, "LENGTH")

4.  Let _len_ be ToLength(_lenValue_).

5.  ReturnIfAbrupt(_len_).

6.  If IsCallable(_callbackfn_) is FALSE, throw a TYPEERROR exception.

7.  If _thisArg_ was supplied, let _T_ be _thisArg_; else let _T_ be
    UNDEFINED.

8.  Let _A_ be UNDEFINED.

9.  If _O_ is an exotic Array object, then

    a.  Let _C_ be Get(_O_, "CONSTRUCTOR").

    b.  ReturnIfAbrupt(_C_).

    c.  If IsConstructor(_C_) is TRUE, then

        i.  Let _thisRealm_ be the running execution context’s Realm.

        ii. If SameValue(_thisRealm_ and GetFunctionRealm(_C_)) is TRUE,
            then

            1.  Let _A_ be the result of calling the [[Construct]]
                internal method of _C_ with an argument list containing
                the single item _len_.

10. If _A_ is UNDEFINED, then

    a.  Let _A_ be ArrayCreate(_len_).

11. ReturnIfAbrupt(_A_).

12. Let _k_ be 0.

13. Repeat, while _k_ < _len

    a.  Let _Pk_ be ToString(_k_).

    b.  Let _kPresent_ be HasProperty(_O_, _Pk_).

    c.  ReturnIfAbrupt(_kPresent_).

    d.  If _kPresent_ is TRUE, then

        i.  Let _kValue_ be Get(_O_, _Pk_).

        ii. ReturnIfAbrupt(_kValue_).

        iii. Let _mappedValue_ be the result of calling the [[Call]]
            internal method of _callbackfn_ with _T_ as _thisArgument_
            and a List containing _kValue_, _k_, and _O_ as
            _argumentsList_.

        iv. ReturnIfAbrupt(_mappedValue_).

        v.  Let _status_ be CreateDataPropertyOrThrow (_A_, _Pk_,
            _mappedValue_).

        vi. ReturnIfAbrupt(_status_).

    e.  Increase _k_ by 1.

14. Return _A_.

The LENGTH property of the MAP method is 1.

NOTE The MAP function is intentionally generic; it does not require that
its THIS value be an Array object. Therefore it can be transferred to
other kinds of objects for use as a method.

Array.prototype.pop ( )

NOTE The last element of the array is removed from the array and
returned.

When the POP method is called the following steps are taken:

1.  Let _O_ be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(_O_).

3.  Let _lenVal_ be Get(_O_, "LENGTH").

4.  Let _len_ be ToLength(_lenVal_).

5.  ReturnIfAbrupt(_len_).

6.  If _len_ is zero,

    a.  Let _putStatus_ be Put(_O_, "LENGTH", 0, TRUE).

    b.  ReturnIfAbrupt(_putStatus_).

    c.  Return UNDEFINED.

7.  Else _len_ > 0,

    a.  Let _newLen_ be _len_–1.

    b.  Let _indx_ be ToString(_newLen_).

    c.  Let _element_ be Get(_O_, _indx_).

    d.  ReturnIfAbrupt(_element_).

    e.  Let _deleteStatus_ be DeletePropertyOrThrow(_O_, _indx_).

    f.  ReturnIfAbrupt(_deleteStatus_).

    g.  Let _putStatus_ be Put(_O_, "LENGTH", _newLen_, TRUE).

    h.  ReturnIfAbrupt(_putStatus_).

    i.  Return _element_.

NOTE The POP function is intentionally generic; it does not require that
its THIS value be an Array object. Therefore it can be transferred to
other kinds of objects for use as a method.

Array.prototype.push ( ...items )

NOTE The arguments are appended to the end of the array, in the order in
which they appear. The new length of the array is returned as the result
of the call.

When the PUSH method is called with zero or more arguments the following
steps are taken:

1.  Let _O_ be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(_O_).

3.  Let _lenVal_ be Get(_O_, "LENGTH").

4.  Let _n_ be ToLength(_lenVal_).

5.  ReturnIfAbrupt(_n_).

6.  Let _items_ be a List whose elements are, in left to right order,
    the arguments that were passed to this function invocation.

7.  Repeat, while _items_ is not empty

    a.  Remove the first element from _items_ and let _E_ be the value
        of the element.

    b.  Let _putStatus_ be Put(_O_, ToString(_n_), _E_, TRUE).

    c.  ReturnIfAbrupt(_putStatus_).

    d.  Increase _n_ by 1.

8.  Let _putStatus_ be Put(_O_, "LENGTH", _n_, TRUE).

9.  ReturnIfAbrupt(_putStatus_).

10. Return _n_.

The LENGTH property of the PUSH method is 1.

NOTE The PUSH function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method.

Array.prototype.reduce ( callbackfn [ , initialValue ] )

NOTE _callbackfn_ should be a function that takes four arguments. REDUCE
calls the callback, as a function, once for each element present in the
array, in ascending order.

_callbackfn_ is called with four arguments: the _previousValue_ (or
value from the previous call to _callbackfn_), the _currentValue_ (value
of the current element), the _currentIndex_, and the object being
traversed. The first time that callback is called, the _previousValue_
and _currentValue_ can be one of two values. If an _initialValue_ was
provided in the call to REDUCE, then _previousValue_ will be equal to
_initialValue_ and _currentValue_ will be equal to the first value in
the array. If no _initialValue_ was provided, then _previousValue_ will
be equal to the first value in the array and _currentValue_ will be
equal to the second. It is a TYPEERROR if the array contains no elements
and _initialValue_ is not provided.

REDUCE does not directly mutate the object on which it is called but the
object may be mutated by the calls to _callbackfn_.

The range of elements processed by REDUCE is set before the first call
to _callbackfn_. Elements that are appended to the array after the call
to REDUCE begins will not be visited by _callbackfn_. If existing
elements of the array are changed, their value as passed to _callbackfn_
will be the value at the time REDUCE visits them; elements that are
deleted after the call to REDUCE begins and before being visited are not
visited.

When the REDUCE method is called with one or two arguments, the
following steps are taken:

1.  Let _O_ be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(_O_).

3.  Let _lenValue_ be Get(_O_, "LENGTH").

4.  Let _len_ be ToLength(_lenValue_).

5.  ReturnIfAbrupt(_len_).

6.  If IsCallable(_callbackfn_) is FALSE, throw a TYPEERROR exception.

7.  If _len_ is 0 and _initialValue_ is not present, throw a TYPEERROR
    exception.

8.  Let _k_ be 0.

9.  If _initialValue_ is present, then

    a.  Set _accumulator_ to _initialValue_.

10. Else _initialValue_ is not present,

    a.  Let _kPresent_ be FALSE.

    b.  Repeat, while _kPresent_ is FALSE and _k_ < _len_

        i.  Let _Pk_ be ToString(_k_).

        ii. Let _kPresent_ be HasProperty(_O_, _Pk_).

        iii. ReturnIfAbrupt(_kPresent_).

        iv. If _kPresent_ is TRUE, then

            1.  Let _accumulator_ be Get(_O_, _Pk_).

            2.  ReturnIfAbrupt(_accumulator_).

        v.  Increase _k_ by 1.

    c.  If _kPresent_ is FALSE, throw a TYPEERROR exception.

11. Repeat, while _k_ < _len

    a.  Let _Pk_ be ToString(_k_).

    b.  Let _kPresent_ be HasProperty(_O_, _Pk_).

    c.  ReturnIfAbrupt(_kPresent_).

    d.  If _kPresent_ is TRUE, then

        i.  Let _kValue_ be Get(_O_, _Pk_).

        ii. ReturnIfAbrupt(_kValue_).

        iii. Let _accumulator_ be the result of calling the [[Call]]
            internal method of _callbackfn_ with UNDEFINED as
            _thisArgument_ and a List containing _accumulator_,
            _kValue_, _k_, and _O_ as _argumentsList_.

        iv. ReturnIfAbrupt(_accumulator_).

    e.  Increase _k_ by 1.

12. Return _accumulator_.

The LENGTH property of the REDUCE method is 1.

NOTE The REDUCE function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method.

Array.prototype.reduceRight ( callbackfn [ , initialValue ] )

NOTE _callbackfn_ should be a function that takes four arguments.
REDUCERIGHT calls the callback, as a function, once for each element
present in the array, in descending order.

_callbackfn_ is called with four arguments: the _previousValue_ (or
value from the previous call to _callbackfn_), the _currentValue_ (value
of the current element), the _currentIndex_, and the object being
traversed. The first time the function is called, the _previousValue_
and _currentValue_ can be one of two values. If an _initialValue_ was
provided in the call to REDUCERIGHT, then _previousValue_ will be equal
to _initialValue_ and _currentValue_ will be equal to the last value in
the array. If no _initialValue_ was provided, then _previousValue_ will
be equal to the last value in the array and _currentValue_ will be equal
to the second-to-last value. It is a TYPEERROR if the array contains no
elements and _initialValue_ is not provided.

REDUCERIGHT does not directly mutate the object on which it is called
but the object may be mutated by the calls to _callbackfn_.

The range of elements processed by REDUCERIGHT is set before the first
call to _callbackfn_. Elements that are appended to the array after the
call to REDUCERIGHT begins will not be visited by _callbackfn_. If
existing elements of the array are changed by _callbackfn_, their value
as passed to _callbackfn_ will be the value at the time REDUCERIGHT
visits them; elements that are deleted after the call to REDUCERIGHT
begins and before being visited are not visited.

When the REDUCERIGHT method is called with one or two arguments, the
following steps are taken:

1.  Let _O_ be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(_O_).

3.  Let _lenValue_ be Get(_O_, "LENGTH").

4.  Let _len_ be ToLength(_lenValue_).

5.  ReturnIfAbrupt(_len_).

6.  If IsCallable(_callbackfn_) is FALSE, throw a TYPEERROR exception.

7.  If _len_ is 0 and _initialValue_ is not present, throw a TYPEERROR
    exception.

8.  Let _k_ be _len_-1.

9.  If _initialValue_ is present, then

    a.  Set _accumulator_ to _initialValue_.

10. Else _initialValue_ is not present,

    a.  Let _kPresent_ be FALSE.

    b.  Repeat, while _kPresent_ is FALSE and _k_ ≥ 0

        i.  Let _Pk_ be ToString(_k_).

        ii. Let _kPresent_ be HasProperty(_O_, _Pk_).

        iii. ReturnIfAbrupt(_kPresent_).

        iv. If _kPresent_ is TRUE, then

            1.  Let _accumulator_ be Get(_O_, _Pk_).

            2.  ReturnIfAbrupt(_accumulator_).

        v.  Decrease _k_ by 1.

    c.  If _kPresent_ is FALSE, throw a TYPEERROR exception.

11. Repeat, while _k_ ≥ 

    a.  Let _Pk_ be ToString(_k_).

    b.  Let _kPresent_ be HasProperty(_O_, _Pk_).

    c.  ReturnIfAbrupt(_kPresent_).

    d.  If _kPresent_ is TRUE, then

        i.  Let _kValue_ be Get(_O_, _Pk_).

        ii. ReturnIfAbrupt(_kValue_).

        iii. Let _accumulator_ be the result of calling the [[Call]]
            internal method of _callbackfn_ with UNDEFINED as
            _thisArgument_ and a List containing _accumulator_,
            _kValue_, _k_, and _O_ as _argumentsList_.

        iv. ReturnIfAbrupt(_accumulator_).

    e.  Decrease _k_ by 1.

12. Return _accumulator_.

The LENGTH property of the REDUCERIGHT method is 1.

NOTE The REDUCERIGHT function is intentionally generic; it does not
require that its this value be an Array object. Therefore it can be
transferred to other kinds of objects for use as a method.

Array.prototype.reverse ( )

NOTE The elements of the array are rearranged so as to reverse their
order. The object is returned as the result of the call.

When the REVERSE method is called the following steps are taken:

1.  Let _O_ be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(_O_).

3.  Let _lenVal_ be Get(_O_, "LENGTH").

4.  Let _len_ be ToLength(_lenVal_).

5.  ReturnIfAbrupt(_len_).

6.  Let _middle_ be floor(_len_/2).

7.  Let _lower_ be 0.

8.  Repeat, while _lower_ ≠ _middle

    a.  Let _upper_ be _len_− _lower_ −1.

    b.  Let _upperP_ be ToString(_upper_).

    c.  Let _lowerP_ be ToString(_lower_).

    d.  Let _lowerExists_ be HasProperty(_O_, _lowerP_).

    e.  ReturnIfAbrupt(_lowerExists_).

    f.  If _lowerExists_ is TRUE, then

        i.  Let _lowerValue_ be Get(_O_, _lowerP_).

        ii. ReturnIfAbrupt(_lowerValue_).

    g.  Let _upperExists_ be HasProperty(_O_, _upperP_).

    h.  ReturnIfAbrupt(_upperExists_).

    i.  If _upperExists_ is TRUE, then

        i.  Let _upperValue_ be Get(_O_, _upper_).

        ii. ReturnIfAbrupt(_upperValue_).

    j.  k.  l.  m.  n.  If _lowerExists_ is TRUE and _upperExists_ is
        TRUE, then

        i.  Let _putStatus_ be Put(_O_, _lowerP_, _upperValue_, TRUE).

        ii. ReturnIfAbrupt(_putStatus_).

        iii. Let _putStatus_ be Put(_O_, _upperP_, _lowerValue_, TRUE).

        iv. ReturnIfAbrupt(_putStatus_).

    o.  Else if _lowerExists_ is FALSE and _upperExists_ is TRUE, then

        i.  Let _putStatus_ be Put(_O_, _lowerP_, _upperValue_, TRUE).

        ii. ReturnIfAbrupt(_putStatus_).

        iii. Let _deleteStatus_ be DeletePropertyOrThrow (_O_,
            _upperP_).

        iv. ReturnIfAbrupt(_deleteStatus_).

    p.  Else if _lowerExists_ is TRUE and _upperExists_ is FALSE, then

        i.  Let _deleteStatus_ be DeletePropertyOrThrow (_O_, _lowerP_).

        ii. ReturnIfAbrupt(_deleteStatus_).

        iii. Let _putStatus_ be Put(_O_, _upperP_, _lowerValue_, TRUE).

        iv. ReturnIfAbrupt(_putStatus_).

    q.  Else both _lowerExists_ and _upperExists_ are FALSE,

        i.  No action is required.

    r.  Increase _lower_ by 1.

9.  Return _O_ .

NOTE The REVERSE function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore, it can be transferred
to other kinds of objects for use as a method.

Array.prototype.shift ( )

NOTE The first element of the array is removed from the array and
returned.

When the SHIFT method is called the following steps are taken:

1.  Let _O_ be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(_O_).

3.  Let _lenVal_ be Get(_O_, "LENGTH").

4.  Let _len_ be ToLength(_lenVal_).

5.  ReturnIfAbrupt(_len_).

6.  If _len_ is zero, then

    a.  Let _putStatus_ be Put(_O_, "LENGTH", 0, TRUE).

    b.  ReturnIfAbrupt(_putStatus_).

    c.  Return UNDEFINED.

7.  Let _first_ be Get(_O_, "0").

8.  ReturnIfAbrupt(_first_).

9.  Let _k_ be 1.

10. Repeat, while _k_ < _len

    a.  Let _from_ be ToString(_k_).

    b.  Let _to_ be ToString(_k_–1).

    c.  Let _fromPresent_ be HasProperty(_O_, _from_).

    d.  ReturnIfAbrupt(_fromPresent_).

    e.  If _fromPresent_ is TRUE, then

        i.  Let _fromVal_ be Get(_O_, _from_).

        ii. ReturnIfAbrupt(_fromVal_).

        iii. Let _putStatus_ be Put(_O_, _to_, _fromVal_, TRUE).

        iv. ReturnIfAbrupt(_putStatus_).

    f.  Else _fromPresent_ is FALSE,

        i.  Let _deleteStatus_ be DeletePropertyOrThrow(_O_, _to_).

        ii. ReturnIfAbrupt(_deleteStatus_).

    g.  Increase _k_ by 1.

11. Let _deleteStatus_ be DeletePropertyOrThrow(_O_, ToString(_len_–1)).

12. ReturnIfAbrupt(_deleteStatus_).

13. Let _putStatus_ be Put(_O_, "LENGTH", _len_–1, TRUE).

14. ReturnIfAbrupt(_putStatus_).

15. Return _first_.

NOTE The SHIFT function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method.

Array.prototype.slice (start, end)

NOTE The SLICE method takes two arguments, _start_ and _end_, and
returns an array containing the elements of the array from element
_start_ up to, but not including, element _end_ (or through the end of
the array if _end_ is UNDEFINED). If _start_ is negative, it is treated
as _length_+_start_ where _length_ is the length of the array. If _end_
is negative, it is treated as _length_+_end_ where _length_ is the
length of the array.

The following steps are taken:

1.  Let _O_ be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(_O_).

3.  Let _lenVal_ be Get(_O_, "LENGTH").

4.  Let _len_ be ToLength(_lenVal_).

5.  ReturnIfAbrupt(_len_).

6.  Let _relativeStart_ be ToInteger(_start_).

7.  ReturnIfAbrupt(_relativeStart_).

8.  If _relativeStart_ is negative, let _k_ be max((_len_ +
    _relativeStart_),0); else let _k_ be min(_relativeStart_, _len_).

9.  If _end_ is UNDEFINED, let _relativeEnd_ be _len_; else let
    _relativeEnd_ be ToInteger(_end_).

10. ReturnIfAbrupt(_relativeEnd_).

11. If _relativeEnd_ is negative, let _final_ be max((_len_ +
    _relativeEnd_),0); else let _final_ be min(_relativeEnd_, _len_).

12. Let _count_ be max(_final_ – _k_, 0).

13. Let _A_ be UNDEFINED.

14. If _O_ is an exotic Array object, then

    a.  Let _C_ be Get(_O_, "CONSTRUCTOR").

    b.  ReturnIfAbrupt(_C_).

    c.  If IsConstructor(_C_) is TRUE, then

        i.  Let _thisRealm_ be the running execution context’s Realm.

        ii. If SameValue(_thisRealm_ and GetFunctionRealm(_C_)) is TRUE,
            then

            1.  Let _A_ be the result of calling the [[Construct]]
                internal method of _C_ with argument (_count_).

15. If _A_ is UNDEFINED, then

    a.  Let _A_ be ArrayCreate(_count_).

16. ReturnIfAbrupt(_A_).

17. Let _n_ be 0.

18. Repeat, while _k_ < _final

    a.  Let _Pk_ be ToString(_k_).

    b.  Let _kPresent_ be HasProperty(_O_, _Pk_).

    c.  ReturnIfAbrupt(_kPresent_).

    d.  If _kPresent_ is TRUE, then

        i.  Let _kValue_ be Get(_O_, _Pk_).

        ii. ReturnIfAbrupt(_kValue_).

        iii. Let _status_ be CreateDataPropertyOrThrow(_A_,
            ToString(_n_), _kValue_ ).

        iv. ReturnIfAbrupt(_status_).

    e.  Increase _k_ by 1.

    f.  Increase _n_ by 1.

19. Let _putStatus_ be Put(_A_, "LENGTH", _n_, TRUE).

20. ReturnIfAbrupt(_putStatus_).

21. Return _A_.

The LENGTH property of the SLICE method is 2.

NOTE 1 The explicit setting of the LENGTH property of the result Array
in step 19 is necessary to ensure that its value is correct in
situations where the trailing elements of the result Array are not
present.

NOTE 2 The SLICE function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method.

Array.prototype.some ( callbackfn [ , thisArg ] )

NOTE _callbackfn_ should be a function that accepts three arguments and
returns a value that is coercible to the Boolean value TRUE or FALSE.
SOME calls _callbackfn_ once for each element present in the array, in
ascending order, until it finds one where _callbackfn_ returns TRUE. If
such an element is found, SOME immediately returns TRUE. Otherwise, SOME
returns FALSE. _callbackfn_ is called only for elements of the array
which actually exist; it is not called for missing elements of the
array.

If a _thisArg_ parameter is provided, it will be used as the THIS value
for each invocation of _callbackfn_. If it is not provided, UNDEFINED is
used instead.

_callbackfn_ is called with three arguments: the value of the element,
the index of the element, and the object being traversed.

SOME does not directly mutate the object on which it is called but the
object may be mutated by the calls to _callbackfn_.

The range of elements processed by SOME is set before the first call to
_callbackfn_. Elements that are appended to the array after the call to
SOME begins will not be visited by _callbackfn_. If existing elements of
the array are changed, their value as passed to _callbackfn_ will be the
value at the time that SOME visits them; elements that are deleted after
the call to SOME begins and before being visited are not visited. SOME
acts like the "exists" quantifier in mathematics. In particular, for an
empty array, it returns FALSE.

When the SOME method is called with one or two arguments, the following
steps are taken:

1.  Let _O_ be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(_O_).

3.  Let _lenValue_ be Get(_O_, "LENGTH").

4.  Let _len_ be ToLength(_lenValue_).

5.  ReturnIfAbrupt(_len_).

6.  If IsCallable(_callbackfn_) is FALSE, throw a TYPEERROR exception.

7.  If _thisArg_ was supplied, let _T_ be _thisArg_; else let _T_ be
    UNDEFINED.

8.  Let _k_ be 0.

9.  Repeat, while _k_ < _len

    a.  Let _Pk_ be ToString(_k_).

    b.  Let _kPresent_ be HasProperty(_O_, _Pk_).

    c.  ReturnIfAbrupt(_kPresent_).

    d.  If _kPresent_ is TRUE, then

        i.  Let _kValue_ be Get(_O_, _Pk_).

        ii. ReturnIfAbrupt(_kValue_).

        iii. Let _testResult_ be the result of calling the [[Call]]
            internal method of _callbackfn_ with _T_ as _thisArgument_
            and a List containing _kValue_, _k_, and _O_ as
            _argumentsList_.

        iv. ReturnIfAbrupt(_testResult_).

        v.  If ToBoolean(_testResult)_ is TRUE, return TRUE.

    e.  Increase _k_ by 1.

10. Return FALSE.

The LENGTH property of the SOME method is 1.

NOTE The SOME function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method.

Array.prototype.sort (comparefn)

The elements of this array are sorted. The sort is not necessarily
stable (that is, elements that compare equal do not necessarily remain
in their original order). If _comparefn_ is not UNDEFINED, it should be
a function that accepts two arguments _x_ and _y_ and returns a negative
value if _x_ < _y_, zero if _x_ = _y_, or a positive value if _x_ > _y_.

Upon entry, the following steps are performed to initialize evaluation
of the SORT function:

1.  Let _obj_ be the result of calling ToObject passing the THIS value
    as the argument.

2.  Let _lenValue_ be Get(_obj_, "LENGTH").

3.  Let _len_ be ToLength(_lenValue_).

4.  ReturnIfAbrupt(_len_).

The result of the SORT function is then determined as follows:

If _comparefn_ is not UNDEFINED and is not a consistent comparison
function for the elements of this array (see below), the behaviour of
SORT is implementation-defined.

Let _proto_ be the result of calling the [[GetPrototypeOf]] internal
method of _obj_. If _proto_ is not NULL and there exists an integer _j_
such that all of the conditions below are satisfied then the behaviour
of SORT is implementation-defined:

-   _obj_ is sparse (22.1)

-   0 ≤ _j_ < _len_

-   The result of HasProperty(_proto_, ToString(_j_)) is TRUE.

The behaviour of SORT is also implementation defined if _obj_ is sparse
and any of the following conditions are true:

-   The result of the predicate IsExtensible(_obj_) is FALSE.

-   Any array index property of _obj_ whose name is a nonnegative
    integer less than _len_ is a data property whose [[Configurable]]
    attribute is FALSE.

The behaviour of SORT is also implementation defined if any array index
property of _obj_ whose name is a nonnegative integer less than _len_ is
an accessor property or is a data property whose [[Writable]] attribute
is FALSE.

Otherwise, the following steps are taken:

1.  Perform an implementation-dependent sequence of calls to the [[Get]]
    and [[Set]] internal methods of _obj_, to the DeletePropertyOrThrow
    abstract operation with _obj_ as the first argument, and to
    SortCompare (described below), where the property key argument for
    each call to [[Get]], [[Set]], or DeletePropertyOrThrow is the
    string representation of a nonnegative integer less than _len_ and
    where the arguments for calls to SortCompare are results of previous
    calls to the [[Get]] internal method. If _obj_ is not sparse then
    DeletePropertyOrThrow must not be called. If any [[Set]] call
    returns FALSE a TYPEERROR exception is thrown. If an abrupt
    completion is returned from any of these operations, it is
    immediately returned as the value of this function.

2.  Return _obj_.

The returned object must have the following two characteristics:

-   There must be some mathematical permutation π of the nonnegative
    integers less than _len_, such that for every nonnegative integer
    _j_ less than _len_, if property old[_j_] existed, then new[π(_j_)]
    is exactly the same value as old[_j_],. But if property old[_j_] did
    not exist, then new[π(_j_)] does not exist.

-   Then for all nonnegative integers _j_ and _k_, each less than _len_,
    if SortCompare(_j_,_k_) < 0 (see SortCompare below), then Π(_j_) <
    Π(_k_).

Here the notation old[_j_] is used to refer to the hypothetical result
of calling the [[Get]] internal method of _obj_ with argument _j_ before
this function is executed, and the notation new[_j_] to refer to the
hypothetical result of calling the [[Get]] internal method of _obj_ with
argument _j_ after this function has been executed.

A function _comparefn_ is a consistent comparison function for a set of
values _S_ if all of the requirements below are met for all values _a_,
_b_, and _c_ (possibly the same value) in the set _S_: The notation
_a_ <~CF~ _b_ means _comparefn_(_a_,_b_) < 0; _a_ =~CF~ _b_ means
_comparefn_(_a_,_b_) = 0 (of either sign); and _a_ >~CF~ _b_ means
_comparefn_(_a_,_b_) > 0.

-   Calling _comparefn_(_a_,_b_) always returns the same value _v_ when
    given a specific pair of values _a_ and _b_ as its two arguments.
    Furthermore, Type(_v_) is Number, and _v_ is not NaN. Note that this
    implies that exactly one of _a_ <~CF~ _b_, _a_ =~CF~ _b_, and
    _a_ >~CF~ _b_ will be true for a given pair of _a_ and _b_.

-   Calling _comparefn_(_a_,_b_) does not modify _obj_.

-   _a_ =~CF~ _a_ (reflexivity)

-   If _a_ =~CF~ _b_, then _b_ =~CF~ _a_ (symmetry)

-   If _a_ =~CF~ _b_ and _b_ =~CF~ _c_, then _a_ =~CF~ _c_ (transitivity
    of =~CF~)

-   If _a_ <~CF~ _b_ and _b_ <~CF~ _c_, then _a_ <~CF~ _c_ (transitivity
    of <~CF~)

-   If _a_ >~CF~ _b_ and _b_ >~CF~ _c_, then _a_ >~CF~ _c_ (transitivity
    of >~CF~)

NOTE 1 The above conditions are necessary and sufficient to ensure that
_comparefn_ divides the set _S_ into equivalence classes and that these
equivalence classes are totally ordered.

NOTE 2 The SORT function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore, it can be transferred
to other kinds of objects for use as a method.

Runtime Semantics: SortCompare Abstract Operation

When the SortCompare abstract operation is called with two arguments _j_
and _k_, the following steps are taken:

1.  Let _jString_ be ToString(_j_).

2.  Let _kString_ be ToString(_k_).

3.  Let _hasj_ be HasProperty(_obj_, _jString_).

4.  ReturnIfAbrupt(_hasj_).

5.  Let _hask_ be HasProperty(_obj_, _kString_).

6.  ReturnIfAbrupt(_hask_).

7.  If _hasj_ and _hask_ are both FALSE, then return +0.

8.  If _hasj_ is FALSE, then return 1.

9.  If _hask_ is FALSE, then return –1.

10. Let _x_ be Get(_obj_,_jString_).

11. ReturnIfAbrupt(_x_).

12. Let _y_ be Get(_obj_, _kString_).

13. ReturnIfAbrupt(_y_).

14. If _x_ and _y_ are both UNDEFINED, return +0.

15. If _x_ is UNDEFINED, return 1.

16. If _y_ is UNDEFINED, return −1.

17. If the argument _comparefn_ is not UNDEFINED, then

    a.  If IsCallable(_comparefn_) is FALSE, throw a TYPEERROR
        exception.

    b.  Let _v_ be the result of calling the [[Call]] internal method of
        _comparefn_ passing UNDEFINED as _thisArgument_ and with a List
        containing the values of _x_ and _y_ as the _argumentsList_.

    c.  ReturnIfAbrupt(_v_).

    d.  If _v_ is NAN, then return +0.

    e.  Return _v_.

18. Let _xString_ be ToString(_x_).

19. ReturnIfAbrupt(_xString_).

20. Let _yString_ be ToString(_y_).

21. ReturnIfAbrupt(_yString_).

22. If _xString_ < _yString_, return −1.

23. If _xString_ > _yString_, return 1.

24. Return +0.

NOTE Because non-existent property values always compare greater than
UNDEFINED property values, and UNDEFINED always compares greater than
any other value, UNDEFINED property values always sort to the end of the
result, followed by non-existent property values.

Array.prototype.splice (start, deleteCount , ...items )

NOTE When the SPLICE method is called with two or more arguments
_start_, _deleteCount_ and zero or more _items_,., the _deleteCount
elements of the array starting at integer index _start_ are replaced by
the arguments _items_,. An Array object containing the deleted elements
(if any) is returned.

The following steps are taken:

1.  Let _O_ be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(_O_).

3.  Let _lenVal_ be Get(_O_, "LENGTH")

4.  Let _len_ be ToLength(_lenVal_).

5.  ReturnIfAbrupt(_len_).

6.  Let _relativeStart_ be ToInteger(_start_).

7.  ReturnIfAbrupt(_relativeStart_).

8.  If _relativeStart_ is negative, let _actualStart_ be max((_len_ +
    _relativeStart_),0); else let _actualStart_ be min(_relativeStart_,
    _len_).

9.  If the number of actual arguments is 0, then

    a.  Let _actualDeleteCount_ be 0.

10. Else if the number of actual arguments is 1, then

    a.  Let _actualDeleteCount_ be _len_ - _actualStart_

11. Else,

    a.  Let _dc_ be ToInteger(_deleteCount_).

    b.  ReturnIfAbrupt(_dc_).

    c.  Let _actualDeleteCount_ be min(max(_dc_,0), _len_ –
        _actualStart_).

12. Let _A_ be UNDEFINED.

13. If _O_ is an exotic Array object, then

    a.  Let _C_ be Get(_O_, "CONSTRUCTOR").

    b.  ReturnIfAbrupt(_C_).

    c.  If IsConstructor(_C_) is TRUE, then

        i.  Let _thisRealm_ be the running execution context’s Realm.

        ii. If SameValue(_thisRealm_ and GetFunctionRealm(_C_)) is TRUE,
            then

            1.  Let _A_ be the result of calling the [[Construct]]
                internal method of _C_ with argument
                (_actualDeleteCount_).

14. If _A_ is UNDEFINED, then

    a.  Let _A_ be ArrayCreate(_actualDeleteCount_).

15. ReturnIfAbrupt(_A_).

16. Let _k_ be 0.

17. Repeat, while _k_ < _actualDeleteCount

    a.  Let _from_ be ToString(_actualStart_+_k_).

    b.  Let _fromPresent_ be HasProperty(_O_, _from_).

    c.  ReturnIfAbrupt(_fromPresent_).

    d.  If _fromPresent_ is TRUE, then

        i.  Let _fromValue_ be Get(_O,_ _from_).

        ii. ReturnIfAbrupt(_fromValue_).

        iii. Let _status_ be CreateDataPropertyOrThrow(_A_,
            ToString(_k_), _fromValue_).

        iv. ReturnIfAbrupt(_status_).

    e.  Increment _k_ by 1.

18. Let _putStatus_ be Put(_A_, "LENGTH", _actualDeleteCount_, TRUE).

19. ReturnIfAbrupt(_putStatus_).

20. Let _items_ be a List whose elements are, in left to right order,
    the portion of the actual argument list starting with the third
    argument. The list will be empty fewer than three arguments were
    passed.

21. Let _itemCount_ be the number of elements in _items_.

22. If _itemCount_ < _actualDeleteCount_, then

    a.  Let _k_ be _actualStart_.

    b.  Repeat, while _k_ < (_len_ – _actualDeleteCount_)

        i.  Let _from_ be ToString(_k_+_actualDeleteCount_).

        ii. Let _to_ be ToString(_k_+_itemCount_).

        iii. Let _fromPresent_ be HasProperty(_O_, _from_).

        iv. ReturnIfAbrupt(_fromPresent_).

        v.  If _fromPresent_ is TRUE, then

            1.  Let _fromValue_ be Get(_O_, _from_).

            2.  ReturnIfAbrupt(_fromValue_).

            3.  Let _putStatus_ be Put(_O_, _to_, _fromValue_, TRUE).

            4.  ReturnIfAbrupt(_putStatus_).

        vi. Else _fromPresent_ is FALSE,

            1.  Let _deleteStatus_ be DeletePropertyOrThrow(_O_, _to_).

            2.  ReturnIfAbrupt(_deleteStatus_).

        vii. Increase _k_ by 1.

    c.  Let _k_ be _len_.

    d.  Repeat, while _k_ > (_len_ – _actualDeleteCount_ + _itemCount_)

        i.  Let _deleteStatus_ be DeletePropertyOrThrow(_O_,
            ToString(_k_–1)).

        ii. ReturnIfAbrupt(_deleteStatus_).

        iii. Decrease _k_ by 1.

23. Else if _itemCount_ > _actualDeleteCount_, then

    a.  Let _k_ be (_len_ – _actualDeleteCount_).

    b.  Repeat, while _k_ > _actualStart_

        i.  Let _from_ be ToString(_k_ + _actualDeleteCount_ – 1).

        ii. Let _to_ be ToString(_k_ + _itemCount_ – 1)

        iii. Let _fromPresent_ be HasProperty(_O_, _from_).

        iv. ReturnIfAbrupt(_fromPresent_).

        v.  If _fromPresent_ is TRUE, then

            1.  Let _fromValue_ be Get(_O_, _from_).

            2.  ReturnIfAbrupt(_fromValue_).

            3.  Let _putStatus_ be Put(_O_, _to_, _fromValue_, TRUE).

            4.  ReturnIfAbrupt(_putStatus_).

        vi. Else _fromPresent_ is FALSE,

            1.  Let _deleteStatus_ be DeletePropertyOrThrow(_O_, _to_).

            2.  ReturnIfAbrupt(_deleteStatus_).

        vii. Decrease _k_ by 1.

24. Let _k_ be _actualStart_.

25. Repeat, while _items_ is not empty

    a.  Remove the first element from _items_ and let _E_ be the value
        of that element.

    b.  Let _putStatus_ be Put(_O_, ToString(_k_), _E_, TRUE).

    c.  ReturnIfAbrupt(_putStatus_).

    d.  Increase _k_ by 1.

26. Let _putStatus_ be Put(_O_, "LENGTH", _len_ – _actualDeleteCount_ +
    _itemCount_, TRUE).

27. ReturnIfAbrupt(_putStatus_).

28. Return _A_.

The LENGTH property of the SPLICE method is 2.

NOTE 1 The explicit setting of the LENGTH property of the result Array
in step 18 is necessary to ensure that its value is correct in
situations where its trailing elements are not present.

NOTE 2 The SPLICE function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method.

Array.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] )

An ECMAScript implementation that includes the ECMA-402
Internationalization API must implement the
ARRAY.PROTOTYPE.TOLOCALESTRING method as specified in the ECMA-402
specification. If an ECMAScript implementation does not include the
ECMA-402 API the following specification of the TOLOCALESTRING method is
used.

NOTE The first edition of ECMA-402 did not include a replacement
specification for the ARRAY.PROTOTYPE.TOLOCALESTRING method.

The meanings of the optional parameters to this method are defined in
the ECMA-402 specification; implementations that do not include ECMA-402
support must not use those parameter positions for anything else.

The following steps are taken:

1.  Let _array_ be the result of calling ToObject passing the THIS value
    as the argument.

2.  ReturnIfAbrupt(_array_).

3.  Let _arrayLen_ be Get(_array_, "LENGTH").

4.  Let _len_ be ToLength(_arrayLen_).

5.  ReturnIfAbrupt(_len_).

6.  Let _separator_ be the String value for the list-separator String
    appropriate for the host environment’s current locale (this is
    derived in an implementation-defined way).

7.  If _len_ is zero, return the empty String.

8.  Let _firstElement_ be Get(_array_, "0").

9.  ReturnIfAbrupt(_firstElement_).

10. If _firstElement_ is UNDEFINED or NULL, then

    a.  Let _R_ be the empty String.

11. Else

    a.  Let _R_ be Invoke(_firstElement_, "TOLOCALESTRING").

    b.  Let _R_ be ToString(_R_).

    c.  ReturnIfAbrupt(_R_).

12. Let _k_ be 1.

13. Repeat, while _k_ < _len

    a.  Let _S_ be a String value produced by concatenating _R_ and
        _separator_.

    b.  Let _nextElement_ be Get(_array_, ToString(_k_)).

    c.  ReturnIfAbrupt(_nextElement_).

    d.  If _nextElement_ is UNDEFINED or NULL, then

        i.  Let _R_ be the empty String.

    e.  Else

        i.  Let _R_ be Invoke(_nextElement_, "TOLOCALESTRING").

        ii. Let _R_ be ToString(_R_).

        iii. ReturnIfAbrupt(_R_).

    f.  Let _R_ be a String value produced by concatenating _S_ and _R_.

    g.  Increase _k_ by 1.

14. Return _R_.

NOTE 1 The elements of the array are converted to Strings using their
TOLOCALESTRING methods, and these Strings are then concatenated,
separated by occurrences of a separator String that has been derived in
an implementation-defined locale-specific way. The result of calling
this function is intended to be analogous to the result of TOSTRING,
except that the result of this function is intended to be
locale-specific.

NOTE 2 The TOLOCALESTRING function is intentionally generic; it does not
require that its THIS value be an Array object. Therefore it can be
transferred to other kinds of objects for use as a method.

Array.prototype.toString ( )

When the TOSTRING method is called, the following steps are taken:

1.  Let _array_ be the result of calling ToObject on the THIS value.

2.  ReturnIfAbrupt(_array_).

3.  Let _func_ be Get(_array_, "JOIN").

4.  ReturnIfAbrupt(_func_).

5.  If IsCallable(_func_) is FALSE, then let _func_ be the intrinsic
    function %ObjProto_toString% (19.1.3.6).

6.  Return the result of calling the [[Call]] internal method of _func
    providing _array_ as _thisArgument_ and an empty List as
    _argumentsList_.

NOTE The TOSTRING function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method.

Array.prototype.unshift ( ...items )

NOTE The arguments are prepended to the start of the array, such that
their order within the array is the same as the order in which they
appear in the argument list.

When the UNSHIFT method is called with zero or more arguments _item1_,
_item2_, etc., the following steps are taken:

1.  Let _O_ be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(_O_).

3.  Let _lenVal_ be Get(_O_, "LENGTH")

4.  Let _len_ be ToLength(_lenVal_).

5.  ReturnIfAbrupt(_len_).

6.  Let _argCount_ be the number of actual arguments.

7.  If _argCount_ > 0, then

    a.  Let _k_ be _len_.

    b.  Repeat, while _k_ > 0,

        i.  Let _from_ be ToString(_k_–1).

        ii. Let _to_ be ToString(_k_+_argCount_ –1).

        iii. Let _fromPresent_ be HasProperty(_O_, _from_).

        iv. ReturnIfAbrupt(_fromPresent_).

        v.  If _fromPresent_ is TRUE, then

            1.  Let _fromValue_ be the result of Get(_O_, _from_).

            2.  ReturnIfAbrupt(_fromValue_).

            3.  Let _putStatus_ be Put(_O_, _to_, _fromValue_, TRUE).

            4.  ReturnIfAbrupt(_putStatus_).

        vi. Else _fromPresent_ is FALSE,

            1.  Let _deleteStatus_ be DeletePropertyOrThrow(_O_, _to_).

            2.  ReturnIfAbrupt(_deleteStatus_).

        vii. Decrease _k_ by 1.

    c.  Let _j_ be 0.

    d.  Let _items_ be a List whose elements are, in left to right
        order, the arguments that were passed to this function
        invocation.

    e.  Repeat, while _items_ is not empty

        i.  Remove the first element from _items_ and let _E_ be the
            value of that element.

        ii. Let _putStatus_ be Put(_O_, ToString(_j_), _E_, TRUE).

        iii. ReturnIfAbrupt(_putStatus_).

        iv. Increase _j_ by 1.

8.  Let _putStatus_ be Put(_O_, "LENGTH", _len_+_argCount_, TRUE).

9.  ReturnIfAbrupt(_putStatus_).

10. Return _len_+_argCount_.

The LENGTH property of the UNSHIFT method is 1.

NOTE The UNSHIFT function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method.

Array.prototype.values ( )

The following steps are taken:

1.  Let _O_ be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(_O_).

3.  Return CreateArrayIterator(_O_, "VALUE").

This function is the %ArrayProto_values% intrinsic object.

Array.prototype [ @@iterator ] ( )

The initial value of the @@iterator property is the same function object
as the initial value of the ARRAY.PROTOTYPE.VALUES property.

Array.prototype [ @@unscopables ]

The initial value of the @@unscopables data property is an object
created by the following steps:

1.  Let _blackList_ be ObjectCreate(%ObjectPrototype%).

2.  Perform CreateDataProperty(_blackList_, "COPYWITHIN", TRUE).

3.  Perform CreateDataProperty(_blackList_, "ENTRIES", TRUE).

4.  Perform CreateDataProperty(_blackList_, "FILL", TRUE).

5.  Perform CreateDataProperty(_blackList_, "FIND", TRUE).

6.  Perform CreateDataProperty(_blackList_, "FINDINDEX", TRUE).

7.  8.  9.  10. Perform CreateDataProperty(_blackList_, "KEYS", TRUE).

11. Perform CreateDataProperty(_blackList_, "VALUES", TRUE).

12. Assert: Each of the above calls will return TRUE.

13. Return _blackList_.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

NOTE The own property names of this object are property names that were
not included as standard properties of ARRAY.PROTOTYPE prior to the
sixth edition of this specification. These names are ignored for WITH
statement binding purposes in order to preserve the behaviour of
existing code that might use one of these names as a binding in an outer
scope that is shadowed by a WITH statement whose binding object is an
Array object.

Properties of Array Instances

Array instances are exotic Array objects and have the internal methods
specified for such objects. Array instances inherit properties from the
Array prototype object. Array instances also have an
[[ArrayInitializationState]] internal slot.

Array instances have a LENGTH property, and a set of enumerable
properties with array index names.

length

The LENGTH property of this Array object is a data property whose value
is always numerically greater than the name of every deletable property
whose name is an array index.

The LENGTH property initially has the attributes { [[Writable]]: TRUE,
[[Enumerable]]: FALSE, [[Configurable]]: FALSE }.

NOTE Attempting to set the length property of an Array object to a value
that is numerically less than or equal to the largest numeric property
name of an existing array indexed non-deletable property of the array
will result in the length being set to a numeric value that is one
greater than that largest numeric property name. See 9.4.2.1.

Array Iterator Objects 

An Array Iterator is an object, that represents a specific iteration
over some specific Array instance object. There is not a named
constructor for Array Iterator objects. Instead, Array iterator objects
are created by calling certain methods of Array instance objects.

CreateArrayIterator Abstract Operation

Several methods of Array objects return Iterator objects. The abstract
operation CreateArrayIterator with arguments _array_ and _kind_ is used
to create such iterator objects. It performs the following steps:

1.  Assert: Type(_array_) is Object.

2.  3.  Let _iterator_ be ObjectCreate(%ArrayIteratorPrototype%,
    ([[IteratedObject]], [[ArrayIteratorNextIndex]],
    [[ArrayIterationKind]])).

4.  Set _iterator’s_ [[IteratedObject]] internal slot to _array_.

5.  Set _iterator’s_ [[ArrayIteratorNextIndex]] internal slot to 0.

6.  Set _iterator’s_ [[ArrayIterationKind]] internal slot to _kind_.

7.  Return _iterator_.

The %ArrayIteratorPrototype% Object

All Array Iterator Objects inherit properties from the
%ArrayIteratorPrototype% intrinsic object. The %ArrayIteratorPrototype%
object is an ordinary object and its [[Prototype]] internal slot is the
%ObjectPrototype% intrinsic object. In addition,
%ArrayIteratorPrototype% has the following properties:

%ArrayIteratorPrototype%. next( )

1.  Let _O_ be the THIS value.

2.  If Type(_O_) is not Object, throw a TYPEERROR exception.

3.  If _O_ does not have all of the internal slots of an Array Iterator
    Instance (22.1.5.3), throw a TYPEERROR exception.

4.  Let _a_ be the value of the [[IteratedObject]] internal slot of _O_.

5.  If _a_ is UNDEFINED, then return CreateIterResultObject(UNDEFINED,
    TRUE).

6.  Let _index_ be the value of the [[ArrayIteratorNextIndex]] internal
    slot of _O_.

7.  Let _itemKind_ be the value of the [[ArrayIterationKind]] internal
    slot of _O_.

8.  Let _lenValue_ be Get(_a_, "LENGTH").

9.  Let _len_ be ToLength(_lenValue_).

10. ReturnIfAbrupt(_len_).

11. If _index_ ≥ _len_, then

    a.  Set the value of the [[IteratedObject]] internal slot of _O_ to
        UNDEFINED.

    b.  Return CreateIterResultObject(UNDEFINED, TRUE).

12. Set the value of the [[ArrayIteratorNextIndex]] internal slot of _O
    to _index_+1.

13. If _itemKind_ is "KEY", then let _result_ be _index_.

14. Else,

    a.  Let _elementKey_ be ToString(_index_).

    b.  Let _elementValue_ be Get(_a_, _elementKey_).

    c.  ReturnIfAbrupt(_elementValue_).

15. If _itemKind_ is "VALUE", then let _result_ be _elementValue_.

16. Else,

    a.  Assert _itemKind_ is "KEY+VALUE",.

    b.  Let _result_ be ArrayCreate(2).

    c.  Assert: _result_ is a new, well-formed Array object so the
        following operations will never fail.

    d.  Call CreateDataProperty(_result_, "0", _index_).

    e.  Call CreateDataProperty(_result_, "1", _elementValue_).

    f.  

17. 18. 19. Return CreateIterResultObject(_result_, FALSE).

%ArrayIteratorPrototype% [ @@iterator ] ( )

The following steps are taken:

1.  Return the THIS value.

The value of the NAME property of this function is "[SYMBOL.ITERATOR]".

%ArrayIteratorPrototype% [ @@toStringTag ]

The initial value of the @@toStringTag property is the string value
"ARRAY ITERATOR".

Properties of Array Iterator Instances

Array Iterator instances are ordinary objects that inherit properties
from the %ArrayIteratorPrototype% intrinsic object. Array Iterator
instances are initially created with the internal slots listed in Table
44.

Table 44 — Internal Slots of Array Iterator Instances

  ---------------------------- ------------------------------------------------------------------------------------------------------------------------------------------------
  INTERNAL SLOT                DESCRIPTION
  [[IteratedObject]]           The object whose array elements are being iterated.
  [[ArrayIteratorNextIndex]]   The integer index of the next array index to be examined by this iteration.
  [[ArrayIterationKind]]       A string value that identifies what is to be returned for each element of the iteration. The possible values are: "KEY", "VALUE", "KEY+VALUE".
  ---------------------------- ------------------------------------------------------------------------------------------------------------------------------------------------


_TypedArray_ Objects 

_TypedArray_ objects present an array-like view of an underlying binary
data buffer (24.1). Each element of a _TypedArray_ instance has the same
underlying binary scalar data type. There is a distinct _TypedArray_
constructor, listed in Table 45, for each of the nine supported element
types. Each constructor in Table 45 has a corresponding distinct
prototype object.

Table 45 – The _TypedArray_ Constructors

  -------------------------------------------------------------------------------------------------------------------------------------
  Constructor Name    Element   Element Size   Conversion Operation   Description                                   Equivalent C Type
                      Type                                                                                          
  ------------------- --------- -------------- ---------------------- --------------------------------------------- -------------------
  Int8Array           Int8      1              ToInt8                 8-bit 2’s complement signed integer           signed char

  Uint8Array          Uint8     1              ToUint8                8-bit unsigned integer                        unsigned char

  Uint8ClampedArray   Uint8C    1              ToUint8Clamp           8-bit unsigned integer (clamped conversion)   unsigned char

  Int16Array          Int16     2              ToInt16                16-bit 2’s complement signed integer          Short

  Uint16Array         Uint16    2              ToUint16               16-bit unsigned integer                       unsigned short

  Int32Array          Int32     4              ToInt32                32-bit 2’s complement signed integer          Int

  Uint32Array         Uint32    4              ToUint32               32-bit unsigned integer                       unsigned int

  Float32Array        Float32   4                                     32-bit IEEE floating point                    Float

  Float64Array        Float64   8                                     64-bit IEEE floating point                    Double
  -------------------------------------------------------------------------------------------------------------------------------------

In the definitions below, references to _TypedArray_ should be replaced
with the appropriate constructor name from the above table. The phrase
“the element size in bytes” refers to the value in the Element Size
column of the table in the row corresponding to the constructor. The
phrase “element Type” refers to the value in the Element Type column for
that row.

The %TypedArray% Intrinsic Object

The %TypedArray% intrinsic object is a constructor-like function object
that all of the _TypedArray_ constructor object inherit from.
%TypedArray% and its corresponding prototype object provide common
properties that are inherited by all _TypedArray_ constructors and their
instances. The %TypedArray% intrinsic does not have a global name or
appear as a property of the global object.

If the THIS value passed in the call is an Object with a
[[ViewedArrayBuffer]] internal slot whose value is UNDEFINED, it
initializes the THIS value using the argument values. This permits super
invocation of the _TypedArray_ constructors by _TypedArray_ subclasses.

The %TypedArray% intrinsic function object is designed to act as the
superclass of the various _TypedArray_ constructors. Those constructors
use %TypedArray% to initialize their instances by invoking %TypedArray%
as if by making a SUPER call. The %TypedArray% intrinsic function is not
designed to be directly called in any other way. If %TypedArray% is
directly called or called as part of a NEW expression an exception is
thrown.

The actual behaviour of a SUPER call of %TypedArray% depends upon the
number and kind of arguments that are passed to it.

%TypedArray% ( length )

This description applies if and only when %TypedArray% function is
called and the Type of the first argument is not Object.

%TypedArray% called with argument _length_ performs the following steps:

1.  Assert: Type(_length_) is not Object.

2.  Let _O_ be the THIS value.

3.  If Type(_O_) is not Object, then throw a TYPEERROR exception.

4.  If _O_ does not have a [[TypedArrayName]] internal slot, then throw
    a TYPEERROR exception.

5.  If the value of _O’s_ [[TypedArrayName]] internal slot is UNDEFINED,
    then throw a TYPEERROR exception.

6.  Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.

7.  If the value of _O’s_ [[ViewedArrayBuffer]] internal slot is not
    UNDEFINED, then throw a TYPEERROR exception.

8.  Let _constructorName_ be the string value of _O_’s
    [[TypedArrayName]] internal slot.

9.  Let _elementType_ be the string value of the Element Type value in
    Table 45 for _constructorName_.

10. Let _numberLength_ be ToNumber(_length_).

11. Let _elementLength_ be ToLength(_numberLength_).

12. ReturnIfAbrupt(_elementLength_).

13. If SameValueZero(_numberLength_, _elementLength_) is FALSE, then
    throw a RANGEERROR exception.

14. Let _data_ be AllocateArrayBuffer(%ArrayBuffer%).

15. ReturnIfAbrupt(_data_).

16. If the value of _O’s_ [[ViewedArrayBuffer]] internal slot is not
    UNDEFINED, then throw a TYPEERROR exception.

17. Let _elementSize_ be the Element Size value in Table 45 for
    _constructorName_.

18. Let _byteLength_ be _elementSize_ × _elementLength_.

19. Let _status_ be SetArrayBufferData(_data_, _byteLength_).

20. ReturnIfAbrupt(_status_).

21. Set _O’s_ [[ViewedArrayBuffer]] internal slot to _data_.

22. Set _O_’s [[ByteLength]] internal slot to _byteLength_.

23. Set _O_’s [[ByteOffset]] internal slot to 0.

24. Set _O_’s [[ArrayLength]] internal slot to _elementLength_.

25. Return _O_.

%TypedArray% ( typedArray )

This description applies if and only if the %TypedArray% function is
called with at least one argument and the Type of the first argument is
Object and that object has a [[TypedArrayName]] internal slot.

%TypedArray%called with argument _typedArray_ performs the following
steps:

1.  Assert: Type(_typedArray_) is Object and _typedArray_ has a
    [[TypedArrayName]] internal slot.

2.  Let _srcArray_ be _typedArray_.

3.  Let _O_ be the THIS value.

4.  If Type(_O_) is not Object or if _O_ does not have a
    [[TypedArrayName]] internal slot, then throw a TYPEERROR exception.

5.  If the value of _O’s_ [[TypedArrayName]] internal slot is UNDEFINED,
    then throw a TYPEERROR exception.

6.  Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.

7.  If the value of _O’s_ [[ViewedArrayBuffer]] internal slot is not
    UNDEFINED, then throw a TYPEERROR exception.

8.  Let _srcData_ be the value of _srcArray’s_ [[ViewedArrayBuffer]]
    internal slot.

9.  If _srcData_ is UNDEFINED, then throw a TYPEERROR exception.

10. If IsNeuteredBuffer(_srcData_) is TRUE, then throw a TYPEERROR
    exception.

11. Let _constructorName_ be the string value of _O_’s
    [[TypedArrayName]] internal slot.

12. Let _elementType_ be the string value of the Element Type value in
    Table 45 for _constructorName_.

13. Let _elementLength_ be the value of _srcArray’s_ [[ArrayLength]]
    internal slot.

14. Let _srcName_ be the string value of _srcArray’s_ [[TypedArrayName]]
    internal slot.

15. Let _srcType_ be the string value of the Element Type value in Table
    45 for _srcName_.

16. Let _srcElementSize_ be the Element Size value in Table 45 for
    _srcName_.

17. 18. Let _srcByteOffset_ be the value of _srcArray_’s [[ByteOffset]]
    internal slot.

19. Let _elementSize_ be the Element Size value in Table 45 for
    _constructorName_.

20. Let _byteLength_ be _elementSize_ × _elementLength_.

21. If SameValue(_elementType_,_srcType_), then

    a.  Let _data_ be CloneArrayBuffer(_srcData_, _srcByteOffset_).

    b.  ReturnIfAbrupt(_data_).

22. Else,

    a.  Let _bufferConstructor_ be Get(_srcData_, "CONSTRUCTOR").

    b.  ReturnIfAbrupt(_bufferConstructor_).

    c.  If _bufferConstructor_ is UNDEFINED, then let
        _bufferConstructor_ be %ArrayBuffer%.

    d.  Let _data_ be AllocateArrayBuffer(_bufferConstructor_).

    e.  If IsNeuteredBuffer(_srcData_) is TRUE, then throw a TYPEERROR
        exception.

    f.  Let _status_ be SetArrayBufferData(_data_, _byteLength_).

    g.  ReturnIfAbrupt(_status_).

    h.  Let _srcByteIndex_ be _srcByteOffset_.

    i.  Let _targetByteIndex_ be 0.

    j.  Let _count_ be _elementLength_.

    k.  Repeat, while _count_ >0

        i.  Let _value_ be GetValueFromBuffer(_srcData_, _srcByteIndex_,
            _srcType_).

        ii. Let _status_ be SetValueInBuffer(_data_, _targetByteIndex_,
            _elementType_, _value_).

        iii. Set _srcByteIndex_ to _srcByteIndex_ + _srcElementSize_.

        iv. Set _targetByteIndex_ to _targetByteIndex_ + _elementSize_.

        v.  Decrement _count_ by 1.

23. If the value of _O’s_ [[ViewedArrayBuffer]] internal slot is not
    UNDEFINED, then throw a TYPEERROR exception.

24. Assert: _O_ has not been reentrantly initialized.

25. Set _O’s_ [[ViewedArrayBuffer]] internal slot to _data_.

26. Set _O_’s [[ByteLength]] internal slot to _byteLength_.

27. Set _O_’s [[ByteOffset]] internal slot to 0.

28. Set _O_’s [[ArrayLength]] internal slot to _elementLength_.

29. Return _O_.

%TypedArray% ( object )

This description applies when the %TypedArray% function is called with
at least one argument and the Type of first argument is Object and that
object does not have either a [[TypedArrayName]] or an
[[ArrayBufferData]] internal slot.

%TypedArray% called with argument _object_ performs the following steps:

1.  Assert: Type(_object_) is Object and _object_ does not have either a
    [[TypedArrayName]] or an [[ArrayBufferData]] internal slot.

2.  Let _O_ be the THIS value.

3.  4.  If Type(_O_) is not Object or if _O_ does not have a
    [[TypedArrayName]] internal slot, then throw a TYPEERROR exception.

5.  If the value of _O’s_ [[TypedArrayName]] internal slot is UNDEFINED,
    then throw a TYPEERROR exception.

6.  Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.

7.  If the value of _O’s_ [[ViewedArrayBuffer]] internal slot is not
    UNDEFINED, then throw a TYPEERROR exception.

8.  9.  10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. a.  b.  c.  d.  e.  f.  

23. 24. 25. 26. 27. 28. 29. Return TypedArrayFrom(UNDEFINED, _O_,
    _object_, UNDEFINED, UNDEFINED).

%TypedArray% ( buffer [ , byteOffset [ , length ] ] )

This description applies when the %TypedArray% function is called with
at least one argument and the Type of the first argument is Object and
that object has an [[ArrayBufferData]] internal slot.

%TypedArray% called with arguments _buffer_, _byteOffset_, and _length_
performs the following steps:

1.  Assert: Type(_buffer_) is Object and _buffer_ has an
    [[ArrayBufferData]] internal slot.

2.  Let _O_ be the THIS value.

3.  If the value of _buffer_’s [[ArrayBufferData]] internal slot is
    UNDEFINED, then throw a TYPEERROR exception.

4.  If IsNeuteredBuffer(_buffer_) is TRUE, then throw a TYPEERROR
    exception.

5.  If Type(_O_) is not Object or if _O_ does not have a
    [[TypedArrayName]] internal slot, then throw a TYPEERROR exception.

6.  If the value of _O’s_ [[TypedArrayName]] internal slot is UNDEFINED,
    then throw a TYPEERROR exception.

7.  Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.

8.  If the value of _O’s_ [[ViewedArrayBuffer]] internal slot is not
    UNDEFINED, then throw a TYPEERROR exception.

9.  Let _constructorName_ be the string value of _O_’s
    [[TypedArrayName]] internal slot.

10. Let _elementType_ be the string value of the Element Type value in
    Table 45 for _constructorName_.

11. Let _elementSize_ be the Number value of the Element Size value in
    Table 45 for _constructorName_.

12. Let _offset_ be ToInteger(_byteOffset_).

13. ReturnIfAbrupt(_offset_).

14. If _offset_ < 0, then throw a RANGEERROR exception.

15. If _offset_ modulo _elementSize_ ≠ 0, then throw a RANGEERROR
    exception.

16. Let _bufferByteLength_ be the value of _buffer’s
    [[ArrayBufferByteLength]] internal slot.

17. If _length_ is UNDEFINED, then

    a.  If _bufferByteLength_ modulo _elementSize_ ≠ 0, then throw a
        RANGEERROR exception.

    b.  Let _newByteLength_ be _bufferByteLength_ – _offset_.

    c.  If _newByteLength_ < 0, then throw a RANGEERROR exception.

18. Else,

    a.  Let _newLength_ be ToLength(_length)._

    b.  ReturnIfAbrupt(_newLength_).

    c.  Let _newByteLength_ be _newLength_ × _elementSize_.

    d.  If _offset_+_newByteLength_ > _bufferByteLength_, then throw a
        RANGEERROR exception.

19. If the value of _O’s_ [[ViewedArrayBuffer]] internal slot is not
    UNDEFINED, then throw a TYPEERROR exception.

20. Set _O’s_ [[ViewedArrayBuffer]] internal slot to _buffer_.

21. Set _O_’s [[ByteLength]] internal slot to _newByteLength_.

22. Set _O_’s [[ByteOffset]] internal slot to _offset_.

23. Set _O_’s [[ArrayLength]] internal slot to _newByteLength /
    elementSize_ .

24. Return _O_.

%TypedArray% ( all other argument combinations )

If the %TypedArray% function is called with arguments that do not match
any of the preceeding argument descriptions a TYPEERROR exception is
thrown.

Properties of the %TypedArray% Intrinsic Object

The %TypedArray% intrinsic object is a built-in function object. The
value of the [[Prototype]] internal slot of %TypedArray% is the Function
prototype object (19.2.3).

Besides a LENGTH property whose value is 3 and a NAME property whose
value is "TYPEDARRAY", %TypedArray% has the following properties:

%TypedArray%.from ( source [ , mapfn [ , thisArg ] ] )

When the FROM method is called with argument _source_, and optional
arguments _mapfn_ and _thisArg_, the following steps are taken:

1.  Let _C_ be the THIS value.

2.  If IsConstructor(_C_) is FALSE, then throw a TYPEERROR exception.

3.  Let _items_ be ToObject(_source_).

4.  ReturnIfAbrupt(_items_).

5.  If _mapfn_ was supplied, let _f_ be _mapfn_; otherwise let _f_ be
    UNDEFINED.

6.  If _f_ is not UNDEFINED, then

    a.  If IsCallable(_f_) is FALSE, then throw a TYPEERROR exception.

7.  If _thisArg_ was supplied, let _t_ be _thisArg_; else let _t_ be
    UNDEFINED.

8.  Return TypedArrayFrom(_C_, UNDEFINED, _items_, _f_, _t_).

The LENGTH property of the FROM method is 1.

NOTE The FROM function is an intentionally generic factory method; it
does not require that its THIS value be a Typed Array constructor.
Therefore it can be transferred to or inherited by any other
constructors that may be called with a single numeric argument. This
function uses [[Put]] to store elements into a newly created object and
assume that the constructor sets the LENGTH property of the new object
to the argument value passed to it.

Runtime Semantics: TypedArrayFrom( constructor, target, items, mapfn, thisArg )

When the TypedArrayFrom abstract operation is called with arguments
_constructor_, _target_, _items_, _mapfn_, and _thisArg_, the following
steps are taken:

1.  Let _C_ be _constructor_.

2.  Assert: one of _constructor_ and _target_ is UNDEFINED.

3.  Assert: If _constructor_ is not UNDEFINED, then IsConstructor(_C_)
    is TRUE.

4.  Assert: _target_ is either UNDEFINED or an Object that has been
    validated by the %TypedArray% constructor as described in 22.2.1.3

5.  Assert: Type(_items_) is Object.

6.  Assert: Type(_mapfn_) is either a callable Object or Undefined.

7.  8.  If _mapfn_ is UNDEFINED, then let _mapping_ be FALSE.

9.  else

    a.  b.  Let _T_ be _thisArg_.

    c.  Let _mapping_ be TRUE

10. Let _usingIterator_ be CheckIterable(_items_).

11. ReturnIfAbrupt(_usingIterator_).

12. If _usingIterator_ is not UNDEFINED, then

    a.  Let _iterator_ be GetIterator(_items_, _usingIterator_).

    b.  ReturnIfAbrupt(_iterator_).

    c.  Let _values_ be a new empty List.

    d.  Let _next_ be TRUE.

    e.  Repeat, while _next_ is not FALSE

        i.  Let _next_ be IteratorStep(_iterator_).

        ii. ReturnIfAbrupt(_next_).

    f.  If _next_ is not FALSE, then

        i.  Let _nextValue_ be IteratorValue(_next_).

        ii. ReturnIfAbrupt(_nextValue_).

        iii. Append _nextValue_ to the end of the List _values_.

    g.  Let _len_ be the number of elements in _values_.

    h.  Let _targetObj_ be TypedArrayAllocOrInit(_C_, _target_, _len_).

    i.  ReturnIfAbrupt(_targetObj_).

    j.  i.  ii. 

    k.  i.  ii. iii. iv. v.  vi. vii. viii. ix. x.  xi. xii. xiii. xiv. xv. xvi. 

    l.  Let _k_ be 0.

    m.  Repeat, while _k_ < _len_

        i.  Let _Pk_ be ToString(_k_).

        ii. Let _kValue_ be the first element of _values_ and remove
            that element from _list_.

        iii. If _mapping_ is TRUE, then

            1.  Let _mappedValue_ be the result of calling the [[Call]]
                internal method of _mapfn_ with _T_ as _thisArgument_
                and (_kValue_, _k_) as _argumentsList_.

            2.  ReturnIfAbrupt(_mappedValue_).

        iv. Else, let _mappedValue_ be _kValue_.

        v.  Let _putStatus_ be Put(_targetObj_, _Pk_, _mappedValue_,
            TRUE).

        vi. ReturnIfAbrupt(_putStatus_).

        vii. Increase _k_ by 1.

    n.  Assert: _values_ is now an empty List.

    o.  Return _targetObj_.

13. Assert: _items_ is not an Iterator so assume it is an array-like
    object.

14. Let _lenValue_ be Get(_items_, "LENGTH").

15. Let _len_ be ToLength(_lenValue_).

16. ReturnIfAbrupt(_len_).

17. Let _targetObj_ be TypedArrayAllocOrInit(_C_, _target_, _len_).

18. ReturnIfAbrupt(_targetObj_).

19. Let _k_ be 0.

20. Repeat, while _k_ < _len

    a.  Let _Pk_ be ToString(_k_).

    b.  Let _kValue_ be Get(_items_, _Pk_).

    c.  ReturnIfAbrupt(_kValue_).

    d.  If _mapping_ is TRUE, then

        i.  Let _mappedValue_ be the result of calling the [[Call]]
            internal method of _mapfn_ with _T_ as _thisArgument_ and
            (_kValue_, _k_) as _argumentsList_.

        ii. ReturnIfAbrupt(_mappedValue_).

    e.  Else, let _mappedValue_ be _kValue_.

    f.  Let _putStatus_ be Put(_targetObj_, _Pk_, _mappedValue_, TRUE).

    g.  ReturnIfAbrupt(_putStatus_).

    h.  Increase _k_ by 1.

21. Return _targetObj_.

Runtime Semantics: TypedArrayAllocOrInit( constructor, target, length)

When the TypedArrayAllocOrInit abstract operation is called with
arguments _constructor_, _target_, and _length_, the following steps are
taken:

1.  Assert: one of _constructor_ and _target_ is UNDEFINED.

2.  Assert: If _constructor_ is not UNDEFINED, then
    IsConstructor(_constructor_) is TRUE.

3.  Assert: _target_ is either UNDEFINED or an Object that has been
    validated by the %TypedArray% constructor as described in 22.2.1.3.
    However, side-effects of subsequent operations may have initialized
    _target_’s [[ViewedArrayBuffer]].

4.  Assert: Type(_length_) is Number.

5.  If _target_ is UNDEFINED, then

    a.  Let _targetObj_ be the result of calling the [[Construct]]
        internal method of _constructor_ with argument (_length_).

    b.  ReturnIfAbrupt(_targetObj_).

6.  Else,

    a.  Let _targetObj_ be _target_.

    b.  Let _constructorName_ be the string value of _targetObj_’s
        [[TypedArrayName]] internal slot.

    c.  Let _elementType_ be the string value of the Element Type value
        in Table 45 for _constructorName_.

    d.  Let _data_ be AllocateArrayBuffer(%ArrayBuffer%).

    e.  ReturnIfAbrupt(_data_).

    f.  Let _elementSize_ be the Element Size value in Table 45 for
        _constructorName_.

    g.  Let _byteLength_ be _elementSize_ × _length_.

    h.  Let _status_ be SetArrayBufferData(_data_, _byteLength_)

    i.  ReturnIfAbrupt(_status_).

    j.  Note: Side-effects of preceding steps may have already
        initialized _targetObj_.

    k.  If the value of _targetObj’s_ [[ViewedArrayBuffer]] internal
        slot is not UNDEFINED, then throw a TYPEERROR exception.

    l.  m.  Set _targetObj’s_ [[ViewedArrayBuffer]] internal slot to
        _data_.

    n.  Set _targetObj_’s [[ByteLength]] internal slot to _byteLength_.

    o.  Set _targetObj_’s [[ByteOffset]] internal slot to 0.

    p.  Set _targetObj_’s [[ArrayLength]] internal slot to _length_.

7.  Return _targetObj_.

%TypedArray%.of ( ...items )

When the OF method is called with any number of arguments, the following
steps are taken:

1.  2.  Let _len_ be the actual number of arguments passed to this
    function.

3.  Let _items_ be the List of arguments passed to this function.

4.  Let _C_ be the THIS value.

5.  If IsConstructor(_C_) is TRUE, then

    a.  Let _newObj_ be the result of calling the [[Construct]] internal
        method of _C_ with argument (_len_).

    b.  ReturnIfAbrupt(_newObj_).

6.  Else,

    a.  Throw a TYPEERROR exception.

7.  Let _k_ be 0.

8.  Repeat, while _k_ < _len

    a.  b.  Let _kValue_ be element _k_ of _items_.

    c.  Let _Pk_ be ToString(_k_).

    d.  Let _status_ be Put(_newObj_,_Pk_, _kValue_.[[value]], TRUE).

    e.  ReturnIfAbrupt(_status_).

    f.  Increase _k_ by 1.

9.  Return _newObj_.

The LENGTH property of the OF method is 0.

NOTE 1 The _items_ argument is assumed to be a well-formed rest argument
value.

NOTE 2 The OF function is an intentionally generic factory method; it
does not require that its THIS value be a _TypedArray_ constructor.
Therefore it can be transferred to or inherited by other constructors
that may be called with a single numeric argument. However, it does
assume that constructor creates and initializes a length property that
is initialized to its argument value.

%TypedArray%.prototype

The initial value of %TypedArray%.prototype is the %TypedArrayPrototype%
intrinsic object (22.2.3).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

%TypedArray% [ @@create ] ( )

The @@create method of %TypedArray% performs the following steps:

1.  Let _F_ be the THIS value.

2.  3.  Let _proto_ be GetPrototypeFromConstructor(_F_,
    "%TYPEDARRAYPROTOTYPE%").

4.  ReturnIfAbrupt(_proto_).

5.  Let _obj_ be IntegerIndexedObjectCreate (_proto_,
    ([[ViewedArrayBuffer]], [[TypedArrayName]], [[ByteLength]],
    [[ByteOffset]], [[ArrayLength]]) ).

6.  Assert: The [[ViewedArrayBuffer]] internal slot of _obj_ is
    UNDEFINED.

7.  Assert: The [[TypedArrayName]] internal slot of _obj_ is UNDEFINED .

8.  Set the [[ByteLength]] internal slot of _obj_ to 0.

9.  Set the [[ByteOffset]] internal slot of _obj_ to 0.

10. Set the [[ArrayLength]] internal slot of _obj_ to 0.

11. Return _obj_.

The value of the NAME property of this function is "[SYMBOL.CREATE]".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Properties of the %TypedArrayPrototype% Object

The value of the [[Prototype]] internal slot of the
%TypedArrayPrototype% object is the standard built-in Object prototype
object (19.1.3). The %TypedArrayPrototype% object is an ordinary object.
It does not have a [[ViewedArrayBuffer]] or or any other of the internal
slots that are specific to _TypedArray_ instance objects.

get %TypedArray%.prototype.buffer

%TypedArray%.PROTOTYPE.BUFFER is an accessor property whose set accessor
function is UNDEFINED. Its get accessor function performs the following
steps:

1.  Let _O_ be the THIS value.

2.  If Type(_O_) is not Object, throw a TYPEERROR exception.

3.  If _O_ does not have a [[ViewedArrayBuffer]] internal slot throw a
    TYPEERROR exception.

4.  Let _buffer_ be the value of _O_’s [[ViewedArrayBuffer]] internal
    slot.

5.  If _buffer_ is UNDEFINED, then throw a TYPEERROR exception.

6.  Return _buffer_.

get %TypedArray%.prototype.byteLength

%TypedArray%.PROTOTYPE.BYTELENGTH is an accessor property whose set
accessor function is UNDEFINED. Its get accessor function performs the
following steps:

1.  Let _O_ be the THIS value.

2.  If Type(_O_) is not Object, throw a TYPEERROR exception.

3.  If _O_ does not have a [[ViewedArrayBuffer]] internal slot throw a
    TYPEERROR exception.

4.  Let _buffer_ be the value of _O_’s [[ViewedArrayBuffer]] internal
    slot.

5.  If _buffer_ is UNDEFINED, then throw a TYPEERROR exception.

6.  If IsNeuteredBuffer(_buffer_) is TRUE, then return 0.

7.  Let _size_ be the value of _O_’s [[ByteLength]] internal slot.

8.  Return _size_.

get %TypedArray%.prototype.byteOffset

%TypedArray%.PROTOTYPE.BYTEOFFSET is an accessor property whose set
accessor function is UNDEFINED. Its get accessor function performs the
following steps:

1.  Let _O_ be the THIS value.

2.  If Type(_O_) is not Object, throw a TYPEERROR exception.

3.  If _O_ does not have a [[ViewedArrayBuffer]] internal slot throw a
    TYPEERROR exception.

4.  Let _buffer_ be the value of _O_’s [[ViewedArrayBuffer]] internal
    slot.

5.  If _buffer_ is UNDEFINED, then throw a TYPEERROR exception.

6.  If IsNeuteredBuffer(_buffer_) is TRUE, then return 0.

7.  Let _offset_ be the value of _O_’s [[ByteOffset]] internal slot.

8.  Return _offset_.

%TypedArray%.prototype.constructor

The initial value of %TypedArray%.prototype.constructor is the
%TypedArray% intrinsic object.

%TypedArray%.prototype.copyWithin (target, start, end = this.length )

%TypedArray%.PROTOTYPE.COPYWITHIN is a distinct function that implements
the same algorithm as ARRAY.PROTOTYPE.COPYWITHIN as defined in 22.1.3.3
except that the THIS object’s [[ArrayLength]] internal slot is accessed
in place of performing a [[Get]] of "LENGTH". The implementation of the
algorithm may be optimized with the knowledge that the THIS value is an
object that has a fixed length and whose integer indexed properties are
not sparse. However, such optimization must not introduce any observable
changes in the specified behaviour of the algorithm.

This function is not generic. If the THIS value is not a object with a
[[TypedArrayName]] internal slot, a TYPEERROR exception is immediately
thrown when this function is called. A TYPEERROR exception is also
immediately thrown if the THIS value’s [[ViewedArrayBuffer]] is
UNDEFINED or has been neutered..

The LENGTH property of the COPYWITHIN method is 2.

%TypedArray%.prototype.entries ( )

The following steps are taken:

1.  Let _O_ be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(_O_).

3.  If Type(_O_) is not Object, throw a TYPEERROR exception.

4.  If _O_ does not have a [[ViewedArrayBuffer]] internal slot throw a
    TYPEERROR exception.

5.  Let _buffer_ be the value of _O_’s [[ViewedArrayBuffer]] internal
    slot.

6.  If _buffer_ is UNDEFINED, then throw a TYPEERROR exception.

7.  If IsNeuteredBuffer(_buffer_) is TRUE, throw a TYPEERROR exception.

8.  Return CreateArrayIterator(_O_, "KEY+VALUE").

%TypedArray%.prototype.every ( callbackfn [ , thisArg ] )

%TypedArray%.PROTOTYPE.EVERY is a distinct function that implements the
same algorithm as ARRAY.PROTOTYPE.EVERY as defined in 22.1.3.5 except
that the THIS object’s [[ArrayLength]] internal slot is accessed in
place of performing a [[Get]] of "LENGTH". The implementation of the
algorithm may be optimized with the knowledge that the THIS value is an
object that has a fixed length and whose integer indexed properties are
not sparse. However, such optimization must not introduce any observable
changes in the specified behaviour of the algorithm and must take into
account the possibility that calls to _callbackfn_ may neuter the the
THIS value.

This function is not generic. If the THIS value is not a object with a
[[TypedArrayName]] internal slot, a TYPEERROR exception is immediately
thrown when this function is called.

The LENGTH property of the EVERY method is 1.

%TypedArray%.prototype.fill (value [ , start [ , end ] ] )

%TypedArray%.PROTOTYPE.FILL is a distinct function that implements the
same algorithm as ARRAY.PROTOTYPE.FILL as defined in 22.1.3.6 except
that the THIS object’s [[ArrayLength]] internal slot is accessed in
place of performing a [[Get]] of "LENGTH". The implementation of the
algorithm may be optimized with the knowledge that the THIS value is an
object that has a fixed length and whose integer indexed properties are
not sparse. However, such optimization must not introduce any observable
changes in the specified behaviour of the algorithm.

This function is not generic. If the THIS value is not a object with a
[[TypedArrayName]] internal slot, a TYPEERROR exception is immediately
thrown when this function is called.

The LENGTH property of the FILL method is 1.

%TypedArray%.prototype.filter ( callbackfn [ , thisArg ] )

The interpretation and use of the arguments of
%TypedArray%.PROTOTYPE.FILTER are the same as for ARRAY.PROTOTYPE.FILTER
as defined in 22.1.3.7.

When the FILTER method is called with one or two arguments, the
following steps are taken:

1.  Let _O_ be the THIS value.

2.  If Type(_O_) is not Object, throw a TYPEERROR exception.

3.  If _O_ does not have a [[TypedArrayName]] internal slot, then throw
    a TYPEERROR exception.

4.  Let _buffer_ be the value of _O_’s [[ViewedArrayBuffer]] internal
    slot.

5.  If _buffer_ is UNDEFINED, then throw a TYPEERROR exception.

6.  If IsNeuteredBuffer(_buffer_) is TRUE, throw a TYPEERROR exception.

7.  Let _len_ be the value of _O’s_ [[ArrayLength]] internal slot.

8.  If IsCallable(_callbackfn_) is FALSE, throw a TYPEERROR exception.

9.  If _thisArg_ was supplied, let _T_ be _thisArg_; else let _T_ be
    UNDEFINED.

10. Let _C_ be Get(_O_, "CONSTRUCTOR").

11. ReturnIfAbrupt(_C_).

12. If IsConstructor(_C_) is FALSE, then

    a.  Throw a TYPEERROR exception.

13. Let _kept_ be a new empty List.

14. Let _k_ be 0.

15. Let _captured_ be 0.

16. Repeat, while _k_ < _len

    a.  Let _Pk_ be ToString(_k_).

    b.  Let _kValue_ be Get(_O_, _Pk_).

    c.  ReturnIfAbrupt(_kValue_).

    d.  Let _selected_ be the result of calling the [[Call]] internal
        method of _callbackfn_ with _T_ as _thisArgument_ and a List
        containing _kValue_, _k_, and _O_ as _argumentsList_.

    e.  ReturnIfAbrupt(_selected_).

    f.  If ToBoolean(_selected_) is TRUE, then

        i.  Append _kValue_ to the end of _kept_.

        ii. Increase _captured_ by 1.

    g.  Increase _k_ by 1.

17. Let _A_ be the result of calling the [[Construct]] internal method
    of _C_ with argument (_captured_).

18. ReturnIfAbrupt(_A_).

19. Let _n_ be 0.

20. For each element _e_ of _kept

    a.  Let _status_ be Put(_A_, ToString(_n_), _e_, TRUE ).

    b.  ReturnIfAbrupt(_status_).

    c.  Increment _n_ by 1.

21. Return _A_.

This function is not generic. If the THIS value is not a object with a
[[TypedArrayName]] internal slot, a TYPEERROR exception is immediately
thrown when this function is called.

The LENGTH property of the FILTER method is 1.

%TypedArray%.prototype.find (predicate [ , thisArg ] )

%TypedArray%.PROTOTYPE.FIND is a distinct function that implements the
same algorithm as ARRAY.PROTOTYPE.FIND as defined in 22.1.3.8 except
that the THIS object’s [[ArrayLength]] internal slot is accessed in
place of performing a [[Get]] of "LENGTH". The implementation of the
algorithm may be optimized with the knowledge that the THIS value is an
object that has a fixed length and whose integer indexed properties are
not sparse. However, such optimization must not introduce any observable
changes in the specified behaviour of the algorithm and must take into
account the possibility that calls to _predicate_ may neuter the the
THIS value.

This function is not generic. If the THIS value is not a object with a
[[TypedArrayName]] internal slot, a TYPEERROR exception is immediately
thrown when this function is called. A TYPEERROR exception is also
immediately thrown if the THIS value’s [[ViewedArrayBuffer]] is
UNDEFINED or has been neutered..

The LENGTH property of the FIND method is 1.

%TypedArray%.prototype.findIndex ( predicate [ , thisArg ] )

%TypedArray%.PROTOTYPE.FINDINDEX is a distinct function that implements
the same algorithm as ARRAY.PROTOTYPE.FINDINDEX as defined in 22.1.3.9
except that the THIS object’s [[ArrayLength]] internal slot is accessed
in place of performing a [[Get]] of "LENGTH". The implementation of the
algorithm may be optimized with the knowledge that the THIS value is an
object that has a fixed length and whose integer indexed properties are
not sparse. However, such optimization must not introduce any observable
changes in the specified behaviour of the algorithm and must take into
account the possibility that calls to _predicate_ may neuter the the
THIS value.

This function is not generic. If the THIS value is not a object with a
[[TypedArrayName]] internal slot, a TYPEERROR exception is immediately
thrown when this function is called. A TYPEERROR exception is also
immediately thrown if the THIS value’s [[ViewedArrayBuffer]] is
UNDEFINED or has been neutered..

The LENGTH property of the FINDINDEX method is 1.

%TypedArray%.prototype.forEach ( callbackfn [ , thisArg ] )

%TypedArray%.PROTOTYPE.FOREACH is a distinct function that implements
the same algorithm as ARRAY.PROTOTYPE.FOREACH as defined in 22.1.3.10
except that the THIS object’s [[ArrayLength]] internal slot is accessed
in place of performing a [[Get]] of "LENGTH". The implementation of the
algorithm may be optimized with the knowledge that the THIS value is an
object that has a fixed length and whose integer indexed properties are
not sparse. However, such optimization must not introduce any observable
changes in the specified behaviour of the algorithm and must take into
account the possibility that calls to _callbackfn_ may neuter the the
THIS value.

This function is not generic. If the THIS value is not a object with a
[[TypedArrayName]] internal slot, a TYPEERROR exception is immediately
thrown when this function is called. A TYPEERROR exception is also
immediately thrown if the THIS value’s [[ViewedArrayBuffer]] is
UNDEFINED or has been neutered..

The LENGTH property of the FOREACH method is 1.

%TypedArray%.prototype.indexOf (searchElement [ , fromIndex ] )

%TypedArray%.PROTOTYPE.INDEXOF is a distinct function that implements
the same algorithm as ARRAY.PROTOTYPE.INDEXOF as defined in 22.1.3.11
except that the THIS object’s [[ArrayLength]] internal slot is accessed
in place of performing a [[Get]] of "LENGTH". The implementation of the
algorithm may be optimized with the knowledge that the THIS value is an
object that has a fixed length and whose integer indexed properties are
not sparse. However, such optimization must not introduce any observable
changes in the specified behaviour of the algorithm.

This function is not generic. If the THIS value is not a object with a
[[TypedArrayName]] internal slot, a TYPEERROR exception is immediately
thrown when this function is called. A TYPEERROR exception is also
immediately thrown if the THIS value’s [[ViewedArrayBuffer]] is
UNDEFINED or has been neutered..

The LENGTH property of the INDEXOF method is 1.

%TypedArray%.prototype.join ( separator )

%TypedArray%.PROTOTYPE.JOIN is a distinct function that implements the
same algorithm as ARRAY.PROTOTYPE.JOIN as defined in 22.1.3.12 except
that the THIS object’s [[ArrayLength]] internal slot is accessed in
place of performing a [[Get]] of "LENGTH". The implementation of the
algorithm may be optimized with the knowledge that the THIS value is an
object that has a fixed length and whose integer indexed properties are
not sparse. However, such optimization must not introduce any observable
changes in the specified behaviour of the algorithm.

This function is not generic. If the THIS value is not a object with a
[[TypedArrayName]] internal slot, a TYPEERROR exception is immediately
thrown when this function is called. A TYPEERROR exception is also
immediately thrown if the THIS value’s [[ViewedArrayBuffer]] is
UNDEFINED or has been neutered..

%TypedArray%.prototype.keys ( )

The following steps are taken:

1.  Let _O_ be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(_O_).

3.  If Type(_O_) is not Object, throw a TYPEERROR exception.

4.  If _O_ does not have a [[ViewedArrayBuffer]] internal slot throw a
    TYPEERROR exception.

5.  Let _buffer_ be the value of _O_’s [[ViewedArrayBuffer]] internal
    slot.

6.  If _buffer_ is UNDEFINED, then throw a TYPEERROR exception.

7.  If IsNeuteredBuffer(_buffer_) is TRUE, throw a TYPEERROR exception.

8.  Return CreateArrayIterator(_O_, "KEY").

%TypedArray%.prototype.lastIndexOf ( searchElement [ , fromIndex ] )

%TypedArray%.PROTOTYPE.LASTINDEXOF is a distinct function that
implements the same algorithm as ARRAY.PROTOTYPE.LASTINDEXOF as defined
in 22.1.3.14 except that the THIS object’s [[ArrayLength]] internal slot
is accessed in place of performing a [[Get]] of "LENGTH". The
implementation of the algorithm may be optimized with the knowledge that
the THIS value is an object that has a fixed length and whose integer
indexed properties are not sparse. However, such optimization must not
introduce any observable changes in the specified behaviour of the
algorithm.

This function is not generic. If the THIS value is not a object with a
[[TypedArrayName]] internal slot, a TYPEERROR exception is immediately
thrown when this function is called. A TYPEERROR exception is also
immediately thrown if the THIS value’s [[ViewedArrayBuffer]] is
UNDEFINED or has been neutered..

The LENGTH property of the LASTINDEXOF method is 1.

get %TypedArray%.prototype.length

%TypedArray%.PROTOTYPE.LENGTH is an accessor property whose set accessor
function is UNDEFINED. Its get accessor function performs the following
steps:

1.  Let _O_ be the THIS value.

2.  If Type(_O_) is not Object, throw a TYPEERROR exception.

3.  If _O_ does not have a [[TypedArrayName]] internal slot, then throw
    a TYPEERROR exception.

4.  Assert: _O_ has [[ViewedArrayBuffer]] and [[ArrayLength]] internal
    slots.

5.  Let _buffer_ be the value of _O_’s [[ViewedArrayBuffer]] internal
    slot.

6.  If _buffer_ is UNDEFINED, then throw a TYPEERROR exception.

7.  If IsNeuteredBuffer(_buffer_) is TRUE, then return 0.

8.  Let _length_ be the value of _O_’s [[ArrayLength]] internal slot.

9.  Return _length_.

This function is not generic. If the THIS value is not a object with a
[[TypedArrayName]] internal slot, a TYPEERROR exception is immediately
thrown when this function is called.

%TypedArray%.prototype.map ( callbackfn [ , thisArg ] )

The interpretation and use of the arguments of
%TypedArray%.PROTOTYPE.MAP are the same as for ARRAY.PROTOTYPE.MAP as
defined in 22.1.3.15.

When the MAP method is called with one or two arguments, the following
steps are taken:

1.  Let _O_ be the THIS value.

2.  If Type(_O_) is not Object, throw a TYPEERROR exception.

3.  If _O_ does not have a [[TypedArrayName]] internal slot, then throw
    a TYPEERROR exception.

4.  Let _buffer_ be the value of _O_’s [[ViewedArrayBuffer]] internal
    slot.

5.  If _buffer_ is UNDEFINED, then throw a TYPEERROR exception.

6.  If IsNeuteredBuffer(_buffer_) is TRUE, throw a TYPEERROR exception.

7.  Let _len_ be the value of _O’s_ [[ArrayLength]] internal slot.

8.  If IsCallable(_callbackfn_) is FALSE, throw a TYPEERROR exception.

9.  If _thisArg_ was supplied, let _T_ be _thisArg_; else let _T_ be
    UNDEFINED.

10. Let _C_ be Get(_O_, "CONSTRUCTOR").

11. ReturnIfAbrupt(_C_).

12. If IsConstructor(_C_) is TRUE, then

    a.  Let _A_ be the result of calling the [[Construct]] internal
        method of _C_ with argument List (_len_).

    b.  ReturnIfAbrupt(_A_).

13. Else,

    a.  Throw a TYPEERROR exception.

14. Let _k_ be 0.

15. Repeat, while _k_ < _len

    a.  Let _Pk_ be ToString(_k_).

    b.  Let _kValue_ be Get(_O_, _Pk_).

    c.  ReturnIfAbrupt(_kValue_).

    d.  Let _mappedValue_ be the result of calling the [[Call]] internal
        method of _callbackfn_ with _T_ as _thisArgument_ and a List
        containing _kValue_, _k_, and _O_ as _argumentsList_.

    e.  ReturnIfAbrupt(_mappedValue_).

    f.  Let _status_ be Put(_A_, _Pk_, _mappedValue_, TRUE ).

    g.  ReturnIfAbrupt(_status_).

    h.  Increase _k_ by 1.

16. Return _A_.

This function is not generic. If the THIS value is not a object with a
[[TypedArrayName]] internal slot, a TYPEERROR exception is immediately
thrown when this function is called.

The LENGTH property of the MAP method is 1.

%TypedArray%.prototype.reduce ( callbackfn [ , initialValue ] )

%TypedArray%.PROTOTYPE.REDUCE is a distinct function that implements the
same algorithm as ARRAY.PROTOTYPE.REDUCE as defined in 22.1.3.18 except
that the THIS object’s [[ArrayLength]] internal slot is accessed in
place of performing a [[Get]] of "LENGTH". The implementation of the
algorithm may be optimized with the knowledge that the THIS value is an
object that has a fixed length and whose integer indexed properties are
not sparse. However, such optimization must not introduce any observable
changes in the specified behaviour of the algorithm and must take into
account the possibility that calls to _callbackfn_ may neuter the the
THIS value.

This function is not generic. If the THIS value is not a object with a
[[TypedArrayName]] internal slot, a TYPEERROR exception is immediately
thrown when this function is called. A TYPEERROR exception is also
immediately thrown if the THIS value’s [[ViewedArrayBuffer]] is
UNDEFINED or has been neutered..

The LENGTH property of the REDUCE method is 1.

%TypedArray%.prototype.reduceRight ( callbackfn [ , initialValue ] )

%TypedArray%.PROTOTYPE.REDUCERIGHT is a distinct function that
implements the same algorithm as ARRAY.PROTOTYPE.REDUCERIGHT as defined
in 22.1.3.19 except that the THIS object’s [[ArrayLength]] internal slot
is accessed in place of performing a [[Get]] of "LENGTH". The
implementation of the algorithm may be optimized with the knowledge that
the THIS value is an object that has a fixed length and whose integer
indexed properties are not sparse. However, such optimization must not
introduce any observable changes in the specified behaviour of the
algorithm and must take into account the possibility that calls to
_callbackfn_ may neuter the the THIS value.

This function is not generic. If the THIS value is not a object with a
[[TypedArrayName]] internal slot, a TYPEERROR exception is immediately
thrown when this function is called. A TYPEERROR exception is also
immediately thrown if the THIS value’s [[ViewedArrayBuffer]] is
UNDEFINED or has been neutered..

The LENGTH property of the REDUCERIGHT method is 1.

%TypedArray%.prototype.reverse ( )

%TypedArray%.PROTOTYPE.REVERSE is a distinct function that implements
the same algorithm as ARRAY.PROTOTYPE.REVERSE as defined in 22.1.3.20
except that the THIS object’s [[ArrayLength]] internal slot is accessed
in place of performing a [[Get]] of "LENGTH". The implementation of the
algorithm may be optimized with the knowledge that the THIS value is an
object that has a fixed length and whose integer indexed properties are
not sparse. However, such optimization must not introduce any observable
changes in the specified behaviour of the algorithm.

This function is not generic. If the THIS value is not a object with a
[[TypedArrayName]] internal slot, a TYPEERROR exception is immediately
thrown when this function is called. A TYPEERROR exception is also
immediately thrown if the THIS value’s [[ViewedArrayBuffer]] is
UNDEFINED or has been neutered.

%TypedArray%.prototype.set(array [ , offset ] )

Set multiple values in this _TypedArray_, reading the values from the
object _array_. The optional _offset_ value indicates the first element
index in this _TypedArray_ where values are written. If omitted, it is
assumed to be 0.

1.  Assert: _array_ does not have a [[TypedArrayName]] internal slot. If
    it does, the definition in 22.2.3.23 applies.

2.  Let _target_ be the THIS value.

3.  If Type(_target_) is not Object, throw a TYPEERROR exception.

4.  If _target_ does not have a [[TypedArrayName]] internal slot, then
    throw a TYPEERROR exception.

5.  Assert: _target_ has a [[ViewedArrayBuffer]] internal slot.

6.  Let _targetBuffer_ be the value of _target_’s [[ViewedArrayBuffer]]
    internal slot.

7.  If _targetBuffer_ is UNDEFINED, then throw a TYPEERROR exception.

8.  Let _targetLength_ be the value of _target_’s [[ArrayLength]]
    internal slot.

9.  Let _targetOffset_ be ToInteger (_offset_)

10. ReturnIfAbrupt(_targetOffset_).

11. If _targetOffset_ < 0, then throw a RANGEERROR exception.

12. Let _targetName_ be the string value of _target_’s
    [[TypedArrayName]] internal slot.

13. Let _targetElementSize_ be the Number value of the Element Size
    value specified in Table 45 for _targetName_.

14. Let _targetType_ be the string value of the Element Type value in
    Table 45 for _targetName_.

15. Let _targetByteOffset_ be the value of _target_’s [[ByteOffset]]
    internal slot.

16. Let _src_ be ToObject(_array_).

17. ReturnIfAbrupt(_src_).

18. Let _srcLen_ be Get(_src_, "LENGTH").

19. Let _numberLength_ be ToNumber(_srcLen_).

20. Let _srcLength_ be ToInteger(_numberLength_).

21. ReturnIfAbrupt(_srcLength_).

22. If _numberLength_ ≠ _srcLength_ or _srcLength_ < 0, then throw a
    TYPEERROR exception.

23. If _srcLength_ + _targetOffset_ > _targetLength_, then throw a
    RANGEERROR exception.

24. Let _targetByteIndex_ be _targetOffset_ × _targetElementSize_ +
    _targetByteOffset_.

25. Let _k_ be 0.

26. Let _limit_ be _targetByteIndex_ + _targetElementSize_ ×
    min(_srcLength_, _targetLength_ – _targetOffset_).

27. Repeat, while _targetByteIndex_ < _limit

    a.  Let _Pk_ be ToString(_k_).

    b.  Let _kValue_ be Get(_src_, _Pk_).

    c.  Let _kNumber_ be ToNumber(_kValue_).

    d.  ReturnIfAbrupt(_kNumber_).

    e.  Perform SetValueInBuffer(_targetBuffer_, _targetByteIndex_,
        _targetType_, _kNumber_).

    f.  Set _k_ to _k_ + 1.

    g.  Set _targetByteIndex_ to _targetByteIndex_ +
        _targetElementSize_.

28. Return UNDEFINED.

%TypedArray%.prototype.set(typedArray [, offset ] )

Set multiple values in this _TypedArray_, reading the values from the
_typedArray_ argument object. The optional _offset_ value indicates the
first element index in this _TypedArray_ where values are written. If
omitted, it is assumed to be 0.

1.  Assert: _typedArray_ has a [[TypedArrayName]] internal slot. If it
    does not, the definition in 22.2.3.22 applies.

2.  Let _target_ be the THIS value.

3.  If Type(_target_) is not Object, throw a TYPEERROR exception.

4.  If _target_ does not have a [[TypedArrayName]] internal slot, then
    throw a TYPEERROR exception.

5.  Assert: _target_ has a [[ViewedArrayBuffer]] internal slot.

6.  7.  8.  9.  10. 11. Let _targetOffset_ be ToInteger (_offset_)

12. ReturnIfAbrupt(_targetOffset_).

13. If _targetOffset_ < 0, then throw a RANGEERROR exception.

14. Let _targetBuffer_ be the value of _target_’s [[ViewedArrayBuffer]]
    internal slot.

15. If _targetBuffer_ is UNDEFINED, then throw a TYPEERROR exception.

16. If IsNeuteredBuffer(_targetBuffer_) is TRUE, then throw a TYPEERROR
    exception.

17. Let _targetLength_ be the value of _target_’s [[ArrayLength]]
    internal slot.

18. Let _srcBuffer_ be the value of _typedArray_’s [[ViewedArrayBuffer]]
    internal slot.

19. If _srcBuffer_ is UNDEFINED, then throw a TYPEERROR exception.

20. If IsNeuteredBuffer(_srcBuffer_) is TRUE, then throw a TYPEERROR
    exception.

21. Let _targetName_ be the string value of _target_’s
    [[TypedArrayName]] internal slot.

22. Let _targetType_ be the string value of the Element Type value in
    Table 45 for _targetName_.

23. Let _targetElementSize_ be the Number value of the Element Size
    value specified in Table 45 for _targetName_.

24. Let _targetByteOffset_ be the value of _target_’s [[ByteOffset]]
    internal slot.

25. Let _srcName_ be the string value of _typedArray_’s
    [[TypedArrayName]] internal slot.

26. Let _srcType_ be the string value of the Element Type value in Table
    45 for _srcName_ .

27. Let _srcElementSize_ be the Number value of the Element Size value
    specified in Table 45 for _srcName_.

28. Let _srcLength_ be the value of _typedArray_’s [[ArrayLength]]
    internal slot.

29. Let _srcByteOffset_ be the value of _typedArray_’s [[ByteOffset]]
    internal slot.

30. If _srcLength_ + _targetOffset_ > _targetLength_, then throw a
    RANGEERROR exception.

31. If SameValue(_srcBuffer_, _targetBuffer_) is TRUE, then

    a.  Let _srcBuffer_ be CloneArrayBuffer(_srcBuffer_,
        _srcByteOffset_).

    b.  ReturnIfAbrupt(_srcBuffer_).

    c.  If IsNeuteredBuffer(_targetBuffer_) is TRUE, then throw a
        TYPEERROR exception.

    d.  Let _srcByteIndex_ be 0.

32. Else, let _srcByteIndex_ be _srcByteOffset_.

33. Let _targetByteIndex_ be _targetOffset_ × _targetElementSize_ +
    _targetByteOffset_.

34. Let _limit_ be _targetByteIndex_ + _targetElementSize_ ×
    min(_srcLength_, _targetLength_ – _targetOffset_).

35. Repeat, while _targetByteIndex_ < _limit

    a.  Let _value_ be GetValueFromBuffer(_srcBuffer_, _srcByteIndex_,
        _srcType_).

    b.  Let _status_ be SetValueInBuffer (_targetBuffer_,
        _targetByteIndex_, _targetType_, _value_).

    c.  Set _srcByteIndex_ to _srcByteIndex_ + _srcElementSize_.

    d.  Set _targetByteIndex_ to _targetByteIndex_ +
        _targetElementSize_.

36. Return UNDEFINED.

%TypedArray%.prototype.slice ( start, end )

The interpretation and use of the arguments of
%TypedArray%.PROTOTYPE.SLICE are the same as for ARRAY.PROTOTYPE.SLICE
as defined in 22.1.3.22. The following steps are taken:

1.  Let _O_ be the THIS value.

2.  If Type(_O_) is not Object, throw a TYPEERROR exception.

3.  If _O_ does not have a [[TypedArrayName]] internal slot, then throw
    a TYPEERROR exception.

4.  Let _buffer_ be the value of _O_’s [[ViewedArrayBuffer]] internal
    slot.

5.  If _buffer_ is UNDEFINED, then throw a TYPEERROR exception.

6.  If IsNeuteredBuffer(_buffer_) is TRUE, throw a TYPEERROR exception.

7.  NOTE Side-effects of subsequent operations may still neuter
    _buffer_, but that will be detected by an accesses that are made to
    the content of _buffer_.

8.  Let _len_ be the value of _O’s_ [[ArrayLength]] internal slot.

9.  Let _relativeStart_ be ToInteger(_start_).

10. ReturnIfAbrupt(_relativeStart_).

11. If _relativeStart_ is negative, let _k_ be max((_len_ +
    _relativeStart_),0); else let _k_ be min(_relativeStart_, _len_).

12. If _end_ is UNDEFINED, let _relativeEnd_ be _len_; else let
    _relativeEnd_ be ToInteger(_end_).

13. ReturnIfAbrupt(_relativeEnd_).

14. If _relativeEnd_ is negative, let _final_ be max((_len_ +
    _relativeEnd_),0); else let _final_ be min(_relativeEnd_, _len_).

15. Let _count_ be max(_final_ – _k_, 0).

16. Let _C_ be Get(_O_, "CONSTRUCTOR").

17. ReturnIfAbrupt(_C_).

18. If IsConstructor(_C_) is TRUE, then

    a.  Let _A_ be the result of calling the [[Construct]] internal
        method of _C_ with argument (_count_).

    b.  ReturnIfAbrupt(_A_).

19. Else,

    a.  Throw a TYPEERROR exception.

20. Let _n_ be 0.

21. Repeat, while _k_ < _final

    a.  Let _Pk_ be ToString(_k_).

    b.  Let _kValue_ be Get(_O_, _Pk_).

    c.  ReturnIfAbrupt(_kValue_).

    d.  Let _status_ be Put(_A_, ToString(_n_), _kValue_, TRUE ).

    e.  ReturnIfAbrupt(_status_).

    f.  Increase _k_ by 1.

    g.  Increase _n_ by 1.

22. Return _A_.

This function is not generic. If the THIS value is not a object with a
[[TypedArrayName]] internal slot, a TYPEERROR exception is immediately
thrown when this function is called.

The LENGTH property of the SLICE method is 2.

%TypedArray%.prototype.some ( callbackfn [ , thisArg ] )

%TypedArray%.PROTOTYPE.SOME is a distinct function that implements the
same algorithm as ARRAY.PROTOTYPE.SOME as defined in 22.1.3.23 except
that the THIS object’s [[ArrayLength]] internal slot is accessed in
place of performing a [[Get]] of "LENGTH". The implementation of the
algorithm may be optimized with the knowledge that the THIS value is an
object that has a fixed length and whose integer indexed properties are
not sparse. However, such optimization must not introduce any observable
changes in the specified behaviour of the algorithm and must take into
account the possibility that calls to _callbackfn_ may neuter the the
THIS value.

This function is not generic. If the THIS value is not a object with a
[[TypedArrayName]] internal slot, a TYPEERROR exception is immediately
thrown when this function is called. A TYPEERROR exception is also
immediately thrown if the THIS value’s [[ViewedArrayBuffer]] is
UNDEFINED or has been neutered.

The LENGTH property of the SOME method is 1.

%TypedArray%.prototype.sort ( comparefn )

%TypedArray%.PROTOTYPE.SORT is a distinct function that, except as
described below, implements the same requirements as those of
ARRAY.PROTOTYPE.SORT as defined in 22.1.3.24. The implementation of the
%TypedArray%.PROTOTYPE.SORT specification may be optimized with the
knowledge that the THIS value is an object that has a fixed length and
whose integer indexed properties are not sparse. The only internal
methods of the THIS object that the algorithm may call are [[Get]] and
[[Set]].

This function is not generic. If the THIS value is not a object with a
[[TypedArrayName]] internal slot, a TYPEERROR exception is immediately
thrown when it is called.

Upon entry, the following steps are performed to initialize evaluation
of the SORT function. These steps are used instead of the entry steps in
22.1.3.24:

1.  Let _obj_ be the THIS value as the argument.

2.  If _obj_ does not have a [[TypedArrayName]] internal slot, then
    throw a TYPEERROR exception.

3.  Let _buffer_ be the value of _O_’s [[ViewedArrayBuffer]] internal
    slot.

4.  If _buffer_ is UNDEFINED, then throw a TYPEERROR exception.

5.  If IsNeuteredBuffer(_buffer_) is TRUE, then throw a TYPEERROR
    exception.

6.  Let _len_ be the value of _obj_’s [[ArrayLength]] internal slot.

The following version of SortCompare is used by
%TypedArray%.PROTOTYPE.SORT. It performs a numeric comparison rather
than the string comparsion used in 22.1.3.24.

The Typed Array SortCompare abstract operation is called with two
arguments _j_ and _k_, the following steps are taken:

1.  Let _jString_ be ToString(_j_).

2.  Let _kString_ be ToString(_k_).

3.  Let _x_ be Get(_obj_,_jString_).

4.  ReturnIfAbrupt(_x_).

5.  Let _y_ be the result of Get(_obj_, _kString_).

6.  ReturnIfAbrupt(_y_).

7.  Assert: Both Type(_x_) and Type(_y_) is Number.

8.  9.  10. 11. If the argument _comparefn_ is not UNDEFINED, then

    a.  If IsCallable(_comparefn_) is FALSE, throw a TYPEERROR
        exception.

    b.  Let _v_ be the result of calling the [[Call]] internal method of
        _comparefn_ passing UNDEFINED as _thisArgument_ and with a List
        containing the values of _x_ and _y_ as the _argumentsList_.

    c.  ReturnIfAbrupt(_v_).

    d.  If _v_ is NAN, then return +0.

    e.  Return _v_.

12. If _x_ and _y_ are both NAN, return +0.

13. If _x_ is NAN, return 1.

14. If _y_ is NAN, return −1.

15. If _x_ < _y_, return −1.

16. If _x_ > _y_, return 1.

17. Return +0.

NOTE 1 Because NAN always compares greater than any other value, NAN
property values always sort to the end of the result when a _comparefn_
is not provided.

%TypedArray%.prototype.subarray( [ begin [ , end ] ] )

Returns a new _TypedArray_ object whose element types is the same as
this _TypedArray_ and whose ArrayBuffer is the same as the ArrayBuffer
of this _TypedArray_, referencing the elements at _begin_, inclusive, up
to _end_, exclusive. If either _begin_ or _end_ is negative, it refers
to an index from the end of the array, as opposed to from the beginning.

1.  Let _O_ be the THIS value.

2.  If Type(_O_) is not Object, throw a TYPEERROR exception.

3.  If _O_ does not have a [[TypedArrayName]] internal slot, then throw
    a TYPEERROR exception.

4.  Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.

5.  Let _buffer_ be the value of _O_’s [[ViewedArrayBuffer]] internal
    slot.

6.  If _buffer_ is UNDEFINED, then throw a TYPEERROR exception.

7.  Let _srcLength_ be the value of _O_’s [[ArrayLength]] internal slot.

8.  Let _beginInt_ be ToInteger(_begin_)

9.  ReturnIfAbrupt(_beginInt_).

10. If _beginInt_ < 0, then let _beginInt_ be _srcLength_ + _beginInt_.

11. Let _beginIndex_ be min(_srcLength_, max(0, _beginInt_)).

12. If _end_ is UNDEFINED, then let _end_ be _srcLength_.

13. Let _endInt_ be ToInteger(_end_).

14. ReturnIfAbrupt(_endInt_).

15. If _endInt_ < 0, then let _endInt_ be _srcLength_ + _endInt_.

16. Let _endIndex_ be max(0,min(_srcLength_, _endInt_)).

17. If _endIndex_ < _beginIndex_, then let _endIndex_ be _beginIndex_.

18. Let _newLength_ be _endIndex_ - _beginIndex_.

19. Let _constructorName_ be the string value of _O_’s
    [[TypedArrayName]] internal slot.

20. Let _elementType_ be the string value of the Element Type value in
    Table 45 for _constructorName_.

21. Let _elementSize_ be the Number value of the Element Size value
    specified in Table 45 for _constructorName_.

22. Let _srcByteOffset_ be the value of _O_’s [[ByteOffset]] internal
    slot.

23. Let _beginByteOffset_ be _srcByteOffset_ + _beginIndex_ ×
    _elementSize_.

24. Let _constructor_ be Get(_O_, "CONSTRUCTOR").

25. ReturnIfAbrupt(_constructor_).

26. If IsConstructor(_constructor_) is FALSE, then throw a TYPEERROR
    exception.

27. Let _argumentsList_ be a List consisting of _buffer_,
    _beginByteOffset_, and _newLength_.

28. Return the result of calling the [[Construct]] internal method of
    _constructor_ with _argumentsList_ as the argument.

%TypedArray%.prototype.toLocaleString ([ reserved1 [ , reserved2 ] ])

The initial value of the %TypedArray%.prototype.toLocaleString data
property is the same built-in function object as the
Array.prototype.toLocaleString method defined in 22.1.3.26.

%TypedArray%.prototype.toString ( )

The initial value of the %TypedArray%.prototype.toString data property
is the same built-in function object as the Array.prototype.toString
method defined in 22.1.3.27.

%TypedArray%.prototype.values ( )

The following steps are taken:

1.  Let _O_ be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(_O_).

3.  If Type(_O_) is not Object, throw a TYPEERROR exception.

4.  If _O_ does not have a [[ViewedArrayBuffer]] internal slot throw a
    TYPEERROR exception.

5.  Let _buffer_ be the value of _O_’s [[ViewedArrayBuffer]] internal
    slot.

6.  If _buffer_ is UNDEFINED, then throw a TYPEERROR exception.

7.  If IsNeuteredBuffer(_buffer_) is TRUE, throw a TYPEERROR exception.

8.  Return CreateArrayIterator(_O_, "VALUE").

%TypedArray%.prototype [ @@iterator ] ( )

The initial value of the @@iterator property is the same function object
as the initial value of the %TypedArray%.PROTOTYPE.VALUES property.

get %TypedArray%.prototype [ @@toStringTag ]

%TypedArray%.PROTOTYPE[@@TOSTRINGTAG] is an accessor property whose set
accessor function is UNDEFINED. Its get accessor function performs the
following steps:

1.  Let _O_ be the THIS value.

2.  If Type(_O_) is not Object, throw a TYPEERROR exception.

3.  If _O_ does not have a [[TypedArrayName]] internal slot, throw a
    TYPEERROR exception.

4.  Let _name_ be the value of _O_’s [[TypedArrayName]] internal slot.

5.  If the value of _O_’s [[TypedArrayName]] internal slot is UNDEFINED,
    throw a TYPEERROR exception.

6.  Assert: _name_ is a String value.

7.  Return _name_.

This property has the attributes { [[Enumerable]]: FALSE,
[[Configurable]]: TRUE }.

The initial value of the NAME property of this function is "GET
[SYMBOL.TOSTRINGTAG]".

The _TypedArray_ Constructors

Each of these _TypedArray_ constructor objects has the structure
described below, differing only in the name used as the constructor name
instead of _TypedArray_, in Table 45.

When a _TypedArray_ constructor is called as a function rather than as a
constructor, it initializes a new _TypedArray_ object. The THIS value
passed in the call must be an Object with a [[TypedArrayName]] internal
slot and a [[ViewedArrayBuffer]] internal slot whose value is UNDEFINED.
The constructor function initializes the THIS value using the argument
values.

The _TypedArray_ constructors are designed to be subclassable. They may
be used as the value of an EXTENDS clause of a class declaration.
Subclass constructors that intended to inherit the specified
_TypedArray_ behaviour must include a SUPER call to the _TypedArray
constructor to initialize subclass instances.

_TypedArray_( ... argumentsList)

A _TypedArray_ constructor with a list of arguments _argumentsList_
performs the following steps:

1.  Let _O_ be the THIS value.

2.  If Type(_O_) is not Object, then throw a TYPEERROR exception.

3.  If _O_ does not have a [[TypedArrayName]] internal slot, then throw
    a TYPEERROR exception.

4.  If the value of _O’s_ [[TypedArrayName]] internal slot is not
    UNDEFINED, then throw a TYPEERROR exception.

5.  Set _O’s_ [[TypedArrayName]] internal slot to the String value from
    the constructor name column in the row of Table 45 corresponding to
    this constructor.

6.  Let _F_ be the active function object.

7.  Let _realmF_ be GetFunctionRealm(_F_) .

8.  Let _super_ be _realmF_.[[intrinsics]].[[%TypedArray%]].

9.  10. Return the result of calling the [[Call]] internal method of
    _super_ with _O_ and _argumentsList_ as arguments.

new _TypedArray_( ... argumentsList)

A _TypedArray_ constructor called as part of a new expression performs
the following steps:

1.  Let _F_ be the _TypedArray_ function object on which the NEW
    operator was applied.

2.  Let _argumentsList_ be the _argumentsList_ argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return Construct(_F_, _argumentsList_).

Properties of the _TypedArray_ Constructors

The value of the [[Prototype]] internal slot of each _TypedArray_
constructor is the %TypedArray% intrinsic object (22.2.1).

Each _TypedArray_ constructor has a NAME property whose value is the
String value of the constructor name specifried for it in Table 45.

Besides a LENGTH property (whose value is 3), each _TypedArray_
constructor has the following properties:

_TypedArray_.BYTES_PER_ELEMENT

The value of _TypedArray_.BYTES_PER_ELEMENT is the Number value of the
Element Size value specified in Table 45 for _TypedArray_.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

_TypedArray_.prototype

The initial value of _TypedArray_.prototype is the corresponding
_TypedArray_ prototype object (22.2.6).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Properties of _TypedArray_ Prototype Objects

The value of the [[Prototype]] internal slot of a _TypedArray_ prototype
object is the standard built-in %TypedArrayPrototype% object (22.2.3). A
_TypedArray_ prototype object is an ordinary object. It does not have a
[[ViewedArrayBuffer]] or or any other of the internal slots that are
specific to _TypedArray_ instance objects.

_TypedArray_.prototype.BYTES_PER_ELEMENT

The value of _TypedArray_.prototype.BYTES_PER_ELEMENT is the Number
value of the Element Size value specified in Table 45 for _TypedArray_.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

_TypedArray_.prototype.constructor

The initial value of a _TypedArray_.prototype.constructor is the
corresponding standard built-in _TypedArray_ constructor.

Properties of _TypedArray_ Instances

_TypedArray_ instances are Integer Indexed exotic objects. Each
_TypedArray_ instances inherits properties from the corresponding
_TypedArray_ prototype object. Each _TypedArray_ instances have the
following internal slots: [[TypedArrayName]], [[ViewedArrayBuffer]],
[[ByteLength]], [[ByteOffset]], and [[ArrayLength]].



KEYED COLLECTION 


Map Objects

Map objects are collections of key/value pairs where both the keys and
values may be arbitrary ECMAScript language values. A distinct key value
may only occur in one key/value pair within the Map’s collection.
Distinct key values are discriminated using the SameValueZero
comparision algorithm.

Map object must be implemented using either hash tables or other
mechanisms that, on average, provide access times that are sublinear on
the number of elements in the collection. The data structures used in
this Map objects specification is only intended to describe the required
observable semantics of Map objects. It is not intended to be a viable
implementation model.

The Map Constructor 

The Map constructor is the %Map% intrinsic object and the initial value
of the MAP property of the global object. When MAP is called as a
function rather than as a constructor, it initializes its THIS value
with the internal state necessary to support the MAP.PROTOTYPE built-in
methods.

The MAP constructor is designed to be subclassable. It may be used as
the value in an EXTENDS clause of a class definition. Subclass
constructors that intend to inherit the specified MAP behaviour must
include a SUPER call to MAP.

Map ( [ iterable ] ) 

When the MAP function is called with optional argument the following
steps are taken:

1.  Let _map_ be the THIS value.

2.  If Type(_map_) is not Object then, throw a TYPEERROR exception.

3.  If _map_ does not have a [[MapData]] internal slot, then throw a
    TYPEERROR exception.

4.  If _map’s_ [[MapData]] internal slot is not UNDEFINED, then throw a
    TYPEERROR exception.

5.  If _iterable_ is not present, let _iterable_ be UNDEFINED.

6.  If _iterable_ is either UNDEFINED or NULL, then let _iter_ be
    UNDEFINED.

7.  Else,

    a.  b.  c.  Let _adder_ be the result of Get(_map_, "SET").

    d.  ReturnIfAbrupt(_adder_).

    e.  If IsCallable(_adder_) is FALSE, throw a TYPEERROR Exception.

    f.  Let _iter_ be the result of GetIterator(_iterable_).

    g.  ReturnIfAbrupt(_iter_).

8.  If the value of _map’s_ [[MapData]] internal slot is not UNDEFINED,
    then throw a TYPEERROR exception.

9.  Assert: _map_ has not been reentrantly initialized.

10. Set _map’s_ [[MapData]] internal slot to a new empty List.

11. If _iter_ is UNDEFINED, then return _map_.

12. Repeat

    a.  Let _next_ be the result of IteratorStep(_iter_).

    b.  ReturnIfAbrupt(_next_).

    c.  If _next_ is FALSE, then return _map_.

    d.  Let _nextItem_ be IteratorValue(_next_).

    e.  ReturnIfAbrupt(_nextItem_).

    f.  If Type(_nextItem_) is not Object, then throw a TYPEERROR
        exception.

    g.  Let _k_ be the result of Get(_nextItem_, "0").

    h.  ReturnIfAbrupt(_k_).

    i.  Let _v_ be the result of Get(_nextItem_, "1").

    j.  ReturnIfAbrupt(_v_).

    k.  Let _status_ be the result of calling the [[Call]] internal
        method of _adder_ with _map_ as _thisArgument_ and a List whose
        elements are _k_ and _v_ as _argumentsList_.

    l.  ReturnIfAbrupt(_status_).

NOTE If the parameter _iterable_ is present, it is expected to be an
object that implements an @@iterator method that returns an iterator
object that produces a two element array-like object whose first element
is a value that will be used as a Map key and whose second element is
the value to associate with that key.

new Map ( ... argumentsList )

When MAP is called as part of a NEW expression it is a constructor: it
initializes a newly created object.

MAP called as part of a new expression with argument list
_argumentsList_ performs the following steps:

1.  Let _F_ be the Map function object on which the NEW operator was
    applied.

2.  Let _argumentsList_ be the _argumentsList_ argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of Construct(_F_, _argumentsList_).

If Map is implemented as an ECMAScript function object, its
[[Construct]] internal method will perform the above steps.

Properties of the Map Constructor

The value of the [[Prototype]] internal slot of the Map constructor is
the Function prototype object (19.2.3).

Besides the LENGTH property (whose value is 1), the Map constructor has
the following properties:

Map.prototype

The initial value of MAP.PROTOTYPE is the Map prototype object (23.1.3).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Map[ @@create ] ( )

The @@create method of a Map function object _F_ performs the following
steps:

1.  Let _F_ be the THIS value.

2.  Let _obj_ be the result of calling
    OrdinaryCreateFromConstructor(_F_, "%MAPPROTOTYPE%", ([[MapData]])
    ).

3.  Return _obj_.

The value of the NAME property of this function is "[SYMBOL.CREATE]".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Properties of the Map Prototype Object

The value of the [[Prototype]] internal slot of the Map prototype object
is the standard built-in Object prototype object (19.1.3). The Map
prototype object is an ordinary object. It does not have a [[MapData]]
internal slot.

Map.prototype.clear ( )

The following steps are taken:

1.  Let _M_ be the THIS value.

2.  If Type(_M)_ is not Object, then throw a TYPEERROR exception.

3.  If _M_ does not have a [[MapData]] internal slot throw a TYPEERROR
    exception.

4.  If _M’s_ [[MapData]] internal slot is UNDEFINED, then throw a
    TYPEERROR exception.

5.  Let _entries_ be the List that is the value of _M_’s [[MapData]]
    internal slot.

6.  Repeat for each Record {[[key]], [[value]]} _p_ that is an element
    of _entries,_

    a.  Set _p_.[[key]] to empty_._

    b.  Set _p_.[[value]] to empty_._

7.  Return UNDEFINED.

NOTE The existing [[MapData]] List is preserved because there may be
existing MapIterator objects that are suspended midway through iterating
over that List.

Map.prototype.constructor

The initial value of MAP.PROTOTYPE.CONSTRUCTOR is the built-in MAP
constructor.

Map.prototype.delete ( key )

The following steps are taken:

1.  Let _M_ be the THIS value.

2.  If Type(_M)_ is not Object, then throw a TYPEERROR exception.

3.  If _M_ does not have a [[MapData]] internal slot throw a TYPEERROR
    exception.

4.  If _M’s_ [[MapData]] internal slot is UNDEFINED, then throw a
    TYPEERROR exception.

5.  Let _entries_ be the List that is the value of _M_’s [[MapData]]
    internal slot.

6.  Repeat for each Record {[[key]], [[value]]} _p_ that is an element
    of _entries,_

    a.  If _p_.[[key]] is not empty and SameValueZero(_p_.[[key]],
        _key_) is TRUE, then

        i.  Set _p_.[[key]] to empty_._

        ii. Set _p_.[[value]] to empty_._

        iii. Return TRUE.

7.  Return FALSE.

NOTE The value EMPTY is used as a specification device to indicate that
an entry has been deleted. Actual implementations may take other actions
such as physically removing the entry from internal data structures.

Map.prototype.entries ( )

The following steps are taken:

1.  Let _M_ be the THIS value.

2.  Return the result of calling the CreateMapIterator abstract
    operation with arguments _M_ and "KEY+VALUE".

Map.prototype.forEach ( callbackfn [ , thisArg ] )

NOTE _callbackfn_ should be a function that accepts three arguments.
FOREACH calls _callbackfn_ once for each key/value pair present in the
map object, in key insertion order. _callbackfn_ is called only for keys
of the map which actually exist; it is not called for keys that have
been deleted from the map.

If a _thisArg_ parameter is provided, it will be used as the THIS value
for each invocation of _callbackfn_. If it is not provided, UNDEFINED is
used instead.

_callbackfn_ is called with three arguments: the value of the item, the
key of the item, and the Map object being traversed.

FOREACH does not directly mutate the object on which it is called but
the object may be mutated by the calls to _callbackfn_.

When the FOREACH method is called with one or two arguments, the
following steps are taken:

1.  Let _M_ be the THIS value.

2.  If Type(_M)_ is not Object, then throw a TYPEERROR exception.

3.  If _M_ does not have a [[MapData]] internal slot throw a TYPEERROR
    exception.

4.  If _M’s_ [[MapData]] internal slot is UNDEFINED, then throw a
    TYPEERROR exception.

5.  If IsCallable(_callbackfn_) is FALSE, throw a TYPEERROR exception.

6.  If _thisArg_ was supplied, let _T_ be _thisArg_; else let _T_ be
    UNDEFINED.

7.  Let _entries_ be the List that is the value of _M_’s [[MapData]]
    internal slot.

8.  Repeat for each Record {[[key]], [[value]]} _e_ that is an element
    of _entries,_ in original key insertion order

    a.  If _e_.[[key]] is not empty, then

        i.  Let _funcResult_ be the result of calling the [[Call]]
            internal method of _callbackfn_ with _T_ as _thisArgument_
            and a List containing _e_.[[value]], _e_.[[key]], and _M_ as
            _argumentsList_.

        ii. ReturnIfAbrupt(_funcResult_).

9.  Return UNDEFINED.

The LENGTH property of the FOREACH method is 1.

Map.prototype.get ( key )

The following steps are taken:

1.  Let _M_ be the THIS value.

2.  If Type(_M)_ is not Object, then throw a TYPEERROR exception.

3.  If _M_ does not have a [[MapData]] internal slot throw a TYPEERROR
    exception.

4.  If _M’s_ [[MapData]] internal slot is UNDEFINED, then throw a
    TYPEERROR exception.

5.  Let _entries_ be the List that is the value of _M_’s [[MapData]]
    internal slot.

6.  Repeat for each Record {[[key]], [[value]]} _p_ that is an element
    of _entries,_

    a.  If _p_.[[key]] is not empty and SameValueZero(_p_.[[key]],
        _key_) is TRUE, then return _p_.[[value]].

7.  Return UNDEFINED.

Map.prototype.has ( key )

The following steps are taken:

1.  Let _M_ be the THIS value.

2.  If Type(_M)_ is not Object, then throw a TYPEERROR exception.

3.  If _M_ does not have a [[MapData]] internal slot throw a TYPEERROR
    exception.

4.  If _M’s_ [[MapData]] internal slot is UNDEFINED, then throw a
    TYPEERROR exception.

5.  Let _entries_ be the List that is the value of _M_’s [[MapData]]
    internal slot.

6.  Repeat for each Record {[[key]], [[value]]} _p_ that is an element
    of _entries,_

    a.  If _p_.[[key]] is not empty and SameValueZero(_p_.[[key]],
        _key_) is TRUE, then return TRUE_._

7.  Return FALSE.

Map.prototype.keys ( )

The following steps are taken:

1.  Let _M_ be the THIS value.

2.  Return the result of calling the CreateMapIterator abstract
    operation with arguments _M_ and "KEY".

Map.prototype.set ( key , value )

The following steps are taken:

1.  Let _M_ be the THIS value.

2.  If Type(_M)_ is not Object, then throw a TYPEERROR exception.

3.  If _M_ does not have a [[MapData]] internal slot throw a TYPEERROR
    exception.

4.  If _M’s_ [[MapData]] internal slot is UNDEFINED, then throw a
    TYPEERROR exception.

5.  Let _entries_ be the List that is the value of _M_’s [[MapData]]
    internal slot.

6.  Repeat for each Record {[[key]], [[value]]} _p_ that is an element
    of _entries,_

    a.  If _p_.[[key]] is not empty and SameValueZero(_p_.[[key]],
        _key_) is TRUE, then

        i.  Set _p_.[[value]] to _value._

        ii. Return _M_.

7.  If _key_ is −0, then let _key_ be +0.

8.  Let _p_ be the Record {[[key]]: _key_, [[value]]: _value_}.

9.  Append _p_ as the last element of _entries_.

10. Return _M_.

get Map.prototype.size 

Map.prototype.size is an accessor property whose set accessor function
is UNDEFINED. Its get accessor function performs the following steps:

1.  Let _M_ be the THIS value.

2.  If Type(_M)_ is not Object, then throw a TYPEERROR exception.

3.  If _M_ does not have a [[MapData]] internal slot throw a TYPEERROR
    exception.

4.  If _M’s_ [[MapData]] internal slot is UNDEFINED, then throw a
    TYPEERROR exception.

5.  Let _entries_ be the List that is the value of _M_’s [[MapData]]
    internal slot.

6.  Let _count_ be 0.

7.  For each Record {[[key]], [[value]]} _p_ that is an element of
    _entries_

    a.  If _p_.[[key]] is not empty then

        i.  Set _count_ to _count_+1.

8.  Return _count_.

Map.prototype.values ( )

The following steps are taken:

1.  Let _M_ be the THIS value.

2.  Return the result of calling the CreateMapIterator abstract
    operation with arguments _M_ and "VALUE".

Map.prototype [ @@iterator ]( )

The initial value of the @@iterator property is the same function object
as the initial value of the ENTRIES property.

Map.prototype [ @@toStringTag ]

The initial value of the @@toStringTag property is the string value
"MAP".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Properties of Map Instances

Map instances are ordinary objects that inherit properties from the Map
prototype. Map instances also have a [[MapData]] internal slot.

Map Iterator Objects 

A Map Iterator is an object, that represents a specific iteration over
some specific Map instance object. There is not a named constructor for
Map Iterator objects. Instead, map iterator objects are created by
calling certain methods of Map instance objects.

CreateMapIterator Abstract Operation

Several methods of Map objects return Iterator objects. The abstract
operation CreateMapIterator with arguments _map_ and _kind_ is used to
create such iterator objects. It performs the following steps:

1.  If Type(_map_) is not Object, throw a TYPEERROR exception.

2.  If _map_ does not have a [[MapData]] internal slot throw a TYPEERROR
    exception.

3.  If the value of _map’s_ [[MapData]] internal slot is UNDEFINED, then
    throw a TYPEERROR exception.

4.  Let _iterator_ be the result of ObjectCreate(%MapIteratorPrototype%,
    ([[Map]], [[MapNextIndex]], [[MapIterationKind]])).

5.  Set _iterator’s_ [[Map]] internal slot to _map_.

6.  Set _iterator’s_ [[MapNextIndex]] internal slot to 0.

7.  Set _iterator’s_ [[MapIterationKind]] internal slot to _kind_.

8.  Return _iterator_.

The %MapIteratorPrototype% Object

All Map Iterator Objects inherit properties from the
%MapIteratorPrototype% intrinsic object. The %MapIteratorPrototype%
intrinsic object is an ordinary object and its [[Prototype]] internal
slot is the %ObjectPrototype% intrinsic object. In addition,
%MapIteratorPrototype% has the following properties:

%MapIteratorPrototype%.next ( )

1.  Let _O_ be the THIS value.

2.  If Type(_O_) is not Object, throw a TYPEERROR exception.

3.  If _O_ does not have all of the internal slots of a Map Iterator
    Instance (23.1.5.3), throw a TYPEERROR exception.

4.  Let _m_ be the value of the [[Map]] internal slot of _O_.

5.  Let _index_ be the value of the [[MapNextIndex]] internal slot of
    _O_.

6.  Let _itemKind_ be the value of the [[MapIterationKind]] internal
    slot of _O_.

7.  If _m_ is UNDEFINED, then return CreateIterResultObject(UNDEFINED,
    TRUE)

8.  Assert: _m_ has a [[MapData]] internal slot and _m_ has been
    initialized so the value of [[MapData]] is not UNDEFINED.

9.  Let _entries_ be the List that is the value of the [[MapData]]
    internal slot of _m_.

10. Repeat while _index_ is less than the total number of elements of
    _entries_. The number of elements must be redetermined each time
    this method is evaluated.

    a.  Let _e_ be the Record {[[key]], [[value]]} that is the value of
        _entries_[_index_].

    b.  Set _index_ to _index_+1;

    c.  Set the [[MapNextIndex]] internal slot of _O_ to _index_.

    d.  If _e_.[[key]] is not empty, then

        i.  If _itemKind_ is "KEY" then, let _result_ be _e_.[[key]].

        ii. Else if _itemKind_ is "VALUE" then, let _result_ be
            _e_.[[value]].

        iii. Else,

            1.  Assert: _itemKind_ is "KEY+VALUE".

            2.  Let _result_ be the result of performing ArrayCreate(2).

            3.  Assert: _result_ is a new, well-formed Array object so
                the following operations will never fail.

            4.  Call CreateDataProperty(_result_, "0", _e_.[[key]]) .

            5.  Call CreateDataProperty(_result_, "1", _e_.[[value]]).

        iv. Return CreateIterResultObject(_result_, FALSE).

11. Set the [[Map]] internal slot of _O_ to UNDEFINED.

12. Return CreateIterResultObject(UNDEFINED, TRUE).

 %MapIteratorPrototype% [ @@iterator ] ( )

The following steps are taken:

1.  Return the THIS value.

The value of the NAME property of this function is "[SYMBOL.ITERATOR]".

%MapIteratorPrototype% [ @@toStringTag ]

The initial value of the @@toStringTag property is the string value "MAP
ITERATOR".

Properties of Map Iterator Instances

Map Iterator instances are ordinary objects that inherit properties from
the %MapIteratorPrototype% intrinsic object. Map Iterator instances are
initially created with the internal slots described in Table 46.

Table 46 — Internal Slots of Map Iterator Instances

  ---------------------- ------------------------------------------------------------------------------------------------------------------------------------------------
  INTERNAL SLOT          DESCRIPTION
  [[Map]]                The Map object that is being iterated.
  [[MapNextIndex]]       The integer index of the next Map data element to be examined by this iterator.
  [[MapIterationKind]]   A string value that identifies what is to be returned for each element of the iteration. The possible values are: "KEY", "VALUE", "KEY+VALUE".
  ---------------------- ------------------------------------------------------------------------------------------------------------------------------------------------


Set Objects

Set objects are collections of ECMAScript language values. A distinct
value may only occur once as an element of a Set’s collection. Distinct
values are discriminated using the SameValueZero comparision algorithm.

Set objects must be implemented using either hash tables or other
mechanisms that, on average, provide access times that are sublinear on
the number of elements in the collection. The data structures used in
this Set objects specification is only intended to describe the required
observable semantics of Set objects. It is not intended to be a viable
implementation model.

The Set Constructor 

The Set constructor is the %Set% intrinsic object and the initial value
of the SET property of the global object. When SET is called as a
function rather than as a constructor, it initializes its THIS value
with the internal state necessary to support the SET.PROTOTYPE built-in
methods.

The SET constructor is designed to be subclassable. It may be used as
the value in an EXTENDS clause of a class definition. Subclass
constructors that intend to inherit the specified SET behaviour must
include a SUPER call to SET.

Set ( [ iterable ] )

When the SET function is called with optional argument _iterable_ the
following steps are taken:

1.  Let _set_ be the THIS value.

2.  If Type(_set_) is not Object then, throw a TYPEERROR exception.

3.  If _set_ does not have a [[SetData]] internal slot, then throw a
    TYPEERROR exception.

4.  If _set’s_ [[SetData]] internal slot is not UNDEFINED, then throw a
    TYPEERROR exception.

5.  If _iterable_ is not present, let _iterable_ be UNDEFINED.

6.  If _iterable_ is either UNDEFINED or NULL, then let _iter_ be
    UNDEFINED.

7.  Else,

    a.  b.  c.  Let _adder_ be the result of Get(_set_, "ADD").

    d.  ReturnIfAbrupt(_adder_).

    e.  If IsCallable(_adder_) is FALSE, throw a TYPEERROR Exception.

    f.  Let _iter_ be the result of GetIterator(ToObject(_iterable_)).

    g.  ReturnIfAbrupt(_iter_).

8.  If the value of _set’s_ [[SetData]] internal slot is not UNDEFINED,
    then throw a TYPEERROR exception.

9.  Assert: _set_ has not been reentrantly initialized.

10. Set _set’s_ [[SetData]] internal slot to a new empty List.

11. If _iter_ is UNDEFINED, then return _set_.

12. Repeat

    a.  Let _next_ be the result of IteratorStep(_iter_).

    b.  ReturnIfAbrupt(_next_).

    c.  If _next_ is FALSE, then return _set_.

    d.  Let _nextValue_ be IteratorValue(_next_).

    e.  ReturnIfAbrupt(_nextValue_).

    f.  Let _status_ be the result of calling the [[Call]] internal
        method of _adder_ with _set_ as _thisArgument_ and a List whose
        sole element is _nextValue_ as _argumentsList_.

    g.  ReturnIfAbrupt(_status_).

NOTE Using a method call for inserting values during initialization
enables subclasses to that redefine add to still make a super call to
the inherited constructor.

new Set ( ...argumentsList )

When SET is called as part of a NEW expression it is a constructor: it
initializes a newly created object. Set called as part of a new
expression with argument list _argumentsList_ performs the following
steps:

1.  Let _F_ be the Set function object on which the NEW operator was
    applied.

2.  Let _argumentsList_ be the _argumentsList_ argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of Construct(_F_, _argumentsList_).

If Set is implemented as an ECMAScript function object, its
[[Construct]] internal method will perform the above steps.

Properties of the Set Constructor

The value of the [[Prototype]] internal slot of the Set constructor is
the Function prototype object (19.2.3).

Besides the LENGTH property (whose value is 1), the Set constructor has
the following properties:

Set.prototype

The initial value of SET.PROTOTYPE is the intrinsic %SetPrototype%
object (23.2.3).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Set[ @@create ] ( )

The @@create method of a Set function object _F_ performs the following
steps:

1.  Let _F_ be the THIS value.

2.  Let _obj_ be the result of calling
    OrdinaryCreateFromConstructor(_F_, "%SETPROTOTYPE%", (
    [[SetData]])).

3.  Return _obj_.

The value of the NAME property of this function is "[SYMBOL.CREATE]".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Properties of the Set Prototype Object

The value of the [[Prototype]] internal slot of the Set prototype object
is the standard built-in Object prototype object (19.1.3). The Set
prototype object is an ordinary object. It does not have a [[SetData]]
internal slot.

Set.prototype.add ( value )

The following steps are taken:

1.  Let _S_ be the THIS value.

2.  If Type(_S)_ is not Object, then throw a TYPEERROR exception.

3.  If _S_ does not have a [[SetData]] internal slot throw a TYPEERROR
    exception.

4.  If _S’s_ [[SetData]] internal slot is UNDEFINED, then throw a
    TYPEERROR exception.

5.  Let _entries_ be the List that is the value of _S_’s [[SetData]]
    internal slot.

6.  Repeat for each _e_ that is an element of _entries,

    a.  If _e_ is not empty and SameValueZero(_e_, _value_) is TRUE,
        then

        i.  Return _S_.

7.  If _value_ is −0, then let _value_ be +0.

8.  Append _value_ as the last element of _entries_.

9.  Return _S_.

Set.prototype.clear ( )

The following steps are taken:

1.  Let _S_ be THIS value.

2.  If Type(_S)_ is not Object, then throw a TYPEERROR exception.

3.  If _S_ does not have a [[SetData]] internal slot throw a TYPEERROR
    exception.

4.  If _S’s_ [[SetData]] internal slot is UNDEFINED, then throw a
    TYPEERROR exception.

5.  Let _entries_ be the List that is the value of _S_’s [[SetData]]
    internal slot.

6.  Repeat for each _e_ that is an element of _entries,

    a.  Replace the element of _entries_ whose value is _e_ with an
        element whose value is empty_._

7.  Return UNDEFINED.

Set.prototype.constructor

The initial value of SET.PROTOTYPE.CONSTRUCTOR is the built-in SET
constructor.

Set.prototype.delete ( value )

The following steps are taken:

1.  Let _S_ be the THIS value.

2.  If Type(_S)_ is not Object, then throw a TYPEERROR exception.

3.  If _S_ does not have a [[SetData]] internal slot throw a TYPEERROR
    exception.

4.  If _S’s_ [[SetData]] internal slot is UNDEFINED, then throw a
    TYPEERROR exception.

5.  Let _entries_ be the List that is the value of _S_’s [[SetData]]
    internal slot.

6.  Repeat for each _e_ that is an element of _entries_,

    a.  If _e_ is not empty and SameValueZero(_e_, _value_) is TRUE,
        then

        i.  Replace the element of _entries_ whose value is _e_ with an
            element whose value is empty_._

        ii. Return TRUE.

7.  Return FALSE.

NOTE The value EMPTY is used as a specification device to indicate that
an entry has been deleted. Actual implementations may take other actions
such as physically removing the entry from internal data structures.

Set.prototype.entries ( )

The following steps are taken:

1.  Let _S_ be the THIS value.

2.  Return the result of calling the CreateSetIterator abstract
    operation with arguments _S_ and "KEY+VALUE".

NOTE For iteration purposes, a Set appears similar to a Map where each
entry has the same value for its key and value.

Set.prototype.forEach ( callbackfn [ , thisArg ] )

NOTE _callbackfn_ should be a function that accepts three arguments.
FOREACH calls _callbackfn_ once for each value present in the set
object, in value insertion order. _callbackfn_ is called only for values
of the Set which actually exist; it is not called for keys that have
been deleted from the set.

If a _thisArg_ parameter is provided, it will be used as the THIS value
for each invocation of _callbackfn_. If it is not provided, UNDEFINED is
used instead.

If _callbackfn_ is an Arrow Function, THIS was lexically bound when the
function was created so _thisArg_ will have no effect.

_callbackfn_ is called with three arguments: the first two arguments are
a value contained in the Set. The same value of passed for both
arguments. The Set object being traversed is passed as the third
argument.

The _callbackfn_ is called with three arguments to be consistent with
the call back functions used by FOREACH methods for Map and Array. For
Sets, each item value is considered to be both the key and the value.

FOREACH does not directly mutate the object on which it is called but
the object may be mutated by the calls to _callbackfn_.

Each value is normally visited only once. However, a value will be
revisited if it is deleted after it has been visited and then re-added
before the to FOREACH call completes. Values that are deleted after the
call to FOREACH begins and before being visited are not visited unless
the value is added again before the to FOREACH call completes. New
values added, after the call to FOREACH begins are visited.

When the FOREACH method is called with one or two arguments, the
following steps are taken:

1.  Let _S_ be the THIS value.

2.  If Type(_S)_ is not Object, then throw a TYPEERROR exception.

3.  If _S_ does not have a [[SetData]] internal slot throw a TYPEERROR
    exception.

4.  If _S’s_ [[SetData]] internal slot is UNDEFINED, then throw a
    TYPEERROR exception.

5.  If IsCallable(_callbackfn_) is FALSE, throw a TYPEERROR exception.

6.  If _thisArg_ was supplied, let _T_ be _thisArg_; else let _T_ be
    UNDEFINED.

7.  Let _entries_ be the List that is the value of _S_’s [[SetData]]
    internal slot.

8.  Repeat for each _e_ that is an element of _entries,_ in original
    insertion order

    a.  If _e_ is not empty, then

        i.  Let _funcResult_ be the result of calling the [[Call]]
            internal method of _callbackfn_ with _T_ as _thisArgument_
            and a List containing _e_, _e_, and _S_ as _argumentsList_.

        ii. ReturnIfAbrupt(_funcResult_).

9.  Return UNDEFINED.

The LENGTH property of the FOREACH method is 1.

Set.prototype.has ( value )

The following steps are taken:

1.  Let _S_ be the THIS value.

2.  If Type(_S)_ is not Object, then throw a TYPEERROR exception.

3.  If _S_ does not have a [[SetData]] internal slot throw a TYPEERROR
    exception.

4.  If _S’s_ [[SetData]] internal slot is UNDEFINED, then throw a
    TYPEERROR exception.

5.  Let _entries_ be the List that is the value of _S_’s [[SetData]]
    internal slot.

6.  Repeat for each _e_ that is an element of _entries,

    a.  If _e_ is not empty and SameValueZero(_e_, _value_) is TRUE,
        then return TRUE_._

7.  Return FALSE.

Set.prototype.keys ( )

The initial value of the KEYS property is the same function object as
the initial value of the VALUES property.

NOTE For iteration purposes, a Set appears similar to a Map where each
entry has the same value for its key and value.

get Set.prototype.size 

SET.PROTOTYPE.SIZE is an accessor property whose set accessor function
is UNDEFINED. Its get accessor function performs the following steps:

1.  Let _S_ be the THIS value.

2.  If Type(_S)_ is not Object, then throw a TYPEERROR exception.

3.  If _S_ does not have a [[SetData]] internal slot throw a TYPEERROR
    exception.

4.  If _S’s_ [[SetData]] internal slot is UNDEFINED, then throw a
    TYPEERROR exception.

5.  Let _entries_ be the List that is the value of _S_’s [[SetData]]
    internal slot.

6.  Let _count_ be 0.

7.  For each _e_ that is an element of _entries

    a.  If _e_ is not empty then

        i.  Set _count_ to _count_+1.

8.  Return _count_.

Set.prototype.values ( )

The following steps are taken:

1.  Let _S_ be the THIS value.

2.  Return the result of calling the CreateSetIterator abstract
    operation with argument _S_ and "VALUE".

Set.prototype [@@iterator ] ( )

The initial value of the @@iterator property is the same function object
as the initial value of the VALUES property.

Set.prototype [ @@toStringTag ]

The initial value of the @@toStringTag property is the string value
"SET".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Properties of Set Instances

Set instances are ordinary objects that inherit properties from the Set
prototype. After initialization by the Set constructor, Set instances
also have a [[SetData]] internal slot.

Set Iterator Objects 

A Set Iterator is an ordinary object, with the structure defined below,
that represents a specific iteration over some specific Set instance
object. There is not a named constructor for Set Iterator objects.
Instead, set iterator objects are created by calling certain methods of
Set instance objects.

CreateSetIterator Abstract Operation

Several methods of Set objects return Iterator objects. The abstract
operation CreateSetIterator with arguments _set_ and _kind_ is used to
create such iterator objects. It performs the following steps:

1.  If Type(_set_) is not Object, throw a TYPEERROR exception.

2.  If _set_ does not have a [[SetData]] internal slot throw a TYPEERROR
    exception.

3.  If _set’s_ [[SetData]] internal slot is UNDEFINED, then throw a
    TYPEERROR exception.

4.  Let _iterator_ be the result of ObjectCreate(%SetIteratorPrototype%,
    ([[IteratedSet]], [[SetNextIndex]], [[SetIterationKind]])).

5.  Set _iterator’s_ [[IteratedSet]] internal slot to _set_.

6.  Set _iterator’s_ [[SetNextIndex]] internal slot to 0.

7.  Set _iterator’s_ [[SetIterationKind]] internal slot to _kind_.

8.  Return _iterator_.

The %SetIteratorPrototype% Object

All Set Iterator Objects inherit properties from the
%SetIteratorPrototype% intrinsic object. The %SetIteratorPrototype%
intrinsic object is an ordinary object and its [[Prototype]] internal
slot is the %ObjectPrototype% intrinsic object. In addition,
%SetIteratorPrototype% has the following properties:

%SetIteratorPrototype%.next ( )

1.  Let _O_ be the THIS value.

2.  If Type(_O_) is not Object, throw a TYPEERROR exception.

3.  If _O_ does not have all of the internal slots of a Set Iterator
    Instance (23.2.5.3), throw a TYPEERROR exception.

4.  Let _s_ be the value of the [[IteratedSet]] internal slot of _O_.

5.  Let _index_ be the value of the [[SetNextIndex]] internal slot of
    _O_.

6.  Let _itemKind_ be the value of the [[SetIterationKind]] internal
    slot of _O_.

7.  If _s_ is UNDEFINED, then return CreateIterResultObject(UNDEFINED,
    TRUE).

8.  Assert: _s_ has a [[SetData]] internal slot and _s_ has been
    initialized so the value of [[SetData]] is not UNDEFINED.

9.  Let _entries_ be the List that is the value of the [[SetData]]
    internal slot of _s_.

10. Repeat while _index_ is less than the total number of elements of
    _entries_. The number of elements must be redetermined each time
    this method is evaluated.

    a.  Let _e_ be _entries_[_index_].

    b.  Set _index_ to _index_+1;

    c.  Set the [[SetNextIndex]] internal slot of _O_ to _index_.

    d.  If _e_ is not empty, then

        i.  If _itemKind_ is "KEY+VALUE" then,

            1.  Let _result_ be the result of performing ArrayCreate(2).

            2.  Assert: _result_ is a new, well-formed Array object so
                the following operations will never fail.

            3.  Call CreateDataProperty(_result_, "0", _e_) .

            4.  Call CreateDataProperty(_result_, "1", _e_).

            5.  Return CreateIterResultObject(_result_, FALSE).

        ii. Return CreateIterResultObject(_e_, FALSE).

11. Set the [[IteratedSet]] internal slot of _O_ to UNDEFINED.

12. Return CreateIterResultObject(UNDEFINED, TRUE).

%SetIteratorPrototype% [ @@iterator ] ( )

The following steps are taken:

1.  Return the THIS value.

The value of the NAME property of this function is "[SYMBOL.ITERATOR]".

%SetIteratorPrototype% [ @@toStringTag ]

The initial value of the @@toStringTag property is the string value "SET
ITERATOR".

Properties of Set Iterator Instances

Set Iterator instances are ordinary objects that inherit properties from
the %SetIteratorPrototype% intrinsic object. Set Iterator instances are
initially created with the internal slots specified in Table 47.

Table 47 — Internal Slots of Set Iterator Instances

  ---------------------- -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  INTERNAL SLOT          DESCRIPTION
  [[IteratedSet]]        The Set object that is being iterated.
  [[SetNextIndex]]       The integer index of the next Set data element to be examined by this iterator
  [[SetIterationKind]]   A string value that identifies what is to be returned for each element of the iteration. The possible values are: "KEY", "VALUE", "KEY+VALUE". "KEY" and "VALUE" have the same meaning.
  ---------------------- -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


WeakMap Objects

WeakMap objects are collections of key/value pairs where the keys are
objects and values may be arbitrary ECMAScript language values. A
WeakMap may be queried to see if it contains an key/value pair with a
specific key, but no mechanisms is provided for enumerating the objects
it holds as keys. If an object that is being used as the key of a
WeakMap key/value pair is only reachable by following a chain of
references that start within that WeakMap, then that key/value pair is
inaccessible and is automatically removed from the WeakMap. WeakMap
implementations must detect and remove such key/value pairs and any
associated resources.

An implementation may impose an arbitrarily determined latency between
the time a key/value pair of a WeakMap becomes inaccessible and the time
when the key/value pair is removed from the WeakMap. If this latency was
observable to ECMAScript program, it would be a source of indeterminacy
that could impact program execution.  For that reason, an ECMAScript
implementation must not provide any means to observe a key of a WeakMap
that does not require the observer to present the observed key. 

WeakMap objects must be implemented using either hash tables or other
mechanisms that, on average, provide access times that are sublinear on
the number of key/value pairs in the collection. The data structure used
in this WeakMap objects specification are only intended to describe the
required observable semantics of WeakMap objects. It is not intended to
be a viable implementation model.

NOTE WeakMap and WeakSets are intended to provide mechanisms for
dynamically associating state with an object in a manner that does not
“leak” memory resources if, in the absence of the WeakMap or WeakSet,
the object otherwise became inaccessible and subject to resource
reclamation by the implementation’s garbage collection mechanisms.
Achieving this characteristic requires coordination between the WeakMap
or WeakSet implementation and the garbage collector. The following
references describe mechanism that may be useful to implementations of
WeakMap and WeakSets:

  Barry Hayes. 1997. Ephemerons: a new finalization mechanism. In
  _Proceedings of the 12th ACM SIGPLAN conference on Object-oriented
  programming, systems, languages, and applications (OOPSLA '97)_, A.
  Michael Berman (Ed.). ACM, New York, NY, USA, 176-183.
  _http://doi.acm.org/10.1145/263698.263733_.

  Alexandra Barros, Roberto Ierusalimschy, Eliminating Cycles in Weak
  Tables. Journal of Universal Computer Science - J.UCS , vol. 14, no.
  21, pp. 3481-3497, 2008.
  _http://www.jucs.org/jucs_14_21/eliminating_cycles_in_weak_

The WeakMap Constructor 

The WeakMap constructor is the %WeakMap% intrinsic object and the
initial value of the WEAKMAP property of the global object. When WEAKMAP
is called as a function rather than as a constructor, it initializes its
THIS value with the internal state necessary to support the
WEAKMAP.PROTOTYPE built-in methods.

The WEAKMAP constructor is designed to be subclassable. It may be used
as the value in an EXTENDS clause of a class definition. Subclass
constructors that intend to inherit the specified WEAKMAP behaviour must
include a SUPER call to WEAKMAP.

WeakMap ( [ iterable ] )

When the WEAKMAP function is called with optional argument _iterable_
the following steps are taken:

1.  Let _map_ be the THIS value.

2.  If Type(_map_) is not Object then, throw a TYPEERROR exception.

3.  If _map_ does not have a [[WeakMapData]] internal slot, then throw a
    TYPEERROR exception.

4.  If _map’s_ [[WeakMapData]] internal slot is not UNDEFINED, then
    throw a TYPEERROR exception.

5.  If _iterable_ is not present, let _iterable_ be UNDEFINED.

6.  If _iterable_ is either UNDEFINED or NULL, then let _iter_ be
    UNDEFINED.

7.  Else,

    a.  b.  c.  Let _adder_ be the result of Get(_map_, "SET").

    d.  ReturnIfAbrupt(_adder_).

    e.  If IsCallable(_adder_) is FALSE, throw a TYPEERROR Exception.

    f.  Let _iter_ be the result of GetIterator(_iterable_).

    g.  ReturnIfAbrupt(_iter_).

8.  If the value of _map’s_ [[WeakMapData]] internal slot is not
    UNDEFINED, then throw a TYPEERROR exception.

9.  Assert: _map_ has not been reentrantly initialized.

10. Set _map’s_ [[WeakMapData]] internal slot to a new empty List.

11. If _iter_ is UNDEFINED, then return _map_.

12. Repeat

    a.  Let _next_ be the result of IteratorStep(_iter_).

    b.  ReturnIfAbrupt(_next_).

    c.  If _next_ is FALSE, then return _map_.

    d.  Let _nextValue_ be IteratorValue(_next_).

    e.  ReturnIfAbrupt(_nextValue_).

    f.  If Type(_nextValue_) is not Object, then throw a TYPEERROR
        exception

    g.  Let _k_ be the result of Get(_nextValue_, "0").

    h.  ReturnIfAbrupt(_k_).

    i.  Let _v_ be the result of Get(_nextValue_, "1").

    j.  ReturnIfAbrupt(_v_).

    k.  Let _status_ be the result of calling the [[Call]] internal
        method of _adder_ with _map_ as _thisArgument_ and a List whose
        elements are _k_ and _v_ as _argumentsList_.

    l.  ReturnIfAbrupt(_status_).

NOTE If the parameter _iterable_ is present, it is expected to be an
object that implements an @@iterator method that returns an iterator
object that produces a two element array-like object whose first element
is a value that will be used as a WeakMap key and whose second element
is the value to associate with that key.

new WeakMap ( ...argumentsList )

When WEAKMAP is called as part of a NEW expression it is a constructor:
it initializes a newly created object.

WEAKMAP called as part of a new expression with argument list
_argumentsList_ performs the following steps:

1.  Let _F_ be the WeakMap function object on which the NEW operator was
    applied.

2.  Let _argumentsList_ be the _argumentsList_ argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of Construct(_F_, _argumentsList_).

If WeakMap is implemented as an ECMAScript function object, its
[[Construct]] internal method will perform the above steps.

Properties of the WeakMap Constructor

The value of the [[Prototype]] internal slot of the WeakMap constructor
is the Function prototype object (19.2.3).

Besides the LENGTH property (whose value is 1), the WeakMap constructor
has the following properties:

WeakMap.prototype

The initial value of WEAKMAP.PROTOTYPE is the WeakMap prototype object
(23.3.3).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

WeakMap[ @@create ] ( )

The @@create method of a WeakMap object _F_ performs the following
steps:

1.  Let _F_ be the THIS value.

2.  Let _obj_ be the result of calling
    OrdinaryCreateFromConstructor(_F_, "%WEAKMAPPROTOTYPE%", (
    [[WeakMapData]] )).

3.  Return _obj_.

The value of the NAME property of this function is "[SYMBOL.CREATE]".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Properties of the WeakMap Prototype Object

The value of the [[Prototype]] internal slot of the WeakMap prototype
object is the standard built-in Object prototype object (19.1.3). The
WeakMap prototype object is an ordinary object. It does not have a
[[WeakMapData]] internal slot.

WeakMap.prototype.clear ( )

The following steps are taken:

1.  Let _M_ be the THIS value.

2.  If Type(_M)_ is not Object, then throw a TYPEERROR exception.

3.  If _M_ does not have a [[WeakMapData]] internal slot throw a
    TYPEERROR exception.

4.  If _M’s_ [[WeakMapData]] internal slot is UNDEFINED, then throw a
    TYPEERROR exception.

5.  Set the value of _M_’s [[WeakMapData]] internal slot to a new empty
    List.

6.  Return UNDEFINED.

WeakMap.prototype.constructor

The initial value of WEAKMAP.PROTOTYPE.CONSTRUCTOR is the built-in
WEAKMAP constructor.

WeakMap.prototype.delete ( key )

The following steps are taken:

1.  Let _M_ be the THIS value.

2.  If Type(_M)_ is not Object, then throw a TYPEERROR exception.

3.  If _M_ does not have a [[WeakMapData]] internal slot throw a
    TYPEERROR exception.

4.  Let _entries_ be the List that is the value of _M_’s [[WeakMapData]]
    internal slot.

5.  If _entries_ is UNDEFINED, then throw a TYPEERROR exception.

6.  If Type(_key_) is not Object, then return FALSE.

7.  Repeat for each Record {[[key]], [[value]]} _p_ that is an element
    of _entries,_

    a.  If _p_.[[key]] is not empty and SameValue(_p_.[[key]], _key_) is
        TRUE, then

        i.  Set _p_.[[key]] to empty_._

        ii. Set _p_.[[value]] to empty_._

        iii. Return TRUE.

8.  Return FALSE.

NOTE The value EMPTY is used as a specification device to indicate that
an entry has been deleted. Actual implementations may take other actions
such as physically removing the entry from internal data structures.

WeakMap.prototype.get ( key )

The following steps are taken:

1.  Let _M_ be the THIS value.

2.  If Type(_M)_ is not Object, then throw a TYPEERROR exception.

3.  If _M_ does not have a [[WeakMapData]] internal slot throw a
    TYPEERROR exception.

4.  Let _entries_ be the List that is the value of _M_’s [[WeakMapData]]
    internal slot.

5.  If _entries_ is UNDEFINED, then throw a TYPEERROR exception.

6.  If Type(_key_) is not Object, then return UNDEFINED.

7.  Repeat for each Record {[[key]], [[value]]} _p_ that is an element
    of _entries,_

    a.  If _p_.[[key]] is not empty and SameValue(_p_.[[key]], _key_) is
        TRUE, then return _p_.[[value]].

8.  Return UNDEFINED_.

WeakMap.prototype.has ( key )

The following steps are taken:

1.  Let _M_ be the THIS value.

2.  If Type(_M)_ is not Object, then throw a TYPEERROR exception.

3.  If _M_ does not have a [[WeakMapData]] internal slot throw a
    TYPEERROR exception.

4.  Let _entries_ be the List that is the value of _M_’s [[WeakMapData]]
    internal slot.

5.  If _entries_ is UNDEFINED, then throw a TYPEERROR exception.

6.  If Type(_key_) is not Object, then return FALSE.

7.  Repeat for each Record {[[key]], [[value]]} _p_ that is an element
    of _entries,_

    a.  If _p_.[[key]] is not empty and SameValue(_p_.[[key]], _key_) is
        TRUE, then return TRUE_._

8.  Return FALSE.

WeakMap.prototype.set ( key , value )

The following steps are taken:

1.  Let _M_ be the THIS value.

2.  If Type(_M)_ is not Object, then throw a TYPEERROR exception.

3.  If _M_ does not have a [[WeakMapData]] internal slot throw a
    TYPEERROR exception.

4.  Let _entries_ be the List that is the value of _M_’s [[WeakMapData]]
    internal slot.

5.  If _entries_ is UNDEFINED, then throw a TYPEERROR exception.

6.  If Type(_key_) is not Object, then throw a TYPEERROR exception.

7.  Repeat for each Record {[[key]], [[value]]} _p_ that is an element
    of _entries,_

    a.  If _p_.[[key]] is not empty and SameValue(_p_.[[key]], _key_) is
        TRUE, then

        i.  Set _p_.[[value]] to _value._

        ii. Return _M_.

8.  Let _p_ be the Record {[[key]]: _key_, [[value]]: _value_}.

9.  Append _p_ as the last element of _entries_.

10. Return _M_.

WeakMap.prototype [ @@toStringTag ]

The initial value of the @@toStringTag property is the string value
"WEAKMAP".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Properties of WeakMap Instances

WeakMap instances are ordinary objects that inherit properties from the
WeakMap prototype. WeakMap instances also have a [[WeakMapData]]
internal slot.


WeakSet Objects

WeakSet objects are collections of objects. A distinct object may only
occur once as an element of a WeakSet’s collection. A WeakSet may be
queried to see if it contains a specific object, but no mechanisms is
provided for enumerating the objects it holds. If an object that is
contain by a WeakSet is only reachable by following a chain of
references that start within that WeakSet, then that object is
inaccessible and is automatically removed from the WeakSet. WeakSet
implementations must detect and remove such objects and any associated
resources.

An implementation may impose an arbitrarily determined latency between
the time an object contained in a WeakSet becomes inaccessible and the
time when the object is removed from the WeakSet. If this latency was
observable to ECMAScript program, it would be a source of indeterminacy
that could impact program execution.  For that reason, an ECMAScript
implementation must not provide any means to determine if a WeakSet
contains a particular object that does not require the observer to
present the observed object.

WeakSet objects must be implemented using either hash tables or other
mechanisms that, on average, provide access times that are sublinear on
the number of elements in the collection. The data structure used in
this WeakSet objects specification is only intended to describe the
required observable semantics of WeakSet objects. It is not intended to
be a viable implementation model.

NOTE See the NOTE in 23.3.

The WeakSet Constructor 

The WeakSet constructor is the %WeakSet% intrinsic object and the
initial value of the WEAKSET property of the global object. When WEAKSET
is called as a function rather than as a constructor, it initializes its
THIS value with the internal state necessary to support the
WEAKSET.PROTOTYPE built-in methods.

The WEAKSET constructor is designed to be subclassable. It may be used
as the value in an EXTENDS clause of a class definition. Subclass
constructors that intend to inherit the specified WEAKSET behaviour must
include a SUPER call to WEAKSET.

WeakSet ( [ iterable ] )

When the WEAKSET function is called with optional argument _iterable_
the following steps are taken:

1.  Let _set_ be the THIS value.

2.  If Type(_set_) is not Object then, throw a TYPEERROR exception.

3.  If _set_ does not have a [[WeakSetData]] internal slot, then throw a
    TYPEERROR exception.

4.  If _set’s_ [[WeakSetData]] internal slot is not UNDEFINED, then
    throw a TYPEERROR exception.

5.  If _iterable_ is not present, let _iterable_ be UNDEFINED.

6.  If _iterable_ is either UNDEFINED or NULL, then let _iter_ be
    UNDEFINED.

7.  Else,

    a.  Let _iter_ be the result of GetIterator(_iterable_).

    b.  ReturnIfAbrupt(_iter_).

    c.  Let _adder_ be the result of Get(_set_, "ADD").

    d.  ReturnIfAbrupt(_adder_).

    e.  If IsCallable(_adder_) is FALSE, throw a TYPEERROR Exception.

    f.  Let _iter_ be the result of GetIterator(ToObject(_iterable_)).

    g.  ReturnIfAbrupt(_iter_).

8.  If the value of _set’s_ [[WeakSetData]] internal slot is not
    UNDEFINED, then throw a TYPEERROR exception.

9.  Assert: _set_ has not been reentrantly initialized.

10. Set _set’s_ [[WeakSetData]] internal slot to a new empty List.

11. If _iter_ is UNDEFINED, then return _set_.

12. Repeat

    a.  Let _next_ be the result of IteratorStep(_iter_).

    b.  ReturnIfAbrupt(_next_).

    c.  If _next_ is FALSE, then return _set_.

    d.  Let _nextValue_ be IteratorValue(_next_).

    e.  ReturnIfAbrupt(_nextValue_).

    f.  Let _status_ be the result of calling the [[Call]] internal
        method of _adder_ with _set_ as _thisArgument_ and a List whose
        sole element is _nextValue_ as _argumentsList_.

    g.  ReturnIfAbrupt(_status_).

new WeakSet ( ...argumentsList)

When WEAKSET is called as part of a NEW expression it is a constructor:
it initializes a newly created object.

WEAKSET called as part of a new expression with argument list
_argumentsList_ performs the following steps:

1.  Let _F_ be the WEAKSET function object on which the NEW operator was
    applied.

2.  Let _argumentsList_ be the _argumentsList_ argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of Construct(_F_, _argumentsList_).

If WeakSet is implemented as an ECMAScript function object, its
[[Construct]] internal method will perform the above steps.

Properties of the WeakSet Constructor

The value of the [[Prototype]] internal slot of the WeakSet constructor
is the Function prototype object (19.2.3).

Besides the LENGTH property (whose value is 1), the WeakSet constructor
has the following properties:

WeakSet.prototype

The initial value of WEAKSET.PROTOTYPE is the intrinsic
%WeakSetPrototype% object (23.4.3).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

WeakSet [ @@create ] ( )

The @@create method of a WeakSet function object _F_ performs the
following steps:

1.  Let _F_ be the THIS value.

2.  Let _obj_ be the result of calling
    OrdinaryCreateFromConstructor(_F_, "%WEAKSETPROTOTYPE%", (
    [[WeakSetData]] )).

3.  Return _obj_.

The value of the NAME property of this function is "[SYMBOL.CREATE]".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Properties of the WeakSet Prototype Object

The value of the [[Prototype]] internal slot of the WeakSet prototype
object is the standard built-in Object prototype object (19.1.3). The
WeakSet prototype object is an ordinary object. It does not have a
[[WeakSetData]] internal slot.

WeakSet.prototype.add ( value )

The following steps are taken:

1.  Let _S_ be the THIS value.

2.  If Type(_S)_ is not Object, then throw a TYPEERROR exception.

3.  If _S_ does not have a [[WeakSetData]] internal slot throw a
    TYPEERROR exception.

4.  If _S’s_ [[WeakSetData]] internal slot is UNDEFINED, then throw a
    TYPEERROR exception.

5.  If Type(_value)_ is not Object, then throw a TYPEERROR exception.

6.  Let _entries_ be the List that is the value of _S_’s [[WeakSetData]]
    internal slot.

7.  Repeat for each _e_ that is an element of _entries,

    a.  If _e_ is not empty and SameValue(_e_, _value_) is TRUE, then

        i.  Return _S_.

8.  Append _value_ as the last element of _entries_.

9.  Return _S_.

WeakSet.prototype.clear ( )

The following steps are taken:

1.  Let _S_ be THIS value.

2.  If Type(_S)_ is not Object, then throw a TYPEERROR exception.

3.  If _S_ does not have a [[WeakSetData]] internal slot throw a
    TYPEERROR exception.

4.  If _S’s_ [[WeakSetData]] internal slot is UNDEFINED, then throw a
    TYPEERROR exception.

5.  Set the value of _S_’s [[WeakSetData]] internal slot to a new empty
    List.

6.  Return UNDEFINED.

WeakSet.prototype.constructor

The initial value of WEAKSET.PROTOTYPE.CONSTRUCTOR is the %WeakSet%
intrinsic object.

WeakSet.prototype.delete ( value )

The following steps are taken:

1.  Let _S_ be the THIS value.

2.  If Type(_S)_ is not Object, then throw a TYPEERROR exception.

3.  If _S_ does not have a [[WeakSetData]] internal slot throw a
    TYPEERROR exception.

4.  If _S’s_ [[WeakSetData]] internal slot is UNDEFINED, then throw a
    TYPEERROR exception.

5.  If Type(_value)_ is not Object, then return FALSE.

6.  Let _entries_ be the List that is the value of _S_’s [[WeakSetData]]
    internal slot.

7.  Repeat for each _e_ that is an element of _entries_,

    a.  If _e_ is not empty and SameValue(_e_, _value_) is TRUE, then

        i.  Replace the element of _entries_ whose value is _e_ with an
            element whose value is empty_._

        ii. Return TRUE.

8.  Return FALSE.

NOTE The value EMPTY is used as a specification device to indicate that
an entry has been deleted. Actual implementations may take other actions
such as physically removing the entry from internal data structures.

WeakSet.prototype.has ( value )

The following steps are taken:

1.  Let _S_ be the THIS value.

2.  If Type(_S)_ is not Object, then throw a TYPEERROR exception.

3.  If _S_ does not have a [[WeakSetData]] internal slot throw a
    TYPEERROR exception.

4.  If _S’s_ [[WeakSetData]] internal slot is UNDEFINED, then throw a
    TYPEERROR exception.

5.  Let _entries_ be the List that is the value of _S_’s [[WeakSetData]]
    internal slot.

6.  If Type(_value_) is not Object, then return FALSE.

7.  Repeat for each _e_ that is an element of _entries,

    a.  If _e_ is not empty and SameValue(_e_, _value_), then return
        TRUE_._

8.  Return FALSE.

WeakSet.prototype [ @@toStringTag ]

The initial value of the @@toStringTag property is the string value
"WEAKSET".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Properties of WeakSet Instances

WeakSet instances are ordinary objects that inherit properties from the
WeakSet prototype. After initialization by the WeakSet constructor,
WeakSet instances also have a [[WeakSetData]] internal slot.



STRUCTURED DATA


ArrayBuffer Objects

Abstract Operations For ArrayBuffer Objects

AllocateArrayBuffer( constructor )

The abstract operation AllocateArrayBuffer with argument _constructor_
is used to create an uninitialized ArrayBuffer object. It performs the
following steps:

1.  Let _obj_ be OrdinaryCreateFromConstructor(_constructor_,
    "%ARRAYBUFFERPROTOTYPE%", ( [[ArrayBufferData]],
    [[ArrayBufferByteLength]]) ).

2.  ReturnIfAbrupt(_obj_).

3.  Set the [[ArrayBufferByteLength]] internal slot of _obj_ to 0.

4.  Return _obj_.

IsNeuteredBuffer( arrayBuffer )

The abstract operation IsNeuteredBuffer with argument _arrayBuffer_
performs the following steps:

1.  Assert: Type(_arrayBuffer_) is Object and it has [[ArrayBufferData]]
    internal slot.

2.  If _arrayBuffer’s_ [[ArrayBufferData]] internal slot is NULL, then
    return TRUE.

3.  Return FALSE.

NeuterArrayBuffer( arrayBuffer )

The abstract operation NeuterArrayBuffer with argument _arrayBuffer_
performs the following steps:

1.  Assert: Type(_arrayBuffer_) is Object and it has [[ArrayBufferData]]
    and [[ArrayBufferByteLength]] internal slots.

2.  Set _arrayBuffer’s_ [[ArrayBufferData]] internal slot to NULL.

3.  Set _arrayBuffer_’s [[ArrayBufferByteLength]] internal slot to 0.

4.  Return NormalCompletion(NULL).

NOTE Neutering an ArrayBuffer instance disassociates the Data Block used
as its backing store from the instance and sets the byte length of the
buffer to 0. No operations defined by this specification uses the
NeuterArrayBuffer abstract operation. However, an ECMAScript
implementation or host environment may define such operations.

SetArrayBufferData( arrayBuffer, bytes )

The abstract operation SetArrayBufferData with arguments _arrayBuffer_
and _bytes_ is used to initialize the storage block encapsulated by an
ArrayBuffer object. It performs the following steps:

1.  ReturnIfAbrupt(_arrayBuffer_).

2.  Assert: Type(_arrayBuffer_) is Object and it has an
    [[ArrayBufferData]] internal slot.

3.  Assert: _bytes_ is a positive integer.

4.  Let _block_ be CreateByteDataBlock(_bytes_).

5.  ReturnIfAbrupt(_block_).

6.  Set _arrayBuffer’s_ [[ArrayBufferData]] internal slot to _block_.

7.  Set _arrayBuffer_’s [[ArrayBufferByteLength]] internal slot to
    _bytes_.

8.  Return _arrayBuffer_.

CloneArrayBuffer( srcBuffer, srcByteOffset )

The abstract operation CloneArrayBuffer takes two parameters, an
ArrayBuffer _srcBuffer_ and an integer _srcByteOffset_. It creates a new
ArrayBuffer whose data is a copy of _srcBuffer’s_ data starting at
_srcByteOffset_. This operation performs the following steps:

1.  Assert: Type(_srcBuffer_) is Object and it has an
    [[ArrayBufferData]] internal slot.

2.  Let _srcBlock_ be the value of _srcBuffer’s_ [[ArrayBufferData]]
    internal slot.

3.  If _srcBlock_ is UNDEFINED, then throw a TYPEERROR exception.

4.  If IsNeuteredBuffer(_srcBuffer_) is TRUE, then throw a TYPEERROR
    exception.

5.  Let _srcLength_ be the value of _srcBuffer_’s
    [[ArrayBufferByteLength]] internal slot.

6.  Let _bufferConstructor_ be Get(_srcBuffer_, "CONSTRUCTOR").

7.  ReturnIfAbrupt(_bufferConstructor_).

8.  Assert: _srcByteOffset_ ≤ _srcLength_.

9.  Let _cloneLength_ be _srcLength_ – _srcByteOffset.

10. If _bufferConstructor_ is UNDEFINED, then let _bufferConstructor_ be
    %ArrayBuffer%.

11. Let _targetBuffer_ be AllocateArrayBuffer(_bufferConstructor_).

12. NOTE: Side-effects of the above steps may have neutered _srcBuffer_.

13. If IsNeuteredBuffer(_srcBuffer_) is TRUE, then throw a TYPEERROR
    exception.

14. Let _srcBlock_ be the value of _srcBuffer’s_ [[ArrayBufferData]]
    internal slot.

15. Let _status_ be SetArrayBufferData(_targetBuffer_, _cloneLength_).

16. ReturnIfAbrupt(_status_).

17. Let _targetBlock_ be the value of _targetBuffer’s
    [[ArrayBufferData]] internal slot.

18. Perform CopyDataBlockBytes(_targetBlock_, 0, _srcBlock_,
    _srcByteOffset_, _cloneLength_).

19. Return _targetBuffer_.

GetValueFromBuffer ( arrayBuffer, byteIndex, type, isLittleEndian )

The abstract operation GetValueFromBuffer takes four parameters, an
ArrayBuffer _arrayBuffer_, an integer _byteIndex_, a String _type_, and
optionally a Boolean _isLittleEndian_. This operation performs the
following steps:

1.  Assert: _arrayBuffer_ has been initialized.

2.  Assert: IsNeuteredBuffer(_arrayBuffer_) is FALSE.

3.  Assert: There are sufficient bytes in _arrayBuffer_ starting at
    _byteIndex_ to represent a value of _type_.

4.  Assert: _byteIndex_ is a positive integer.

5.  Let _block_ be _arrayBuffer’s_ [[ArrayBufferData]] internal slot.

6.  7.  Let _elementSize_ be the Number value of the Element Size value
    specified in Table 45 for Element Type _type_.

8.  Let _rawValue_ be a List of _elementSize containing, in order,_ the
    _elementSize_ bytes starting at _byteIndex_ of _block_.

9.  If _isLittleEndian_ is not present, set _isLittleEndian_ to either
    TRUE or FALSE. The choice is implementation dependent and should be
    the alternative that is most efficient for the implementation. An
    implementation must use the same value each time this step is
    executed and the same value must be used for the corresponding step
    in the SetValueInBuffer abstract operation.

10. If _isLittleEndian_ is FALSE, reverse the order of the elements of
    _rawValue_.

11. If _type_ is “Float32” , then

    a.  Let _value_ be the byte elements of _rawValue_ concatenated and
        interpreted as a little-endian bit string encoding of an IEEE
        754-2008 binary32 value.

    b.  If _value_ is an IEEE 754-2008 binary32 NaN value, return the
        NAN Number value.

    c.  Return the Number value that corresponds to _value_.

12. If _type_ is “Float64” , then

    a.  Let _value_ be the byte elements of _rawValue_ concatenated and
        interpreted as a little-endian bit string encoding of an IEEE
        754-2008 binary64 value.

    b.  If _value_ is an IEEE 754-2008 binary64 NaN value, return the
        NAN Number value.

    c.  Return the Number value that corresponds to _value_.

13. If the first code unit of _type_ is "U", then

    a.  Let _intValue_ be the byte elements of _rawValue_ concatenated
        and interpreted as a bit string encoding of an unsigned
        little-endian binary number.

14. Else

    a.  Let _intValue_ be the byte elements of _rawValue_ concatenated
        and interpreted as a bit string encoding of a binary
        little-endian 2’s complement number of bit length _elementSize_
        × 8.

15. Return the Number value that corresponds to _intValue_.

SetValueInBuffer ( arrayBuffer, byteIndex, type, value, isLittleEndian )

The abstract operation SetValueInBuffer takes five parameters, an
ArrayBuffer _arrayBuffer_, an integer _byteIndex_, a String _type_, a
Number _value_, and optionally a Boolean _isLittleEndian_. This
operation performs the following steps:

1.  Assert: _arrayBuffer_ has been initialized.

2.  Assert: IsNeuteredBuffer(_arrayBuffer_) is FALSE.

3.  Assert: There are sufficient bytes in _arrayBuffer_ starting at
    _byteIndex_ to represent a value of _type_.

4.  Assert: _byteIndex_ is a positive integer.

5.  Assert: Type(_value_) is Number.

6.  Let _block_ be _arrayBuffer’s_ [[ArrayBufferData]] internal slot.

7.  If _block_ is UNDEFINED, then throw a TYPEERROR exception.

8.  Let _elementSize_ be the Number value of the Element Size specified
    in Table 45 for Element Type _type_.

9.  If _isLittleEndian_ is not present, set _isLittleEndian_ to either
    TRUE or FALSE. The choice is implementation dependent and should be
    the alternative that is most efficient for the implementation. An
    implementation must use the same value each time this step is
    executed and the same value must be used for the corresponding step
    in the GetValueFromBuffer abstract operation.

10. If _type_ is “Float32” , then

    a.  Set _rawValue_ to a List containing the 4 bytes that are the
        result of converting _value_ to IEEE-868-2008 binary32 format
        using “Round to nearest, ties to even” rounding mode. If
        _isLittleEndian_ is FALSE, the bytes are arranged in big endian
        order. Otherwise, the bytes are arranged in little endian order.
        If _value_ is NAN, _rawValue_ may be set to any implementation
        choosen non-signaling NaN encoding.

11. Else, if _type_ is “Float64” , then

    a.  Set _rawValue_ to a List containing the 8 bytes that are the
        IEEE-868-2008 binary64 format encoding of _value_. If
        _isLittleEndian_ is FALSE, the bytes are arranged in big endian
        order. Otherwise, the bytes are arranged in little endian order.
        If _value_ is NAN, _rawValue_ may be set to any implementation
        choosen non-signaling NaN encoding.

12. Else,

    a.  Let _n_ be the the Number value of the Element Size specified in
        Table 45 for Element Type _type_.

    b.  Let _convOp_ be the abstract operation named in the Conversion
        Operation column in Table 45 for Element Type _type_.

    c.  Let _intValue_ be the result of calling _convOp_ with _value_ as
        its argument .

    d.  If _intValue_ ≥ 0, then

        i.  Let _rawBytes_ be a List containing the _n_-byte binary
            encoding of _intValue_. If _isLittleEndian_ is FALSE, the
            bytes are ordered in big endian order. Otherwise, the bytes
            are ordered in little endian order.

    e.  Else,

        i.  Let _rawBytes_ be a List containing the _n_-byte binary 2’s
            complement encoding of _intValue_. If _isLittleEndian_ is
            FALSE, the bytes are ordered in big endian order. Otherwise,
            the bytes are ordered in little endian order.

13. Store the individual bytes of _rawBytes_ in order starting at
    position _byteIndex_ of _block_.

14. Return NormalCompletion (UNDEFINED).

The ArrayBuffer Constructor

The ArrayBuffer constructor is the %ArrayBuffer% intrinsic object and
the initial value of the ARRAYBUFFER property of the global object. When
ARRAYBUFFER is called as a function rather than as a constructor, its
THIS value must be an Object with an [[ArrayBufferData]] internal slot
whose value is UNDEFINED. The ArrayBuffer constructor initializes the
THIS value using the argument values.

The ARRAYBUFFER constructor is designed to be subclassable. It may be
used as the value of an EXTENDS clause of a class declaration. Subclass
constructors that intended to inherit the specified ARRAYBUFFER
behaviour must include a SUPER call to the ARRAYBUFFER constructor to
initialize subclass instances.

ArrayBuffer( length )

ArrayBuffer called as function with argument _length_ performs the
following steps:

1.  Let _O_ be the THIS value.

2.  If Type(_O_) is not Object or if _O_ does not have an
    [[ArrayBufferData]] internal slot or if the value of _O’s_
    [[ArrayBufferData]] internal slot is not UNDEFINED, then

    a.  Throw a TYPEERROR exception.

3.  Let _numberLength_ be ToNumber(_length_).

4.  Let _byteLength_ be ToLength(_numberLength_).

5.  ReturnIfAbrupt(_byteLength_).

6.  If SameValueZero(_numberLength_, _byteLength_) is FALSE, then throw
    a RANGEERROR exception.

7.  If the value of _O’s_ [[ArrayBufferData]] internal slot is not
    UNDEFINED, then

    a.  Throw a TYPEERROR exception.

8.  Return the result of SetArrayBufferData(_O_, _byteLength_).

new ArrayBuffer( ...argumentsList )

ArrayBuffer called as part of a new expression performs the following
steps:

1.  Let _F_ be the ArrayBuffer function object on which the NEW operator
    was applied.

2.  Let _argumentsList_ be the _argumentsList_ argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of Construct(_F_, _argumentsList_).

If ArrayBuffer is implemented as an ECMAScript function object, its
[[Construct]] internal method will perform the above steps.

Properties of the ArrayBuffer Constructor

The value of the [[Prototype]] internal slot of the ArrayBuffer
constructor is the Function prototype object (19.2.3).

Besides its LENGTH property (whose value is 1), the ArrayBuffer
constructor has the following properties:

ArrayBuffer.isView ( arg )

The isView function takes one argument _arg_, and performs the following
steps are taken:

1.  If Type(_arg_) is not Object, return FALSE.

2.  If _arg_ has a [[ViewedArrayBuffer]] internal slot, then return
    TRUE.

3.  Return FALSE.

ArrayBuffer.prototype

The initial value of ArrayBuffer.prototype is the ArrayBuffer prototype
object (24.1.4).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

 ArrayBuffer[ @@create ] ( )

The @@create method of an ArrayBuffer function object _F_ performs the
following steps:

1.  Let _F_ be the THIS value.

2.  Return the result of calling AllocateArrayBuffer(_F_).

The value of the NAME property of this function is "[SYMBOL.CREATE]".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Properties of the ArrayBuffer Prototype Object

The value of the [[Prototype]] internal slot of the ArrayBuffer
prototype object is the standard built-in Object prototype object
(19.1.3). The ArrayBuffer prototype object is an ordinary object. It
does not have an [[ArrayBufferData]] or [[ArrayBufferByteLength]]
internal slot.

 get ArrayBuffer.prototype.byteLength 

ARRAYBUFFER.PROTOTYPE.BYTELENGTH is an accessor property whose set
accessor function is UNDEFINED. Its get accessor function performs the
following steps:

1.  Let _O_ be the THIS value.

2.  If Type(_O_) is not Object, throw a TYPEERROR exception.

3.  If _O_ does not have an [[ArrayBufferData]] internal slot throw a
    TYPEERROR exception.

4.  If the value of _O_’s [[ArrayBufferData]] internal slot is
    UNDEFINED, then throw a TYPEERROR exception.

5.  If IsNeuteredBuffer(_O_) is TRUE, then throw a TYPEERROR exception.

6.  Let _length_ be the value of _O_’s [[ArrayBufferByteLength]]
    internal slot.

7.  Return _length_.

ArrayBuffer.prototype.constructor

The initial value of ArrayBuffer.prototype.constructor is the standard
built-in ArrayBuffer constructor.

ArrayBuffer.prototype.slice ( start , end )

The following steps are taken:

1.  Let _O_ be the THIS value.

2.  If Type(_O_) is not Object, throw a TYPEERROR exception.

3.  If _O_ does not have an [[ArrayBufferData]] internal slot throw a
    TYPEERROR exception.

4.  If the value of _O_’s [[ArrayBufferData]] internal slot is
    UNDEFINED, then throw a TYPEERROR exception.

5.  If IsNeuteredBuffer(_O_) is TRUE, then throw a TYPEERROR exception.

6.  Let _len_ be the value of _O_’s [[ArrayBufferByteLength]] internal
    slot.

7.  Let _relativeStart_ be ToInteger(_start_).

8.  ReturnIfAbrupt(_relativeStart_).

9.  If _relativeStart_ is negative, let _first_ be max((_len_ +
    _relativeStart_),0); else let _first_ be min(_relativeStart_,
    _len_).

10. If _end_ is UNDEFINED, let _relativeEnd_ be _len_; else let
    _relativeEnd_ be ToInteger(_end_).

11. ReturnIfAbrupt(_relativeEnd_).

12. If _relativeEnd_ is negative, let _final_ be max((_len_ +
    _relativeEnd_),0); else let _final_ be min(_relativeEnd_, _len_).

13. Let _newLen_ be max(_final_-_first_,0).

14. Let _ctor_ be the result of Get(_O_, "CONSTRUCTOR").

15. ReturnIfAbrupt(_ctor_).

16. If IsConstructor(_ctor_) is FALSE, then throw a TYPEERROR exception.

17. Let _new_ be the result of calling the [[Construct]] internal method
    of _ctor_ with a new List containing the single element _newLen_.

18. ReturnIfAbrupt(_new_).

19. If _new_ does not have an [[ArrayBufferData]] internal slot throw a
    TYPEERROR exception.

20. If the value of _new_’s [[ArrayBufferData]] internal slot is
    UNDEFINED, then throw a TYPEERROR exception.

21. If the value of _new_’s [[ArrayBufferByteLength]] internal slot <
    _newLen_, then throw a TYPEERROR exception.

22. NOTE: Side-effects of the above steps may have neutered _O_.

23. If IsNeuteredBuffer(_O_) is TRUE, then throw a TYPEERROR exception.

24. Let _fromBuf_ be the value of _O_’s [[ArrayBufferData]] internal
    slot.

25. Let _toBuf_ be the value of _new_’s [[ArrayBufferData]] internal
    slot.

26. Perform CopyDataBlockBytes(_toBuf_, 0, _fromBuf_, _first_,
    _newLen_).

27. Return _new_.

ArrayBuffer.prototype [ @@toStringTag ]

The initial value of the @@toStringTag property is the string value
"ARRAYBUFFER".

Properties of the ArrayBuffer Instances

ArrayBuffer instances inherit properties from the ArrayBuffer prototype
object. ArrayBuffer instances each have an [[ArrayBufferData]] internal
slot and an [[ArrayBufferByteLength]] internal slot.

ArrayBuffer instances whose [[ArrayBufferData]] is NULL are considered
to be _neutered_ and all operators to access or modify data contained in
the ArrayBuffer instance will fail.


DataView Objects

Abstract Operations For DataView Objects

GetViewValue ( view, requestIndex, isLittleEndian, type )

The abstract operation GetViewValue with arguments _view_,
_requestIndex_, _isLittleEndian_, and _type_ is used by functions on
DataView instances is to retrieve values from the view’s buffer. It
performs the following steps:

1.  If Type(_view_) is not Object, throw a TYPEERROR exception.

2.  If _view_ does not have a [[DataView]] internal slot, then throw a
    TYPEERROR exception.

3.  4.  5.  Let _numberIndex_ be ToNumber(_requestIndex_)

6.  Let _getIndex_ be ToInteger(_numberIndex_).

7.  ReturnIfAbrupt(_getIndex_).

8.  If _numberIndex_ ≠ _getIndex_ or _getIndex_ < 0, then throw a
    RANGEERROR exception.

9.  Let _isLittleEndian_ be ToBoolean(_isLittleEndian_).

10. ReturnIfAbrupt(_isLittleEndian_).

11. Let _buffer_ be the value of _view’s_ [[ViewedArrayBuffer]] internal
    slot.

12. If _buffer_ is UNDEFINED, then throw a TYPEERROR exception.

13. If IsNeuteredBuffer(_buffer_) is TRUE, then throw a TYPEERROR
    exception.

14. Let _viewOffset_ be the value of _view’s_ [[ByteOffset]] internal
    slot.

15. Let _viewSize_ be the value of _view’s_ [[ByteLength]] internal
    slot.

16. Let _elementSize_ be the Number value of the Element Size value
    specified in Table 45 for Element Type _type_.

17. If _getIndex_ +_elementSize_ > _viewSize_, then throw a RANGEERROR
    exception.

18. Let _bufferIndex_ be _getIndex_ + _viewOffset_.

19. Return the result of GetValueFromBuffer(_buffer_, _bufferIndex_,
    _type_, _isLittleEndian_).

SetViewValue ( view, requestIndex, isLittleEndian, type, value )

The abstract operation SetViewValue with arguments _view_,
_requestIndex_, _isLittleEndian_, _type_, and _value_ is used by
functions on DataView instances to store values into the view’s buffer.
It performs the following steps:

1.  If Type(_view_) is not Object, throw a TYPEERROR exception.

2.  If _view_ does not have a [[DataView]] internal slot, then throw a
    TYPEERROR exception.

3.  4.  5.  Let _numberIndex_ be ToNumber(_requestIndex_)

6.  Let _getIndex_ be ToInteger(_numberIndex_).

7.  ReturnIfAbrupt(_getIndex_).

8.  If _numberIndex_ ≠ _getIndex_ or _getIndex_ < 0, then throw a
    RANGEERROR exception.

9.  Let _isLittleEndian_ be ToBoolean(_isLittleEndian_).

10. ReturnIfAbrupt(_isLittleEndian_).

11. Let _buffer_ be the value of _view’s_ [[ViewedArrayBuffer]] internal
    slot.

12. If _buffer_ is UNDEFINED, then throw a TYPEERROR exception.

13. If IsNeuteredBuffer(_buffer_) is TRUE, then throw a TYPEERROR
    exception.

14. Let _viewOffset_ be the value of _view’s_ [[ByteOffset]] internal
    slot.

15. Let _viewSize_ be the value of _view’s_ [[ByteLength]] internal
    slot.

16. Let _elementSize_ be the Number value of the Element Size value
    specified in Table 45 for Element Type _type_.

17. If _getIndex_ +_elementSize_ > _viewSize_, then throw a RANGEERROR
    exception.

18. Let _bufferIndex_ be _getIndex_ + _viewOffset_.

19. Return the result of SetValueInBuffer(_buffer_, _bufferIndex_,
    _type_, _value_, _isLittleEndian_).

NOTE The algorithms for GetViewValue and SetViewValue are identical
except for their final steps.

The DataView Constructor 

The DataView constructor is the %DataView% intrinsic object and the
initial value of the DATAVIEW property of the global object. When
DATAVIEW is called as a function rather than as a constructor, it
initializes its THIS value with the internal state necessary to support
the DATAVIEW.PROTOTYPE internal methods.

The DATAVIEW constructor is designed to be subclassable. It may be used
as the value of an EXTENDS clause of a class declaration. Subclass
constructors that intended to inherit the specified DATAVIEW behaviour
must include a SUPER call to the DATAVIEW constructor to initialize
subclass instances.

DataView (buffer [ , byteOffset [ , byteLength ] ] )

DATAVIEW called with arguments _buffer_, _byteOffset_, and _length_
performs the following steps:

1.  Let _O_ be the THIS value.

2.  If Type(_O_) is not Object or if _O_ does not have a [[DataView]]
    internal slot, throw a TYPEERROR exception.

3.  Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.

4.  If the value of _O’s_ [[ViewedArrayBuffer]] internal slot is not
    UNDEFINED, then

    a.  Throw a TYPEERROR exception.

5.  If Type(_buffer_) is not Object, then throw a TYPEERROR exception.

6.  If _buffer_ does not have an [[ArrayBufferData]] internal slot, then
    throw a TYPEERROR exception.

7.  If the value of _buffer_’s [[ArrayBufferData]] internal slot is
    UNDEFINED, then throw a TYPEERROR exception.

8.  Let _numberOffset_ be ToNumber(_byteOffset_).

9.  Let _offset_ be ToInteger(_numberOffset_).

10. ReturnIfAbrupt(_offset_).

11. If _numberOffset_ ≠ _offset_ or _offset_ < 0, then throw a
    RANGEERROR exception.

12. Let _bufferByteLength_ be the value of _buffer’s
    [[ArrayBufferByteLength]] internal slot.

13. If _offset_ > _bufferByteLength_, then throw a RANGEERROR exception.

14. If _byteLength_ is UNDEFINED, then

    a.  Let _viewByteLength_ be _bufferByteLength_ – _offset_.

15. Else,

    a.  Let _numberLength_ be ToNumber(_byteLength_).

    b.  Let _viewLength_ be ToInteger (_numberLength)._

    c.  ReturnIfAbrupt(_viewLength_).

    d.  If _numberLength_ ≠ _viewLength_ or _viewLength_ < 0, then throw
        a RANGEERROR exception.

    e.  Let _viewByteLength_ be _viewLength_.

    f.  If _offset_+_viewByteLength_ > _bufferByteLength_, then throw a
        RANGEERROR exception.

16. If the value of _O’s_ [[ViewedArrayBuffer]] internal slot is not
    UNDEFINED, then throw a TYPEERROR exception,

17. Set _O’s_ [[ViewedArrayBuffer]] internal slot to _buffer_.

18. Set _O_’s [[ByteLength]] internal slot to _viewByteLength_.

19. Set _O_’s [[ByteOffset]] internal slot to _offset_.

20. Return _O_.

new DataView ( ...argumentsList )

When DATAVIEW is called as part of a new expression it performs the
following steps:

1.  Let _F_ be the function object on which the NEW operator was
    applied.

2.  Let _argumentsList_ be the _argumentsList_ argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of Construct(_F_, _argumentsList_).

If DATAVIEW is implemented as an ECMAScript function object, its
[[Construct]] internal method will perform the above steps.

Properties of the DataView Constructor

The value of the [[Prototype]] internal slot of the DATAVIEW constructor
is the FUNCTION prototype object (19.2.3).

Besides the LENGTH property (whose value is 3), the DataView constructor
has the following properties:

DataView.prototype

The initial value of DATAVIEW.PROTOTYPE is the DataView prototype object
(24.2.4).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

DataView [ @@create ] ( )

The @@create method of a DataView function object _F_ performs the
following steps:

1.  Let _F_ be the THIS value.

2.  Let _obj_ be the result of calling
    OrdinaryCreateFromConstructor(_F_, "%DATAVIEWPROTOTYPE%", (
    [[DataView]], [[ViewedArrayBuffer]], [[ByteLength]], [[ByteOffset]])
    ).

3.  Set the value of _obj’s_ [[DataView]] internal slot to TRUE.

4.  Return _obj_.

The value of the NAME property of this function is "[SYMBOL.CREATE]".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

NOTE The value of the [[DataView]] internal slot is not used within this
specification. The simple presense of that internal slot is used within
the specification to identify objects created using this @@create
method.

Properties of the DataView Prototype Object

The value of the [[Prototype]] internal slot of the DataView prototype
object is the standard built-in Object prototype object (19.1.3). The
DataView prototype object is an ordinary object. It does not have a
[[DataView]], [[ViewedArrayBuffer]], [[ByteLength]], or [[ByteOffset]]
internal slot.

get DataView.prototype.buffer

DATAVIEW.PROTOTYPE.BUFFER is an accessor property whose set accessor
function is UNDEFINED. Its get accessor function performs the following
steps:

1.  Let _O_ be the THIS value.

2.  If Type(_O_) is not Object, throw a TYPEERROR exception.

3.  If _O_ does not have a [[ViewedArrayBuffer]] internal slot throw a
    TYPEERROR exception.

4.  Let _buffer_ be the value of _O_’s [[ViewedArrayBuffer]] internal
    slot.

5.  If _buffer_ is UNDEFINED, then throw a TYPEERROR exception.

6.  Return _buffer_.

get DataView.prototype.byteLength

DATAVIEW.PROTOTYPE.BYTELENGTH is an accessor property whose set accessor
function is UNDEFINED. Its get accessor function performs the following
steps:

1.  Let _O_ be the THIS value.

2.  If Type(_O_) is not Object, throw a TYPEERROR exception.

3.  If _O_ does not have a [[ViewedArrayBuffer]] internal slot throw a
    TYPEERROR exception.

4.  Let _buffer_ be the value of _O_’s [[ViewedArrayBuffer]] internal
    slot.

5.  If _buffer_ is UNDEFINED, then throw a TYPEERROR exception.

6.  If IsNeuteredBuffer(_buffer_) is TRUE, then throw a TYPEERROR
    exception.

7.  Let _size_ be the value of _O_’s [[ByteLength]] internal slot.

8.  Return _size_.

get DataView.prototype.byteOffset

DATAVIEW.PROTOTYPE.BYTEOFFSET is an accessor property whose set accessor
function is UNDEFINED. Its get accessor function performs the following
steps:

1.  Let _O_ be the THIS value.

2.  If Type(_O_) is not Object, throw a TYPEERROR exception.

3.  If _O_ does not have a [[ViewedArrayBuffer]] internal slot throw a
    TYPEERROR exception.

4.  Let _buffer_ be the value of _O_’s [[ViewedArrayBuffer]] internal
    slot.

5.  If _buffer_ is UNDEFINED, then throw a TYPEERROR exception.

6.  If IsNeuteredBuffer(_buffer_) is TRUE, then throw a TYPEERROR
    exception.

7.  Let _offset_ be the value of _O_’s [[ByteOffset]] internal slot.

8.  Return _offset_.

DataView.prototype.constructor

The initial value of DATAVIEW.PROTOTYPE.CONSTRUCTOR is the standard
built-in DataView constructor.

DataView.prototype.getFloat32 ( byteOffset [ , littleEndian ] )

When the GETFLOAT32 method is called with argument _byteOffset_ and
optional argument _littleEndian_ the following steps are taken:

1.  Let _v_ be the THIS value.

2.  If _littleEndian_ is not present, then let _littleEndian_ be FALSE.

3.  Return the result of GetViewValue(_v_, _byteOffset_, _littleEndian_,
    "FLOAT32").

DataView.prototype.getFloat64 ( byteOffset [ , littleEndian ] )

When the GETFLOAT64 method is called with argument _byteOffset_ and
optional argument _littleEndian_ the following steps are taken:

1.  Let _v_ be the THIS value.

2.  If _littleEndian_ is not present, then let _littleEndian_ be FALSE.

3.  Return the result of GetViewValue(_v_, _byteOffset_, _littleEndian_,
    "FLOAT64").

DataView.prototype.getInt8 ( byteOffset )

When the GETINT8 method is called with argument _byteOffset_ the
following steps are taken:

1.  Let _v_ be the THIS value.

2.  Return the result of GetViewValue(_v_, _byteOffset_, TRUE, "INT8").

DataView.prototype.getInt16 ( byteOffset [ , littleEndian ] )

When the GETINT16 method is called with argument _byteOffset_ and
optional argument _littleEndian_ the following steps are taken:

1.  Let _v_ be the THIS value.

2.  If _littleEndian_ is not present, then let _littleEndian_ be FALSE.

3.  Return the result of GetViewValue(_v_, _byteOffset_, _littleEndian_,
    "INT16").

DataView.prototype.getInt32 ( byteOffset [ , littleEndian ] )

When the GETINT32 method is called with argument _byteOffset_ and
optional argument _littleEndian_ the following steps are taken:

1.  Let _v_ be the THIS value.

2.  If _littleEndian_ is not present, then let _littleEndian_ be
    UNDEFINED.

3.  Return the result of GetViewValue(_v_, _byteOffset_, _littleEndian_,
    "INT32").

DataView.prototype.getUint8 ( byteOffset )

When the GETUINT8 method is called with argument _byteOffset_ the
following steps are taken:

1.  Let _v_ be the THIS value.

2.  Return the result of GetViewValue(_v_, _byteOffset_, TRUE, "UINT8").

DataView.prototype.getUint16 ( byteOffset [ , littleEndian ] )

When the GETUINT16 method is called with argument _byteOffset_ and
optional argument _littleEndian_ the following steps are taken:

1.  Let _v_ be the THIS value.

2.  If _littleEndian_ is not present, then let _littleEndian_ be FALSE.

3.  Return the result of GetViewValue(_v_, _byteOffset_, _littleEndian_,
    "UINT16").

DataView.prototype.getUint32 ( byteOffset [ , littleEndian ] )

When the GETUINT32 method is called with argument _byteOffset_ and
optional argument _littleEndian_ the following steps are taken:

1.  Let _v_ be the THIS value.

2.  If _littleEndian_ is not present, then let _littleEndian_ be FALSE.

3.  Return the result of GetViewValue(_v_, _byteOffset_, _littleEndian_,
    "UINT32").

DataView.prototype.setFloat32 ( byteOffset, value [ , littleEndian ] )

When the SETFLOAT32 method is called with arguments _byteOffset_ and
_value_ and optional argument _littleEndian_ the following steps are
taken:

1.  Let _v_ be the THIS value.

2.  If _littleEndian_ is not present, then let _littleEndian_ be FALSE.

3.  Return the result of SetViewValue(_v_, _byteOffset_, _littleEndian_,
    "FLOAT32", _value_).

DataView.prototype.setFloat64 ( byteOffset, value [ , littleEndian ] )

When the SETFLOAT64 method is called with arguments _byteOffset_ and
_value_ and optional argument _littleEndian_ the following steps are
taken:

1.  Let _v_ be the THIS value.

2.  If _littleEndian_ is not present, then let _littleEndian_ be FALSE.

3.  Return the result of SetViewValue(_v_, _byteOffset_, _littleEndian_,
    "FLOAT64", _value_).

DataView.prototype.setInt8 ( byteOffset, value )

When the SETINT8 method is called with arguments _byteOffset_ and
_value_ the following steps are taken:

1.  Let _v_ be the THIS value.

2.  Return the result of SetViewValue(_v_, _byteOffset_, TRUE, "INT8",
    _value_).

DataView.prototype.setInt16 ( byteOffset, value [ , littleEndian ] )

When the SETINT16 method is called with arguments _byteOffset_ and
_value_ and optional argument _littleEndian_ the following steps are
taken:

1.  Let _v_ be the THIS value.

2.  If _littleEndian_ is not present, then let _littleEndian_ be FALSE.

3.  Return the result of SetViewValue(_v_, _byteOffset_, _littleEndian_,
    "INT16", _value_).

DataView.prototype.setInt32 ( byteOffset, value [ , littleEndian ] )

When the SETINT32 method is called with arguments _byteOffset_ and
_value_ and optional argument _littleEndian_ the following steps are
taken:

1.  Let _v_ be the THIS value.

2.  If _littleEndian_ is not present, then let _littleEndian_ be FALSE.

3.  Return the result of SetViewValue(_v_, _byteOffset_, _littleEndian_,
    "INT32", _value_).

DataView.prototype.setUint8 ( byteOffset, value )

When the SETUINT8 method is called with arguments _byteOffset_ and
_value_ the following steps are taken:

1.  Let _v_ be the THIS value.

2.  Return the result of SetViewValue(_v_, _byteOffset_, TRUE, "UINT8",
    _value_).

DataView.prototype.setUint16 ( byteOffset, value [ , littleEndian ] )

When the SETUINT16 method is called with arguments _byteOffset_ and
_value_ and optional argument _littleEndian_ the following steps are
taken:

1.  Let _v_ be the THIS value.

2.  If _littleEndian_ is not present, then let _littleEndian_ be FALSE.

3.  Return the result of SetViewValue(_v_, _byteOffset_, _littleEndian_,
    "UINT16", _value_).

DataView.prototype.setUint32 ( byteOffset, value [ , littleEndian ] )

When the SETUINT32 method is called with arguments _byteOffset_ and
_value_ and optional argument _littleEndian_ the following steps are
taken:

1.  Let _v_ be the THIS value.

2.  If _littleEndian_ is not present, then let _littleEndian_ be FALSE.

3.  Return the result of SetViewValue(_v_, _byteOffset_, _littleEndian_,
    "UINT32", _value_).

DataView.prototype[ @@toStringTag ]

The initial value of the @@toStringTag property is the string value
"DATAVIEW".

Properties of DataView Instances

DataView instances are ordinary objects that inherit properties from the
DataView prototype object. DataView instances each have a [[DataView]],
[[ViewedArrayBuffer]], [[ByteLength]], and [[ByteOffset]] internal
slots.


The JSON Object

The JSON object is a single ordinary object that contains two functions,
PARSE and STRINGIFY, that are used to parse and construct JSON texts.
The JSON Data Interchange Format is defined in ECMA-404. The JSON
interchange format used in this specification is exactly that described
by ECMA-404.

Conforming implementations of JSON.PARSE and JSON.STRINGIFY must support
the exact interchange format described in this specification without any
deletions or extensions to the format.

The value of the [[Prototype]] internal slot of the JSON object is the
standard built-in Object prototype object (19.1.3). The value of the
[[Extensible]] internal slot of the JSON object is set to TRUE.

The JSON object does not have a [[Construct]] internal method; it is not
possible to use the JSON object as a constructor with the NEW operator.

The JSON object does not have a [[Call]] internal method; it is not
possible to invoke the JSON object as a function.

JSON.parse ( text [ , reviver ] )

The PARSE function parses a JSON text (a JSON-formatted String) and
produces an ECMAScript value. The JSON format is a subset of the syntax
for ECMAScript literals, Array Initializers and Object Initializers.
After parsing, JSON objects are realized as ECMAScript objects. JSON
arrays are realized as ECMAScript Array instances. JSON strings,
numbers, booleans, and null are realized as ECMAScript Strings, Numbers,
Booleans, and NULL.

The optional _reviver_ parameter is a function that takes two
parameters, (_key_ and _value_). It can filter and transform the
results. It is called with each of the _key_/_value_ pairs produced by
the parse, and its return value is used instead of the original value.
If it returns what it received, the structure is not modified. If it
returns UNDEFINED then the property is deleted from the result.

1.  Let _JText_ be ToString(_text_).

2.  ReturnIfAbrupt(_JText_).

3.  Parse _JText_ interpreted as UTF-16 encoded Unicode points as a JSON
    text as specified in
    ECMA-404. Throw a SYNTAXERROR exception if _JText_ is not a valid
    JSON text as defined in that specification.

4.  Let _scriptText_ be the result of concatenating "(", _JText_, and
    ");".

5.  Let _completion_ be the result of parsing and evaluating
    _scriptText_ as if it was the source text of an ECMAScript _Script_.
    but using the alternative definition of _DoubleStringCharacter_
    provided below. The extended PropertyDefinitionEvaluation semantics
    defined in B.3.1 must not be used during the evaluation.

6.  Let _unfiltered_ be _completion_.[[value]].

7.  Assert: _unfiltered_ will be either a primitive value or an object
    that is defined by either an _ArrayLiteral_ or an _ObjectLiteral_.

8.  If IsCallable(_reviver_) is TRUE, then

    a.  Let _root_ be ObjectCreate(%ObjectPrototype%).

    b.  Let _status_ be the result of CreateDataProperty(_root_, the
        empty String, _unfiltered_).

    c.  Assert: _status_ is TRUE.

    d.  Return the result of calling the abstract operation Walk,
        passing _root_ and the empty String. The abstract operation Walk
        is described below.

9.  Else

    a.  Return _unfiltered_.

JSON allows Unicode code points U+2028 and U+2029 to directly appear in
_String_ literals without using an escape sequence. This is enabled by
using the following alternative definition of _DoubleStringCharacter_
when parsing _scriptText_ in step 5:

_DoubleStringCharacter_ ::

SourceCharacter BUT NOT ONE OF " OR \ OR U+0000 THROUGH U+001F

\ EscapeSequence

-   The CV of _DoubleStringCharacter_ :: _SourceCharacter_ BUT NOT ONE
    OF " OR \ OR U+0000 THROUGH U+001F is the UTF-16Encoding (10.1.1) of
    the code point value of _SourceCharacter_.

NOTE The syntax of a valid JSON text is a subset of the ECMAScript
_PrimaryExpression_ syntax. Hence a valid JSON text is also a valid
_PrimaryExpression_. Step 3 above verifies that _JText_ conforms to that
subset. When _scriptText_ is parsed and evaluated as a _Script_ the
result will be either a String, Number, Boolean, or Null primitive value
or an Object defined as if by an _ArrayLiteral_ or _ObjectLiteral_.

Runtime Semantics: Walk Abstract Operation

The abstract operation Walk is a recursive abstract operation that takes
two parameters: a _holder_ object and the String _name_ of a property in
that object. Walk uses the value of _reviver_ that was originally passed
to the above parse function.

1.  Let _val_ be the result of Get(_holder_, _name_).

2.  ReturnIfAbrupt(_val_).

3.  If _val_ is an object, then

    a.  If _val_ is an exotic Array object then

        i.  Set _I_ to 0.

        ii. Let _len_ be the result of Get(_val_, "LENGTH").

        iii. Assert: _len_ is not an abrupt completion and its value is
            a positive integer.

        iv. Repeat while _I_ < _len_,

            1.  Let _newElement_ be the result of calling the abstract
                operation Walk, passing _val_ and ToString(_I_).

            2.  If _newElement_ is UNDEFINED, then

                a.  Let _status_ be the result of calling the [[Delete]]
                    internal method of _val_ with ToString(_I_) as the
                    argument.

            3.  Else

                a.  Let _status_ be the result of calling the
                    [[DefineOwnProperty]] internal method of _val_ with
                    arguments ToString(_I_) and
                    PropertyDescriptor{[[Value]]: _newElement_,
                    [[Writable]]: TRUE, [[Enumerable]]: TRUE,
                    [[Configurable]]: TRUE}.

                b.  NOTE This algorithm intentionally does not throw an
                    exception if status is FALSE.

            4.  ReturnIfAbrupt(_status_).

            5.  Add 1 to _I_.

    b.  Else

        i.  Let _keys_ be EnumerableOwnNames(_val_).

        ii. For each String _P_ in _keys_ do,

            1.  Let _newElement_ be the result of calling the abstract
                operation Walk, passing _val_ and _P_.

            2.  If _newElement_ is UNDEFINED, then

                a.  Let _status_ be the result of calling the [[Delete]]
                    internal method of _val_ with _P_ as the argument.

            3.  Else

                a.  Let _status_ be the result of calling the
                    [[DefineOwnProperty]] internal method of _val_ with
                    arguments _P_ and PropertyDescriptor{[[Value]]:
                    _newElement_, [[Writable]]: TRUE, [[Enumerable]]:
                    TRUE, [[Configurable]]: TRUE}.

                b.  NOTE This algorithm intentionally does not throw an
                    exception if status is FALSE.

            4.  ReturnIfAbrupt(_status_).

4.  Return the result of calling the [[Call]] internal method of
    _reviver_ passing _holder_ as _thisArgument_ and with a List
    containing _name_ and _val_ as _argumentsList_.

It is not permitted for a conforming implementation of JSON.PARSE to
extend the JSON grammars. If an implementation wishes to support a
modified or extended JSON interchange format it must do so by defining a
different parse function.

NOTE In the case where there are duplicate name Strings within an
object, lexically preceding values for the same key shall be
overwritten.

JSON.stringify ( value [ , replacer [ , space ] ] )

The STRINGIFY function returns a String in UTF-16 encoded JSON format
representing an ECMAScript value. It can take three parameters. The
_value_ parameter is an ECMAScript value, which is usually an object or
array, although it can also be a String, Boolean, Number or NULL. The
optional _replacer_ parameter is either a function that alters the way
objects and arrays are stringified, or an array of Strings and Numbers
that acts as a white list for selecting the object properties that will
be stringified. The optional _space_ parameter is a String or Number
that allows the result to have white space injected into it to improve
human readability.

These are the steps in stringifying an object:

1.  Let _stack_ be an empty List.

2.  Let _indent_ be the empty String.

3.  Let _PropertyList_ and _ReplacerFunction_ be UNDEFINED.

4.  If Type(_replacer_) is Object, then

    a.  If IsCallable(_replacer_) is TRUE, then

        i.  Let _ReplacerFunction_ be _replacer_.

    b.  Else if _replacer_ is an exotic Array object, then

        i.  Let _PropertyList_ be an empty List

        ii. For each value _v_ of a property of _replacer_ that has an
            array index property name. The properties are enumerated in
            the ascending array index order of their names.

            1.  Let _item_ be UNDEFINED.

            2.  If Type(_v_) is String then let _item_ be _v._

            3.  Else if Type(_v_) is Number then let _item_ be
                ToString(_v_).

            4.  Else if Type(_v_) is Object then,

                a.  If _v_ has a [[StringData]] or [[NumberData]]
                    internal slot, then let _item_ be ToString(_v_).

            5.  If _item_ is not UNDEFINED and _item_ is not currently
                an element of _PropertyList_ then,

                a.  Append _item_ to the end of _PropertyList_.

5.  If Type(_space_) is Object then,

    a.  If _space_ has a [[NumberData]] internal slot then,

        i.  Let _space_ be ToNumber(_space_).

    b.  Else if _space_ has a [[StringData]] internal slot then,

        i.  Let _space_ be ToString(_space_).

6.  If Type(_space_) is Number

    a.  Let _space_ be min(10, ToInteger(_space_)).

    b.  Set _gap_ to a String containing _space_ occurrences of code
        unit 0x0020 (SPACE). This will be the empty String if _space_ is
        less than 1.

7.  Else if Type(_space)_ is String

    a.  If the number of elements in _space_ is 10 or less, set _gap_ to
        _space_ otherwise set _gap_ to a String consisting of the first
        10 elements of _space_.

8.  Else

    a.  Set _gap_ to the empty String.

9.  Let _wrapper_ be ObjectCreate(%ObjectPrototype%).

10. Let _status_ be the result of CreateDataProperty(_wrapper_, the
    empty String, _value_).

11. Assert: _status_ is TRUE.

12. Return the result of calling the abstract operation Str(the empty
    String, _wrapper_).

NOTE 1 JSON structures are allowed to be nested to any depth, but they
must be acyclic. If _value_ is or contains a cyclic structure, then the
stringify function must throw a TYPEERROR exception. This is an example
of a value that cannot be stringified:

  a = [];

  a[0] = a;

  my_text = JSON.stringify(a); // This must throw a TypeError.

NOTE 2 Symbolic primitive values are rendered as follows:

-   The NULL value is rendered in JSON text as the String NULL.

-   The UNDEFINED value is not rendered.

-   The TRUE value is rendered in JSON text as the String TRUE.

-   The FALSE value is rendered in JSON text as the String FALSE.

NOTE 3 String values are wrapped in double quotes. The code units " and
\ are escaped with \ prefixes. Control characters code units are
replaced with escape sequences \UHHHH, or with the shorter forms, \B
(backspace), \F (form feed), \N (LINE FEED), \R (carriage return), \T
(CHARACTER TABULATION).

NOTE 4 Finite numbers are stringified as if by calling
ToString(_number_). NAN and Infinity regardless of sign are represented
as the String NULL.

NOTE 5 Values that do not have a JSON representation (such as UNDEFINED
and functions) do not produce a String. Instead they produce the
UNDEFINED value. In arrays these values are represented as the String
NULL. In objects an unrepresentable value causes the property to be
excluded from stringification.

NOTE 6 An object is rendered as an opening left brace followed by zero
or more properties, separated with commas, closed with a right brace. A
property is a quoted String representing the key or property name, a
colon, and then the stringified property value. An array is rendered as
an opening left bracket followed by zero or more values, separated with
commas, closed with a right bracket.

Runtime Semantics: Str Abstract Operation

The abstract operation Str(_key_, _holder_) has access to
_ReplacerFunction_ from the invocation of the STRINGIFY method. Its
algorithm is as follows:

1.  Let _value_ be the result of Get(_holder_, _key_).

2.  ReturnIfAbrupt(_value_).

3.  If Type(_value_) is Object, then

    a.  Let _toJSON_ be the result of Get(_value_, "TOJSON").

    b.  If IsCallable(_toJSON_) is TRUE

        i.  Let _value_ be the result of calling the [[Call]] internal
            method of _toJSON_ passing _value_ as _thisArgument_ and a
            List containing _key_ as _argumentsList_.

        ii. ReturnIfAbrupt(_value_).

4.  If _ReplacerFunction_ is not UNDEFINED, then

    a.  Let _value_ be the result of calling the [[Call]] internal
        method of _ReplacerFunction_ passing _holder_ as the THIS value
        and with an argument list consisting of _key_ and _value_.

    b.  ReturnIfAbrupt(_value_).

5.  If Type(_value_) is Object then,

    a.  If _value_ has a [[NumberData]] internal slot then,

        i.  Let _value_ be ToNumber(_value_).

    b.  Else if _value_ has a [[StringData]] internal slot then,

        i.  Let _value_ be ToString(_value_).

    c.  Else if _value_ has a [[BooleanData]] internal slot then,

        i.  Let _value_ be the value of the [[BooleanData]] internal
            slot of _value_.

        ii. If _value_ is UNDEFINED, then throw a TYPEERROR exception.

6.  If _value_ is NULL then return "NULL".

7.  If _value_ is TRUE then return "TRUE".

8.  If _value_ is FALSE then return "FALSE".

9.  If Type(_value_) is String, then return the result of calling the
    abstract operation Quote with argument _value_.

10. If Type(_value_) is Number

    a.  If _value_ is finite then return ToString(_value_).

    b.  Else, return "NULL".

11. If Type(_value_) is Object, and IsCallable(_value_) is FALSE

    a.  If _value_ is an exotic Array object then

        i.  Return the result of calling the abstract operation JA with
            argument _value_.

    b.  Else, return the result of calling the abstract operation JO
        with argument _value_.

12. Return UNDEFINED.

Runtime Semantics: Quote Abstract Operation

The abstract operation Quote(_value_) wraps a String value in double
quotes and escapes code units within it.

1.  Let _product_ be code unit U+0022 (QUOTATION MARK).

2.  For each code unit _C_ in _value

    a.  If _C_ is U+0022 or U+005C (reverse solidus)

        i.  Let _product_ be the concatenation of _product_ and code
            unit U+005C.

        ii. Let _product_ be the concatenation of _product_ and _C_.

    b.  Else if _C_ is backspace, formfeed, newline, carriage return, or
        tab

        i.  Let _product_ be the concatenation of _product_ and code
            unit U+005C (reverse solidus).

        ii. Let _abbrev_ be the string value corresponding to the value
            of _C_ as follows:

  backspace "B"

  formfeed "F"

  newline "N"

  carriage return "R"

  tab "T"

i.  Let _product_ be the concatenation of _product_ and _abbrev_.

a.  Else if _C_ has a code unit value less than U+0020 (SPACE)

    i.  Let _product_ be the concatenation of _product_ and code unit
        U+005C (reverse solidus).

    ii. Let _product_ be the concatenation of _product_ and "U".

    iii. Let _hex_ be the string result of converting the numeric code
        unit value of _C_ to a String of four hexadecimal digits.
        Alphabetic hexadecimal digits are presented as lowercase Latin
        letters.

    iv. Let _product_ be the concatenation of _product_ and _hex_.

b.  Else

    i.  Let _product_ be the concatenation of _product_ and _C_.

1.  Let _product_ be the concatenation of _product_ and code unit U+
    (QUOTATION MARK).

2.  Return _product_.

Runtime Semantics: JO Abstract Operation

The abstract operation JO(_value_) serializes an object. It has access
to the _stack_, _indent_, _gap_, and _PropertyList_ of the invocation of
the STRINGIFY method.

1.  If _stack_ contains _value_ then throw a TYPEERROR exception because
    the structure is cyclical.

2.  Append _value_ to _stack_.

3.  Let _stepback_ be _indent_.

4.  Let _indent_ be the concatenation of _indent_ and _gap_.

5.  If _PropertyList_ is not UNDEFINED, then

    a.  Let _K_ be _PropertyList_.

6.  Else

    a.  Let _K_ be EnumerableOwnNames(_value_).

7.  Let _partial_ be an empty List.

8.  For each element _P_ of _K_,

    a.  Let _strP_ be the result of Str(_P_, _value_).

    b.  ReturnIfAbrupt(_strP_).

    c.  If _strP_ is not UNDEFINED

        i.  Let _member_ be the result of calling the abstract operation
            Quote with argument _P_.

        ii. Let _member_ be the concatenation of _member_ and the string
            ":".

        iii. If _gap_ is not the empty String

            1.  Let _member_ be the concatenation of _member_ and code
                unit U+020 (SPACE).

        iv. Let _member_ be the concatenation of _member_ and _strP_.

        v.  Append _member_ to _partial_.

9.  If _partial_ is empty, then

    a.  Let _final_ be "{}".

10. Else

    a.  If _gap_ is the empty String

        i.  Let _properties_ be a String formed by concatenating all the
            element Strings of _partial_ with each adjacent pair of
            Strings separated with code unit U+002C (comma). A comma is
            not inserted either before the first String or after the
            last String.

        ii. Let _final_ be the result of concatenating "{",
            _properties_, and "}".

    b.  Else _gap_ is not the empty String

        i.  Let _separator_ be the result of concatenating code unit
            U+002C (comma), code unit U+000A (line feed), and _indent_.

        ii. Let _properties_ be a String formed by concatenating all the
            element Strings of _partial_ with each adjacent pair of
            Strings separated with _separator_. The _separator_ String
            is not inserted either before the first String or after the
            last String.

        iii. Let _final_ be the result of concatenating "{", code unit
            U+000A (line feed), _indent_, _properties_, code unit
            U+000A, _stepback_, and "}".

11. Remove the last element of _stack_.

12. Let _indent_ be _stepback_.

13. Return _final_.

Runtime Semantics: JA Abstract Operation

The abstract operation JA(_value_) serializes an array. It has access to
the _stack_, _indent_, and _gap_ of the invocation of the stringify
method. The representation of arrays includes only the elements between
zero and ARRAY.LENGTH – 1 inclusive. Properties whose keys are not array
indexes are excluded from the stringification. An array is stringified
as an open left bracket, elements separated by comma, and a closing
right bracket.

1.  If _stack_ contains _value_ then throw a TYPEERROR exception because
    the structure is cyclical.

2.  Append _value_ to _stack_.

3.  Let _stepback_ be _indent_.

4.  Let _indent_ be the concatenation of _indent_ and _gap_.

5.  Let _partial_ be an empty List.

6.  Assert: _value_ is a standard array object and hence its "LENGTH"
    property is a nonnegative integer.

7.  Let _lenVal_ be the result of Get(_value_, "LENGTH")

8.  Let _len_ be ToLength(_lenVal_).

9.  ReturnIfAbrupt(_len_).

10. Let _index_ be 0.

11. Repeat while _index_ < _len

    a.  Let _strP_ be the result of calling the abstract operation
        Str(ToString(_index_), _value_).

    b.  ReturnIfAbrupt(_strP_).

    c.  If _strP_ is UNDEFINED

        i.  Append "NULL" to _partial_.

    d.  Else

        i.  Append _strP_ to _partial_.

    e.  Increment _index_ by 1.

12. If _partial_ is empty, then

    a.  Let _final_ be "[]".

13. Else

    a.  If _gap_ is the empty String

        i.  Let _properties_ be a String formed by concatenating all the
            element Strings of _partial_ with each adjacent pair of
            Strings separated with code unit U+002C (comma). A comma is
            not inserted either before the first String or after the
            last String.

        ii. Let _final_ be the result of concatenating "[",
            _properties_, and "]".

    b.  Else

        i.  Let _separator_ be the result of concatenating code unit
            U+002C (comma), code unit U+000A (line feed), and _indent_.

        ii. Let _properties_ be a String formed by concatenating all the
            element Strings of _partial_ with each adjacent pair of
            Strings separated with _separator_. The _separator_ String
            is not inserted either before the first String or after the
            last String.

        iii. Let _final_ be the result of concatenating "[", code unit
            U+000A (line feed), _indent_, _properties_, code unit
            U+000A, _stepback_, and "]".

14. Remove the last element of _stack_.

15. Let _indent_ be _stepback_.

16. Return _final_.

JSON [ @@toStringTag ]

The initial value of the @@toStringTag property is the string value
"JSON".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.



CONTROL ABSTRACTION OBJECTS 


Common Iteration Interfaces

An interface is a set of property keys whose associated values match a
specific specification. Any object that provides all the properties as
described by an interface’s specification _conforms_ to that interface.
An interface is not represented by an distinct object. There may be many
separately implemented objects that conform to any interface. An
individual object may conform to multiple interfaces.

The _Iterable_ Interface

The _Iterable_ interface includes the following property:

  PROPERTY     VALUE                                               REQUIREMENTS
  ------------ --------------------------------------------------- ---------------------------------------------------------------------------
  @@ITERATOR   A zero arguments function that returns an object.   The function returns an object that conforms to the _iterator_ interface.

The _Iterator_ Interface

The _Iterator_ interface includes the following properties:

  PROPERTY   VALUE                                REQUIREMENTS
  ---------- ------------------------------------ --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  NEXT       A function that returns an object.   The function returns an object that conforms to the _IteratorResult_ interface. If a previous call to the NEXT method of an _Iterator_ has returned an _IteratorResult_ object whose DONE property is TRUE, then all subsequent calls to the NEXT method of that object must also return an _IteratorResult_ object whose DONE property is TRUE,

NOTE Arguments may be passed to the next function but their
interpretation and validity is dependent upon the target Iterator. The
for-of statement and other common users of Iterators do not pass any
arguments, so Iterators that expect to be used in such a manner must be
prepared to deal with being called with no arguments.

The _IteratorResult_ Interface

The _IteratorResult_ interface includes the following properties:

  PROPERTY   VALUE                           REQUIREMENTS
  ---------- ------------------------------- ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  DONE       Either TRUE or FALSE.           This is the result status of an _iterator_ NEXT method call. If the end of the iterator was reached DONE is TRUE. If the end was not reached DONE is FALSE and a value is available. If a DONE property (either own or inherited does not exist), it is consider to have the value FALSE.
  VALUE      Any ECMAScript languge value.   If done is FALSE, this is the current iteration element value. If done is TRUE, this is the return value of the iterator, if it supplied one. If the iterator does not have a return value, VALUE is UNDEFINED. In that case, the VALUE property may be absent from the conforming object if it does not inherit an explicit VALUE property.


GeneratorFunction Objects

GENERATOR FUNCTION objects are constructor functions that are usually
created by evaluating _GeneratorDeclaration_, _GeneratorExpression_, and
_GeneratorMethod_ syntactic productions. They may also be created by
calling the GENERATORFUNCTION constructor.

  --
  --

Figure 2 (Informative) — Generator Objects Relationships

The GeneratorFunction Constructor

The GeneratorFunction constructor is the %GeneratorFunction% intrinsic.
When GENERATORFUNCTION is called as a function rather than as a
constructor, it creates and initializes a new GeneratorFunction object.
Thus the function call GENERATORFUNCTION (…) is equivalent to the object
creation expression NEW GENERATORFUNCTION (…) with the same arguments.
However, if the THIS value passed in the call is an Object with a
[[Code]] internal slot whose value is UNDEFINED, it initializes the THIS
value using the argument values. This permits GENERATORFUNCTION to be
used both as factory method and to perform constructor instance
initialization.

GENERATORFUNCTION may be subclassed and subclass constructors may
perform a SUPER invocation of the GENERATORFUNCTION constructor to
initialize subclass instances. However, all syntactic forms for defining
generator function objects create direct instances of GENERATORFUNCTION.
There is no syntactic means to create instances of GENERATORFUNCTION
subclasses.

GeneratorFunction (p1, p2, … , pn, body)

The last argument specifies the body (executable code) of a generator
function; any preceding arguments specify formal parameters.

When the GENERATORFUNCTION function is called with some arguments _p1_,
_p2_, … , _pn_, _body_ (where _n_ might be 0, that is, there are no
“_p_” arguments, and where _body_ might also not be provided), the
following steps are taken:

1.  Let _argCount_ be the total number of arguments passed to this
    function invocation.

2.  Let _P_ be the empty String.

3.  If _argCount_ = 0, let _bodyText_ be the empty String.

4.  Else if _argCount_ = 1, let _bodyText_ be that argument.

5.  Else _argCount_ > 1,

    a.  Let _firstArg_ be the first argument.

    b.  Let _P_ be ToString(_firstArg_).

    c.  ReturnIfAbrupt(_P_).

    d.  Let _k_ be 2.

    e.  Repeat, while _k_ < _argCount_

        i.  Let _nextArg_ be the _k_’th argument.

        ii. Let _nextArgString_ be ToString(_nextArg_).

        iii. ReturnIfAbrupt(_nextArgString_).

        iv. Let _P_ be the result of concatenating the previous value of
            _P_, the String "," (a comma), and _nextArgString_.

        v.  Increase _k_ by 1.

    f.  Let _bodyText_ be the _k_’th argument.

6.  Let _bodyText_ be ToString(_bodyText_).

7.  ReturnIfAbrupt(_bodyText_).

8.  Let _parameters_ be the result of parsing _P_, interpreted as UTF-
    encoded Unicode text as described in 10.1.1_,_ using
    _FormalParameters_ as the goal symbol. Throw a SYNTAXERROR exception
    if the parse fails.

9.  Let _funcBody_ be the result of parsing _bodyText_, interpreted as
    UTF-16 encoded Unicode text as described in 10.1.1_,_ using
    _FunctionBody_~[Yield]~ as the goal symbol. Throw a SYNTAXERROR
    exception if the parse fails or if any static semantics errors are
    detected.

10. 11. If any element of the BoundNames of _parameters_ also occurs in
    the LexicallyDeclaredNames of _funcBody_, then throw a SYNTAXERROR
    exception.

12. If _bodyText_ is strict mode code (see 10.2.1) then let _strict_ be
    TRUE, else let _strict_ be FALSE.

13. Let _scope_ be the Global Environment.

14. Let _F_ be the THIS value.

15. If Type(_F_) is not Object or if _F_ does not have a [[Code]]
    internal slot or if the value of [[Code]] is not UNDEFINED, then

    a.  Let _C_ be the active function object..

    b.  Let _proto_ be the result of GetPrototypeFromConstructor(_C_,
        "%GENERATOR%").

    c.  ReturnIfAbrupt(_proto_).

    d.  Let _F_ be FunctionAllocate(_proto_ , _strict_, "GENERATOR").

    e.  ReturnIfAbrupt(_F_).

16. If the value of _F’s_ [[FunctionKind]] internal slot is not
    "GENERATOR", then throw a TYPEERROR exception.

17. 18. Let _isExtensible_ be IsExtensible(_F_).

19. ReturnIfAbrupt(_isExtensible_).

20. If _isExtensible_ is FALSE, then throw a TYPEERROR exception.

21. 22. 23. Using _funcBody_ as the _FunctionBody_ production, let
    _body_ be the supplemental syntactic grammar production:
    _GeneratorBody_ : _FunctionBody_.

24. Let _status_ be FunctionInitialize(_F_, Normal, _strict_,
    _parameters_, _body,_ _scope_).

25. Let _prototype_ ObjectCreate(%GeneratorPrototype%).

26. If ReferencesSuper(_funcBody_) is TRUE or
    ReferencesSuper(_parameters_) is TRUE, then

    a.  Perform MakeMethod(_F_, UNDEFINED, UNDEFINED).

27. Let _status_ be the result of the abstract operation MakeConstructor
    with arguments _F_, TRUE, and _prototype_.

28. ReturnIfAbrupt(_status_).

29. Let _hasName_ be HasOwnProperty(_F_, "NAME").

30. ReturnIfAbrupt(_hasName_).

31. If _hasName_ is FALSE, then

    a.  Let status be SetFunctionName(_F_, "ANONYMOUS").

    b.  ReturnIfAbrupt(_status_).

32. Return _F_.

A PROTOTYPE property is automatically created for every function created
using the GENERATORFUNCTION constructor, to provide for the possibility
that the function will be used as a constructor.

new GeneratorFunction ( ... argumentsList)

When GENERATORFUNCTION is called as part of a NEW expression, it creates
and initializes a newly created object:

1.  Let _F_ be the GENERATORFUNCTION function object on which the NEW
    operator was applied.

2.  Let _argumentsList_ be the _argumentsList_ argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of Construct (_F_, _argumentsList_).

If GENERATORFUNCTION is implemented as an ECMAScript function object,
its [[Construct]] internal method will perform the above steps.

Properties of the GeneratorFunction Constructor

The GeneratorFunction constructor is a built-in Function object that
inherits from the Function constructor. The value of the [[Prototype]]
internal slot of the GeneratorFunction constructor is the intrinsic
object %Function%.

The value of the [[Extensible]] internal slot of the GeneratorFunction
constructor is TRUE.

The value of the NAME property of the GeneratorFunction is
"GENERATORFUNCTION".

The GeneratorFunction constructor has the following properties:

 GeneratorFunction.length

This is a data property with a value of 1. This property has the
attributes { [[Writable]]: FALSE, [[Enumerable]]: FALSE,
[[Configurable]]: TRUE }.

GeneratorFunction.prototype

The initial value of GENERATORFUNCTION.PROTOTYPE is %Generator%, the
standard built-in GeneratorFunction prototype.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

 GeneratorFunction[ @@create ] ( )

The @@create method of an object _F_ performs the following steps:

1.  Let _F_ be the THIS value.

2.  Let _proto_ be the result of GetPrototypeFromConstructor(_F_,
    "%GENERATOR%").

3.  ReturnIfAbrupt(_proto_).

4.  Return FunctionAllocate(_proto_, FALSE, "GENERATOR").

5.  

The value of the NAME property of this function is "[SYMBOL.CREATE]".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

NOTE The GeneratorFunction @@CREATE function passes FALSE as the
_strict_ parameter to FunctionAllocate. This causes the allocated
ECMAScript function object to have the internal methods of a non-strict
constructor function. The GENERATORFUNCTION constructor may reset the
functions [[Strict]] internal slot to TRUE. It is up to the
implementation whether this also changes the internal methods.

Properties of the GeneratorFunction Prototype Object

The GeneratorFunction prototype object is an ordinary object. It is not
a function object and does not have a [[Code]] internal slot or any
other of the internal slots listed in Table 26 or Table 48. In addition
to being the value of the prototype property of the %GeneratorFunction%
intrinsic and is itself the %Generator% intrinsic.

The value of the [[Prototype]] internal slot of the GeneratorFunction
prototype object is the %FunctionPrototype% intrinsic object. The
initial value of the [[Extensible]] internal slot of the
GeneratorFunction prototype object is TRUE.

GeneratorFunction.prototype.constructor

The initial value of GENERATORFUNCTION.PROTOTYPE.CONSTRUCTOR is the
intrinsic object %GeneratorFunction%.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

GeneratorFunction.prototype.prototype

The value of GENERATORFUNCTION.PROTOTYPE.PROTOTYPE is the
%GeneratorPrototype% intrinsic object.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

 GeneratorFunction.prototype [ @@toStringTag ]

The initial value of the @@toStringTag property is the string value
"GENERATORFUNCTION".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

 GeneratorFunction.prototype [ @@create ] ( )

The @@create method of an object _F_ performs the following steps:

1.  Let _F_ be the THIS value.

2.  Let _obj_ be the result of calling
    OrdinaryCreateFromConstructor(_F_, "%GENERATORPROTOTYPE%", (
    [[GeneratorState]], [[GeneratorContext]]) ).

3.  Return _obj_.

The value of the NAME property of this function is "[SYMBOL.CREATE]".

This property has the attributes { [[Writable]]: TRUE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

GeneratorFunction Instances

Every GeneratorFunction instance is an ECMAScript function object and
has the internal slots listed in Table 26. The value of the
[[FunctionKind]] internal slot for all such instances is "GENERATOR".

The GeneratorFunction instances have the following own properties:

length

The value of the LENGTH property is an integer that indicates the
typical number of arguments expected by the GeneratorFunction. However,
the language permits the function to be invoked with some other number
of arguments. The behaviour of a GeneratorFunction when invoked on a
number of arguments other than the number specified by its LENGTH
property depends on the function.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

prototype

Whenever a GeneratorFunction instance is created another ordinary object
is also created and is the initial value of the generator function’s
PROTOTYPE property. The value of the prototype property is used to
initialize the [[Prototype]] internal slot of a newly created Generator
object before the generator function object is invoked as a constructor
for that newly created object.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

NOTE Unlike function instances, the object that is the value of the a
GeneratorFunction’s PROTOTYPE property does not have a CONSTRUCTOR
property whose value is the GeneratorFunction instance.


Generator Objects

A Generator object is an instance of a generator function and conforms
to both the _Iterator_ and _Iterable_ interfaces.

Generator instances directly inherit properties from the object that is
the value of the PROTOTYPE property of the Generator function that
created the instance. Generator instances indirectly inherit properties
from the Generator Prototype intrinsic, %GeneratorPrototype%.

Properties of Generator Prototype

The Generator prototype object is the %GeneratorPrototype% intrinsic. It
is also the initial value of the PROTOTYPE property of the %Generator%
intrinsic (the GeneratorFrunction.prototype).

The Generator prototype is an ordinary object. It is not a Generator
instance and does not have a [[GeneratorState]] internal slot.

The value of the [[Prototype]] internal slot of the Generator prototype
object is the intrinsic object %ObjectPrototype% (19.1.3). The initial
value of the [[Extensible]] internal slot of the Function prototype
object is TRUE.

All Generator instances indirectly inherit properties of the Generator
prototype object.

Generator.prototype.constructor

The initial value of GENERATOR.PROTOTYPE.CONSTRUCTOR is the intrinsic
object %Generator%.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

 Generator.prototype.next ( value )

The NEXT method performs the following steps:

1.  Let _g_ be the THIS value.

2.  Return the result of GeneratorResume(_g_, _value_).

Generator.prototype.return ( value )

The THROW method performs the following steps:

1.  Let _g_ be the THIS value.

2.  Let _C_ be Completion{[[type]]: return, [[value]]: _value_,
    [[target]]: empty}.

3.  Return GeneratorResumeAbrupt(_g_, _C_).

Generator.prototype.throw ( exception )

The THROW method performs the following steps:

1.  Let _g_ be the THIS value.

2.  3.  4.  5.  6.  Let _C_ be Completion{[[type]]: throw, [[value]]:
    _exception_, [[target]]: empty}.

7.  8.  9.  a.  b.  c.  

10. 11. 12. 13. 14. 15. 16. 17. Return GeneratorResumeAbrupt(_g_, _C_).

Generator.prototype [ @@iterator ] ( )

The following steps are taken:

1.  Return the THIS value.

The value of the NAME property of this function is "[SYMBOL.ITERATOR]".

Generator.prototype [ @@toStringTag ]

The initial value of the @@toStringTag property is the string value
"GENERATOR".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Properties of Generator Instances

Generator instances are initially created with the internal slots
described in Table 48.

Table 48 — Internal Slots of Generator Instances

  ---------------------- -----------------------------------------------------------------------------------------------------------------------------------------------------
  INTERNAL SLOT          DESCRIPTION
  [[GeneratorState]]     The current execution state of the generator. The possible values are: UNDEFINED, "SUSPENDEDSTART", "SUSPENDEDYIELD", "EXECUTING", and "COMPLETED".
  [[GeneratorContext]]   The execution context that is used when executing the code of this generator.
  ---------------------- -----------------------------------------------------------------------------------------------------------------------------------------------------

Generator Abstract Operations

 GeneratorStart (generator, generatorBody)

The abstract operation GeneratorStart with arguments _generator_ and
_generatorBody_ performs the following steps:

1.  Assert: The value of _generator’s_ [[GeneratorState]] internal slot
    is UNDEFINED.

2.  Let _genContext_ be the running execution context.

3.  Set the Generator component of _genContext_ to _generator.

4.  Set the code evaluation state of _genContext_ such that when
    evaluation is resumed for that execution context the following steps
    will be performed:

    a.  Let _result_ be the result of evaluating _generatorBody_.

    b.  Assert: If we return here, the generator either threw an
        exception or performed either an implicit or explicit return.

    c.  Remove _genContext_ from the execution context stack and restore
        the execution context that is at the top of the execution
        context stack as the running execution context.

    d.  Set _generator’s_ [[GeneratorState]] internal slot to
        "COMPLETED".

    e.  Once a generator enters the "COMPLETED" state it never leaves it
        and its associated execution context is never resumed. Any
        execution state associated with _generator_ can be discard at
        this point.

    f.  ReturnIfAbrupt(_result_).

    g.  Return CreateIterResultObject(_result_, TRUE).

5.  Set _generator’s_ [[GeneratorContext]] internal slot to
    _genContext_.

6.  Set _generator’s_ [[GeneratorState]] internal slot to
    "SUSPENDEDSTART".

7.  Return NormalCompletion(_generator_).

 GeneratorResume ( generator, value )

The abstract operation GeneratorResume with arguments _generator_ and
_value_ performs the following steps:

1.  If Type(_generator_) is not Object, then throw a TYPEERROR
    exception.

2.  If _generator_ does not have a [[GeneratorState]] internal slot,
    then throw a TYPEERROR exception.

3.  Let _state_ be the value of _generator’s_ [[GeneratorState]]
    internal slot.

4.  Assert: _generator_ also has a [[GeneratorContext]] internal slot.

5.  If _state_ is "COMPLETED", then return
    CreateIterResultObject(UNDEFINED, TRUE).

6.  If _state_ is neither "SUSPENDEDSTART" nor "SUSPENDEDYIELD", then
    throw a TYPEERROR exception.

7.  Let _genContext_ be the value of _generator’s_ [[GeneratorContext]]
    internal slot.

8.  Let _methodContext_ be the running execution context.

9.  Suspend _methodContext_.

10. Set _generator’s_ [[GeneratorState]] internal slot to "EXECUTING".

11. Push _genContext_ onto the execution context stack; _genContext_ is
    now the running execution context.

12. Resume the suspended evaluation of _genContext_ using
    NormalCompletion(_value_) as the result of the operation that
    suspended it. Let _result_ be the value returned by the resumed
    computation.

13. Assert: When we return here, _genContext_ has already been removed
    from the execution context stack and _methodContext_ is the
    currently running execution context.

14. Return _result_.

GeneratorResumeAbrupt(generator, abruptCompletion)

The abstract operation GeneratorResumeAbrupt with arguments _generator_
and _abruptCompletion_ performs the following steps:

1.  If Type(_generator_) is not Object, then throw a TYPEERROR
    exception.

2.  If _generator_ does not have a [[GeneratorState]] internal slot,
    then throw a TYPEERROR exception.

3.  Let _state_ be the value of _generator’s_ [[GeneratorState]]
    internal slot.

4.  Assert: _generator_ also has a [[GeneratorContext]] internal slot.

5.  Let _E_ be Completion{[[type]]: throw, [[value]]: _exception_,
    [[target]]: empty}.

6.  If _state_ is "COMPLETED", then return _abruptCompletion_.

7.  If _state_ is neither "SUSPENDEDSTART" nor "SUSPENDEDYIELD", then
    throw a TYPEERROR exception.

8.  If _state_ is "SUSPENDEDSTART" then,

    a.  Set _generator’s_ [[GeneratorState]] internal slot to
        "COMPLETED".

    b.  Once a generator enters the "COMPLETED" state it never leaves it
        and its associated execution context is never resumed. Any
        execution state associated with _generator_ can be discard at
        this point.

    c.  Return _abruptCompletion_.

9.  Let _genContext_ be the value of _generator’s_ [[GeneratorContext]]
    internal slot.

10. Let _methodContext_ be the running execution context.

11. Suspend _methodContext_.

12. Set _generator’s_ [[GeneratorState]] internal slot to "EXECUTING".

13. Push _genContext_ onto the execution context stack; _genContext_ is
    now the running execution context.

14. Resume the suspended evaluation of _genContext_ using
    _abruptCompletion_ as the result of the operation that suspended it.
    Let _result_ be the value returned by the resumed compation.

15. Assert: When we return here, _genContext_ has already been removed
    from the execution context stack and _methodContext_ is the
    currently running execution context.

16. Return _result_.

GeneratorYield ( iterNextObj )

The abstract operation GeneratorYield with argument _iterNextObj_
performs the following steps:

1.  Assert: _iterNextObj_ is an Object that implemented the
    _IteratorResult_ interface.

2.  Let _genContext_ be the running execution context.

3.  Assert: _genContext_ is the execution context of a generator.

4.  Let _generator_ be the value of the Generator component of
    _genContext_.

5.  Set the value of _generator’s_ [[GeneratorState]] internal slot to
    "SUSPENDEDYIELD".

6.  Remove _genContext_ from the execution context stack and restore the
    execution context that is at the top of the execution context stack
    as the running execution context.

7.  Set the code evaluation state of _genContext_ such that when
    evaluation is resumed with a Completion _resumptionValue_ the
    following steps will be performed:

    a.  Return _resumptionValue_.

    b.  NOTE: This returns to the evaluation of the _YieldExpression_
        production that originally called this abstract operation.

8.  Return NormalCompletion(_iterNextObj_).

9.  NOTE: This returns to the evaluation of the operation that had most
    previously resumed evaluation of _genContext_.


Promise Objects

A Promise is an object that is used as a placeholder for the eventual
results of a deferred (and possibly asynchronous) computation.

Any Promise object is in one of three mutually exclusive states:
_fulfilled_, _rejected_, and _pending_:

-   A promise P is fulfilled if P.THEN(F, R) will immediately enqueue a
    Job to call the function F.

-   A promise P is rejected if P.THEN(F, R) will immediately enqueue a
    Job to call the function R.

-   A promise is pending if it is neither fulfilled nor rejected.

A promise is said to be _settled_ if it is not pending, i.e. if it is
either fulfilled or rejected.

A promise is _resolved_ if it is settled or if it has been "locked in"
to match the state of another promise. Attempting to resolve or reject a
resolved promise has no effect. A promise is _unresolved_ if it is not
resolved. An unresolved promise is always in the pending state. A
resolved promise may be pending, fulfilled or rejected.

Promise Abstract Operations

PromiseCapability Records

A PromiseCapability is a Record value used to encapsulate a promise
object along with the functions that are capable of resolving or
rejecting that promise object. PromiseCapability records are produced by
the NewPromiseCapability abstract operation.

PromiseCapability Records have the fields listed in Table 49.

Table 49 — PromiseCapability Record Fields

  -------------- ------------------- ----------------------------------------------------------------
  _FIELD NAME_   _VALUE_             _MEANING_
  [[Promise]]    An object           An object that is usable as a promise.
  [[Resolve]]    A function object   The function that is used to resolve the given promise object.
  [[Reject]]     A function object   The function that is used to reject the given promise object.
  -------------- ------------------- ----------------------------------------------------------------

IfAbruptRejectPromise ( value, capability )

IfAbruptRejectPromise is a short hand for a sequence of algorithm steps
that use a PromiseCapability record. An algorithm step of the form:

1.  IfAbruptRejectPromise(_value_, _capability_).

means the same thing as:

1.  If _value_ is an abrupt completion,

    a.  Let _rejectResult_ be the result of calling the [[Call]]
        internal method of _capability_.[[Reject]] with UNDEFINED as
        _thisArgument_ and (_value_.[[value]]) as _argumentsList_.

    b.  ReturnIfAbrupt(_rejectResult_).

    c.  Return _capability_.[[Promise]].

2.  Else if _value_ is a Completion Record, then let _value_ be
    _value_.[[value]].

PromiseReaction Records

The PromiseReaction is a Record value used to store information about
how a promise should react when it becomes resolved or rejected with a
given value. PromiseReaction records are created by the THEN method of
the Promise prototype, and are used by a PromiseReactionJob.

PromiseReaction records have the fields listed in Table 50.

Table 50 — PromiseReaction Record Fields

  ------------------ ------------------------------- ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  _FIELD NAME_       _VALUE_                         _MEANING_
  [[Capabilities]]   A PromiseCapability record      The capabilities of the promise for which this record provides a reaction handler.
  [[Handler]]        A function object or a String   The function that should be applied to the incoming value, and whose return value will govern what happens to the derived promise. If [[Handler]] is "IDENTITY" it is equivalent to a function that simply returns its first argument. If [[Handler]] is "THROWER" it is equivalent to a function that throws its first argument as an exception.
  ------------------ ------------------------------- ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

CreateResolvingFunctions ( promise )

When CreateResolvingFunctions is performed with argument _promise_, the
following steps are taken:

1.  Let _alreadyResolved_ be a new Record { [[value]]: FALSE }.

2.  Let _resolve_ be a new built-in function object as defined in
    Promise Resolve Functions (25.4.1.3.2).

3.  Set the [[Promise]] internal slot of _resolve_ to _promise_.

4.  Set the [[AlreadyResolved]] internal slot of _resolve_ to
    _alreadyResolved_.

5.  Let _reject_ be a new built-in function object as defined in Promise
    Reject Functions (25.4.1.3.1).

6.  Set the [[Promise]] internal slot of _reject_ to _promise_.

7.  Set the [[AlreadyResolved]] internal slot of _reject_ to
    _alreadyResolved_.

8.  Return a new Record { [[Resolve]]: _resolve_, [[Reject]]: _reject
    }.

Promise Reject Functions

A promise reject function is an anonymous built-in function that has
[[Promise]] and [[AlreadyResolved]] internal slots.

When a promise reject function _F_ is called with argument _reason_, the
following steps are taken:

1.  Assert: _F_ has a [[Promise]] internal slot whose value is an
    Object.

2.  Let _promise_ be the value of _F_'s [[Promise]] internal slot.

3.  Let _alreadyResolved_ be the value of _F_'s [[AlreadyResolved]]
    internal slot.

4.  If _alreadyResolved_.[[value]] is TRUE, then return UNDEFINED.

5.  Set _alreadyResolved_.[[value]] to TRUE.

6.  Return RejectPromise(_promise_, _reason_).

Promise Resolve Functions

A promise resolve function is an anonymous built-in function that has
[[Promise]] and [[AlreadyResolved]] internal slots.

When a promise resolve function _F_ is called with argument
_resolution_, the following steps are taken:

1.  Assert: _F_ has a [[Promise]] internal slot whose value is an
    Object.

2.  Let _promise_ be the value of _F_'s [[Promise]] internal slot.

3.  Let _alreadyResolved_ be the value of _F_'s [[AlreadyResolved]]
    internal slot.

4.  If _alreadyResolved_.[[value]] is TRUE, then return UNDEFINED.

5.  Set _alreadyResolved_.[[value]] to TRUE.

6.  If SameValue(_resolution_, _promise_) is TRUE, then

    a.  Let _selfResolutionError_ be a newly-created TYPEERROR object.

    b.  Return RejectPromise(_promise_, _selfResolutionError_).

7.  If Type(_resolution_) is not Object, then

    a.  Return FulfillPromise(_promise_, _resolution_).

8.  Let _then_ be Get(_resolution_, "THEN").

9.  If _then_ is an abrupt completion, then

    a.  Return RejectPromise(_promise_, _then_.[[value]]).

10. Let _then_ be _then_.[[value]].

11. If IsCallable(_then_) is FALSE, then

    a.  Return FulfillPromise(_promise_, _resolution_).

    b.  c.  d.  e.  

12. Perform EnqueueJob ("PromiseJobs", PromiseResolveThenableJob,
    (_promise_, _resolution_, _then_))

13. Return UNDEFINED.

FulfillPromise ( promise, value)

When the FulfillPromise abstract operation is called with arguments
_promise_ and _value_ the following steps are taken:

1.  Assert: the value of _promise_'s [[PromiseState]] internal slot is
    "PENDING".

2.  Let _reactions_ be the value of _promise_'s
    [[PromiseFulfillReactions]] internal slot.

3.  Set the value of _promise_'s [[PromiseResult]] internal slot to
    _value_.

4.  Set the value of _promise_'s [[PromiseFulfillReactions]] internal
    slot to UNDEFINED.

5.  Set the value of _promise_'s [[PromiseRejectReactions]] internal
    slot to UNDEFINED.

6.  Set the value of _promise_'s [[PromiseState]] internal slot to
    "FULFILLED".

7.  Return TriggerPromiseReactions(_reactions_, _value_).

NewPromiseCapability ( C )

The abstract operation NewPromiseCapability takes a constructor
function, and attempts to use that constructor function in the fashion
of the built-in PROMISE constructor to create a Promise object and
extract its resolve and reject functions. The promise plus the resolve
and reject functions are used to initialize a new PromiseCapability
record which is returned as the value of this abstract operation.

1.  If IsConstructor(_C_) is FALSE, throw a TYPEERROR exception.

2.  Assert: _C_ is a constructor function that supports the parameter
    conventions of the PROMISE constructor (see 25.4.3.1).

3.  Let _promise_ be CreateFromConstructor(_C_).

4.  ReturnIfAbrupt(_promise_).

5.  If Type(_promise_) is not Object, then throw a TYPEERROR exception.

6.  Return CreatePromiseCapabilityRecord(_promise_, _C_).

NOTE This abstract operation supports Promise subclassing, as it is
generic on any constructor that calls a passed executor function
argument in the same way as the Promise constructor. It is used to
generalize static methods of the Promise constructor to any subclass.

CreatePromiseCapabilityRecord( promise, constructor ) 

When the CreatePromiseCapabilityRecord abstract operation is called with
arguments _promise_ and _constructor_ the following steps are taken:

1.  Assert: _promise_ is an uninitialized object created as if by
    invoking @@create on _constructor_.

2.  Assert: IsConstructor(_constructor_) is TRUE.

3.  Let _promiseCapability_ be a new PromiseCapability { [[Promise]]:
    _promise_, [[Resolve]]: UNDEFINED, [[Reject]]: UNDEFINED }.

4.  Let _executor_ be a new built-in function object as defined in
    GetCapabilitiesExecutor Functions (25.4.1.5.1).

5.  Set the [[Capability]] internal slot of _executor_ to
    _promiseCapability_.

6.  Let _constructorResult_ be the result of calling the [[Call]]
    internal method of _constructor_, passing _promise_ and (_executor_)
    as the arguments.

7.  ReturnIfAbrupt(_constructorResult_).

8.  If IsCallable(_promiseCapability_.[[Resolve]]) is FALSE, then throw
    a TYPEERROR exception.

9.  If IsCallable(_promiseCapability_.[[Reject]]) is FALSE, then throw a
    TYPEERROR exception.

10. If Type(_constructorResult_) is Object and SameValue(_promise_,
    _constructorResult_) is FALSE, then throw a TYPEERROR exception.

11. Return _promiseCapability_.

GetCapabilitiesExecutor Functions

A GetCapabilitiesExecutor function is an anonymous built-in function
that has a [[Capability]] internal slot.

When a GetCapabilitiesExecutor function _F_ is called with arguments
_resolve_ and _reject_ the following steps are taken:

1.  Assert: _F_ has a [[Capability]] internal slot whose value is a
    PromiseCapability Record.

2.  Let _promiseCapability_ be the value of _F_'s [[Capability]]
    internal slot.

3.  If _promiseCapability_.[[Resolve]] is not UNDEFINED, then throw a
    TYPEERROR exception.

4.  If _promiseCapability_.[[Reject]] is not UNDEFINED, then throw a
    TYPEERROR exception.

5.  Set _promiseCapability_.[[Resolve]] to _resolve_.

6.  Set _promiseCapability_.[[Reject]] to _reject_.

7.  Return UNDEFINED.

IsPromise ( x )

The abstract operation IsPromise checks for the promise brand on an
object.

1.  If Type(_x_) is not Object, return FALSE.

2.  If _x_ does not have a [[PromiseState]] internal slot, return FALSE.

3.  If the value of _x_'s [[PromiseState]] internal slot is UNDEFINED,
    return FALSE.

4.  Return TRUE.

RejectPromise ( promise, reason)

When the RejectPromise abstract operation is called with arguments
_promise_ and _reason_ the following steps are taken:

1.  Assert: the value of _promise_'s [[PromiseState]] internal slot is
    "PENDING".

2.  Let _reactions_ be the value of _promise_'s
    [[PromiseRejectReactions]] internal slot.

3.  Set the value of _promise_'s [[PromiseResult]] internal slot to
    _reason_.

4.  Set the value of _promise_'s [[PromiseFulfillReactions]] internal
    slot to UNDEFINED.

5.  Set the value of _promise_'s [[PromiseRejectReactions]] internal
    slot to UNDEFINED.

6.  Set the value of _promise_'s [[PromiseState]] internal slot to
    "REJECTED".

7.  Return TriggerPromiseReactions(_reactions_, _reason_).

TriggerPromiseReactions ( reactions, argument )

The abstract operation TriggerPromiseReactions takes a collection of
functions to trigger in the next Job, and calls them, passing each the
given argument. Typically, these reactions will modify a
previously-returned promise, possibly calling in to a user-supplied
handler before doing so.

1.  Repeat for each _reaction_ in _reactions_, in original insertion
    order

    a.  Perform EnqueueJob("PROMISEJOBS", PromiseReactionJob,
        (_reaction_, _argument_)).

2.  Return UNDEFINED.

Promise Jobs

PromiseReactionJob ( reaction, argument )

The job PromiseReactionJob with parameters _reaction_ and _argument_
applies the appropriate handler to the incoming value, and uses the
handler's return value to resolve or reject the derived promise
associated with that handler.

1.  Assert: _reaction_ is a PromiseReaction Record.

2.  Let _promiseCapability_ be _reaction_.[[Capabilities]].

3.  Let _handler_ be _reaction_.[[Handler]].

4.  If _handler_ is "IDENTITY", then let _handlerResult_ be
    NormalCompletion(_argument_).

5.  Else If _handler_ is "THROWER", then let _handlerResult_ be
    Completion{[[type]]: throw, [[value]]: _argument_, [[target]]:
    empty}.

6.  Else, let _handlerResult_ be the result of calling the [[Call]]
    internal method of _handler_ passing UNDEFINED as _thisArgument_ and
    (_argument_) as _argumentsList_.

7.  If _handlerResult_ is an abrupt completion, then

    a.  Let _status_ be the result of calling the [[Call]] internal
        method of _promiseCapability_.[[Reject]] passing UNDEFINED as
        _thisArgument_ and (_handlerResult_.[[value]]) as
        _argumentsList_.

    b.  NextJob _status_.

8.  Let _handlerResult_ be _handlerResult_.[[value]].

9.  Let _status_ be the result of calling the [[Call]] internal method
    of _promiseCapability_.[[Resolve]] passing UNDEFINED as
    _thisArgument_ and (_handlerResult_) as _argumentsList._

10. NextJob _status_.

PromiseResolveThenableJob ( promiseToResolve, thenable, then)

The job PromiseResolveThenableJob with parameters _promiseToResolve_,
_thenable_, and _then_ performs the following steps:

1.  Let _resolvingFunctions_ be CreateResolvingFunctions(_promise_).

2.  Let _thenCallResult_ be the result of calling the [[Call]] internal
    method of _then_ passing _thenable_ as the _thisArgument_ and
    (_resolvingFunctions_.[[Resolve]], _resolvingFunctions_.[[Reject]])
    as _argumentsList_.

3.  If _thenCallResult_ is an abrupt completion,

    a.  Let _status_ be the result of calling the [[Call]] internal
        method of _resolvingFunctions_.[[Reject]] passing UNDEFINED as
        the _thisArgument_ and (_thenCallResult_.[[value]]) as
        _argumentsList._

    b.  NextJob _status._

4.  NextJob _thenCallResult_.

NOTE This Job uses the supplied thenable and its THEN method to resolve
the given promise. This process must take place as a Job to ensure that
the evaluation of the THEN method occurs after evaluation of any
surrounding code has completed.

The Promise Constructor

The Promise constructor is the %Promise% intrinsic object and the
initial value of the PROMISE property of the global object. When PROMISE
is called as a function rather than as a constructor, it initializes its
THIS value with the internal state necessary to support the
PROMISE.PROTOTYPE methods.

The PROMISE constructor is designed to be subclassable. It may be used
as the value in an EXTENDS clause of a class definition. Subclass
constructors that intend to inherit the specified PROMISE behaviour must
include a SUPER call to PROMISE.

Promise ( executor )

When the PROMISE function is called with argument _executor_ the
following steps are taken:

1.  Let _promise_ be the THIS value.

2.  If Type(_promise_) is not Object, then throw a TYPEERROR exception.

3.  If _promise_ does not have a [[PromiseState]] internal slot, then
    throw a TYPEERROR exception.

4.  If _promise_'s [[PromiseState]] internal slot is not UNDEFINED, then
    throw a TYPEERROR exception.

5.  If IsCallable(_executor_) is FALSE, then throw a TYPEERROR
    exception.

6.  Return InitializePromise(_promise_, _executor_).

NOTE The _executor_ argument must be a function object. It is called for
initiating and reporting completion of the possibly deferred action
represented by this Promise object. The executor is called with two
arguments: _resolve_ and _reject_. These are functions that may be used
by the _executor_ function to report eventual completion or failure of
the deferred computation. Returning from the executor function does not
mean that the deferred action has been completed but only that the
request to eventually perform the deferred action has been accepted.

The _resolve_ function that is passed to an _executor_ function accepts
a single argument. The _executor_ code may eventually call the _resolve_
function to indicate that it wishes to resolve the associated Promise
object. The argument passed to the _resolve_ function represents the
eventual value of the deferred action and can be either the actual
fulfillment value or another Promise object which will provide the value
if it is fulfilled.

The _reject_ function that is passed to an _executor_ function accepts a
single argument. The _executor_ code may eventually call the _reject_
function to indicate that the associated Promise is rejected and will
never be fulfilled. The argument passed to the _reject_ function is used
as the rejection value of the promise. Typically it will be an ERROR
object.

The resolve and reject functions passed to an _executor_ function by the
Promise constructor have the capability to actually resolve and reject
the associated promise. Subclasses may have different constructor
behaviour that passes in customized values for resolve and reject.

InitializePromise ( promise, executor )

The abstract operation InitializePromise initializes a newly allocated
_promise_ object using an _executor_ function.

1.  Assert: _promise_ has a [[PromiseState]] internal slot and its value
    is UNDEFINED.

2.  Assert: IsCallable(_executor_) is TRUE.

3.  Set _promise_'s [[PromiseState]] internal slot to "PENDING".

4.  Set _promise_'s [[PromiseFulfillReactions]] internal slot to a new
    empty List.

5.  Set _promise_'s [[PromiseRejectReactions]] internal slot to a new
    empty List.

6.  Let _resolvingFunctions_ be CreateResolvingFunctions(_promise_).

7.  Let _completion_ be the result of calling the [[Call]] internal
    method of _executor_ with UNDEFINED as _thisArgument_ and
    (_resolvingFunctions_.[[Resolve]], _resolvingFunctions_.[[Reject]])
    as _argumentsList_.

8.  If _completion_ is an abrupt completion, then

    a.  Let _status_ be the result of calling the [[Call]] internal
        method of _resolvingFunctions_.[[Reject]] with UNDEFINED as
        _thisArgument_ and (_completion_.[[value]]) as _argumentsList_.

    b.  ReturnIfAbrupt(_status_).

9.  Return _promise_.

new Promise ( ... argumentsList )

When PROMISE is called as part of a NEW expression it is a constructor:
it initializes a newly created object.

PROMISE called as part of a new expression with argument list
_argumentsList_ performs the following steps:

1.  Let _F_ be the Promise function object on which the NEW operator was
    applied.

2.  Let _argumentsList_ be the _argumentsList_ argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return Construct(_F_, _argumentsList_).

If Promise is implemented as an ECMAScript function object, its
[[Construct]] internal method will perform the above steps.

Properties of the Promise Constructor

The value of the [[Prototype]] internal slot of the PROMISE constructor
is the FUNCTION prototype object (19.2.3).

Besides the LENGTH property (whose value is 1), the Promise constructor
has the following properties:

Promise.all ( iterable ) 

The ALL function returns a new promise which is fulfilled with an array
of fulfillment values for the passed promises, or rejects with the
reason of the first passed promise that rejects. It resoves all elements
of the passed iterable to promises as it runs this algorithm.

1.  Let _C_ be the THIS value.

2.  Let _promiseCapability_ be NewPromiseCapability(_C_).

3.  ReturnIfAbrupt(_promiseCapability_).

4.  Let _iterator_ be GetIterator(_iterable_).

5.  IfAbruptRejectPromise(_iterator_, _promiseCapability_).

6.  Let _values_ be ArrayCreate(0).

7.  Let _remainingElementsCount_ be a new Record { [[value]]: 1 }.

8.  Let _index_ be 0.

9.  Repeat

    a.  Let _next_ be IteratorStep(_iterator_).

    b.  IfAbruptRejectPromise(_next_, _promiseCapability_).

    c.  If _next_ is FALSE,

        i.  Set _remainingElementsCount_.[[value]] to
            _remainingElementsCount_.[[value]] - 1.

        ii. If _remainingElementsCount_.[[value]] is 0,

            1.  Let _resolveResult_ be the result of calling the
                [[Call]] internal method of
                _promiseCapability_.[[Resolve]] with UNDEFINED as
                _thisArgument_ and (_values_) as _argumentsList_.

            2.  ReturnIfAbrupt(_resolveResult_).

        iii. Return _promiseCapability_.[[Promise]].

    d.  Let _nextValue_ be IteratorValue(_next_).

    e.  IfAbruptRejectPromise(_nextValue_, _promiseCapability_).

    f.  Let _nextPromise_ be Invoke(_C_, "RESOLVE", (_nextValue_)).

    g.  IfAbruptRejectPromise(_nextPromise_, _promiseCapability_).

    h.  Let _resolveElement_ be a new built-in function object as
        defined in Promise.all Resolve Element Functions.

    i.  Set the [[AlreadyCalled]] internal slot of _resolveElement_ to a
        new Record { [[value]]: FALSE }..

    j.  Set the [[Index]] internal slot of _resolveElement_ to _index_.

    k.  Set the [[Values]] internal slot of _resolveElement_ to
        _values_.

    l.  Set the [[Capabilities]] internal slot of _resolveElement_ to
        _promiseCapability_.

    m.  Set the [[RemainingElements]] internal slot of _resolveElement_
        to _remainingElementsCount_.

    n.  Set _remainingElementsCount_.[[value]] to
        _remainingElementsCount_.[[value]] + 1.

    o.  Let _result_ be Invoke(_nextPromise_, "THEN", (_resolveElement_,
        _promiseCapability_.[[Reject]])).

    p.  IfAbruptRejectPromise(_result_, _promiseCapability_).

    q.  Set _index_ to _index_ + 1.

Note: The ALL function requires its THIS value to be a constructor
function that supports the parameter conventions of the PROMISE
constructor.

Promise.all Resolve Element Functions

A Promise.all resolve element function is an anonymous built-in function
that is used to resolve a specific Promise.all element. Each Promise.all
resolve element function has [[Index]], [[Values]], [[Capabilities]],
[[RemainingElements]], and [[AlreadyCalled]] internal slots.

When a Promise.all resolve element function _F_ is called with argument
_x_, the following steps are taken:

1.  Let _alreadyCalled_ be the value of _F_'s [[AlreadyCalled]] internal
    slot.

2.  If _alreadyCalled_.[[value]] is TRUE, then return UNDEFINED.

3.  Set _alreadyCalled_.[[value]] to TRUE.

4.  Let _index_ be the value of _F_'s [[Index]] internal slot.

5.  Let _values_ be the value of _F_'s [[Values]] internal slot.

6.  Let _promiseCapability_ be the value of _F_'s [[Capabilities]]
    internal slot.

7.  Let _remainingElementsCount_ be the value of _F_'s
    [[RemainingElements]] internal slot.

8.  Let _result_ be CreateDataProperty(_values_, ToString(_index_),
    _x_).

9.  IfAbruptRejectPromise(_result_, _promiseCapability_).

10. Set _remainingElementsCount_.[[value]] to
    _remainingElementsCount_.[[value]] - 1.

11. If _remainingElementsCount_.[[value]] is 0,

    a.  Return the result of calling the [[Call]] internal method of
        _promiseCapability_.[[Resolve]] with UNDEFINED as _thisArgument_
        and (_values_) as _argumentsList_.

12. Return UNDEFINED.

Promise.prototype

The initial value of PROMISE.PROTOTYPE is the Promise prototype object
(25.4.4.6.1).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Promise.race ( iterable )

The RACE function returns a new promise which is settled in the same way
as the first passed promise to settle. It resolves all elements of the
passed iterable to promises as it runs this algorithm.

1.  Let _C_ be the THIS value.

2.  Let _promiseCapability_ be NewPromiseCapability(_C_).

3.  ReturnIfAbrupt(_promiseCapability_).

4.  Let _iterator_ be GetIterator(_iterable_).

5.  IfAbruptRejectPromise(_iterator_, _promiseCapability_).

6.  Repeat

    a.  Let _next_ be IteratorStep(_iterator_).

    b.  IfAbruptRejectPromise(_next_, _promiseCapability_).

    c.  If _next_ is FALSE, return _promiseCapability_.[[Promise]].

    d.  Let _nextValue_ be IteratorValue(_next_).

    e.  IfAbruptRejectPromise(_nextValue_, _promiseCapability_).

    f.  Let _nextPromise_ be Invoke(_C_, "RESOLVE", (_nextValue_)).

    g.  IfAbruptRejectPromise(_nextPromise_, _promiseCapability_).

    h.  Let _result_ be Invoke(_nextPromise_, "THEN",
        (_promiseCapability_.[[Resolve]],
        _promiseCapability_.[[Reject]])).

    i.  IfAbruptRejectPromise(_result_, _promiseCapability_).

NOTE 1 If the _iterable_ argument is empty or if none of the promises in
_iterable_ ever settle then the pending promise returned by this method
will never be settled

NOTE 2 The RACE function expects its THIS value to be a constructor
function that supports the parameter conventions of the PROMISE
constructor. It also expects that its THIS value provides a RESOLVE
method.

Promise.reject ( r )

The REJECT function returns a new promise rejected with the passed
argument.

1.  Let _C_ be the THIS value.

2.  Let _promiseCapability_ be NewPromiseCapability(_C_).

3.  ReturnIfAbrupt(_promiseCapability_).

4.  Let _rejectResult_ be the result of calling the [[Call]] internal
    method of _promiseCapability_.[[Reject]] with UNDEFINED as
    _thisArgument_ and (_r_) as _argumentsList_.

5.  ReturnIfAbrupt(_rejectResult_).

6.  Return _promiseCapability_.[[Promise]].

NOTE The REJECT function requires that its THIS value to be a
constructor function that supports the parameter conventions of the
PROMISE constructor.

Promise.resolve ( x )

The RESOLVE function returns either a new promise resolved with the
passed argument, or the argument itself if the argument a promise
produced by this construtor.

1.  Let _C_ be the THIS value.

2.  If IsPromise(_x_) is TRUE,

    a.  Let _constructor_ be the value of _x_'s [[PromiseConstructor]]
        internal slot.

    b.  If SameValue(_constructor_, _C_) is TRUE, return _x_.

3.  Let _promiseCapability_ be NewPromiseCapability(_C_).

4.  ReturnIfAbrupt(_promiseCapability_).

5.  Let _resolveResult_ be the result of calling the [[Call]] internal
    method of _promiseCapability_.[[Resolve]] with UNDEFINED as
    _thisArgument_ and (_x_) as _argumentsList_.

6.  ReturnIfAbrupt(_resolveResult_).

7.  Return _promiseCapability_.[[Promise]].

NOTE The RESOLVE function requires that its THIS value to be a
constructor function that supports the parameter conventions of the
PROMISE constructor.

Promise [ @@create ] ( )

The @@create method of a Promise function object _F_ performs the
following steps:

1.  Let _F_ be the THIS value.

2.  Return AllocatePromise(_F_).

The value of the NAME property of this function is "[SYMBOL.CREATE]".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

AllocatePromise ( constructor ) 

The abstract operation AllocatePromise allocates a new promise object
using the _constructor_ argument.

1.  Let _obj_ be OrdinaryCreateFromConstructor(_constructor_,
    "%PROMISEPROTOTYPE%", ([[PromiseState]], [[PromiseConstructor]],
    [[PromiseResult]], [[PromiseFulfillReactions]],
    [[PromiseRejectReactions]]) ).

2.  Set the value of _obj’s_ [[PromiseConstructor]] internal slot to
    _constructor_.

3.  Return _obj_.

Properties of the Promise Prototype Object

The value of the [[Prototype]] internal slot of the Promise prototype
object is the standard built-in Object prototype object (19.1.3). The
Promise prototype object is an ordinary object. It does not have a
[[PromiseState]] internal slot or any of the other internal slots of
Promise instances.

Promise.prototype.catch ( onRejected )

When the CATCH method is called with argument _onRejected_ the following
steps are taken:

1.  Let _promise_ be the THIS value.

2.  Return Invoke(_promise_, "THEN", (UNDEFINED, _onRejected_)).

Promise.prototype.constructor

The initial value of PROMISE.PROTOTYPE.CONSTRUCTOR is the standard
built-in Promise constructor.

Promise.prototype.then ( onFulfilled , onRejected )

When the THEN method is called with arguments _onFulfilled_ and
_onRejected_ the following steps are taken:

1.  Let _promise_ be the THIS value.

2.  If IsPromise(_promise_) is FALSE, throw a TYPEERROR exception.

3.  If IsCallable(_onFulfilled_) is FALSE, then

    a.  Let _onFulfilled_ be "IDENTITY".

4.  If IsCallable(_onRejected_) is FALSE, then

    a.  Let _onRejected_ be "THROWER".

5.  6.  Let _C_ be Get(_promise_, "CONSTRUCTOR").

7.  ReturnIfAbrupt(_C_).

8.  Let _promiseCapability_ be NewPromiseCapability(_C_).

9.  ReturnIfAbrupt(_promiseCapability_).

10. Let _fulfillReaction_ be the PromiseReaction { [[Capabilities]]:
    _promiseCapability_, [[Handler]]: _onFulfilled_ }.

11. Let _rejectReaction_ be the PromiseReaction { [[Capabilities]]:
    _promiseCapability_, [[Handler]]: _onRejected_}.

12. If the value of _promise_'s [[PromiseState]] internal slot is
    "pending",

    a.  Append _fulfillReaction_ as the last element of the List that is
        the value of _promise_'s [[PromiseFulfillReactions]] internal
        slot.

    b.  Append _rejectReaction_ as the last element of the List that is
        the value of _promise_'s [[PromiseRejectReactions]] internal
        slot.

13. Else if the value of _promise_'s [[PromiseState]] internal slot is
    "FULFILLED",

    a.  Let _value_ be the value of _promise_'s [[PromiseResult]]
        internal slot.

    b.  Perform EnqueueJob("PROMISEJOBS", PromiseReactionJob,
        (_fulfillReaction_, _value_)).

14. Else if the value of _promise_'s [[PromiseState]] internal slot is
    "REJECTED",

    a.  Let _reason_ be the value of _promise_'s [[PromiseResult]]
        internal slot.

    b.  Perform EnqueueJob("PROMISEJOBS", PromiseReactionJob,
        (_rejectReaction_, _reason_)).

15. Return _promiseCapability_.[[Promise]].

1.  

1.  2.  3.  4.  a.  b.  

5.  6.  7.  8.  9.  10. a.  

11. 

1.  1.  Promise.prototype [ @@toStringTag ]

The initial value of the @@toStringTag property is the string value
"PROMISE".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Properties of Promise Instances

Promise instances are ordinary objects that inherit properties from the
Promise prototype object (the intrinsic, %PromisePrototype%). Promise
instances are initially created with the internal slots described in
Table 51.

Table 51 — Internal Slots of Promise Instances

  ----------------------------- --------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  INTERNAL SLOT                 DESCRIPTION
  [[PromiseState]]                A string value that governs how a promise will react to incoming calls to its THEN method. The possible values are: UNDEFINED, "PENDING", "FULFILLED", and "REJECTED".
  [[PromiseConstructor]]          The function object that was used to construct this promise. Checked by the RESOLVE method of the PROMISE constructor.
  [[PromiseResult]]               The value with which the promise has been fulfilled or rejected, if any. Only meaningful if [[PromiseState]] is not "PENDING".
  [[PromiseFulfillReactions]]     A List of PromiseReaction records to be processed when/if the promise transitions from the "PENDING" state to the"FULFILLED" state.
  [[PromiseRejectReactions]]      A List of PromiseReaction records to be processed when/if the promise transitions from the "PENDING" state to the"REJECTED" state.
  ----------------------------- --------------------------------------------------------------------------------------------------------------------------------------------------------------------------



REFLECTION 


The Reflect Object

The Reflect object is a single ordinary object.

The value of the [[Prototype]] internal slot of the Reflect object is
the standard built-in Object prototype object (19.1.3).

The Reflect object is not a function object. It does not have a
[[Construct]] internal method; it is not possible to use the Reflect
object as a constructor with the NEW operator. The Reflect object also
does not have a [[Call]] internal method; it is not possible to invoke
the Reflect object as a function.

Reflect.apply ( target, thisArgument, argumentsList )

When the APPLY function is called with arguments _target_,
_thisArgument_, and _argumentsList_ the following steps are taken:

1.  2.  3.  If IsCallable(_target_) is FALSE, then throw a TYPEERROR
    exception.

4.  Let _args_ be CreateListFromArrayLike(_argumentsList_).

5.  ReturnIfAbrupt(_args_).

6.  Perform the PrepareForTailCall abstract operation.

7.  Return the result of calling the [[Call]] internal method of
    _target_ with arguments _thisArgument_ and _args_.

Reflect.construct ( target, argumentsList )

When the CONSTRUCT function is called with arguments _target_ and
_argumentsList_ the following steps are taken:

1.  2.  3.  If IsConstructor(_target_) is FALSE, then throw a TYPEERROR
    exception.

4.  Let _args_ be CreateListFromArrayLike(_argumentsList_).

5.  ReturnIfAbrupt(_args_).

6.  Return the result of calling the [[Construct]] internal method of
    _target_ with argument _args_.

Reflect.defineProperty ( target, propertyKey, attributes )

When the DEFINEPROPERTY function is called with arguments _target_,
_propertyKey_, and _attributes_ the following steps are taken:

1.  Let _obj_ be ToObject(_target_).

2.  ReturnIfAbrupt(_obj_).

3.  Let _key_ be ToPropertyKey(_propertyKey_).

4.  ReturnIfAbrupt(_key_).

5.  Let _desc_ be the result of calling ToPropertyDescriptor with
    _attributes_ as the argument.

6.  ReturnIfAbrupt(_desc_).

7.  Return the result of calling the [[DefineOwnProperty]] internal
    method of _obj_ with arguments _key_, and _desc_.

Reflect.deleteProperty ( target, propertyKey )

When the DELETEPROPERTY function is called with arguments _target_ and
_propertyKey_, the following steps are taken:

1.  Let _obj_ be ToObject(_target_).

2.  ReturnIfAbrupt(_obj_).

3.  Let _key_ be ToPropertyKey(_propertyKey_).

4.  ReturnIfAbrupt(_key_).

5.  Return the result of calling the [[Delete]] internal method of _obj
    with argument _key_.

Reflect.enumerate ( target )

When the ENUMERATE function is called with argument _target_ the
following steps are taken:

1.  Let _obj_ be ToObject(_target_).

2.  ReturnIfAbrupt(_obj_).

3.  Let _iterator_ be the result of calling the [[Enumerate]] internal
    method of _obj_.

4.  Return _iterator_.

Reflect.get ( target, propertyKey [ , receiver ])

When the GET function is called with arguments _target_, _propertyKey_,
and _receiver_ the following steps are taken:

1.  Let _obj_ be ToObject(_target_).

2.  ReturnIfAbrupt(_obj_).

3.  Let _key_ be ToPropertyKey(_propertyKey_).

4.  ReturnIfAbrupt(_key_).

5.  If _receiver_ is not present, then

    a.  Let _receiver_ be _target_.

6.  Return the result of calling the [[Get]] internal method of _obj
    with arguments _key_, and _receiver_.

Reflect.getOwnPropertyDescriptor ( target, propertyKey )

When the GETOWNPROPERTYDESCRIPTOR function is called with arguments
_target_ and _propertyKey_, the following steps are taken:

1.  Let _obj_ be ToObject(_target_).

2.  ReturnIfAbrupt(_obj_).

3.  Let _key_ be ToPropertyKey(_propertyKey_).

4.  ReturnIfAbrupt(_key_).

5.  Let _desc_ be the result of calling the [[GetOwnProperty]] internal
    method of _obj_ with argument _key_.

6.  ReturnIfAbrupt(_desc_).

7.  Return the result of calling FromPropertyDescriptor(_desc_).

Reflect.getPrototypeOf ( target )

When the GETPROTOTYPEOF function is called with argument _target_ the
following steps are taken:

1.  Let _obj_ be ToObject(_target_).

2.  ReturnIfAbrupt(_obj_).

3.  Return the result of calling the [[GetPrototypeOf]] internal method
    of _obj_.

Reflect.has ( target, propertyKey )

When the HAS function is called with arguments _target_ and
_propertyKey_, the following steps are taken:

1.  Let _obj_ be ToObject(_target_).

2.  ReturnIfAbrupt(_obj_).

3.  Let _key_ be ToPropertyKey(_propertyKey_).

4.  ReturnIfAbrupt(_key_).

5.  Return the result of calling the [[HasProperty]] internal method of
    _obj_ with argument _key_.

1.  2.  3.  4.  5.  

Reflect.isExtensible (target)

When the ISEXTENSIBLE function is called with argument _target_ the
following steps are taken:

1.  Let _obj_ be ToObject(_target_).

2.  ReturnIfAbrupt(_obj_).

3.  Return the result of calling the [[IsExtensible]] internal method of
    _obj_.

Reflect.ownKeys ( target )

When the OWNKEYS function is called with argument _target_ the following
steps are taken:

1.  Let _obj_ be ToObject(_target_).

2.  ReturnIfAbrupt(_obj_).

3.  Return the result of calling the [[OwnPropertyKeys]] internal method
    of _obj_.

Reflect.preventExtensions ( target )

When the PREVENTEXTENSIONS function is called with argument _target_,
the following steps are taken:

1.  Let _obj_ be ToObject(_target_).

2.  ReturnIfAbrupt(_obj_).

3.  Return the result of calling the [[PreventExtensions]] internal
    method of _obj_.

Reflect.set ( target, propertyKey, V [ , receiver ] )

When the SET function is called with arguments _target_, _V_,
_propertyKey_, and _receiver_ the following steps are taken:

1.  Let _obj_ be ToObject(_target_).

2.  ReturnIfAbrupt(_obj_).

3.  Let _key_ be ToPropertyKey(_propertyKey_).

4.  ReturnIfAbrupt(_key_).

5.  If _receiver_ is not present, then

    a.  Let _receiver_ be _target_.

6.  Return the result of calling the [[Set]] internal method of _obj
    with arguments _key_, _V_, and _receiver_.

Reflect.setPrototypeOf ( target, proto )

When the SETPROTOTYPEOF function is called with arguments _target_ and
_propertyKey_, the following steps are taken:

1.  Let _obj_ be ToObject(_target_).

2.  ReturnIfAbrupt(_obj_).

3.  If Type(_proto_) is not Object and _proto_ is not NULL, then throw a
    TYPEERROR exception

4.  Return the result of calling the [[SetPrototypeOf]] internal method
    of _obj_ with argument _proto_.


Realm Objects

The Reflect.Realm Constructor

The initial value of REFLECT.REALM is the %Realm% intrinsic object.
REFLECT.REALM is the constructor for Realm objects. When REFLECT.REALM
is called as a function rather than as a constructor, it initializes its
THIS value with the internal state necessary to support the
REFLECT.REALM.PROTOTYPE built-in methods.

The REFLECT.REALM constructor is designed to be subclassable. It may be
used as the value in an EXTENDS clause of a class definition. Subclass
constructors that intend to inherit the specified Realm behaviour must
include a SUPER call to REFLECT.REALM.

Reflect.Realm ( [ target , handler ] )

When the REFLECT.REALM function is called with optional arguments
_target_ and _handler_ the following steps are taken:

1.  Let _realmObject_ be the THIS value.

2.  If Type(_realmObject_) is not Object or _realmObject_ does not have
    a [[RealmRecord]] internal slot, throw a TYPEERROR exception.

3.  4.  If the value of _realmObject_’s [[RealmRecord]] internal slot is
    not UNDEFINED, throw a TYPEERROR exception.

5.  6.  7.  8.  9.  10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 24. If
    any arguments were passed to this function, then

    a.  Let _newGlobal_ be ProxyCreate(_target_, _handler_).

    b.  ReturnIfAbrupt(_newGlobal_)

25. Else,

    a.  b.  Let _newGlobal_ be UNDEFINED.

26. Let _realmRec_ be CreateRealm().

27. Perform SetRealmGlobalObj(_realmRec_, _newGlobal_).

28. 29. 30. 31. Let _translate_ be GetMethod(_realmObject_,
    "DIRECTEVAL").

32. ReturnIfAbrupt(_translate_).

33. Let _fallback_ be GetMethod(_realmObject_, "NONEVAL").

34. ReturnIfAbrupt(_fallback_).

35. Let _indirectEval_ be GetMethod(_realmObject_, "INDIRECTEVAL").

36. ReturnIfAbrupt(_indirectEval_).

37. Set _realmRec_.[[directEvalTranslate]] to _translate_.

38. Set _realmRec_.[[nonEvalFallback]] to _fallback_.

39. Set _realmRec_.[[indirectEval]] to _indirectEval_.

40. NOTE the following step ensures that this function was not
    reentrantly applied to _realmObject_ during the above steps.

41. If the value of _realmObject_’s [[RealmRecord]] internal slot is not
    UNDEFINED, throw a TYPEERROR exception.

42. 43. Set _realmObject_’s [[RealmRecord]] internal slot to _realmRec_.

44. Let _initGlobal_ be GetMethod(_realmObject_, "INITGLOBAL").

45. ReturnIfAbrupt(_initGlobal_).

46. If _initGlobal_ is not UNDEFINED, then

    a.  b.  Let _status_ be the result of calling the [[Call]] internal
        method of _initGlobal_, passing _realmObject_ as the THIS value
        and no arguments.

    c.  ReturnIfAbrupt(_status_).

47. Else,

    a.  Let _status_ be SetDefaultGlobalBindings(_realmRec_).

    b.  ReturnIfAbrupt(_status_).

48. Return _realmObject_.

new Reflect.Realm ( ...argumentsList )

When REFLECT.REALM is called as part of a NEW expression it is a
constructor: it initializes a newly created object. It performs the
following steps:

1.  Let _F_ be the %Realm% function object on which the NEW operator was
    applied.

2.  Let _argumentsList_ be the _argumentsList_ argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of Construct(_F_, _argumentsList_).

If REFLECT.REALM is implemented as an ECMAScript function object, its
[[Construct]] internal method will perform the above steps.

Properties of the Reflect.Realm Constructor

The value of the [[Prototype]] internal slot of the REFLECT.REALM
constructor is the Function prototype object (19.2.3).

Besides the LENGTH property (whose value is 0), the REFLECT.REALM
constructor has the following properties:

Reflect.Realm.prototype

The initial value of REFLECT.REALM.PROTOTYPE is the intrinsic
%RealmPrototype% object (26.2.3).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Reflect.Realm [ @@create ] ( )

The @@create method of a REFLECT.REALM function object _F_ performs the
following steps:

1.  Let _F_ be the THIS value.

2.  Let _obj_ be the result of calling
    OrdinaryCreateFromConstructor(_F_, "%REALMPROTOTYPE%", (
    [[RealmRecord]])).

3.  Return _obj_.

The value of the NAME property of this function is "[SYMBOL.CREATE]".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Properties of the Reflect.Realm Prototype Object

The value of the [[Prototype]] internal slot of the REFLECT.REALM
prototype object is the standard built-in Object prototype object
(19.1.3). The REFLECT.REALM prototype object is an ordinary object. It
does not have a [[RealmRecord]] internal slot.

Reflect.Realm.prototype.constructor

The initial value of REFLECT.REALM.PROTOTYPE.CONSTRUCTOR is the built-in
%Realm% constructor.

Reflect.Realm.prototype.eval ( source )

When REFLECT.REALM.PROTOTYPE.EVAL is called with argument _source_ it
performs the following steps:

1.  Let _realmObject_ be the THIS value.

2.  If Type(_realmObject_) is not Object or _realmObject_ does not have
    a [[RealmRecord]] internal slot, throw a TYPEERROR exception.

3.  Let _realm_ be the value of _realmObject_’s [[RealmRecord]] internal
    slot.

4.  If _realm_ is UNDEFINED, then throw a TYPEERROR exception.

5.  Return the result of IndirectEval(_realm,_ _source_).

get Reflect.Realm.prototype.global

REFLECT.REALM.PROTOTYPE.GLOBAL is an accessor property whose set
accessor function is UNDEFINED. Its get accessor function performs the
following steps:

1.  Let _realmObject_ be the THIS value.

2.  If Type(_realmObject_) is not Object or _realmObject_ does not have
    a [[RealmRecord]] internal slot, throw a TYPEERROR exception.

3.  Let _realm_ be the value of _realmObject_’s [[RealmRecord]] internal
    slot.

4.  If _realm_ is UNDEFINED, then throw a TYPEERROR exception.

5.  Return _realm_.[[globalThis]].

get Reflect.Realm.prototype.intrinsics

REFLECT.REALM.PROTOTYPE.INTRINSICS is an accessor property whose set
accessor function is UNDEFINED. Its get accessor function performs the
following steps:

1.  Let _realmObject_ be the THIS value.

2.  If Type(_realmObject_) is not Object or _realmObject_ does not have
    a [[RealmRecord]] internal slot, throw a TYPEERROR exception.

3.  Let _realm_ be the value of _realmObject_’s [[RealmRecord]] internal
    slot.

4.  If _realm_ is UNDEFINED, then throw a TYPEERROR exception.

5.  Let _table_ be ObjectCreate(%ObjectPrototype%).

6.  Let _intrinsics_ be _realm’s_ [[instrinsics]] internal slot.

7.  For each _name_ in the “Intrinsic Key” column of Table 7, in row
    order do

    a.  b.  Let _object_ be the value of the field of _intrinsics_ whose
        name is _name_.

    c.  Perform CreateDataProperty(_table_, _key_, _object_).

8.  Return _table_.

get Reflect.Realm.prototype.stdlib

REFLECT.REALM.PROTOTYPE.STDLIB is an accessor property whose set
accessor function is UNDEFINED. Its get accessor function performs the
following steps:

1.  Let _realmObject_ be the THIS value.

2.  If Type(_realmObject_) is not Object or _realmObject_ does not have
    a [[RealmRecord]] internal slot, throw a TYPEERROR exception.

3.  Let _realm_ be the value of _realmObject_’s [[RealmRecord]] internal
    slot.

4.  If _realm_ is UNDEFINED, then throw a TYPEERROR exception.

5.  Let _props_ be ObjectCreate(%ObjectPrototype%).

6.  For each property of the Global Object specified in clause 18, do

    a.  Let _name_ be the string value of the property name.

    b.  Let _desc_ be the fully populated data property descriptor for
        the property containing the specified attributes for the
        property. For properties whose values are functions, the value
        of the [[Value]] attribute is the corresponding intrinsic
        function object for _realm_.

    c.  Let _status_ be DefinePropertyOrThrow(_props_, _name_, _desc_).

    d.  ReturnIfAbrupt(_status_).

7.  Return _props_.

NOTE The object returned is suitable for use as the second argument to
Object.defineProperties. A Realm’s global object can be initialized with
its clause 18 standard values using an expression such as:

OBJECT.DEFINEPROPERTIES(NEWREALM.GLOBAL, NEWREALM.STDLIB);

Reflect.Realm.prototype [ @@toStringTag ]

The initial value of the @@toStringTag property is the string value
"REFLECT.REALM".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Realm Subclass Extension Properties

The following properties are intended to be over-ridden by subclasses of
REFLECT.REALM.

Reflect.Realm.prototype.directEval ( source )

When REFLECT.REALM.PROTOTYPE.DIRECTEVAL is called with argument _source_
it performs the following steps:

1.  2.  3.  4.  5.  Return _source_.

NOTE If an apparent direct eval call had multiple arguments, those
arguments are all passed to this function.

Reflect.Realm.prototype.indirectEval ( source )

When REFLECT.REALM.PROTOTYPE.INDIRECTEVAL is called with argument
_source_ it performs the following steps:

1.  Let _realmObject_ be the THIS value.

2.  If Type(_realmObject_) is not Object or _realmObject_ does not have
    a [[RealmRecord]] internal slot, throw a TYPEERROR exception.

3.  Let _realm_ be the value of _realmObject_’s [[RealmRecord]] internal
    slot.

4.  If _realm_ is UNDEFINED, then throw a TYPEERROR exception.

5.  Return IndirectEval(_realm,_ _source_).

Reflect.Realm.prototype.initGlobal ( )

When REFLECT.REALM.PROTOTYPE.INITGLOBAL is called it performs the
following steps:

1.  Let _realmObject_ be the THIS value.

2.  If Type(_realmObject_) is not Object or _realmObject_ does not have
    a [[RealmRecord]] internal slot, throw a TYPEERROR exception.

3.  Let _realmRec_ be the value of _realmObject_’s [[RealmRecord]]
    internal slot.

4.  If _realmRec_ is UNDEFINED, then throw a TYPEERROR exception.

1.  2.  a.  b.  c.  d.  

1.  Return SetDefaultGlobalBindings(_realmRec_).

Reflect.Realm.prototype.nonEval (function, thisValue, argumentsList )

When REFLECT.REALM.PROTOTYPE.NONEVAL is called with arguments
_function_, _thisValue_, and _argumentsList_ it performs the following
steps:

1.  2.  3.  4.  5.  6.  7.  If IsCallable(_function_) is FALSE, then
    throw a TYPEERROR exception.

8.  Let _args_ be CreateListFromArrayLike(_argumentsList_).

9.  ReturnIfAbrupt(_args_).

10. Perform PrepareForTailCall( ).

11. Return the result of calling the [[Call]] internal method of
    _function_with arguments _thisValue_ and _args_.

12. 

Properties of Reflect.Realm Instances

REFLECT.REALM instances are ordinary objects that inherit properties
from the REFLECT.REALM prototype object. REFLECT.REALM instances each
have a [[RealmRecord]] internal slot.


Loader Objects

Loader objects are able to load the source code of an ECMAScript
_Module_ in the context of a specific Realm.

The Reflect.Loader Constructor

The initialize value of REFLECT.LOADER is the %Loader% intrinsic object.
REFLECT.LOADER is the constructor for Loader objects. When
REFLECT.LOADER is called as a function rather than as a constructor, it
initializes its THIS value with the internal state necessary to support
the REFLECT.LOADER.PROTOTYPE built-in methods.

The REFLECT.LOADER constructor is designed to be subclassable. It may be
used as the value in an EXTENDS clause of a class definition. Subclass
constructors that intend to support the specified Loader behaviour must
include a SUPER call to REFLECT.LOADER.

Reflect.Loader ( [ options ] )

When the Reflect.Loader function is called with optional argument
_options_ the following steps are taken:

1.  Let _loader_ be the THIS value.

2.  If Type(_loader_) is not Object, throw a TYPEERROR exception.

3.  If _loader_ does not have a [[LoaderRecord]] internal slot, throw a
    TYPEERROR exception.

4.  If the value of _loader_’s [[LoaderRecord]] internal slot is not
    UNDEFINED, throw a TYPEERROR exception.

5.  Let _realmObject_ be the result of GetOption(_options_, "REALM").

6.  ReturnIfAbrupt(_realmObject_).

7.  If _realmObject_ is UNDEFINED, let _realm_ be the Realm of the
    running execution context.

8.  Else,

    a.  If Type(_realmObject_) is not Object or _realmObject_ does not
        have a [[RealmRecord]] internal slot, throw a TYPEERROR
        exception.

    b.  Let _realm_ be the value of _realmObject_’s [[RealmRecord]]
        internal slot.

    c.  If _realm_ is UNDEFINED, throw a TYPEERROR exception.

9.  For each _name_ in the List ("NORMALIZE", "LOCATE", "FETCH",
    "TRANSLATE", "INSTANTIATE"),

    a.  Let _hook_ be the result of GetOption(_options_, _name_).

    b.  ReturnIfAbrupt(_hook_).

    c.  If _hook_ is not UNDEFINED,

        i.  If IsCallable(_hook_) is FALSE, throw a TYPEERROR exception.

        ii. Let _result_ be CreateDataPropertyOrThrow(_loader_, _name_,
            _hook_).

        iii. ReturnIfAbrupt(_result_).

10. NOTE the following step ensures that this function was not
    reentrantly applied to _loader_ during the above steps.

11. If the value of _loader_’s [[LoaderRecord]] internal slot is not
    UNDEFINED, throw a TYPEERROR exception.

12. Let _loaderRecord_ be CreateLoaderRecord(_realm_, _loader_).

13. Set _loader_’s [[LoaderRecord]] internal slot to _loaderRecord_.

14. Return _loader_.

new Reflect.Loader ( ...argumentsList )

When REFLECT.LOADER is called as part of a NEW expression it is a
constructor: it initializes a newly created object. It performs the
following steps:

1.  Let _F_ be the REFLECT.LOADER function object on which the NEW
    operator was applied.

2.  Let _argumentsList_ be the _argumentsList_ argument of the
    [[Construct]] internal method that was invoked by the NEW operator.

3.  Return the result of Construct(_F_, _argumentsList_).

If REFLECT.LOADER is implemented as an ECMAScript function object, its
[[Construct]] internal method will perform the above steps.

Properties of the Loader Constructor

The value of the [[Prototype]] internal slot of the REFLECT.LOADER
constructor is the Function prototype object (19.2.3).

Besides the LENGTH property (whose value is 0), the REFLECT.LOADER
constructor has the following properties:

Reflect.Loader.prototype

The initial value of REFLECT.LOADER.PROTOTYPE is the intrinsic
%LoaderPrototype% object (26.3.3).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Reflect.Loader [ @@create ] ( )

The @@create method of a REFLECT.LOADER function object _F_ performs the
following steps:

1.  Let _F_ be the THIS value.

2.  Let _obj_ be the result of calling
    OrdinaryCreateFromConstructor(_F_, "%LOADERPROTOTYPE%",
    ([[LoaderRecord]])).

3.  Return _obj_.

The value of the NAME property of this function is "[SYMBOL.CREATE]".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Properties of the Reflect.Loader Prototype Object

The value of the [[Prototype]] internal slot of the REFLECT.LOADER
prototype object is the standard built-in Object prototype object
(19.1.3). The REFLECT.LOADER prototype object is an ordinary object. It
does not have a [[LoaderRecord]] internal slot.

The phrase "this Loader" within the specification of the following
methods refers to the result returned by performing the abstract
operation thisLoader with the THIS value of the current method
invocation passed as the argument.

The abstract operation thisLoader with argument _value_ performs the
following steps:

1.  If Type(_value_) is Object and _value_ has a [[LoaderRecord]]
    internal slot, then

    a.  Let _r_ be _value_’s [[LoaderRecord]] internal slot.

    b.  If _r_ is not UNDEFINED, then return _value_.

2.  Throw a TYPEERROR exception.

Reflect.Loader.prototype.constructor

The initial value of REFLECT.LOADER.PROTOTYPE.CONSTRUCTOR is the
built-in %Loader% constructor.

Reflect.Loader.prototype.define ( name, source [ , options ] )

The DEFINE method installs a module in this _loader_'s module registry
for _source_ using _name_ as the registry key. The module is not
immediately available. The TRANSLATE and INSTANTIATE hooks are called
asynchronously, and dependencies are loaded asynchronously. DEFINE
returns a Promise object that resolves to UNDEFINED when the new module
and its dependencies are installed in the registry.

When the DEFINE method is called with arguments _name_, _source_, and
optional argument _options_ the following steps are taken:

1.  Let _loader_ be this Loader.

2.  ReturnIfAbrupt(_loader_).

3.  Let _loaderRecord_ be _loader’s_ [[LoaderRecord]] internal slot.

4.  Let _name_ be ToString(_name_).

5.  ReturnIfAbrupt(_name_).

6.  Let _address_ be GetOption(_options_, "ADDRESS").

7.  ReturnIfAbrupt(_address_).

8.  Let _metadata_ be GetOption(_options_, "METADATA").

9.  ReturnIfAbrupt(_metadata_).

10. If _metadata_ is UNDEFINED then let _metadata_ be
    ObjectCreate(%ObjectPrototype%).

11. Let _p_ be PromiseOfStartLoadPartwayThrough("TRANSLATE",
    _loaderRecord_, _name_, _metadata_, _source_, _address_).

12. ReturnIfAbrupt(_p_).

13. Let _G_ be a new function as defined by ReturnUndefined.

14. Let _p_ be the result of calling PromiseThen(_p_, _G_).

15. Return _p_.

The LENGTH property of the DEFINE method is 2.

Reflect.Loader.prototype.delete ( name )

The DELETE method removes an entry whose key is _name_ from this
_loader_'s module registry. It performs the following steps:

1.  Let _loader_ be this Loader.

2.  ReturnIfAbrupt(_loader_).

3.  Let _loaderRecord_ be _loader’s_ [[LoaderRecord]] internal slot.

4.  Let _name_ be ToString(_name_).

5.  ReturnIfAbrupt(_name_).

6.  Let _modules_ be the value of _loaderRecord_.[[Modules]],

7.  Repeat for each Record {[[_name_]], [[value]]} _p_ that is an
    element of _modules_,

    a.  If SameValue(_p_.[[key]], _name_), then

        i.  Set _p_.[[key]] to empty.

        ii. Set _p_.[[value]] to empty.

        iii. Return TRUE.

8.  Return FALSE.

Reflect.Loader.prototype.entries ( )

The following steps are taken:

1.  Let _loader_ be this Loader.

2.  ReturnIfAbrupt(_loader_).

3.  Return the result of CreateLoaderIterator(_loader_, "KEY+VALUE").

Reflect.Loader.prototype.get ( name )

If this Loader's module registry contains a Module with the given
normalized _name_, return it. Otherwise, return UNDEFINED. If the module
is in the registry but has never been evaluated, first synchronously
evaluate the bodies of the module and any dependencies that have not
evaluated yet.

When the GET method is called with the argument _name_, the following
steps are taken:

1.  Let _loader_ be this Loader.

2.  ReturnIfAbrupt(_loader_).

3.  Let _loaderRecord_ be _loader’s_ [[LoaderRecord]] internal slot.

4.  Let _name_ be ToString(_name_).

5.  ReturnIfAbrupt(_name_).

6.  Let _modules_ be the value of _loaderRecord._[[Modules]],

7.  Repeat for each Record {[[key]], [[value]]} _p_ that is an element
    of _modules_,

    a.  If SameValue(_p_.[[key]], _name_) is TRUE, then

        i.  Let _module_ be _p_.[[value]].

        ii. Let _result_ be EnsureEvaluated(_module_,
            (),_loaderRecord_).

        iii. ReturnIfAbrupt(_result_).

        iv. Return _p_.[[value]].

8.  Return UNDEFINED.

get Reflect.Loader.prototype.global

REFLECT.LOADER.PROTOTYPE.GLOBAL is an accessor property whose set
accessor function is UNDEFINED. Its get accessor function performs the
following steps:

1.  Let _loader_ be this Loader.

2.  ReturnIfAbrupt(_loader_).

3.  Let _loaderRecord_ be _loader’s_ [[LoaderRecord]] internal slot.

4.  Let _realm_ be the value of _loaderRecord_.[[Realm]].

5.  Return _realm_.[[globalThis]].

Reflect.Loader.prototype.has ( name )

When the Reflect.Loader.prototype.HAS method is called with argument
_name_ the following steps are taken:

1.  Let _loader_ be this Loader.

2.  ReturnIfAbrupt(_loader_).

3.  Let _loaderRecord_ be _loader’s_ [[LoaderRecord]] internal slot.

4.  Let _name_ be ToString(_name_).

5.  ReturnIfAbrupt(_name_).

6.  Let _modules_ be the value of _loaderRecord._[[Modules]],

7.  Repeat for each Record {[[key]], [[value]]} _p_ that is an element
    of _modules_,

    a.  If SameValue(_p_.[[key]], _name_) is TRUE, then return TRUE.

8.  Return FALSE.

NOTE This method does not call any hooks or run any module code.

Reflect.Loader.prototype.import ( name [ , options ] )

The IMPORT method asynchronously loads, links, and evaluates a module
and all its dependencies if these actions have not already been
performed. The argument _name_ is the registry key for the module.
IMPORT returns a Promise that resolves to the MODULE object once it has
been committed to the registry and evaluated.

When the IMPORT method is called with argument _name_ and optional
arguments _options_ the following steps are taken:

1.  Let _loader_ be this Loader.

2.  ReturnIfAbrupt(_loader_).

3.  Let _loaderRecord_ be _loader’s_ [[LoaderRecord]] internal slot.

4.  Let _p_ be the result of calling LoadModule(_loaderRecord_, _name_,
    _options_).

5.  ReturnIfAbrupt(_p_).

6.  Let _F_ be a new function object as defined by EvaluateLoadedModule.

7.  Set _F_’s [[Loader]] internal slot to _loaderRecord_.

8.  Let _p_ be PromiseThen(_p_, _F_).

9.  Return _p_.

If the optional argument _options_ is an object with an ADDRESS property
the string value of that property is used as the module location and
module loading starts with the fetch step. If an ADDRESS property is not
present, module loading starts with the locate step.

The LENGTH property of the IMPORT method is 1.

NOTE Invoking the IMPORT method is the dynamic equivalent (when combined
with normalization) of:
 _ImportDeclaration_ :: IMPORT _ModuleSpecifier_ ;

Reflect.Loader.prototype.keys ( )

The following steps are taken:

1.  Let _loader_ be this Loader.

2.  ReturnIfAbrupt(_loader_).

3.  Return the result of CreateLoaderIterator(_loader_, "KEY").

Reflect.Loader.prototype.load ( name [ , options ] )

The LOAD method asynchronously loads and links and all its dependencies
if these actions have not already been performed. The argument _name_ is
the registry key for the module. LOAD returns a Promise that resolves to
the MODULE object once it has been committed to the registry.

When the LOAD method is called with argument _name_ and optional
arguments _options_ the following steps are taken:

1.  Let _loader_ be this Loader.

2.  ReturnIfAbrupt(_loader_).

3.  Let _loaderRecord_ be _loader’s_ [[LoaderRecord]] internal slot.

4.  Let _p_ be the result of calling LoadModule(_loaderRecord_, _name_,
    _options_).

5.  ReturnIfAbrupt(_p_).

6.  Let _p_ be PromiseThen(_p_, %ReturnUndefined%).

7.  Return _p_.

If the optional argument _options_ is an object with an ADDRESS
property. The string value of that property is used as the module
location and module loading starts with the fetch step. If an ADDRESS
property is not present, module loading starts with the locate step.

The LENGTH property of the LOAD method is 1.

NOTE The LOAD method differs from the IMPORT method in that it does not
force evaluation of the loaded module.

Reflect.Loader.prototype.module ( source [, options ] )

The MODULE method asynchronously loads, links, and evaluates an
anonymous module from _source_. The module's dependencies, if any, are
loaded and committed to the registry. The anonymous module itself is not
added to the registry. MODULE returns a Promise object that resolves to
a new Module instance object once the given module body has been
evaluated.

When the MODULE method is called with argument _source_ and optional
arguments _options_ the following steps are taken:

1.  Let _loader_ be this Loader.

2.  ReturnIfAbrupt(_loader_).

3.  Let _loaderRecord_ be _loader’s_ [[LoaderRecord]] internal slot.

4.  If _options_ was not passed, then let _options_ be UNDEFINED.

5.  Let _address_ be GetOption(_options_, "ADDRESS").

6.  ReturnIfAbrupt(_address_).

7.  Let _load_ be CreateLoad(UNDEFINED).

8.  Set _load_.[[Address]] to _address_.

9.  Let _linkSet_ be CreateLinkSet(_loaderRecord_, _load_).

10. Let _successCallback_ be a new function object as defined by
    EvaluateLoadedModule.

11. Set _successCallback_’s [[Loader]] internal slot to _loaderRecord_.

12. Set _successCallback_’s [[Load]] internal slot to _load_.

13. Let _p_ be the result of calling PromiseThen(_linkSet_.[[Done]],
    _successCallback_).

14. Let _sourcePromise_ be PromiseOf(_source_).

15. Perform ProceedToTranslate(_loaderRecord_, _load_, _sourcePromise_).

16. Return _p_.

The optional argument _options_ is an object with an ADDRESS property.

The LENGTH property of the MODULE method is 1.

Reflect.Loader.prototype.newModule ( obj )

TO DO

In the prototype this is the Module Factory Function. However, this
factory seems to have only specialized utility and it seems to
unnecessarily clutter the “global” namespace of Module abstractions.
Making it a method of module loaders seems like a more sanity thing to
do, but we can break it out if that;s what people really want.

Also need to reconcile with are execute factory returns by the
instantiate hook. Is this method intended to be able as an execute
factory. If sho it probably needs to accept multiple arguments.

When the NEWMODULE method is called with argument _obj_ it creates a new
Module objects whose export properties are derived form the properties
of _obj_. The following steps are performed:

1.  If Type(_obj_) is not Object, throw a TYPEERROR exception.

2.  Let _mod_ be CreateLinkedModuleInstance( )

3.  Let _keys_ be the result of calling the ObjectKeys abstract
    operation passing _obj_ as the argument.

4.  ReturnIfAbrupt(_keys_).

5.  For each _key_ in _keys_, do

    a.  Let _value_ be the result of Get(_obj_, _key_).

    b.  ReturnIfAbrupt(_value_).

    c.  Let _F_ be the result of calling CreateConstantGetter(_key_,
        _value_).

    d.  Let _desc_ be the PropertyDescriptor {[[Configurable]]: FALSE,
        [[Enumerable]]: TRUE, [[Get]]: _F_, [[Set]]: UNDEFINED}.

    e.  Let _status_ be the result of calling the DefinePropertyOrThrow
        abstract operation passing _mod_, _key_, and _desc_ as
        arguments.

    f.  ReturnIfAbrupt(_status_).

6.  Call the [[PreventExtensions]] internal method of _mod_.

7.  Return _mod_.

get Reflect.Loader.prototype.realm

REFLECT.LOADER.PROTOTYPE.REALM is an accessor property whose set
accessor function is UNDEFINED. Its get accessor function performs the
following steps:

1.  Let _loader_ be this Loader.

2.  ReturnIfAbrupt(_loader_).

3.  Let _loaderRecord_ be _loader’s_ [[LoaderRecord]] internal slot.

4.  Return RealmObjectFor(_loaderRecord_.[[Realm]]).

Reflect.Loader.prototype.set ( name, module )

Store a Module obj in this Loader's _module_ registry, overwriting any
existing entry with the same _name_.

The following steps are taken:

1.  Let _loader_ be this Loader.

2.  ReturnIfAbrupt(_loader_).

3.  Let _loaderRecord_ be _loader’s_ [[LoaderRecord]] internal slot.

4.  Let _name_ be ToString(_name_).

5.  ReturnIfAbrupt(_name_).

6.  If Type(_module_) is not Object, throw a TYPEERROR exception.

7.  Let _modules_ be the value of _loaderRecord._[[Modules]],

8.  Repeat for each Record {[[key]], [[value]]} _p_ that is an element
    of _modules_,

    a.  If SameValue(_p_.[[key]], _name_) is TRUE, then

        1.  Set _p_.[[value]] to _module_.

        2.  Return _loader_.

9.  Let _p_ be the Record {[[key]]: _name_, [[value]]: _module_}.

10. Append _p_ as the last record of _loaderRecord_.[[Modules]].

11. Return _loader_.

Reflect.Loader.prototype.values ( )

The following steps are taken:

1.  Let _loader_ be this Loader.

2.  ReturnIfAbrupt(_loader_).

3.  Return the result of CreateLoaderIterator(_loader_, "VALUE").

Reflect.Loader.prototype[@@iterator] ( )

The initial value of the @@iterator property is the same function object
as the initial value of the ENTRIES property.

Reflect.Loader.prototype [ @@toStringTag ]

The initial value of the @@toStringTag property is the string value
"REFLECT.LOADER".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Reflect.Loader Pipeline Hook Properties

Loader hooks are methods that are called at various points in the
process of loading a module. REFLECT.LOADER.PROTOTYPE provides default
implementations for the hook methods. However, individual Loader object
may over-ride these defaults using own properties.

Reflect.Loader.prototype.normalize ( name, refererName, refererAddress )

When the NORMALIZE loader hook is called with arguments _name_,
_refererName_, and _refererAddress_ _loadRequest_, the following steps
are taken:

1.  Assert: Type(_name_) is String.

2.  Return _name_.

This is a Loader hook that may be over-ridden by an own property of
Loader instances. The NORMALIZE hook is called once per distinct
_ModuleSpecifier_ String value in a _ModuleBody_, while the module
_ModuleBody_ with that is being loaded. The _name_ argument is the
StringValue of a _ModuleSpecifier_.

The NORMALIZE hook returns an eventual String, the normalized module
name, which is used for the rest of the import process. In particular,
the [[Loads]] and [[Modules]] Lists of a ModuleLinkage record are both
keyed by normalized module names. The module registry contains at most
one module for a given normalized module name.

After calling this hook, if the normalized module _name_ is in the
registry or the load table, no new Load Record is created. Otherwise the
loader initiates a load for that module that starts by calling the
LOCATE hook.

Reflect.Loader.prototype.locate ( loadRequest )

When the locate method is called with argument _loadRequest_ the
following steps are taken:

1.  Return the result of Get(_loadRequest_, "NAME").

This is a Loader hook that may be over-ridden by an own property of
Loader instances. The LOCATE hook is called for each distinct normalized
import _ModuleSpecifier_ immediately after the NORMALIZE hook returns
successfully, unless the module is already loaded or loading.

The LOCATE hook is called to obtain to determine the Loader-dependent
resource address (URL, path, etc.) corresponding to normalized module
name. The resource address is used later in the Loader pipeline to
retrieve the source code of the requested module.

When a LOCATE hook is called by an Loader object the argument
_loadRequest_ is a LoadRequest object (15.2.3.2). The value of the NAME
property is the normalized module name. The LOCATE hook returns an
eventual value that is used as the resource address. When the returned
value is resolved, loading will continue with the FETCH hook.

NOTE The SYSTEM.LOCATE hook typically is significantly more complicated
than the default LOCATE hook.

Reflect.Loader.prototype.fetch ( loadRequest )

When the FETCH loader hook is called with argument _loadRequest_, the
following steps are taken:

1.  Throw a TYPEERROR exception.

This is a Loader hook that will normally be over-ridden by an own
property of Loader instances. The FETCH hook is called by a Loader for
all modules whose source code was not directly provided to the Loader.
It is also used to process the IMPORT keyword. The FETCH hook is not
called for module bodies directly provided as arguments to
LOADER.MODULE() or LOADER.DEFINE(). However, the FETCH hook may be
called when loading other modules imported by such modules.

When a FETCH hook is called by an Loader object the argument
_loadRequest_ is a LoadRequest object (15.2.3.2) with an ADDRESS
property. The value of the ADDRESS property identifies the module source
code to fetch. The fetch hook returns an eventual String containing the
source code of the module.

Reflect.Loader.prototype.translate ( loadRequest )

When the translate method is called, the following steps are taken:

1.  Return the result of Get(_loadRequest_, "SOURCE").

This is a LOADER hook that may be over-ridden by an own property of
Loader instances. The TRANSLATE hook is called for each _ModuleBody_
including those passed to LOADER.MODULE() or LOADER.DEFINE().The
TRANSLATE hook is called prior to parsing the _ModuleBody_ and provides
a Loader the opportunity to modify or replace the source code that will
be parsed.

NOTE An example of the use of the TRANSLATE hook would be to translate
source code for a another programing language into an ECMAScript
_ModuleBody_.

When a TRANSLATE hook is called by an Loader object the argument
_loadRequest_ is a LoadRequest object (15.2.3.2) with ADDRESS and SOURCE
properties. The value of the ADDRESS property identifies the module
source code to fetch. The value of the SOURCE property is the resolved
value returned from the FETCH hook. The TRANSLATE hook returns either an
eventual String value ECMAScript that will be parsed as a _ModuleBody_.

Reflect.Loader.prototype.instantiate ( loadRequest )

When the instantiate loader hook is called with argument _loadRequest_,
the following steps are taken:

1.  Return UNDEFINED.

This hook allows a Loader to provide interoperability with other module
systems.

When a INSTANTIATE hook is called by an Loader object the argument,
_loadRequest_, is a LoadRequest object (15.2.3.2) with ADDRESS and
SOURCE properties. _loadRequest_.NAME, _loadRequest_.METADATA, and
_loadRequest_.ADDRESS are the same values passed to the FETCH and
TRANSLATE hooks. _loadRequest_.SOURCE is the value produced by the
TRANSLATE hook.

If the INSTANTIATE hook returns an eventual UNDEFINED, then the loader
uses the default linking behaviour. It parses _loadRequest_.SOURCE as a
Module, looks at its imports, loads its dependencies asynchronously, and
finally links them together and adds them to the registry.

Otherwise, the INSTANTIATE hook must return an eventual
_instantiationRequest_ object. An _instantiateRequest_ object has two
required properties. The value of the DEPS property is an array of
strings. Each string is the name of a module upon which the module
identified by _loadRequest_ has dependencies. The value of the EXECUTE
property is a function which the loader will use to create the module
and link it with its clients and dependencies. The function should
expect to receive the same number of arguments as the size of the DEPS
array and must return an eventual Module object. The arguments are
Module objects and have a one-to-one correspondence with elements of the
DEPS array.

The module is evaluated during the linking process. First all of the
modules it depends upon are linked and evaluated , and then passed to
the EXECUTE function. Then the resulting module is linked with the
downstream dependencies.

NOTE This feature is provided in order to permit custom loaders to
support using IMPORT to import pre-ES6 modules such as AMD modules. The
design requires incremental linking when such modules are present, but
it ensures that modules implemented with standard source-level module
declarations can still be statically validated.

Properties of Reflect.Loader Instances

Loader instances are ordinary objects that inherit properties from the
%LoaderPrototype% intrinsic object. Loader instances each have a
[[Loader]] interal slot whose value after initialization is the Loader
Record that the Load instance reflects.

Loader Iterator Objects 

A Loader Iterator object represents a specific iteration over the module
registry of some specific Loader instance object. There is not a named
constructor for Loader Iterator objects. Instead, Loader iterator
objects are created by calling certain methods of Loader instance
objects.

CreateLoaderIterator Abstract Operation

Several methods of Loader objects return Iterator objects. The abstract
operation CreateLoaderIterator with arguments _loader_ and _kind_ is
used to create such iterator objects. It performs the following steps:

1.  Assert: _loader_ is an initialized Loader instance object.

2.  Let _iterator_ be ObjectCreate(%LoaderIteratorPrototype%,
    ([[Loader]], [[LoaderNextIndex]], [[LoaderIterationKind]])).

3.  Set _iterator’s_ [[Loader]] internal slot to _loader_.

4.  Set _iterator’s_ [[LoaderNextIndex]] internal slot to 0.

5.  Set _iterator’s_ [[LoaderIterationKind]] internal slot to _kind_.

6.  Return _iterator_.

The %LoaderIteratorPrototype% Object

All Loader Iterator Objects inherit properties from the
%LoaderIteratorPrototype% intrinsic object. The
%LoaderIteratorPrototype% intrinsic object is an ordinary object and its
[[Prototype]] internal slot is the %ObjectPrototype% intrinsic object.
In addition, %LoaderIteratorPrototype% has the following properties:

%LoaderIteratorPrototype%.next ( )

1.  Let _O_ be the THIS value.

2.  If Type(_O_) is not Object, throw a TYPEERROR exception.

3.  If _O_ does not have all of the internal slots of a Loader Iterator
    Instance (26.3.5.3), throw a TYPEERROR exception.

4.  Let _m_ be the value of the [[Loader]] internal slot of _O_.

5.  Let _loaderRecord_ be _m’s_ [[LoaderRecord]] internal slot.

6.  Let _index_ be the value of the [[LoaderNextIndex]] internal slot of
    _O_.

7.  Let _itemKind_ be the value of the [[LoaderIterationKind]] internal
    slot of _O_.

8.  If _m_ is UNDEFINED, then return CreateIterResultObject(UNDEFINED,
    TRUE).

9.  Let _entries_ be the List that is the value of
    _loaderRecord_.[[Modules]].

10. Repeat while _index_ is less than the total number of elements of
    _entries_. The number of elements must be redetermined each time
    this method is evaluated.

    a.  Let _e_ be the Record {[[key]], [[value]]} that is the value of
        _entries_[_index_].

    b.  Set _index_ to _index_+1;

    c.  Set the [[LoaderNextIndex]] internal slot of _O_ to _index_.

    d.  If _e_.[[key]] is not empty, then

        i.  If _itemKind_ is "KEY" then, let _result_ be _e_.[[key]].

        ii. Else if _itemKind_ is "VALUE" then, let _result_ be
            _e_.[[value]].

        iii. Else,

            1.  Assert: _itemKind_ is "KEY+VALUE".

            2.  Let _result_ be the result of performing ArrayCreate(2).

            3.  Assert: _result_ is a new, well-formed Array object so
                the following operations will never fail.

            4.  Call CreateDataProperty(_result_, "0", _e_.[[key]]) .

            5.  Call CreateDataProperty(_result_, "1", _e_.[[value]]).

        iv. Return CreateIterResultObject(_result_, FALSE).

11. Set the [[Loader]] internal slot of _O_ to UNDEFINED.

12. Return CreateIterResultObject(UNDEFINED, TRUE).

NOTE Setting the [[Loader]] internal slot to undefined when the iterator
is exhausted ensures that the same iterator cannot be restarted if new
entries are subsequently added. This condition is tested in step 8.

%LoaderIteratorPrototype% [ @@iterator ] ( )

The following steps are taken:

1.  Return the THIS value.

The value of the NAME property of this function is "[SYMBOL.ITERATOR]".

%LoaderIteratorPrototype% [ @@toStringTag ]

The initial value of the @@toStringTag property is the string value
"LOADER ITERATOR".

Properties of Loader Iterator Instances

Loader Iterator instances are ordinary objects that inherit properties
from the %LoaderIteratorPrototype% intrinsic object. Loader Iterator
instances are initially created with the internal slots described in
Table 52.

Table 52 — Internal Slots of Loader Iterator Instances

  ------------------------- ------------------------------------------------------------------------------------------------------------------------------------------------
  INTERNAL SLOT             DESCRIPTION
  [[Loader]]                The Loader object that is being iterated.
  [[LoaderNextIndex]]       The integer index of the next Loader registry data element to be examined by this iterator.
  [[LoaderIterationKind]]   A string value that identifies what is to be returned for each element of the iteration. The possible values are: "KEY", "VALUE", "KEY+VALUE".
  ------------------------- ------------------------------------------------------------------------------------------------------------------------------------------------


The System Object

The System object is the Loader Object instance associated with the
Realm of the current global object.


Proxy Objects

The Proxy Constructor Function

The Proxy Constructor is a Built-in Function with unique [[Construct]]
behaviour. It is not intended to be subclassed.

The Proxy Constructor does not have a PROTOTYPE property.

The value of the LENGTH property of the Proxy Constructor is 2.

Proxy ( target, handler )

The PROXY function is not intended to be directly called as a function.
If it is called, the following steps are performed:

1.  Throw a TYPEERROR exception.

new Proxy ( target, handler )

When PROXY is called as part of a NEW expression it is a constructor: it
creates and initializes a new exotic proxy object. PROXY called as part
of a new expression with arguments _target_ and _handler_ performs the
following steps:

1.  Return ProxyCreate(_target_, _handler_).

If PROXY is implemented as an ECMAScript function object, it must have a
[[Construct]] internal method that performs the above steps.

Properties of the Proxy Constructor Function

Proxy.revocable ( target, handler )

The PROXY.REVOCABLE function is used to create a revocable Proxy object.
When PROXY.REVOCABLE is called with arguments _target_ and _handler_ the
following steps are taken:

1.  Let _p_ be ProxyCreate(_target_, _handler_).

2.  ReturnIfAbrupt(_p_).

3.  Let _revoker_ be a new built-in function object as defined in
    26.5.2.1.1.

4.  Set the [[RevokableProxy]] internal slot of _revoker_ to _p_.

5.  Let _result_ be ObjectCreate(%ObjectPrototype%).

6.  CreateDataProperty(_result_, "PROXY", _p_).

7.  CreateDataProperty(_result_, "REVOKE", _revoker_).

8.  Return _result_.

Proxy Revocation Functions

A Proxy revocation function is an anonymous function that has the
ability to invalidate a specific Proxy object.

Each Proxy revocation function has a [[RevokableProxy]] internal slot.

When a Proxy revocation function, _F_, is called the following steps are
taken:

1.  Let _p_ be the value of _F_’s [[RevokableProxy]] internal slot.

2.  If _p_ is NULL, then return UNDEFINED.

3.  Set the value of _F_’s [[RevokableProxy]] internal slot to NULL.

4.  Assert: _p_ is a Proxy object.

5.  Set the [[ProxyTarget]] internal slot of _p_ to NULL.

6.  Set the [[ProxyHandler]] internal slot of _p_ to NULL.

7.  Return UNDEFINED.

(informative)
Grammar Summary

TODO: THE GRAMMARS IN THE ANNEX HAVE NOT YET BEEN UPDATED FOR ES6. FOR
NOW, SEE THE GRAMMARS IN THE MAIN BODY OF THE SPECIFICATION.


Lexical Grammar

SourceCharacter :: See 10.1

any Unicode code point

InputElementDiv :: See clause 11

WhiteSpace
LineTerminator
Comment
Token
RightBracePunctuator
DivPunctuator

InputElementRegExp :: See clause 11

WhiteSpace
LineTerminator
Comment
Token
RightBracePunctuator
RegularExpressionLiteral

InputElementTemplateTail :: See clause 11

WhiteSpace
LineTerminator
Comment
Token
DivPunctuator
TemplateSubstitutionTail

WhiteSpace :: See 11.2

<TAB>
<VT>
<FF>
<SP>
<NBSP>
<BOM>
<USP>

LineTerminator :: See 11.3

<LF>
<CR>
<LS>
<PS>

LineTerminatorSequence :: See 11.3

<LF>
<CR> [lookahead ∉ <LF> ]
<LS>
<PS>
<CR> <LF>

Comment :: See 11.4

MultiLineComment
SingleLineComment

MultiLineComment :: See 11.4

/* MultiLineCommentChars~opt~ */

MultiLineCommentChars :: See 11.4

MultiLineNotAsteriskChar MultiLineCommentChars~opt~
* PostAsteriskCommentChars~opt~

PostAsteriskCommentChars :: See 11.4

MultiLineNotForwardSlashOrAsteriskChar MultiLineCommentChars~opt~
* PostAsteriskCommentChars~opt~

MultiLineNotAsteriskChar :: See 11.4

SourceCharacter BUT NOT *

MultiLineNotForwardSlashOrAsteriskChar :: See 11.4

SourceCharacter BUT NOT ONE OF / OR *

SingleLineComment :: See 11.4

// SingleLineCommentChars~opt~

SingleLineCommentChars :: See 11.4

SingleLineCommentChar SingleLineCommentChars~opt~

SingleLineCommentChar :: See 11.4

SourceCharacter BUT NOT LineTerminator

Token :: See 11.5

IdentifierName
Punctuator
NumericLiteral
StringLiteral
Template

IdentifierName :: See 11.6

IdentifierStart
IdentifierName IdentifierPart

IdentifierStart :: See 11.6

UnicodeIDStart
$
_
\ UnicodeEscapeSequence

IdentifierPart :: See 11.6

UnicodeIDContinue
$
_
\ UnicodeEscapeSequence
<ZWNJ>
<ZWJ>

UnicodeIDStart :: See 11.6

any Unicode code point with the Unicode property “ID_Start”

UnicodeIDContinue :: See 11.6

any Unicode code point with the Unicode property “ID_Continue”

ReservedWord :: See 11.6.2

Keyword
FutureReservedWord
NullLiteral
BooleanLiteral

Keyword :: ONE OF See 11.6.2.1

  ---------- ---------- ------------ --------
  break      do         in           typeof
  case       else       instanceof   var
  catch      export     new          void
  class      extends    return       while
  const      finally    super        with
  continue   for        switch       yield
  debugger   function   this         
  delete     import     try          
  ---------- ---------- ------------ --------

FutureReservedWord :: See 11.6.2.2

ENUM

  -- -- -- --
  -- -- -- --

  The following tokens are also considered to be _FutureReservedWords_
  when parsing strict mode code (see 10.2.1).

  ------------ --------- ----------- --------
  implements   package   protected   static
                                     
  interface    private   public      
  ------------ --------- ----------- --------

Punctuator :: ONE OF See 11.7

  ----- ------ ----- ----- ----- -----
  {     }      (     )     [     ]
  .     ;      ,     <     >     <=
  >=    ==     !=    ===   !==   
  +     -      *     %     ++    --
  <<    >>     >>>   &     |     ^
  !     ~      &&    ||    ?     :
  =     +=     -=    *=    %=    <<=
  >>=   >>>=   &=    |=    ^=    =>
  ----- ------ ----- ----- ----- -----

DivPunctuator :: ONE OF See 11.7

  --- ---- -- -- -- --
  /   /=            
  --- ---- -- -- -- --

RightBracePunctuator :: ONE OF See 11.7

  --- -- -- -- -- --
  }               
  --- -- -- -- -- --

NullLiteral :: See 7.8.1

NULL

BooleanLiteral :: See 11.8.2

TRUE
FALSE

_NumericLiteral_ :: See 11.8.

DecimalLiteral
BinaryIntegerLiteral
OctalIntegerLiteral
HexIntegerLiteral

DecimalLiteral :: See 11.8.3

DecimalIntegerLiteral . DecimalDigits~opt~ ExponentPart~opt~
. DecimalDigits ExponentPart~opt~
DecimalIntegerLiteral ExponentPart~opt~

DecimalIntegerLiteral :: See 11.8.3

0
NonZeroDigit DecimalDigits~opt~

DecimalDigits :: See 11.8.3

DecimalDigit
DecimalDigits DecimalDigit

DecimalDigit :: ONE OF See 11.8.3

0 1 2 3 4 5 6 7 8 

NonZeroDigit :: ONE OF See 11.8.3

1 2 3 4 5 6 7 8 

ExponentPart :: See 11.8.3

ExponentIndicator SignedInteger

ExponentIndicator :: ONE OF See 11.8.3

E E

SignedInteger :: See 11.8.3

DecimalDigits
+ DecimalDigits
- DecimalDigits

BinaryIntegerLiteral :: See 11.8.3

0B BinaryDigits
0B BinaryDigits

BinaryDigits :: See 11.8.3

BinaryDigit
BinaryDigits BinaryDigit

BinaryDigit :: ONE OF See 11.8.3

0 

OctalIntegerLiteral :: See 11.8.3

0O OctalDigits
0O OctalDigits

OctalDigits :: See 11.8.3

OctalDigit
OctalDigits OctalDigit

OctalDigit :: ONE OF See 11.8.3

0 1 2 3 4 5 6 

HexIntegerLiteral :: See 11.8.3

0X HexDigits
0X HexDigist

HexDigits :: See 11.8.3

HexDigit
HexDigits HexDigit

HexDigit :: ONE OF See 11.8.3

0 1 2 3 4 5 6 7 8 9 A B C D E F A B C D E F

StringLiteral :: See 11.8.4

" DoubleStringCharacters~opt~ "
' SingleStringCharacters~opt~ '

DoubleStringCharacters :: See 11.8.4

DoubleStringCharacter DoubleStringCharacters~opt~

SingleStringCharacters :: See 11.8.4

SingleStringCharacter SingleStringCharacters~opt~

DoubleStringCharacter :: See 11.8.4

SourceCharacter BUT NOT ONE OF " OR \ OR LineTerminator
\ EscapeSequence
LineContinuation

SingleStringCharacter :: See 11.8.4

SourceCharacter BUT NOT ONE OF ' OR \ OR LineTerminator
\ EscapeSequence
LineContinuation

LineContinuation :: See 11.8.4

\ LineTerminatorSequence

EscapeSequence :: See 11.8.4

CharacterEscapeSequence
0 [lookahead ∉ DecimalDigit]
HexEscapeSequence
UnicodeEscapeSequence

CharacterEscapeSequence :: See 11.8.4

SingleEscapeCharacter
NonEscapeCharacter

SingleEscapeCharacter :: ONE OF See 11.8.4

' " \ B F N R T V

NonEscapeCharacter :: See 11.8.4

SourceCharacter BUT NOT ONE OF EscapeCharacter OR LineTerminator

EscapeCharacter :: See 11.8.4

SingleEscapeCharacter
DecimalDigit
X
U

HexEscapeSequence :: See 11.8.4

X HexDigit HexDigit

UnicodeEscapeSequence :: See 11.8.4

U Hex4Digits
U{ HexDigits }

Hex4Digits :: See 11.8.4

HexDigit HexDigit HexDigit HexDigit

RegularExpressionLiteral :: See 11.8.5

/ RegularExpressionBody / RegularExpressionFlags

RegularExpressionBody :: See 11.8.5

RegularExpressionFirstChar RegularExpressionChars

RegularExpressionChars :: See 11.8.5

[empty]
RegularExpressionChars RegularExpressionChar

RegularExpressionFirstChar :: See 11.8.5

RegularExpressionNonTerminator BUT NOT ONE OF * OR \ OR / OR [
RegularExpressionBackslashSequence
RegularExpressionClass

RegularExpressionChar :: See 11.8.5

RegularExpressionNonTerminator BUT NOT ONE OF \ OR / OR [
RegularExpressionBackslashSequence
RegularExpressionClass

RegularExpressionBackslashSequence :: See 11.8.5

\ RegularExpressionNonTerminator

RegularExpressionNonTerminator :: See 11.8.5

SourceCharacter BUT NOT LineTerminator

RegularExpressionClass :: See 11.8.5

[ RegularExpressionClassChars ]

RegularExpressionClassChars :: See 11.8.5

[empty]
RegularExpressionClassChars RegularExpressionClassChar

RegularExpressionClassChar :: See 11.8.5

RegularExpressionNonTerminator BUT NOT ONE OF ] OR \
RegularExpressionBackslashSequence

RegularExpressionFlags :: See 11.8.5

[empty]
RegularExpressionFlags IdentifierPart

Template :: See 11.8.6

NoSubstitutionTemplate
TemplateHead

NoSubstitutionTemplate :: See 11.8.6

` TemplateCharacters~opt~ `

TemplateHead :: See 11.8.6

` TemplateCharacters~opt~ ${

TemplateSubstitutionTail :: See 11.8.6

TemplateMiddle
TemplateTail

TemplateMiddle :: See 11.8.6

} TemplateCharacters~opt~ ${

TemplateTail :: See 11.8.6

} TemplateCharacters~opt~ `

TemplateCharacters :: See 11.8.6

TemplateCharacter TemplateCharacters~opt~

TemplateCharacter :: See 11.8.6

SourceCharacter BUT NOT ONE OF ` OR \ OR $ OR LineTerminatorSequence
$ [lookahead ≠ { ]
\ EscapeSequence
LineContinuation
LineTerminatorSequence

1.  


2.  


3.  


4.  


5.  


6.  


7.  


8.  


9.  


10. 


11. 


12. 


13. 


14. 


15. 


16. 


17. 


18. 


19. 


20. 


21. 


22. 


23. 


24. 


25. 


26. 


27. 


28. 


29. 


30. 


31. 


32. 


33. 


34. 


35. 


36. 


37. 


38. 


39. 


    Expressions

PrimaryExpression : See 11.1

THIS
Identifier
Literal
ArrayLiteral
ObjectLiteral
( Expression )

ArrayLiteral : See 11.1.4

[ Elision~opt~ ]
[ ElementList ]
[ ElementList , Elision~opt~ ]

ElementList : See 11.1.4

Elision~opt~ AssignmentExpression
ElementList , Elision~opt~ AssignmentExpression

Elision : See 11.1.4

,
Elision ,

ObjectLiteral : See 11.1.5

{ }
{ PropertyDefinitionList }
{ PropertyDefinitionList , }

PropertyDefinitionList : See 11.1.5

PropertyDefinition
PropertyDefinitionList , PropertyDefinition

PropertyDefinition : See 11.1.5

PropertyName : AssignmentExpression
GET PropertyName ( ) { FunctionBody }
SET PropertyName ( PropertySetParameterList ) { FunctionBody }

PropertyName : See 11.1.5

IdentifierName
StringLiteral
NumericLiteral

PropertySetParameterList : See 11.1.5

Identifier

MemberExpression : See 11.2

PrimaryExpression
FunctionExpression
MemberExpression [ Expression ]
MemberExpression . IdentifierName
NEW MemberExpression _Arguments_

NewExpression : See 11.2

MemberExpression
NEW NewExpression

CallExpression : See 11.2

MemberExpression Arguments
CallExpression Arguments
CallExpression [ Expression ]
CallExpression . IdentifierName

Arguments : See 11.2

( )
( ArgumentList )

ArgumentList : See 11.2

AssignmentExpression
ArgumentList , AssignmentExpression

LeftHandSideExpression : See 11.2

NewExpression
CallExpression

PostfixExpression : See 11.3

LeftHandSideExpression
LeftHandSideExpression [no LineTerminator here] ++
LeftHandSideExpression [no LineTerminator here] --

UnaryExpression : See 11.4

PostfixExpression
DELETE UnaryExpression
VOID UnaryExpression
TYPEOF UnaryExpression
++ UnaryExpression
-- UnaryExpression
+ UnaryExpression
- UnaryExpression
~ UnaryExpression
! UnaryExpression

MultiplicativeExpression : See 11.5

UnaryExpression
MultiplicativeExpression * UnaryExpression
MultiplicativeExpression / UnaryExpression
MultiplicativeExpression % UnaryExpression

AdditiveExpression : See 11.6

MultiplicativeExpression
AdditiveExpression + MultiplicativeExpression
AdditiveExpression - MultiplicativeExpression

ShiftExpression : See 11.7

AdditiveExpression
ShiftExpression << AdditiveExpression
ShiftExpression >> AdditiveExpression
ShiftExpression >>> AdditiveExpression

RelationalExpression : See 11.8

ShiftExpression
RelationalExpression < ShiftExpression
RelationalExpression > ShiftExpression
RelationalExpression <= ShiftExpression
RelationalExpression >= ShiftExpression
RelationalExpression INSTANCEOF ShiftExpression
RelationalExpression IN ShiftExpression

EqualityExpression : See 11.9

RelationalExpression
EqualityExpression == RelationalExpression
EqualityExpression != RelationalExpression
EqualityExpression === RelationalExpression
EqualityExpression !== RelationalExpression

BitwiseANDExpression : See 11.10

EqualityExpression
BitwiseANDExpression & EqualityExpression

BitwiseXORExpression : See 11.10

BitwiseANDExpression
BitwiseXORExpression ^ BitwiseANDExpression

BitwiseORExpression : See 11.10

BitwiseXORExpression
BitwiseORExpression | BitwiseXORExpression

LogicalANDExpression : See 11.11

BitwiseORExpression
LogicalANDExpression && BitwiseORExpression

LogicalORExpression : See 11.11

LogicalANDExpression
LogicalORExpression || LogicalANDExpression

ConditionalExpression : See 11.12

LogicalORExpression
LogicalORExpression ? AssignmentExpression : AssignmentExpression

AssignmentExpression : See 11.13

ConditionalExpression
LeftHandSideExpression = AssignmentExpression
LeftHandSideExpression AssignmentOperator AssignmentExpression

AssignmentOperator : ONE OF See 11.13

  ---- ---- ---- ---- ---- ----- ----- ------ ---- ---- ----
  *=   /=   %=   +=   -=   <<=   >>=   >>>=   &=   ^=   |=
  ---- ---- ---- ---- ---- ----- ----- ------ ---- ---- ----

Expression : See 11.14

AssignmentExpression
Expression , AssignmentExpression


Statements

Statement : See clause 12

Block
VariableStatement
EmptyStatement
ExpressionStatement
IfStatement
IterationStatement
ContinueStatement
BreakStatement
ReturnStatement
WithStatement
LabelledStatement
SwitchStatement
ThrowStatement
TryStatement
DebuggerStatement

Block : See 12.1

{ StatementList~opt~ }

StatementList : See 12.1

Statement
StatementList Statement

VariableStatement : See 12.2

VAR VariableDeclarationList ;

VariableDeclarationList : See 12.2

VariableDeclaration
VariableDeclarationList , VariableDeclaration

VariableDeclaration : See 12.2

Identifier Initialiser~opt~

Initialiser : See 12.2

= AssignmentExpression

EmptyStatement : See 12.3

;

ExpressionStatement : See 12.4

[lookahead ∉ {{, FUNCTION}] Expression ;

IfStatement : See 12.5

IF ( Expression ) Statement ELSE Statement
IF ( Expression ) Statement

IterationStatement : See 12.6

DO Statement WHILE ( Expression );
WHILE ( Expression ) Statement
FOR (Expression~opt~; Expression~opt~ ; Expression~opt~ ) Statement
FOR ( VAR VariableDeclarationList; Expression~opt~ ; Expression~opt~ )
Statement
FOR ( LeftHandSideExpression IN Expression ) Statement
FOR ( VAR VariableDeclaration IN Expression ) Statement

ContinueStatement : See 12.7

CONTINUE ;
CONTINUE [no LineTerminator here] Identifier ;

BreakStatement : See 12.8

BREAK ;
BREAK [no LineTerminator here] Identifier ;

ReturnStatement : See 12.9

RETURN ;
RETURN [no LineTerminator here] Expression ;

WithStatement : See 12.10

WITH ( Expression ) Statement

SwitchStatement : See 12.11

SWITCH ( Expression ) CaseBlock

CaseBlock : See 12.11

{ CaseClauses~opt~ }
{ CaseClauses~opt~ DefaultClause CaseClauses~opt~ }

CaseClauses : See 12.11

CaseClause
CaseClauses CaseClause

CaseClause : See 12.11

CASE Expression : StatementList~opt~

DefaultClause : See 12.11

DEFAULT : StatementList~opt~

LabelledStatement : See 12.12

Identifier : Statement

ThrowStatement : See 12.13

THROW [no LineTerminator here] Expression ;

TryStatement : See 12.14

TRY Block Catch~
~TRY Block Finally~
~TRY Block Catch Finally

Catch : See 12.14

CATCH ( Identifier ) Block

Finally : See 12.14

FINALLY Block

DebuggerStatement : See 12.15

DEBUGGER ;


Functions and Scripts

FunctionDeclaration : See clause 13

FUNCTION Identifier ( FormalParameterList~opt~ ) { FunctionBody }

FunctionExpression : See clause 13

FUNCTION Identifier~opt~ ( FormalParameterList~opt~ ) { FunctionBody }

FormalParameterList : See clause 13

Identifier
FormalParameterList , Identifier

FunctionBody : See clause 13

SourceElements~opt~

Program : See clause 14

SourceElements~opt~

SourceElements : See clause 14

SourceElement
SourceElements SourceElement

SourceElement : See clause 14

Statement
FunctionDeclaration


Number Conversions

StringNumericLiteral ::: See 7.1.3.1

StrWhiteSpace~opt~
StrWhiteSpace~opt~ StrNumericLiteral StrWhiteSpace~opt~

StrWhiteSpace ::: See 7.1.3.1

StrWhiteSpaceChar StrWhiteSpace~opt~

StrWhiteSpaceChar ::: See 7.1.3.1

WhiteSpace
LineTerminator

StrNumericLiteral ::: See 7.1.3.1

StrDecimalLiteral
HexIntegerLiteral

StrDecimalLiteral ::: See 7.1.3.1

StrUnsignedDecimalLiteral
+ StrUnsignedDecimalLiteral
- StrUnsignedDecimalLiteral

StrUnsignedDecimalLiteral ::: See 7.1.3.1

INFINITY
DecimalDigits . DecimalDigits~opt~ ExponentPart~opt~
. DecimalDigits ExponentPart~opt~
DecimalDigits ExponentPart~opt~

DecimalDigits ::: See 7.1.3.1

DecimalDigit
DecimalDigits DecimalDigit

DecimalDigit ::: ONE OF See 7.1.3.1

0 1 2 3 4 5 6 7 8 

ExponentPart ::: See 7.1.3.1

ExponentIndicator SignedInteger

ExponentIndicator ::: ONE OF See 7.1.3.1

E E

SignedInteger ::: See 7.1.3.1

DecimalDigits
+ DecimalDigits
- DecimalDigits

HexIntegerLiteral ::: See 7.1.3.1

0X HexDigit
0X HexDigit
HexIntegerLiteral HexDigit

HexDigit ::: ONE OF See 7.1.3.1

0 1 2 3 4 5 6 7 8 9 A B C D E F A B C D E F


Universal Resource Identifier Character Classes

uri ::: See 15.1.3

uriCharacters~opt~

uriCharacters ::: See 15.1.3

uriCharacter uriCharacters~opt~

uriCharacter ::: See 15.1.3

uriReserved
uriUnescaped
uriEscaped

uriReserved ::: ONE OF See 15.1.3

; / ? : @ & = + $ ,

uriUnescaped ::: See 15.1.3

uriAlpha
DecimalDigit
uriMark

uriEscaped ::: See 15.1.3

% HexDigit HexDigit

uriAlpha ::: ONE OF See 15.1.3

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

uriMark ::: ONE OF See 15.1.3

- _ . ! ~ * ' ( )


Regular Expressions

Pattern :: See 15.10.1

Disjunction

Disjunction :: See 15.10.1

Alternative
 Alternative | Disjunction

Alternative :: See 15.10.1

[empty]
Alternative Term

Term :: See 15.10.1

Assertion
Atom
Atom Quantifier

Assertion :: See 15.10.1

^
$
\ B
\ B
( ? = Disjunction )
( ? ! Disjunction )

Quantifier :: See 15.10.1

QuantifierPrefix
QuantifierPrefix ?

QuantifierPrefix :: See 15.10.1

*
+
?
{ DecimalDigits }
{ DecimalDigits , }
{ DecimalDigits , DecimalDigits }

Atom :: See 15.10.1

PatternCharacter
.
\ AtomEscape
CharacterClass
( Disjunction )
( ? : Disjunction )

_PatternCharacter_ :: See 15.10.

_SourceCharacter_ BUT NOT ONE OF-
 ^ $ \ . * + ? ( ) [ ] { } |

AtomEscape :: See 15.10.1

DecimalEscape
CharacterEscape
CharacterClassEscape

CharacterEscape :: See 15.10.1

ControlEscape
C ControlLetter
HexEscapeSequence
UnicodeEscapeSequence
IdentityEscape

ControlEscape :: ONE OF See 15.10.1

F N R T V

ControlLetter :: ONE OF See 15.10.1

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

IdentityEscape :: See 15.10.1

SourceCharacter BUT NOT IdentifierPart
<ZWJ>
<ZWNJ>

DecimalEscape :: See 15.10.1

DecimalIntegerLiteral [lookahead ∉ DecimalDigit]

CharacterClassEscape :: ONE OF See 15.10.1

D D S S W W

CharacterClass :: See 15.10.1

[ [lookahead ∉ {^}] ClassRanges ]
[ ^ ClassRanges ]

ClassRanges :: See 15.10.1

[empty]
NonemptyClassRanges

NonemptyClassRanges :: See 15.10.1

ClassAtom
ClassAtom NonemptyClassRangesNoDash
ClassAtom – ClassAtom ClassRanges

NonemptyClassRangesNoDash :: See 15.10.1

ClassAtom
ClassAtomNoDash NonemptyClassRangesNoDash
ClassAtomNoDash – ClassAtom ClassRanges

ClassAtom :: See 15.10.1

-
ClassAtomNoDash

ClassAtomNoDash :: See 15.10.1

SourceCharacter BUT NOT ONE OF \ OR ] OR -
\ ClassEscape

ClassEscape :: See 15.10.1

DecimalEscape
B
CharacterEscape
CharacterClassEscape

(normative)
Additional ECMAScript Features for Web Browsers

The ECMAScript language syntax and semantics defined in this annex are
required when the ECMAScript host is a web browser. The content of this
annex is normative but optional if the ECMAScript host is not a web
browser.

1.  


    Additional Syntax

    1.  Numeric Literals

The syntax and semantics of 11.8.3 is extended as follows except that
this extension is not allowed for strict mode code:

Syntax

NumericLiteral ::

DecimalLiteral
BinaryIntegerLiteral
OctalIntegerLiteral
HexIntegerLiteral
LegacyOctalIntegerLiteral

LegacyOctalIntegerLiteral ::

0 OctalDigit
LegacyOctalIntegerLiteral OctalDigit

1.  STATIC SEMANTICS

-   The MV of _LegacyOctalIntegerLiteral_ :: 0 _OctalDigit_ is the MV of
    _OctalDigit_.

-   The MV of _LegacyOctalIntegerLiteral_ :: _LegacyOctalIntegerLiteral_
    _OctalDigit_ is (the MV of _LegacyOctalIntegerLiteral_ times 8) plus
    the MV of _OctalDigit_.

    1.  String Literals 

The syntax and semantics of 11.8.4 is extended as follows except that
this extension is not allowed for strict mode code:

Syntax

EscapeSequence ::

CharacterEscapeSequence
OctalEscapeSequence
HexEscapeSequence
UnicodeEscapeSequence

OctalEscapeSequence ::

OctalDigit [lookahead ∉ DecimalDigit]
ZeroToThree OctalDigit [lookahead ∉ DecimalDigit]
FourToSeven OctalDigit
ZeroToThree OctalDigit OctalDigit

ZeroToThree :: ONE OF

0 1 2 

FourToSeven :: ONE OF

4 5 6 

This definition of _EscapeSequence_ is not used when parsing
_TemplateCharacter_ (11.8.6).

1.  STATIC SEMANTICS

-   The CV of _EscapeSequence_ :: _OctalEscapeSequence_ is the CV of the
    _OctalEscapeSequence_.

-   The CV of _OctalEscapeSequence_ :: _OctalDigit_ is code unit whose
    value is the MV of the _OctalDigit_.

-   The CV of _OctalEscapeSequence_ :: _ZeroToThree_ _OctalDigit_ is the
    code unit whose value is (8 times the MV of the _ZeroToThree_) plus
    the MV of the _OctalDigit_.

-   The CV of _OctalEscapeSequence_ :: _FourToSeven_ _OctalDigit_ is the
    code unit whose value is (8 times the MV of the _FourToSeven_) plus
    the MV of the _OctalDigit_.

-   The CV of _OctalEscapeSequence_ :: _ZeroToThree_ _OctalDigit_
    _OctalDigit_ is the code unit whose value is (64 (that is, 8^2^)
    times the MV of the _ZeroToThree_) plus (8 times the MV of the first
    _OctalDigit_) plus the MV of the second _OctalDigit_.

-   The MV of _ZeroToThree_ :: 0 is 0.

-   The MV of _ZeroToThree_ :: 1 is 1.

-   The MV of _ZeroToThree_ :: 2 is 2.

-   The MV of _ZeroToThree_ :: 3 is 3.

-   The MV of _FourToSeven_ :: 4 is 4.

-   The MV of _FourToSeven_ :: 5 is 5.

-   The MV of _FourToSeven_ :: 6 is 6.

-   The MV of _FourToSeven_ :: 7 is 7.

    1.  HTML-like Comments

TODO See _http://javascript.spec.whatwg.org/#comment-syntax_

Regular Expressions Patterns

The syntax of 21.2.1 is extended as modified and extended as follows.
These changes introduce ambiguities that are broken by the ordering or
grammar productions and by contextual information. The following grammar
is used, with each alternative considered only if previous production
alternatives do not match.

SYNTAX

Term~[U]~ ::

[~U] ExtendedTerm
[+U] Assertion~[U]~
[+U] Atom~[U]~
[+U] Atom~[U]~ Quantifier

ExtendedTerm ::

Assertion
AtomNoBrace Quantifier
Atom
QuantifiableAssertion Quantifier

AtomNoBrace ::

PatternCharacterNoBrace
.
\ AtomEscape
CharacterClass
( Disjunction )
( ? : Disjunction )

Atom~[U]~ ::

PatternCharacter
.
\ AtomEscape~[?U]~
CharacterClass~[?U]~
( Disjunction~[?U]~ )
( ? : Disjunction~[?U]~ )

PatternCharacterNoBrace ::

SourceCharacter BUT NOT ONE OF
 ^ $ \ . * + ? ( ) [ ] { } |

PatternCharacter ::

SourceCharacter BUT NOT ONE OF
 ^ $ \ . * + ? ( ) [ ] |

QuantifiableAssertion ::

( ? = Disjunction )
( ? ! Disjunction )

Assertion~[U]~ ::

^
$
\ B
\ B
[+U] ( ? = Disjunction~[?U]~ )
[+U] ( ? ! Disjunction~[?U]~ )
[~U] QuantifiableAssertion

AtomEscape~[U]~ ::

[+U] DecimalEscape
[~U] DecimalEscape but only if the integer value of DecimalEscape is <=
NCapturingParens
[+U] CharacterEscape~[U]~
[+U] CharacterClassEscape
[~U] CharacterClassEscape
[~U] CharacterEscape

CharacterEscape~[U]~ ::

ControlEscape
C ControlLetter
HexEscapeSequence
RegExpUnicodeEscapeSequence~[?U]~
[~U] OctalEscapeSequence
IdentityEscape~[?U]~

IdentityEscape~[U]~ ::

[+U] SyntaxCharacter
[~U] SourceCharacter BUT NOT C
[~U] <ZWJ>
[~U] <ZWNJ>

NonemptyClassRanges~[U]~ ::

ClassAtom~[?U]~
ClassAtom~[?U]~ NonemptyClassRangesNoDash~[?U]
~[+U] ClassAtom~[U]~ - ClassAtom~[U]~ ClassRanges~[U]~
[~U] ClassAtomInRange - ClassAtomInRange ClassRanges

NonemptyClassRangesNoDash~[U]~ ::

ClassAtom~[?U]~
ClassAtomNoDash~[?U]~ NonemptyClassRangesNoDash~[?U]
~[+U] ClassAtomNoDash~[U]~ - ClassAtom~[U]~ ClassRanges~[U]~
[~U] ClassAtomNoDashInRange - ClassAtomInRange ClassRanges

ClassAtom~[U]~ ::

-
ClassAtomNoDash~[?U]~

ClassAtomNoDash~[U]~ ::

SourceCharacter BUT NOT ONE OF \ OR ] OR -
\ ClassEscape~[?U]~

ClassAtomInRange ::

-
ClassAtomNoDashInRange

ClassAtomNoDashInRange ::

SourceCharacter BUT NOT ONE OF \ OR ] OR -
\ ClassEscape but only if ClassEscape evaluates to a CharSet with
exactly one character
\ IdentityEscape

ClassEscape~[U]~ ::

[+U] DecimalEscape
[~U] DecimalEscape but only if the integer value of DecimalEscape is <=
NCapturingParens
B
[+U] CharacterEscape~[U]~
[+U] CharacterClassEscape
[~U] CharacterClassEscape
[~U] CharacterEscape

1.  PATTERN SEMANTICS

The semantics of 21.2.2 is extended as follows:

Within 21.2.2.5 reference to “_Atom_ :: ( _Disjunction_ )” are to be
interpreted as meaning “_Atom_ :: ( _Disjunction_ )or _AtomNoBrace_ :: (
_Disjunction_ )”.

Term (21.2.2.5) includes the following additional evaluation rule:

  The production _Term_ :: _QuantifiableAssertion_ _Quantifier_
  evaluates the same as the production _Term_ :: _Atom_ _Quantifier_ but
  with _QuantifiableAssertion_ substituted for _Atom_.

Atom (21.2.2.8) evaluation rules for the _Atom_ productions except for
_Atom_ :: _PatternCharacter_ are also used for the _AtomNoBrace
productions, but with _AtomNoBrace_ substituted for _Atom_. The
following evaluation rule is also added:

The production _AtomNoBrace_ :: _PatternCharacterNoBrace_ evaluates as
follows:

1.  Let _ch_ be the character represented by _PatternCharacterNoBrace_.

2.  Let _A_ be a one-element CharSet containing the character _ch_.

3.  Call CharacterSetMatcher(_A_, FALSE) and return its Matcher result.

CharacterEscape (21.2.2.10) includes the following additional evaluation
rule:

  The production _CharacterEscape_ :: _OctalEscapeSequence_ evaluates by
  evaluating the CV of the _OctalscapeSequence_ (see B.1.2) and
  returning its character result.

ClassAtom (21.2.2.17) includes the following additional evaluation
rules:

  The production _ClassAtomInRange_ :: - evaluates by returning the
  CharSet containing the one character -.

  The production _ClassAtomInRange_ :: _ClassAtomNoDashInRange_
  evaluates by evaluating _ClassAtomNoDashInRange_ to obtain a CharSet
  and returning that CharSet.

ClassAtomNoDash (21.2.2.18) includes the following additional evaluation
rules:

  The production _ClassAtomNoDashInRange_ :: _SourceCharacter_ BUT NOT
  ONE OF \ OR ] OR - evaluates by returning a one-element CharSet
  containing the character represented by _SourceCharacter_.

  The production _ClassAtomNoDashInRange_ :: \ _ClassEscape_ but ony
  if…, evaluates by evaluating _ClassEscape_ to obtain a CharSet and
  returning that CharSet.

  The production _ClassAtomNoDashInRange_ :: \ _IdentityEscape_
  evaluates by returning the character represented by _IdentityEscape_.


Additional Built-in Properties

When the ECMAScript host is a web browser the following additional
properties of the standard built-in objects are defined.

1.  Additional Properties of the Global Object

    1.  escape (string)

The ESCAPE function is a property of the global object. It computes a
new version of a String value in which certain code units have been
replaced by a hexadecimal escape sequence.

For those code units being replaced whose value is U+00FF or less, a
two-digit escape sequence of the form %_xx_ is used. For those
characters being replaced whose code unit value is greater than U+00FF,
a four-digit escape sequence of the form %U_xxxx_ is used.

When the ESCAPE function is called with one argument _string_, the
following steps are taken:

1.  Let _string_ be ToString(_string_).

2.  ReturnIfAbrupt(_string_).

3.  Let _length_ be the number of code units in _string_.

4.  Let _R_ be the empty string.

5.  Let _k_ be 0.

6.  Repeat, while _k_ < _length_,

    a.  Let _char_ be the code unit (represented as a 16-bit unsigned
        integer) at position _k_ within _string_.

    b.  If _char_ is the code point of one of the 69 nonblank code units
        in
        "ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@*_+-./"
        then,

        i.  Let _S_ be a String containing the single code unit _char_.

    c.  Else if _char_ > 256,

        i.  Let _S_ be a String containing six code units "%U_wxyz_"
            where _wxyz_ are the code units of the four hexadecimal
            digits encoding the value of _char_.

    d.  Else, _char_ < 256

        i.  Let _S_ be a String containing three code units "%_xy_"
            where _xy_ are the code units of two hexadecimal digits
            encoding the value of _char_.

    e.  Let _R_ be a new String value computed by concatenating the
        previous value of _R_ and _S_.

    f.  Increase _k_ by 1.

7.  Return _R_.

NOTE The encoding is partly based on the encoding described in RFC 1738,
but the entire encoding specified in this standard is described above
without regard to the contents of RFC 1738. This encoding does not
reflect changes to RFC 1738 made by RFC 3986.

unescape (string)

The UNESCAPE function is a property of the global object. It computes a
new version of a String value in which each escape sequence of the sort
that might be introduced by the ESCAPE function is replaced with the
code unit that it represents.

When the UNESCAPE function is called with one argument _string_, the
following steps are taken:

1.  Let _string_ be ToString(_string_).

2.  ReturnIfAbrupt(_string_).

3.  Let _length_ be the number of code units in _string_.

4.  Let _R_ be the empty String.

5.  Let _k_ be 0.

6.  Repeat, while _k_ ≠ _length

    a.  Let _c_ be the code unit at position _k_ within _string_.

    b.  If _c_ is %,

        i.  If _k_ ≤ _length_−6 and the code unit at position _k_+1
            within _string_ is U and the four code units at positions
            _k_+2, _k_+3, _k_+4, and _k_+5 within _string_ are all
            hexadecimal digits, then

            1.  Let _c_ be the code unit whose value is the integer
                represented by the four hexadecimal digits at positions
                _k_+2, _k_+3, _k_+4, and _k_+5 within _string_.

            2.  Increase _k_ by 5.

        ii. Else if _k_ ≤ _length_−3 and the two code units at positions
            _k_+1 and _k_+2 within _string_ are both hexadecimal digits,
            then

            1.  Let _c_ be the code unit whose value is the integer
                represented by two zeroes plus the two hexadecimal
                digits at positions _k_+1 and _k_+2 within _string_.

            2.  Increase _k_ by 2.

    c.  Let _R_ be a new String value computed by concatenating the
        previous value of _R_ and _c_.

    d.  Increase _k_ by 1.

7.  Return _R_.

    1.  Additional Properties of the Object.prototype Object

        1.  Object.prototype.__proto__ 

Object.prototype.__proto__ is an accessor property with attributes {
[[Enumerable]]: FALSE, [[Configurable]]: TRUE }. The [[Get]] and [[Set]]
attributes are defined as follows

get Object.prototype.__proto__ 

The value of the [[Get]] attribute is a built-in function that requires
no arguments. It performs the following steps:

1.  Let _O_ be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(_O_).

3.  Return the result of calling the [[GetPrototypeOf]] internal method
    of _O_.

    1.  set Object.prototype.__proto__ 

The value of the [[Set]] attribute is a built-in function that takes an
argument _proto_. It performs the following steps:

1.  Let _O_ be CheckObjectCoercible(THIS value)_.

2.  ReturnIfAbrupt(_O_).

3.  If Type(_proto_) is neither Object nor Null, then return UNDEFINED.

4.  If Type(_O)_ is not Object, then return UNDEFINED.

5.  Let _status_ be the result of calling the [[SetPrototypeOf]]
    internal method of _O_ with argument _proto_.

6.  ReturnIfAbrupt(_status_).

7.  If _status_ is FALSE, then throw a TYPEERROR exception.

8.  Return UNDEFINED.

    1.  Additional Properties of the String.prototype Object

        1.  String.prototype.substr (start, length)

The SUBSTR method takes two arguments, _start_ and _length_, and returns
a substring of the result of converting the THIS object to a String,
starting from position _start_ and running for _length_ code units (or
through the end of the String if _length_ is UNDEFINED). If _start_ is
negative, it is treated as (_sourceLength_+_start_) where _sourceLength_
is the length of the String. The result is a String value, not a String
object. The following steps are taken:

1.  Let _O_ be CheckObjectCoercible(THIS value).

2.  Let _S_ be ToString(_O_).

3.  Let _intStart_ be ToInteger(_start_).

4.  ReturnIfAbrupt(_intStart_).

5.  If _length_ is UNDEFINED, let _end_ be +∞; otherwise let _end_ be
    ToInteger(_length_).

6.  ReturnIfAbrupt(_end_).

7.  Let _size_ be the number of code units in _S_.

8.  If _intStart_ is negative, then let _intStart_ be max(_size_ +
    _intStart_,0).

9.  Let _resultLength_ be min(max(_end_,0), _size_ – _intStart_).

10. If _resultLength_ ≤ 0, return the empty String "".

11. Return a String containing _resultLength_ consecutive code units
    from _S_ beginning with the code unit at position _intStart_.

The LENGTH property of the SUBSTR method is 2.

NOTE The SUBSTR function is intentionally generic; it does not require
that its THIS value be a String object. Therefore it can be transferred
to other kinds of objects for use as a method.

String.prototype.anchor ( name )

When the ANCHOR method is called with argument _name_, the following
steps are taken:

1.  Let _S_ be the THIS value.

2.  Return CreateHTML(_S_, "A", "NAME", _name_).

    1.  CreateHTML ( name ) Abstract Operation

The abstract operation CreateHTML is called with arguments _string,
tag_, _attribute_, and _value_. The arguments _tag_ and _attribute_ must
be string values. The following steps are taken:

1.  Let _str_ be CheckObjectCoercible(_string_).

2.  Let _S_ be ToString(_str_).

3.  ReturnIfAbrupt(_S_).

4.  Let _p1_ be the string value that is the concatenation of "<" and
    _tag_.

5.  If _attribute_ is not the empty String, then

    a.  Let _V_ be ToString(_value_).

    b.  ReturnIfAbrupt(_V_).

    c.  Let _escapedV_ be the string value that is the same as _V_
        except that each occurrence of the code unit U+0022 (QUOTATION
        MARK) in _V_ has been replaced with the six code unit sequence
        "&QUOT;".

    d.  Let _p1_ be the string value that is the concatenation of the
        following string values:

-   The string value of _p1_

-   Code unit U+0020 (SPACE)

-   The string value of _attribute_

-   Code unit U+003D (EQUALS SIGN)

-   Code unit U+0022 (QUOTATION MARK)

-   The string value of _escapedV_

-   Code unit U+0022 (QUOTATION MARK)

1.  Let _p2_ be the string value that is the concatenation of _p1_ and
    ">".

2.  Let _p3_ be the string value that is the concatenation of _p2_ and
    _S_.

3.  Let _p4_ be the string value that is the concatenation of _p3_,
    "</", _tag_, and ">".

4.  Return _p4_.

    1.  String.prototype.big ()

When the BIG method is called with no arguments, the following steps are
taken:

1.  Let _S_ be the THIS value.

2.  Return CreateHTML(_S_, "BIG", "", "").

    1.  String.prototype.blink ()

When the BLINK method is called with no arguments, the following steps
are taken:

1.  Let _S_ be the THIS value.

2.  Return CreateHTML(_S_, "BLINK", "", "").

    1.  String.prototype.bold ()

When the BOLD method is called with no arguments, the following steps
are taken:

1.  Let _S_ be the THIS value.

2.  Return CreateHTML(_S_, "B", "", "").

    1.  String.prototype.fixed ()

When the FIXED method is called with no arguments, the following steps
are taken:

1.  Let _S_ be the THIS value.

2.  Return CreateHTML(_S_, "TT", "", "").

    1.  String.prototype.fontcolor ( color )

When the FONTCOLOR method is called with argument _color_, the following
steps are taken:

1.  Let _S_ be the THIS value.

2.  Return CreateHTML(_S_, "FONT", "COLOR", _color_).

    1.  String.prototype.fontsize ( size )

When the FONTSIZE method is called with argument _size_, the following
steps are taken:

1.  Let _S_ be the THIS value.

2.  Return CreateHTML(_S_, "FONT", "SIZE", _size_).

    1.  String.prototype.italics ()

When the ITALICS method is called with no arguments, the following steps
are taken:

1.  Let _S_ be the THIS value.

2.  Return CreateHTML(_S_, "I", "", "").

    1.  String.prototype.link ( url )

When the LINK method is called with argument _url_, the following steps
are taken:

1.  Let _S_ be the THIS value.

2.  Return CreateHTML(_S_, "A", "HREF", _url_).

    1.  String.prototype.small ()

When the SMALL method is called with no arguments, the following steps
are taken:

1.  Let _S_ be the THIS value.

2.  Return CreateHTML(_S_, "SMALL", "", "").

    1.  String.prototype.strike ()

When the STRIKE method is called with no arguments, the following steps
are taken:

1.  Let _S_ be the THIS value.

2.  Return CreateHTML(_S_, "STRIKE", "", "").

    1.  String.prototype.sub ()

When the SUB method is called with no arguments, the following steps are
taken:

1.  Let _S_ be the THIS value.

2.  Return CreateHTML(_S_, "SUB", "", "").

    1.  String.prototype.sup ()

When the SUP method is called with no arguments, the following steps are
taken:

1.  Let _S_ be the THIS value.

2.  Return CreateHTML(_S_, "SUP", "", "").

    1.  Additional Properties of the Date.prototype Object

        1.  Date.prototype.getYear ( )

NOTE The GETFULLYEAR method is preferred for nearly all purposes,
because it avoids the “year 2000 problem.”

When the GETYEAR method is called with no arguments, the following steps
are taken:

1.  Let _t_ be this time value.

2.  ReturnIfAbrupt(_t_).

3.  If _t_ is NAN, return NAN.

4.  Return YearFromTime(LocalTime(_t_)) − 1900.

    1.  Date.prototype.setYear (year)

NOTE The SETFULLYEAR method is preferred for nearly all purposes,
because it avoids the “year 2000 problem.”

When the SETYEAR method is called with one argument _year_, the
following steps are taken:

1.  Let _t_ be LocalTime(this time value); but if this time value is
    NAN, let _t_ be +0.

2.  Let _y_ be ToNumber(_year_).

3.  ReturnIfAbrupt(_y_).

4.  If _y_ is NAN, set the [[DateValue]] internal slot of this Date
    object to NAN and return NAN.

5.  If _y_ is not NAN and 0 ≤ ToInteger(_y_) ≤ 99 then let _yyyy_ be
    ToInteger(_y_) + 1900. Otherwise, let _yyyy_ be _y_.

6.  Let _d_ be MakeDay(_yyyy_, MonthFromTime(_t_), DateFromTime(_t_)).

7.  Let _date_ be UTC(MakeDate(_d_, TimeWithinDay(_t_))).

8.  Set the [[DateValue]] internal slot of this Date object to
    TimeClip(_date_).

9.  Return the value of the [[DateValue]] internal slot of this Date
    object.

    1.  Date.prototype.toGMTString ( )

NOTE The property TOUTCSTRING is preferred. The TOGMTSTRING property is
provided principally for compatibility with old code. It is recommended
that the TOUTCSTRING property be used in new ECMAScript code.

The Function object that is the initial value of
DATE.PROTOTYPE.TOGMTSTRING is the same Function object that is the
initial value of DATE.PROTOTYPE.TOUTCSTRING.

1.  Additional Properties of the RegExp.prototype Object

    1.  RegExp.prototype.compile (pattern, flags )

When the COMPILE method is called with arguments _pattern_ and _flags_,
the following steps are taken:

1.  Let _O_ be the THIS value.

2.  If Type(_O_) is not Object or Type(_O_) is Object and _O_ does not
    have a [[RegExpMatcher]] internal slot, then

    a.  Throw a TYPEERROR exception.

3.  Let _extensible_ be the result of calling the [[IsExtensible]]
    internal method of _O_.

4.  ReturnIfAbrupt(_extensible_).

5.  If _extensible_ is FALSE, then throw a TYPEERROR exception.

6.  If Type(_pattern_) is Object and _pattern_ has a [[RegExpMatcher]]
    internal slot, then

    a.  If the value of _pattern’s_ [[RegExpMatcher]] internal slot is
        UNDEFINED, then throw a TYPEERROR exception.

    b.  If _flags_ is not UNDEFINED, then throw a TYPEERROR exception.

    c.  Let _P_ be the value of _pattern’s_ [[OriginalSource]] internal
        slot.

    d.  Let _F_ be the value of _pattern’s_ [[OriginalFlags]] internal
        slot.

7.  Else,

    a.  Let _P_ be _pattern_.

    b.  Let _F_ be _flags_.

8.  Return RegExpInitialize(_O,_ _P_, _F_).

NOTE The COMPILE method completely reinitializes the THIS object RegExp
with a new pattern and flags. An implementaton may interpret use of this
method as an assertion that the resulting RegExp object will be used
multiple times and hence is a candidate for extra optimization.

1.  


    Other Additional Features

    1.  __proto__ Property Names in Object Initializers

The following Early Error rule is added to those in 12.2.5.1:

_ObjectLiteral_ : { _PropertyDefinitionList_ }

and

_ObjectLiteral_ : { _PropertyDefinitionList_ , }

-   It is a Syntax Error if PropertyNameList of _PropertyDefinitionList_
    contains any duplicate entries for "__PROTO__" and at least two of
    those entries were obtained from productions of the form
    _PropertyDefinition_ : _PropertyName_ : _AssignmentExpression_.

In 12.2.5.9 the PropertyDefinitionEvaluation algorithm for the
production _PropertyDefinition_ : _PropertyName_ :
_AssignmentExpression_ is replaced with the following:

_PropertyDefinition_ : _PropertyName_ : _AssignmentExpression

1.  Let _propKey_ be the result of evaluating _PropertyName_.

2.  ReturnIfAbrupt(_propKey_).

3.  Let _exprValueRef_ be the result of evaluating
    _AssignmentExpression_.

4.  Let _propValue_ be GetValue(_exprValueRef_).

5.  ReturnIfAbrupt(_propValue_).

6.  If _propKey_ is the string value "__PROTO__" and if
    IsComputedPropertyKey(_propKey_) is FALSE, then

    a.  If Type(_propValue_) is either Object or Null, then

        i.  Return the result of calling the [[SetPrototypeOf]] internal
            method of _object_ with argument _propValue_.

    b.  Return NormalCompletion(empty).

7.  If IsFunctionDefinition(_AssignmentExpression_) is TRUE, then

    a.  Assert: _propValue_ is an ECMAScript function object.

    b.  Let _referencesSuper_ be the value of _propValue_’s
        [[NeedsSuper]] internal slot.

    c.  Let _thisMode_ be the value of _propValue_’s [[ThisMode]]
        internal slot.

    d.  If _thisMode_ is not lexical and _referencesSuper_ is TRUE, then

        i.  If _propValue_’s [[HomeObject]] internal slot is UNDEFINED,
            then

            1.  Assert: _AssignmentExpression_ is not a class definition
                whose constructor references SUPER.

            2.  Set the _propValue_’s [[HomeObject]] internal slot to
                _object_.

            3.  Set the _propValue_’s [[MethodName]] internal slot to
                _propKey_.

    e.  If IsAnonymousFunctionDefinition(_AssignmentExpression_) is
        TRUE, then

        i.  SetFunctionName(_propValue_, _propKey_).

        ii. Assert: SetFunctionName will not return an abrupt
            completion.

8.  Let _desc_ be the Property Descriptor{[[Value]]: _propValue_,
    [[Writable]]: TRUE, [[Enumerable]]: TRUE, [[Configurable]]: TRUE}

9.  Return DefinePropertyOrThrow(_object_, _propKey_, _desc_).

    1.  Labelled Function Declarations

Prior to the Sixth Edition, the ECMAScript specification
_LabelledStatement_ did not allow for the association of a statement
label with a _FunctionDeclaration_. However, a labelled
_FunctionDeclaration_ was an allowable extension for non-strict mode
code and most browser-hosted ECMAScript implementations supported that
extension. In the Sixth Edition, the grammar productions for
_LabelledStatement_ permits use of _FunctionDeclaration_ as a
_LabelledItem_ but 13.12.1 includes an Early Error rule that produces a
Syntax Error if that occurs. For web browser compatibility, that rule is
modified with the addition of the underlined text:

_LabelledItem_ : _FunctionDeclaration

-   It is a Syntax Error if any strict mode source code matches this
    rule.

    1.  Block-Level Function Declarations Web Legacy Compatibility Semantics 

Prior to the Sixth Edition, the ECMAScript specification did not define
the occurrence of a _FunctionDeclaration_ as an element of a _Block_
statement’s _StatementList_. However, support for that form of
_FunctionDeclaration_ was an allowable extension and most browser-hosted
ECMAScript implementations permitted them. Unfortunately, the semantics
of such declarations differ among those implementations. Because of
these semantic differences, existing web ECMAScript code that uses
_Block_ level function declarations is only portable among browser
implementation if the usage only depends upon the semantic intersection
of all of the browser implementations for such declarations. The
following are the use cases that fall within that intersection
semantics:

1.  A function is declared and only referenced within a single block

    -   A function declaration with the name _f_ is declared exactly
        once within the function code of an enclosing function _g_ and
        that declaration is nested within a _Block_.

    -   No other declaration of _f_ that is not a VAR declaration occurs
        within the function code of _g_

    -   All references to _f_ occur within the _StatementList_ of the
        _Block_ containing the declaration of _f_.

2.  A function is declared and possibly used within a single _Block_ but
    also referenced by an inner function definition that is not
    contained within that same _Block_.

    -   A function declaration with the name _f_ is declared exactly
        once within the function code of an enclosing function _g_ and
        that declaration is nested within a _Block_.

    -   No other declaration of _f_ that is not a VAR declaration occurs
        within the function code of _g_

    -   References to _f_ may occur within the _StatementList_ of the
        _Block_ containing the declaration of _f_.

    -   References to _f_ occur within the function code of _g_ that
        lexically follows the _Block_ containing the declaration of _f_.

3.  A function is declared and possibly used within a single block but
    also referenced within subsequent blocks.

    -   A function declaration with the name _f_ is declared exactly
        once within the function code of an enclosing function _g_ and
        that declaration is nested within a _Block_.

    -   No other declaration of _f_ that is not a VAR declaration occurs
        within the function code of _g_

    -   References to _f_ may occur within the _StatementList_ of the
        _Block_ containing the declaration of _f_.

    -   References to _f_ occur within another function _h_ that is
        nested within _g_ and no other declaration of _f_ shadows the
        references to _f_ from within _h_.

    -   All invocations of _h_ occur after the declaration of _f_ has
        been evaluated.

The first use case is interoperable with the semantics of _Block_ level
function declarations provided by ECMA-262 Edition 6. Any pre-existing
ECMAScript code that employees that use case will operate using the
Block level function declarations semantics defined by clauses 9, 13,
and 14 of this specification.

Sixth edition interoperability for the second and third use cases
requires the following extensions to the clause 9 and clause 14
semantics. These extensions are applied to each non-strict mode function
_g_ for each _FunctionDeclaration_ _f_ that is directly contained in the
_StatementList_ of a _Block_, _CaseClause_, or _DefaultClause_ that is
part of the function code of _g_

1.  Let _F_ be StringValue of the _BindingIdentifier_ of
    _FunctionDeclaration_ _f_.

2.  If replacing the _FunctionDeclaration_ _f_ with a
    _VariableStatement_ that has _F_ as a _BindingIdentifier_ would not
    produce any Early Errors for _g_, then

    a.  During FunctionDeclarationInstantiation (9.2.13) for _g_ perform
        the following steps immediately before performing step 25:

        i.  ii. NOTE A var binding for _F_ is only instantiated here if
            it is not also a VarDeclaredName, the name of a formal
            parameter, or another _FunctionDeclarations_.

        iii. If _instantiatedVarNames_ does not contain _F_, then

            1.  Let _status_ be the result of calling _bodyEnv’s_
                CreateMutableBinding concrete method passing _F_ as the
                argument.

            2.  3.  Assert: _status_ is never an abrupt completion.

            4.  Call the InitializeBinding concrete method of _bodyEnv_
                with arguments _F_ and UNDEFINED.

            5.  Append _F_ to _instantiatedVarNames_.

    b.  In place of the _FunctionDeclaration_ Evaluation algorithm
        provide in 14.1.22, perform the following steps to evaluate the
        _FunctionDeclaration_ _f_:

        1.  Let _fenv_ be the running execution context’s
            VariableEnvironment.

        2.  Let _benv_ be the running execution context’s
            LexicalEnvironment.

        3.  Let _fobj_ be the result of calling the GetBindingValue
            concrete method of _benv_ with arguments _F_ and FALSE.

        4.  ReturnIfAbrupt(_fobj_).

        i.  1.  Let _status_ be the result of calling _fenv_’s
                SetMutableBinding concrete method with arguments _F_,
                _fobj_, and FALSE.

            2.  Assert: _status_ is never an abrupt completion.

            3.  Return NormalCompletion(empty).

If an ECMAScript implementation has a mechanism for reporting diagnostic
warning messages, a warning should be produced for each function _g_
whose function code contains a _FunctionDeclaration_ for which steps 2.a
and 2.b above will be performed.

FunctionDeclarations in IfStatement Statement Clauses.

The following rules for _IfStatement_ augment those in 13.5:

IfStatement~[Yield,\ Return]~ :

IF ( Expression~[In,\ ?Yield]~ ) FunctionDeclaration~[?Yield]~ ELSE
Statement~[?Yield,\ ?Return]~
IF ( Expression~[In,\ ?Yield]~ ) Statement~[?Yield,\ ?Return]~ ELSE
FunctionDeclaration~[?Yield]~
IF ( Expression~[In,\ ?Yield]~ ) FunctionDeclaration~[?Yield]~ ELSE
FunctionDeclaration~[?Yield]~
IF ( Expression~[In,\ ?Yield]~ ) FunctionDeclaration~[?Yield]~

The above rules are only applied when parsing non-strict mode code. If
any non-strict code is match by one of these rules subsequent processing
of that code takes places as if each matching occurrence of
_FunctionDeclaration_~[?Yield]~ was the sole _StatementListItem_ of a
_BlockStatement_ occupying that position in the source code. The
semantics of such a synthetic _BlockStatement_ includes the web legacy
compatibility semantics specified in B.3.3.

VariableStatements in Catch blocks

The content of subclause 13.14.1 is replaced with the following:

_Catch_ : CATCH ( _CatchParameter_ ) _Block

-   It is a Syntax Error if any element of the BoundNames of
    _CatchParameter_ also occurs in the LexicallyDeclaredNames of
    _Block_.

-   It is a Syntax Error if any element of the BoundNames of
    _CatchParameter_ also occurs in the VarDeclaredNames of _Block_,
    unless that element is only bound by a _VariableStatment_ or the
    _VariableDeclarationList_ of a for statement, or the _ForBinding_ of
    a for-in statement.

NOTE The _Block_ of a _Catch_ clause may contain VAR declarations that
bind a name that is also bound by the _CatchParameter_. At runtime, such
bindings are instantiated in the VariableDeclarationEnvironment. They do
not shadow the same-named bindings introduced by the _CatchParameter_
and hence the _Initializer_ for such VAR declarations will assign to the
corresponding catch parameter rather than the VAR binding. The
relaxation of the normal static semantic rule does not apply to names
only bound by for-of statements.

(informative)
The Strict Mode of ECMAScript

THE STRICT MODE RESTRICTION AND EXCEPTIONS

-   Use of the identifiers "IMPLEMENTS", "INTERFACE", "PACKAGE",
      "PRIVATE", "PROTECTED", "PUBLIC", and "STATIC" is prohibited
      within strict mode code. (11.6.2.2).

-   A conforming implementation, when processing strict mode code, may
      not extend the syntax of _NumericLiteral_ (11.8.3) to include
      _LegacyOctalIntegerLiteral_ as described in B.1.1.

-   A conforming implementation, when processing strict mode code (see
      10.2.1), may not extend the syntax of _EscapeSequence_ to include
      _LegacyOctalEscapeSequence_ as described in B.1.2.

-   Assignment to an undeclared identifier or otherwise unresolvable
      reference does not create a property in the global object. When a
      simple assignment occurs within strict mode code, its
      _LeftHandSide_ must not evaluate to an unresolvable Reference. If
      it does a REFERENCEERROR exception is thrown (6.2.3.2). The
      _LeftHandSide_ also may not be a reference to a data property with
      the attribute value {[[Writable]]:FALSE}, to an accessor property
      with the attribute value {[[Set]]:UNDEFINED}, nor to a
      non-existent property of an object whose [[Extensible]] internal
      slot has the value FALSE. In these cases a TYPEERROR exception is
      thrown (12.14).

-   The identifier EVAL or ARGUMENTS may not appear as the
      _LeftHandSideExpression_ of an Assignment operator (12.14) or of a
      _PostfixExpression_ (12.14) or as the _UnaryExpression_ operated
      upon by a Prefix Increment (12.5.7) or a Prefix Decrement (12.5.8)
      operator.

-   Arguments objects for strict mode functions define non-configurable
      accessor properties named "CALLER" and "CALLEE" which throw a
      TYPEERROR exception on access (9.2.8).

-   Arguments objects for strict mode functions do not dynamically share
      their array indexed property values with the corresponding formal
      parameter bindings of their functions. (9.4.4).

-   For strict mode functions, if an arguments object is created the
      binding of the local identifier ARGUMENTS to the arguments object
      is immutable and hence may not be the target of an assignment
      expression. (9.2.13).

-   It is a SYNTAXERROR if the _IdentifierName_ EVAL or the
      _IdentifierName_ ARGUMENTS occurs as a _BindingIdentifier_ within
      strict mode code (12.1.1).

-   -   -   Strict mode eval code cannot instantiate variables or
      functions in the variable environment of the caller to eval.
      Instead, a new variable environment is created and that
      environment is used for declaration binding instantiation for the
      eval code (18.2.1).

-   If THIS is evaluated within strict mode code, then the THIS value is
      not coerced to an object. A THIS value of NULL or UNDEFINED is not
      converted to the global object and primitive values are not
      converted to wrapper objects. The THIS value passed via a function
      call (including calls made using FUNCTION.PROTOTYPE.APPLY and
      FUNCTION.PROTOTYPE.CALL) do not coerce the passed this value to an
      object (8.3.2, 12.2.1, 19.2.3.1, 0).

-   When a DELETE operator occurs within strict mode code, a SYNTAXERROR
      is thrown if its _UnaryExpression_ is a direct reference to a
      variable, function argument, or function name (12.5.4).

-   When a DELETE operator occurs within strict mode code, a TYPEERROR
      is thrown if the property to be deleted has the attribute {
      [[Configurable]]:FALSE } (12.5.4).

-   -   Strict mode code may not include a _WithStatement_. The
      occurrence of a _WithStatement_ in such a context is a SYNTAXERROR
      (13.10).

-   It is a SYNTAXERROR if a _TryStatement_ with a _Catch_ occurs within
      strict code and the _Identifier_ of the _Catch_ production is EVAL
      or ARGUMENTS (13.14)

-   -   It is a SYNTAXERROR if the same _BindingIdentifier_ appears more
      than once in the _FormalParameters_ of a strict mode function. An
      attempt to create such a function using a FUNCTION or GENERATOR
      constructor is a SYNTAXERROR (14.1.2, 19.2.1, 25.2.1).

-   An implementation may not extend, beyond that defined in this
      specification, the meanings within strict mode functions of
      properties named CALLER or ARGUMENTS of function instances.
      ECMAScript code may not create or modify properties with these
      names on function objects that correspond to strict mode functions
      (9.2.1, 9.4.4).

-   It is a SYNTAXERROR if the _IdentifierName_ EVAL or the
      _IdentifierName_ ARGUMENTS occurs as as the _BindingIdentifier_ of
      a _FunctionDeclaration,_ _FunctionExpression_,
      _GeneratorDeclaration_, or _GeneratorExpression_ (12.1.1, 14.1.2,
      14.4.1).

(informative)
Corrections and Clarifications with Possible Compatibility Impact


In Edition 6

9.1.4.2.1, 9.1.4.2.2: The 5^th^ Edition moved the capture of the current
array length prior to the integer conversion of the array index or new
length value. However, the captured length value could become invalid if
the conversion process has the side-effect of changing the array length.
The 6^th^ Edition specifies that the current array length must be
captured after the possible occurrence of such side-effects.

20.3.1.14: Previous editions permitted the TimeClip abstract operation
to return either +0 or −0 as the representation of a 0 time value. The
6^th^ Edition specifies that +0 always returned. This means that for the
6^th^ Edition the time value of a Date object is never observably −0 and
methods that return time values never return −0.

20.3.1.15: If a time zone offset is not present, the local time zone is
used. Edition 5.1 incorrectly stated that a missing time zone should be
interpreted as “z”.

20.3.4.36: If the year cannot be represented using the Date Time String
Format specified in 20.3.1.15 a RangeError exception is thrown. Previous
editions did not specify the behaviour for that case.

20.3.4.41: Previous editions did not specify the value returned by
Date.prototype.toString when this time value is NaN. The 6^th^ Edition
specifies the result to be the String value is "INVALID DATE".

21.2.3.1, 21.2.3.3.4: If any LineTerminator code points in the value of
the SOURCE property of an RegExp instance must be expressed using an
escape sequence. Edition 5.1 only required the escaping of "/".

22.1.3.24, 22.1.3.24.1 Previous editions did not specify how a NAN value
returned by a _comparefn_ was interpreted by ARRAY.PROTOTYPE.SORT.
Edition 6 specifies that such as value is treated as if +0 was returned
from the _comparefn_.


In Edition 5.1

Clause references in this list refer to the clause numbers used in
Edition 5.1.

7.8.4: CV definitions added for _DoubleStringCharacter_ ::
_LineContinuation_ and _SingleStringCharacter_ :: _LineContinuation_.

10.2.1.1.3: The argument S is not ignored. It controls whether an
exception is thrown when attempting to set an immutable binding.

10.2.1.2.2: In algorithm step 5, TRUE is passed as the last argument to
[[DefineOwnProperty]].

10.5: Former algorithm step 5.e is now 5.f and a new step 5.e was added
to restore compatibility with 3^rd^ Edition when redefining global
functions.

11.5.3: In the final bullet item, use of IEEE 754 round-to-nearest mode
is specified.

12.6.3: Missing ToBoolean restored in step 3.a.ii of both algorithms.

12.6.4: Additional final sentences in each of the last two paragraphs
clarify certain property enumeration requirements.

12.7, 12.8, 12.9: BNF modified to clarify that a CONTINUE or BREAK
statement without an _Identifier_ or a RETURN statement without an
_Expression_ may have a _LineTerminator_ before the semi-colon.

12.14: Step 3 of algorithm 1 and step 2.a of algorithm 3 are corrected
such that the value field of _B_ is passed as a parameter rather than
_B_ itself.

15.1.2.2: In step 2 of algorithm, clarify that _S_ may be the empty
string.

15.1.2.3: In step 2 of algorithm clarify that _trimmedString_ may be the
empty string.

15.1.3: Added notes clarifying that ECMAScript’s URI syntax is based
upon RFC 2396 and not the newer RFC 3986. In the algorithm for Decode, a
step was removed that immediately preceded the current step 4.d.vii.10.a
because it tested for a condition that cannot occur.

15.2.3.7: Corrected use of variable _P_ in steps 5 and 6 of algorithm.

15.2.4.2: Edition 5 handling of UNDEFINED and NULL as THIS value caused
existing code to fail. Specification modified to maintain compatibility
with such code. New steps 1 and 2 added to the algorithm.

15.3.3.3: Steps 5 and 7 of Edition 5 algorithm have been deleted because
they imposed requirements upon the _argArray_ argument that are
inconsistent with other uses of generic array-like objects.

15.4.3.12: In step 9.a, incorrect reference to _relativeStart_ was
replaced with a reference to _actualStart_.

15.4.3.15: Clarified that the default value for _fromIndex_ is the
length minus 1 of the array.

15.4.3.18: In step 10 (corresponding to step 8 in 5.1) of the algorithm,
UNDEFINED is now the specified return value.

15.4.3.22: In step 11.d.iii (corresponding to 9.c.ii in 5.1) the first
argument to the [[Call]] internal method has been changed to UNDEFINED
for consistency with the definition of Array.prototype.reduce.

15.4.5.1: In Algorithm steps 3.l.ii and 3.l.iii the variable name was
inverted resulting in an incorrectly inverted test.

15.5.4.9: Normative requirement concerning canonically equivalent
strings deleted from paragraph following algorithm because it is listed
as a recommendation in NOTE 2.

15.5.4.14: In split algorithm step 11.a and 13.a, the positional order
of the arguments to _SplitMatch_ was corrected to match the actual
parameter signature of _SplitMatch_. In step 13.a.iii.7.d, _lengthA_
replaces _A_.length.

15.5.5.2: In first paragraph, removed the implication that the
individual character property access had “array index” semantics.
Modified algorithm steps 3 and 5 such that they do not enforce “array
index” requirement.

15.9.1.15: Specified legal value ranges for fields that lacked them.
Eliminated “time-only” formats. Specified default values for all
optional fields.

15.10.2.2: The step numbers of the algorithm for the internal closure
produced by step 2 were incorrectly numbered in a manner that implied
that they were steps of the outer algorithm.

15.10.2.6: In the abstract operation IsWordChar the first character in
the list in step 3 is “A” rather than “A”.

15.10.2.8: In the algorithm for the closure returned by the abstract
operation CharacterSetMatcher, the variable defined by step 3 and passed
as an argument in step 4 was renamed to _ch_ in order to avoid a name
conflict with a formal parameter of the closure.

15.10.6.2: Step 9.e was deleted because It performed an extra increment
of _i_.

15.11.1.1: Removed requirement that the message own property is set to
the empty String when the _message_ argument is UNDEFINED.

15.11.1.2: Removed requirement that the message own property is set to
the empty String when the _message_ argument is UNDEFINED.

15.11.4.4: Steps 6-10 modified/added to correctly deal with missing or
empty message property value.

15.11.1.2: Removed requirement that the message own property is set to
the empty String when the _message_ argument is UNDEFINED.

15.12.3: In step 10.b.iii of the _JA_ abstract operation, the last
element of the concatenation is “]”.

B.2.1: Added to NOTE that the encoding is based upon RFC 1738 rather
than the newer RFC 3986.

Annex C: An item was added corresponding to 7.6.12 regarding
_FutureReservedWords_ in strict mode.


In Edition 5

Clause references in this list refer to the clause numbers used in
Edition 5.

Throughout: In the Edition 3 specification the meaning of phrases such
as “as if by the expression NEW ARRAY()” are subject to
misinterpretation. In the Edition 5 specification text for all internal
references and invocations of standard built-in objects and methods has
been clarified by making it explicit that the intent is that the actual
built-in object is to be used rather than the current dynamically
resolved value of the correspondingly identifier binding.

11.8.1: ECMAScript generally uses a left to right evaluation order,
however the Edition 3 specification language for the > and <= operators
resulted in a partial right to left order. The specification has been
corrected for these operators such that it now specifies a full left to
right evaluation order. However, this change of order is potentially
observable if side-effects occur during the evaluation process.

11.1.4: Edition 5 clarifies the fact that a trailing comma at the end of
an _ArrayInitialiser_ does not add to the length of the array. This is
not a semantic change from Edition 3 but some implementations may have
previously misinterpreted this.

11.2.3: Edition 5 reverses the order of steps 2 and 3 of the algorithm.
The original order as specified in Editions 1 through 3 was incorrectly
specified such that side-effects of evaluating _Arguments_ could affect
the result of evaluating _MemberExpression_.

12.4: In Edition 3, an object is created, as if by NEW OBJECT()to serve
as the scope for resolving the name of the exception parameter passed to
a CATCH clause of a TRY statement. If the actual exception object is a
function and it is called from within the CATCH clause, the scope object
will be passed as the THIS value of the call. The body of the function
can then define new properties on its THIS value and those property
names become visible identifiers bindings within the scope of the CATCH
clause after the function returns. In Edition 5, when an exception
parameter is called as a function, UNDEFINED is passed as the THIS
value.

(informative)
Additions and Changes That
Introduce Incompatibilities with Prior Editions


In the 6^th^ Edition

9: In Edition 6, Function calls are not allowed to return a Reference
value.

12.2.5.1: Early error relating to duplicate property names in Object
Initializers have been eliminated in Editon 6.

13.6: In Edition 6, a terminating semi-colon is no longer required at
the end of a do-while statement.

13.6: Prior to Edition 6, an initialization expression could appear as
part of the _VariableDeclaration_ that precedes the IN keyword. The
value of that expression was always discarded. In Edition 6, the
_ForBind_ in that same position does not allow the occurance of such an
initializer.

13.14: In Edition 6, it is an early error for a _Catch_ clause to
contained a VAR declaration for the same _Identifier_ that appears as
the _Catch_ clause parameter. In previous editions, such a variable
declaration would be instantiated in the enclosing variable environment
but the declaration’s _Initializer_ value would be assigned to the
_Catch_ parameter.

14.3 In Edition 6, the function objects that are created as the values
of the [[Get]] or [[Set]] attribute of accessor properties in an
_ObjectLiteral_ are not constructor functions. In Edition 5, they were
constructors.

19.1.2.2 and 19.1.2.3: In Edition 6, all property additions and changes
are processed, even if one of them throws an exception. If an exception
occurs during such processing, the first such exception is thrown after
all propertie are processed. In Edition 5, processing of property
additions and changes immediately terminated when the first exception
occurred.

19.1.2.5: In Edition 6, if the argument to OBJECT.FREEZE is not an
object it is treated as if it was a non-extensible ordinary object with
no own properties. In Edition 5, a non-object argument always causes a
TYPEERROR to be thrown.

19.1.2.6: In Edition 6, if the argument to
OBJECT.GETOWNPROPERTYDESCRIPTOR is not an object an attempt is make to
coerce the argument using ToObject. If the coerecion is successful the
result is used in place of the original argument value. In Edition 5, a
non-object argument always causes a TYPEERROR to be thrown.

19.1.2.7: In Edition 6, if the argument to OBJECT.GETOWNPROPERTYNAMES is
not an object an attempt is make to coerce the argument using ToObject.
If the coerecion is successful the result is used in place of the
original argument value. In Edition 5, a non-object argument always
causes a TYPEERROR to be thrown.

19.1.2.9: In Edition 6, if the argument to OBJECT.GETPROTOTYPEOF is not
an object an attempt is make to coerce the argument using ToObject. If
the coerecion is successful the result is used in place of the original
argument value. In Edition 5, a non-object argument always causes a
TYPEERROR to be thrown.

19.1.2.11: In Edition 6, if the argument to OBJECT.ISEXTENSIBLE is not
an object it is treated as if it was a non-extensible ordinary object
with no own properties. In Edition 5, a non-object argument always
causes a TYPEERROR to be thrown.

19.1.2.12: In Edition 6, if the argument to OBJECT.ISFROZEN is not an
object it is treated as if it was a non-extensible ordinary object with
no own properties. In Edition 5, a non-object argument always causes a
TYPEERROR to be thrown.

19.1.2.13: In Edition 6, if the argument to OBJECT.ISSEALED is not an
object it is treated as if it was a non-extensible ordinary object with
no own properties. In Edition 5, a non-object argument always causes a
TYPEERROR to be thrown.

19.1.2.14: In Edition 6, if the argument to OBJECT.KEYS is not an object
an attempt is make to coerce the argument using ToObject. If the
coerecion is successful the result is used in place of the original
argument value. In Edition 5, a non-object argument always causes a
TYPEERROR to be thrown.

19.1.2.15: In Edition 6, if the argument to OBJECT.PREVENTEXTENSIONS is
not an object it is treated as if it was a non-extensible ordinary
object with no own properties. In Edition 5, a non-object argument
always causes a TYPEERROR to be thrown.

19.1.2.17: In Edition 6, if the argument to OBJECT.SEAL is not an object
it is treated as if it was a non-extensible ordinary object with no own
properties. In Edition 5, a non-object argument always causes a
TYPEERROR to be thrown.

19.2.4.1: In Edition 6, the LENGTH property of function instances is
configurable. In previous editions it was non-configurable.

19.3.3 In Edition 6, the Boolean prototype object is not a Boolean
instance. In previous editions it was a Boolean instance whose Boolean
value was FALSE.

20.1.3 In Edition 6, the Number prototype object is not a Number
instance. In previous editions it was a Number instance whose number
value was +0.

20.3.4 In Edition 6, the Date prototype object is not a Date instance.
In previous editions it was a Date instance whose TimeValue was NaN.

22.1.3 In Edition 6, the Array prototype object is not an Array
instance. In previous editions it was an Array instance with a length
property whose value was +0.

21.1.3 In Edition 6, the String prototype object is not a String
instance. In previous editions it was a String instance whose String
value was the empty string.

21.1.3.22 and 21.1.3.24 In Edition 6, lowercase/upper conversion
processing operates on code points. In previous editions such the
conversion processing was only applied to individual code units. The
only affected code points are those in the Deseret block of Unicode

21.1.3.25 In Edition 6, the STRING.PROTOTYPE.TRIM method is defined to
recognize white space code points that may exists outside of the Unicode
BMP. However, as of Unicode 6.1 no such code points are defined. In
previous editions such code points would not have been recognized as
white space.

21.2.5 In Edition 6, the RegExp prototype object is not a RegExp
instance. In previous editions it was a RegExp instance whose pattern is
the empty string.

21.2.5 In Edition 6, SOURCE, GLOBAL, IGNORECASE, and MULTILINE are
accessor properties defined on the RegExp prototype object. In previous
editions they were data properties defined on RegExp instances.

22.1.3 In Edition 6, the Array prototype object is not an Array
instance. In previous editions it was an Array instance with a length
property whose value was +0.


In the 5^th^ Edition

Clause references in this list refer to the clause numbers used in
Edition 5 and 5.1.

7.1: Unicode format control s are no longer stripped from ECMAScript
source text before processing. In Edition 5, if such a character appears
in a _StringLiteral_ or _RegularExpressionLiteral_ the character will be
incorporated into the literal where in Edition 3 the character would not
be incorporated into the literal.

7.2: Unicode character <BOM> is now treated as whitespace and its
presence in the middle of what appears to be an identifier could result
in a syntax error which would not have occurred in Edition 3

7.3: Line terminator characters that are preceded by an escape sequence
are now allowed within a string literal token. In Edition 3 a syntax
error would have been produced.

7.8.5: Regular expression literals now return a unique object each time
the literal is evaluated. This change is detectable by any programs that
test the object identity of such literal values or that are sensitive to
the shared side effects.

7.8.5: Edition 5 requires early reporting of any possible RegExp
constructor errors that would be produced when converting a
_RegularExpressionLiteral_ to a RegExp object. Prior to Edition 
implementations were permitted to defer the reporting of such errors
until the actual execution time creation of the object.

7.8.5: In Edition 5 unescaped “/” characters may appear as a
_CharacterClass_ in a regular expression literal. In Edition 3 such a
character would have been interpreted as the final character of the
literal.

10.4.2: In Edition 5, indirect calls to the EVAL function use the global
environment as both the variable environment and lexical environment for
the eval code. In Edition 3, the variable and lexical environments of
the caller of an indirect EVAL was used as the environments for the eval
code.

15.4.3: In Edition 5 all methods of ARRAY.PROTOTYPE are intentionally
generic. In Edition 3 TOSTRING and TOLOCALESTRING were not generic and
would throw a TYPEERROR exception if applied to objects that were not
instances of Array.

10.6: In Edition 5 the array indexed properties of argument objects that
correspond to actual formal parameters are enumerable. In Edition 3,
such properties were not enumerable.

10.6: In Edition 5 the value of the [[Class]] internal slot of an
arguments object is "ARGUMENTS". In Edition 3, it was "OBJECT". This is
observable if TOSTRING is called as a method of an arguments object.

12.6.4: for-in statements no longer throw a TYPEERROR if the IN
expression evaluates to NULL or UNDEFINED. Instead, the statement
behaves as if the value of the expression was an object with no
enumerable properties.

15: In Edition 5, the following new properties are defined on built-in
objects that exist in Edition 3: OBJECT.GETPROTOTYPEOF,
OBJECT.GETOWNPROPERTYDESCRIPTOR, OBJECT.GETOWNPROPERTYNAMES,
OBJECT.CREATE, OBJECT.DEFINEPROPERTY, OBJECT.DEFINEPROPERTIES,
OBJECT.SEAL, OBJECT.FREEZE, OBJECT.PREVENTEXTENSIONS, OBJECT.ISSEALED,
OBJECT.ISFROZEN, OBJECT.ISEXTENSIBLE, OBJECT.KEYS,
FUNCTION.PROTOTYPE.BIND, ARRAY.PROTOTYPE.INDEXOF,
ARRAY.PROTOTYPE.LASTINDEXOF, ARRAY.PROTOTYPE.EVERY,
ARRAY.PROTOTYPE.SOME, ARRAY.PROTOTYPE.FOREACH, ARRAY.PROTOTYPE.MAP,
ARRAY.PROTOTYPE.FILTER, ARRAY.PROTOTYPE.REDUCE,
ARRAY.PROTOTYPE.REDUCERIGHT, STRING.PROTOTYPE.TRIM, DATE.NOW,
DATE.PROTOTYPE.TOISOSTRING, DATE.PROTOTYPE.TOJSON.

15: Implementations are now required to ignore extra arguments to
standard built-in methods unless otherwise explicitly specified. In
Edition 3 the handling of extra arguments was unspecified and
implementations were explicitly allowed to throw a TYPEERROR exception.

15.1.1: The value properties NAN, INFINITY, and UNDEFINED of the Global
Object have been changed to be read-only properties.

15.1.2.1. Implementations are no longer permitted to restrict the use of
eval in ways that are not a direct call. In addition, any invocation of
eval that is not a direct call uses the global environment as its
variable environment rather than the caller’s variable environment.

15.1.2.2: The specification of the function PARSEINT no longer allows
implementations to treat Strings beginning with a 0 as octal values.

15.3.3.3: In Edition 3, a TYPEERROR is thrown if the second argument
passed to FUNCTION.PROTOTYPE.APPLY is neither an array object nor an
arguments object. In Edition 5, the second argument may be any kind of
generic array-like object that has a valid LENGTH property.

15.3.3.3, 15.3.3.4: In Edition 3 passing UNDEFINED or NULL as the first
argument to either FUNCTION.PROTOTYPE.APPLY or FUNCTION.PROTOTYPE.CALL
causes the global object to be passed to the indirectly invoked target
function as the THIS value. If the first argument is a primitive value
the result of calling ToObject on the primitive value is passed as the
THIS value. In Edition 5, these transformations are not performed and
the actual first argument value is passed as the THIS value. This
difference will normally be unobservable to existing ECMAScript Edition
3 code because a corresponding transformation takes place upon
activation of the target function. However, depending upon the
implementation, this difference may be observable by host object
functions called using APPLY or CALL. In addition, invoking a standard
built-in function in this manner with NULL or UNDEFINED passed as the
THIS value will in many cases cause behaviour in Edition 5
implementations that differ from Edition 3 behaviour. In particular, in
Edition 5 built-in functions that are specified to actually use the
passed THIS value as an object typically throw a TYPEERROR exception if
passed NULL or UNDEFINED as the THIS value.

15.3.4.2: In Edition 5, the PROTOTYPE property of Function instances is
not enumerable. In Edition 3, this property was enumerable.

15.5.5.2: In Edition 5, the individual characters of a String object’s
[[StringData]] may be accessed as array indexed properties of the String
object. These properties are non-writable and non-configurable and
shadow any inherited properties with the same names. In Edition 3, these
properties did not exist and ECMAScript code could dynamically add and
remove writable properties with such names and could access inherited
properties with such names.

15.9.4.2: DATE.PARSE is now required to first attempt to parse its
argument as an ISO format string. Programs that use this format but
depended upon implementation specific behaviour (including failure) may
behave differently.

15.10.2.12: In Edition 5, \S now additionally matches <BOM>.

15.10.4.1: In Edition 3, the exact form of the String value of the
SOURCE property of an object created by the REGEXP constructor is
implementation defined. In Edition 5, the String must conform to certain
specified requirements and hence may be different from that produced by
an Edition 3 implementation.

15.10.6.4: In Edition 3, the result of REGEXP.PROTOTYPE.TOSTRING need
not be derived from the value of the RegExp object’s SOURCE property. In
Edition 5 the result must be derived from the SOURCE property in a
specified manner and hence may be different from the result produced by
an Edition 3 implementation.

15.11.2.1, 15.11.4.3: In Edition 5, if an initial value for the MESSAGE
property of an Error object is not specified via the ERROR constructor
the initial value of the property is the empty String. In Edition 3,
such an initial value is implementation defined.

15.11.4.4: In Edition 3, the result of ERROR.PROTOTYPE.TOSTRING is
implementation defined. In Edition 5, the result is fully specified and
hence may differ from some Edition 3 implementations.

15.12: In Edition 5, the name JSON is defined in the global environment.
In Edition 3, testing for the presence of that name will show it to be
UNDEFINED unless it is defined by the program or implementation.

Bibliography

ISO 8601:2004(E) _Data elements and interchange formats – Information
interchange_ — _Representation of dates and times_

RFC 1738 “Uniform Resource Locators (URL)”, available at
<_http://tools.ietf.org/html/rfc1738_>

RFC 2396 “Uniform Resource Identifiers (URI): Generic Syntax”, available
at <_http://tools.ietf.org/html/rfc2396_>

RFC 3629 “UTF-8, a transformation format of ISO 10646”, available at
<_http://tools.ietf.org/html/rfc3629_>

RFC 4627 “The application/json Media Type for JavaScript Object Notation
(JSON)” , available at <_http://tools.ietf.org/html/rfc4627_>

Unicode Inc. (2010), Unicode Technical Report #15: “Unicode
Normalization Forms”, available at
<_http://www.unicode.org/reports/tr15/tr15-29.html_>

[1] Note: Please note that for ECMAScript Edition 4 the Ecma standard
number “ECMA-262 Edition 4” was reserved but not used in the Ecma
publication process. Therefore “ECMA-262 Edition 4” as an Ecma
International publication does not exist.
