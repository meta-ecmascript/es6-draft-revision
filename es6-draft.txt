Contents Page

Introduction vii

1 Scope 1

2 Conformance 1

3 _Normative references_ 1

4 Overview 1

4.1 _Web Scripting_ 2

4.2 _Language Overview_ 2

4.2.1 Objects 3

4.2.2 _The Strict Variant of ECMAScript_ 4

4.3 _Terms and definitions_ 4

5 _Notational Conventions_ 7

5.1 _Syntactic and Lexical Grammars_ 7

5.1.1 _Context-Free Grammars_ 7

5.1.2 _The Lexical and RegExp Grammars_ 8

5.1.3 _The Numeric String Grammar_ 8

5.1.4 _The Syntactic Grammar_ 8

5.1.5 _The JSON Grammar_ 9

5.1.6 _Grammar Notation_ 9

5.2 _Algorithm Conventions_ 12

_5.3 Static Semantic Rules_ 13

6 _Source Text_ 13

7 _Lexical Conventions_ 14

7.1 _Unicode Format-Control Characters_ 14

7.2 _White Space_ 15

7.3 _Line Terminators_ 15

7.4 Comments 16

7.5 Tokens 17

7.6 _Identifier Names and Identifiers_ 17

7.6.1 _Reserved Words_ 19

7.7 Punctuators 20

7.8 Literals 20

7.8.1 _Null Literals_ 20

7.8.2 _Boolean Literals_ 20

7.8.3 _Numeric Literals_ 21

7.8.4 _String Literals_ 23

7.8.5 _Regular Expression Literals_ 25

7.9 _Automatic Semicolon Insertion_ 26

7.9.1 _Rules of Automatic Semicolon Insertion_ 26

7.9.2 _Examples of Automatic Semicolon Insertion_ 27

8 Types 29

8.1 _The Undefined Type_ 29

8.2 _The Null Type_ 29

8.3 _The Boolean Type_ 29

8.4 _The String Type_ 29

8.5 _The Number Type_ 30

8.6 _The Object Type_ 31

8.6.1 _Property Attributes_ 31

8.6.2 _Object Internal Properties and Methods_ 32

8.7 _The Reference Specification Type_ 36

8.7.1 _GetValue (V)_ 37

8.7.2 _PutValue (V, W)_ 37

8.8 _The List Specification Type_ 38

8.9 _The Completion Specification Type_ 38

8.10 _The Property Descriptor and Property Identifier Specification
Types_ 38

8.10.1 _IsAccessorDescriptor ( Desc )_ 39

8.10.2 _IsDataDescriptor ( Desc )_ 39

8.10.3 _IsGenericDescriptor ( Desc )_ 39

8.10.4 _FromPropertyDescriptor ( Desc )_ 39

8.10.5 _ToPropertyDescriptor ( Obj )_ 40

8.11 _The Lexical Environment and Environment Record Specification
Types_ 40

8.12 _Algorithms for Object Internal Methods_ 40

8.12.1 _[[GetOwnProperty]] (P)_ 40

8.12.2 _[[GetProperty]] (P)_ 41

8.12.3 _[[Get]] (P)_ 41

8.12.4 _[[CanPut]] (P)_ 41

8.12.5 _[[Put]] ( P, V, Throw )_ 41

8.12.6 _[[HasProperty]] (P)_ 42

8.12.7 _[[Delete]] (P, Throw)_ 42

8.12.8 _[[DefaultValue]] (hint)_ 42

8.12.9 _[[DefineOwnProperty]] (P, Desc, Throw)_ 43

9 _Type Conversion and Testing_ 44

9.1 ToPrimitive 44

9.2 ToBoolean 44

9.3 ToNumber 45

9.3.1 _ToNumber Applied to the String Type_ 45

9.4 ToInteger 48

9.5 _ToInt32: (Signed 32 Bit Integer)_ 48

9.6 _ToUint32: (Unsigned 32 Bit Integer)_ 48

9.7 _ToUint16: (Unsigned 16 Bit Integer)_ 49

9.8 ToString 49

9.8.1 _ToString Applied to the Number Type_ 49

9.9 ToObject 50

9.10 CheckObjectCoercible 50

9.11 IsCallable 51

9.12 _The SameValue Algorithm_ 51

10 _Executable Code and Execution Contexts_ 51

10.1 _Types of Executable Code_ 51

10.1.1 _Strict Mode Code_ 52

10.1.2 _Extended Code_ 52

10.2 _Lexical Environments_ 53

10.2.1 _Environment Records_ 53

10.2.2 _Lexical Environment Operations_ 57

10.2.3 _The Global Environment_ 58

10.3 _Execution Contexts_ 58

10.3.1 _Identifier Resolution_ 59

10.4 _Establishing an Execution Context_ 59

10.4.1 _Entering Global Code_ 59

10.4.2 _Entering Eval Code_ 60

10.4.3 _Entering Function Code_ 60

10.5 _Declaration Binding Instantiation_ 61

10.5.1 _Base Code Top-Level Declaration Instantiation_ 61

10.5.2 _Extended Code Top-Level Declaration Instantiation_ 61

10.5.3 _Function Declaration Instantiation_ 61

10.5.4 _Block Declaration Instantiation_ 63

10.6 _Arguments Object_ 63

11 Expressions 66

11.1 _Primary Expressions_ 66

11.1.1 _The this Keyword_ 66

11.1.2 _Identifier Reference_ 66

11.1.3 _Literal Reference_ 67

11.1.4 _Array Initialiser_ 67

11.1.5 _Object Initialiser_ 69

11.1.6 _Function Expressions_ 74

11.1.7 _The Grouping Operator_ 74

11.2 _Left-Hand-Side Expressions_ 74

11.2.1 _Property Accessors_ 75

11.2.2 _The new Operator_ 76

11.2.3 _Function Calls_ 76

11.2.3 _The super Keyword_ 76

11.2.5 _Argument Lists_ 77

11.3 _Postfix Expressions_ 78

11.3.1 _Postfix Increment Operator_ 79

11.3.2 _Postfix Decrement Operator_ 79

11.4 _Unary Operators_ 80

11.4.1 _The delete Operator_ 80

11.4.2 _The void Operator_ 81

11.4.3 _The typeof Operator_ 81

11.4.4 _Prefix Increment Operator_ 81

11.4.5 _Prefix Decrement Operator_ 82

11.4.6 _Unary + Operator_ 82

11.4.7 _Unary - Operator_ 82

11.4.8 _Bitwise NOT Operator ( ~ )_ 82

11.4.9 _Logical NOT Operator ( ! )_ 82

11.5 _Multiplicative Operators_ 83

11.5.1 _Applying the * Operator_ 83

11.5.2 _Applying the / Operator_ 83

11.5.3 _Applying the % Operator_ 84

11.6 _Additive Operators_ 84

11.6.1 _The Addition operator ( + )_ 85

11.6.2 _The Subtraction Operator ( - )_ 85

11.6.3 _Applying the Additive Operators to Numbers_ 85

11.7 _Bitwise Shift Operators_ 86

11.7.1 _The Left Shift Operator ( << )_ 86

11.7.2 _The Signed Right Shift Operator ( >> )_ 86

11.7.3 _The Unsigned Right Shift Operator ( >>> )_ 87

11.8 _Relational Operators_ 87

_11.8.1 Runtime Semantics_ 87

11.9 _Equality Operators_ 89

_11.9.1 Runtime Semantics_ 90

11.10 _Binary Bitwise Operators_ 92

11.11 _Binary Logical Operators_ 93

11.12 _Conditional Operator ( ? : )_ 94

11.13 _Assignment Operators_ 94

_Static Semantics_ 94

_Runtime Semantics_ 95

_11.13.1 Destructuring Assignment_ 96

11.14 _Comma Operator ( , )_ 99

12 _Statements and Declarations_ 100

12.1 Block 101

12.2 _Declarations and the Variable Statement_ 104

12.2.1 _Let Declaration_ 104

12.2.2 _Const Declaration_ 107

12.2.3 _Variable Statement_ 108

12.2.4 _Destructuring Binding Patterns_ 110

12.3 _Empty Statement_ 116

12.4 _Expression Statement_ 116

12.5 _The if Statement_ 116

12.6 _Iteration Statements_ 117

12.6.1 _The do-while Statement_ 117

12.6.2 _The while Statement_ 117

12.6.3 _The for Statement_ 118

12.6.4 _The for-in Statement_ 119

12.7 _The continue Statement_ 120

12.8 _The break Statement_ 120

12.9 _The return Statement_ 121

12.10 _The with Statement_ 121

12.11 _The switch Statement_ 122

12.12 _Labelled Statements_ 126

12.13 _The throw Statement_ 126

12.14 _The try Statement_ 127

12.15 _The debugger statement_ 129

13 _Function Definition_ 129

13.2 _Creating Function Objects_ 134

13.2.1 [[Call]] 135

13.2.2 [[Construct]] 135

13.2.3 _The [[ThrowTypeError]] Function Object_ 136

14 Program 136

14.1 _Directive Prologues and the Use Strict Directive_ 137

15 _Standard Built-in ECMAScript Objects_ 137

15.1 _The Global Object_ 138

15.1.1 _Value Properties of the Global Object_ 139

15.1.2 _Function Properties of the Global Object_ 139

15.1.3 _URI Handling Function Properties_ 141

15.1.4 _Constructor Properties of the Global Object_ 145

15.1.5 _Other Properties of the Global Object_ 146

15.2 _Object Objects_ 146

15.2.1 _The Object Constructor Called as a Function_ 146

15.2.2 _The Object Constructor_ 147

15.2.3 _Properties of the Object Constructor_ 147

15.2.4 _Properties of the Object Prototype Object_ 150

15.2.5 _Properties of Object Instances_ 152

15.3 _Function Objects_ 152

15.3.1 _The Function Constructor Called as a Function_ 152

15.3.2 _The Function Constructor_ 152

15.3.3 _Properties of the Function Constructor_ 153

15.3.4 _Properties of the Function Prototype Object_ 154

15.3.5 _Properties of Function Instances_ 156

15.4 _Array Objects_ 157

15.4.1 _The Array Constructor Called as a Function_ 158

15.4.2 _The Array Constructor_ 158

15.4.3 _Properties of the Array Constructor_ 159

15.4.4 _Properties of the Array Prototype Object_ 159

15.4.5 _Properties of Array Instances_ 175

15.5 _String Objects_ 177

15.5.1 _The String Constructor Called as a Function_ 177

15.5.2 _The String Constructor_ 177

15.5.3 _Properties of the String Constructor_ 177

15.5.4 _Properties of the String Prototype Object_ 178

15.5.5 _Properties of String Instances_ 187

15.6 _Boolean Objects_ 188

15.6.1 _The Boolean Constructor Called as a Function_ 188

15.6.2 _The Boolean Constructor_ 188

15.6.3 _Properties of the Boolean Constructor_ 188

15.6.4 _Properties of the Boolean Prototype Object_ 188

15.6.5 _Properties of Boolean Instances_ 189

15.7 _Number Objects_ 189

15.7.1 _The Number Constructor Called as a Function_ 189

15.7.2 _The Number Constructor_ 189

15.7.3 _Properties of the Number Constructor_ 189

15.7.4 _Properties of the Number Prototype Object_ 190

15.7.5 _Properties of Number Instances_ 194

15.8 _The Math Object_ 194

15.8.1 _Value Properties of the Math Object_ 195

15.8.2 _Function Properties of the Math Object_ 196

15.9 _Date Objects_ 200

15.9.1 _Overview of Date Objects and Definitions of Abstract
Operators_ 200

15.9.2 _The Date Constructor Called as a Function_ 205

15.9.3 _The Date Constructor_ 206

15.9.4 _Properties of the Date Constructor_ 207

15.9.5 _Properties of the Date Prototype Object_ 208

15.9.6 _Properties of Date Instances_ 215

15.10 _RegExp (Regular Expression) Objects_ 215

15.10.1 Patterns 215

15.10.2 _Pattern Semantics_ 217

15.10.3 _The RegExp Constructor Called as a Function_ 229

15.10.4 _The RegExp Constructor_ 229

15.10.5 _Properties of the RegExp Constructor_ 230

15.10.6 _Properties of the RegExp Prototype Object_ 230

15.10.7 _Properties of RegExp Instances_ 232

15.11 _Error Objects_ 233

15.11.1 _The Error Constructor Called as a Function_ 233

15.11.2 _The Error Constructor_ 233

15.11.3 _Properties of the Error Constructor_ 233

15.11.4 _Properties of the Error Prototype Object_ 234

15.11.5 _Properties of Error Instances_ 234

15.11.6 _Native Error Types Used in This Standard_ 234

15.11.7 NativeError Object Structure 235

15.12 _The JSON Object_ 237

15.12.1 _The JSON Grammar_ 237

15.12.2 _parse ( text [ , reviver ] )_ 238

15.12.3 _stringify ( value [ , replacer [ , space ] ] )_ 240

16 Errors 243

_Annex A (informative) Grammar Summary_ 246

A.1 _Lexical Grammar_ 246

A.2 _Number Conversions_ 252

A.3 Expressions 253

A.4 Statements 257

A.5 _Functions and Programs_ 259

A.6 _Universal Resource Identifier Character Classes_ 260

A.7 _Regular Expressions_ 260

A.8 JSON 263

A.8.1 _JSON Lexical Grammar_ 263

A.8.2 _JSON Syntactic Grammar_ 263

_Annex B (normative) Additional ECMAScript Features for Web Browsers_
266

B.1 _Additional Syntax_ 266

B.1.1 _Numeric Literals_ 266

B.1.2 _String Literals_ 266

B.2 _Additional Properties_ 267

B.2.1 _escape (string)_ 267

B.2.2 _unescape (string)_ 268

B.2.3 _String.prototype.substr (start, length)_ 269

B.2.4 _Date.prototype.getYear ( )_ 269

B.2.5 _Date.prototype.setYear (year)_ 269

B.2.6 _Date.prototype.toGMTString ( )_ 269

_Annex C (informative) The Strict Mode of ECMAScript_ 270

_Annex D (informative) Corrections and Clarifications in the 5^th^
Edition with Possible 3^rd^ Edition Compatibility Impact_ 272

_Annex E (informative) Additions and Changes in the 5^th^ Edition that
Introduce Incompatibilities with the 3^rd^ Edition_ 274

_Annex F (informative) Technically Significant Corrections and
Clarifications in the 5.1 Edition_ 278

Introduction

This Ecma Standard is based on several originating technologies, the
most well known being JavaScript (Netscape) and JScript (Microsoft). The
language was invented by Brendan Eich at Netscape and first appeared in
that company’s Navigator 2.0 browser. It has appeared in all subsequent
browsers from Netscape and in all browsers from Microsoft starting with
Internet Explorer 3.0.

The development of this Standard started in November 1996. The first
edition of this Ecma Standard was adopted by the Ecma General Assembly
of June 1997.

That Ecma Standard was submitted to ISO/IEC JTC 1 for adoption under the
fast-track procedure, and approved as international standard ISO/IEC
16262, in April 1998. The Ecma General Assembly of June 1998 approved
the second edition of ECMA-262 to keep it fully aligned with ISO/IEC
16262. Changes between the first and the second edition are editorial in
nature.

The third edition of the Standard introduced powerful regular
expressions, better string handling, new control statements, try/catch
exception handling, tighter definition of errors, formatting for numeric
output and minor changes in anticipation of forthcoming
internationalisation facilities and future language growth. The third
edition of the ECMAScript standard was adopted by the Ecma General
Assembly of December 1999 and published as ISO/IEC 16262:2002 in June
2002.

Since publication of the third edition, ECMAScript has achieved massive
adoption in conjunction with the World Wide Web where it has become the
programming language that is supported by essentially all web browsers.
Significant work was done to develop a fourth edition of ECMAScript.
Although that work was not completed and not published[1] as the fourth
edition of ECMAScript, it informs continuing evolution of the language.
The fifth edition of ECMAScript (published as ECMA-262 5^th^ edition)
codifies de facto interpretations of the language specification that
have become common among browser implementations and adds support for
new features that have emerged since the publication of the third
edition. Such features include accessor properties, reflective creation
and inspection of objects, program control of property attributes,
additional array manipulation functions, support for the JSON object
encoding format, and a strict mode that provides enhanced error checking
and program security.

The edition 5.1 of the ECMAScript Standard has been fully aligned with
the third edition of the international standard ISO/IEC 16262:2011.

This present sixth edition of the Standard………

ECMAScript is a vibrant language and the evolution of the language is
not complete. Significant technical enhancement will continue with
future editions of this specification.

This Ecma Standard has been adopted by the General Assembly of <month>
<year>.

"DISCLAIMER

_This draft document may be copied and furnished to others, and
derivative works that comment on or otherwise explain it or assist in
its implementation may be prepared, copied, published, and distributed,
in whole or in part, without restriction of any kind, provided that the
above copyright notice and this section are included on all such copies
and derivative works. However, this document itself may not be modified
in any way, including by removing the copyright notice or references to
Ecma International, except as needed for the purpose of developing any
document or deliverable produced by Ecma International._

_This disclaimer is valid only prior to final version of this document.
After approval all rights on the standard are reserved by Ecma
International._

_The limited permissions are granted through the standardization phase
and will not be revoked by Ecma International or its successors or
assigns during this time._

_This document and the information contained herein is provided on an
"AS IS" basis and ECMA INTERNATIONAL DISCLAIMS ALL WARRANTIES, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
THE INFORMATION HEREIN WILL NOT INFRINGE ANY OWNERSHIP RIGHTS OR ANY
IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE."_

ECMAScript Language Specification



SCOPE


This Standard defines the ECMAScript scripting language.



CONFORMANCE


A conforming implementation of ECMAScript must provide and support all
the types, values, objects, properties, functions, and program syntax
and semantics described in this specification.

A conforming implementation of this Standard shall interpret characters
in conformance with the Unicode Standard, Version 3.0 or later and
ISO/IEC 10646-1 with either UCS-2 or UTF-16 as the adopted encoding
form, implementation level 3. If the adopted ISO/IEC 10646-1 subset is
not otherwise specified, it is presumed to be the BMP subset, collection
300. If the adopted encoding form is not otherwise specified, it
presumed to be the UTF-16 encoding form.

A conforming implementation of ECMAScript is permitted to provide
additional types, values, objects, properties, and functions beyond
those described in this specification. In particular, a conforming
implementation of ECMAScript is permitted to provide properties not
described in this specification, and values for those properties, for
objects that are described in this specification.

A conforming implementation of ECMAScript is permitted to support
program and regular expression syntax not described in this
specification. In particular, a conforming implementation of ECMAScript
is permitted to support program syntax that makes use of the “future
reserved words” listed in 7.6.1.2 of this specification.



NORMATIVE REFERENCES


The following referenced documents are indispensable for the application
of this document. For dated references, only the edition cited applies.
For undated references, the latest edition of the referenced document
(including any amendments) applies.

ISO/IEC 9899:1996_, Programming Languages – C, including amendment 1 and
technical corrigenda 1 and 2_

ISO/IEC 10646-1:1993_, Information Technology – Universal Multiple-Octet
Coded Character Set (UCS) plus its amendments and corrigenda_

This section contains a non-normative overview of the ECMAScript
language.

ECMAScript is an object-oriented programming language for performing
computations and manipulating computational objects within a host
environment. ECMAScript as defined here is not intended to be
computationally self-sufficient; indeed, there are no provisions in this
specification for input of external data or output of computed results.
Instead, it is expected that the computational environment of an
ECMAScript program will provide not only the objects and other
facilities described in this specification but also certain
environment-specific host objects, whose description and behaviour are
beyond the scope of this specification except to indicate that they may
provide certain properties that can be accessed and certain functions
that can be called from an ECMAScript program.

A _SCRIPTING LANGUAGE_ is a programming language that is used to
manipulate, customise, and automate the facilities of an existing
system. In such systems, useful functionality is already available
through a user interface, and the scripting language is a mechanism for
exposing that functionality to program control. In this way, the
existing system is said to provide a host environment of objects and
facilities, which completes the capabilities of the scripting language.
A scripting language is intended for use by both professional and
non-professional programmers.

ECMAScript was originally designed to be a _WEB SCRIPTING LANGUAGE_,
providing a mechanism to enliven Web pages in browsers and to perform
server computation as part of a Web-based client-server architecture.
ECMAScript can provide core scripting capabilities for a variety of host
environments, and therefore the core scripting language is specified in
this document apart from any particular host environment.

Some of the facilities of ECMAScript are similar to those used in other
programming languages; in particular Java, Self, and Scheme as
described in:

Gosling, James, Bill Joy and Guy Steele. The Java^^ Language
Specification. Addison Wesley Publishing Co., 1996.

Ungar, David, and Smith, Randall B. Self: The Power of Simplicity.
OOPSLA '87 Conference Proceedings, pp. 227–241, Orlando, FL, October
1987.

IEEE Standard for the Scheme Programming Language. IEEE Std 1178-1990.

A web browser provides an ECMAScript host environment for client-side
computation including, for instance, objects that represent windows,
menus, pop-ups, dialog boxes, text areas, anchors, frames, history,
cookies, and input/output. Further, the host environment provides a
means to attach scripting code to events such as change of focus, page
and image loading, unloading, error and abort, selection, form
submission, and mouse actions. Scripting code appears within the HTML
and the displayed page is a combination of user interface elements and
fixed and computed text and images. The scripting code is reactive to
user interaction and there is no need for a main program.

A web server provides a different host environment for server-side
computation including objects representing requests, clients, and files;
and mechanisms to lock and share data. By using browser-side and
server-side scripting together, it is possible to distribute computation
between the client and server while providing a customised user
interface for a Web-based application.

Each Web browser and server that supports ECMAScript supplies its own
host environment, completing the ECMAScript execution environment.

The following is an informal overview of ECMAScript—not all parts of the
language are described. This overview is not part of the standard
proper.

ECMAScript is object-based: basic language and host facilities are
provided by objects, and an ECMAScript program is a cluster of
communicating objects. An ECMAScript OBJECT is a collection of
PROPERTIES each with zero or more ATTRIBUTES that determine how each
property can be used—for example, when the Writable attribute for a
property is set to FALSE, any attempt by executed ECMAScript code to
change the value of the property fails. Properties are containers that
hold other objects, _PRIMITIVE VALUES_, or FUNCTIONS. A primitive
value is a member of one of the following built-in types: UNDEFINED,
NULL, BOOLEAN, NUMBER, and STRING; an object is a member of the
remaining built-in type OBJECT; and a function is a callable object. A
function that is associated with an object via a property is a METHOD.

ECMAScript defines a collection of _BUILT-IN OBJECTS_ that round out the
definition of ECMAScript entities. These built-in objects include the
global object, the OBJECT object, the FUNCTION object, the ARRAY object,
the STRING object, the BOOLEAN object, the NUMBER object, the MATH
object, the DATE object, the REGEXP object, the JSON object, and the
Error objects ERROR, EVALERROR, RANGEERROR, REFERENCEERROR, SYNTAXERROR,
TYPEERROR and URIERROR.

ECMAScript also defines a set of built-in OPERATORS. ECMAScript
operators include various unary operations, multiplicative operators,
additive operators, bitwise shift operators, relational operators,
equality operators, binary bitwise operators, binary logical operators,
assignment operators, and the comma operator.

ECMAScript syntax intentionally resembles Java syntax. ECMAScript syntax
is relaxed to enable it to serve as an easy-to-use scripting language.
For example, a variable is not required to have its type declared nor
are types associated with properties, and defined functions are not
required to have their declarations appear textually before calls to
them.

ECMAScript does not use classes such as those in C++, Smalltalk, or
Java. Instead objects may be created in various ways including via a
literal notation or via CONSTRUCTORS which create objects and then
execute code that initialises all or part of them by assigning initial
values to their properties. Each constructor is a function that has a
property named “PROTOTYPE” that is used to implement _PROTOTYPE-BASED
INHERITANCE_ and _SHARED PROPERTIES_. Objects are created by using
constructors in NEW expressions; for example, NEW DATE(2009,11) creates
a new Date object. Invoking a constructor without using NEW has
consequences that depend on the constructor. For example, DATE()
produces a string representation of the current date and time rather
than an object.

Every object created by a constructor has an implicit reference (called
the object’s prototype) to the value of its constructor’s “PROTOTYPE”
property. Furthermore, a prototype may have a non-null implicit
reference to its prototype, and so on; this is called the _prototype
chain_. When a reference is made to a property in an object, that
reference is to the property of that name in the first object in the
prototype chain that contains a property of that name. In other words,
first the object mentioned directly is examined for such a property; if
that object contains the named property, that is the property to which
the reference refers; if that object does not contain the named
property, the prototype for that object is examined next; and so on.

Figure 1 — Object/Prototype Relationships

In a class-based object-oriented language, in general, state is carried
by instances, methods are carried by classes, and inheritance is only of
structure and behaviour. In ECMAScript, the state and methods are
carried by objects, and structure, behaviour, and state are all
inherited.

All objects that do not directly contain a particular property that
their prototype contains share that property and its value. Figure 1
illustrates this:

CF is a constructor (and also an object). Five objects have been created
by using NEW expressions: CF~1~, CF~2~, CF~3~, CF~4~, and CF~5~. Each of
these objects contains properties named q1 and q2. The dashed lines
represent the implicit prototype relationship; so, for example, CF~3~’s
prototype is CF~P~. The constructor, CF, has two properties itself,
named P1 and P2, which are not visible to CF~P~, CF~1~, CF~2~, CF~3~,
CF~4~, or CF~5~. The property named CFP1 in CF~P~ is shared by CF~1~,
CF~2~, CF~3~, CF~4~, and CF~5~ (but not by CF), as are any properties
found in CF~P~’s implicit prototype chain that are not named q1, q2, or
CFP1. Notice that there is no implicit prototype link between CF and
CF~P~.

Unlike class-based object languages, properties can be added to objects
dynamically by assigning values to them. That is, constructors are not
required to name or assign values to all or any of the constructed
object’s properties. In the above diagram, one could add a new shared
property for CF~1~, CF~2~, CF~3~, CF~4~, and CF~5\ ~by assigning a new
value to the property in CF~P~.

The ECMAScript Language recognises the possibility that some users of
the language may wish to restrict their usage of some features available
in the language. They might do so in the interests of security, to avoid
what they consider to be error-prone features, to get enhanced error
checking, or for other reasons of their choosing. In support of this
possibility, ECMAScript defines a strict variant of the language. The
strict variant of the language excludes some specific syntactic and
semantic features of the regular ECMAScript language and modifies the
detailed semantics of some features. The strict variant also specifies
additional error conditions that must be reported by throwing error
exceptions in situations that are not specified as errors by the
non-strict form of the language.

The strict variant of ECMAScript is commonly referred to as the _strict
mode_ of the language. Strict mode selection and use of the strict mode
syntax and semantics of ECMAScript is explicitly made at the level of
individual ECMAScript code units. Because strict mode is selected at the
level of a syntactic code unit, strict mode only imposes restrictions
that have local effect within such a code unit. Strict mode does not
restrict or modify any aspect of the ECMAScript semantics that must
operate consistently across multiple code units. A complete ECMAScript
program may be composed for both strict mode and non-strict mode
ECMAScript code units. In this case, strict mode only applies when
actually executing code that is defined within a strict mode code unit.

In order to conform to this specification, an ECMAScript implementation
must implement both the full unrestricted ECMAScript language and the
strict mode variant of the ECMAScript language as defined by this
specification. In addition, an implementation must support the
combination of unrestricted and strict mode code units into a single
composite program.

For the purposes of this document, the following terms and definitions
apply.

4.3.1

type

set of data values as defined in Clause 8 of this specification

4.3.2

primitive value

member of one of the types Undefined, Null, Boolean, Number, or String
as defined in Clause 8

NOTE A primitive value is a datum that is represented directly at the
lowest level of the language implementation.

4.3.3

object

member of the type Object

NOTE An object is a collection of properties and has a single prototype
object. The prototype may be the null value.

4.3.4

constructor

function object that creates and initialises objects

NOTE The value of a constructor’s “prototype” property is a prototype
object that is used to implement inheritance and shared properties.

4.3.5

prototype

object that provides shared properties for other objects

NOTE When a constructor creates an object, that object implicitly
references the constructor’s “PROTOTYPE” property for the purpose of
resolving property references. The constructor’s “PROTOTYPE” property
can be referenced by the program expression constructor.PROTOTYPE, and
properties added to an object’s prototype are shared, through
inheritance, by all objects sharing the prototype. Alternatively, a new
object may be created with an explicitly specified prototype by using
the OBJECT.CREATE built-in function.

4.3.6

native object

object in an ECMAScript implementation whose semantics are fully defined
by this specification rather than by the host environment

NOTE Standard native objects are defined in this specification. Some
native objects are built-in; others may be constructed during the course
of execution of an ECMAScript program.

4.3.7

built-in object

object supplied by an ECMAScript implementation, independent of the host
environment, that is present at the start of the execution of an
ECMAScript program

NOTE Standard built-in objects are defined in this specification, and an
ECMAScript implementation may specify and define others. Every built-in
object is a native object. A _built-in constructor_ is a built-in object
that is also a constructor.

4.3.8

host object

object supplied by the host environment to complete the execution
environment of ECMAScript

NOTE Any object that is not native is a host object.

4.3.9

undefined value

primitive value used when a variable has not been assigned a value

4.3.10

Undefined type

type whose sole value is the undefined value

4.3.11

null value

primitive value that represents the intentional absence of any object
value

4.3.12

Null type

type whose sole value is the null value

4.3.13

Boolean value

member of the Boolean type

NOTE There are only two Boolean values, TRUE and FALSE.

4.3.14

Boolean type

type consisting of the primitive values TRUE and FALSE

4.3.15

Boolean object

member of the Object type that is an instance of the standard built-in
BOOLEAN constructor

NOTE A Boolean object is created by using the BOOLEAN constructor in a
NEW expression, supplying a Boolean value as an argument. The resulting
object has an internal property whose value is the Boolean value. A
Boolean object can be coerced to a Boolean value.

4.3.16

String value

primitive value that is a finite ordered sequence of zero or more 16-bit
unsigned integer

NOTE A String value is a member of the String type. Each integer value
in the sequence usually represents a single 16-bit unit of UTF-16 text.
However, ECMAScript does not place any restrictions or requirements on
the values except that they must be 16-bit unsigned integers.

4.3.17

String type

set of all possible String values

4.3.18

String object

member of the Object type that is an instance of the standard built-in
STRING constructor

NOTE A String object is created by using the STRING constructor in a NEW
expression, supplying a String value as an argument. The resulting
object has an internal property whose value is the String value. A
String object can be coerced to a String value by calling the STRING
constructor as a function (15.5.1).

4.3.19

Number value

primitive value corresponding to a double-precision 64-bit binary format
IEEE 754 value

NOTE A Number value is a member of the Number type and is a direct
representation of a number.

4.3.20

Number type

set of all possible Number values including the special “Not-a-Number”
(NaN) values, positive infinity, and negative infinity

4.3.21

Number object

member of the Object type that is an instance of the standard built-in
NUMBER constructor

NOTE A Number object is created by using the NUMBER constructor in a NEW
expression, supplying a Number value as an argument. The resulting
object has an internal property whose value is the Number value. A
Number object can be coerced to a Number value by calling the NUMBER
constructor as a function (15.7.1).

4.3.22

Infinity

number value that is the positive infinite Number value

4.3.23

NaN

number value that is a IEEE 754 “Not-a-Number” value

4.3.24

function

member of the Object type that is an instance of the standard built-in
FUNCTION constructor and that may be invoked as a subroutine

NOTE In addition to its named properties, a function contains executable
code and state that determine how it behaves when invoked. A function’s
code may or may not be written in ECMAScript.

4.3.25

built-in function

built-in object that is a function

NOTE Examples of built-in functions include PARSEINT and MATH.EXP. An
implementation may provide implementation-dependent built-in functions
that are not described in this specification.

4.3.26

property

association between a name and a value that is a part of an object

NOTE Depending upon the form of the property the value may be
represented either directly as a data value (a primitive value, an
object, or a function object) or indirectly by a pair of accessor
functions.

4.3.27

method

function that is the value of a property

NOTE When a function is called as a method of an object, the object is
passed to the function as its THIS value.

4.3.28

built-in method

method that is a built-in function

NOTE Standard built-in methods are defined in this specification, and an
ECMAScript implementation may specify and provide other additional
built-in methods.

4.3.29

attribute

internal value that defines some characteristic of a property

4.3.30

own property

property that is directly contained by its object

4.3.31

inherited property

property of an object that is not an own property but is a property
(either own or inherited) of the object’s prototype

A _context-free grammar_ consists of a number of productions. Each
production has an abstract symbol called a nonterminal as its
_left-hand side_, and a sequence of zero or more nonterminal and
terminal symbols as its _right-hand side_. For each grammar, the
terminal symbols are drawn from a specified alphabet.

Starting from a sentence consisting of a single distinguished
nonterminal, called the _goal symbol_, a given context-free grammar
specifies a language, namely, the (perhaps infinite) set of possible
sequences of terminal symbols that can result from repeatedly replacing
any nonterminal in the sequence with a right-hand side of a production
for which the nonterminal is the left-hand side.

A _lexical grammar_ for ECMAScript is given in clause 7. This grammar
has as its terminal symbols characters (Unicode code units) that conform
to the rules for SourceCharacter defined in Clause 6. It defines a set
of productions, starting from the goal symbol InputElementDiv or
InputElementRegExp, that describe how sequences of such characters are
translated into a sequence of input elements.

Input elements other than white space and comments form the terminal
symbols for the syntactic grammar for ECMAScript and are called
ECMAScript tokens. These tokens are the reserved words, identifiers,
literals, and punctuators of the ECMAScript language. Moreover, line
terminators, although not considered to be tokens, also become part of
the stream of input elements and guide the process of automatic
semicolon insertion (7.9). Simple white space and single-line comments
are discarded and do not appear in the stream of input elements for the
syntactic grammar. A MultiLineComment (that is, a comment of the form
“/*…*/” regardless of whether it spans more than one line) is likewise
simply discarded if it contains no line terminator; but if a
MultiLineComment contains one or more line terminators, then it is
replaced by a single line terminator, which becomes part of the stream
of input elements for the syntactic grammar.

A _RegExp grammar_ for ECMAScript is given in 15.10. This grammar also
has as its terminal symbols the characters as defined by
SourceCharacter. It defines a set of productions, starting from the
goal symbol Pattern, that describe how sequences of characters are
translated into regular expression patterns.

Productions of the lexical and RegExp grammars are distinguished by
having two colons “::” as separating punctuation. The lexical and RegExp
grammars share some productions.

Another grammar is used for translating Strings into numeric values.
This grammar is similar to the part of the lexical grammar having to do
with numeric literals and has as its terminal symbols SourceCharacter.
This grammar appears in 9.3.1.

Productions of the numeric string grammar are distinguished by having
three colons “:::” as punctuation.

The _syntactic grammar_ for ECMAScript is given in clauses 11, 12, 13
and 14. This grammar has ECMAScript tokens defined by the lexical
grammar as its terminal symbols (5.1.2). It defines a set of
productions, starting from the goal symbol Program, that describe how
sequences of tokens can form syntactically correct ECMAScript programs.

When a stream of characters is to be parsed as an ECMAScript program, it
is first converted to a stream of input elements by repeated application
of the lexical grammar; this stream of input elements is then parsed by
a single application of the syntactic grammar. The program is
syntactically in error if the tokens in the stream of input elements
cannot be parsed as a single instance of the goal nonterminal Program,
with no tokens left over.

Productions of the syntactic grammar are distinguished by having just
one colon “:” as punctuation.

The syntactic grammar as presented in clauses 11, 12, 13 and 14 is
actually not a complete account of which token sequences are accepted as
correct ECMAScript programs. Certain additional token sequences are also
accepted, namely, those that would be described by the grammar if only
semicolons were added to the sequence in certain places (such as before
line terminator characters). Furthermore, certain token sequences that
are described by the grammar are not considered acceptable if a
terminator character appears in certain “awkward” places.

In certain cases in order to avoid ambiguities the syntactic grammar
uses productions that permit token sequences that are not valid
ECMAScript programs. In such cases a more restrictive supplemental
grammar is provided that further restricts the acceptable token
sequences. In such situations, when explicitly specific, the input
elements corresponding to such a production is parsed again using a goal
symbol of a supplemental grammar. The program is syntactically in error
if the tokens in the stream of input elements cannot be parsed as a
single instance of the supplemental goal symbol, with no tokens left
over.

The JSON grammar is used to translate a String describing a set of
ECMAScript objects into actual objects. The JSON grammar is given in
15.12.1.

The JSON grammar consists of the JSON lexical grammar and the JSON
syntactic grammar. The JSON lexical grammar is used to translate
character sequences into tokens and is similar to parts of the
ECMAScript lexical grammar. The JSON syntactic grammar describes how
sequences of tokens from the JSON lexical grammar can form syntactically
correct JSON object descriptions.

Productions of the JSON lexical grammar are distinguished by having two
colons “::” as separating punctuation. The JSON lexical grammar uses
some productions from the ECMAScript lexical grammar. The JSON syntactic
grammar is similar to parts of the ECMAScript syntactic grammar.
Productions of the JSON syntactic grammar are distinguished by using one
colon “:” as separating punctuation.

Terminal symbols of the lexical, RegExp, and numeric string grammars,
and some of the terminal symbols of the other grammars, are shown in
FIXED WIDTH font, both in the productions of the grammars and throughout
this specification whenever the text directly refers to such a terminal
symbol. These are to appear in a program exactly as written. All
terminal symbol characters specified in this way are to be understood as
the appropriate Unicode character from the ASCII range, as opposed to
any similar-looking characters from other Unicode ranges.

Nonterminal symbols are shown in italic type. The definition of a
nonterminal is introduced by the name of the nonterminal being defined
followed by one or more colons. (The number of colons indicates to which
grammar the production belongs.) One or more alternative right-hand
sides for the nonterminal then follow on succeeding lines. For example,
the syntactic definition:

WhileStatement :

WHILE ( Expression ) Statement

states that the nonterminal WhileStatement represents the token WHILE,
followed by a left parenthesis token, followed by an Expression,
followed by a right parenthesis token, followed by a Statement. The
occurrences of Expression and Statement are themselves nonterminals.
As another example, the syntactic definition:

ArgumentList :

AssignmentExpression
ArgumentList , AssignmentExpression

states that an ArgumentList may represent either a single
AssignmentExpression or an ArgumentList, followed by a comma,
followed by an AssignmentExpression. This definition of ArgumentList
is recursive, that is, it is defined in terms of itself. The result is
that an ArgumentList may contain any positive number of arguments,
separated by commas, where each argument expression is an
AssignmentExpression. Such recursive definitions of nonterminals are
common.

The subscripted suffix “~opt~”, which may appear after a terminal or
nonterminal, indicates an optional symbol. The alternative containing
the optional symbol actually specifies two right-hand sides, one that
omits the optional element and one that includes it. This means that:

VariableDeclaration :

Identifier Initialiser~opt~

is a convenient abbreviation for:

VariableDeclaration :

Identifier
Identifier Initialiser

and that:

IterationStatement :

FOR ( ExpressionNoIn~opt~ ; Expression~opt~ ; Expression~opt~ )
Statement

is a convenient abbreviation for:

IterationStatement :

FOR ( ; Expression~opt~ ; Expression~opt~ ) Statement
FOR ( ExpressionNoIn ; Expression~opt~ ; Expression~opt~ ) Statement

which in turn is an abbreviation for:

IterationStatement :

FOR ( ; ; Expression~opt~ ) Statement
FOR ( ; Expression ; Expression~opt~ ) Statement
FOR ( ExpressionNoIn ; ; Expression~opt~ ) Statement
FOR ( ExpressionNoIn ; Expression ; Expression~opt~ ) Statement

which in turn is an abbreviation for:

IterationStatement :

FOR ( ; ; ) Statement
FOR ( ; ; Expression ) Statement
FOR ( ; Expression ; ) Statement
FOR ( ; Expression ; Expression ) Statement
FOR ( ExpressionNoIn ; ; ) Statement
FOR ( ExpressionNoIn ; ; Expression ) Statement
FOR ( ExpressionNoIn ; Expression ; ) Statement
FOR ( ExpressionNoIn ; Expression ; Expression ) Statement

so the nonterminal IterationStatement actually has eight alternative
right-hand sides.

When the words “ONE OF” follow the colon(s) in a grammar definition,
they signify that each of the terminal symbols on the following line or
lines is an alternative definition. For example, the lexical grammar for
ECMAScript contains the production:

NonZeroDigit :: ONE OF

1 2 3 4 5 6 7 8 9

which is merely a convenient abbreviation for:

NonZeroDigit ::

1
2
3
4
5
6
7
8
9

If the phrase “[empty]” appears as the right-hand side of a production,
it indicates that the production's right-hand side contains no terminals
or nonterminals.

If the phrase “[lookahead ∉ set]” appears in the right-hand side of a
production, it indicates that the production may not be used if the
immediately following input token is a member of the given set. The
set can be written as a list of terminals enclosed in curly braces.
For convenience, the set can also be written as a nonterminal, in which
case it represents the set of all terminals to which that nonterminal
could expand. For example, given the definitions

DecimalDigit :: ONE OF

0 1 2 3 4 5 6 7 8 9

DecimalDigits ::

DecimalDigit
DecimalDigits DecimalDigit

the definition

LookaheadExample ::

N [lookahead ∉ {1, 3, 5, 7, 9}] DecimalDigits
DecimalDigit [lookahead ∉ DecimalDigit ]

matches either the letter N followed by one or more decimal digits the
first of which is even, or a decimal digit not followed by another
decimal digit.

If the phrase “[no LineTerminator here]” appears in the right-hand
side of a production of the syntactic grammar, it indicates that the
production is _a restricted production_: it may not be used if a
LineTerminator occurs in the input stream at the indicated position.
For example, the production:

ThrowStatement :

THROW [no LineTerminator here] Expression ;

indicates that the production may not be used if a LineTerminator
occurs in the program between the THROW token and the Expression.

Unless the presence of a LineTerminator is forbidden by a restricted
production, any number of occurrences of LineTerminator may appear
between any two consecutive tokens in the stream of input elements
without affecting the syntactic acceptability of the program.

When an alternative in a production of the lexical grammar or the
numeric string grammar appears to be a multi-character token, it
represents the sequence of characters that would make up such a token.

The right-hand side of a production may specify that certain expansions
are not permitted by using the phrase “BUT NOT” and then indicating the
expansions to be excluded. For example, the production:

Identifier ::

IdentifierName BUT NOT ReservedWord

means that the nonterminal Identifier may be replaced by any sequence
of characters that could replace IdentifierName provided that the same
sequence of characters could not replace ReservedWord.

Finally, a few nonterminal symbols are described by a descriptive phrase
in sans-serif type in cases where it would be impractical to list all
the alternatives:

SourceCharacter ::

any Unicode code unit

The specification often uses a numbered list to specify steps in an
algorithm. These algorithms are used to precisely specify the required
semantics of ECMAScript language constructs. The algorithms are not
intended to imply the use of any specific implementation technique. In
practice, there may be more efficient algorithms available to implement
a given feature.

In order to facilitate their use in multiple parts of this
specification, some algorithms, called abstract operations, are
named and written in parameterised functional form so that they may be
referenced by name from within other algorithms.

When an algorithm is to produce a value as a result, the directive
“return x” is used to indicate that the result of the algorithm is the
value of x and that the algorithm should terminate. The notation
Result(n) is used as shorthand for “the result of step n”.

For clarity of expression, algorithm steps may be subdivided into
sequential substeps. Substeps are indented and may themselves be further
divided into indented substeps. Outline numbering conventions are used
to identify substeps with the first level of substeps labelled with
lower case alphabetic characters and the second level of substeps
labelled with lower case roman numerals. If more than three levels are
required these rules repeat with the fourth level using numeric labels.
For example:

A step or substep may be written as an “if” predicate that conditions
its substeps. In this case, the substeps are only applied if the
predicate is true. If a step or substep begins with the word “else”, it
is a predicate that is the negation of the preceding “if” predicate step
at the same level.

A step may specify the iterative application of its substeps.

A step may assert an invariant condition of its algorithm. Such
assertions are used to make explicit algorithmic invariants that would
otherwise be implicit. Such assertions add no additional semantic
requirements and hence need not be checked by an implementation. They
are used simply to clarify algorithms.

Mathematical operations such as addition, subtraction, negation,
multiplication, division, and the mathematical functions defined later
in this clause should always be understood as computing exact
mathematical results on mathematical real numbers, which do not include
infinities and do not include a negative zero that is distinguished from
positive zero. Algorithms in this standard that model floating-point
arithmetic include explicit steps, where necessary, to handle infinities
and signed zero and to perform rounding. If a mathematical operation or
function is applied to a floating-point number, it should be understood
as being applied to the exact mathematical value represented by that
floating-point number; such a floating-point number must be finite, and
if it is +0 or −0 then the corresponding mathematical value is simply 0.

The mathematical function abs(x) yields the absolute value of x,
which is −x if x is negative (less than zero) and otherwise is x
itself.

The mathematical function sign(x) yields 1 if x is positive and −1
if x is negative. The sign function is not used in this standard for
cases when x is zero.

The notation “x modulo y” (y must be finite and nonzero) computes
a value k of the same sign as y (or zero) such that abs(k) <
abs(y) and x_−_k = q × y for some integer q.

The mathematical function floor(x) yields the largest integer (closest
to positive infinity) that is not larger than x.

NOTE floor(x) = x_−(_x modulo 1).

If an algorithm is defined to “throw an exception”, execution of the
algorithm is terminated and no result is returned. The calling
algorithms are also terminated, until an algorithm step is reached that
explicitly deals with the exception, using terminology such as “If an
exception was thrown…”. Once such an algorithm step has been encountered
the exception is no longer considered to have occurred.

Context-free grammars are not sufficiently powerful to express all the
rules that define whether a stream of input elements make up a valid
ECMAScript program that may be evaluated. In some situations additional
rules are needed that may be expressed using either ECMAScript algorithm
conventions or prose requirements. Such rules are always associated with
a production of a grammar and are called the _static semantics_ of the
production.

An implementation must validate all of the static semantic rules used to
parse a Program prior to the first evaluation of that Program. If
any of the static semantic rules are violated the Program is invalid
and can not be evaluated. Static semantic rule violations are early
errors (see clause 16) and reported in the same manner as syntax errors.

ECMAScript source text is represented as a sequence of characters in the
Unicode character encoding, version 3.0 or later. The text is expected
to have been normalised to Unicode Normalization Form C (canonical
composition), as described in Unicode Technical Report #15. Conforming
ECMAScript implementations are not required to perform any normalisation
of text, or behave as though they were performing normalisation of text,
themselves. ECMAScript source text is assumed to be a sequence of 16-bit
code units for the purposes of this specification. Such a source text
may include sequences of 16-bit code units that are not valid UTF-16
character encodings. If an actual source text is encoded in a form other
than 16-bit code units it must be processed as if it was first converted
to UTF-16.

Syntax

SourceCharacter ::

any Unicode code unit

Throughout the rest of this document, the phrase “code unit” and the
word “character” will be used to refer to a 16-bit unsigned value used
to represent a single 16-bit unit of text. The phrase “Unicode
character” will be used to refer to the abstract linguistic or
typographical unit represented by a single Unicode scalar value (which
may be longer than 16 bits and thus may be represented by more than one
code unit). The phrase “code point” refers to such a Unicode scalar
value. “Unicode character” only refers to entities represented by single
Unicode scalar values: the components of a combining character sequence
are still individual “Unicode characters,” even though a user might
think of the whole sequence as a single character.

In string literals, regular expression literals, and identifiers, any
character (code unit) may also be expressed as a Unicode escape sequence
consisting of six characters, namely \U plus four hexadecimal digits.
Within a comment, such an escape sequence is effectively ignored as part
of the comment. Within a string literal or regular expression literal,
the Unicode escape sequence contributes one character to the value of
the literal. Within an identifier, the escape sequence contributes one
character to the identifier.

NOTE Although this document sometimes refers to a “transformation”
between a “character” within a “string” and the 16-bit unsigned integer
that is the code unit of that character, there is actually no
transformation because a “character” within a “string” is actually
represented using that 16-bit unsigned value.

ECMAScript differs from the Java programming language in the behaviour
of Unicode escape sequences. In a Java program, if the Unicode escape
sequence \U000A, for example, occurs within a single-line comment, it is
interpreted as a line terminator (Unicode character 000A is line feed)
and therefore the next character is not part of the comment. Similarly,
if the Unicode escape sequence \U000A occurs within a string literal in
a Java program, it is likewise interpreted as a line terminator, which
is not allowed within a string literal—one must write \N instead of
\U000A to cause a line feed to be part of the string value of a string
literal. In an ECMAScript program, a Unicode escape sequence occurring
within a comment is never interpreted and therefore cannot contribute to
termination of the comment. Similarly, a Unicode escape sequence
occurring within a string literal in an ECMAScript program always
contributes a character to the String value of the literal and is never
interpreted as a line terminator or as a quote mark that might terminate
the string literal.

The source text of an ECMAScript program is first converted into a
sequence of input elements, which are tokens, line terminators,
comments, or white space. The source text is scanned from left to right,
repeatedly taking the longest possible sequence of characters as the
next input element.

There are two goal symbols for the lexical grammar. The
InputElementDiv symbol is used in those syntactic grammar contexts
where a leading division (/) or division-assignment (/=) operator is
permitted. The InputElementRegExp symbol is used in other syntactic
grammar contexts.

NOTE There are no syntactic grammar contexts where both a leading
division or division-assignment, and a leading
RegularExpressionLiteral are permitted. This is not affected by
semicolon insertion (see 7.9); in examples such as the following:

  A = B
  /HI/G.EXEC(C).MAP(D);

where the first non-whitespace, non-comment character after a
LineTerminator is slash (/) and the syntactic context allows division
or division-assignment, no semicolon is inserted at the
LineTerminator. That is, the above example is interpreted in the same
way as:

  A = B / HI / G.EXEC(C).MAP(D);

Syntax

InputElementDiv ::

WhiteSpace
LineTerminator
Comment
Token
DivPunctuator

InputElementRegExp ::

WhiteSpace
LineTerminator
Comment
Token
RegularExpressionLiteral

The Unicode format-control characters (i.e., the characters in category
“Cf” in the Unicode Character Database such as LEFT-TO-RIGHT MARK or
RIGHT-TO-LEFT MARK) are control codes used to control the formatting of
a range of text in the absence of higher-level protocols for this (such
as mark-up languages).

It is useful to allow format-control characters in source text to
facilitate editing and display. All format control characters may be
used within comments, and within string literals and regular expression
literals.

<ZWNJ> and <ZWJ> are format-control characters that are used to make
necessary distinctions when forming words or phrases in certain
languages. In ECMAScript source text, <ZWNJ> and <ZWJ> may also be used
in an identifier after the first character.

<BOM> is a format-control character used primarily at the start of a
text to mark it as Unicode and to allow detection of the text's encoding
and byte order. <BOM> characters intended for this purpose can sometimes
also appear after the start of a text, for example as a result of
concatenating files. <BOM> characters are treated as white space
characters (see 7.2).

The special treatment of certain format-control characters outside of
comments, string literals, and regular expression literals is summarised
in Table 1.

Table 1 — Format-Control Character Usage

  ------------------- ----------------------- --------------- ------------------
  _CODE UNIT VALUE_   NAME                  _FORMAL NAME_   USAGE
  \U200C              Zero width non-joiner   <ZWNJ>          IdentifierPart
  \U200D              Zero width joiner       <ZWJ>           IdentifierPart
  \UFEFF              Byte Order Mark         <BOM>           Whitespace
  ------------------- ----------------------- --------------- ------------------

White space characters are used to improve source text readability and
to separate tokens (indivisible lexical units) from each other, but are
otherwise insignificant. White space characters may occur between any
two tokens and at the start or end of input. White space characters may
also occur within a StringLiteral or a RegularExpressionLiteral
(where they are considered significant characters forming part of the
literal value) or within a Comment, but cannot appear within any other
kind of token.

The ECMAScript white space characters are listed in Table 2.

Table 2 — Whitespace Characters

  --------------------- ------------------------------------- ---------------
  _CODE UNIT VALUE_     NAME                                _FORMAL NAME_

  \U0009                Tab                                   <TAB>

  \U000B                Vertical Tab                          <VT>

  \U000C                Form Feed                             <FF>

  \U0020                Space                                 <SP>

  \U00A0                No-break space                        <NBSP>

  \UFEFF                Byte Order Mark                       <BOM>
                                                              
  Other category “Zs”   Any other Unicode “space separator”   <USP>
  --------------------- ------------------------------------- ---------------

ECMAScript implementations must recognise all of the white space
characters defined in Unicode 3.0. Later editions of the Unicode
Standard may define other white space characters. ECMAScript
implementations may recognise white space characters from later editions
of the Unicode Standard.

Syntax

WhiteSpace ::

<TAB>
<VT>
<FF>
<SP>
<NBSP>
<BOM>
<USP>

Like white space characters, line terminator characters are used to
improve source text readability and to separate tokens (indivisible
lexical units) from each other. However, unlike white space characters,
line terminators have some influence over the behaviour of the syntactic
grammar. In general, line terminators may occur between any two tokens,
but there are a few places where they are forbidden by the syntactic
grammar. Line terminators also affect the process of automatic semicolon
insertion (7.9). A line terminator cannot occur within any token except
a StringLiteral. Line terminators may only occur within a
StringLiteral token as part of a LineContinuation.

A line terminator can occur within a MultiLineComment (7.4) but cannot
occur within a SingleLineComment.

Line terminators are included in the set of white space characters that
are matched by the \S class in regular expressions.

The ECMAScript line terminator characters are listed in Table 3.

Table 3 — Line Terminator Characters

  ------------------- --------------------- ---------------
  _CODE UNIT VALUE_   NAME                _FORMAL NAME_
  \U000A              Line Feed             <LF>
  \U000D              Carriage Return       <CR>
  \U2028              Line separator        <LS>
  \U2029              Paragraph separator   <PS>
  ------------------- --------------------- ---------------

Only the characters in Table 3 are treated as line terminators. Other
new line or line breaking characters are treated as white space but not
as line terminators. The character sequence <CR><LF> is commonly used as
a line terminator. It should be considered a single character for the
purpose of reporting line numbers.

Syntax

LineTerminator ::

<LF>
<CR>
<LS>
<PS>

LineTerminatorSequence ::

<LF>
<CR> [lookahead ∉ <LF> ]
<LS>
<PS>
<CR> <LF>

Comments can be either single or multi-line. Multi-line comments cannot
nest.

Because a single-line comment can contain any character except a
LineTerminator character, and because of the general rule that a token
is always as long as possible, a single-line comment always consists of
all characters from the // marker to the end of the line. However, the
LineTerminator at the end of the line is not considered to be part of
the single-line comment; it is recognised separately by the lexical
grammar and becomes part of the stream of input elements for the
syntactic grammar. This point is very important, because it implies that
the presence or absence of single-line comments does not affect the
process of automatic semicolon insertion (see 7.9).

Comments behave like white space and are discarded except that, if a
MultiLineComment contains a line terminator character, then the entire
comment is considered to be a LineTerminator for purposes of parsing
by the syntactic grammar.

Syntax

Comment ::

MultiLineComment
SingleLineComment

MultiLineComment ::

/* MultiLineCommentChars~opt~ */

MultiLineCommentChars ::

MultiLineNotAsteriskChar MultiLineCommentChars~opt~
* PostAsteriskCommentChars~opt~

PostAsteriskCommentChars ::

MultiLineNotForwardSlashOrAsteriskChar MultiLineCommentChars~opt~
* PostAsteriskCommentChars~opt~

MultiLineNotAsteriskChar ::

SourceCharacter BUT NOT *

MultiLineNotForwardSlashOrAsteriskChar ::

SourceCharacter BUT NOT ONE OF / OR *

SingleLineComment ::

// SingleLineCommentChars~opt~

SingleLineCommentChars ::

SingleLineCommentChar SingleLineCommentChars~opt~

SingleLineCommentChar ::

SourceCharacter BUT NOT LineTerminator

Syntax

Token ::

IdentifierName
Punctuator
NumericLiteral
StringLiteral

NOTE The DivPunctuator and RegularExpressionLiteral productions
define tokens, but are not included in the Token production.

Identifier Names are tokens that are interpreted according to the
grammar given in the “Identifiers” section of chapter 5 of the Unicode
standard, with some small modifications. An Identifier is an
IdentifierName that is not a ReservedWord (see 7.6.1). The Unicode
identifier grammar is based on both normative and informative character
categories specified by the Unicode Standard. The characters in the
specified categories in version 3.0 of the Unicode standard must be
treated as in those categories by all conforming ECMAScript
implementations.

This standard specifies specific character additions: The dollar sign
($) and the underscore (_) are permitted anywhere in an
IdentifierName.

Unicode escape sequences are also permitted in an IdentifierName,
where they contribute a single character to the IdentifierName, as
computed by the CV of the UnicodeEscapeSequence (see 7.8.4). The \
preceding the UnicodeEscapeSequence does not contribute a character to
the IdentifierName. A UnicodeEscapeSequence cannot be used to put a
character into an IdentifierName that would otherwise be illegal. In
other words, if a \ UnicodeEscapeSequence sequence were replaced by
its UnicodeEscapeSequence's CV, the result must still be a valid
IdentifierName that has the exact same sequence of characters as the
original IdentifierName. All interpretations of identifiers within
this specification are based upon their actual characters regardless of
whether or not an escape sequence was used to contribute any particular
characters.

Two IdentifierName that are canonically equivalent according to the
Unicode standard are not equal unless they are represented by the
exact same sequence of code units (in other words, conforming ECMAScript
implementations are only required to do bitwise comparison on
IdentifierName values). The intent is that the incoming source text has
been converted to normalised form C before it reaches the compiler.

ECMAScript implementations may recognise identifier characters defined
in later editions of the Unicode Standard. If portability is a concern,
programmers should only employ identifier characters defined in Unicode
3.0.

Syntax

Identifier ::

IdentifierName BUT NOT ReservedWord

IdentifierName ::

IdentifierStart
IdentifierName IdentifierPart

IdentifierStart ::

UnicodeLetter
$
_
\ UnicodeEscapeSequence

IdentifierPart ::

IdentifierStart
UnicodeCombiningMark
UnicodeDigit
UnicodeConnectorPunctuation
<ZWNJ>
<ZWJ>

UnicodeLetter ::

any character in the Unicode categories “Uppercase letter (Lu)”,
“Lowercase letter (Ll)”, “Titlecase letter (Lt)”, “Modifier letter
(Lm)”, “Other letter (Lo)”, or “Letter number (Nl)”.

UnicodeCombiningMark ::

any character in the Unicode categories “Non-spacing mark (Mn)” or
“Combining spacing mark (Mc)”

UnicodeDigit ::

any character in the Unicode category “Decimal number (Nd)”

UnicodeConnectorPunctuation ::

any character in the Unicode category “Connector punctuation (Pc)”

The definitions of the nonterminal UnicodeEscapeSequence is given in
7.8.4

STATIC SEMANTICS: STRING VALUE

Identifier :: IdentifierName BUT NOT ReservedWord

1.  Return the String Value of IdentifierName.

IdentifierName ::

IdentifierStart
IdentifierName IdentifierPart

1.  Return the String value consisting of the sequence of characters
    corresponding to IdentifierName.

A reserved word is an IdentifierName that cannot be used as an
Identifier.

Syntax

ReservedWord ::

Keyword
FutureReservedWord
NullLiteral
BooleanLiteral

The following tokens are ECMAScript keywords and may not be used as
Identifiers in ECMAScript programs.

Syntax

Keyword :: ONE OF

  ---------- ---------- ------------ --------
  break      do         instanceof   typeof
  case       else       new          var
  catch      finally    return       void
  continue   for        switch       while
  debugger   function   this         with
  default    if         throw        
  delete     in         try          
  ---------- ---------- ------------ --------

The following words are used as keywords in proposed extensions and are
therefore reserved to allow for the possibility of future adoption of
those extensions.

Syntax

FutureReservedWord :: ONE OF

  ------- -------- --------- -------
  class   enum     extends   super
  const   export   import    
  ------- -------- --------- -------

The following tokens are also considered to be FutureReservedWords
when they occur within strict mode code (see 10.1.1). The occurrence of
any of these tokens within strict mode code in any context where the
occurrence of a FutureReservedWord would produce an error must also
produce an equivalent error:

  ------------ --------- ----------- -------- -------
  implements   let       private     public   yield
  interface    package   protected   static   
  ------------ --------- ----------- -------- -------

Syntax

Punctuator :: ONE OF

  ----- ------ ----- ----- ----- -----
  {     }      (     )     [     ]
  .     ;      ,     <     >     <=
  >=    ==     !=    ===   !==   
  +     -      *     %     ++    --
  <<    >>     >>>   &     |     ^
  !     ~      &&    ||    ?     :
  =     +=     -=    *=    %=    <<=
  >>=   >>>=   &=    |=    ^=    <|
  ----- ------ ----- ----- ----- -----

DivPunctuator :: ONE OF

  --- ---- -- -- -- --
  /   /=            
  --- ---- -- -- -- --

Syntax

Literal ::

NullLiteral
ValueLiteral

ValueLiteral ::

BooleanLiteral
NumericLiteral
StringLiteral
RegularExpressionLiteral

Syntax

NullLiteral ::

NULL

Semantics

The value of the null literal NULL is the sole value of the Null type,
namely NULL.

Syntax

BooleanLiteral ::

TRUE
FALSE

Semantics

The value of the Boolean literal TRUE is a value of the Boolean type,
namely TRUE.

The value of the Boolean literal FALSE is a value of the Boolean type,
namely FALSE.

Syntax

NumericLiteral ::

DecimalLiteral
HexIntegerLiteral

DecimalLiteral ::

DecimalIntegerLiteral . DecimalDigits~opt~ ExponentPart~opt~
. DecimalDigits ExponentPart~opt~
DecimalIntegerLiteral ExponentPart~opt~

DecimalIntegerLiteral ::

0
NonZeroDigit DecimalDigits~opt~

DecimalDigits ::

DecimalDigit
DecimalDigits DecimalDigit

DecimalDigit :: ONE OF

0 1 2 3 4 5 6 7 8 9

NonZeroDigit :: ONE OF

1 2 3 4 5 6 7 8 9

ExponentPart ::

ExponentIndicator SignedInteger

ExponentIndicator :: ONE OF

E E

SignedInteger ::

DecimalDigits
+ DecimalDigits
- DecimalDigits

HexIntegerLiteral ::

0X HexDigit
0X HexDigit
HexIntegerLiteral HexDigit

HexDigit :: one of

0 1 2 3 4 5 6 7 8 9 A B C D E F A B C D E F

The source character immediately following a NumericLiteral must not
be an IdentifierStart or DecimalDigit.

NOTE For example:

  3in

is an error and not the two input elements 3 and IN.

Semantics

A numeric literal stands for a value of the Number type. This value is
determined in two steps: first, a mathematical value (MV) is derived
from the literal; second, this mathematical value is rounded as
described below.

-   The MV of NumericLiteral :: DecimalLiteral is the MV of
    DecimalLiteral.

-   The MV of NumericLiteral :: HexIntegerLiteral is the MV of
    HexIntegerLiteral.

-   The MV of DecimalLiteral :: DecimalIntegerLiteral . is the MV of
    DecimalIntegerLiteral.

-   The MV of DecimalLiteral :: DecimalIntegerLiteral .
    DecimalDigits is the MV of DecimalIntegerLiteral plus (the MV of
    DecimalDigits times 10^–n^), where n is the number of
    characters in DecimalDigits.

-   The MV of DecimalLiteral :: DecimalIntegerLiteral .
    ExponentPart is the MV of DecimalIntegerLiteral times 10^e^,
    where e is the MV of ExponentPart.

-   The MV of DecimalLiteral :: DecimalIntegerLiteral .
    _DecimalDigits ExponentPart_ is (the MV of DecimalIntegerLiteral
    plus (the MV of DecimalDigits times 10^–n^)) times 10^e^,
    where n is the number of characters in DecimalDigits and e is
    the MV of ExponentPart.

-   The MV of DecimalLiteral ::. DecimalDigits is the MV of
    DecimalDigits times 10^–n^, where n is the number of
    characters in DecimalDigits.

-   The MV of DecimalLiteral ::. _DecimalDigits ExponentPart_ is the
    MV of DecimalDigits times 10^e_–_n^, where n is the number of
    characters in DecimalDigits and e is the MV of ExponentPart.

-   The MV of DecimalLiteral :: DecimalIntegerLiteral is the MV of
    DecimalIntegerLiteral.

-   The MV of DecimalLiteral :: _DecimalIntegerLiteral ExponentPart_
    is the MV of DecimalIntegerLiteral times 10^e^, where e is the
    MV of ExponentPart.

-   The MV of DecimalIntegerLiteral :: 0 is 0.

-   The MV of DecimalIntegerLiteral :: NonZeroDigit is the MV of
    NonZeroDigit.

-   The MV of DecimalIntegerLiteral :: NonZeroDigit DecimalDigits
    is (the MV of NonZeroDigit times 10^n^) plus the MV of
    DecimalDigits, where n is the number of characters in
    DecimalDigits.

-   The MV of DecimalDigits :: DecimalDigit is the MV of
    DecimalDigit.

-   The MV of DecimalDigits :: DecimalDigits DecimalDigit is (the
    MV of DecimalDigits times 10) plus the MV of DecimalDigit.

-   The MV of ExponentPart :: _ExponentIndicator SignedInteger_ is the
    MV of SignedInteger.

-   The MV of SignedInteger :: DecimalDigits is the MV of
    DecimalDigits.

-   The MV of SignedInteger :: + DecimalDigits is the MV of
    DecimalDigits.

-   The MV of SignedInteger :: - DecimalDigits is the negative of
    the MV of DecimalDigits.

-   The MV of DecimalDigit :: 0 or of HexDigit :: 0 is 0.

-   The MV of DecimalDigit :: 1 or of NonZeroDigit :: 1 or of
    HexDigit :: 1 is 1.

-   The MV of DecimalDigit :: 2 or of NonZeroDigit :: 2 or of
    HexDigit :: 2 is 2.

-   The MV of DecimalDigit :: 3 or of NonZeroDigit :: 3 or of
    HexDigit :: 3 is 3.

-   The MV of DecimalDigit :: 4 or of NonZeroDigit :: 4 or of
    HexDigit :: 4 is 4.

-   The MV of DecimalDigit :: 5 or of NonZeroDigit :: 5 or of
    HexDigit :: 5 is 5.

-   The MV of DecimalDigit :: 6 or of NonZeroDigit :: 6 or of
    HexDigit :: 6 is 6.

-   The MV of DecimalDigit :: 7 or of NonZeroDigit :: 7 or of
    HexDigit :: 7 is 7.

-   The MV of DecimalDigit :: 8 or of NonZeroDigit :: 8 or of
    HexDigit :: 8 is 8.

-   The MV of DecimalDigit :: 9 or of NonZeroDigit :: 9 or of
    HexDigit :: 9 is 9.

-   The MV of HexDigit :: A or of HexDigit :: A is 10.

-   The MV of HexDigit :: B or of HexDigit :: B is 11.

-   The MV of HexDigit :: C or of HexDigit :: C is 12.

-   The MV of HexDigit :: D or of HexDigit :: D is 13.

-   The MV of HexDigit :: E or of HexDigit :: E is 14.

-   The MV of HexDigit :: F or of HexDigit :: F is 15.

-   The MV of HexIntegerLiteral :: 0X HexDigit is the MV of
    HexDigit.

-   The MV of HexIntegerLiteral :: 0X HexDigit is the MV of
    HexDigit.

-   The MV of HexIntegerLiteral :: HexIntegerLiteral HexDigit is
    (the MV of HexIntegerLiteral times 16) plus the MV of HexDigit.

Once the exact MV for a numeric literal has been determined, it is then
rounded to a value of the Number type. If the MV is 0, then the rounded
value is +0; otherwise, the rounded value must be the Number value for
the MV (as specified in 8.5), unless the literal is a DecimalLiteral
and the literal has more than 20 significant digits, in which case the
Number value may be either the Number value for the MV of a literal
produced by replacing each significant digit after the 20th with a 0
digit or the Number value for the MV of a literal produced by replacing
each significant digit after the 20th with a 0 digit and then
incrementing the literal at the 20th significant digit position. A digit
is significant if it is not part of an ExponentPart and

-   it is not 0; or

-   there is a nonzero digit to its left and there is a nonzero digit,
    not in the ExponentPart, to its right.

A conforming implementation, when processing strict mode code (see
10.1.1), must not extend the syntax of NumericLiteral to include
OctalIntegerLiteral as described in B.1.1.

A string literal is zero or more characters enclosed in single or double
quotes. Each character may be represented by an escape sequence. All
characters may appear literally in a string literal except for the
closing quote character, backslash, carriage return, line separator,
paragraph separator, and line feed. Any character may appear in the form
of an escape sequence.

Syntax

StringLiteral ::

" DoubleStringCharacters~opt~ "
' SingleStringCharacters~opt~ '

DoubleStringCharacters ::

DoubleStringCharacter DoubleStringCharacters~opt~

SingleStringCharacters ::

SingleStringCharacter SingleStringCharacters~opt~

DoubleStringCharacter ::

SourceCharacter BUT NOT ONE OF " OR \ OR LineTerminator
\ EscapeSequence
LineContinuation

SingleStringCharacter ::

SourceCharacter BUT NOT ONE OF ' OR \ OR LineTerminator
\ EscapeSequence
LineContinuation

LineContinuation ::

\ LineTerminatorSequence

EscapeSequence ::

CharacterEscapeSequence
0 [lookahead ∉ DecimalDigit]
HexEscapeSequence
UnicodeEscapeSequence

CharacterEscapeSequence ::

SingleEscapeCharacter
NonEscapeCharacter

SingleEscapeCharacter :: ONE OF

' " \ B F N R T V

NonEscapeCharacter ::

SourceCharacter BUT NOT ONE OF EscapeCharacter OR LineTerminator

EscapeCharacter ::

SingleEscapeCharacter
DecimalDigit
X
U

HexEscapeSequence ::

X HexDigit HexDigit

UnicodeEscapeSequence ::

U HexDigit HexDigit HexDigit HexDigit

The definition of the nonterminal HexDigit is given in 7.8.3.
SourceCharacter is defined in clause 6.

Semantics

A string literal stands for a value of the String type. The String value
(SV) of the literal is described in terms of character values (CV)
contributed by the various parts of the string literal. As part of this
process, some characters within the string literal are interpreted as
having a mathematical value (MV), as described below or in 7.8.3.

-   The SV of StringLiteral :: "" is the empty character sequence.

-   The SV of StringLiteral :: '' is the empty character sequence.

-   The SV of StringLiteral :: " DoubleStringCharacters " is the SV
    of DoubleStringCharacters.

-   The SV of StringLiteral :: ' SingleStringCharacters ' is the SV
    of SingleStringCharacters.

-   The SV of DoubleStringCharacters :: DoubleStringCharacter is a
    sequence of one character, the CV of DoubleStringCharacter.

-   The SV of DoubleStringCharacters :: DoubleStringCharacter
    DoubleStringCharacters is a sequence of the CV of
    DoubleStringCharacter followed by all the characters in the SV of
    DoubleStringCharacters in order.

-   The SV of SingleStringCharacters :: SingleStringCharacter is a
    sequence of one character, the CV of SingleStringCharacter.

-   The SV of SingleStringCharacters :: SingleStringCharacter
    SingleStringCharacters is a sequence of the CV of
    SingleStringCharacter followed by all the characters in the SV of
    SingleStringCharacters in order.

-   The SV of LineContinuation :: \ LineTerminatorSequence is the
    empty character sequence.

-   The CV of DoubleStringCharacter :: SourceCharacter BUT NOT ONE
    OF " OR \ OR LineTerminator is the SourceCharacter character
    itself.

-   The CV of DoubleStringCharacter :: \ EscapeSequence is the CV of
    the EscapeSequence.

-   The CV of DoubleStringCharacter :: LineContinuation is the empty
    character sequence.

-   The CV of SingleStringCharacter :: SourceCharacter BUT NOT ONE
    OF ' OR \ OR LineTerminator is the SourceCharacter character
    itself.

-   The CV of SingleStringCharacter :: \ EscapeSequence is the CV of
    the EscapeSequence.

-   The CV of SingleStringCharacter :: LineContinuation is the empty
    character sequence.

-   The CV of EscapeSequence :: CharacterEscapeSequence is the CV of
    the CharacterEscapeSequence.

-   The CV of EscapeSequence :: 0 [lookahead ∉ DecimalDigit] is a
    <NUL> character (Unicode value 0000).

-   The CV of EscapeSequence :: HexEscapeSequence is the CV of the
    HexEscapeSequence.

-   The CV of EscapeSequence :: UnicodeEscapeSequence is the CV of
    the UnicodeEscapeSequence.

-   The CV of CharacterEscapeSequence :: SingleEscapeCharacter is
    the character whose code unit value is determined by the
    SingleEscapeCharacter according to Table 4:

Table 4 — String Single Character Escape Sequences

  ------------------- ------------------- ---------------------- ----------
  _ESCAPE SEQUENCE_   _CODE UNIT VALUE_   NAME                 SYMBOL
  \B                  \U0008              backspace              <BS>
  \T                  \U0009              horizontal tab         <HT>
  \N                  \U000A              line feed (new line)   <LF>
  \V                  \U000B              vertical tab           <VT>
  \F                  \U000C              form feed              <FF>
  \R                  \U000D              carriage return        <CR>
  \"                  \U0022              double quote           "
  \'                  \U0027              single quote           '
  \\                  \U005C              backslash              \
  ------------------- ------------------- ---------------------- ----------

-   The CV of CharacterEscapeSequence :: NonEscapeCharacter is the
    CV of the NonEscapeCharacter.

-   The CV of NonEscapeCharacter :: SourceCharacter BUT NOT ONE OF
    EscapeCharacter OR LineTerminator is the SourceCharacter
    character itself.

-   The CV of HexEscapeSequence :: X HexDigit HexDigit is the
    character whose code unit value is (16 times the MV of the first
    HexDigit) plus the MV of the second HexDigit.

-   The CV of UnicodeEscapeSequence :: U HexDigit HexDigit
    HexDigit HexDigit is the character whose code unit value is
    (4096 times the MV of the first HexDigit) plus (256 times the MV
    of the second HexDigit) plus (16 times the MV of the third
    HexDigit) plus the MV of the fourth HexDigit.

A conforming implementation, when processing strict mode code (see
10.1.1), may not extend the syntax of EscapeSequence to include
OctalEscapeSequence as described in B.1.2.

NOTE A line terminator character cannot appear in a string literal,
except as part of a LineContinuation to produce the empty character
sequence. The correct way to cause a line terminator character to be
part of the String value of a string literal is to use an escape
sequence such as \N or \U000A.

A regular expression literal is an input element that is converted to a
RegExp object (see 15.10) each time the literal is evaluated. Two
regular expression literals in a program evaluate to regular expression
objects that never compare as === to each other even if the two
literals' contents are identical. A RegExp object may also be created at
runtime by NEW REGEXP (see 15.10.4) or calling the REGEXP constructor as
a function (15.10.3).

The productions below describe the syntax for a regular expression
literal and are used by the input element scanner to find the end of the
regular expression literal. The Strings of characters comprising the
RegularExpressionBody and the RegularExpressionFlags are passed
uninterpreted to the regular expression constructor, which interprets
them according to its own, more stringent grammar. An implementation may
extend the regular expression constructor's grammar, but it must not
extend the RegularExpressionBody and RegularExpressionFlags
productions or the productions used by these productions.

Syntax

RegularExpressionLiteral ::

/ RegularExpressionBody / RegularExpressionFlags

RegularExpressionBody ::

RegularExpressionFirstChar RegularExpressionChars

RegularExpressionChars ::

[empty]
RegularExpressionChars RegularExpressionChar

RegularExpressionFirstChar ::

RegularExpressionNonTerminator BUT NOT ONE OF * OR \ OR / OR [
RegularExpressionBackslashSequence
RegularExpressionClass

RegularExpressionChar ::

RegularExpressionNonTerminator BUT NOT ONE OF \ OR / OR [
RegularExpressionBackslashSequence
RegularExpressionClass

RegularExpressionBackslashSequence ::

\ RegularExpressionNonTerminator

RegularExpressionNonTerminator ::

SourceCharacter BUT NOT LineTerminator

RegularExpressionClass ::

[ RegularExpressionClassChars ]

RegularExpressionClassChars ::

[empty]
RegularExpressionClassChars RegularExpressionClassChar

RegularExpressionClassChar ::

RegularExpressionNonTerminator BUT NOT ONE OF ] OR \
RegularExpressionBackslashSequence

RegularExpressionFlags ::

[empty]
RegularExpressionFlags IdentifierPart

NOTE Regular expression literals may not be empty; instead of
representing an empty regular expression literal, the characters //
start a single-line comment. To specify an empty regular expression,
use: /(?:)/.

Semantics

A regular expression literal evaluates to a value of the Object type
that is an instance of the standard built-in constructor RegExp. This
value is determined in two steps: first, the characters comprising the
regular expression's RegularExpressionBody and
RegularExpressionFlags production expansions are collected
uninterpreted into two Strings Pattern and Flags, respectively. Then
each time the literal is evaluated, a new object is created as if by the
expression NEW REGEXP(Pattern, Flags) where RegExp is the standard
built-in constructor with that name. The newly constructed object
becomes the value of the RegularExpressionLiteral. If the call to NEW
REGEXP would generate an error as specified in 15.10.4.1, the error must
be treated as an early error (Clause 16).

Certain ECMAScript statements (empty statement, variable statement,
expression statement, DO-WHILE statement, CONTINUE statement, BREAK
statement, RETURN statement, and THROW statement) must be terminated
with semicolons. Such semicolons may always appear explicitly in the
source text. For convenience, however, such semicolons may be omitted
from the source text in certain situations. These situations are
described by saying that semicolons are automatically inserted into the
source code token stream in those situations.

There are three basic rules of semicolon insertion:

1.  When, as the program is parsed from left to right, a token (called
    the _offending token_) is encountered that is not allowed by any
    production of the grammar, then a semicolon is automatically
    inserted before the offending token if one or more of the following
    conditions is true:

-   The offending token is separated from the previous token by at least
    one LineTerminator.

-   The offending token is }.

    1.  When, as the program is parsed from left to right, the end of
        the input stream of tokens is encountered and the parser is
        unable to parse the input token stream as a single complete
        ECMAScript Program, then a semicolon is automatically inserted
        at the end of the input stream.

    2.  When, as the program is parsed from left to right, a token is
        encountered that is allowed by some production of the grammar,
        but the production is a _restricted production_ and the token
        would be the first token for a terminal or nonterminal
        immediately following the annotation “[no LineTerminator
        here]” within the restricted production (and therefore such a
        token is called a restricted token), and the restricted token is
        separated from the previous token by at least one
        LineTerminator, then a semicolon is automatically inserted
        before the restricted token.

However, there is an additional overriding condition on the preceding
rules: a semicolon is never inserted automatically if the semicolon
would then be parsed as an empty statement or if that semicolon would
become one of the two semicolons in the header of a FOR statement (see
12.6.3).

NOTE The following are the only restricted productions in the grammar:

PostfixExpression :

LeftHandSideExpression [no LineTerminator here] ++
LeftHandSideExpression [no LineTerminator here] --

ContinueStatement :

CONTINUE [no LineTerminator here] Identifier ;

BreakStatement :

BREAK [no LineTerminator here] Identifier ;

ReturnStatement :

RETURN [no LineTerminator here] Expression ;

ThrowStatement :

THROW [no LineTerminator here] Expression ;

The practical effect of these restricted productions is as follows:

  When a ++ or -- token is encountered where the parser would treat it
  as a postfix operator, and at least one LineTerminator occurred
  between the preceding token and the ++ or -- token, then a semicolon
  is automatically inserted before the ++ or -- token.

  When a CONTINUE, BREAK, RETURN, or THROW token is encountered and a
  LineTerminator is encountered before the next token, a semicolon is
  automatically inserted after the CONTINUE, BREAK, RETURN, or THROW
  token.

  The resulting practical advice to ECMAScript programmers is:

  A postfix ++ or -- operator should appear on the same line as its
  operand.

  An Expression in a RETURN or THROW statement should start on the
  same line as the RETURN or THROW token.

  An Identifier in a BREAK or CONTINUE statement should be on the same
  line as the BREAK or CONTINUE token.

The source

  { 1 2 } 3

is not a valid sentence in the ECMAScript grammar, even with the
automatic semicolon insertion rules. In contrast, the source

  { 1
  2 } 3

is also not a valid ECMAScript sentence, but is transformed by automatic
semicolon insertion into the following:

  { 1
  ;2 ;} 3;

which is a valid ECMAScript sentence.

The source

  for (a; b
  )

is not a valid ECMAScript sentence and is not altered by automatic
semicolon insertion because the semicolon is needed for the header of a
FOR statement. Automatic semicolon insertion never inserts one of the
two semicolons in the header of a FOR statement.

The source

  return
  a + b

is transformed by automatic semicolon insertion into the following:

  return;
  a + b;

NOTE The expression A + B is not treated as a value to be returned by
the RETURN statement, because a LineTerminator separates it from the
token RETURN.

The source

  a = b
  ++c

is transformed by automatic semicolon insertion into the following:

  a = b;
  ++c;

NOTE The token ++ is not treated as a postfix operator applying to the
variable B, because a LineTerminator occurs between B and ++.

The source

  if (a > b)
  else c = d

is not a valid ECMAScript sentence and is not altered by automatic
semicolon insertion before the ELSE token, even though no production of
the grammar applies at that point, because an automatically inserted
semicolon would then be parsed as an empty statement.

The source

  a = b + c
  (d + e).print()

is not transformed by automatic semicolon insertion, because the
parenthesised expression that begins the second line can be interpreted
as an argument list for a function call:

a = b + c(d + e).print()

In the circumstance that an assignment statement must begin with a left
parenthesis, it is a good idea for the programmer to provide an explicit
semicolon at the end of the preceding statement rather than to rely on
automatic semicolon insertion.

Algorithms within this specification manipulate values each of which has
an associated type. The possible value types are exactly those defined
in this clause. Types are further subclassified into ECMAScript language
types and specification types.

An ECMAScript language type corresponds to values that are directly
manipulated by an ECMAScript programmer using the ECMAScript language.
The ECMAScript language types are Undefined, Null, Boolean, String,
Number, and Object.

A specification type corresponds to meta-values that are used within
algorithms to describe the semantics of ECMAScript language constructs
and ECMAScript language types. The specification types are Reference,
List, Completion, Property Descriptor, Property Identifier, Lexical
Environment, and Environment Record. Specification type values are
specification artefacts that do not necessarily correspond to any
specific entity within an ECMAScript implementation. Specification type
values may be used to describe intermediate results of ECMAScript
expression evaluation but such values cannot be stored as properties of
objects or values of ECMAScript language variables.

Within this specification, the notation “Type(x)” is used as shorthand
for “the type of x” where “type” refers to the ECMAScript language and
specification types defined in this clause.

The Undefined type has exactly one value, called UNDEFINED. Any variable
that has not been assigned a value has the value UNDEFINED.

The Null type has exactly one value, called NULL.

The Boolean type represents a logical entity having two values, called
TRUE and FALSE.

The String type is the set of all finite ordered sequences of zero or
more 16-bit unsigned integer values (“elements”). The String type is
generally used to represent textual data in a running ECMAScript
program, in which case each element in the String is treated as a code
unit value (see Clause 6). Each element is regarded as occupying a
position within the sequence. These positions are indexed with
nonnegative integers. The first element (if any) is at position 0, the
next element (if any) at position 1, and so on. The length of a String
is the number of elements (i.e., 16-bit values) within it. The empty
String has length zero and therefore contains no elements.

When a String contains actual textual data, each element is considered
to be a single UTF-16 code unit. Whether or not this is the actual
storage format of a String, the characters within a String are numbered
by their initial code unit element position as though they were
represented using UTF-16. All operations on Strings (except as otherwise
stated) treat them as sequences of undifferentiated 16-bit unsigned
integers; they do not ensure the resulting String is in normalised form,
nor do they ensure language-sensitive results.

NOTE The rationale behind this design was to keep the implementation of
Strings as simple and high-performing as possible. The intent is that
textual data coming into the execution environment from outside (e.g.,
user input, text read from a file or received over the network, etc.) be
converted to Unicode Normalised Form C before the running program sees
it. Usually this would occur at the same time incoming text is converted
from its original character encoding to Unicode (and would impose no
additional overhead). Since it is recommended that ECMAScript source
code be in Normalised Form C, string literals are guaranteed to be
normalised (if source text is guaranteed to be normalised), as long as
they do not contain any Unicode escape sequences.

The Number type has exactly 18437736874454810627 (that is,
2^64^−2^53^+3) values, representing the double-precision 64-bit format
IEEE 754 values as specified in the IEEE Standard for Binary
Floating-Point Arithmetic, except that the 9007199254740990 (that is,
2^53^−2) distinct “Not-a-Number” values of the IEEE Standard are
represented in ECMAScript as a single special NAN value. (Note that the
NAN value is produced by the program expression NAN.) In some
implementations, external code might be able to detect a difference
between various Not-a-Number values, but such behaviour is
implementation-dependent; to ECMAScript code, all NaN values are
indistinguishable from each other.

There are two other special values, called POSITIVE INFINITY and
NEGATIVE INFINITY. For brevity, these values are also referred to for
expository purposes by the symbols +∞ and −∞, respectively. (Note that
these two infinite Number values are produced by the program expressions
+INFINITY (or simply INFINITY) and -INFINITY.)

The other 18437736874454810624 (that is, 2^64^−2^53^) values are called
the finite numbers. Half of these are positive numbers and half are
negative numbers; for every finite positive Number value there is a
corresponding negative value having the same magnitude.

Note that there is both a POSITIVE ZERO and a NEGATIVE ZERO. For
brevity, these values are also referred to for expository purposes by
the symbols +0 and −0, respectively. (Note that these two different zero
Number values are produced by the program expressions +0 (or simply 0)
and -0.)

The 18437736874454810622 (that is, 2^64^−2^53^−2) finite nonzero values
are of two kinds:

18428729675200069632 (that is, 2^64^−2^54^) of them are normalised,
having the form

  s × m × 2^e^

where s is +1 or −1, m is a positive integer less than 2^53^ but not
less than 2^52^, and e is an integer ranging from −1074 to 971,
inclusive.

The remaining 9007199254740990 (that is, 2^53^−2) values are
denormalised, having the form

  s × m × 2^e^

where s is +1 or −1, m is a positive integer less than 2^52^, and
e is −1074.

Note that all the positive and negative integers whose magnitude is no
greater than 2^53^ are representable in the Number type (indeed, the
integer 0 has two representations, +0 and -0).

A finite number has an _odd significand_ if it is nonzero and the
integer m used to express it (in one of the two forms shown above) is
odd. Otherwise, it has an _even significand_.

In this specification, the phrase “the Number value for x” where x
represents an exact nonzero real mathematical quantity (which might even
be an irrational number such as π) means a Number value chosen in the
following manner. Consider the set of all finite values of the Number
type, with −0 removed and with two additional values added to it that
are not representable in the Number type, namely 2^1024^ (which is +1 ×
2^53^ × 2^971^) and −2^1024^ (which is −1 × 2^53^ × 2^971^). Choose the
member of this set that is closest in value to x. If two values of the
set are equally close, then the one with an even significand is chosen;
for this purpose, the two extra values 2^1024^ and −2^1024^ are
considered to have even significands. Finally, if 2^1024^ was chosen,
replace it with +∞; if −2^1024^ was chosen, replace it with −∞; if +0
was chosen, replace it with −0 if and only if x is less than zero; any
other chosen value is used unchanged. The result is the Number value for
x. (This procedure corresponds exactly to the behaviour of the IEEE
754 “round to nearest” mode.)

Some ECMAScript operators deal only with integers in the range −2^31^
through 2^31^−1, inclusive, or in the range 0 through 2^32^−1,
inclusive. These operators accept any value of the Number type but first
convert each such value to one of 2^32^ integer values. See the
descriptions of the ToInt32 and ToUint32 operators in 9.5 and 9.6,
respectively.

An Object is a collection of properties. Each property is either a named
data property, a named accessor property, or an internal property:

-   A _named data property_ associates a name with an ECMAScript
    language value and a set of Boolean attributes.

-   A _named accessor property_ associates a name with one or two
    accessor functions, and a set of Boolean attributes. The accessor
    functions are used to store or retrieve an ECMAScript language value
    that is associated with the property.

-   An _internal property_ has no name and is not directly accessible
    via ECMAScript language operators. Internal properties exist purely
    for specification purposes.

There are two kinds of access for named (non-internal) properties: get
and put, corresponding to retrieval and assignment, respectively.

Attributes are used in this specification to define and explain the
state of named properties. A named data property associates a name with
the attributes listed in Table 5

Table 5 — Attributes of a Named Data Property

  _ATTRIBUTE NAME_   _VALUE DOMAIN_                 DESCRIPTION
  ------------------ ------------------------------ -------------------------------------------------------------------------------------------------------------------------------------------------------
  [[Value]]          Any ECMAScript language type   The value retrieved by reading the property.
  [[Writable]]       Boolean                        If FALSE, attempts by ECMAScript code to change the property’s [[Value]] attribute using [[Put]] will not succeed.
  [[Enumerable]]     Boolean                        If TRUE, the property will be enumerated by a for-in enumeration (see 12.6.4). Otherwise, the property is said to be non-enumerable.
  [[Configurable]]   Boolean                        If FALSE, attempts to delete the property, change the property to be an accessor property, or change its attributes (other than [[Value]]) will fail.

A named accessor property associates a name with the attributes listed
in Table 6.

Table 6 — Attributes of a Named Accessor Property

  _ATTRIBUTE NAME_   _VALUE DOMAIN_          DESCRIPTION
  ------------------ ----------------------- --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  [[Get]]            Object or Undefined   If the value is an Object it must be a function Object. The function’s [[Call]] internal method (8.6.2) is called with an empty arguments list to return the property value each time a get access of the property is performed.
  [[Set]]            Object or Undefined   If the value is an Object it must be a function Object. The function’s [[Call]] internal method (8.6.2) is called with an arguments list containing the assigned value as its sole argument each time a set access of the property is performed. The effect of a property's [[Set]] internal method may, but is not required to, have an effect on the value returned by subsequent calls to the property's [[Get]] internal method.
  [[Enumerable]]     Boolean                 If TRUE, the property is to be enumerated by a for-in enumeration (see 12.6.4). Otherwise, the property is said to be non-enumerable.
  [[Configurable]]   Boolean                 If FALSE, attempts to delete the property, change the property to be a data property, or change its attributes will fail.

If the value of an attribute is not explicitly specified by this
specification for a named property, the default value defined in Table 7
is used.

Table 7 — Default Attribute Values

  ATTRIBUTE NAME     DEFAULT VALUE
  ------------------ ---------------
  [[Value]]          UNDEFINED
  [[Get]]            UNDEFINED
  [[Set]]            UNDEFINED
  [[Writable]]       FALSE
  [[Enumerable]]     FALSE
  [[Configurable]]   FALSE

This specification uses various internal properties to define the
semantics of object values. These internal properties are not part of
the ECMAScript language. They are defined by this specification purely
for expository purposes. An implementation of ECMAScript must behave as
if it produced and operated upon internal properties in the manner
described here. The names of internal properties are enclosed in double
square brackets [[ ]]. When an algorithm uses an internal property of an
object and the object does not implement the indicated internal
property, a TYPEERROR exception is thrown.

The Table 8 summarises the internal properties used by this
specification that are applicable to all ECMAScript objects. The Table 9
summarises the internal properties used by this specification that are
only applicable to some ECMAScript objects. The descriptions in these
tables indicate their behaviour for native ECMAScript objects, unless
stated otherwise in this document for particular kinds of native
ECMAScript objects. Host objects may support these internal properties
with any implementation-dependent behaviour as long as it is consistent
with the specific host object restrictions stated in this document.

The “Value Type Domain” columns of the following tables define the types
of values associated with internal properties. The type names refer to
the types defined in Clause 8 augmented by the following additional
names. “any” means the value may be any ECMAScript language type.
“primitive” means Undefined, Null, Boolean, String, or Number.
“SpecOp” means the internal property is an internal method, an
implementation provided procedure defined by an abstract operation
specification. “SpecOp” is followed by a list of descriptive parameter
names. If a parameter name is the same as a type name then the name
describes the type of the parameter. If a “SpecOp” returns a value, its
parameter list is followed by the symbol “→” and the type of the
returned value.

Table 8 — Internal Properties Common to All Objects

  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  _INTERNAL PROPERTY_     _VALUE TYPE DOMAIN_                                                DESCRIPTION
  ----------------------- ------------------------------------------------------------------ ------------------------------------------------------------------------------------------------------------------------------------
  [[Prototype]]           Object or Null                                                   The prototype of this object.

                                                                                             

  [[Extensible]]          Boolean                                                            If TRUE, own properties may be added to the object.

  [[Get]]                 SpecOp(propertyName) → any                                     Returns the value of the named property.

  [[GetOwnProperty]]      SpecOp (propertyName) →                                        Returns the Property Descriptor of the named own property of this object, or UNDEFINED if absent.
                                                                                             
                          Undefined or Property Descriptor                                 

  [[GetProperty]]         SpecOp (propertyName) →                                        Returns the fully populated Property Descriptor of the named property of this object, or UNDEFINED if absent.
                                                                                             
                          Undefined or Property Descriptor                                 

  [[Put]]                 SpecOp (propertyName, _any, Boolean_)                            Sets the specified named property to the value of the second parameter. The flag controls failure handling.

  [[CanPut]]              SpecOp (propertyName) → Boolean                                Returns a Boolean value indicating whether a [[Put]] operation with PropertyName can be performed.

  [[HasProperty]]         SpecOp (propertyName) → Boolean                              Returns a Boolean value indicating whether the object already has a property with the given name.

  [[Delete]]              SpecOp (_propertyName, Boolean_) → Boolean                       Removes the specified named own property from the object. The flag controls failure handling.

  [[DefaultValue]]        SpecOp (Hint) → primitive                                    Hint is a String. Returns a default value for the object.

  [[DefineOwnProperty]]   SpecOp (_propertyName, PropertyDescriptor, Boolean_) → Boolean   Creates or alters the named own property to have the state described by a Property Descriptor. The flag controls failure handling.
  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Every object (including host objects) must implement all of the internal
properties listed in Table 8. However, the [[DefaultValue]] internal
method may, for some objects, simply throw a TYPEERROR exception.

All objects have an internal property called [[Prototype]]. The value of
this property is either NULL or an object and is used for implementing
inheritance. Whether or not a native object can have a host object as
its [[Prototype]] depends on the implementation. Every [[Prototype]]
chain must have finite length (that is, starting from any object,
recursively accessing the [[Prototype]] internal property must
eventually lead to a NULL value). Named data properties of the
[[Prototype]] object are inherited (are visible as properties of the
child object) for the purposes of get access, but not for put access.
Named accessor properties are inherited for both get access and put
access.

Every ECMAScript object has a Boolean-valued [[Extensible]] internal
property that controls whether or not named properties may be added to
the object. If the value of the [[Extensible]] internal property is
FALSE then additional named properties may not be added to the object.
In addition, if [[Extensible]] is FALSE the value of [[Prototype]]
internal properties of the object may not be modified. Once the value of
an [[Extensible]] internal property has been set to FALSE it may not be
subsequently changed to TRUE.

NOTE This specification defines no ECMAScript language operators or
built-in functions that permit a program to modify an object’s
[[Prototype]] internal properties or to change the value of
[[Extensible]] from FALSE to TRUE. Implementation specific extensions
that modify [[Prototype]] or [[Extensible]] must not violate the
invariants defined in the preceding paragraph.

Unless otherwise specified, the common internal methods of native
ECMAScript objects behave as described in 8.12. Array objects have a
slightly different implementation of the [[DefineOwnProperty]] internal
method (see 15.4.5.1) and String objects have a slightly different
implementation of the [[GetOwnProperty]] internal method (see 15.5.5.2).
Arguments objects (10.6) have different implementations of [[Get]],
[[GetOwnProperty]], [[DefineOwnProperty]], and [[Delete]]. Function
objects (15.3) have a different implementation of [[Get]].

Host objects may implement these internal methods in any manner unless
specified otherwise; for example, one possibility is that [[Get]] and
[[Put]] for a particular host object indeed fetch and store property
values but [[HasProperty]] always generates FALSE. However, if any
specified manipulation of a host object's internal properties is not
supported by an implementation, that manipulation must throw a TYPEERROR
exception when attempted.

The [[GetOwnProperty]] internal method of a host object must conform to
the following invariants for each property of the host object:

-   If a property is described as a data property and it may return
    different values over time, then either or both of the [[Writable]]
    and [[Configurable]] attributes must be TRUE even if no mechanism to
    change the value is exposed via the other internal methods.

-   If a property is described as a data property and its [[Writable]]
    and [[Configurable]] are both FALSE, then the SameValue (according
    to 9.12) must be returned for the [[Value]] attribute of the
    property on all calls to [[GetOwnProperty]].

-   If the attributes other than [[Writable]] may change over time or if
    the property might disappear, then the [[Configurable]] attribute
    must be TRUE.

-   If the [[Writable]] attribute may change from FALSE to TRUE, then
    the [[Configurable]] attribute must be TRUE.

-   If the value of the host object’s [[Extensible]] internal property
    has been observed by ECMAScript code to be FALSE, then if a call to
    [[GetOwnProperty]] describes a property as non-existent all
    subsequent calls must also describe that property as non-existent.

The [[DefineOwnProperty]] internal method of a host object must not
permit the addition of a new property to a host object if the
[[Extensible]] internal property of that host object has been observed
by ECMAScript code to be FALSE.

If the [[Extensible]] internal property of that host object has been
observed by ECMAScript code to be FALSE then it must not subsequently
become TRUE.

Table 9 — Internal Properties Only Defined for Some Objects

  _INTERNAL PROPERTY_    _VALUE TYPE DOMAIN_                                     DESCRIPTION
  ---------------------- ------------------------------------------------------- ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  [[NativeBrand]]        Members of the NativeBrand enumeration.                 A tag value used by this specification to categorize various kinds of native ECMAScript objects defined in this specification. Host objects do not have this internal property.
  [[PrimitiveValue]]     primitive                                             Internal state information associated with this object. Of the standard built-in ECMAScript objects, only Boolean, Date, Number, and String objects implement [[PrimitiveValue]].
  [[Construct]]          SpecOp(a List of any) → Object                      Creates an object. Invoked via the NEW operator. The arguments to the SpecOp are the arguments passed to the NEW operator. Objects that implement this internal method are called constructors.
  [[Call]]               SpecOp(any, a List of any) → any or Reference   Executes code associated with the object. Invoked via a function call expression. The arguments to the SpecOp are this object and a list containing the arguments passed to the function call expression. Objects that implement this internal method are callable. Only callable objects that are host objects may return Reference values.
  [[HasInstance]]        SpecOp(any) → Boolean                               Returns a Boolean value indicating whether the argument is likely an Object that was constructed by this object. Of the standard built-in ECMAScript objects, only Function objects implement [[HasInstance]].
  [[Scope]]              Lexical Environment                                     A lexical environment that is the environment in which a Function object is executed. Of the standard built-in ECMAScript objects, only Function objects implement [[Scope]].
  [[FormalParameters]]   Parse Tree                                              A parse tree for ECMAScript code parsed with FormalParameterList as the goal symbol. Of the standard built-in ECMAScript objects, only Function objects implement [[FormalParameters]].
  [[Code]]               Parse Tree                                              A parse tree for ECMAScript code parsed with FunctionBody as the goal symbol. Of the standard built-in ECMAScript objects, only Function objects implement [[Code]].
  [[Strict]]             Boolean                                                 True if a Function object is a strict mode function. Of the standard built-in ECMAScript objects, only Function objects implement [[Strict]].
  [[TargetFunction]]     Object                                                  The target function of a function object created using the standard built-in Function.prototype.bind method. Only ECMAScript objects created using Function.prototype.bind have a [[TargetFunction]] internal property.
  [[BoundThis]]          any                                                   The pre-bound this value of a function Object created using the standard built-in Function.prototype.bind method. Only ECMAScript objects created using Function.prototype.bind have a [[BoundThis]] internal property.
  [[BoundArguments]]     List of any                                           The pre-bound argument values of a function Object created by the standard built-in Function.prototype.bind method. Only objects created by Function.prototype.bind have a [[BoundArguments]] internal property.
  [[Match]]              SpecOp(String, index) → MatchResult             Tests for a regular expression match and returns a MatchResult value (see 15.10.2.1). Of the standard built-in ECMAScript objects, only RegExp objects implement [[Match]].
  [[ParameterMap]]       Object                                                  Provides a mapping between the properties of an arguments object (see 10.6) and the formal parameters of the associated function. Only objects that are arguments objects have a [[ParameterMap]] internal property.

The [[NativeBrand]] internal property is used to identify native
ECMASCript objects as objects that conform to specific parts of this
specification. The value of a [[NativeBrand]] property is a single
member of this set of enumerated values: NativeFunction, NativeArray,
StringWrapper, BooleanWrapper, NumberWrapper, NativeMath, NativeDate,
NativeRegExp, NativeError, NativeJSON, NativeArguments. The actual value
of the [[NativeBrand]] internal property is only used to identify
specific kinds of native ECMAScript objects. Host objects do not have
this internal property,

Table 10 — Values of the [[NativeBrand]] Internal Property

  _INTERNAL PROPERTY_   CATEGORY          DESCRIPTION
  --------------------- ------------------- ---------------
  NativeFunction        Function objects    
  NativeArray           Array objects       
  StringWrapper         String objects      
  BooleanWrapper        Boolean objects     
  NumberWrapper         Number objects      
  NativeMath            The Math object     
  NativeDate            Date objects        
  NativeRegExp          RegExp objects      
  NativeError           Error objects       
  NativeJSON            The JSON object     
  NativeArguments       Arguments objects   
                                            

NOTE The Reference type is used to explain the behaviour of such
operators as DELETE, TYPEOF, and the assignment operators. For example,
the left-hand operand of an assignment is expected to produce a
reference. The behaviour of assignment could, instead, be explained
entirely in terms of a case analysis on the syntactic form of the
left-hand operand of an assignment operator, but for one difficulty:
function calls are permitted to return references. This possibility is
admitted purely for the sake of host objects. No built-in ECMAScript
function defined by this specification returns a reference and there is
no provision for a user-defined function to return a reference. (Another
reason not to use a syntactic case analysis is that it would be lengthy
and awkward, affecting many parts of the specification.)

A REFERENCE is a resolved name binding. A Reference consists of three
components, the base value, the _referenced name_ and the Boolean
valued _strict reference_ flag. The base value is either UNDEFINED, an
Object, a Boolean, a String, a Number, or an environment record
(10.2.1). A base value of UNDEFINED indicates that the Reference could
not be resolved to a binding. The _referenced name_ is a String.

A Super Reference is a Reference that is used to represents a name
binding that was expressed using the SUPER keyword. A Super Reference
has an additional thisValue component and its base value will never
be an environment record.

The following abstract operations are used in this specification to
access the components of references:

-   GetBase(V). Returns the base value component of the reference V.

-   GetReferencedName(V). Returns the referenced name component of the
    reference V.

-   IsStrictReference(V). Returns the strict reference component of the
    reference V.

-   HasPrimitiveBase(V). Returns TRUE if the base value is a Boolean,
    String, or Number.

-   IsPropertyReference(V). Returns TRUE if either the base value is an
    object or HasPrimitiveBase(V) is TRUE; otherwise returns FALSE.

-   IsUnresolvableReference(V). Returns TRUE if the base value is
    UNDEFINED and FALSE otherwise.

-   IsSuperReference(V). Returns TRUE if this reference has a
    thisValue component.

The following abstract operations are used in this specification to
operate on references:

The following [[Get]] internal method is used by GetValue when V is a
property reference with a primitive base value. base is the value the
internal method is called upon with property name P as its argument.
The following steps are taken:

NOTE The object that may be created in step 1 is not accessible outside
of the above method. An implementation might choose to avoid the actual
creation of the object. The only situation where such an actual property
access that uses this internal method can have visible effect is when it
invokes an accessor function.

The following [[Put]] internal method is used by PutValue when V is a
property reference with a primitive base value. base is the value the
internal method is called upon with property name P, value W, and
Boolean flag Throw as arguments. The following steps are taken:

NOTE The object that may be created in step 1 is not accessible outside
of the above method. An implementation might choose to avoid the actual
creation of that transient object. The only situations where such an
actual property assignment that uses this internal method can have
visible effect are when it either invokes an accessor function or is in
violation of a Throw predicated error check. When Throw is TRUE any
property assignment that would create a new property on the transient
object throws an error.

The List type is used to explain the evaluation of argument lists (see
11.2.4) in NEW expressions, in function calls, and in other algorithms
where a simple list of values is needed. Values of the List type are
simply ordered sequences of values. These sequences may be of any
length.

The Completion type is used to explain the behaviour of statements
(BREAK, CONTINUE, RETURN and THROW) that perform nonlocal transfers of
control. Values of the Completion type are triples of the form (type,
value, target), where type is one of NORMAL, BREAK, CONTINUE,
RETURN, or THROW, value is any ECMAScript language value or EMPTY, and
target is any ECMAScript identifier or EMPTY. If cv is a completion
value then cv.type, cv.value, and cv.target may be used to
directly refer to its constituent values.

The term “abrupt completion” refers to any completion with a type
other than NORMAL.

The Property Descriptor type is used to explain the manipulation and
reification of named property attributes. Values of the Property
Descriptor type are records composed of named fields where each field’s
name is an attribute name and its value is a corresponding attribute
value as specified in 8.6.1. In addition, any field may be present or
absent.

Property Descriptor values may be further classified as data property
descriptors and accessor property descriptors based upon the existence
or use of certain fields. A data property descriptor is one that
includes any fields named either [[Value]] or [[Writable]]. An accessor
property descriptor is one that includes any fields named either [[Get]]
or [[Set]]. Any property descriptor may have fields named [[Enumerable]]
and [[Configurable]]. A Property Descriptor value may not be both a data
property descriptor and an accessor property descriptor; however, it may
be neither. A generic property descriptor is a Property Descriptor value
that is neither a data property descriptor nor an accessor property
descriptor. A fully populated property descriptor is one that is either
an accessor property descriptor or a data property descriptor and that
has all of the fields that correspond to the property attributes defined
in either 8.6.1 Table 5 or Table 6.

For notational convenience within this specification, an object
literal-like syntax can be used to define a property descriptor value.
For example, Property Descriptor {[[Value]]: 42, [[Writable]]: FALSE,
[[Configurable]]: TRUE} defines a data property descriptor. Field name
order is not significant. Any fields that are not explicitly listed are
considered to be absent.

In specification text and algorithms, dot notation may be used to refer
to a specific field of a Property Descriptor. For example, if D is a
property descriptor then D.[[Value]] is shorthand for “the field of D
named [[Value]]”.

The Property Identifier type is used to associate a property name with a
Property Descriptor. Values of the Property Identifier type are pairs of
the form (name, descriptor), where name is a String and descriptor is a
Property Descriptor value.

The following abstract operations are used in this specification to
operate upon Property Descriptor values:

When the abstract operation IsAccessorDescriptor is called with property
descriptor Desc, the following steps are taken:

When the abstract operation IsDataDescriptor is called with property
descriptor Desc, the following steps are taken:

When the abstract operation IsGenericDescriptor is called with property
descriptor Desc, the following steps are taken:

When the abstract operation FromPropertyDescriptor is called with
property descriptor Desc, the following steps are taken:

The following algorithm assumes that Desc is a fully populated
Property Descriptor, such as that returned from [[GetOwnProperty]] (see
8.12.1).

When the abstract operation ToPropertyDescriptor is called with object
Obj, the following steps are taken:

The Lexical Environment and Environment Record types are used to explain
the behaviour of name resolution in nested functions and blocks. These
types and the operations upon them are defined in Clause 10.

In the following algorithm descriptions, assume O is a native
ECMAScript object, P is a String, Desc is a Property Description
record, and Throw is a Boolean flag.

When the [[GetOwnProperty]] internal method of O is called with
property name P, the following steps are taken:

However, if O is a String object it has a more elaborate
[[GetOwnProperty]] internal method defined in 15.5.5.2.

When the [[GetProperty]] internal method of O is called with property
name P, the following steps are taken:

When the [[Get]] internal method of O is called with property name
P, the following steps are taken:

1.  Let desc be the result of calling the [[GetProperty]] internal
    method of O with property name P.

2.  If desc is UNDEFINED, return UNDEFINED.

3.  If IsDataDescriptor(desc) is TRUE, return desc.[[Value]].

4.  Otherwise, IsAccessorDescriptor(desc) must be true so, let
    getter be desc.[[Get]].

5.  If getter is UNDEFINED, return UNDEFINED.

6.  Return the result calling the [[Call]] internal method of getter
    providing O as the THIS value and providing no arguments.

When the [[CanPut]] internal method of O is called with property name
P, the following steps are taken:

Host objects may define additional constraints upon [[Put]] operations.
If possible, host objects should not allow [[Put]] operations in
situations where this definition of [[CanPut]] returns false.

When the [[Put]] internal method of O is called with property P,
value V, and Boolean flag Throw, the following steps are taken:

When the [[HasProperty]] internal method of O is called with property
name P, the following steps are taken:

When the [[Delete]] internal method of O is called with property name
P and the Boolean flag Throw, the following steps are taken:

When the [[DefaultValue]] internal method of O is called with hint
String, the following steps are taken:

When the [[DefaultValue]] internal method of O is called with hint
Number, the following steps are taken:

When the [[DefaultValue]] internal method of O is called with no hint,
then it behaves as if the hint were Number, unless O is a Date object
(see 15.9.6), in which case it behaves as if the hint were String.

The above specification of [[DefaultValue]] for native objects can
return only primitive values. If a host object implements its own
[[DefaultValue]] internal method, it must ensure that its
[[DefaultValue]] internal method can return only primitive values.

In the following algorithm, the term “Reject” means “If Throw is TRUE,
then throw a TYPEERROR exception, otherwise return FALSE”. The algorithm
contains steps that test various fields of the Property Descriptor
Desc for specific values. The fields that are tested in this manner
need not actually exist in Desc. If a field is absent then its value
is considered to be FALSE.

When the [[DefineOwnProperty]] internal method of O is called with
property name P, property descriptor Desc, and Boolean flag Throw,
the following steps are taken:

However, if O has an [[NativeBrand]] internal property whose value is
NativeArray O also has a more elaborate [[DefineOwnProperty]] internal
method defined in 15.4.5.1.

NOTE Step 10.b allows any field of Desc to be different from the
corresponding field of current if current’s [[Configurable]] field is
TRUE. This even permits changing the [[Value]] of a property whose
[[Writable]] attribute is FALSE. This is allowed because a TRUE
[[Configurable]] attribute would permit an equivalent sequence of calls
where [[Writable]] is first set to TRUE, a new [[Value]] is set, and
then [[Writable]] is set to FALSE.

The ECMAScript runtime system performs automatic type conversion as
needed. To clarify the semantics of certain constructs it is useful to
define a set of conversion abstract operations. These abstract
operations are not a part of the language; they are defined here to aid
the specification of the semantics of the language. The conversion
abstract operations are polymorphic; that is, they can accept a value of
any ECMAScript language type, but not of specification types.

The abstract operation ToPrimitive takes an input argument and an
optional argument PreferredType. The abstract operation ToPrimitive
converts its input argument to a non-Object type. If an object is
capable of converting to more than one primitive type, it may use the
optional hint PreferredType to favour that type. Conversion occurs
according to Table 11:

Table 11 — ToPrimitive Conversions

  -------------- ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  _INPUT TYPE_   RESULT
  Undefined      The result equals the input argument (no conversion).
  Null           The result equals the input argument (no conversion).
  Boolean        The result equals the input argument (no conversion).
  Number         The result equals the input argument (no conversion).
  String         The result equals the input argument (no conversion).
  Object         Return a default value for the Object. The default value of an object is retrieved by calling the [[DefaultValue]] internal method of the object, passing the optional hint PreferredType. The behaviour of the [[DefaultValue]] internal method is defined by this specification for all native ECMAScript objects in 8.12.8.
  -------------- ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

The abstract operation ToBoolean converts its argument to a value of
type Boolean according to Table 12:

Table 12 — ToBoolean Conversions

  ----------------- -------------------------------------------------------------------------------------------------------------
  _ARGUMENT TYPE_   RESULT
  Undefined         FALSE
  Null              FALSE
  Boolean           The result equals the input argument (no conversion).
  Number            The result is FALSE if the argument is +0, −0, or NAN; otherwise the result is TRUE.
  String            The result is FALSE if the argument is the empty String (its length is zero); otherwise the result is TRUE.
  Object            TRUE
  ----------------- -------------------------------------------------------------------------------------------------------------

The abstract operation ToNumber converts its argument to a value of type
Number according to Table 13:

Table 13 — To Number Conversions

  ----------------- -------------------------------------------------------------------------------------
  _ARGUMENT TYPE_   RESULT

  Undefined         NAN

  Null              +0

  Boolean           The result is 1 if the argument is TRUE. The result is +0 if the argument is FALSE.

  Number            The result equals the input argument (no conversion).

  String            See grammar and note below.

  Object            Apply the following steps:
                    
                    Let primValue be ToPrimitive(_input argument_, hint Number).
                    
                    Return ToNumber(primValue).
  ----------------- -------------------------------------------------------------------------------------

ToNumber applied to Strings applies the following grammar to the input
String. If the grammar cannot interpret the String as an expansion of
StringNumericLiteral, then the result of ToNumber is NAN.

Syntax

StringNumericLiteral :::

StrWhiteSpace~opt~
StrWhiteSpace~opt~ StrNumericLiteral StrWhiteSpace~opt~

StrWhiteSpace :::

StrWhiteSpaceChar StrWhiteSpace~opt~

StrWhiteSpaceChar :::

WhiteSpace
LineTerminator

StrNumericLiteral :::

StrDecimalLiteral
HexIntegerLiteral

StrDecimalLiteral :::

StrUnsignedDecimalLiteral
+ StrUnsignedDecimalLiteral
- StrUnsignedDecimalLiteral

StrUnsignedDecimalLiteral :::

INFINITY
 DecimalDigits . DecimalDigits~opt~ ExponentPart~opt~
. DecimalDigits ExponentPart~opt~
DecimalDigits ExponentPart~opt~

DecimalDigits :::

DecimalDigit
DecimalDigits DecimalDigit

DecimalDigit ::: ONE OF

0 1 2 3 4 5 6 7 8 9

ExponentPart :::

ExponentIndicator SignedInteger

ExponentIndicator ::: ONE OF

E E

SignedInteger :::

DecimalDigits
+ DecimalDigits
- DecimalDigits

HexIntegerLiteral :::

0X HexDigit
0X HexDigit
HexIntegerLiteral HexDigit

HexDigit ::: ONE OF

0 1 2 3 4 5 6 7 8 9 A B C D E F A B C D E F

Some differences should be noted between the syntax of a
StringNumericLiteral and a NumericLiteral (see 7.8.3):

-   A StringNumericLiteral may be preceded and/or followed by white
    space and/or line terminators.

-   A StringNumericLiteral that is decimal may have any number of
    leading 0 digits.

-   A StringNumericLiteral that is decimal may be preceded by + or -
    to indicate its sign.

-   A StringNumericLiteral that is empty or contains only white space
    is converted to +0.

The conversion of a String to a Number value is similar overall to the
determination of the Number value for a numeric literal (see 7.8.3), but
some of the details are different, so the process for converting a
String numeric literal to a value of Number type is given here in full.
This value is determined in two steps: first, a mathematical value (MV)
is derived from the String numeric literal; second, this mathematical
value is rounded as described below.

-   The MV of StringNumericLiteral ::: [empty] is 0.

-   The MV of StringNumericLiteral ::: StrWhiteSpace is 0.

-   The MV of StringNumericLiteral ::: StrWhiteSpace~opt~
      StrNumericLiteral StrWhiteSpace~opt~ is the MV of
      StrNumericLiteral, no matter whether white space is present or
      not.

-   The MV of StrNumericLiteral ::: StrDecimalLiteral is the MV of
      StrDecimalLiteral.

-   The MV of StrNumericLiteral ::: HexIntegerLiteral is the MV of
      HexIntegerLiteral.

-   The MV of StrDecimalLiteral ::: StrUnsignedDecimalLiteral is the
      MV of StrUnsignedDecimalLiteral.

-   The MV of StrDecimalLiteral ::: + StrUnsignedDecimalLiteral is
      the MV of StrUnsignedDecimalLiteral.

-   The MV of StrDecimalLiteral ::: - StrUnsignedDecimalLiteral is
      the negative of the MV of StrUnsignedDecimalLiteral. (Note that
      if the MV of StrUnsignedDecimalLiteral is 0, the negative of
      this MV is also 0. The rounding rule described below handles the
      conversion of this signless mathematical zero to a floating-point
      +0 or −0 as appropriate.)

-   The MV of StrUnsignedDecimalLiteral::: INFINITY is 10^10000^ (a
      value so large that it will round to +∞).

-   The MV of StrUnsignedDecimalLiteral::: DecimalDigits. is the MV
      of DecimalDigits.

-   The MV of StrUnsignedDecimalLiteral::: DecimalDigits .
      DecimalDigits is the MV of the first DecimalDigits plus (the
      MV of the second DecimalDigits times 10^−n^), where n is the
      number of characters in the second DecimalDigits.

-   The MV of StrUnsignedDecimalLiteral::: DecimalDigits.
      ExponentPart is the MV of DecimalDigits times 10^e^, where
      e is the MV of ExponentPart.

-   The MV of StrUnsignedDecimalLiteral::: DecimalDigits.
      _DecimalDigits ExponentPart_ is (the MV of the first
      DecimalDigits plus (the MV of the second DecimalDigits times
      10^−n^)) times 10^e^, where n is the number of characters in
      the second DecimalDigits and e is the MV of ExponentPart.

-   The MV of StrUnsignedDecimalLiteral:::. DecimalDigits is the MV
      of DecimalDigits times 10^−n^, where n is the number of
      characters in DecimalDigits.

-   The MV of StrUnsignedDecimalLiteral:::. _DecimalDigits
      ExponentPart_ is the MV of DecimalDigits times 10^e_−_n^,
      where n is the number of characters in DecimalDigits and e
      is the MV of ExponentPart.

-   The MV of StrUnsignedDecimalLiteral::: DecimalDigits is the MV
      of DecimalDigits.

-   The MV of StrUnsignedDecimalLiteral::: DecimalDigits
      ExponentPart is the MV of DecimalDigits times 10^e^, where
      e is the MV of ExponentPart.

-   The MV of DecimalDigits ::: DecimalDigit is the MV of
      DecimalDigit.

-   The MV of DecimalDigits ::: DecimalDigits DecimalDigit is (the
      MV of DecimalDigits times 10) plus the MV of DecimalDigit.

-   The MV of ExponentPart ::: _ExponentIndicator SignedInteger_ is
      the MV of SignedInteger.

-   The MV of SignedInteger ::: DecimalDigits is the MV of
      DecimalDigits.

-   The MV of SignedInteger ::: + DecimalDigits is the MV of
      DecimalDigits.

-   The MV of SignedInteger ::: - DecimalDigits is the negative of
      the MV of DecimalDigits.

-   The MV of DecimalDigit ::: 0 or of HexDigit ::: 0 is 0.

-   The MV of DecimalDigit ::: 1 or of HexDigit ::: 1 is 1.

-   The MV of DecimalDigit ::: 2 or of HexDigit ::: 2 is 2.

-   The MV of DecimalDigit ::: 3 or of HexDigit ::: 3 is 3.

-   The MV of DecimalDigit ::: 4 or of HexDigit ::: 4 is 4.

-   The MV of DecimalDigit ::: 5 or of HexDigit ::: 5 is 5.

-   The MV of DecimalDigit ::: 6 or of HexDigit ::: 6 is 6.

-   The MV of DecimalDigit ::: 7 or of HexDigit ::: 7 is 7.

-   The MV of DecimalDigit ::: 8 or of HexDigit ::: 8 is 8.

-   The MV of DecimalDigit ::: 9 or of HexDigit ::: 9 is 9.

-   The MV of HexDigit ::: A or of HexDigit ::: A is 10.

-   The MV of HexDigit ::: B or of HexDigit ::: B is 11.

-   The MV of HexDigit ::: C or of HexDigit ::: C is 12.

-   The MV of HexDigit ::: D or of HexDigit ::: D is 13.

-   The MV of HexDigit ::: E or of HexDigit ::: E is 14.

-   The MV of HexDigit ::: F or of HexDigit ::: F is 15.

-   The MV of HexIntegerLiteral ::: 0X HexDigit is the MV of
      HexDigit.

-   The MV of HexIntegerLiteral ::: 0X HexDigit is the MV of
      HexDigit.

-   The MV of HexIntegerLiteral ::: HexIntegerLiteral HexDigit is
      (the MV of HexIntegerLiteral times 16) plus the MV of
      HexDigit.

Once the exact MV for a String numeric literal has been determined, it
is then rounded to a value of the Number type. If the MV is 0, then the
rounded value is +0 unless the first non white space character in the
String numeric literal is ‘-’, in which case the rounded value is −0.
Otherwise, the rounded value must be the Number value for the MV (in the
sense defined in 8.5), unless the literal includes a
StrUnsignedDecimalLiteral and the literal has more than 20 significant
digits, in which case the Number value may be either the Number value
for the MV of a literal produced by replacing each significant digit
after the 20th with a 0 digit or the Number value for the MV of a
literal produced by replacing each significant digit after the 20th with
a 0 digit and then incrementing the literal at the 20th digit position.
A digit is significant if it is not part of an ExponentPart and

-   it is not 0; or

-   there is a nonzero digit to its left and there is a nonzero digit,
    not in the ExponentPart, to its right.

The abstract operation ToInteger converts its argument to an integral
numeric value. This abstract operation functions as follows:

The abstract operation ToInt32 converts its argument to one of 2^32^
integer values in the range −2^31^ through 2^31^−1, inclusive. This
abstract operation functions as follows:

NOTE Given the above definition of ToInt32:

-   The ToInt32 abstract operation is idempotent: if applied to a result
      that it produced, the second application leaves that value
      unchanged.

-   ToInt32(ToUint32(x)) is equal to ToInt32(x) for all values of
      x. (It is to preserve this latter property that +∞ and −∞ are
      mapped to +0.)

-   ToInt32 maps −0 to +0.

The abstract operation ToUint32 converts its argument to one of 2^32^
integer values in the range 0 through 2^32^−1, inclusive. This
abstraction operation functions as follows:

NOTE Given the above definition of ToUInt32:

-   Step 5 is the only difference between ToUint32 and ToInt32.

-   The ToUint32 abstract operation is idempotent: if applied to a
      result that it produced, the second application leaves that value
      unchanged.

-   ToUint32(ToInt32(x)) is equal to ToUint32(x) for all values of
      x. (It is to preserve this latter property that +∞ and −∞ are
      mapped to +0.)

-   ToUint32 maps −0 to +0.

The abstract operation ToUint16 converts its argument to one of 2^16^
integer values in the range 0 through 2^16^−1, inclusive. This abstract
operation functions as follows:

NOTE Given the above definition of ToUint16:

-   The substitution of 2^16^ for 2^32^ in step 4 is the only difference
      between ToUint32 and ToUint16.

-   ToUint16 maps −0 to +0.

The abstract operation ToString converts its argument to a value of type
String according to Table 14:

Table 14 — ToString Conversions

  ----------------- -----------------------------------------------------------------
  _ARGUMENT TYPE_   RESULT

  Undefined         "UNDEFINED"

  Null              "NULL"

  Boolean           If the argument is TRUE, then the result is "TRUE".
                    
                    If the argument is FALSE, then the result is "FALSE".

  Number            See 9.8.1.

  String            Return the input argument (no conversion)

  Object            Apply the following steps:
                    
                    1. Let primValue be ToPrimitive(input argument, hint String).
                    
                    2. Return ToString(primValue).
  ----------------- -----------------------------------------------------------------

The abstract operation ToString converts a Number m to String format
as follows:

NOTE 1 The following observations may be useful as guidelines for
implementations, but are not part of the normative requirements of this
Standard:

-   If x is any Number value other than −0, then ToNumber(ToString(x))
      is exactly the same Number value as x.

-   The least significant digit of s is not always uniquely determined
      by the requirements listed in step 5.

NOTE 2 For implementations that provide more accurate conversions than
required by the rules above, it is recommended that the following
alternative version of step 5 be used as a guideline:

  Otherwise, let n, k, and s be integers such that k ≥ 1,
  10^k−1^ ≤ s < 10^k^, the Number value for s × 10^n_−_k^ is
  m, and k is as small as possible. If there are multiple
  possibilities for s, choose the value of s for which s ×
  10^n_−_k^ is closest in value to m. If there are two such possible
  values of s, choose the one that is even. Note that k is the
  number of digits in the decimal representation of s and that s is
  not divisible by 10.

NOTE 3 Implementers of ECMAScript may find useful the paper and code
written by David M. Gay for binary-to-decimal conversion of
floating-point numbers:

  Gay, David M. Correctly Rounded Binary-Decimal and Decimal-Binary
  Conversions. Numerical Analysis, Manuscript 90-10. AT&T Bell
  Laboratories (Murray Hill, New Jersey). November 30, 1990. Available
  as
  http://cm.bell-labs.com/cm/cs/doc/90/4-10.ps.gz. Associated code
  available as
  http://cm.bell-labs.com/netlib/fp/dtoa.c.gz and as
  http://cm.bell-labs.com/netlib/fp/g_fmt.c.gz and may also be found at
  the various NETLIB mirror sites.

The abstract operation ToObject converts its argument to a value of type
Object according to Table 15:

Table 15 — ToObject

  ----------------- ------------------------------------------------------------------------------------------------------------------------------------------------------------
  _ARGUMENT TYPE_   RESULT
  Undefined         Throw a TYPEERROR exception.
  Null              Throw a TYPEERROR exception.
  Boolean           Create a new Boolean object whose [[PrimitiveValue]] internal property is set to the value of the argument. See 15.6 for a description of Boolean objects.
  Number            Create a new Number object whose [[PrimitiveValue]] internal property is set to the value of the argument. See 15.7 for a description of Number objects.
  String            Create a new String object whose [[PrimitiveValue]] internal property is set to the value of the argument. See 15.5 for a description of String objects.
  Object            The result is the input argument (no conversion).
  ----------------- ------------------------------------------------------------------------------------------------------------------------------------------------------------

The abstract operation CheckObjectCoercible throws an error if its
argument is a value that cannot be converted to an Object using
ToObject. It is defined by Table 16:

Table 16 — CheckObjectCoercible Results

  _ARGUMENT TYPE_   RESULT
  ----------------- ------------------------------
  Undefined         Throw a TYPEERROR exception.
  Null              Throw a TYPEERROR exception.
  Boolean           Return
  Number            Return
  String            Return
  Object            Return

The abstract operation IsCallable determines if its argument, which must
be an ECMAScript language value, is a callable function Object according
to Table 17:

Table 17 — IsCallable Results

  ----------------- --------------------------------------------------------------------------------------------------
  _ARGUMENT TYPE_   RESULT
  Undefined         Return FALSE.
  Null              Return FALSE.
  Boolean           Return FALSE.
  Number            Return FALSE.
  String            Return FALSE.
  Object            If the argument object has a [[Call]] internal method, then return TRUE, otherwise return FALSE.
  ----------------- --------------------------------------------------------------------------------------------------

The internal comparison abstract operation SameValue(x, y), where
x and y are ECMAScript language values, produces TRUE or FALSE. Such
a comparison is performed as follows:

There are three types of ECMAScript executable code:

-   _Global code_ is source text that is treated as an ECMAScript
      Program. The global code of a particular Program does not
      include any source text that is parsed as part of a
      FunctionBody.

-   _Eval code_ is the source text supplied to the built-in EVAL
      function. More precisely, if the parameter to the built-in EVAL
      function is a String, it is treated as an ECMAScript Program.
      The eval code for a particular invocation of EVAL is the global
      code portion of that Program.

-   _Function code_ is source text that is parsed as part of a
      FunctionBody. The _function code_ of a particular FunctionBody
      does not include any source text that is parsed as part of a
      nested FunctionBody. _Function code_ also denotes the source
      text supplied when using the built-in FUNCTION object as a
      constructor. More precisely, the last parameter provided to the
      FUNCTION constructor is converted to a String and treated as the
      FunctionBody. If more than one parameter is provided to the
      FUNCTION constructor, all parameters except the last one are
      converted to Strings and concatenated together, separated by
      commas. The resulting String is interpreted as the
      FormalParameterList for the FunctionBody defined by the last
      parameter. The function code for a particular instantiation of a
      FUNCTION does not include any source text that is parsed as part
      of a nested FunctionBody.

An ECMAScript Program syntactic unit may be processed using either
unrestricted or strict mode syntax and semantics. When processed using
strict mode the three types of ECMAScript code are referred to as strict
global code, strict eval code, and strict function code. Code is
interpreted as strict mode code in the following situations:

-   Global code is strict global code if it begins with a Directive
      Prologue that contains a Use Strict Directive (see 14.1).

-   Eval code is strict eval code if it begins with a Directive Prologue
      that contains a Use Strict Directive or if the call to eval is a
      direct call (see 15.1.2.1.1) to the eval function that is
      contained in strict mode code.

-   Function code that is part of a FunctionDeclaration,
      FunctionExpression, or accessor PropertyAssignment is strict
      function code if its FunctionDeclaration, FunctionExpression,
      or PropertyAssignment is contained in strict mode code or if the
      function code begins with a Directive Prologue that contains a Use
      Strict Directive.

-   Function code that is supplied as the last argument to the built-in
      Function constructor is strict function code if the last argument
      is a String that when processed as a FunctionBody begins with a
      Directive Prologue that contains a Use Strict Directive.

-   Unless specified otherwise, extended code (10.1.2) is also strict
      mode code.

_Extended code_ is any code contained in an ECMAScript Program
syntactic unit that contains occurrences of lexical or syntactic
productions defined subsequent to the Fifth Edition of the ECMAScript
specification. Code is interpreted as extended code in the following
situations:

-   Global code is extended global code if it is contained in an
      ECMAScript Program syntactic unit that has been designated as an
      extended Program unit in an implementation defined manner or if
      ???.

-   Eval code is extended eval code if the call to eval is a direct call
      (see 15.1.2.1.1) to the eval function that is contained in
      extended mode code or if it begins with ???.

-   Function code that is part of a FunctionDeclaration,
      FunctionExpression, or accessor PropertyAssignment is extended
      function code if its FunctionDeclaration, FunctionExpression,
      or PropertyAssignment is contained in extended mode code or if
      the function code begins with ???.

-   Function code that is supplied as the last argument to the built-in
      Function constructor is strict function code if the last argument
      is a String that when processed as a FunctionBody begins with
      ???.

The term “strict code” is used to designate both actual strict mode code
and extended code while the term “extended code” only designates actual
extended code. The term “base code” is used to designate code that is
not extended code.

A _Lexical Environment_ is a specification type used to define the
association of Identifiers to specific variables and functions based
upon the lexical nesting structure of ECMAScript code. A Lexical
Environment consists of an Environment Record and a possibly null
reference to an outer Lexical Environment. Usually a Lexical
Environment is associated with some specific syntactic structure of
ECMAScript code such as a FunctionDeclaration, a WithStatement, or a
Catch clause of a TryStatement and a new Lexical Environment is
created each time such code is evaluated.

An _Environment Record_ records the identifier bindings that are created
within the scope of its associated Lexical Environment.

The outer environment reference is used to model the logical nesting of
Lexical Environment values. The outer reference of a (inner) Lexical
Environment is a reference to the Lexical Environment that logically
surrounds the inner Lexical Environment. An outer Lexical Environment
may, of course, have its own outer Lexical Environment. A Lexical
Environment may serve as the outer environment for multiple inner
Lexical Environments. For example, if a FunctionDeclaration contains
two nested FunctionDeclarations then the Lexical Environments of each
of the nested functions will have as their outer Lexical Environment the
Lexical Environment of the current execution of the surrounding
function.

Lexical Environments and Environment Record values are purely
specification mechanisms and need not correspond to any specific
artefact of an ECMAScript implementation. It is impossible for an
ECMAScript program to directly access or manipulate such values.

There are two kinds of Environment Record values used in this
specification: _declarative environment records_ and _object environment
records_. Declarative environment records are used to define the effect
of ECMAScript language syntactic elements such as
FunctionDeclarations, VariableDeclarations, and Catch clauses that
directly associate identifier bindings with ECMAScript language values.
Object environment records are used to define the effect of ECMAScript
elements such as Program and WithStatement that associate identifier
bindings with the properties of some object.

For specification purposes Environment Record values can be thought of
as existing in a simple object-oriented hierarchy where Environment
Record is an abstract class with two concrete subclasses, declarative
environment record and object environment record. The abstract class
includes the abstract specification methods defined in Table 18. These
abstract methods have distinct concrete algorithms for each of the
concrete subclasses.

Table 18 — Abstract Methods of Environment Records

  METHOD                     PURPOSE
  ---------------------------- --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  HasBinding(N)                Determine if an environment record has a binding for an identifier. Return TRUE if it does and FALSE if it does not. The String value N is the text of the identifier.
  CreateMutableBinding(N, D)   Create a new mutable binding in an environment record. The String value N is the text of the bound name. If the optional Boolean argument D is TRUE the binding is may be subsequently deleted.
  SetMutableBinding(N,V, S)    Set the value of an already existing mutable binding in an environment record. The String value N is the text of the bound name. V is the value for the binding and may be a value of any ECMAScript language type. S is a Boolean flag. If S is TRUE and the binding cannot be set throw a TYPEERROR exception. S is used to identify strict mode references.
  GetBindingValue(N,S)         Returns the value of an already existing binding from an environment record. The String value N is the text of the bound name. S is used to identify strict mode references. If S is TRUE and the binding does not exist or is uninitialised throw a REFERENCEERROR exception.
  DeleteBinding(N)             Delete a binding from an environment record. The String value N is the text of the bound name If a binding for N exists, remove the binding and return TRUE. If the binding exists but cannot be removed return FALSE. If the binding does not exist return TRUE.
  ImplicitThisValue()          Returns the value to use as the THIS value on calls to function objects that are obtained as binding values from this environment record.

Each declarative environment record is associated with an ECMAScript
program scope containing variable, constant, and/or function
declarations. A declarative environment record binds the set of
identifiers defined by the declarations contained within its scope.

In addition to the mutable bindings supported by all Environment
Records, declarative environment records also provide for immutable
bindings. An immutable binding is one where the association between an
identifier and a value may not be modified once it has been established.
Creation and initialisation of declarative binding are distinct steps so
it is possible for such bindings to exist in either an initialised or
uninitialised state. Declarative environment records support the methods
listed in Table 19 in addition to the Environment Record abstract
specification methods:

Table 19 — Additional Methods of Declarative Environment Records

  METHOD                    PURPOSE
  --------------------------- -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  CreateImmutableBinding(N)   Create a new but uninitialised immutable binding in an environment record. The String value N is the text of the bound name.
  InitializeBinding(N,V)      Set the value of an already existing but uninitialised binding in an environment record. The String value N is the text of the bound name. V is the value for the binding and is a value of any ECMAScript language type.

The behaviour of the concrete specification methods for Declarative
Environment Records is defined by the following algorithms.

The concrete environment record method HasBinding for declarative
environment records simply determines if the argument identifier is one
of the identifiers bound by the record:

The concrete Environment Record method CreateMutableBinding for
declarative environment records creates a new mutable binding for the
name N that is initialised to the value UNDEFINED. A binding must not
already exist in this Environment Record for N. If Boolean argument
D is provided and has the value TRUE the new binding is marked as
being subject to deletion.

The concrete Environment Record method SetMutableBinding for declarative
environment records attempts to change the bound value of the current
binding of the identifier whose name is the value of the argument N to
the value of argument V. A binding for N must already exist. If the
binding is an immutable binding, a TYPEERROR is thrown if S is TRUE.

The concrete Environment Record method GetBindingValue for declarative
environment records simply returns the value of its bound identifier
whose name is the value of the argument N. The binding must already
exist. If S is TRUE and the binding is an uninitialised immutable
binding throw a REFERENCEERROR exception.

The concrete Environment Record method DeleteBinding for declarative
environment records can only delete bindings that have been explicitly
designated as being subject to deletion.

Declarative Environment Records always return UNDEFINED as their
ImplicitThisValue.

The concrete Environment Record method CreateImmutableBinding for
declarative environment records creates a new immutable binding for the
name N that is initialised to the value UNDEFINED. A binding must not
already exist in this environment record for N.

The concrete Environment Record method InitializeBinding for declarative
environment records is used to set the bound value of the current
binding of the identifier whose name is the value of the argument N to
the value of argument V. An uninitialised binding for N must already
exist.

Each object environment record is associated with an object called its
_binding object_. An object environment record binds the set of
identifier names that directly correspond to the property names of its
binding object. Property names that are not an IdentifierName are not
included in the set of bound identifiers. Both own and inherited
properties are included in the set regardless of the setting of their
[[Enumerable]] attribute. Because properties can be dynamically added
and deleted from objects, the set of identifiers bound by an object
environment record may potentially change as a side-effect of any
operation that adds or deletes properties. Any bindings that are created
as a result of such a side-effect are considered to be a mutable binding
even if the Writable attribute of the corresponding property has the
value FALSE. Immutable bindings do not exist for object environment
records.

Object environment records can be configured to provide their binding
object as an implicit this value for use in function calls. This
capability is used to specify the behaviour of With Statement (12.10)
induced bindings. The capability is controlled by a provideThis
Boolean value that is associated with each object environment record. By
default, the value of provideThis is FALSE for any object environment
record.

The behaviour of the concrete specification methods for Object
Environment Records is defined by the following algorithms.

The concrete Environment Record method HasBinding for object environment
records determines if its associated binding object has a property whose
name is the value of the argument N:

The concrete Environment Record method CreateMutableBinding for object
environment records creates in an environment record’s associated
binding object a property whose name is the String value and initialises
it to the value UNDEFINED. A property named N must not already exist
in the binding object. If Boolean argument D is provided and has the
value TRUE the new property’s [[Configurable]] attribute is set to TRUE,
otherwise it is set to FALSE.

The concrete Environment Record method SetMutableBinding for object
environment records attempts to set the value of the environment
record’s associated binding object’s property whose name is the value of
the argument N to the value of argument V. A property named N
should already exist but if it does not or is not currently writable,
error handling is determined by the value of the Boolean argument S.

The concrete Environment Record method GetBindingValue for object
environment records returns the value of its associated binding object’s
property whose name is the String value of the argument identifier N.
The property should already exist but if it does not the result depends
upon the value of the S argument:

The concrete Environment Record method DeleteBinding for object
environment records can only delete bindings that correspond to
properties of the environment object whose [[Configurable]] attribute
have the value TRUE.

Object Environment Records return UNDEFINED as their ImplicitThisValue
unless their provideThis flag is TRUE.

The following abstract operations are used in this specification to
operate upon lexical environments:

The abstract operation GetIdentifierReference is called with a Lexical
Environment lex, a String name, and a Boolean flag strict. The
value of lex may be NULL. When called, the following steps are
performed:

When the abstract operation NewDeclarativeEnvironment is called with
either a Lexical Environment or NULL as argument E the following steps
are performed:

When the abstract operation NewObjectEnvironment is called with an
Object O and a Lexical Environment E (or NULL) as arguments, the
following steps are performed:

The _global environment_ is a unique Lexical Environment which is
created before any ECMAScript code is executed. The global environment’s
Environment Record is an object environment record whose binding object
is the global object (15.1). The global environment’s outer environment
reference is NULL.

As ECMAScript code is executed, additional properties may be added to
the global object and the initial properties may be modified.

When control is transferred to ECMAScript executable code, control is
entering an _execution context_. Active execution contexts logically
form a stack. The top execution context on this logical stack is the
running execution context. A new execution context is created whenever
control is transferred from the executable code associated with the
currently running execution context to executable code that is not
associated with that execution context. The newly created execution
context is pushed onto the stack and becomes the running execution
context.

An execution context contains whatever state is necessary to track the
execution progress of its associated code. In addition, each execution
context has the state components listed in Table 20.

Table 20 —Execution Context State Components

  COMPONENT           PURPOSE
  --------------------- ----------------------------------------------------------------------------------------------------------------------------------------------------------------------
  LexicalEnvironment    Identifies the Lexical Environment used to resolve identifier references made by code within this execution context.
  VariableEnvironment   Identifies the Lexical Environment whose environment record holds bindings created by VariableStatements and FunctionDeclarations within this execution context.
  ThisBinding           The value associated with the THIS keyword within ECMAScript code associated with this execution context.

The LexicalEnvironment and VariableEnvironment components of an
execution context are always Lexical Environments. When an execution
context is created its LexicalEnvironment and VariableEnvironment
components initially have the same value. The value of the
VariableEnvironment component never changes while the value of the
LexicalEnvironment component may change during execution of code within
an execution context.

In most situations only the running execution context (the top of the
execution context stack) is directly manipulated by algorithms within
this specification. Hence when the terms “LexicalEnvironment”,
“VariableEnvironment” and “ThisBinding” are used without qualification
they are in reference to those components of the running execution
context.

An execution context is purely a specification mechanism and need not
correspond to any particular artefact of an ECMAScript implementation.
It is impossible for an ECMAScript program to access an execution
context.

Identifier resolution is the process of determining the binding of an
IdentifierName using the LexicalEnvironment of the running execution
context. During execution of ECMAScript code, Identifier Resolution is
performed using the following algorithm:

The result of evaluating an identifier is always a value of type
Reference with its referenced name component equal to the Identifier
String.

Evaluation of global code or code using the eval function (15.1.2.1)
establishes and enters a new execution context. Every invocation of an
ECMAScript code function (13.2.1) also establishes and enters a new
execution context, even if a function is calling itself recursively.
Every return exits an execution context. A thrown exception may also
exit one or more execution contexts.

When control enters an execution context, the execution context’s
ThisBinding is set, its VariableEnvironment and initial
LexicalEnvironment are defined, and declaration binding instantiation
(10.5) is performed. The exact manner in which these actions occur
depend on the type of code being entered.

The following steps are performed when control enters the execution
context for global code:

The following steps are performed to initialise a global execution
context for ECMAScript code C:

The following steps are performed when control enters the execution
context for eval code:

NOTE The eval code cannot instantiate variable or function bindings in
the variable environment of the calling context that invoked the eval if
either the code of the calling context or the eval code is strict code.
Instead such bindings are instantiated in a new VariableEnvironment that
is only accessible to the eval code.

The following steps are performed when control enters the execution
context for function code contained in function object F, a caller
provided argumentsList, and a caller provided thisArg:

NOTE When an execution context is established for evaluating
non-function code that is base code declarations are instantiated in the
current VariableEnvironment. Each top-level level variable, constant, or
function declarated in the code is instantiated.

Top-level Declaration Instantiation for base code is performed as
follows:

NOTE When an execution context is established for evaluating function
code a new Declarative Environment Record is created and bindings for
each formal parameter, and each function level variable, constant, or
function declarated in the function are instantiated in the environment
record. Formal parameters and functions are initialized as part of this
process. All other bindings are initialized during execution of the
function code.

Function Declaration Instantiation is performed as follows using
arguments func, argumentsList, and env. func is the function
object that for which the execution context is being established. env
is the declarative environment record in which bindings are to be
created.

1.  Let code be the value of the [[Code]] internal property of func.

2.  Let strict be be the value of the [[Strict]] internal property of
    func.

3.  Let formals be the value of the [[FormalParameterList]] internal
    property of func.

4.  Let parameterNames be the BoundNames of FormalParameterList.

5.  For each String argName in parameterNames, in list order do

    a.  Let alreadyDeclared be the result of calling env’s
        HasBinding concrete method passing argName as the argument.

    b.  NOTE Duplicate parameter names can only occur in non-strict
        code.

    c.  If alreadyDeclared is FALSE, then

        i.  Call env’s CreateMutableBinding concrete method passing
            argName as the argument.

    d.  If strict is FALSE, then

        i.  Call env’s InitializeBinding concrete method passing
            argName, and UNDEFINED as the arguments.

6.  Let declarations be the LexicalDeclarations of code.

7.  If strict is TRUE, then

    a.  Let ao be the result of CreateStrictArgumentsObject. with
        argument argumentsList.

    b.  Perform Binding Initialization for formals with ao and env
        as arguments.

8.  Else,

    a.  Let names be BoundNames of formals.

    b.  NOTE Because F is a none strict function it is not extended
        code. Hence formals does not contain the names of any
        destructuring BindingProperties, rest parameters, or
        parameters with default value initialisers.

    c.  Let ao be the result of performing the abstract operation
        CreateMappedArgumentsObject with arguments names, env, and
        argumentsList.

    d.  Perform Binding Initialization for formals with ao and
        UNDEFINED as arguments.

9.  NOTE Binding initialization for formals is perform prior to to
    instantiating any non-parameter declarations in order to ensure that
    any such local declarations are not visible to any parameter
    initialization code that may be evaluated.

10. For each element d in declarations do

    a.  For each element dn of the BoundNames of d do

        i.  Let alreadyDeclared be the result of calling env’s
            HasBinding concrete method passing dn as the argument.

        ii. If alreadyDeclared is FALSE, then

            1.  If d is a ConstDeclaration, then

                a.  Call env’s CreateImmutableBinding concrete method
                    passing dn as the argument.

            2.  Else,

                a.  Call env’s CreateMutableBinding concrete method
                    passing dn and FALSE as the arguments.

11. Let argumentsAlreadyDeclared be the result of calling env’s
    HasBinding concrete method passing "ARGUMENTS" as the argument.

12. NOTE If argumentsAlreadyDeclared is TRUE then the value of ao is
    not directly observable to ECMAScript code and need not actually
    exist. In that case, its use in the above steps is strictly as a
    device for specifying formal parameter initialization semantics.

13. 14. If argumentsAlreadyDeclared is FALSE, then

    a.  If strict is TRUE, then

        i.  Call env’s CreateImmutableBinding concrete method passing
            the String "ARGUMENTS" as the argument.

    b.  Else,

        i.  Call env’s CreateMutableBinding concrete method passing
            the String "ARGUMENTS" as the argument.

    c.  Call env’s InitializeBinding concrete method passing
        "ARGUMENTS" and ao as arguments.

15. Let varNames be the VarDeclaredNames of code.

16. For each String varName in varNames, in list order do

    a.  Let alreadyDeclared be the result of calling env’s
        HasBinding concrete method passing varName as the argument.

    b.  NOTE A VarDeclaredNames is only instantiated and initialied here
        if it is not also the name of a formal parameter or a
        FunctionDeclarations. Such duplicate declarations may only
        occur in non-extended code.

    c.  If alreadyDeclared is FALSE, then

        i.  Call env’s CreateMutableBinding concrete method passing
            varName as the argument.

        ii. Call env’s InitializeBinding concrete method passing fn,
            and UNDEFINED as the arguments.

17. Let initializedFunctions be an emptyList.

18. For each FunctionDeclaration f in declarations, in reverse
    list order do

    a.  NOTE If there are multiple FunctionDeclarations for the same
        name, the last declaration is used. Multiple
        FunctionDeclarations for the same name is only valid in
        non-extended code.

    b.  Let fn be the sole element of the BoundNames of f.

    c.  If fn is not an element of initializedFunctions, then

        i.  Append fn to initializedFunctions.

        ii. Let fo be the result of instantiating _FunctionDeclaration
            f_ as described in Clause 13.

        iii. Call env’s InitializeBinding concrete method passing
            fn, and fo as the arguments.

19. Return.

NOTE When a Block or CaseBlock production contained in extended code
is evaluated a new Declarative Environment Record is created and
bindings for each block scoped variable, constant, or function
declarated in the block are instantiated in the environment record.

Block Declaration Instantiation is performed as follows using arguments
code and env. code is the grammar production corresponding to the
body of the block. env is the declarative environment record in which
bindings are to be.

1.  2.  Let declarations be the LexicalDeclarations of code.

3.  For each element d in declarations do

    a.  For each element dn of the BoundNames of d do

        i.  If d is a ConstDeclaration, then

            1.  Call env’s CreateImmutableBinding concrete method
                passing dn as the argument.

        ii. Else,

            1.  Call env’s CreateMutableBinding concrete method
                passing dn and FALSE as the arguments.

4.  For each FunctionDeclaration f in declarations, in list order
    do

    a.  Let fn be the sole element of the BoundNames of f.

    b.  Let fo be the result of instantiating _FunctionDeclaration f_
        as described in Clause 13.

    c.  d.  Call env’s InitializeBinding concrete method passing fn,
        and fo as the arguments.

5.  a.  i.  1.  

        ii. 1.  

When control enters an execution context for function code, an arguments
object is created unless (as specified in 10.5) the identifier ARGUMENTS
occurs as an Identifier in the function’s FormalParameterList or
occurs as the BindingIdentifier of a Declaration contained in the
function code.

The abstract operation CreateStrictArgumentsObject called with
argument list args performs the following steps:

1.  Let len be the number of elements in args.

2.  Let obj be the result of the abstraction operation
    InstantiateArgumentsObject with argument len.

3.  Let indx = len - 1.

4.  Repeat while indx >= 0,

    a.  Let val be the element of args at 0-origined list position
          indx.

    b.  Call the [[DefineOwnProperty]] internal method on obj passing
          ToString(indx), the property descriptor {[[Value]]: val,
          [[Writable]]: TRUE, [[Enumerable]]: TRUE, [[Configurable]]:
          TRUE}, and FALSE as arguments.

    c.  Let indx = indx - 1

5.  Let thrower be the [[ThrowTypeError]] function Object (13.2.3).

6.  Call the [[DefineOwnProperty]] internal method of obj with
    arguments "CALLER", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
    thrower, [[Enumerable]]: FALSE, [[Configurable]]: FALSE}, and
    FALSE.

7.  Call the [[DefineOwnProperty]] internal method of obj with
    arguments "CALLEE", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
    thrower, [[Enumerable]]: FALSE, [[Configurable]]: FALSE}, and
    FALSE.

8.  Return obj

The abstract operation CreateMappedArgumentsObject called with List
names, environment record env, and argument list args performs the
following steps:

1.  Let len be the number of elements in args.

2.  Let obj be the result of the abstraction operation
    InstantiateArgumentsObject with argument len.

3.  Let map be the result of creating a new ECMAScript object.

4.  Set all the internal methods of map as specified in 8.12.

5.  Let mappedNames be an empty List.

6.  Let indx = len - 1.

7.  Repeat while indx >= 0,

    a.  Let val be the element of args at 0-origined list position
        indx.

    b.  Call the [[DefineOwnProperty]] internal method on obj passing
        ToString(indx), the property descriptor {[[Value]]: val,
        [[Writable]]: TRUE, [[Enumerable]]: TRUE, [[Configurable]]:
        TRUE}, and FALSE as arguments.

    c.  If indx is less than the number of elements in names, then

        i.  Let name be the element of names at 0-origined list
            position indx.

        ii. If name is not an element of mappedNames, then

            1.  Add name as an element of the list mappedNames.

            2.  Let g be the result of calling the MakeArgGetter
                abstract operation with arguments name and env.

            3.  Let p be the result of calling the MakeArgSetter
                abstract operation with arguments name and env.

            4.  Call the [[DefineOwnProperty]] internal method of map
                passing ToString(indx), the Property Descriptor
                {[[Set]]: p, [[Get]]: g, [[Configurable]]: TRUE},
                and FALSE as arguments.

    d.  Let indx = indx - 1

8.  If mappedNames is not empty, then

    a.  Set the [[ParameterMap]] internal property of obj to map.

    b.  Set the [[Get]], [[GetOwnProperty]], [[DefineOwnProperty]], and
        [[Delete]] internal methods of obj to the definitions provided
        below.

9.  Call the [[DefineOwnProperty]] internal method on obj passing
    "CALLEE", the property descriptor {[[Value]]: func, [[Writable]]:
    TRUE, [[Enumerable]]: FALSE, [[Configurable]]: TRUE}, and FALSE as
    arguments.

10. Return obj

The abstract operation InstantiateArgumentsObject called with an
argument len performs the following steps:

The abstract operation MakeArgGetter called with String name and
environment record env creates a function object that when executed
returns the value bound for name in env. It performs the following
steps:

The abstract operation MakeArgSetter called with String name and
environment record env creates a function object that when executed
sets the value bound for name in env. It performs the following
steps:

The [[Get]] internal method of an arguments object for a non-strict mode
function with formal parameters when called with a property name P
performs the following steps:

The [[GetOwnProperty]] internal method of an arguments object for a
non-strict mode function with formal parameters when called with a
property name P performs the following steps:

The [[DefineOwnProperty]] internal method of an arguments object for a
non-strict mode function with formal parameters when called with a
property name P, Property Descriptor Desc, and Boolean flag Throw
performs the following steps:

The [[Delete]] internal method of an arguments object for a non-strict
mode function with formal parameters when called with a property name
P and Boolean flag Throw performs the following steps:

NOTE 1 For non-strict mode functions the array index (defined in 15.4)
named data properties of an arguments object whose numeric name values
are less than the number of formal parameters of the corresponding
function object initially share their values with the corresponding
argument bindings in the function’s execution context. This means that
changing the property changes the corresponding value of the argument
binding and vice-versa. This correspondence is broken if such a property
is deleted and then redefined or if the property is changed into an
accessor property. For strict mode functions, the values of the
arguments object’s properties are simply a copy of the arguments passed
to the function and there is no dynamic linkage between the property
values and the formal parameter values.

NOTE 2 The ParameterMap object and its property values are used as a
device for specifying the arguments object correspondence to argument
bindings. The ParameterMap object and the objects that are the values of
its properties are not directly accessible from ECMAScript code. An
ECMAScript implementation does not need to actually create or use such
objects to implement the specified semantics.

NOTE 3 Arguments objects for strict mode functions define
non-configurable accessor properties named "CALLER" and "CALLEE" which
throw a TYPEERROR exception on access. The "CALLEE" property has a more
specific meaning for non-strict mode functions and a "CALLER" property
has historically been provided as an implementation-defined extension by
some ECMAScript implementations. The strict mode definition of these
properties exists to ensure that neither of them is defined in any other
manner by conforming ECMAScript implementations.

Syntax

PrimaryExpression :

THIS
Identifier
Literal
SealedArrayLiteral
SealedObjectLiteral
FunctionExpression
( Expression )

RUNTIME SEMANTICS: EVALUATION

PrimaryExpression : THIS

1.  Return the value of the ThisBinding of the current execution
    context.

An Identifier is evaluated by performing Identifier Resolution as
specified in 10.3.1 using the IdentifierName corresponding to
Identifier. The result of evaluating an Identifier is always a value
of type Reference.

A Literal is evaluated as described in 7.8.

NOTE An array initialiser is an expression describing the initialisation
of an Array object, written in a form of a literal. It is a list of zero
or more expressions, each of which represents an array element, enclosed
in square brackets. The elements need not be literals; they are
evaluated each time the array initialiser is evaluated.

Array elements may be elided at the beginning, middle or end of the
element list. Whenever a comma in the element list is not preceded by an
AssignmentExpression (i.e., a comma at the beginning or after another
comma), the missing array element contributes to the length of the Array
and increases the index of subsequent elements. Elided array elements
are not defined. If an element is elided at the end of an array, that
element does not contribute to the length of the Array.

Syntax

SealedArrayLiteral :

ArrayLiteral
# ArrayLiteral

ArrayLiteral :

[ Elision~opt~ ]
[ ElementList ]
[ ElementList , Elision~opt~ ]

ElementList :

Elision~opt~ AssignmentExpression
Elision~opt~ … AssignmentExpression
ElementList , Elision~opt~ AssignmentExpression
ElementList , Elision~opt~ SpreadElement

Elision :

,
Elision ,

SpreadElement :

… AssignmentExpression

STATIC SEMANTICS: EARLY ERRORS

SpreadElement : _… AssignmentExpression_

-   It is a Syntax Error if the source code parsed with this production
    is not extended code.

-   

STATIC SEMANTICS: ELISION WIDTH

Elision : [empty]

1.  Return the numeric value 0.

Elision : ,

1.  Return the numeric value 1.

Elision : Elision ,

1.  Let preceding be the Elision Width of Elision.

2.  Return preceding+1.

RUNTIME SEMANTICS: ARRAY ACCUMULATION

  With parameters array and nextIndex.

ElementList : Elision~opt~ AssignmentExpression

1.  Let padding be the Elision Width of Elision~opt~.

2.  Let initResult be the result of evaluating AssignmentExpression.

3.  Let initValue be GetValue(initResult).

4.  Call the [[DefineOwnProperty]] internal method of array with
    arguments ToString(ToUint32(nextIndex+padding)), the Property
    Descriptor { [[Value]]: initValue, [[Writable]]: TRUE,
    [[Enumerable]]: TRUE, [[Configurable]]: TRUE}, and FALSE.

5.  Return nextIndex+padding+1.

ElementList : Elision~opt~ SpreadElement

1.  Let padding be the Elision Width of Elision~opt~.

2.  Return the result of performing Array Accumulation for
    SpreadElement with arguments array and nextIndex_+_padding.

ElementList : ElementList , Elision~opt~ AssignmentExpression

1.  Let postIndex be the result of performing Array Accumulation for
    ElementList with arguments array and nextIndex.

2.  Let padding be the Elision Width of Elision~opt~.

3.  Let initResult be the result of evaluating AssignmentExpression.

4.  Let initValue be GetValue(initResult).

5.  Call the [[DefineOwnProperty]] internal method of array with
    arguments ToString(ToUint32((postIndex_+_padding)) and the
    Property Descriptor { [[Value]]: initValue, [[Writable]]: TRUE,
    [[Enumerable]]: TRUE, [[Configurable]]: TRUE}, and FALSE.

6.  Return postIndex_+_padding+1.

ElementList : ElementList , Elision~opt~ SpreadElement

1.  Let postIndex be the result of performing Array Accumulation for
    ElementList with arguments array and nextIndex.

2.  Let pad be the result of evaluating Elision~opt~; if not
    present, use the numeric value zero.

3.  Return the result of performing Array Accumulation for
    SpreadElement with arguments array and postIndex_+_padding.

SpreadElement : … AssignmentExpression

1.  Let spreadRef be the result of evaluating AssignmentExpression.

2.  Let spreadValue be GetValue(spreadRef).

3.  Let spreadObj be ToObject(spreadValue).

4.  Let lenVal be the result of calling the [[Get]] internal method of
    spreadObj with argument “LENGTH”.

5.  Let spreadLen be ToUint32(lenVal).

6.  Let n=0;

7.  Repeat, while n < spreadLen

    a.  Let exists be the result of calling the [[HasProperty]]
          internal method of spreadObj with ToString(n).

    b.  If exists is TRUE then,

        i.  Let v be the result of calling the [[Get]] internal method
              of spreadObj passing ToString(n) as the argument.

        ii. Call the [[DefineOwnProperty]] internal method of array
              with arguments ToString(ToUint32(nextIndex)), Property
              Descriptor {[[Value]]: v, [[Writable]]: TRUE,
              [[Enumerable]]: TRUE, [[Configurable]]: TRUE}, and FALSE.

    c.  Let n = n+1.

    d.  Let nextIndex = nextIndex +1.

8.  Return nextIndex.

NOTE [[DefineOwnProperty]] is used to ensure that own properties are
defined for the array even if the standard built-in Array prototype
object has been modified in a manner that would preclude the creation of
new own properties using [[Put]].

RUNTIME SEMANTICS: EVALUATION

ArrayLiteral : [ Elision~opt~ ]

1.  Let array be the result of creating a new object as if by the
    expression NEW ARRAY() where ARRAY is the standard built-in
    constructor with that name.

2.  Let pad be the Elision Width of Elision~opt~.

3.  Call the [[Put]] internal method of array with arguments "LENGTH",
    pad, and FALSE.

4.  Return array.

ArrayLiteral : [ ElementList ]

1.  Let array be the result of creating a new object as if by the
    expression NEW ARRAY() where ARRAY is the standard built-in
    constructor with that name.

2.  Let len be result of performing Array Accumulation for
    ElementList with arguments array and 0.

3.  Call the [[Put]] internal method of array with arguments "LENGTH",
    len, and FALSE.

4.  Return array.

ArrayLiteral : [ ElementList , Elision~opt~ ]

1.  Let array be the result of creating a new object as if by the
    expression NEW ARRAY() where ARRAY is the standard built-in
    constructor with that name.

2.  3.  Let len be result of performing Array Accumulation for
    ElementList with arguments array and 0.

4.  Let pad be the Elision Width of Elision~opt~.

5.  6.  Call the [[Put]] internal method of array with arguments
    "LENGTH", ToUint32(pad_+_len), and FALSE.

7.  Return array.

1.  2.  3.  4.  5.  6.  

1.  2.  3.  4.  5.  6.  7.  a.  b.  i.  ii. 

    c.  d.  

8.  

1.  2.  3.  4.  5.  6.  7.  

-   

1.  2.  3.  4.  5.  6.  7.  8.  9.  10. a.  b.  i.  ii. 

    c.  d.  

11. 

1.  

1.  2.  

NOTE An object initialiser is an expression describing the
initialisation of an Object, written in a form resembling a literal. It
is a list of zero or more pairs of property names and associated values,
enclosed in curly braces. The values need not be literals; they are
evaluated each time the object initialiser is evaluated.

Syntax

SealedObjectLiteral :

ObjectLiteral
# ObjectLiteral

ObjectLiteral :

{ }
{ PropertyNameAndValueList }
{ PropertyNameAndValueList , }

PropertyNameAndValueList :

PropertyAssignment
PropertyNameAndValueList , PropertyAssignment

PropertyAssignment :

IdentifierName
PropertyName : AssignmentExpression
PropertyName ( FormalParameterList ) { FunctionBody }
GET PropertyName ( ) { FunctionBody }
SET PropertyName ( PropertySetParameterList ) { FunctionBody }

PropertyName :

IdentifierName
StringLiteral
NumericLiteral

PropertySetParameterList :

BindingIdentifier
BindingPattern

EARLY ERRORS

PropertyNameAndValueList : PropertyNameAndValueList ,
PropertyAssignment

-   It is a Syntax Error if this production is contained in strict code,
    PropertyAssignment is the production PropertyAssignment :
    PropertyName : AssignmentExpression, and
    PropertyDefinitionList(PropName of PropertyAssignment) of
    PropertyNameAndValueList is not the empty List.

-   It is a Syntax Error if PropertyAssignment is the production
     PropertyAssignment : GET PropertyName ( ) { FunctionBody }
    and PropertyDefinitionList (PropName of PropertyAssignment) of
    PropertyNameAndValueList includes a production of the form
    PropertyAssignment : PropertyName : AssignmentExpression.

-   It is a Syntax Error if PropertyAssignment is the production
     PropertyAssignment : SET PropertyName (
    PropertySetParameterList ) { FunctionBody }
    and PropertyDefinitionList (PropName of PropertyAssignment) of
    PropertyNameAndValueList includes a production of the form
    PropertyAssignment : PropertyName : AssignmentExpression.

-   It is a Syntax Error if PropertyAssignment is the production
     PropertyAssignment : GET PropertyName ( ) { FunctionBody }
    and PropertyDefinitionList (PropName of PropertyAssignment) of
    PropertyNameAndValueList includes a production of the form
    PropertyAssignment : GET PropertyName ( ) { FunctionBody }.

-   It is a Syntax Error if PropertyAssignment is the production
     PropertyAssignment : SET PropertyName (
    PropertySetParameterList ) { FunctionBody }
    and PropertyDefinitionList (PropName of PropertyAssignment) of
    PropertyNameAndValueList includes a production of the form
     PropertyAssignment : SET PropertyName (
    PropertySetParameterList ) { FunctionBody }.

PropertyAssignment : PropertyName ( FormalParameterList ) {
FunctionBody }

-   It is a Syntax Error if the source code parsed with this production
    is not extended code.

-   It is a Syntax Error if the PropName of PropertyName also occurs
    in the VarDeclaredNames of FunctionBody.

-   It is a Syntax Error if the PropName of PropertyName also occurs
    in the LexicallyDeclaredNames of FunctionBody.

-   It is a Syntax Error if any element of the LexicallyDeclaredNames of
    FormalParameterList also occurs in the VarDeclaredNames of
    FunctionBody.

-   It is a Syntax Error if any element of the BoundNames of
    FormalParameterList also occurs in the LexicallyDeclaredNames of
    FunctionBody.

PropertyAssignment : GET PropertyName () { FunctionBody }

-   It is a Syntax Error if the source code matching this production is
    extended code and the PropName of PropertyName also occurs in the
    VarDeclaredNames of FunctionBody.

-   It is a Syntax Error if the source code matching this production is
    extended code and the PropName of PropertyName also occurs in the
    LexicallyDeclaredNames of FunctionBody.

PropertyAssignment : SET PropertyName ( PropertySetParameterList )
{ FunctionBody }

-   It is a Syntax Error if the source code matching this production is
    extended code and the PropName of PropertyName also occurs in the
    VarDeclaredNames of FunctionBody.

-   It is a Syntax Error if the source code matching this production is
    extended code and the PropName of PropertyName also occurs in the
    LexicallyDeclaredNames of FunctionBody.

-   It is a Syntax Error if the source code matching this production is
    extended code and any element of the LexicallyDeclaredNames of
    PropertySetParameterList also occurs in the VarDeclaredNames of
    FunctionBody.

-   It is a Syntax Error if the source code matching this production is
    extended code and any element of the BoundNames of
    PropertySetParameterList also occurs in the LexicallyDeclaredNames
    of FunctionBody.

PropertySetParameterList : BindingPattern

-   It is a Syntax Error if the source code parsed with this production
    is not extended code.

-   It is a Syntax Error if BoundNames of BindingPattern contains any
    duplicate elements.

STATIC SEMANTICS: BOUNDNAMES

PropertySetParameterList : _BindingIdentifier _

1.  Return BoundNames of BindingIdentifier.

PropertySetParameterList: _BindingPattern _

1.  Return BoundNames of BindingPattern.

STATIC SEMANTICS: EXPECTEDARGUMENTCOUNT

PropertySetParameterList : _BindingIdentifier _

1.  Return 1.

PropertySetParameterList : _BindingPattern _

1.  Return 1.

STATIC SEMANTICS: HASINITIALISER

PropertySetParameterList : _BindingIdentifier _

1.  Return FALSE.

PropertySetParameterList : _BindingPattern _

1.  Return FALSE.

STATIC SEMANTICS: PROPERTYDEFINITIONLIST(NAME)

PropertyAssignment : PropertyName : AssignmentExpression

1.  If PropName of PropertyName is not name return the empty List.

2.  Return a List containing PropertyAssignment.

PropertyNameAndValueList : PropertyNameAndValueList ,
PropertyAssignment

1.  Let previous be PropertyDefinitionList(name) of
    PropertyNameAndValueList.

2.  If PropName of PropertyAssignment is name then,

    a.  Append PropertyAssignment to the end of previous.

3.  Return previous.

STATIC SEMANTICS: PROPNAME

PropertyAssignment : IdentifierName

1.  Return String Value of IdentifierName.

PropertyAssignment : PropertyName : AssignmentExpression

1.  Return PropName of PropertyName.

PropertyAssignment : PropertyName ( FormalParameterList ) {
FunctionBody }

1.  Return PropName of PropertyName.

PropertyAssignment : GET PropertyName ( ) { FunctionBody }

1.  Return PropName of PropertyName.

PropertyAssignment : SET PropertyName ( PropertySetParameterList )
{ FunctionBody }

1.  Return PropName of PropertyName.

PropertyName : IdentifierName

1.  Return PropName of IdentifierName.

PropertyName : StringLiteral

1.  Return the SV of the StringLiteral.

PropertyName : NumericLiteral

1.  Let nbr be the result of forming the value of the
    NumericLiteral.

2.  Return ToString(nbr).

RUNTIME SEMANTICS: EVALUATION

ObjectLiteral : { }

1.  Return a new object created as if by the expression NEW OBJECT()
    where OBJECT is the standard built-in constructor with that name.

ObjectLiteral :

  { PropertyNameAndValueList }_
  _{ PropertyNameAndValueList , }

1.  Let obj be the result of creating a new object as if by the
    expression NEW OBJECT() where OBJECT is the standard built-in
    constructor with that name.

2.  Perform Property Definition Dvaluation of PropertyNameAndValueList
    with argument obj.

3.  Return obj.

RUNTIME SEMANTICS: PROPERTY DEFINITION EVALUATION

  With parameter object.

PropertyNameAndValueList : PropertyAssignment

1.  2.  3.  4.  Perform Property Definition Dvaluation of
    PropertyAssignment with argument object.

PropertyNameAndValueList : PropertyNameAndValueList ,
PropertyAssignment

PropertyAssignment : IdentifierName

1.  Let propName be PropName(IdentifierName).

2.  Let exprValue be the result of performing Identifier Resolution as
    specified in 10.3.1 using IdentifierName.

3.  Let propValue be GetValue(exprValue).

4.  Let desc be the Property Descriptor{[[Value]]: propValue,
    [[Writable]]: TRUE, [[Enumerable]]: TRUE, [[Configurable]]: TRUE}

5.  Call the [[DefineOwnProperty]] internal method of object with
    arguments propName, desc, and FALSE.

6.  

PropertyAssignment : PropertyName : AssignmentExpression

1.  Let propName be PropName(PropertyName).

2.  Let exprValue be the result of evaluating AssignmentExpression.

3.  Let propValue be GetValue(exprValue).

4.  Let desc be the Property Descriptor{[[Value]]: propValue,
    [[Writable]]: TRUE, [[Enumerable]]: TRUE, [[Configurable]]: TRUE}

5.  Call the [[DefineOwnProperty]] internal method of object with
    arguments propName, desc, and FALSE.

PropertyAssignment : PropertyName ( FormalParameterList ) {
FunctionBody }

1.  Let propName be PropName of PropertyName.

2.  Let closure be the result of creating a new Function object as
    specified in 13.2 using a FormalParameterList : [empty] production
    as the parameter list and body specified by FunctionBody. Pass in
    the LexicalEnvironment of the running execution context as the
    Scope. Pass in TRUE as the Strict flag. Pass object as the
    optional homeObject argument and propName as the optional
    methodName argument.

3.  Let desc be the Property Descriptor{[[Get]]: closure,
    [[Enumerable]]: TRUE, [[Configurable]]: TRUE}

4.  Call the [[DefineOwnProperty]] internal method of object with
    arguments propName, desc, and FALSE.

PropertyAssignment : GET PropertyName ( ) { FunctionBody }

1.  Let propName be PropName(PropertyName).

2.  Let closure be the result of creating a new Function object as
    specified in 13.2 using a FormalParameterList : [empty] production
    as the formal parameter list and body specified by FunctionBody.
    Pass in the LexicalEnvironment of the running execution context as
    the Scope. Pass in TRUE as the Strict flag if the
    PropertyAssignment is contained in strict code or if its
    FunctionBody is strict code. Pass object as the optional
    homeObject argument and propName as the optional methodName
    argument.

3.  Let desc be the Property Descriptor{[[Get]]: closure,
    [[Enumerable]]: TRUE, [[Configurable]]: TRUE}

4.  Call the [[DefineOwnProperty]] internal method of object with
    arguments propName, desc, and FALSE.

PropertyAssignment : SET PropertyName ( PropertySetParameterList )
{ FunctionBody }

1.  Let propName be PropName(PropertyName).

2.  Let closure be the result of creating a new Function object as
    specified in 13.2 with parameters specified by
    PropertySetParameterList and body specified by FunctionBody.
    Pass in the LexicalEnvironment of the running execution context as
    the Scope. Pass in TRUE as the Strict flag if the
    PropertyAssignment is contained in strict code or if its
    FunctionBody is strict code. Pass object as the optional
    homeObject argument and propName as the optional methodName
    argument.

3.  Let desc be the Property Descriptor{[[Set]]: closure,
    [[Enumerable]]: TRUE, [[Configurable]]: TRUE}

4.  Call the [[DefineOwnProperty]] internal method of object with
    arguments propName, desc, and FALSE.

5.  

RUNTIME SEMANTICS: EVALUATION

PrimaryExpression : FunctionExpression

1.  Return the result of evaluating FunctionExpression.

1.  

1.  

1.  2.  

RUNTIME SEMANTICS: EVALUATION

PrimaryExpression : ( Expression )

1.  Return the result of evaluating Expression. This may be of type
    Reference.

NOTE This algorithm does not apply GetValue to the result of evaluating
Expression. The principal motivation for this is so that operators such
as DELETE and TYPEOF may be applied to parenthesised expressions.

Syntax

MemberExpression :

PrimaryExpression
MemberExpression [ Expression ]
MemberExpression . IdentifierName
MemberExpression <| TriangleLiteral
SUPER [ Expression ]
SUPER . IdentifierName
NEW MemberExpression Arguments

NewExpression :

MemberExpression
NEW NewExpression

CallExpression :

MemberExpression Arguments
SUPER Arguments
CallExpression Arguments
CallExpression [ Expression ]
CallExpression . IdentifierName
CallExpression <| TriangleLiteral

Arguments :

( )
( ArgumentList )

ArgumentList :

AssignmentExpression
... AssignmentExpression
ArgumentList , AssignmentExpression
ArgumentList , ... AssignmentExpression

TriangleLiteral :

SealedArrayLiteral
SealedObjectLiteral
FunctionExpression
ValueLiteral

LeftHandSideExpression :

NewExpression
CallExpression

Properties are accessed by name, using either the dot notation:

MemberExpression . IdentifierName
CallExpression . IdentifierName

or the bracket notation:

MemberExpression [ Expression ]
CallExpression [ Expression ]

The dot notation is explained by the following syntactic conversion:

MemberExpression . IdentifierName

is identical in its behaviour to

MemberExpression [ <identifier-name-string> ]

and similarly

CallExpression . IdentifierName

is identical in its behaviour to

CallExpression [ <identifier-name-string> ]

where <identifier-name-string> is a string literal containing the same
sequence of characters after processing of Unicode escape sequences as
the IdentifierName.

RUNTIME SEMANTICS: EVALUATION

MemberExpression : MemberExpression [ Expression ]

CallExpression : CallExpression [ Expression ]

Is evaluated in exactly the same manner as MemberExpression :
MemberExpression [ Expression ] except that the contained
CallExpression is evaluated in step 1.

RUNTIME SEMANTICS: EVALUATION

NEW NewExpression

1.  Let ref be the result of evaluating NewExpression.

2.  Let constructor be GetValue(ref).

3.  If Type(constructor) is not Object, throw a TYPEERROR exception.

4.  If constructor does not implement the [[Construct]] internal
    method, throw a TYPEERROR exception.

5.  Return the result of calling the [[Construct]] internal method on
    constructor, providing no arguments (that is, an empty list of
    arguments).

MemberExpression : NEW MemberExpression Arguments

1.  Let ref be the result of evaluating MemberExpression.

2.  Let constructor be GetValue(ref).

3.  Let argList be the result of evaluating Arguments, producing an
    internal list of argument values (11.2.4).

4.  If Type(constructor) is not Object, throw a TYPEERROR exception.

5.  If constructor does not implement the [[Construct]] internal
    method, throw a TYPEERROR exception.

6.  Return the result of calling the [[Construct]] internal method on
    constructor, providing the list argList as the argument values.

RUNTIME SEMANTICS: EVALUATION

CallExpression : MemberExpression Arguments

1.  Let ref be the result of evaluating MemberExpression.

2.  Let func be GetValue(ref).

3.  Let argList be the result of evaluating Arguments, producing an
    internal list of argument values (see 11.2.4).

4.  If Type(func) is not Object, throw a TYPEERROR exception.

5.  If IsCallable(func) is FALSE, throw a TYPEERROR exception.

6.  If Type(ref) is Reference, then

    a.  If IsPropertyReference(ref) is TRUE, then

        i.  Let thisValue be GetBase(ref).

    b.  Else, the base of ref is an Environment Record

        i.  Let thisValue be the result of calling the
            ImplicitThisValue concrete method of GetBase(ref).

7.  Else, Type(ref) is not Reference.

    a.  Let thisValue be UNDEFINED.

8.  Return the result of calling the [[Call]] internal method on func,
    providing thisValue as the THIS value and providing the list
    argList as the argument values.

CallExpression : CallExpression Arguments

This is evaluated in exactly the same manner as CallExpression :
MemberExpression Arguments except that the contained
CallExpression is evaluated in step 1.

NOTE The returned result will never be of type Reference if func is a
native ECMAScript object. Whether calling a host object can return a
value of type Reference is implementation-dependent. If a value of type
Reference is returned, it must be a non-strict Property Reference.

Static SEMANTICS

STATIC SEMANTICS: EARLY ERRORS

MemberExpression :

SUPER [ Expression ]
SUPER . IdentifierName

-   It is a Syntax Error if the source code parsed with this production
    is global code code that is not eval code.

-   It is a SyntaxError if the source code parsed with this production
    is eval code that is also global code and the source code is not
    being processed by a direct call to eval that is contained in
    function code.

-   It is a Syntax Error if the source code parsed with this production
    is not extended code.

CallExpression : SUPER Arguments

-   It is a Syntax Error if the source code parsed with this production
    is global code code that is not eval code.

-   It is a SyntaxError if the source code parsed with this production
    is eval code that is also global code and the source code is not
    being processed by a direct call to eval that is contained in
    function code.

-   It is a Syntax Error if the source code parsed with this production
    is not extended code.

RUNTIME SEMANTICS: EVALUATION

MemberExpression : SUPER [ Expression ]

1.  Let baseReference be the result of evaluating MemberExpression.

2.  Let baseValue be GetValue(baseReference).

3.  Let propertyNameReference be the result of evaluating
    Expression.

4.  Let propertyNameValue be GetValue(propertyNameReference).

5.  Call CheckObjectCoercible(baseValue).

6.  Let propertyNameString be ToString(propertyNameValue).

7.  If the code matched by the syntactic production that is being
    evaluated is strict mode code, let strict be TRUE, else let
    strict be FALSE.

8.  Return a value of type Reference whose base value is baseValue and
    whose referenced name is propertyNameString, and whose strict mode
    flag is strict.

The evaluation of an argument list produces a List of values (see 8.8).

STATIC SEMANTICS: EARLY ERRORS

1.  

1.  

1.  2.  3.  

ArgumentList : _… AssignmentExpression_

-   It is a Syntax Error if the source code parsed with this production
    is not extended code.

ArgumentList : ArgumentList , _… _AssignmentExpression

-   It is a Syntax Error if the source code parsed with this production
    is not extended code.

RUNTIME SEMANTICS: EVALUATION

Arguments : ( )

1.  Return an empty List.

Arguments : ( ArgumentList )

1.  Return the result of evaluating ArgumentList.

ArgumentList : AssignmentExpression

1.  Let ref be the result of evaluating AssignmentExpression.

2.  Let arg be GetValue(ref).

3.  Return a List whose sole item is arg.

ArgumentList : _… AssignmentExpression_

1.  Let list be an empty List.

2.  Let spreadRef be the result of evaluating AssignmentExpression.

3.  Let spreadValue be GetValue(spreadRef).

4.  Let spreadObj be ToObject(spreadValue).

5.  Let lenVal be the result of calling the [[Get]] internal method of
    spreadObj with argument “LENGTH”.

6.  Let spreadLen be ToUint32(lenVal).

7.  Let n = 0.

8.  Repeat, while n < spreadLen

    a.  Let nextArg be the result of calling the [[Get]] internal
          method of spreadObj passing ToString(n) as the argument.

    b.  Append nextArg as the last element of list.

    c.  Let n = n+1.

9.  Return list.

ArgumentList : ArgumentList , AssignmentExpression

1.  Let precedingArgs be the result of evaluating ArgumentList.

2.  Let ref be the result of evaluating AssignmentExpression.

3.  Let arg be GetValue(ref).

4.  Return a List whose length is one greater than the length of
    precedingArgs and whose items are the items of precedingArgs, in
    order, followed at the end by arg which is the last item of the
    new list.

ArgumentList : ArgumentList , _… _AssignmentExpression

1.  Let precedingArgs be an empty List.

2.  Let spreadRef be the result of evaluating AssignmentExpression.

3.  Let spreadValue be GetValue(spreadRef).

4.  Let spreadObj be ToObject(spreadValue).

5.  Let lenVal be the result of calling the [[Get]] internal method of
    spreadObj with argument “LENGTH”.

6.  Let spreadLen be ToUint32(lenVal).

7.  Let n = 0.

8.  Repeat, while n < spreadLen

    a.  Let nextArg be the result of calling the [[Get]] internal
          method of spreadObj passing ToString(n) as the argument.

    b.  Append nextArg as the last element of precedingArgs.

    c.  Let n = n+1.

9.  Return precedingArgs.

Syntax

PostfixExpression :

LeftHandSideExpression
LeftHandSideExpression [no LineTerminator here] ++
LeftHandSideExpression [no LineTerminator here] --

STATIC SEMANTICS

STATIC SEMANTICS: EARLY ERRORS

PostfixExpression :

LeftHandSideExpression [no LineTerminator here] ++
LeftHandSideExpression [no LineTerminator here] --

-   It is a Syntax Error if the PostfixExpression is contained in
    strict code and LeftHandSideExpression is the Identifier EVAL or
    the Identifier ARGUMENTS.

-   It is a Syntax Error if the AssignmentExpression is contained in
    extended code and the LeftHandSideExpression is a Literal or a
    FunctionExpression.

-   It is a Syntax Error if the AssignmentExpression is contained in
    extended code and the LeftHandSideExpression is an Identifier
    that does not statically resolve to a declarative environment record
    binding or if the resolved binding is an immutable binding.

-   It is a Syntax Error if the LeftHandSideExpression is
    PrimaryExpression : ( Expression ) and Expression derived a
    production that would produce a Syntax Error according to these
    rules. This rule is recursively applied.

RUNTIME SEMANTICS: EVALUATION

PostfixExpression : LeftHandSideExpression [no LineTerminator
here] ++

1.  Let lhs be the result of evaluating LeftHandSideExpression.

2.  

-   -   -   -   

1.  Let oldValue be ToNumber(GetValue(lhs)).

2.  Let newValue be the result of adding the value 1 to oldValue,
    using the same rules as for the + operator (see 11.6.3).

3.  Call PutValue(lhs, newValue).

4.  Return oldValue.

RUNTIME SEMANTICS: EVALUATION

PostfixExpression : LeftHandSideExpression [no LineTerminator
here] --

1.  Let lhs be the result of evaluating LeftHandSideExpression.

2.  

-   -   -   -   

1.  Let oldValue be ToNumber(GetValue(lhs)).

2.  Let newValue be the result of subtracting the value 1 from
    oldValue, using the same rules as for the - operator (11.6.3).

3.  Call PutValue(lhs, newValue).

4.  Return oldValue.

Syntax

UnaryExpression :

PostfixExpression
DELETE UnaryExpression
VOID UnaryExpression
TYPEOF UnaryExpression
++ UnaryExpression
-- UnaryExpression
+ UnaryExpression
- UnaryExpression
~ UnaryExpression
! UnaryExpression

STATIC SEMANTICS

STATIC SEMANTICS: EARLY ERRORS

UnaryExpression :

DELETE UnaryExpression
++ UnaryExpression
-- UnaryExpression

-   It is a Syntax Error if the UnaryExpression is contained in strict
    code and the derived UnaryExpression is the Identifier EVAL or
    the Identifier ARGUMENTS.

-   It is a Syntax Error if the UnaryExpression is contained in
    extended code and the derived UnaryExpression is a Literal or a
    FunctionExpression.

-   It is a Syntax Error if the UnaryExpression is contained in
    extended code and the derived UnaryExpression is an Identifier
    that does not statically resolve to a declarative environment record
    binding or if the resolved binding is an immutable binding.

-   It is a Syntax Error if the derived UnaryExpression is
    PrimaryExpression : ( Expression ) and Expression derived a
    production that would produce a Syntax Error according to these
    rules. This rule is recursively applied.

RUNTIME SEMANTICS: EVALUATION

UnaryExpression : DELETE UnaryExpression

1.  Let ref be the result of evaluating UnaryExpression.

2.  If Type(ref) is not Reference, return TRUE.

3.  If IsUnresolvableReference(ref) is TRUE, then,

    a.  If IsStrictReference(ref) is TRUE, throw a SYNTAXERROR
        exception.

    b.  Else, return TRUE.

4.  If IsPropertyReference(ref) is TRUE, then

    a.  Return the result of calling the [[Delete]] internal method on
        ToObject(GetBase(ref)) providing GetReferencedName(ref) and
        IsStrictReference(ref) as the arguments.

5.  Else, ref is a Reference to an Environment Record binding, so

    a.  b.  Let bindings be GetBase(ref).

    c.  Return the result of calling the DeleteBinding concrete method
        of bindings, providing GetReferencedName(ref) as the
        argument.

NOTE When a DELETE operator occurs within strict mode code, a
SYNTAXERROR exception is thrown if its UnaryExpression is a direct
reference to a variable, function argument, or function name. In
addition, if a DELETE operator occurs within strict mode code and the
property to be deleted has the attribute { [[Configurable]]: FALSE }, a
TYPEERROR exception is thrown.

RUNTIME SEMANTICS: EVALUATION

UnaryExpression : VOID UnaryExpression

1.  Let expr be the result of evaluating UnaryExpression.

2.  Call GetValue(expr).

3.  Return UNDEFINED.

NOTE GetValue must be called even though its value is not used because
it may have observable side-effects.

RUNTIME SEMANTICS: EVALUATION

UnaryExpression : TYPEOF UnaryExpression

1.  Let val be the result of evaluating UnaryExpression.

2.  If Type(val) is Reference, then

    a.  If IsUnresolvableReference(val) is TRUE, return "UNDEFINED".

    b.  Let val be GetValue(val).

3.  Return a String determined by Type(val) according to Table 21.

Table 21 — typeof Operator Results

  ----------------------------------------------------- -----------------------------------------------------------------------------------------
  _TYPE OF val_                                         RESULT
  Undefined                                             "UNDEFINED"
  Null                                                  "OBJECT"
  Boolean                                               "BOOLEAN"
  Number                                                "NUMBER"
  String                                                "STRING"
  Object (native and does not implement [[Call]])       "OBJECT"
  Object (native or host and does implement [[Call]])   "FUNCTION"
  Object (host and does not implement [[Call]])         Implementation-defined except may not be "UNDEFINED", "BOOLEAN", "NUMBER", or "STRING".
  ----------------------------------------------------- -----------------------------------------------------------------------------------------

RUNTIME SEMANTICS: EVALUATION

UnaryExpression : ++ UnaryExpression

1.  Let expr be the result of evaluating UnaryExpression.

2.  

-   -   -   -   

1.  Let oldValue be ToNumber(GetValue(expr)).

2.  Let newValue be the result of adding the value 1 to oldValue,
    using the same rules as for the + operator (see 11.6.3).

3.  Call PutValue(expr, newValue).

4.  Return newValue.

RUNTIME SEMANTICS: EVALUATION

UnaryExpression : -- UnaryExpression

1.  Let expr be the result of evaluating UnaryExpression.

2.  

-   -   -   -   

1.  Let oldValue be ToNumber(GetValue(expr)).

2.  Let newValue be the result of subtracting the value 1 from
    oldValue, using the same rules as for the - operator (see 11.6.3).

3.  Call PutValue(expr, newValue).

4.  Return newValue.

NOTE The unary + operator converts its operand to Number type.

RUNTIME SEMANTICS: EVALUATION

UnaryExpression : + UnaryExpression

1.  Let expr be the result of evaluating UnaryExpression.

2.  Return ToNumber(GetValue(expr)).

NOTE The unary - operator converts its operand to Number type and then
negates it. Negating +0 produces −0, and negating −0 produces +0.

RUNTIME SEMANTICS: EVALUATION

UnaryExpression : - UnaryExpression

1.  Let expr be the result of evaluating UnaryExpression.

2.  Let oldValue be ToNumber(GetValue(expr)).

3.  If oldValue is NAN, return NAN.

4.  Return the result of negating oldValue; that is, compute a Number
    with the same magnitude but opposite sign.

RUNTIME SEMANTICS: EVALUATION

UnaryExpression : ~ UnaryExpression

1.  Let expr be the result of evaluating UnaryExpression.

2.  Let oldValue be ToInt32(GetValue(expr)).

3.  Return the result of applying bitwise complement to oldValue. The
    result is a signed 32-bit integer.

RUNTIME SEMANTICS: EVALUATION

UnaryExpression : ! UnaryExpression

1.  Let expr be the result of evaluating UnaryExpression.

2.  Let oldValue be ToBoolean(GetValue(expr)).

3.  If oldValue is TRUE, return FALSE.

4.  Return TRUE.

Syntax

MultiplicativeExpression :

UnaryExpression
MultiplicativeExpression * UnaryExpression
MultiplicativeExpression / UnaryExpression
MultiplicativeExpression % UnaryExpression

RUNTIME SEMANTICS: EVALUATION

The production MultiplicativeExpression : _MultiplicativeExpression @
UnaryExpression_, where @ stands for one of the operators in the above
definitions, is evaluated as follows:

1.  Let left be the result of evaluating MultiplicativeExpression.

2.  Let leftValue be GetValue(left).

3.  Let right be the result of evaluating UnaryExpression.

4.  Let rightValue be GetValue(right).

5.  Let leftNum be ToNumber(leftValue).

6.  Let rightNum be ToNumber(rightValue).

7.  Return the result of applying the specified operation (*, /, or %)
    to leftNum and rightNum. See the Notes below 11.5.1, 11.5.2,
    11.5.3.

The * operator performs multiplication, producing the product of its
operands. Multiplication is commutative. Multiplication is not always
associative in ECMAScript, because of finite precision.

The result of a floating-point multiplication is governed by the rules
of IEEE 754 binary double-precision arithmetic:

-   If either operand is NAN, the result is NAN.

-   The sign of the result is positive if both operands have the same
      sign, negative if the operands have different signs.

-   Multiplication of an infinity by a zero results in NAN.

-   Multiplication of an infinity by an infinity results in an infinity.
      The sign is determined by the rule already stated above.

-   Multiplication of an infinity by a finite nonzero value results in a
      signed infinity. The sign is determined by the rule already stated
      above.

-   In the remaining cases, where neither an infinity or NaN is
      involved, the product is computed and rounded to the nearest
      representable value using IEEE 754 round-to-nearest mode. If the
      magnitude is too large to represent, the result is then an
      infinity of appropriate sign. If the magnitude is too small to
      represent, the result is then a zero of appropriate sign. The
      ECMAScript language requires support of gradual underflow as
      defined by IEEE 754.

The / operator performs division, producing the quotient of its
operands. The left operand is the dividend and the right operand is the
divisor. ECMAScript does not perform integer division. The operands and
result of all division operations are double-precision floating-point
numbers. The result of division is determined by the specification of
IEEE 754 arithmetic:

-   If either operand is NAN, the result is NAN.

-   The sign of the result is positive if both operands have the same
      sign, negative if the operands have different signs.

-   Division of an infinity by an infinity results in NAN.

-   Division of an infinity by a zero results in an infinity. The sign
      is determined by the rule already stated above.

-   Division of an infinity by a nonzero finite value results in a
      signed infinity. The sign is determined by the rule already stated
      above.

-   Division of a finite value by an infinity results in zero. The sign
      is determined by the rule already stated above.

-   Division of a zero by a zero results in NAN; division of zero by any
      other finite value results in zero, with the sign determined by
      the rule already stated above.

-   Division of a nonzero finite value by a zero results in a signed
      infinity. The sign is determined by the rule already stated above.

-   In the remaining cases, where neither an infinity, nor a zero, nor
      NAN is involved, the quotient is computed and rounded to the
      nearest representable value using IEEE 754 round-to-nearest mode.
      If the magnitude is too large to represent, the operation
      overflows; the result is then an infinity of appropriate sign. If
      the magnitude is too small to represent, the operation underflows
      and the result is a zero of the appropriate sign. The ECMAScript
      language requires support of gradual underflow as defined by IEEE
      754.

The % operator yields the remainder of its operands from an implied
division; the left operand is the dividend and the right operand is the
divisor.

NOTE In C and C++, the remainder operator accepts only integral
operands; in ECMAScript, it also accepts floating-point operands.

The result of a floating-point remainder operation as computed by the %
operator is not the same as the “remainder” operation defined by IEEE
754. The IEEE 754 “remainder” operation computes the remainder from a
rounding division, not a truncating division, and so its behaviour is
not analogous to that of the usual integer remainder operator. Instead
the ECMAScript language defines % on floating-point operations to behave
in a manner analogous to that of the Java integer remainder operator;
this may be compared with the C library function fmod.

The result of an ECMAScript floating-point remainder operation is
determined by the rules of IEEE arithmetic:

-   If either operand is NAN, the result is NAN.

    -   The sign of the result equals the sign of the dividend.

    -   If the dividend is an infinity, or the divisor is a zero, or
          both, the result is NAN.

    -   If the dividend is finite and the divisor is an infinity, the
          result equals the dividend.

    -   If the dividend is a zero and the divisor is nonzero and finite,
          the result is the same as the dividend.

    -   In the remaining cases, where neither an infinity, nor a zero,
          nor NAN is involved, the floating-point remainder r from a
          dividend n and a divisor d is defined by the mathematical
          relation r = n − (d × q) where q is an integer that is
          negative only if n/d is negative and positive only if n/d is
          positive, and whose magnitude is as large as possible without
          exceeding the magnitude of the true mathematical quotient of n
          and d. r is computed and rounded to the nearest representable
          value using IEEE 754 round-to-nearest mode.

Syntax

AdditiveExpression :

MultiplicativeExpression
AdditiveExpression + MultiplicativeExpression
AdditiveExpression - MultiplicativeExpression

NOTE The addition operator either performs string concatenation or
numeric addition.

RUNTIME SEMANTICS: EVALUATION

AdditiveExpression : AdditiveExpression + MultiplicativeExpression

NOTE 1 No hint is provided in the calls to ToPrimitive in steps 5 and 6.
All native ECMAScript objects except Date objects handle the absence of
a hint as if the hint Number were given; Date objects handle the absence
of a hint as if the hint String were given. Host objects may handle the
absence of a hint in some other manner.

NOTE 2 Step 7 differs from step 3 of the comparison algorithm for the
relational operators (11.8.1), by using the logical-or operation instead
of the logical-and operation.

RUNTIME SEMANTICS: EVALUATION

AdditiveExpression : AdditiveExpression - MultiplicativeExpression

The + operator performs addition when applied to two operands of numeric
type, producing the sum of the operands. The - operator performs
subtraction, producing the difference of two numeric operands.

Addition is a commutative operation, but not always associative.

The result of an addition is determined using the rules of IEEE 754
binary double-precision arithmetic:

-   If either operand is NAN, the result is NAN.

-   The sum of two infinities of opposite sign is NAN.

-   The sum of two infinities of the same sign is the infinity of that
      sign.

-   The sum of an infinity and a finite value is equal to the infinite
      operand.

-   The sum of two negative zeroes is −0. The sum of two positive
      zeroes, or of two zeroes of opposite sign, is +0.

-   The sum of a zero and a nonzero finite value is equal to the nonzero
      operand.

-   The sum of two nonzero finite values of the same magnitude and
      opposite sign is +0.

-   In the remaining cases, where neither an infinity, nor a zero, nor
      NaN is involved, and the operands have the same sign or have
      different magnitudes, the sum is computed and rounded to the
      nearest representable value using IEEE 754 round-to-nearest mode.
      If the magnitude is too large to represent, the operation
      overflows and the result is then an infinity of appropriate sign.
      The ECMAScript language requires support of gradual underflow as
      defined by IEEE 754.

The - operator performs subtraction when applied to two operands of
numeric type, producing the difference of its operands; the left operand
is the minuend and the right operand is the subtrahend. Given numeric
operands a and b, it is always the case that a–b produces the same
result as _a +(–b)_.

Syntax

ShiftExpression :

AdditiveExpression
ShiftExpression << AdditiveExpression
ShiftExpression >> AdditiveExpression
ShiftExpression >>> AdditiveExpression

NOTE Performs a bitwise left shift operation on the left operand by the
amount specified by the right operand.

RUNTIME SEMANTICS: EVALUATION

ShiftExpression : ShiftExpression << AdditiveExpression

NOTE Performs a sign-filling bitwise right shift operation on the left
operand by the amount specified by the right operand.

RUNTIME SEMANTICS: EVALUATION

ShiftExpression : ShiftExpression >> AdditiveExpression

NOTE Performs a zero-filling bitwise right shift operation on the left
operand by the amount specified by the right operand.

RUNTIME SEMANTICS: EVALUATION

ShiftExpression : ShiftExpression >>> AdditiveExpression

NOTE The result of evaluating a relational operator is always of type
Boolean, reflecting whether the relationship named by the operator holds
between its two operands.

Syntax

RelationalExpression :

ShiftExpression
RelationalExpression < ShiftExpression
RelationalExpression > ShiftExpression
RelationalExpression <= ShiftExpression
RelationalExpression >= ShiftExpression
RelationalExpression INSTANCEOF ShiftExpression
RelationalExpression IN ShiftExpression

RelationalExpressionNoIn :

ShiftExpression
RelationalExpressionNoIn < ShiftExpression
RelationalExpressionNoIn > ShiftExpression
RelationalExpressionNoIn <= ShiftExpression
RelationalExpressionNoIn >= ShiftExpression
RelationalExpressionNoIn INSTANCEOF ShiftExpression

The semantics of the RelationalExpressionNoIn productions are the same
as the RelationalExpression productions except that the contained
RelationalExpressionNoIn is used in place of the contained
RelationalExpression.

NOTE The “NoIn” variants are needed to avoid confusing the in operator
in a relational expression with the in operator in a for statement.

RUNTIME SEMANTICS: THE ABSTRACT RELATIONAL COMPARISON ALGORITHM

The comparison x < y, where x and y are values, produces TRUE,
FALSE, or UNDEFINED (which indicates that at least one operand is NAN).
In addition to x and y the algorithm takes a Boolean flag named
LeftFirst as a parameter. The flag is used to control the order in
which operations with potentially visible side-effects are performed
upon x and y. It is necessary because ECMAScript specifies left to
right evaluation of expressions. The default value of LeftFirst is
TRUE and indicates that the x parameter corresponds to an expression
that occurs to the left of the y parameter’s corresponding expression.
If LeftFirst is FALSE, the reverse is the case and operations must be
performed upon y before x. Such a comparison is performed as
follows:

NOTE 1 Step 3 differs from step 7 in the algorithm for the addition
operator + (11.6.1) in using and instead of or.

NOTE 2 The comparison of Strings uses a simple lexicographic ordering on
sequences of code unit values. There is no attempt to use the more
complex, semantically oriented definitions of character or string
equality and collating order defined in the Unicode specification.
Therefore String values that are canonically equal according to the
Unicode standard could test as unequal. In effect this algorithm assumes
that both Strings are already in normalised form. Also, note that for
strings containing supplementary characters, lexicographic ordering on
sequences of UTF-16 code unit values differs from that on sequences of
code point values.

RUNTIME SEMANTICS: EVALUATION

RelationalExpression : RelationalExpression < ShiftExpression

RelationalExpression : RelationalExpression > ShiftExpression

RelationalExpression : RelationalExpression <= ShiftExpression

RelationalExpression : RelationalExpression >= ShiftExpression

RelationalExpression: RelationalExpression INSTANCEOF
ShiftExpression

RelationalExpression : RelationalExpression IN ShiftExpression

NOTE The result of evaluating an equality operator is always of type
Boolean, reflecting whether the relationship named by the operator holds
between its two operands.

Syntax

EqualityExpression :

RelationalExpression
EqualityExpression == RelationalExpression
EqualityExpression != RelationalExpression
EqualityExpression === RelationalExpression
EqualityExpression !== RelationalExpression
EqualityExpression [no LineTerminator here] IS RelationalExpression
EqualityExpression [no LineTerminator here] ISNT RelationalExpression

EqualityExpressionNoIn :

RelationalExpressionNoIn
EqualityExpressionNoIn == RelationalExpressionNoIn
EqualityExpressionNoIn != RelationalExpressionNoIn
EqualityExpressionNoIn === RelationalExpressionNoIn
EqualityExpressionNoIn !== RelationalExpressionNoIn
EqualityExpression [no LineTerminator here] IS RelationalExpression
EqualityExpression [no LineTerminator here] ISNT RelationalExpression

The semantics of the EqualityExpressionNoIn productions are the same
as the EqualityExpression productions except that the contained
EqualityExpressionNoIn and RelationalExpressionNoIn are used in
place of the contained EqualityExpression and RelationalExpression,
respectively.

RUNTIME SEMANTICS: THE ABSTRACT EQUALITY COMPARISON ALGORITHM

The comparison x == y, where x and y are values, produces TRUE
or FALSE. Such a comparison is performed as follows:

NOTE 1 Given the above definition of equality:

-   String comparison can be forced by: "" + A == "" + B.

-   Numeric comparison can be forced by: +A == +B.

-   Boolean comparison can be forced by: !A == !B.

NOTE 2 The equality operators maintain the following invariants:

-   A != B is equivalent to !(A == B).

-   A == B is equivalent to B == A, except in the order of evaluation of
      A and B.

NOTE 3 The equality operator is not always transitive. For example,
there might be two distinct String objects, each representing the same
String value; each String object would be considered equal to the String
value by the == operator, but the two String objects would not be equal
to each other. For Example:

-   NEW STRING("A") == "A" and "A" == NEW STRING("A")are both TRUE.

-   NEW STRING("A") == NEW STRING("A") is FALSE.

NOTE 4 Comparison of Strings uses a simple equality test on sequences of
code unit values. There is no attempt to use the more complex,
semantically oriented definitions of character or string equality and
collating order defined in the Unicode specification. Therefore Strings
values that are canonically equal according to the Unicode standard
could test as unequal. In effect this algorithm assumes that both
Strings are already in normalised form.

RUNTIME SEMANTICS: THE STRICT EQUALITY COMPARISON ALGORITHM

The comparison x === y, where x and y are values, produces TRUE
or FALSE. Such a comparison is performed as follows:

NOTE This algorithm differs from the SameValue Algorithm (9.12) in its
treatment of signed zeroes and NaNs.

RUNTIME SEMANTICS: EVALUATION

EqualityExpression : EqualityExpression == RelationalExpression

EqualityExpression : EqualityExpression != RelationalExpression

EqualityExpression : EqualityExpression === RelationalExpression

EqualityExpression : EqualityExpression !== RelationalExpression

EqualityExpression : EqualityExpression [no LineTerminator here]
IS RelationalExpression

1.  Let lref be the result of evaluating EqualityExpression.

2.  Let lval be GetValue(lref).

3.  Let rref be the result of evaluating RelationalExpression.

4.  Let rval be GetValue(rref).

5.  Return the result of performing SaveValue(rval, lval).

EqualityExpression : EqualityExpression [no LineTerminator here]
ISNT RelationalExpression

1.  Let lref be the result of evaluating EqualityExpression.

2.  Let lval be GetValue(lref).

3.  Let rref be the result of evaluating RelationalExpression.

4.  Let rval be GetValue(rref).

5.  Let r be the result of performing SaveValue(rval, lval).

6.  If r is TRUE, return FALSE. Otherwise, return TRUE.

Syntax

BitwiseANDExpression :

EqualityExpression
BitwiseANDExpression & EqualityExpression

BitwiseANDExpressionNoIn :

EqualityExpressionNoIn
BitwiseANDExpressionNoIn & EqualityExpressionNoIn

BitwiseXORExpression :

BitwiseANDExpression
BitwiseXORExpression ^ BitwiseANDExpression

BitwiseXORExpressionNoIn :

BitwiseANDExpressionNoIn
BitwiseXORExpressionNoIn ^ BitwiseANDExpressionNoIn

BitwiseORExpression :

BitwiseXORExpression
BitwiseORExpression | BitwiseXORExpression

BitwiseORExpressionNoIn :

BitwiseXORExpressionNoIn
BitwiseORExpressionNoIn | BitwiseXORExpressionNoIn

RUNTIME SEMANTICS: EVALUATION

The production A : _A @ B_, where @ is one of the bitwise operators in
the productions above, is evaluated as follows:

Syntax

LogicalANDExpression :

BitwiseORExpression
LogicalANDExpression && BitwiseORExpression

LogicalANDExpressionNoIn :

BitwiseORExpressionNoIn
LogicalANDExpressionNoIn && BitwiseORExpressionNoIn

LogicalORExpression :

LogicalANDExpression
LogicalORExpression || LogicalANDExpression

LogicalORExpressionNoIn :

LogicalANDExpressionNoIn
LogicalORExpressionNoIn || LogicalANDExpressionNoIn

The semantics of the LogicalANDExpressionNoIn and
LogicalORExpressionNoIn productions are the same manner as the
LogicalANDExpression and LogicalORExpression productions except that
the contained LogicalANDExpressionNoIn, BitwiseORExpressionNoIn and
LogicalORExpressionNoIn are used in place of the contained
LogicalANDExpression, BitwiseORExpression and LogicalORExpression,
respectively.

NOTE The value produced by a && or || operator is not necessarily of
type Boolean. The value produced will always be the value of one of the
two operand expressions.

RUNTIME SEMANTICS: EVALUATION

LogicalANDExpression : LogicalANDExpression && BitwiseORExpression

LogicalORExpression : LogicalORExpression || LogicalANDExpression

Syntax

ConditionalExpression :

LogicalORExpression
LogicalORExpression ? AssignmentExpression : AssignmentExpression

ConditionalExpressionNoIn :

LogicalORExpressionNoIn
LogicalORExpressionNoIn ? AssignmentExpression :
AssignmentExpressionNoIn

The semantics of the ConditionalExpressionNoIn production is the same
as the ConditionalExpression production except that the contained
LogicalORExpressionNoIn, AssignmentExpression and
AssignmentExpressionNoIn are used in place of the contained
LogicalORExpression, first AssignmentExpression and second
AssignmentExpression, respectively.

NOTE The grammar for a ConditionalExpression in ECMAScript is a little
bit different from that in C and Java, which each allow the second
subexpression to be an Expression but restrict the third expression to
be a ConditionalExpression. The motivation for this difference in
ECMAScript is to allow an assignment expression to be governed by either
arm of a conditional and to eliminate the confusing and fairly useless
case of a comma expression as the centre expression.

RUNTIME SEMANTICS: EVALUATION

ConditionalExpression : LogicalORExpression ? AssignmentExpression
: AssignmentExpression

Syntax

AssignmentExpression :

ConditionalExpression
LeftHandSideExpression = AssignmentExpression
LeftHandSideExpression AssignmentOperator AssignmentExpression

AssignmentExpressionNoIn :

ConditionalExpressionNoIn
LeftHandSideExpression = AssignmentExpressionNoIn
LeftHandSideExpression AssignmentOperator AssignmentExpressionNoIn

AssignmentOperator : ONE OF

  ---- ---- ---- ---- ---- ----- ----- ------ ---- ---- ----
  *=   /=   %=   +=   -=   <<=   >>=   >>>=   &=   ^=   |=
  ---- ---- ---- ---- ---- ----- ----- ------ ---- ---- ----

The semantics of the AssignmentExpressionNoIn productions are the same
manner as the AssignmentExpression productions except that the
contained ConditionalExpressionNoIn and AssignmentExpressionNoIn are
used in place of the contained ConditionalExpression and
AssignmentExpression, respectively.

STATIC SEMANTICS: EARLY ERRORS

AssignmentExpression :

LeftHandSideExpression = AssignmentExpression
LeftHandSideExpression AssignmentOperator AssignmentExpression

-   It is a Syntax Error if the AssignmentExpression is contained in
    strict code and LeftHandSideExpression is the Identifier EVAL or
    the Identifier ARGUMENTS.

-   -   It is a Syntax Error if the AssignmentExpression is contained
    in extended code and the LeftHandSideExpression is a Literal or
    a FunctionExpression.

-   It is a Syntax Error if the AssignmentExpression is contained in
    extended code and the LeftHandSideExpression is an Identifier
    that does not statically resolve to a declarative environment record
    binding or if the resolved binding is an immutable binding.

-   It is a Syntax Error if the LeftHandSideExpression is
    PrimaryExpression : ( Expression ) and Expression derived a
    production that would produce a Syntax Error according to these
    rules. This rule is recursively applied.

AssignmentExpression : LeftHandSideExpression = AssignmentExpression

-   It is a Syntax Error if the AssignmentExpression is contained in
    extended code and the LeftHandSideExpression is an ObjectLiteral
    or an ArrayLiteral and the source code corresponding to
    LeftHandSideExpression cannot be parsed using AssignmentPattern
    as the goal symbol.

RUNTIME SEMANTICS: EVALUATION

AssignmentExpression : LeftHandSideExpression =
AssignmentExpression

AssignmentExpression : _LeftHandSideExpression AssignmentOperator
AssignmentExpression_

-   -   -   -   

NOTE When an assignment occurs within strict mode code, lref in step
1.d of the first must not be an unresolvable reference. If it is, a
REFERENCEERROR exception is thrown upon assignment. The LeftHandSide
also may not be a reference to a data property with the attribute value
{[[Writable]]:FALSE}, to an accessor property with the attribute value
{[[Set]]:UNDEFINED}, nor to a non-existent property of an object whose
[[Extensible]] internal property has the value FALSE. In these cases a
TYPEERROR exception is thrown.

Supplemental Syntax

In certain circumstances when processing the production
AssignmentExpression : LeftHandSideExpression =
AssignmentExpression the following grammar is used to refine the
interpretation of LeftHandSideExpression.

AssignmentPattern :

ObjectAssignmentPattern
ArrayAssignmentPattern

ObjectAssignmentPattern :

{ }
{ AssignmentPropertyList }
{ AssignmentPropertyList , }

ArrayAssignmentPattern :

[ Elision~opt~ AssignmentRestElement~opt~ ]
[ AssignmentElementList ]
[ AssignmentElementList , Elision~opt~ AssignmentRestElement~opt~ ]

AssignmentPropertyList :

AssignmentProperty
AssignmentPropertyList , AssignmentProperty

AssignmentElementList :

Elision~opt~ AssignmentElement
AssignmentElementList , Elision~opt~ AssignmentElement

AssignmentProperty :

Identifier
PropertyName : LeftHandSideExpression

AssignmentElement :

LeftHandSideExpression

AssignmentRestElement :

… LeftHandSideExpression

STATIC SEMANTICS: EARLY ERRORS

AssignmentProperty : PropertyName : LeftHandSideExpression

AssignmentElement : LeftHandSideExpression

-   It is a Syntax Error if LeftHandSideExpression is the Identifier
    EVAL or the Identifier ARGUMENTS.

-   It is a Syntax Error if LeftHandSideExpression is the Identifier
    THIS or the Identifier SUPER.

-   It is a Syntax Error if the LeftHandSideExpression is a Literal,
    a FunctionExpression or a ClassExpression.

-   It is a Syntax Error if the LeftHandSideExpression is an
    Identifier that does not statically resolve to a declarative
    environment record binding or if the resolved binding an immutable
    binding.

-   It is a Syntax Error if the LeftHandSideExpression is an
    ObjectLiteral or an ArrayLiteral and the source code
    corresponding to LeftHandSideExpression using cannot be parsed
    using AssignmentPattern as the goal symbol.

-   It is a Syntax Error if the LeftHandSideExpression is
    PrimaryExpression : ( Expression ) and Expression derived a
    production that would produce a Syntax Error according to these
    rules. This rule is recursively applied.

AssignmentRestElement : … LeftHandSideExpression

-   It is a Syntax Error if LeftHandSideExpression is the Identifier
    EVAL or the Identifier ARGUMENTS.

-   It is a Syntax Error if LeftHandSideExpression is the Identifier
    THIS or the Identifier SUPER.

-   It is a Syntax Error if the LeftHandSideExpression is a Literal,
    an ObjectLiteral, an ArrayLiteral, a FunctionExpression, or a
    ClassExpression.

-   It is a Syntax Error if the LeftHandSideExpression is an
    Identifier that does not statically resolve to a declarative
    environment record binding or if the resolved binding an immutable
    binding.

-   It is a Syntax Error if the LeftHandSideExpression is
    PrimaryExpression : ( Expression ) and Expression derived a
    production that would produce a Syntax Error according to these
    rules. This rule is recursively applied.

RUNTIME SEMANTICS: DESTRUCTURING ASSIGNMENT EVALUATION

  with parameter obj

AssignmentPattern : ObjectAssignmentPattern

1.  Perform Destructuring Assignment Evaluation of
    ObjectAssignmentPattern with obj as the argument.

2.  

AssignmentPattern : ArrayAssignmentPattern

1.  Perform Destructuring Assignment Evaluation of
    ArrayAssignmentPattern with obj as the argument.

2.  

ObjectAssignmentPattern : { }

and

ArrayAssignmentPattern :

[]
[Elision]

1.  Return.

ObjectAssignmentPattern :

{ AssignmentPropertyList }
{ AssignmentPropertyList , }

1.  Perform Destructuring Assignment Evaluation of
    AssignmentPropertyList with obj as the argument.

2.  

AssignmentPropertyList : AssignmentProperty

1.  Perform Destructuring Assignment Evaluation of AssignmentProperty
    with obj as the argument.

2.  

AssignmentPropertyList : AssignmentPropertyList ,
AssignmentProperty

1.  Perform Destructuring Assignment Evaluation of
    AssignmentPropertyList with obj as the argument.

2.  Perform Destructuring Assignment Evaluation of AssignmentProperty
    with obj as the argument.

AssignmentProperty : Identifier

1.  Let v be the result of calling the [[Get]] internal method of
    obj with the Identifier string as the argument.

2.  Let lref be the result of performing Identifier Resolution(10.3.1)
    with the IdentifierName corresponding to Identifier.

3.  Call PutValue(lref_,_v).

4.  

-   -   -   -   -   -   

AssignmentProperty : PropertyName : LeftHandSideExpression

1.  Let name be the result of evaluating PropertyName.

2.  Let v be the result of calling the [[Get]] internal method of
    obj with name as the argument.

3.  If LeftHandSideExpression is an ObjectLiteral or an
    ArrayLiteral then

    a.  Let AssignmentPattern be the parse of the source code
        corresponding to LeftHandSideExpression using
        AssignmentPattern as the goal symbol

    b.  Let vObj be ToObject(v).

    c.  Evaluate AssignmentPattern using vObj as the obj
        parameter.

    d.  Return.

4.  Let lref be the result of evaluating LeftHandSideExpression.

5.  Call PutValue(lref_,_v).

6.  

ArrayAssignmentPattern : [ Elision~opt~ AssignmentRestElement ]

1.  If Elision is present, then let skip be the result of evaluating
    Elision, otherwise let skip be 0.

2.  Perform Indexed Destructuring Assignment Evaluation of
    AssignmentRestElement with and skip as the arguments.

3.  

ArrayAssignmentPattern : [ AssignmentElementList ]

1.  Perform Indexed Destructuring Assignment Evaluation of
    AssignmentElementList using obj and 0 as the arguments.

ArrayAssignmentPattern : [ AssignmentElementList , Elision~opt~
AssignmentRestElement~opt~ ]

1.  Let lastIndex be the result of performing Indexed Destructuring
    Assignment Evaluation of AssignmentElementList using obj and 0
    as the arguments.

2.  If Elision is present, then let skip be the result of evaluating
    Elision, otherwise let skip be 0.

3.  If AssignmentRestElement is present, then perform Indexed
    Destructuring Assignment Evaluation of AssignmentRestElement with
    obj and lastIndex_+_skip as the arguments.

4.  

RUNTIME SEMANTICS: INDEXED DESTRUCTURING ASSIGNMENT EVALUATION

  with parameters obj and index

AssignmentElementList : Elision~opt~ _AssignmentElement _

1.  If Elision is present, then let skip be the result of evaluating
    Elision, otherwise let skip be 0.

2.  Perform Indexed Destructuring Assignment Evaluation of
    AssignmentElement with obj and index_+_skip as the arguments.

3.  Return index_+_skip+1.

4.  

AssignmentElementList : AssignmentElementList , Elision~opt~
_AssignmentElement _

  with parameters obj and index

1.  Let listNext be the result of performing Indexed Destructuring
    Assignment Evaluation of AssignmentElementList using obj as the
    obj parameter and index as the index parameter

2.  If Elision is present, then let skip be the result of evaluating
    Elision, otherwise let skip be 0.

3.  Perform Indexed Destructuring Assignment Evaluation of
    AssignmentElement with obj and listNext_+_skip as the
    arguments.

4.  Return listNext_+_skip+1.

5.  

AssignmentElement : LeftHandSideExpression

  with parameters obj and index

1.  Let name be ToString(index).

2.  Let v be the result of calling the [[Get]] internal method of
    obj with name as the argument.

3.  If LeftHandSideExpression is an ObjectLiteral or an
    ArrayLiteral then

    a.  Let AssignmentPattern be the parse of the source code
        corresponding to LeftHandSideExpression using
        AssignmentPattern as the goal symbol

    b.  Let vObj be ToObject(v).

    c.  Performing Destructuring Assignment Evaluation of
        AssignmentPattern with vObj as the argument.

    d.  Return.

4.  Let lref be the result of evaluating LeftHandSideExpression.

5.  Call PutValue(lref_,_v).

6.  

AssignmentRestElement : … LeftHandSideExpression

  with parameters obj and index

1.  Let lref be the result of evaluating LeftHandSideExpression.

2.  Let lenVal be the result of calling the [[Get]] internal method of
    obj with argument “LENGTH”.

3.  Let len be ToUint32(lenVal).

4.  Let A be a new array object created as if by the expression NEW
    ARRAY() where ARRAY is the standard built-in constructor with that
    name.

5.  Let n=0;

6.  Repeat, while index < len

    a.  Let P be ToString(index).

    b.  Let exists be the result of calling the [[HasProperty]]
        internal method of obj with argument P.

    c.  If exists is TRUE, then

        i.  Let v be the result of calling the [[Get]] internal method
              of obj passing ToString(index) as the argument.

        ii. Call the [[DefineOwnProperty]] internal method of A with
              arguments ToString(n), Property Descriptor {[[Value]]:
              v, [[Writable]]: TRUE, [[Enumerable]]: TRUE,
              [[Configurable]]: TRUE}, and FALSE.

    d.  Let n = n+1.

    e.  Let index = index+1.

7.  Call PutValue(lref_,_A).

8.  

Syntax

Expression :

AssignmentExpression
Expression , AssignmentExpression

ExpressionNoIn :

AssignmentExpressionNoIn
ExpressionNoIn , AssignmentExpressionNoIn

The semantics of the ExpressionNoIn production is the same manner as
the Expression production except that the contained ExpressionNoIn
and AssignmentExpressionNoIn are used in place of the contained
Expression and AssignmentExpression, respectively.

RUNTIME SEMANTICS: EVALUATION

Expression : Expression , AssignmentExpression

NOTE GetValue must be called even though its value is not used because
it may have observable side-effects.

Syntax

Statement :

BlockStatement
VariableStatement
EmptyStatement
ExpressionStatement
IfStatement
IterationStatement
ContinueStatement
BreakStatement
ReturnStatement
WithStatement
LabelledStatement
SwitchStatement
ThrowStatement
TryStatement
DebuggerStatement

Declaration :

FunctionDeclaration
LetDeclaration
ConstDeclaration

Static Semantics

A Statement can be part of a LabelledStatement, which itself can be
part of a LabelledStatement, and so on. The labels introduced this way
are collectively referred to as the “current label set” when describing
the semantics of individual statements. A LabelledStatement has no
semantic meaning other than the introduction of a label to a _label
set_. The label set of an IterationStatement or a SwitchStatement
initially contains the single element EMPTY. The label set of any other
statement is initially empty.

STATIC SEMANTICS: BOUNDNAMES

The BoundNames of the Declaration productions are determined as
follows:

1.  Return the BoundNames of the single non-terminal symbol that is the
    right hand side of the production.

STATIC SEMANTICS: VARDECLAREDNAMES

Statement :

EmptyStatement
ExpressionStatement
ContinueStatement
BreakStatement
ReturnStatement
ThrowStatement
DebuggerStatement

1.  Return a new empty List.

Statement :

BlockStatement
VariableStatement
IterationStatement
WithStatement
LabelledStatement
SwitchStatement
TryStatement

1.  Return the VarDeclaredNames of the single non-terminal symbol that
    is the right hand side of the production.

Statement : VariableStatement

1.  Return the BoundNames of VariableStatement.

RUNTIME SEMANTICS: EVALUATION

The Statement productions are all evaluated as as follows

1.  Return the result of evaluating the single non-terminal symbol that
    is the right hand side of the production.

The Declaration productions are all evaluated as as follows

1.  Return the result of evaluating the single non-terminal symbol that
    is the right hand side of the production.

NOTE The result of evaluating a Statement or Declaration is always a
Completion value.

1.  

1.  

Syntax

BlockStatement :

Block

Block :

{ StatementList~opt~ }

StatementList :

StatementListItem
StatementList StatementListItem

StatementListItem :

Statement
Declaration

STATIC SEMANTICS: EARLY ERRORS

Block : { StatementList }

-   It is a Syntax Error if StatementList includes a
    StatementListItem : Declaration production whose Declaration
    is a Declaration : FunctionDeclaration production and the source
    code matching this Block production is not contained in extended
    code.

-   It is a Syntax Error if the LexicallyDeclaredNames of
    StatementList contains any duplicate entires.

-   It is a Syntax Error if any element of the LexicallyDeclaredNames of
    StatementList also occurs in the VarDeclaredNames of
    StatementList.

STATIC SEMANTICS: LEXICALDECLARATIONS

StatementList : StatementListItem

1.  Return the LexicalDeclarations of StatementListItem.

StatementList : _StatementList StatementListItem_

1.  Let declarations be LexicalDeclarations of StatementList.

2.  Append to names the elements of the LexicalDeclarations of
    StatementListItem.

3.  Return declarations.

StatementListItem : Statement

1.  Return a new empty List.

StatementListItem : Declaration

1.  Return return a new List containing Declaration.

1.  

1.  

STATIC SEMANTICS: LEXICALLYDECLAREDNAMES

Block : { }

1.  Return a new empty List.

Block : { StatementList }

1.  Return the LexicallyDeclaredNames of StatementListItem.

StatementList : StatementListItem

1.  Return the LexicallyDeclaredNames of StatementListItem.

StatementList : _StatementList StatementListItem_

1.  Let names be LexicallyDeclaredNames of StatementList.

2.  Append to names the elements of the LexicallyDeclaredNames of
    StatementListItem.

3.  Return names.

StatementListItem : Statement

1.  Return a new empty List.

StatementListItem : Declaration

1.  Return the BoundNames of Declaration.

STATIC SEMANTICS: VARDECLAREDNAMES

BlockStatement : Block

1.  Return the VarDeclaredNames of Block.

Block : { }

1.  Return a new empty List.

Block : { StatementList }

1.  Return the VarDeclaredNames of StatementList.

StatementList : StatementListItem

1.  Return the VarDeclaredNames of StatementListItem.

StatementList : _StatementList StatementListItem_

1.  Let names be VarDeclaredNames of StatementList.

2.  Append to names the elements of the VarDeclaredNames of
    StatementListItem.

3.  Return names.

StatementListItem : Statement

1.  Return the VarDeclaredNames of Statement.

StatementListItem : Declaration

1.  Return a new empty List.

RUNTIME SEMANTICS: EVALUATION

BlockStatement : Block

1.  Return the result of evaluating Block.

Block : { }

1.  Return (NORMAL, EMPTY, EMPTY).

-   -   -   

1.  

1.  

Block : { StatementList }

NOTE No matter how control leaves the Block the LexicalEnvironment is
always restored to its former state.

1.  

1.  

1.  

StatementList : StatementListItem

1.  2.  3.  

1.  2.  3.  

1.  2.  3.  

StatementList : _StatementList StatementListItem_

NOTE Steps 5 and 6 of the above algoritm ensure that the value of a
StatementList is the value of the last value producing Statement in
the StatementList. For example, the following calls to the EVAL
function all return the value 1:

  EVAL("1;;;;;")

  EVAL("1;{}")

  EVAL("1;VAR A;")

1.  

1.  

StatementListItem : Statement

1.  Return the result of evaluating Statement.

1.  

1.  

1.  

StatementListItem : Declaration

1.  Return the result of evaluating Declaration.

NOTE A LET declaration defines variables that are scoped to the current
execution context’s LexicalEnvironment. Let variables are created when
their containing Lexical Environment is instantiated but may not be
accssed in any way until the variable’s LetBinding is executed. A
variable defined by a LetBinding with an Initialiser is assigned the
value of its Initialiser’s AssignmentExpression when the
LetBinding is executed, not when the variable is created. If a
LetBinding does not have an an Initialiser the variable is assigned
the value UNDEFINED when the LetBinding is executed.

Syntax

LetDeclaration :

LET LetBindingList ;

LetBindingList :

LetBinding
LetBindingList , LetBinding

LetBindingListNoIn :

LetBindingNoIn
LetBindingListNoIn , LetBindingNoIn

LetBinding :

BindingIdentifier Initialiser~opt
~BindingPattern Initialiser

LetBindingNoIn :

BindingIdentifier InitialiserNoIn~opt
~BindingPattern InitialiserNoIn

BindingIdentifier :

Identifier

Initialiser :

= AssignmentExpression

InitialiserNoIn :

= AssignmentExpressionNoIn

The semantics of the LetBindingListNoIn, LetBindingNoIn and
InitialiserNoIn productions are the same as the LetBindingList,
LetBinding and Initialiser productions except that the contained
LetBindingListNoIn, LetBindingNoIn, InitialiserNoIn and
AssignmentExpressionNoIn are used in place of the contained
LetBindingList, LetBinding, Initialiser and
AssignmentExpression, respectively.

STATIC SEMANTICS: EARLY ERRORS

LetDeclaration : LET LetBindingList ;

-   It is a Syntax Error if the code that matches this production is not
    contained in extended code.

BindingIdentifier : Identifier

-   It is a Syntax Error if the BindingIdentifier is contained in
    strict code and if the Identifier is EVAL or ARGUMENTS.

STATIC SEMANTICS: BOUNDNAMES

LetDeclaration : LET LetBindingList ;

1.  Return BoundNames of LetBindingList.

LetBindingList : LetBinding

1.  Return BoundNames of LetBinding.

LetBindingList : LetBindingList , LetBinding

1.  Let names be BoundNames of LetBindingList.

2.  Append to names the elements of BoundNames of LetBinding.

3.  Return names.

LetBinding : _BindingIdentifier Initialiser_~opt~

1.  Return the BoundNames of BindingIdentifier.

LetBinding: _BindingPattern Initialiser_

1.  Return the BoundNames of BindingPattern.

BindingIdentifier : Identifier

1.  Return a new List containing the String Value of Identifier.

RUNTIME SEMANTICS: STRING VALUE

BindingIdentifier : Identifier

1.  Return the String Value of Identifier.

RUNTIME SEMANTICS: BINDING INITIALIZATION

  With arguments value and enviornment.

NOTE UNDEFINED is passed for environment to indicate that a PutValue
operation should be used to assign the initialization value. This is the
the case for VAR statements formal parameter lists of non-strict
functions. In those cases a lexical binding is hosted and preinitialized
prior to evaluation of its initializer.

BindingIdentifier : Identifier

1.  Perform Binding Initialization for Identifier passing value and
    env as the arguments.

Token Identifier

1.  If enviornment is not UNDEFINED, then

    a.  Call the InitializeBinding concrete method of enviornment
        passing Identifier and value as the arguments.

2.  Else

    a.  Let lhs be the result of evaluating Identifier as described
        in 11.1.2.

    b.  Call PutValue(lhs, value).

RUNTIME SEMANTICS: EVALUATION

LetDeclaration : LET LetBindingList ;

1.  Evaluate LetBindingList.

2.  Return (normal, empty, empty).

LetBindingList : LetBinding

1.  Evaluate LetBinding.

LetBindingList : LetBindingList , LetBinding

1.  Evaluate LetBindingList.

2.  Evaluate LetBinding.

LetBinding : _BindingIdentifier _

LetBinding : _BindingIdentifier Initialiser_

1.  Let rhs be the result of evaluating Initialiser.

2.  Let value be GetValue(rhs).

3.  Let env be the running execution context’s LexicalEnvironment.

4.  Perform Binding Initialization for BindingIdentifier passing
    value and env as the arguments.

LetBinding: _BindingPattern Initialiser_

1.  Let rhs be the result of evaluating Initialiser.

2.  Let rval be GetValue(rhs).

3.  Let env be the running execution context’s LexicalEnvironment.

4.  Perform Binding Initialization for BindingPattern using rval as
    the obj parameter and env as the environment parameter.

1.  

Initialiser : = AssignmentExpression

NOTE A CONST declaration defines read-only variables that are scoped to
the current execution context’s LexicalEnvironment. Constant variables
are created when their containing Lexical Environment is instantiated
but may not be accssed in any way until the variable’s ConstBinding is
executed. A variable defined by a ConstBinding is assigned the value
of its Initialiser’s AssignmentExpression when the ConstBinding is
executed, not when the variable is created.

Syntax

ConstDeclaration :

CONST ConstBindingList ;

ConstBindingList :

ConstBinding
ConstBinding List , ConstBinding

ConstBinding :

BindingIdentifier Initialiser~
~BindingPattern Initialiser

STATIC SEMANTICS: EARLY ERRORS

ConstDeclaration : CONST ConstBindingList ;

-   It is a Syntax Error if the code that matches this production is not
    contained in extended code.

STATIC SEMANTICS: BOUNDNAMES

ConstDeclaration : CONST ConstBindingList ;

1.  Return BoundNames of ConstBindingList.

ConstBindingList : ConstBinding

1.  Return BoundNames of ConstBinding.

ConstBindingList : ConstBindingList , ConstBinding

1.  Let names be BoundNames of ConstBindingList.

2.  Append to names the elements of BoundNames of ConstBinding.

3.  Return names.

ConstBinding : _BindingIdentifier Initialiser_

1.  Return the BoundNames of BindingIdentifier.

ConstBinding: _BindingPattern Initialiser_

1.  Return the BoundNames of BindingPattern.

RUNTIME SEMANTICS: EVALUATION

ConstDeclaration : CONST ConstBindingList ;

1.  Evaluate ConstBindingList.

2.  Return (normal, empty, empty).

1.  

ConstBindingList : ConstBinding

1.  Evaluate ConstBinding.

1.  2.  3.  

ConstBindingList : ConstBindingList , ConstBinding

1.  Evaluate ConstBindingList.

2.  Evaluate ConstBinding.

1.  

ConstBinding : _BindingIdentifier Initialiser_

1.  Let rhs be the result of evaluating Initialiser.

2.  Let value be GetValue(rhs).

3.  Let env be the running execution context’s LexicalEnvironment.

4.  Perform Binding Initialization for BindingIdentifier passing
    value and env as the arguments.

1.  

ConstBinding: _BindingPattern Initialiser_

1.  Let rhs be the result of evaluating Initialiser.

2.  Let rval be GetValue(rhs).

3.  Let env be the running execution context’s LexicalEnvironment.

4.  Perform Binding Initialization for BindingPattern using rval as
    the obj parameter and env as the environment parameter.

NOTE A VAR statement declares variables that are scoped to the current
execution context’s VariableEnvironment. Var variables are created when
their containing Lexical Environment is instantiated and are initialised
to UNDEFINED when created. Within the scope of any VariableEnvironemnt a
common Identifier may appear in more than one VariableDeclaration
but those declarations collective define only one variable. A variable
defined by a VariableDeclaration with an Initialiser is assigned the
value of its Initialiser’s AssignmentExpression when the
VariableDeclaration is executed, not when the variable is created.

Syntax

VariableStatement :

VAR VariableDeclarationList ;

VariableDeclarationList :

VariableDeclaration
VariableDeclarationList , VariableDeclaration

VariableDeclarationListNoIn :

VariableDeclarationNoIn
VariableDeclarationListNoIn , VariableDeclarationNoIn

VariableDeclaration :

BindingIdentifier Initialiser~opt
~BindingPattern Initialiser

VariableDeclarationNoIn :

BindingIdentifier InitialiserNoIn~opt
~BindingPattern InitialiserNoIn

The semantics of the VariableDeclarationListNoIn,
VariableDeclarationNoIn and InitialiserNoIn productions are the same
as the VariableDeclarationList, VariableDeclaration and
Initialiser productions except that the contained
VariableDeclarationListNoIn, VariableDeclarationNoIn,
InitialiserNoIn and AssignmentExpressionNoIn are used in of the
contained VariableDeclarationList, VariableDeclaration,
Initialiser and AssignmentExpression, respectively.

STATIC SEMANTICS: EARLY ERRORS

VariableDeclaration : _BindingPattern Initialiser_

-   It is a Syntax Error if the source code matching this production is
    not contained in extended code.

STATIC SEMANTICS: BOUNDNAMES

VariableStatement : VAR VariableDeclarationList ;

1.  Return BoundNames of VariableDeclarationList.

VariableDeclarationList :VariableDeclaration

1.  Return BoundNames of VariableDeclaration.

VariableDeclarationList : VariableDeclarationList ,
VariableDeclaration

1.  Let names be BoundNames of VariableDeclarationList.

2.  Append to names the elements of BoundNames of
    VariableDeclaration.

3.  Return names.

VariableDeclaration : _BindingIdentifier Initialiser_~opt~

1.  Return the BoundNames of BindingIdentifier.

VariableDeclaration : _BindingPattern Initialiser_

1.  Return the BoundNames of BindingPattern.

RUNTIME SEMANTICS: EVALUATION

VariableStatement : VAR VariableDeclarationList ;

1.  Evaluate VariableDeclarationList.

2.  Return (normal, empty, empty).

1.  

VariableDeclarationList :VariableDeclaration

1.  Evaluate VariableDeclaration.

1.  2.  3.  

VariableDeclarationList : VariableDeclarationList ,
VariableDeclaration

1.  Evaluate VariableDeclarationList.

2.  Evaluate VariableDeclaration.

1.  

VariableDeclaration : BindingIdentifier

VariableDeclaration : _BindingIdentifier Initialiser_

1.  Let rhs be the result of evaluating Initialiser.

2.  Let value be GetValue(rhs).

3.  Perform Binding Initialization for BindingIdentifier passing
    value and UNDEFINED as the arguments.

NOTE 1 The String value of a VariableDeclaration is used in the
evaluation of for-in statements (12.6.4).

NOTE 2 If a VariableDeclaration is nested within a with statement and
the Identifier in the VariableDeclaration is the same as a property
name of the binding object of the with statement’s object environment
record, then step 3 will assign value to the property instead of to the
VariableEnvironment binding of the Identifier.

-   

1.  

VariableDeclaration : _BindingPattern Initialiser_

1.  Let rhs be the result of evaluating Initialiser.

2.  Let rval be ToObject(GetValue(rhs)).

3.  Perform Binding Initialization for BindingPattern using rval as
    the obj parameter and UNDEFINED as the environment parameter.

Syntax

BindingPattern :

ObjectBindingPattern
ArrayBindingPattern

ObjectBindingPattern :

{ }
{ BindingPropertyList }
{ BindingPropertyList , }

ArrayBindingPattern :

[ Elision~opt~ BindingRestElement~opt~ ]
[ BindingElementList ]
[ BindingElementList , Elision~opt~ BindingRestElement~opt~ ]

BindingPropertyList :

BindingProperty
BindingPropertyList , BindingProperty

BindingElementList :

Elision~opt~ BindingElement
BindingElementList , Elision~opt~ BindingElement

BindingProperty :

SingleNameBinding ~
~ PropertyName : BindingElement

BindingElement :

SingleNameBinding
BindingPattern Initialiser~opt~

SingleNameBinding :

BindingIdentifier Initialiser~opt~

BindingRestElement :

… BindingIdentifier

STATIC SEMANTICS: BOUNDNAMES

BindingPattern : ObjectBindingPattern

1.  Return BoundNames of ObjectBindingPattern.

BindingPattern : ArrayBindingPattern

1.  Return BoundNames of ArrayBindingPattern.

ObjectBindingPattern: { }

1.  Return an empty List.

ObjectBindingPattern :

{ BindingPropertyList }
{ BindingPropertyList , }

1.  Return the BoundNames of BindingPropertyList.

ArrayBindingPattern : [ Elision~opt~ ]

1.  Return an empty List.

ArrayBindingPattern : [ Elision~opt~ BindingRestElement ]

1.  Return the BoundNames of BindingElementList.

ArrayBindingPattern : [ BindingElementList ]

1.  Return the BoundNames of BindingElementList.

ArrayBindingPattern : [ BindingElementList , Elision~opt~ ]

1.  Return the BoundNames of BindingElementList.

ArrayBindingPattern : [ BindingElementList , Elision~opt~
BindingRestElement ]

1.  Let names be BoundNames of BindingElementList.

2.  Append to names the elements of BoundNames of
    BindingRestElement.

3.  Return names.

BindingPropertyList : BindingProperty

1.  Return BoundNames of BindingProperty.

BindingPropertyList : BindingPropertyList , BindingProperty

1.  Let names be BoundNames of BindingPropertyList.

2.  Append to names the elements of BoundNames of BindingProperty.

3.  Return names.

BindingElementList : Elision~opt~ BindingElement

1.  Return BoundNames of BindingElement.

BindingElementList : BindingElementList , Elision~opt~
BindingElement

1.  Let names be BoundNames of BindingElementList.

2.  Append to names the elements of BoundNames of BindingElement.

3.  Return names.

BindingProperty : _SingleNameBinding _

1.  Return the BoundNames of SingleNameBinding .

BindingProperty : PropertyName : _BindingElement _

1.  Return the BoundNames of BindingElement.

SingleNameBinding : _BindingIdentifier Initialiser_~opt~

1.  Return the BoundNames of BindingIdentifier.

BindingElement : _SingleNameBinding _

1.  Return the BoundNames of SingleNameBinding .

BindingElement : _BindingPattern Initialiser_~opt~

1.  Return the BoundNames of BindingPattern.

BindingRestElement : ... BindingIdentifier

1.  Return the BoundNames of BindingIdentifier.

STATIC SEMANTICS: HASINITIALISER

BindingElement : _SingleNameBinding _

1.  Return HasInitializer of SingleNameBinding .

BindingElement : _BindingPattern _

1.  Return FALSE.

BindingElement : _BindingPattern Initialiser_

1.  Return TRUE.

SingleNameBinding : _BindingIdentifier _

1.  Return FALSE.

SingleNameBinding : _BindingIdentifier Initialiser_

1.  Return TRUE.

RUNTIME SEMANTICS: BINDING INITIALIZATION

  With parameters value and enviornment.

NOTE When UNDEFINED is passed for environment it indicates that a
PutValue operation should be used to assign the initialization value.
This is the the case for formal parameter lists of non-strict functions.
In that case the formal parameter bindings are preinitialized in order
to deal with the possibility of multiple parameters with the same name.

BindingPattern : ObjectBindingPattern

1.  If value is neither of NULL or UNDEFINED, then

    a.  Let obj be ToObject(value).

2.  Else, let obj be UNDEFINED.

3.  Perform Binding Initialization for ObjectBindingPattern using
    obj and environment as arguments.

1.  

BindingPattern : ArrayBindingPattern

1.  If value is neither of NULL or UNDEFINED, then

    a.  Let array be ToObject(value).

    b.  c.  

2.  Else,

    a.  Let array be UNDEFINED.

    b.  

3.  Perform Indexed Binding Initialization for ArrayBindingPattern
    using array, 0, and environment as arguments.

1.  

ObjectBindingPattern: { }

1.  Return.

ObjectBindingPattern :

{ BindingPropertyList }
{ BindingPropertyList , }

1.  

1.  a.  

2.  3.  Perform Binding Initialization for BindingPropertyList using
    value and environment as arguments.

1.  

1.  

1.  

1.  2.  a.  

3.  4.  

1.  

1.  a.  

2.  3.  4.  

1.  2.  3.  

1.  a.  

2.  3.  4.  5.  

1.  

BindingPropertyList : BindingProperty

1.  Perform Binding Initialization for BindingProperty using value
    and environment as arguments.

1.  2.  3.  

BindingPropertyList : BindingPropertyList , BindingProperty

1.  Perform Binding Initialization for BindingPropertyList using
    value and environment as arguments.

2.  Perform Binding Initialization for BindingProperty using value
    and environment as arguments.

BindingProperty : SingleNameBinding

1.  Let name be the string that is the only element of BoundNames of
    SingleNameBinding.

2.  Perform Keyed Binding Initialization for SingleNameBinding using
    value, environment, and name as the arguments.

BindingProperty : PropertyName : _BindingElement _

1.  Let P be the PropName of PropertyName

2.  Perform Keyed Binding Initialization for BindingElement using
    value, envirnment, and P as arguments.

RUNTIME SEMANTICS: INDEXED BINDING INITIALIZATION

  With parameters array, nextIndex, and environment.

NOTE When UNDEFINED is passed for environment it indicates that a
PutValue operation should be used to assign the initialization value.
This is the the case for formal parameter lists of non-strict functions.
In that case the formal parameter bindings are preinitialized in order
to deal with the possibility of multiple parameters with the same name.

ArrayBindingPattern : [ Elision~opt~ ]

1.  Return.

ArrayBindingPattern: [ Elision~opt~ BindingRestElement ]

1.  If Elision is present, then let nextIndex be the result of
    evaluating Elision, otherwise let nextIndex be 0.

2.  Perform Indexed Binding Initialization for BindingRestElement
    using _array, nextIndex_, and environment as arguments.

ArrayBindingPattern: [ BindingElementList ]

1.  Perform Indexed Binding Initialization for BindingElementList
    using array, nextIndex, and environment as arguments.

ArrayBindingPattern: [ BindingElementList , Elision~opt~]

1.  Perform Indexed Binding Initialization for BindingElementList
    using array, nextIndex, and environment as arguments.

ArrayBindingPattern: [ BindingElementList , Elision~opt~
BindingRestElement ]

1.  Let index be the result of performing Indexed Binding
    Initialization for BindingElementList using array, _,
    nextIndex_, and environment as arguments.

2.  If Elision is present, then let skip be the result of evaluating
    Elision, otherwise let skip be 0.

3.  Perform Indexed Binding Initialization for BindingRestElement
    using _array, index+_skip , and environment as arguments.

1.  

BindingElementList : Elision~opt~ BindingElement

1.  If Elision is present, then let skip be the result of evaluating
    Elision, otherwise let skip be 0.

2.  Perform Indexed Binding Initialization for BindingElement using
    array, nextIndex +skip , and environment as arguments.

3.  Return index_+_skip+1.

1.  2.  3.  

BindingElementList : BindingElementList , Elision~opt~
_BindingElement _

1.  Let listNext be the result of performing Indexed Binding
    Initialization for BindingElementList using _array, nextIndex_,
    and environment as arguments.

2.  If Elision is present, then let skip be the result of evaluating
    Elision, otherwise let skip be 0.

3.  Perform Indexed Binding Initialization for BindingElement using
    array, listNext_+_skip , and environment as arguments.

4.  Return listNext_+_skip+1.

5.  

1.  

1.  2.  3.  

1.  2.  

1.  

1.  2.  3.  a.  

4.  a.  i.  

    b.  i.  

5.  

1.  

1.  2.  a.  

3.  a.  i.  

    b.  i.  

4.  

1.  

BindingElement: SingleNameBinding

1.  a.  

2.  3.  Perform Keyed Binding Initialization for SingleNameBinding
    using array, environment, and ToString(nextIndex) as the
    arguments.

1.  

BindingElement: _BindingPattern Initialiser_~opt~

1.  Let P be ToString(nextIndex).

2.  3.  4.  5.  Let exists be the result of calling the
    [[HasProperty]] internal method of array with argument P.

6.  7.  8.  If exists is TRUE, then

    a.  Let v be the result of calling the [[Get]] internal method of
        array with argument P.

9.  Else

    a.  If Initialiser~opt~ is present, then

        i.  Let v be the result of evaluating Initialiser.

    b.  Else,

        i.  Let v be UNDEFINED.

10. Perform Binding Initialization for BindingPattern passing v and
    environment as arguments.

BindingRestElement : … BindingIdentifier

1.  Let A be a new array object created as if by the expression NEW
    ARRAY() where ARRAY is the standard built-in constructor with that
    name.

2.  Let lenVal be the result of calling the [[Get]] internal method of
    array with argument “LENGTH”.

3.  Let arrayLength be ToUint32(lenVal).

4.  Let n=0.

5.  Let index = nextIndex.

6.  Repeat, while index < arrayLength

    a.  Let P be ToString(index).

    b.  Let exists be the result of calling the [[HasProperty]]
          internal method of array with argument P.

    c.  If exists is TRUE, then

        i.  Let v be the result of calling the [[Get]] internal method
              of array passing P as the argument.

        ii. Call the [[DefineOwnProperty]] internal method of A with
              arguments ToString(n), Property Descriptor {[[Value]]:
              v, [[Writable]]: TRUE, [[Enumerable]]: TRUE,
              [[Configurable]]: TRUE}, and FALSE.

    d.  Let n = n+1.

    e.  Let index = index+1.

7.  Perform Binding Initialization for BindingIdentifer using array
    and environment as arguments.

RUNTIME SEMANTICS: KEYED BINDING INITIALIZATION

  With parameters obj, environment, and propertyName.

NOTE When UNDEFINED is passed for environment it indicates that a
PutValue operation should be used to assign the initialization value.
This is the the case for formal parameter lists of non-strict functions.
In that case the formal parameter bindings are preinitialized in order
to deal with the possibility of multiple parameters with the same name.

BindingElement: SingleNameBinding

1.  Perform Keyed Binding Initialization for SingleNameBinding using
    obj, environment, and propertyName as the arguments.

BindingElement: BindingPattern Initialiser~opt~

1.  Let exists be the result of calling the [[HasProperty]] internal
    method of obj with argument propertyName.

2.  If exists is TRUE, then

    a.  Let v be the result of calling the [[Get]] internal method of
        obj with argument propertyName.

3.  Else

    a.  If Initialiser~opt~ is present, then

        i.  Let v be the result of evaluating Initialiser.

    b.  Else,

        i.  Let v be UNDEFINED.

4.  Perform Binding Initialization for BindingPattern passing v and
    environment as arguments.

SingleNameBinding : _BindingIdentifier Initialiser_~opt~

1.  Let exists be the result of calling the [[HasProperty]] internal
    method of obj with argument propertyName.

2.  If exists is TRUE, then

    a.  Let v be the result of calling the [[Get]] internal method of
        obj passing propertyName as the argument.

3.  Else

    a.  If Initialiser~opt~ is present, then

        i.  Let v be the result of evaluating Initialiser.

    b.  Else,

        i.  Let v be UNDEFINED.

4.  Perform Binding Initialization for BindingIdentifer passing v
    and enviornment as arguments.

1.  

1.  

1.  2.  3.  4.  5.  a.  b.  c.  i.  ii. 

    d.  e.  

6.  

Syntax

EmptyStatement :

;

RUNTIME SEMANTICS: EVALUATION

EmptyStatement : ;

Syntax

ExpressionStatement :

[lookahead ∉ {{, FUNCTION}] Expression ;

NOTE An ExpressionStatement cannot start with an opening curly brace
because that might make it ambiguous with a Block. Also, an
ExpressionStatement cannot start with the FUNCTION keyword because
that might make it ambiguous with a FunctionDeclaration.

RUNTIME SEMANTICS: EVALUATION

ExpressionStatement : [lookahead ∉ {{, FUNCTION}] Expression;

Syntax

IfStatement :

IF ( Expression ) Statement ELSE Statement
IF ( Expression ) Statement

Each ELSE for which the choice of associated IF is ambiguous shall be
associated with the nearest possible IF that would otherwise have no
corresponding ELSE.

STATIC SEMANTICS: VARDECLAREDNAMES

IfStatement : IF ( Expression ) Statement ELSE Statement

1.  Let names be VarDeclaredNames of the first Statement.

2.  Append to names the elements of the VarDeclaredNames of the second
    Statement.

3.  Return names.

IfStatement : IF ( Expression ) _Statement _

1.  Return the VarDeclaredNames of Statement.

RUNTIME SEMANTICS: EVALUATION

IfStatement : IF ( Expression ) Statement ELSE Statement

1.  

IfStatement : IF ( Expression ) Statement

Syntax

IterationStatement :

DO Statement WHILE ( Expression );
WHILE ( Expression ) Statement
FOR (ExpressionNoIn~opt~; Expression~opt~ ; Expression~opt~ ) Statement
FOR ( VAR VariableDeclarationListNoIn; Expression~opt~ ; Expression~opt~
) Statement
FOR ( LeftHandSideExpression IN Expression ) Statement
FOR ( VAR VariableDeclarationNoIn IN Expression ) Statement

STATIC SEMANTICS: VARDECLAREDNAMES

DO Statement WHILE ( Expression );

1.  Return the VarDeclaredNames of Statement.

RUNTIME SEMANTICS: EVALUATION

DO Statement WHILE ( Expression );

STATIC SEMANTICS: VARDECLAREDNAMES

IterationStatement : WHILE ( Expression )

1.  Return the VarDeclaredNames of Statement.

RUNTIME SEMANTICS: EVALUATION

IterationStatement : WHILE ( Expression ) Statement

STATIC SEMANTICS: VARDECLAREDNAMES

FOR (ExpressionNoIn~opt~ ; Expression~opt~ ; Expression~opt~)
Statement

1.  Return the VarDeclaredNames of Statement.

IterationStatement : FOR ( VAR VariableDeclarationListNoIn ;
Expression~opt~ ; Expression~opt~ ) Statement

1.  Let names be BoundNames of VariableDeclarationListNoIn.

2.  Append to names the elements of the VarDeclaredNames of
    Statement.

3.  Return names.

RUNTIME SEMANTICS: EVALUATION

IterationStatement : FOR (ExpressionNoIn~opt~ ; Expression~opt~ ;
Expression~opt~) Statement

1.  2.  3.  

IterationStatement : FOR ( VAR VariableDeclarationListNoIn ;
Expression~opt~ ; Expression~opt~ ) Statement

STATIC SEMANTICS: VARDECLAREDNAMES

FOR ( LeftHandSideExpression IN Expression ) Statement

1.  Return the VarDeclaredNames of Statement.

IterationStatement : FOR ( VAR VariableDeclarationNoIn IN
Expression ) Statement

1.  Let names be BoundNames of VariableDeclarationNoIn.

2.  Append to names the elements of the VarDeclaredNames of
    Statement.

3.  Return names

RUNTIME SEMANTICS: EVALUATION

IterationStatement : FOR ( LeftHandSideExpression IN Expression )
Statement

1.  2.  3.  

IterationStatement : FOR ( VAR VariableDeclarationNoIn IN
Expression ) Statement

The mechanics and order of enumerating the properties (step 6.a in the
first algorithm, step 7.a in the second) is not specified. Properties of
the object being enumerated may be deleted during enumeration. If a
property that has not yet been visited during enumeration is deleted,
then it will not be visited. If new properties are added to the object
being enumerated during enumeration, the newly added properties are not
guaranteed to be visited in the active enumeration. A property name must
not be visited more than once in any enumeration.

Enumerating the properties of an object includes enumerating properties
of its prototype, and the prototype of the prototype, and so on,
recursively; but a property of a prototype is not enumerated if it is
“shadowed” because some previous object in the prototype chain has a
property with the same name. The values of [[Enumerable]] attributes are
not considered when determining if a property of a prototype object is
shadowed by a previous object on the prototype chain.

NOTE See NOTE 11.13.1.

Syntax

ContinueStatement :

CONTINUE ;
CONTINUE [no LineTerminator here] Identifier;

Semantics

A program is considered syntactically incorrect if either of the
following is true:

-   The program contains a CONTINUE statement without the optional
      Identifier, which is not nested, directly or indirectly (but not
      crossing function boundaries), within an IterationStatement.

-   The program contains a CONTINUE statement with the optional
      Identifier, where Identifier does not appear in the label set
      of an enclosing (but not crossing function boundaries)
      IterationStatement.

A ContinueStatement without an Identifier is evaluated as follows:

A ContinueStatement with the optional Identifier is evaluated as
follows:

Syntax

BreakStatement :

BREAK ;
BREAK [no LineTerminator here] Identifier ;

Semantics

A program is considered syntactically incorrect if either of the
following is true:

-   The program contains a BREAK statement without the optional
      Identifier, which is not nested, directly or indirectly (but not
      crossing function boundaries), within an IterationStatement or a
      SwitchStatement.

-   The program contains a BREAK statement with the optional
      Identifier, where Identifier does not appear in the label set
      of an enclosing (but not crossing function boundaries)
      Statement.

A BreakStatement without an Identifier is evaluated as follows:

A BreakStatement with an Identifier is evaluated as follows:

Syntax

ReturnStatement :

RETURN ;
RETURN [no LineTerminator here] Expression ;

Semantics

An ECMAScript program is considered syntactically incorrect if it
contains a RETURN statement that is not within a FunctionBody. A
RETURN statement causes a function to cease execution and return a value
to the caller. If Expression is omitted, the return value is
UNDEFINED. Otherwise, the return value is the value of Expression.

A ReturnStatement is evaluated as follows:

Syntax

WithStatement :

WITH ( Expression ) Statement

NOTE The WITH statement adds an object environment record for a computed
object to the lexical environment of the current execution context. It
then executes a statement using this augmented lexical environment.
Finally, it restores the original lexical environment.

Semantics

The static semantics of the production WithStatement : WITH (
Expression ) Statement are:

-   It is a Syntax Error if the code that matches this production is
    contained in static code.

The VarDeclaredNames of the production WithStatement : WITH (
Expression ) Statement is determined as follows:

1.  Return the VarDeclaredNames of Statement.

The production WithStatement : WITH ( Expression ) Statement is
evaluated as follows:

NOTE No matter how control leaves the embedded Statement, whether
normally or by some form of abrupt completion or exception, the
LexicalEnvironment is always restored to its former state.

Syntax

SwitchStatement :

SWITCH ( Expression ) CaseBlock

CaseBlock :

{ CaseClauses~opt~ }
{ CaseClauses~opt~ DefaultClause CaseClauses~opt~ }

CaseClauses :

CaseClause
CaseClauses CaseClause

CaseClause :

CASE Expression : StatementList~opt~

DefaultClause :

DEFAULT : StatementList~opt~

STATIC SEMANTICS: EARLY ERRORS

CaseBlock : { CaseClauses } are:

-   It is a Syntax Error if the LexicallyDeclaredNames of CaseClauses
    contains any duplicate entires.

-   It is a Syntax Error if any element of the LexicallyDeclaredNames of
    CaseClauses also occurs in the VarDeclaredNames of CaseClauses.

CaseClause : CASE Expression : StatementList

-   It is a Syntax Error if StatementList includes a
    StatementListItem : FunctionDeclaration production and the
    source code matching this CaseClause production is not contained
    in extended code.

STATIC SEMANTICS: LEXICALDECLARATIONS

CaseBlock : { }

1.  Return a new empty List.

CaseBlock : { CaseClauses }

1.  Return the LexicalDeclarations of CaseClauses.

CaseBlock : { CaseClauses~opt~ _DefaultClause CaseClauses_~opt~ }

1.  If the first CaseClauses is present, let declarations be the
    LexicalDeclarations of the first CaseClauses.

2.  Else let declarations be a new empty List.

3.  Append to declarations the elements of the LexicallyDeclaredNames
    of the DefaultClause.

4.  If the second CaseClauses is not present, return names.

5.  Else return the result of append to names the elements of the the
    LexicallyDeclaredNames of the second CaseClauses.

CaseClauses : CaseClause

1.  Return the LexicalDeclarations of CaseClause.

CaseClauses : _CaseClauses CaseClause_

1.  Let declarations be LexicalDeclarations of CaseClauses.

2.  Append to names the elements of the LexicalDeclarations of
    CaseClause.

3.  Return declarations.

CaseClause : CASE Expression : StatementList~opt~

1.  If the StatementList is present, return the LexicalDeclarations of
    StatementList.

2.  Else return a new empty List.

DefaultClause : DEFAULT : StatementList~opt~

1.  If the StatementList is present, return the LexicalDeclarations of
    StatementList.

2.  Else return a new empty List.

STATIC SEMANTICS: LEXICALLYDECLAREDNAMES

CaseBlock : { }

1.  Return a new empty List.

CaseBlock : { CaseClauses }

1.  Return the LexicallyDeclaredNames of CaseClauses.

CaseBlock : { CaseClauses~opt~ _DefaultClause CaseClauses_~opt~ }

1.  If the first CaseClauses is present, let names be the
    LexicallyDeclaredNames of the first CaseClauses.

2.  Else let names be a new empty List.

3.  Append to names the elements of the LexicallyDeclaredNames of the
    DefaultClause.

4.  If the second CaseClauses is not present, return names.

5.  Else return the result of append to names the elements of the the
    LexicallyDeclaredNames of the second CaseClauses.

CaseClauses : CaseClause

1.  Return the LexicallyDeclaredNames of CaseClause.

CaseClauses : _CaseClauses CaseClause_

1.  Let names be LexicallyDeclaredNames of CaseClauses.

2.  Append to names the elements of the LexicallyDeclaredNames of
    CaseClause.

3.  Return names.

CaseClause : CASE Expression : StatementList~opt~

1.  If the StatementList is present, return the LexicallyDeclaredNames
    of StatementList.

2.  Else return a new empty List.

DefaultClause : DEFAULT : StatementList~opt~

1.  If the StatementList is present, return the LexicallyDeclaredNames
    of StatementList.

2.  Else return a new empty List.

STATIC SEMANTICS: VARDECLAREDNAMES

SwitchStatement : SWITCH ( Expression ) CaseBlock

1.  Return the VarDeclaredNames of CaseBlock.

CaseBlock : { }

1.  Return a new empty List.

CaseBlock : { CaseClauses }

1.  Return the VarDeclaredNames of CaseClauses.

CaseBlock : { CaseClauses~opt~ _DefaultClause CaseClauses_~opt~ }

1.  If the first CaseClauses is present, let names be the
    VarDeclaredNames of the first CaseClauses.

2.  Else let names be a new empty List.

3.  Append to names the elements of the VarDeclaredNames of the
    DefaultClause.

4.  If the second CaseClauses is not present, return names.

5.  Else return the result of append to names the elements of the the
    VarDeclaredNames of the second CaseClauses.

CaseClauses : CaseClause

1.  Return the VarDeclaredNames of CaseClause.

CaseClauses : _CaseClauses CaseClause_

1.  Let names be VarDeclaredNames of CaseClauses.

2.  Append to names the elements of the VarDeclaredNames of
    CaseClause.

3.  Return names.

CaseClause : CASE Expression : StatementList~opt~

1.  If the StatementList is present, return the VarDeclaredNames of
    StatementList.

2.  Else return a new empty List.

DefaultClause : DEFAULT : StatementList~opt~

1.  If the StatementList is present, return the VarDeclaredNames of
    StatementList.

2.  Else return a new empty List.

RUNTIME SEMANTICS: EVALUATION

The production SwitchStatement : SWITCH ( Expression ) CaseBlock
is evaluated as follows:

NOTE No matter how control leaves the SwitchStatement the
LexicalEnvironment is always restored to its former state.

The production CaseBlock : { CaseClauses~opt~ } is given an input
parameter, input, and is evaluated as follows:

The production CaseBlock : { CaseClauses~opt~ _DefaultClause
CaseClauses_~opt~ } is given an input parameter, input, and is
evaluated as follows:

The production CaseClause : CASE Expression : StatementList~opt~
is evaluated as follows:

NOTE Evaluating CaseClause does not execute the associated
StatementList. It simply evaluates the Expression and returns the
value, which the CaseBlock algorithm uses to determine which
StatementList to start executing.

Syntax

LabelledStatement :

Identifier : Statement

Semantics

NOTE A Statement may be prefixed by a label. Labelled statements are
only used in conjunction with labelled BREAK and CONTINUE statements.
ECMAScript has no GOTO statement.

An ECMAScript program is considered syntactically incorrect if it
contains a LabelledStatement that is enclosed by a LabelledStatement
with the same Identifier as label. This does not apply to labels
appearing within the body of a FunctionDeclaration that is nested,
directly or indirectly, within a labelled statement.

The VarDeclaredNames of the production DefaultCase : Identifier :
Statement is determined as follows:

1.  Return the VarDeclaredNames of Statement.

The production Identifier : Statement is evaluated by adding
Identifier to the label set of Statement and then evaluating
Statement. If the LabelledStatement itself has a non-empty label
set, these labels are also added to the label set of Statement before
evaluating it. If the result of evaluating Statement is (BREAK, V,
L) where L is equal to Identifier, the production results in
(NORMAL, V, EMPTY).

Prior to the evaluation of a LabelledStatement, the contained
Statement is regarded as possessing an empty label set, unless it is
an IterationStatement or a SwitchStatement, in which case it is
regarded as possessing a label set consisting of the single element,
EMPTY.

Syntax

ThrowStatement :

THROW [no LineTerminator here] Expression ;

Semantics

The production ThrowStatement : THROW [no LineTerminator here]
Expression ; is evaluated as follows:

Syntax

TryStatement :

TRY Block Catch~
~TRY Block Finally~
~TRY Block Catch Finally

Catch :

CATCH ( CatchParameter ) Block

Finally :

FINALLY Block

CatchParameter :

BindingIdentifier~
~BindingPattern

The TRY statement encloses a block of code in which an exceptional
condition can occur, such as a runtime error or a THROW statement. The
CATCH clause provides the exception-handling code. When a catch clause
catches an exception, its Identifier is bound to that exception.

STATIC SEMANTICS: EARLY ERRORS

Catch : CATCH ( CatchParameter ) Block

-   It is a Syntax Error if any element of the BoundNames of
    CatchParameter also occurs in the LexicallyDeclaredNames of
    Block.

-   It is a Syntax Error if the code that matches this production is
    contained in extended code and any element of the BoundNames of
    CatchParameter also occurs in the VarDeclaredNames of Block.

STATIC SEMANTICS: BOUNDNAMES

CatchParameter: BindingIdentifier

1.  Return the BoundNames of BindingIdentifier.

CatchParameter: BindingPattern

1.  Return the BoundNames of BindingPattern.

STATIC SEMANTICS: VARDECLAREDNAMES

TryStatement : TRY Block Catch

1.  Let names be VarDeclaredNames of Block.

2.  Append to names the elements of the VarDeclaredNames of Catch.

3.  Return names.

TryStatement : TRY Block Finally

1.  Let names be VarDeclaredNames of Block.

2.  Append to names the elements of the VarDeclaredNames of Finally.

3.  Return names.

TryStatement : TRY Block Catch Finally

1.  Let names be VarDeclaredNames of Block.

2.  Append to names the elements of the VarDeclaredNames of Catch.

3.  Append to names the elements of the VarDeclaredNames of Finally.

4.  Return names.

Catch : CATCH ( CatchParameter ) Block

1.  Return the VarDeclaredNames of Block.

Finally : FINALLY Block

1.  Return the VarDeclaredNames of Block.

RUNTIME SEMANTICS: BINDING INITIALIZATION

  With arguments value and enviornment.

NOTE UNDEFINED is passed for environment to indicate that a PutValue
operation should be used to assign the initialization value. This is the
the case for VAR statements formal parameter lists of non-strict
functions. In those cases a lexical binding is hosted and preinitialized
prior to evaluation of its initializer.

CatchParameter: BindingIdentifier

1.  Perform Binding Initialization for BindingIdentifier passing
    value and enviornment as the arguments.

CatchParameter: BindingPattern

1.  Let exceptionObj be ToObject(value).

2.  Perform Binding Initialization for BindingPattern passing
    exceptionObj and enviornment as the arguments.

RUNTIME SEMANTICS: CATCH CLAUSE EVALUATION

with parameter thrownValue

Catch : CATCH ( CatchParameter ) Block

NOTE No matter how control leaves the Block the LexicalEnvironment is
always restored to its former state.

RUNTIME SEMANTICS: EVALUATION

TryStatement : TRY Block Catch

TryStatement : TRY Block Finally

TryStatement : TRY Block Catch Finally

1.  

Finally : FINALLY Block

1.  

1.  2.  

1.  

1.  2.  3.  4.  

Syntax

DebuggerStatement :

DEBUGGER ;

Semantics

NOTE Evaluating the DebuggerStatement production may allow an
implementation to cause a breakpoint when run under a debugger. If a
debugger is not present or active this statement has no observable
effect.

RUNTIME SEMANTICS: EVALUATION

The production DebuggerStatement : DEBUGGER ; is evaluated as follows:

Syntax

FunctionDeclaration :

FUNCTION BindingIdentifier ( FormalParameterList ) { FunctionBody }

FunctionExpression :

FUNCTION BindingIdentifier~opt~ ( FormalParameterList ) { FunctionBody }

FormalParameterList :

[empty]
FunctionRestParameter
FormalsList
FormalsList, FunctionRestParameter

FormalsList :

FormalParameter
FormalsList , FormalParameter

FunctionRestParameter :

... BindingIdentifier

FormalParameter :

BindingElement

FunctionBody :

StatementList~opt~

STATIC SEMANTICS: EARLY ERRORS

FunctionDeclaration : FUNCTION BindingIdentifier (
FormalParameterList ) { FunctionBody }
and
FunctionExpression : FUNCTION BindingIdentifier~opt~ (
FormalParameterList ) { FunctionBody }

-   It is a Syntax Error if the source code matching this production is
    extended code and the BoundNames of BindingIdentifier also occurs
    in the VarDeclaredNames of FunctionBody.

-   It is a Syntax Error if the source code matching this production is
    extended code and the BoundNames of BindingIdentifier also occurs
    in the LexicallyDeclaredNames of FunctionBody.

-   It is a Syntax Error if the source code matching this production is
    extended code and any element of the LexicallyDeclaredNames of
    FormalParameterList also occurs in the VarDeclaredNames of
    FunctionBody.

-   It is a Syntax Error if the source code matching this production is
    extended code and any element of the BoundNames of
    FormalParameterList also occurs in the LexicallyDeclaredNames of
    FunctionBody.

FunctionBody : _StatementList _

-   It is a Syntax Error if the source code matching this production is
    extended code and the LexicallyDeclaredNamesBoundNames of
    StatementList contains any duplicate entires.

-   It is a Syntax Error if the source code matching this production is
    extended code and any element of the LexicallyDeclaredNames of
    StatementList also occurs in the VarDeclaredNames of
    StatementList.

FormalParameterList : FormalsList, FunctionRestParameter

-   It is a Syntax Error if BoundNames of FormalsList contains the
    String Value of Identifier.

FormalsList : FormalsList, FormalParameter

-   It is a Syntax Error if the source code matching this production is
    strict code and BoundNames of FormalsList contains an element
    which is also contained in BoundNames of FormalParameter.

FunctionRestParameter : ... BindingIdentifier

-   It is a Syntax Error if the source code parsed with this production
    is not extended code.

-   

FormalParameter : BindingElement

-   It is a Syntax Error if the derivation of BindingElement is
    _BindingIdentifier Initialiser_ and the source code matching this
    production is not extended code.

-   It is a Syntax Error if the derivation of BindingElement is
    _BindingPattern Initialiser_~opt~ and the source code parsed with
    this production is not extended code.

-   It is a Syntax Error if BoundNames of BindingElement contains any
    duplicate elements.

STATIC SEMANTICS: BOUNDNAMES

FunctionDeclaration : FUNCTION BindingIdentifier (
FormalParameterList ) { FunctionBody }

1.  Return the BoundNames of BindingIdentifier.

FormalParameterList : [empty]

1.  Return an empty List.

FormalParameterList : FunctionRestParameter

1.  Return the BoundNames of FunctionRestParameter.

FormalParameterList : FormalsList

1.  Return the BoundNames of FormalsList.

FormalParameterList : FormalsList , FunctionRestParameter

1.  Let names be BoundNames of FormalsList.

2.  Append to names the BoundNames of FunctionRestParameter.

3.  Return names.

FormalsList : _FormalsList ,_ FormalParameter

1.  Let names be BoundNames of FormalsList.

2.  Append to names the elements of BoundNames of FormalParameter.

3.  Return names.

FormalParameterList : ... BindingIdentifier

1.  Return the BoundNames of BindingIdentifier.

FormalParameter : BindingElement

1.  Return the BoundNames of BindingElement .

STATIC SEMANTICS: EXPECTEDARGUMENTCOUNT

FormalParameterList :

[empty]
FunctionRestParameter

1.  Return 0.

FormalParameterList :

FormalsList
FormalsList , FunctionRestParameter

1.  Return the ExpectedArgumentCount of FormalsList.

NOTE The ExpectedArgumentCount of a FormalParameterList is the number
of FormalParameters to the left of either the rest parameter or the
first FormalParameter with an Initialiser.

FormalsList : FormalParameter

1.  If HasInitialiser of FormalParameter is FALSE return 0

2.  Return 1.

FormalsList : FormalsList, FormalParameter

1.  Let count be the ExpectedArgumentCount of FormalsList.

2.  If HasInitialiser of FormalsList is TRUE or HasInitialiser of
    FormalParameter is TRUE, then return count.

3.  Return count+1.

STATIC SEMANTICS: HASINITIALISER

FormalsList : FormalParameter

1.  Return HasInitialiser of FormalParameter.

FormalsList : _FormalsList ,_ FormalParameter

1.  If HasInitialiser of FormalsList is TRUE, then return TRUE.

2.  Return HasInitialiser of FormalParameter.

FormalParameter : _BindingElement _

1.  Return HasInitialiser of BindingElement.

STATIC SEMANTICS: LEXICALLYDECLAREDNAMES

FunctionBody : [empty]

1.  Return an empty List.

FunctionBody : StatementList

1.  Return the LexicllyDeclaredNames of StatementList.

STATIC SEMANTICS: VARDECLAREDNAMES

FunctionDeclaration : FUNCTION BindingIdentifier (
FormalParameterList ) { FunctionBody }

1.  Return an empty List.

FunctionBody : [empty]

1.  Return an empty List.

FunctionBody : StatementList

1.  Return the VarDeclaredNames of StatementList.

RUNTIME SEMANTICS: BINDING INITIALIZATION

  With parameters value and enviornment and optional parameter
  index.

NOTE When UNDEFINED is passed for environment it indicates that a
PutValue operation should be used to assign the initialization value.
This is the the case for formal parameter lists of non-strict functions.
In that case the formal parameter bindings are preinitialized in order
to deal with the possibility of multiple parameters with the same name.

FormalParameterList : [empty]

1.  Return.

FormalParameterList : FunctionRestParameter

1.  Perform Indexed Binding Initialization for FunctionRestParameter
    using value, lenValue, 0, and environment as the arguments.

2.  Return.

FormalParameterList : FormalsList

1.  Asset: value is a new created arguments object and hence it has a
    valid integer valued "length" property.

2.  Let lenValue be the result of calling the [[Get]] internal method
    of value with argument "length".

3.  Perform Indexed Binding Initialization for FormalsList using
    value, lenValue, 0, and environment as the arguments.

4.  Return.

FormalParameterList : FormalsList , FunctionRestParameter

1.  Let restIndex be the result of performing Indexed Binding
    Initialization for FormalsList using value, lenValue, 0, and
    environment as the arguments.

2.  Perform Indexed Binding Initialization for FunctionRestParameter
    using value, lenValue, restIndex, and environment as the
    arguments.

3.  Return.

RUNTIME SEMANTICS: INDEXED BINDING INITIALIZATION

  With parameters array, _arrayLength, nextIndex,_ and environment.

FormalList : FormalParameter

1.  Perform Binding Initialization for FormalParameter using value,
    env, and index as the arguments.

2.  Return index + 1.

FormalList : FormalsList , FormalParameter

1.  Let lastIndex be the result of performing Indexed Binding
    Initialization for FormalsList using value, lenValue,
    nextIndex, and environment as the arguments.

2.  Perform Indexed Binding Initialization for FormalParameter using
    value, lenValue, lastIndex, and environment as the
    arguments.

3.  Return lastIndex + 1.

FunctionRestParameter : ... BindingIdentifier

1.  Let A be a new array object created as if by the expression NEW
    ARRAY() where ARRAY is the standard built-in constructor with that
    name.

2.  Let n=0;

3.  Repeat, while nextIndex < arrayLength

    a.  Let P be ToString(nextIndex).

    b.  Assert: array is a well formed arguments object, hence it must
          have a property _P_.

    c.  Let v be the result of calling the [[Get]] internal method of
        array passing P as the argument.

    d.  Call the [[DefineOwnProperty]] internal method of A with
          arguments ToString(n), Property Descriptor {[[Value]]: v,
          [[Writable]]: TRUE, [[Enumerable]]: TRUE, [[Configurable]]:
          TRUE}, and FALSE.

    e.  Let n = n+1.

    f.  Let nextIndex = nextIndex +1.

4.  Perform Binding Initialization for BindingIdentifer using A and
    environment as arguments.

FormalParameter : BindingElement

1.  Perform Indexed Binding Initialization for BindingElement using
    array, arrayLength, nextIndex, and environment as the
    arguments.

RUNTIME SEMANTICS: EVALUATION

FunctionDeclaration : FUNCTION BindingIdentifier (
FormalParameterList ) { FunctionBody }

FunctionExpression : FUNCTION ( FormalParameterList ) {
FunctionBody }

FunctionExpression : FUNCTION BindingIdentifier (
FormalParameterList ) { FunctionBody }

NOTE The BindingIdentifier in a FunctionExpression can be referenced
from inside the FunctionExpression's FunctionBody to allow the
function to call itself recursively. However, unlike in a
FunctionDeclaration, the BindingIdentifier in a FunctionExpression
cannot be referenced from and does not affect the scope enclosing the
FunctionExpression.

FunctionBody : StatementList~opt~

A Function object is constructed as follows given an parameter list
specified by FormalParameterList, a body specified by FunctionBody,
a Lexical Environment specified by Scope, a Boolean flag Strict, and
optionally, an object homeObject and a string methodName:

NOTE A PROTOTYPE property is automatically created for every function,
to allow for the possibility that the function will be used as a
constructor.

When the [[Call]] internal method for a Function object F is called
with a this value and a list of arguments, the following steps are
taken:

When the [[Construct]] internal method for a Function object F is
called with a possibly empty list of arguments, the following steps are
taken:

The [[ThrowTypeError]] object is a unique function object that is
defined once as follows:

Syntax

Program :

SourceElements~opt~

SourceElements :

SourceElement
SourceElements SourceElement

SourceElement :

Statement
FunctionDeclaration

Semantics

The production Program : SourceElements~opt~ is evaluated as
follows:

NOTE The processes for initiating the evaluation of a Program and for
dealing with the result of such an evaluation are defined by an
ECMAScript implementation and not by this specification.

The production SourceElements : SourceElements SourceElement is
evaluated as follows:

The production SourceElement : Statement is evaluated as follows:

The production SourceElement : FunctionDeclaration is evaluated as
follows:

A Directive Prologue is the longest sequence of ExpressionStatement
productions occurring as the initial SourceElement productions of a
Program or as the initial StatementListItem productions of a
FunctionBody and where each ExpressionStatement in the sequence
consists entirely of a StringLiteral token followed a semicolon. The
semicolon may appear explicitly or may be inserted by automatic
semicolon insertion. A Directive Prologue may be an empty sequence.

A Use Strict Directive is an ExpressionStatement in a Directive
Prologue whose StringLiteral is either the exact character sequences
"USE STRICT" or 'USE STRICT'. A Use Strict Directive may not contain an
EscapeSequence or LineContinuation.

A Directive Prologue may contain more than one Use Strict Directive.
However, an implementation may issue a warning if this occurs.

NOTE The ExpressionStatement productions of a Directive Prologue are
evaluated normally during evaluation of the containing production.
Implementations may define implementation specific meanings for
ExpressionStatement productions which are not a Use Strict Directive
and which occur in a Directive Prologue. If an appropriate notification
mechanism exists, an implementation should issue a warning if it
encounters in a Directive Prologue an ExpressionStatement that is not
a Use Strict Directive or which does not have a meaning defined by the
implementation.

There are certain built-in objects available whenever an ECMAScript
program begins execution. One, the global object, is part of the lexical
environment of the executing program. Others are accessible as initial
properties of the global object.

Unless specified otherwise, a built-in object has the [[NativeBrand]]
internal property with value NativeFunction if that built-in object has
a [[Call]] internal property. Unless specified otherwise, the
[[Extensible]] internal property of a built-in object initially has the
value TRUE.

Many built-in objects are functions: they can be invoked with arguments.
Some of them furthermore are constructors: they are functions intended
for use with the NEW operator. For each built-in function, this
specification describes the arguments required by that function and
properties of the Function object. For each built-in constructor, this
specification furthermore describes properties of the prototype object
of that constructor and properties of specific object instances returned
by a NEW expression that invokes that constructor.

Unless otherwise specified in the description of a particular function,
if a function or constructor described in this clause is given fewer
arguments than the function is specified to require, the function or
constructor shall behave exactly as if it had been given sufficient
additional arguments, each such argument being the UNDEFINED value.

Unless otherwise specified in the description of a particular function,
if a function or constructor described in this clause is given more
arguments than the function is specified to allow, the extra arguments
are evaluated by the call and then ignored by the function. However, an
implementation may define implementation specific behaviour relating to
such arguments as long as the behaviour is not the throwing of a
TYPEERROR exception that is predicated simply on the presence of an
extra argument.

NOTE Implementations that add additional capabilities to the set of
built-in functions are encouraged to do so by adding new functions
rather than adding new parameters to existing functions.

Every built-in function and every built-in constructor has the Function
prototype object, which is the initial value of the expression
FUNCTION.PROTOTYPE (15.3.4), as the value of its [[Prototype]] internal
property.

Unless otherwise specified every built-in prototype object has the
Object prototype object, which is the initial value of the expression
OBJECT.PROTOTYPE (15.2.4), as the value of its [[Prototype]] internal
property, except the Object prototype object itself.

None of the built-in functions described in this clause that are not
constructors shall implement the [[Construct]] internal method unless
otherwise specified in the description of a particular function. The
behavior specified in this clause for each built-in function is the
specification of the [[Call]] internal method behavior for that
function. None of the built-in functions described in this clause shall
have a PROTOTYPE property unless otherwise specified in the description
of a particular function.

This clause generally describes distinct behaviours for when a
constructor is “called as a function” and for when it is “called as part
of a NEW expression”. The “called as a function” behaviour corresponds
to the invocation of the constructor’s [[Call]] internal method and the
“called as part of a new expression” behaviour corresponds to the
invocation of the constructor’s [[Construct]] internal method.

Every built-in Function object described in this clause—whether as a
constructor, an ordinary function, or both—has a LENGTH property whose
value is an integer. Unless otherwise specified, this value is equal to
the largest number of named arguments shown in the subclause headings
for the function description, including optional parameters.

NOTE For example, the Function object that is the initial value of the
slice property of the String prototype object is described under the
subclause heading “String.prototype.slice (start, end)” which shows the
two named arguments start and end; therefore the value of the length
property of that Function object is 2.

In every case, the LENGTH property of a built-in Function object
described in this clause has the attributes { [[Writable]]: FALSE,
[[Enumerable]]: FALSE, [[Configurable]]: FALSE }. Every other property
described in this clause has the attributes { [[Writable]]: TRUE,
[[Enumerable]]: FALSE, [[Configurable]]: TRUE } unless otherwise
specified.

The unique _global object_ is created before control enters any
execution context.

Unless otherwise specified, the standard built-in properties of the
global object have attributes {[[Writable]]: TRUE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE}.

The global object does not have a [[Construct]] internal property; it is
not possible to use the global object as a constructor with the NEW
operator.

The global object does not have a [[Call]] internal property; it is not
possible to invoke the global object as a function.

The value of the [[Prototype]] internal property of the global object is
implementation-dependent.

In addition to the properties defined in this specification the global
object may have additional host defined properties. This may include a
property whose value is the global object itself; for example, in the
HTML document object model the WINDOW property of the global object is
the global object itself.

The value of NAN is NAN (see 8.5). This property has the attributes {
[[Writable]]: FALSE, [[Enumerable]]: FALSE, [[Configurable]]: FALSE }.

The value of INFINITY is +∞ (see 8.5). This property has the attributes
{ [[Writable]]: FALSE, [[Enumerable]]: FALSE, [[Configurable]]: FALSE }.

The value of UNDEFINED is UNDEFINED (see 8.1). This property has the
attributes { [[Writable]]: FALSE, [[Enumerable]]: FALSE,
[[Configurable]]: FALSE }.

When the EVAL function is called with one argument x, the following
steps are taken:

A direct call to the eval function is one that is expressed as a
CallExpression that meets the following two conditions:

The Reference that is the result of evaluating the MemberExpression in
the CallExpression has an environment record as its base value and its
reference name is "EVAL".

The result of calling the abstract operation GetValue with that
Reference as the argument is the standard built-in function defined in
15.1.2.1.

The PARSEINT function produces an integer value dictated by
interpretation of the contents of the string argument according to the
specified radix. Leading white space in string is ignored. If
radix is UNDEFINED or 0, it is assumed to be 10 except when the number
begins with the character pairs 0X or 0X, in which case a radix of 16 is
assumed. If radix is 16, the number may also optionally begin with the
character pairs 0X or 0X.

When the PARSEINT function is called, the following steps are taken:

NOTE PARSEINT may interpret only a leading portion of string as an
integer value; it ignores any characters that cannot be interpreted as
part of the notation of an integer, and no indication is given that any
such characters were ignored.

The PARSEFLOAT function produces a Number value dictated by
interpretation of the contents of the string argument as a decimal
literal.

When the PARSEFLOAT function is called, the following steps are taken:

NOTE PARSEFLOAT may interpret only a leading portion of string as a
Number value; it ignores any characters that cannot be interpreted as
part of the notation of an decimal literal, and no indication is given
that any such characters were ignored.

Returns TRUE if the argument coerces to NAN, and otherwise returns
FALSE.

NOTE A reliable way for ECMAScript code to test if a value X is a NAN is
an expression of the form X !== X. The result will be TRUE if and only
if X is a NAN.

Returns FALSE if the argument coerces to NAN, +∞, or −∞, and otherwise
returns TRUE.

Uniform Resource Identifiers, or URIs, are Strings that identify
resources (e.g. web pages or files) and transport protocols by which to
access them (e.g. HTTP or FTP) on the Internet. The ECMAScript language
itself does not provide any support for using URIs except for functions
that encode and decode URIs as described in 15.1.3.1, 15.1.3.2, 15.1.3.3
and 15.1.3.4.

NOTE Many implementations of ECMAScript provide additional functions and
methods that manipulate web pages; these functions are beyond the scope
of this standard.

A URI is composed of a sequence of components separated by component
separators. The general form is:

Scheme : First / Second ; Third ? Fourth

where the italicised names represent components and “:”, “/”, “;” and
“?” are reserved characters used as separators. The ENCODEURI and
DECODEURI functions are intended to work with complete URIs; they assume
that any reserved characters in the URI are intended to have special
meaning and so are not encoded. The ENCODEURICOMPONENT and
DECODEURICOMPONENT functions are intended to work with the individual
component parts of a URI; they assume that any reserved characters
represent text and so must be encoded so that they are not interpreted
as reserved characters when the component is part of a complete URI.

The following lexical grammar specifies the form of encoded URIs.

Syntax

uri :::

uriCharacters~opt~

uriCharacters :::

uriCharacter uriCharacters~opt~

uriCharacter :::

uriReserved
uriUnescaped
uriEscaped

uriReserved ::: ONE OF

; / ? : @ & = + $ ,

uriUnescaped :::

uriAlpha
DecimalDigit
uriMark

uriEscaped :::

% HexDigit HexDigit

uriAlpha ::: ONE OF

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

uriMark ::: ONE OF

- _ . ! ~ * ' ( )

NOTE The above syntax is based upon RFC 2396 and does not reflect
changes introduced by the more recent RFC 3986.

When a character to be included in a URI is not listed above or is not
intended to have the special meaning sometimes given to the reserved
characters, that character must be encoded. The character is transformed
into its UTF-8 encoding, with surrogate pairs first converted from
UTF-16 to the corresponding code point value. (Note that for code units
in the range [0,127] this results in a single octet with the same
value.) The resulting sequence of octets is then transformed into a
String with each octet represented by an escape sequence of the form
“%xx”.

The encoding and escaping process is described by the abstract operation
Encode taking two String arguments string and unescapedSet.

The unescaping and decoding process is described by the abstract
operation Decode taking two String arguments string and reservedSet.

NOTE This syntax of Uniform Resource Identifiers is based upon RFC 2396
and does not reflect the more recent RFC 3986 which replaces RFC 2396. A
formal description and implementation of UTF-8 is given in RFC 3629.

In UTF-8, characters are encoded using sequences of 1 to 6 octets. The
only octet of a "sequence" of one has the higher-order bit set to 0, the
remaining 7 bits being used to encode the character value. In a sequence
of n octets, n>1, the initial octet has the n higher-order bits set to
1, followed by a bit set to 0. The remaining bits of that octet contain
bits from the value of the character to be encoded. The following octets
all have the higher-order bit set to 1 and the following bit set to 0,
leaving 6 bits in each to contain bits from the character to be encoded.
The possible UTF-8 encodings of ECMAScript characters are specified in
Table 22.

Table 22 — UTF-8 Encodings

  ------------------- --------------------- --------------- --------------- --------------- ---------------
  _CODE UNIT VALUE_   REPRESENTATION      _1^ST^ OCTET_   _2^ND^ OCTET_   _3^RD^ OCTET_   _4^TH^ OCTET_

  0X0000 - 0X007F     00000000 0zzzzzzz   0zzzzzzz                                      

  0X0080 - 0X07FF     00000_yyy yyzzzzzz_   110yyyyy      10zzzzzz                      

  0X0800 - 0XD7FF     _xxxxyyyy yyzzzzzz_   1110xxxx      10yyyyyy      10zzzzzz      

  0XD800 - 0XDBFF     110110_vv vvwwwwxx_   11110uuu      10uuwwww      10xxyyyy      10zzzzzz
                                                                                            
  _followed by_       _followed by_                                                         
                                                                                            
  0XDC00 – 0XDFFF     110111_yy yyzzzzzz_                                                   

  0XD800 - 0XDBFF     causes URIError                                                     
                                                                                            
  _not followed by_                                                                         
                                                                                            
  0XDC00 – 0XDFFF                                                                           

  0XDC00 – 0XDFFF     causes URIError                                                     

  0XE000 - 0XFFFF     _xxxxyyyy yyzzzzzz_   1110xxxx      10yyyyyy      10zzzzzz      
  ------------------- --------------------- --------------- --------------- --------------- ---------------

Where

uuuuu = vvvv + 1

to account for the addition of 0x10000 as in Surrogates, section 3.7, of
the Unicode Standard.

The range of code unit values 0xD800-0xDFFF is used to encode surrogate
pairs; the above transformation combines a UTF-16 surrogate pair into a
UTF-32 representation and encodes the resulting 21-bit value in UTF-8.
Decoding reconstructs the surrogate pair.

RFC 3629 prohibits the decoding of invalid UTF-8 octet sequences. For
example, the invalid sequence C0 80 must not decode into the character
U+0000. Implementations of the Decode algorithm are required to throw a
URIERROR when encountering such invalid sequences.

The DECODEURI function computes a new version of a URI in which each
escape sequence and UTF-8 encoding of the sort that might be introduced
by the ENCODEURI function is replaced with the character that it
represents. Escape sequences that could not have been introduced by
ENCODEURI are not replaced.

When the DECODEURI function is called with one argument encodedURI,
the following steps are taken:

NOTE The character “#” is not decoded from escape sequences even though
it is not a reserved URI character.

The DECODEURICOMPONENT function computes a new version of a URI in which
each escape sequence and UTF-8 encoding of the sort that might be
introduced by the ENCODEURICOMPONENT function is replaced with the
character that it represents.

When the DECODEURICOMPONENT function is called with one argument
encodedURIComponent, the following steps are taken:

The ENCODEURI function computes a new version of a URI in which each
instance of certain characters is replaced by one, two, three, or four
escape sequences representing the UTF-8 encoding of the character.

When the ENCODEURI function is called with one argument uri, the
following steps are taken:

NOTE The character “#” is not encoded to an escape sequence even though
it is not a reserved or unescaped URI character.

The ENCODEURICOMPONENT function computes a new version of a URI in which
each instance of certain characters is replaced by one, two, three, or
four escape sequences representing the UTF-8 encoding of the character.

When the ENCODEURICOMPONENT function is called with one argument
uriComponent, the following steps are taken:

See 15.2.1 and 15.2.2.

See 15.3.1 and 15.3.2.

See 15.4.1 and 15.4.2.

See 15.5.1 and 15.5.2.

See 15.6.1 and 15.6.2.

See 15.7.1 and 15.7.2.

See 15.9.2.

See 15.10.3 and 15.10.4.

See 15.11.1 and 15.11.2.

See 15.11.6.1.

See 15.11.6.2.

See 15.11.6.3.

See 15.11.6.4.

See 15.11.6.5.

See 15.11.6.6.

See 15.8.

See 15.12.

When OBJECT is called as a function rather than as a constructor, it
performs a type conversion.

When the OBJECT function is called with no arguments or with one
argument value, the following steps are taken:

When OBJECT is called as part of a NEW expression, it is a constructor
that may create an object.

When the OBJECT constructor is called with no arguments or with one
argument value, the following steps are taken:

The value of the [[Prototype]] internal property of the Object
constructor is the standard built-in Function prototype object.

Besides the internal properties and the LENGTH property (whose value is
1), the Object constructor has the following properties:

The initial value of OBJECT.PROTOTYPE is the standard built-in Object
prototype object (15.2.4).

This property has the attributes {[[Writable]]: false, [[Enumerable]]:
false, [[Configurable]]: false }.

When the GETPROTOTYPEOF function is called with argument O, the
following steps are taken:

When the GETOWNPROPERTYDESCRIPTOR function is called, the following
steps are taken:

When the GETOWNPROPERTYNAMES function is called, the following steps are
taken:

NOTE If O is a String instance, the set of own properties processed in
step 4 includes the implicit properties defined in 15.5.5.2 that
correspond to character positions within the object’s [[PrimitiveValue]]
String.

The CREATE function creates a new object with a specified prototype.
When the CREATE function is called, the following steps are taken:

The DEFINEPROPERTY function is used to add an own property and/or update
the attributes of an existing own property of an object. When the
DEFINEPROPERTY function is called, the following steps are taken:

The DEFINEPROPERTIES function is used to add own properties and/or
update the attributes of existing own properties of an object. When the
DEFINEPROPERTIES function is called, the following steps are taken:

If an implementation defines a specific order of enumeration for the
for-in statement, that same enumeration order must be used to order the
list elements in step 3 of this algorithm.

When the SEAL function is called, the following steps are taken:

When the FREEZE function is called, the following steps are taken:

When the PREVENTEXTENSIONS function is called, the following steps are
taken:

When the ISSEALED function is called with argument O, the following
steps are taken:

When the ISFROZEN function is called with argument O, the following
steps are taken:

When the ISEXTENSIBLE function is called with argument O, the
following steps are taken:

When the KEYS function is called with argument O, the following steps
are taken:

If an implementation defines a specific order of enumeration for the
for-in statement, that same enumeration order must be used in step 5 of
this algorithm.

The value of the [[Prototype]] internal property of the Object prototype
object is NULL and the initial value of the [[Extensible]] internal
property is TRUE.

The initial value of OBJECT.PROTOTYPE.CONSTRUCTOR is the standard
built-in OBJECT constructor.

When the TOSTRING method is called, the following steps are taken:

Table 23 — Tags for Classified Native Objects

  [[NATIVEBRAND]] VALUE   TAG VALUE
  ----------------------- -------------
  NativeFunction          "FUNCTION"
  NativeArray             "ARRAY"
  StringWrapper           "STRING"
  BooleanWrapper          "BOOLEAN"
  NumberWrapper           "NUMBER"
  NativeMath              "MATH"
  NativeDate              "DATE"
  NativeRegExp            "REGEXP"
  NativeError             "ERROR"
  NativeJSON              "JSON"
  NativeArguments         "ARGUMENTS"
                          

When the TOLOCALESTRING method is called, the following steps are taken:

NOTE 1 This function is provided to give all Objects a generic
TOLOCALESTRING interface, even though not all may use it. Currently,
ARRAY, NUMBER, and DATE provide their own locale-sensitive
TOLOCALESTRING methods.

NOTE 2 The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that implementations
do not use this parameter position for anything else.

When the VALUEOF method is called, the following steps are taken:

When the HASOWNPROPERTY method is called with argument V, the
following steps are taken:

NOTE 1 Unlike [[HasProperty]] (8.12.6), this method does not consider
objects in the prototype chain.

NOTE 2 The ordering of steps 1 and 2 is chosen to ensure that any
exception that would have been thrown by step 1 in previous editions of
this specification will continue to be thrown even if the THIS value is
UNDEFINED or NULL.

When the ISPROTOTYPEOF method is called with argument V, the following
steps are taken:

NOTE The ordering of steps 1 and 2 is chosen to preserve the behaviour
specified by previous editions of this specification for the case where
V is not an object and the this value is undefined or null.

When the PROPERTYISENUMERABLE method is called with argument V, the
following steps are taken:

NOTE 1 This method does not consider objects in the prototype chain.

NOTE 2 The ordering of steps 1 and 2 is chosen to ensure that any
exception that would have been thrown by step 1 in previous editions of
this specification will continue to be thrown even if the THIS value is
UNDEFINED or NULL.

Object instances have no special properties beyond those inherited from
the Object prototype object.

When FUNCTION is called as a function rather than as a constructor, it
creates and initialises a new Function object. Thus the function call
FUNCTION(…) is equivalent to the object creation expression NEW
FUNCTION(…) with the same arguments.

When the FUNCTION function is called with some arguments p1, p2, … ,
pn, body (where n might be 0, that is, there are no “p”
arguments, and where body might also not be provided), the following
steps are taken:

When FUNCTION is called as part of a NEW expression, it is a
constructor: it initialises the newly created object.

The last argument specifies the body (executable code) of a function;
any preceding arguments specify formal parameters.

When the FUNCTION constructor is called with some arguments p1, p2,
… , pn, body (where n might be 0, that is, there are no “p”
arguments, and where body might also not be provided), the following
steps are taken:

A PROTOTYPE property is automatically created for every function, to
provide for the possibility that the function will be used as a
constructor.

NOTE It is permissible but not necessary to have one argument for each
formal parameter to be specified. For example, all three of the
following expressions produce the same result:

  new Function("a", "b", "c", "return a+b+c")

  new Function("a, b, c", "return a+b+c")

  new Function("a,b", "c", "return a+b+c")

The Function constructor is itself a Function object and has a
[[NativeBrand]] internal property whose value is NativeFunction. The
value of the [[Prototype]] internal property of the Function constructor
is the standard built-in Function prototype object (15.3.4).

The value of the [[Extensible]] internal property of the Function
constructor is TRUE.

The Function constructor has the following properties:

The initial value of FUNCTION.PROTOTYPE is the standard built-in
Function prototype object (15.3.4).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

This is a data property with a value of 1. This property has the
attributes { [[Writable]]: FALSE, [[Enumerable]]: FALSE,
[[Configurable]]: FALSE }.

The Function prototype object is itself a Function object and has a
[[NativeBrand]] internal property whose value is NativeFunction . When
invoked, it accepts any arguments and returns UNDEFINED.

The value of the [[Prototype]] internal property of the Function
prototype object is the standard built-in Object prototype object
(15.2.4). The initial value of the [[Extensible]] internal property of
the Function prototype object is TRUE.

The Function prototype object does not have a VALUEOF property of its
own; however, it inherits the VALUEOF property from the Object prototype
Object.

The LENGTH property of the Function prototype object is 0.

The initial value of FUNCTION.PROTOTYPE.CONSTRUCTOR is the built-in
FUNCTION constructor.

An implementation-dependent representation of the function is returned.
This representation has the syntax of a FunctionDeclaration. Note in
particular that the use and placement of white space, line terminators,
and semicolons within the representation String is
implementation-dependent.

The TOSTRING function is not generic; it throws a TYPEERROR exception if
its THIS value is not a Function object. Therefore, it cannot be
transferred to other kinds of objects for use as a method.

When the APPLY method is called on an object func with arguments
thisArg and argArray, the following steps are taken:

The LENGTH property of the APPLY method is 2.

NOTE The thisArg value is passed without modification as the THIS value.
This is a change from Edition 3, where a UNDEFINED or NULL thisArg is
replaced with the global object and ToObject is applied to all other
values and that result is passed as the THIS value.

When the CALL method is called on an object func with argument
thisArg and optional arguments arg1, arg2 etc, the following steps
are taken:

The LENGTH property of the CALL method is 1.

NOTE The thisArg value is passed without modification as the THIS value.
This is a change from Edition 3, where a UNDEFINED or NULL thisArg is
replaced with the global object and ToObject is applied to all other
values and that result is passed as the THIS value.

The bind method takes one or more arguments, thisArg and (optionally)
arg1, arg2, etc, and returns a new function object by performing the
following steps:

The LENGTH property of the BIND method is 1.

NOTE Function objects created using FUNCTION.PROTOTYPE.BIND do not have
a PROTOTYPE property or the [[Code]], [[FormalParameters]], and
[[Scope]] internal properties.

When the [[Call]] internal method of a function object, F, which was
created using the bind function is called with a THIS value and a list
of arguments ExtraArgs, the following steps are taken:

When the [[Construct]] internal method of a function object, F that
was created using the bind function is called with a list of arguments
ExtraArgs, the following steps are taken:

When the [[HasInstance]] internal method of a function object F, that
was created using the bind function is called with argument V, the
following steps are taken:

In addition to the required internal properties, every function instance
has a [[Call]] internal property and in most cases uses a different
version of the [[Get]] internal property. Depending on how they are
created (see 8.6.2, 13.2, 15, and 15.3.4.5), function instances may have
a [[HasInstance]] internal property, a [[Scope]] internal property, a
[[Construct]] internal property, a [[FormalParameters]] internal
property, a [[Code]] internal property, a [[TargetFunction]] internal
property, a [[BoundThis]] internal property, and a [[BoundArgs]]
internal property.

Every function instance has a [[NativeBrand]] internal property whose
value is NativeFunction.

Function instances that correspond to strict mode functions (13.2) and
function instances created using the FUNCTION.PROTOTYPE.BIND METHOD
(15.3.4.5) have properties named “caller” and “arguments” that throw a
TYPEERROR exception. An ECMAScript implementation must not associate any
implementation specific behaviour with accesses of these properties from
strict mode function code.

The value of the LENGTH property is an integer that indicates the
“typical” number of arguments expected by the function. However, the
language permits the function to be invoked with some other number of
arguments. The behaviour of a function when invoked on a number of
arguments other than the number specified by its LENGTH property depends
on the function. This property has the attributes { [[Writable]]: FALSE,
[[Enumerable]]: FALSE, [[Configurable]]: FALSE }.

The value of the PROTOTYPE property is used to initialise the
[[Prototype]] internal property of a newly created object before the
Function object is invoked as a constructor for that newly created
object. This property has the attribute { [[Writable]]: TRUE,
[[Enumerable]]: FALSE, [[Configurable]]: FALSE }.

NOTE Function objects created using FUNCTION.PROTOTYPE.BIND do not have
a PROTOTYPE property.

Assume F is a Function object.

When the [[HasInstance]] internal method of F is called with value
V, the following steps are taken:

NOTE Function objects created using FUNCTION.PROTOTYPE.BIND have a
different implementation of [[HasInstance]] defined in 15.3.4.5.3.

Function objects use a variation of the [[Get]] internal method used for
other native ECMAScript objects (8.12.3).

Assume F is a Function object. When the [[Get]] internal method of F
is called with property name P, the following steps are taken:

NOTE Function objects created using FUNCTION.PROTOTYPE.BIND use the
default [[Get]] internal method.

Array objects give special treatment to a certain class of property
names. A property name P (in the form of a String value) is an _array
index_ if and only if ToString(ToUint32(P)) is equal to P and
ToUint32(P) is not equal to 2^32^−1. A property whose property name is
an array index is also called an element. Every Array object has a
LENGTH property whose value is always a nonnegative integer less than
2^32^. The value of the LENGTH property is numerically greater than the
name of every property whose name is an array index; whenever a property
of an Array object is created or changed, other properties are adjusted
as necessary to maintain this invariant. Specifically, whenever a
property is added whose name is an array index, the LENGTH property is
changed, if necessary, to be one more than the numeric value of that
array index; and whenever the LENGTH property is changed, every property
whose name is an array index whose value is not smaller than the new
length is automatically deleted. This constraint applies only to own
properties of an Array object and is unaffected by LENGTH or array index
properties that may be inherited from its prototypes.

An object, O, is said to be sparse if the following algorithm
returns TRUE:

When ARRAY is called as a function rather than as a constructor, it
creates and initialises a new Array object. Thus the function call
ARRAY(…) is equivalent to the object creation expression NEW ARRAY(…)
with the same arguments.

When the ARRAY function is called the following steps are taken:

When ARRAY is called as part of a NEW expression, it is a constructor:
it initialises the newly created object.

This description applies if and only if the Array constructor is given
no arguments or at least two arguments.

The [[Prototype]] internal property of the newly constructed object is
set to the original Array prototype object, the one that is the initial
value of ARRAY.PROTOTYPE (15.4.3.1).

The newly constructed object has the [[NativeBrand]] internal property
with value NativeArray.

The [[Extensible]] internal property of the newly constructed object is
set to TRUE.

The LENGTH property of the newly constructed object is set to the number
of arguments.

The 0 property of the newly constructed object is set to item0 (if
supplied); the 1 property of the newly constructed object is set to
item1 (if supplied); and, in general, for as many arguments as there
are, the k property of the newly constructed object is set to argument
k, where the first argument is considered to be argument number 0.
These properties all have the attributes {[[Writable]]: TRUE,
[[Enumerable]]: TRUE, [[Configurable]]: TRUE}.

The [[Prototype]] internal property of the newly constructed object is
set to the original Array prototype object, the one that is the initial
value of ARRAY.PROTOTYPE (15.4.3.1). The newly constructed object has
the [[NativeBrand]] internal property with value NativeArray. The
[[Extensible]] internal property of the newly constructed object is set
to TRUE.

If the argument len is a Number and ToUint32(len) is equal to len,
then the LENGTH property of the newly constructed object is set to
ToUint32(len). If the argument len is a Number and ToUint32(len)
is not equal to len, a RANGEERROR exception is thrown.

If the argument len is not a Number, then the LENGTH property of the
newly constructed object is set to 1 and the 0 property of the newly
constructed object is set to len with attributes {[[Writable]]: TRUE,
[[Enumerable]]: TRUE, [[Configurable]]: TRUE}.

The value of the [[Prototype]] internal property of the Array
constructor is the Function prototype object (15.3.4).

Besides the internal properties and the LENGTH property (whose value is
1), the Array constructor has the following properties:

The initial value of ARRAY.PROTOTYPE is the Array prototype object
(15.4.4).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

The isArray function takes one argument arg, and returns the Boolean
value TRUE if the argument is an object whose class internal property is
"ARRAY"; otherwise it returns FALSE. The following steps are taken:

The value of the [[Prototype]] internal property of the Array prototype
object is the standard built-in Object prototype object (15.2.4).

The Array prototype object is itself an array; it has an [[NativeBrand]]
internal property with value NativeArray, and it has a LENGTH property
(whose initial value is +0) and the special [[DefineOwnProperty]]
internal method described in 15.4.5.1.

In following descriptions of functions that are properties of the Array
prototype object, the phrase “this object” refers to the object that is
the THIS value for the invocation of the function. It is permitted for
the THIS to be an object which does not have an [[NativeBrand]] internal
property with value NativeArray.

NOTE The Array prototype object does not have a VALUEOF property of its
own; however, it inherits the VALUEOF property from the standard
built-in Object prototype Object.

The initial value of ARRAY.PROTOTYPE.CONSTRUCTOR is the standard
built-in ARRAY constructor.

When the TOSTRING method is called, the following steps are taken:

NOTE The TOSTRING function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the TOSTRING
function can be applied successfully to a host object is
implementation-dependent.

The elements of the array are converted to Strings using their
TOLOCALESTRING methods, and these Strings are then concatenated,
separated by occurrences of a separator String that has been derived in
an implementation-defined locale-specific way. The result of calling
this function is intended to be analogous to the result of TOSTRING,
except that the result of this function is intended to be
locale-specific.

The result is calculated as follows:

NOTE 1 The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that implementations
do not use this parameter position for anything else.

NOTE 2 The TOLOCALESTRING function is intentionally generic; it does not
require that its THIS value be an Array object. Therefore it can be
transferred to other kinds of objects for use as a method. Whether the
TOLOCALESTRING function can be applied successfully to a host object is
implementation-dependent.

When the CONCAT method is called with zero or more arguments item1,
item2, etc., it returns an array containing the array elements of the
object followed by the array elements of each argument in order.

The following steps are taken:

The LENGTH property of the CONCAT method is 1.

NOTE The CONCAT function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the CONCAT
function can be applied successfully to a host object is
implementation-dependent.

The elements of the array are converted to Strings, and these Strings
are then concatenated, separated by occurrences of the separator. If
no separator is provided, a single comma is used as the separator.

The JOIN method takes one argument, separator, and performs the
following steps:

The LENGTH property of the JOIN method is 1.

NOTE The JOIN function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore, it can be transferred
to other kinds of objects for use as a method. Whether the JOIN function
can be applied successfully to a host object is
implementation-dependent.

The last element of the array is removed from the array and returned.

NOTE The POP function is intentionally generic; it does not require that
its THIS value be an Array object. Therefore it can be transferred to
other kinds of objects for use as a method. Whether the POP function can
be applied successfully to a host object is implementation-dependent.

The arguments are appended to the end of the array, in the order in
which they appear. The new length of the array is returned as the result
of the call.

When the PUSH method is called with zero or more arguments item1,
item2, etc., the following steps are taken:

The LENGTH property of the PUSH method is 1.

NOTE The PUSH function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the PUSH function
can be applied successfully to a host object is
implementation-dependent.

The elements of the array are rearranged so as to reverse their order.
The object is returned as the result of the call.

NOTE The REVERSE function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore, it can be transferred
to other kinds of objects for use as a method. Whether the REVERSE
function can be applied successfully to a host object is
implementation-dependent.

The first element of the array is removed from the array and returned.

NOTE The SHIFT function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the SHIFT
function can be applied successfully to a host object is
implementation-dependent.

The SLICE method takes two arguments, start and end, and returns an
array containing the elements of the array from element start up to,
but not including, element end (or through the end of the array if
end is UNDEFINED). If start is negative, it is treated as
length_+_start where length is the length of the array. If end is
negative, it is treated as length_+_end where length is the length
of the array. The following steps are taken:

The LENGTH property of the SLICE method is 2.

NOTE The SLICE function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the SLICE
function can be applied successfully to a host object is
implementation-dependent.

The elements of this array are sorted. The sort is not necessarily
stable (that is, elements that compare equal do not necessarily remain
in their original order). If comparefn is not UNDEFINED, it should be
a function that accepts two arguments x and y and returns a negative
value if x < y, zero if x = y, or a positive value if x > y.

Let obj be the result of calling ToObject passing the THIS value as
the argument.

Let len be the result of applying Uint32 to the result of calling the
[[Get]] internal method of obj with argument "LENGTH".

If comparefn is not UNDEFINED and is not a consistent comparison
function for the elements of this array (see below), the behaviour of
SORT is implementation-defined.

Let proto be the value of the [[Prototype]] internal property of
obj. If proto is not NULL and there exists an integer j such that
all of the conditions below are satisfied then the behaviour of SORT is
implementation-defined:

-   obj is sparse (15.4)

-   0 ≤ j < len

-   The result of calling the [[HasProperty]] internal method of proto
    with argument ToString(j) is TRUE.

The behaviour of SORT is also implementation defined if obj is sparse
and any of the following conditions are true:

-   The [[Extensible]] internal property of obj is FALSE.

-   Any array index property of obj whose name is a nonnegative
    integer less than len is a data property whose [[Configurable]]
    attribute is FALSE.

The behaviour of SORT is also implementation defined if any array index
property of obj whose name is a nonnegative integer less than len is
an accessor property or is a data property whose [[Writable]] attribute
is FALSE.

Otherwise, the following steps are taken.

The returned object must have the following two properties.

-   There must be some mathematical permutation π of the nonnegative
    integers less than len, such that for every nonnegative integer
    j less than len, if property old[j] existed, then new[π(j)]
    is exactly the same value as old[j],. But if property old[j] did
    not exist, then new[π(j)] does not exist.

-   Then for all nonnegative integers j and k, each less than len,
    if SortCompare(j_,_k) < 0 (see SortCompare below), then Π(j) <
    Π(k).

Here the notation old[j] is used to refer to the hypothetical result
of calling the [[Get]] internal method of obj with argument j before
this function is executed, and the notation new[j] to refer to the
hypothetical result of calling the [[Get]] internal method of obj with
argument j after this function has been executed.

A function comparefn is a consistent comparison function for a set of
values S if all of the requirements below are met for all values a,
b, and c (possibly the same value) in the set S: The notation
a_ <~CF~ _b means comparefn_(_a_,_b) < 0; a_ =~CF~ _b means
comparefn_(_a_,_b) = 0 (of either sign); and a_ >~CF~ _b means
comparefn_(_a_,_b) > 0.

-   Calling comparefn_(_a_,_b) always returns the same value v when
    given a specific pair of values a and b as its two arguments.
    Furthermore, Type(v) is Number, and v is not NaN. Note that this
    implies that exactly one of a_ <~CF~ _b, a_ =~CF~ _b, and
    a_ >~CF~ _b will be true for a given pair of a and b.

-   Calling comparefn_(_a_,_b) does not modify the THIS object.

-   a_ =~CF~ _a (reflexivity)

-   If a_ =~CF~ _b, then b_ =~CF~ _a (symmetry)

-   If a_ =~CF~ _b and b_ =~CF~ _c, then a_ =~CF~ _c (transitivity
    of =~CF~)

-   If a_ <~CF~ _b and b_ <~CF~ _c, then a_ <~CF~ _c (transitivity
    of <~CF~)

-   If a_ >~CF~ _b and b_ >~CF~ _c, then a_ >~CF~ _c (transitivity
    of >~CF~)

NOTE The above conditions are necessary and sufficient to ensure that
comparefn divides the set S into equivalence classes and that these
equivalence classes are totally ordered.

When the SortCompare abstract operation is called with two arguments j
and k, the following steps are taken:

NOTE 1 Because non-existent property values always compare greater than
UNDEFINED property values, and UNDEFINED always compares greater than
any other value, undefined property values always sort to the end of the
result, followed by non-existent property values.

NOTE 2 The SORT function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore, it can be transferred
to other kinds of objects for use as a method. Whether the SORT function
can be applied successfully to a host object is
implementation-dependent.

When the SPLICE method is called with two or more arguments start,
deleteCount and (optionally) item1, item2, etc., the deleteCount
elements of the array starting at array index start are replaced by
the arguments item1, item2, etc. An Array object containing the
deleted elements (if any) is returned. The following steps are taken:

The LENGTH property of the SPLICE method is 2.

NOTE The SPLICE function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the SPLICE
function can be applied successfully to a host object is
implementation-dependent.

The arguments are prepended to the start of the array, such that their
order within the array is the same as the order in which they appear in
the argument list.

When the UNSHIFT method is called with zero or more arguments item1,
item2, etc., the following steps are taken:

The LENGTH property of the UNSHIFT method is 1.

NOTE The UNSHIFT function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the UNSHIFT
function can be applied successfully to a host object is
implementation-dependent.

INDEXOF compares searchElement to the elements of the array, in
ascending order, using the internal Strict Equality Comparison Algorithm
(11.9.1), and if found at one or more positions, returns the index of
the first such position; otherwise, -1 is returned.

The optional second argument fromIndex defaults to 0 (i.e. the whole
array is searched). If it is greater than or equal to the length of the
array, -1 is returned, i.e. the array will not be searched. If it is
negative, it is used as the offset from the end of the array to compute
fromIndex. If the computed index is less than 0, the whole array will
be searched.

When the INDEXOF method is called with one or two arguments, the
following steps are taken:

The LENGTH property of the INDEXOF method is 1.

NOTE The INDEXOF function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the INDEXOF
function can be applied successfully to a host object is
implementation-dependent.

LASTINDEXOF compares searchElement to the elements of the array in
descending order using the internal Strict Equality Comparison Algorithm
(11.9.1), and if found at one or more positions, returns the index of
the last such position; otherwise, -1 is returned.

The optional second argument fromIndex defaults to the array's length
minus one (i.e. the whole array is searched). If it is greater than or
equal to the length of the array, the whole array will be searched. If
it is negative, it is used as the offset from the end of the array to
compute fromIndex. If the computed index is less than 0, -1 is
returned.

When the LASTINDEXOF method is called with one or two arguments, the
following steps are taken:

The LENGTH property of the LASTINDEXOF method is 1.

NOTE The LASTINDEXOF function is intentionally generic; it does not
require that its THIS value be an Array object. Therefore it can be
transferred to other kinds of objects for use as a method. Whether the
LASTINDEXOF function can be applied successfully to a host object is
implementation-dependent.

callbackfn should be a function that accepts three arguments and
returns a value that is coercible to the Boolean value TRUE or FALSE.
EVERY calls callbackfn once for each element present in the array, in
ascending order, until it finds one where callbackfn returns FALSE. If
such an element is found, EVERY immediately returns FALSE. Otherwise, if
callbackfn returned TRUE for all elements, EVERY will return TRUE.
callbackfn is called only for elements of the array which actually
exist; it is not called for missing elements of the array.

If a thisArg parameter is provided, it will be used as the THIS value
for each invocation of callbackfn. If it is not provided, UNDEFINED is
used instead.

callbackfn is called with three arguments: the value of the element,
the index of the element, and the object being traversed.

EVERY does not directly mutate the object on which it is called but the
object may be mutated by the calls to callbackfn.

The range of elements processed by EVERY is set before the first call to
callbackfn. Elements which are appended to the array after the call to
EVERY begins will not be visited by callbackfn. If existing elements
of the array are changed, their value as passed to callbackfn will be
the value at the time EVERY visits them; elements that are deleted after
the call to EVERY begins and before being visited are not visited. EVERY
acts like the "for all" quantifier in mathematics. In particular, for an
empty array, it returns TRUE.

When the EVERY method is called with one or two arguments, the following
steps are taken:

The LENGTH property of the EVERY method is 1.

NOTE The EVERY function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the EVERY
function can be applied successfully to a host object is
implementation-dependent.

callbackfn should be a function that accepts three arguments and
returns a value that is coercible to the Boolean value TRUE or FALSE.
SOME calls callbackfn once for each element present in the array, in
ascending order, until it finds one where callbackfn returns TRUE. If
such an element is found, SOME immediately returns TRUE. Otherwise, SOME
returns FALSE. callbackfn is called only for elements of the array
which actually exist; it is not called for missing elements of the
array.

If a thisArg parameter is provided, it will be used as the THIS value
for each invocation of callbackfn. If it is not provided, UNDEFINED is
used instead.

callbackfn is called with three arguments: the value of the element,
the index of the element, and the object being traversed.

SOME does not directly mutate the object on which it is called but the
object may be mutated by the calls to callbackfn.

The range of elements processed by SOME is set before the first call to
callbackfn. Elements that are appended to the array after the call to
SOME begins will not be visited by callbackfn. If existing elements of
the array are changed, their value as passed to callbackfn will be the
value at the time that SOME visits them; elements that are deleted after
the call to SOME begins and before being visited are not visited. SOME
acts like the "exists" quantifier in mathematics. In particular, for an
empty array, it returns FALSE.

When the SOME method is called with one or two arguments, the following
steps are taken:

The LENGTH property of the SOME method is 1.

NOTE The SOME function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the SOME function
can be applied successfully to a host object is
implementation-dependent.

callbackfn should be a function that accepts three arguments. FOREACH
calls callbackfn once for each element present in the array, in
ascending order. callbackfn is called only for elements of the array
which actually exist; it is not called for missing elements of the
array.

If a thisArg parameter is provided, it will be used as the THIS value
for each invocation of callbackfn. If it is not provided, UNDEFINED is
used instead.

callbackfn is called with three arguments: the value of the element,
the index of the element, and the object being traversed.

FOREACH does not directly mutate the object on which it is called but
the object may be mutated by the calls to callbackfn.

The range of elements processed by FOREACH is set before the first call
to callbackfn. Elements which are appended to the array after the call
to FOREACH begins will not be visited by callbackfn. If existing
elements of the array are changed, their value as passed to callback
will be the value at the time FOREACH visits them; elements that are
deleted after the call to FOREACH begins and before being visited are
not visited.

When the FOREACH method is called with one or two arguments, the
following steps are taken:

The LENGTH property of the FOREACH method is 1.

NOTE The FOREACH function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the FOREACH
function can be applied successfully to a host object is
implementation-dependent.

callbackfn should be a function that accepts three arguments. MAP
calls callbackfn once for each element in the array, in ascending
order, and constructs a new Array from the results. callbackfn is
called only for elements of the array which actually exist; it is not
called for missing elements of the array.

If a thisArg parameter is provided, it will be used as the THIS value
for each invocation of callbackfn. If it is not provided, UNDEFINED is
used instead.

callbackfn is called with three arguments: the value of the element,
the index of the element, and the object being traversed.

MAP does not directly mutate the object on which it is called but the
object may be mutated by the calls to callbackfn.

The range of elements processed by MAP is set before the first call to
callbackfn. Elements which are appended to the array after the call to
MAP begins will not be visited by callbackfn. If existing elements of
the array are changed, their value as passed to callbackfn will be the
value at the time MAP visits them; elements that are deleted after the
call to MAP begins and before being visited are not visited.

When the MAP method is called with one or two arguments, the following
steps are taken:

The LENGTH property of the MAP method is 1.

NOTE The MAP function is intentionally generic; it does not require that
its THIS value be an Array object. Therefore it can be transferred to
other kinds of objects for use as a method. Whether the MAP function can
be applied successfully to a host object is implementation-dependent.

callbackfn should be a function that accepts three arguments and
returns a value that is coercible to the Boolean value TRUE or FALSE.
FILTER calls callbackfn once for each element in the array, in
ascending order, and constructs a new array of all the values for which
callbackfn returns TRUE. callbackfn is called only for elements of
the array which actually exist; it is not called for missing elements of
the array.

If a thisArg parameter is provided, it will be used as the THIS value
for each invocation of callbackfn. If it is not provided, UNDEFINED is
used instead.

callbackfn is called with three arguments: the value of the element,
the index of the element, and the object being traversed.

FILTER does not directly mutate the object on which it is called but the
object may be mutated by the calls to callbackfn.

The range of elements processed by FILTER is set before the first call
to callbackfn. Elements which are appended to the array after the call
to FILTER begins will not be visited by callbackfn. If existing
elements of the array are changed their value as passed to callbackfn
will be the value at the time FILTER visits them; elements that are
deleted after the call to FILTER begins and before being visited are not
visited.

When the FILTER method is called with one or two arguments, the
following steps are taken:

The LENGTH property of the FILTER method is 1.

NOTE The FILTER function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the FILTER
function can be applied successfully to a host object is
implementation-dependent.

callbackfn should be a function that takes four arguments. REDUCE
calls the callback, as a function, once for each element present in the
array, in ascending order.

callbackfn is called with four arguments: the previousValue (or
value from the previous call to callbackfn), the currentValue (value
of the current element), the currentIndex, and the object being
traversed. The first time that callback is called, the previousValue
and currentValue can be one of two values. If an initialValue was
provided in the call to REDUCE, then previousValue will be equal to
initialValue and currentValue will be equal to the first value in
the array. If no initialValue was provided, then previousValue will
be equal to the first value in the array and currentValue will be
equal to the second. It is a TYPEERROR if the array contains no elements
and initialValue is not provided.

REDUCE does not directly mutate the object on which it is called but the
object may be mutated by the calls to callbackfn.

The range of elements processed by REDUCE is set before the first call
to callbackfn. Elements that are appended to the array after the call
to REDUCE begins will not be visited by callbackfn. If existing
elements of the array are changed, their value as passed to callbackfn
will be the value at the time REDUCE visits them; elements that are
deleted after the call to REDUCE begins and before being visited are not
visited.

When the REDUCE method is called with one or two arguments, the
following steps are taken:

The LENGTH property of the REDUCE method is 1.

NOTE The REDUCE function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the REDUCE
function can be applied successfully to a host object is
implementation-dependent.

callbackfn should be a function that takes four arguments. REDUCERIGHT
calls the callback, as a function, once for each element present in the
array, in descending order.

callbackfn is called with four arguments: the previousValue (or
value from the previous call to callbackfn), the currentValue (value
of the current element), the currentIndex, and the object being
traversed. The first time the function is called, the previousValue
and currentValue can be one of two values. If an initialValue was
provided in the call to REDUCERIGHT, then previousValue will be equal
to initialValue and currentValue will be equal to the last value in
the array. If no initialValue was provided, then previousValue will
be equal to the last value in the array and currentValue will be equal
to the second-to-last value. It is a TYPEERROR if the array contains no
elements and initialValue is not provided.

REDUCERIGHT does not directly mutate the object on which it is called
but the object may be mutated by the calls to callbackfn.

The range of elements processed by REDUCERIGHT is set before the first
call to callbackfn. Elements that are appended to the array after the
call to REDUCERIGHT begins will not be visited by callbackfn. If
existing elements of the array are changed by callbackfn, their value
as passed to callbackfn will be the value at the time REDUCERIGHT
visits them; elements that are deleted after the call to REDUCERIGHT
begins and before being visited are not visited.

When the REDUCERIGHT method is called with one or two arguments, the
following steps are taken:

The LENGTH property of the REDUCERIGHT method is 1.

NOTE The REDUCERIGHT function is intentionally generic; it does not
require that its this value be an Array object. Therefore it can be
transferred to other kinds of objects for use as a method. Whether the
REDUCERIGHT function can be applied successfully to a host object is
implementation-dependent.

Array instances inherit properties from the Array prototype object and
have the [[NativeBrand]] internal property with value NativeArray. Array
instances also have the following properties.

Array objects use a variation of the [[DefineOwnProperty]] internal
method used for other native ECMAScript objects (8.12.9).

Assume A is an Array object, Desc is a Property Descriptor, and
Throw is a Boolean flag.

In the following algorithm, the term “Reject” means “If Throw is TRUE,
then throw a TYPEERROR exception, otherwise return FALSE.”

When the [[DefineOwnProperty]] internal method of A is called with
property P, Property Descriptor Desc, and Boolean flag Throw, the
following steps are taken:

The LENGTH property of this Array object is a data property whose value
is always numerically greater than the name of every deletable property
whose name is an array index.

The LENGTH property initially has the attributes { [[Writable]]: TRUE,
[[Enumerable]]: FALSE, [[Configurable]]: FALSE }.

NOTE Attempting to set the length property of an Array object to a value
that is numerically less than or equal to the largest numeric property
name of an existing array indexed non-deletable property of the array
will result in the length being set to a numeric value that is one
greater than that largest numeric property name. See 15.4.5.1.

When STRING is called as a function rather than as a constructor, it
performs a type conversion.

Returns a String value (not a String object) computed by
ToString(value). If value is not supplied, the empty String "" is
returned.

When STRING is called as part of a NEW expression, it is a constructor:
it initialises the newly created object.

The [[Prototype]] internal property of the newly constructed object is
set to the standard built-in String prototype object that is the initial
value of STRING.PROTOTYPE (15.5.3.1).

The newly constructed object has the [[NativeBrand]] internal property
with value StringWrapper.

The [[Extensible]] internal property of the newly constructed object is
set to TRUE.

The [[PrimitiveValue]] internal property of the newly constructed object
is set to ToString(value), or to the empty String if value is not
supplied.

The value of the [[Prototype]] internal property of the String
constructor is the standard built-in Function prototype object (15.3.4).

Besides the internal properties and the LENGTH property (whose value is
1), the String constructor has the following properties:

The initial value of STRING.PROTOTYPE is the standard built-in String
prototype object (15.5.4).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Returns a String value containing as many characters as the number of
arguments. Each argument specifies one character of the resulting
String, with the first argument specifying the first character, and so
on, from left to right. An argument is converted to a character by
applying the operation ToUint16 (9.7) and regarding the resulting 16-bit
integer as the code unit value of a character. If no arguments are
supplied, the result is the empty String.

The LENGTH property of the FROMCHARCODE function is 1.

The String prototype object is itself a String object whose value is an
empty String. The String prototype object has the [[NativeBrand]]
internal property with value StringWrapper.

The value of the [[Prototype]] internal property of the String prototype
object is the standard built-in Object prototype object (15.2.4).

The initial value of STRING.PROTOTYPE.CONSTRUCTOR is the built-in STRING
constructor.

Returns this String value. (Note that, for a String object, the TOSTRING
method happens to return the same thing as the VALUEOF method.)

The TOSTRING function is not generic; it throws a TYPEERROR exception if
its THIS value is not a String or a String object. Therefore, it cannot
be transferred to other kinds of objects for use as a method.

Returns this String value.

The VALUEOF function is not generic; it throws a TYPEERROR exception if
its THIS value is not a String or String object. Therefore, it cannot be
transferred to other kinds of objects for use as a method.

Returns a String containing the character at position pos in the
String resulting from converting this object to a String. If there is no
character at that position, the result is the empty String. The result
is a String value, not a String object.

If pos is a value of Number type that is an integer, then the result
of X.CHARAT(pos) is equal to the result of X.SUBSTRING(pos,
pos+1).

When the CHARAT method is called with one argument pos, the following
steps are taken:

NOTE The CHARAT function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

Returns a Number (a nonnegative integer less than 2^16^) representing
the code unit value of the character at position pos in the String
resulting from converting this object to a String. If there is no
character at that position, the result is NAN.

When the CHARCODEAT method is called with one argument pos, the
following steps are taken:

NOTE The CHARCODEAT function is intentionally generic; it does not
require that its THIS value be a String object. Therefore it can be
transferred to other kinds of objects for use as a method.

When the CONCAT method is called with zero or more arguments string1,
string2, etc., it returns a String consisting of the characters of
this object (converted to a String) followed by the characters of each
of string1, string2, etc. (where each argument is converted to a
String). The result is a String value, not a String object. The
following steps are taken:

The LENGTH property of the CONCAT method is 1.

NOTE The CONCAT function is intentionally generic; it does not require
that its THIS value be a String object. Therefore it can be transferred
to other kinds of objects for use as a method.

If searchString appears as a substring of the result of converting
this object to a String, at one or more positions that are greater than
or equal to position, then the index of the smallest such position is
returned; otherwise, 1 is returned. If position is UNDEFINED, 0 is
assumed, so as to search all of the String.

The INDEXOF method takes two arguments, searchString and position,
and performs the following steps:

The LENGTH property of the INDEXOF method is 1.

NOTE The INDEXOF function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

If searchString appears as a substring of the result of converting
this object to a String at one or more positions that are smaller than
or equal to position, then the index of the greatest such position is
returned; otherwise, 1 is returned. If position is UNDEFINED, the
length of the String value is assumed, so as to search all of the
String.

The LASTINDEXOF method takes two arguments, searchString and
position, and performs the following steps:

The LENGTH property of the LASTINDEXOF method is 1.

NOTE The LASTINDEXOF function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

When the LOCALECOMPARE method is called with one argument that, it
returns a Number other than NAN that represents the result of a
locale-sensitive String comparison of the this value (converted to a
String) with that (converted to a String). The two Strings are S and
That. The two Strings are compared in an implementation-defined
fashion. The result is intended to order String values in the sort order
specified by the system default locale, and will be negative, zero, or
positive, depending on whether S comes before That in the sort
order, the Strings are equal, or S comes after That in the sort
order, respectively.

Before perform the comparisons the following steps are performed to
prepare the Strings:

The LOCALECOMPARE method, if considered as a function of two arguments
THIS and that, is a consistent comparison function (as defined in
15.4.4.11) on the set of all Strings.

The actual return values are implementation-defined to permit
implementers to encode additional information in the value, but the
function is required to define a total ordering on all Strings and to
return 0 when comparing Strings that are considered canonically
equivalent by the Unicode standard.

If no language-sensitive comparison at all is available from the host
environment, this function may perform a bitwise comparison.

NOTE 1 The LOCALECOMPARE method itself is not directly suitable as an
argument to ARRAY.PROTOTYPE.SORT because the latter requires a function
of two arguments.

NOTE 2 This function is intended to rely on whatever language-sensitive
comparison functionality is available to the ECMAScript environment from
the host environment, and to compare according to the rules of the host
environment’s current locale. It is strongly recommended that this
function treat Strings that are canonically equivalent according to the
Unicode standard as identical (in other words, compare the Strings as if
they had both been converted to Normalised Form C or D first). It is
also recommended that this function not honour Unicode compatibility
equivalences or decompositions.

NOTE 3 The second parameter to this function is likely to be used in a
future version of this standard; it is recommended that implementations
do not use this parameter position for anything else.

NOTE 4 The LOCALECOMPARE function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

When the MATCH method is called with argument regexp, the following
steps are taken:

NOTE The MATCH function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

First set string according to the following steps:

If searchValue is a regular expression (an object that has a
[[NativeBrand]] internal property whose value is NativeRegExp), do the
following: If searchValue.global is FALSE, then search string for
the first match of the regular expression searchValue. If
searchValue.global is TRUE, then search string for all matches of
the regular expression searchValue. Do the search in the same manner
as in STRING.PROTOTYPE.MATCH, including the update of
searchValue.LASTINDEX. Let m be the number of left capturing
parentheses in searchValue (using NcapturingParens as specified in
15.10.2.1).

If searchValue is not a regular expression, let searchString be
ToString(searchValue) and search string for the first occurrence of
searchString. Let m be 0.

If replaceValue is a function, then for each matched substring, call
the function with the following m + 3 arguments. Argument 1 is the
substring that matched. If searchValue is a regular expression, the
next m arguments are all of the captures in the MatchResult (see
15.10.2.1). Argument m + 2 is the offset within string where the
match occurred, and argument m + 3 is string. The result is a String
value derived from the original input by replacing each matched
substring with the corresponding return value of the function call,
converted to a String if need be.

Otherwise, let newstring denote the result of converting
replaceValue to a String. The result is a String value derived from
the original input String by replacing each matched substring with a
String derived from newstring by replacing characters in newstring
by replacement text as specified in Table 24. These $ replacements are
done left-to-right, and, once such a replacement is performed, the new
replacement text is not subject to further replacements. For example,
"$1,$2".REPLACE(/(\$(\D))/G, "$$1-$1$2") returns "$1-$11,$1-$22". A $ in
newstring that does not match any of the forms below is left as is.

Table 24 — Replacement Text Symbol Substitutions

  ------------ --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  Characters   Replacement text
  $$           $
  $&           The matched substring.
  $‘           The portion of string that precedes the matched substring.
  $’           The portion of string that follows the matched substring.
  $N           The n^th^ capture, where n is a single digit in the range 1 to 9 and $n is not followed by a decimal digit. If n_≤_m and the nth capture is UNDEFINED, use the empty String instead. If n_>_m, the result is implementation-defined.
  $NN          The nn^th^ capture, where nn is a two-digit decimal number in the range 01 to 99. If nn_≤_m and the nn^th^ capture is UNDEFINED, use the empty String instead. If nn_>_m, the result is implementation-defined.
  ------------ --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

NOTE The REPLACE function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

When the search method is called with argument regexp, the following
steps are taken:

NOTE The SEARCH function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

The SLICE method takes two arguments, start and end, and returns a
substring of the result of converting this object to a String, starting
from character position start and running to, but not including,
character position end (or through the end of the String if end is
UNDEFINED). If start is negative, it is treated as
sourceLength_+_start where sourceLength is the length of the String.
If end is negative, it is treated as sourceLength_+_end where
sourceLength is the length of the String. The result is a String
value, not a String object. The following steps are taken:

The LENGTH property of the SLICE method is 2.

NOTE The SLICE function is intentionally generic; it does not require
that its THIS value be a String object. Therefore it can be transferred
to other kinds of objects for use as a method.

Returns an Array object into which substrings of the result of
converting this object to a String have been stored. The substrings are
determined by searching from left to right for occurrences of
separator; these occurrences are not part of any substring in the
returned array, but serve to divide up the String value. The value of
separator may be a String of any length or it may be a RegExp object
(i.e., an object with a [[NativeBrand]] internal property whose value is
NativeRegExp ; see 15.10).

The value of separator may be an empty String, an empty regular
expression, or a regular expression that can match an empty String. In
this case, separator does not match the empty substring at the
beginning or end of the input String, nor does it match the empty
substring at the end of the previous separator match. (For example, if
separator is the empty String, the String is split up into individual
characters; the length of the result array equals the length of the
String, and each substring contains one character.) If separator is a
regular expression, only the first match at a given position of the THIS
String is considered, even if backtracking could yield a
non-empty-substring match at that position. (For example,
"AB".SPLIT(/A*?/) evaluates to the array ["A","B"], while
"AB".SPLIT(/A*/) evaluates to the array["","B"].)

If the THIS object is (or converts to) the empty String, the result
depends on whether separator can match the empty String. If it can,
the result array contains no elements. Otherwise, the result array
contains one element, which is the empty String.

If separator is a regular expression that contains capturing
parentheses, then each time separator is matched the results
(including any UNDEFINED results) of the capturing parentheses are
spliced into the output array. For example,

  "A<B>BOLD</B>AND<CODE>CODED</CODE>".SPLIT(/<(\/)?([^<>]+)>/)

evaluates to the array

  ["A", UNDEFINED, "B", "BOLD", "/", "B", "AND", UNDEFINED,
   "CODE", "CODED", "/", "CODE", ""]

If separator is UNDEFINED, then the result array contains just one
String, which is the THIS value (converted to a String). If limit is
not UNDEFINED, then the output array is truncated so that it contains no
more than limit elements.

When the SPLIT method is called, the following steps are taken:

The abstract operation SplitMatch takes three parameters, a String
S, an integer q, and a String or RegExp R, and performs the
following in order to return a MatchResult (see 15.10.2.1):

The LENGTH property of the SPLIT method is 2.

NOTE 1 The SPLIT method ignores the value of separator.GLOBAL for
separators that are RegExp objects.

NOTE 2 The SPLIT function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

The SUBSTRING method takes two arguments, start and end, and returns
a substring of the result of converting this object to a String,
starting from character position start and running to, but not
including, character position end of the String (or through the end of
the String is end is UNDEFINED). The result is a String value, not a
String object.

If either argument is NAN or negative, it is replaced with zero; if
either argument is larger than the length of the String, it is replaced
with the length of the String.

If start is larger than end, they are swapped.

The following steps are taken:

The LENGTH property of the SUBSTRING method is 2.

NOTE The SUBSTRING function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

The following steps are taken:

For the purposes of this operation, the 16-bit code units of the Strings
are treated as code points in the Unicode Basic Multilingual Plane.
Surrogate code points are directly transferred from S to L without
any mapping.

The result must be derived according to the case mappings in the Unicode
character database (this explicitly includes not only the
UnicodeData.txt file, but also the SpecialCasings.txt file that
accompanies it in Unicode 2.1.8 and later).

NOTE 1 The case mapping of some characters may produce multiple
characters. In this case the result String may not be the same length as
the source String. Because both TOUPPERCASE and TOLOWERCASE have
context-sensitive behaviour, the functions are not symmetrical. In other
words, S.TOUPPERCASE().TOLOWERCASE() is not necessarily equal to
S.TOLOWERCASE().

NOTE 2 The TOLOWERCASE function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

This function works exactly the same as TOLOWERCASE except that its
result is intended to yield the correct result for the host
environment’s current locale, rather than a locale-independent result.
There will only be a difference in the few cases (such as Turkish) where
the rules for that language conflict with the regular Unicode case
mappings.

NOTE 1 The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that implementations
do not use this parameter position for anything else.

NOTE 2 The TOLOCALELOWERCASE function is intentionally generic; it does
not require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

This function behaves in exactly the same way as
STRING.PROTOTYPE.TOLOWERCASE, except that characters are mapped to their
uppercase equivalents as specified in the Unicode Character Database.

NOTE The TOUPPERCASE function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

This function works exactly the same as TOUPPERCASE except that its
result is intended to yield the correct result for the host
environment’s current locale, rather than a locale-independent result.
There will only be a difference in the few cases (such as Turkish) where
the rules for that language conflict with the regular Unicode case
mappings.

NOTE 1 The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that implementations
do not use this parameter position for anything else.

NOTE 2 The TOLOCALEUPPERCASE function is intentionally generic; it does
not require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

The following steps are taken:

NOTE The TRIM function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

String instances inherit properties from the String prototype object and
have a [[NativeBrand]] internal property with value StringWrapper.
String instances also have a [[PrimitiveValue]] internal property, a
LENGTH property, and a set of enumerable properties with array index
names.

The [[PrimitiveValue]] internal property is the String value represented
by this String object. The array index named properties correspond to
the individual characters of the String value. A special
[[GetOwnProperty]] internal method is used to specify the number,
values, and attributes of the array index named properties.

The number of characters in the String value represented by this String
object.

Once a String object is created, this property is unchanging. It has the
attributes { [[Writable]]: FALSE, [[Enumerable]]: FALSE,
[[Configurable]]: FALSE }.

String objects use a variation of the [[GetOwnProperty]] internal method
used for other native ECMAScript objects (8.12.1). This special internal
method provides access to named properties corresponding to the
individual characters of String objects.

Assume S is a String object and P is a String.

When the [[GetOwnProperty]] internal method of S is called with
property name P, the following steps are taken:

When BOOLEAN is called as a function rather than as a constructor, it
performs a type conversion.

Returns a Boolean value (not a Boolean object) computed by
ToBoolean(value).

When BOOLEAN is called as part of a NEW expression it is a constructor:
it initialises the newly created object.

The [[Prototype]] internal property of the newly constructed object is
set to the original Boolean prototype object, the one that is the
initial value of BOOLEAN.PROTOTYPE (15.6.3.1).

The newly constructed Boolean object has a [[NativeBrand]] internal
property with value BooleanWrapper.

The [[PrimitiveValue]] internal property of the newly constructed
Boolean object is set to ToBoolean(value).

The [[Extensible]] internal property of the newly constructed object is
set to TRUE.

The value of the [[Prototype]] internal property of the Boolean
constructor is the Function prototype object (15.3.4).

Besides the internal properties and the LENGTH property (whose value is
1), the Boolean constructor has the following property:

The initial value of BOOLEAN.PROTOTYPE is the Boolean prototype object
(15.6.4).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

The Boolean prototype object is itself a Boolean object whose value is
FALSE. The Boolean prototype object has a [[NativeBrand]] internal
property whose value is BooleanWrapper.

The value of the [[Prototype]] internal property of the Boolean
prototype object is the standard built-in Object prototype object
(15.2.4).

The initial value of BOOLEAN.PROTOTYPE.CONSTRUCTOR is the built-in
BOOLEAN constructor.

The following steps are taken:

The following steps are taken:

Boolean instances inherit properties from the Boolean prototype object
and have a [[NativeBrand]] internal property whose value is
BooleanWrapper. Boolean instances also have a [[PrimitiveValue]]
internal property.

The [[PrimitiveValue]] internal property is the Boolean value
represented by this Boolean object.

When NUMBER is called as a function rather than as a constructor, it
performs a type conversion.

Returns a Number value (not a Number object) computed by
ToNumber(value) if value was supplied, else returns +0.

When NUMBER is called as part of a NEW expression it is a constructor:
it initialises the newly created object.

The [[Prototype]] internal property of the newly constructed object is
set to the original Number prototype object, the one that is the initial
value of NUMBER.PROTOTYPE (15.7.3.1).

The newly constructed object is has a [[NativeBrand]] internal property
whose value is NumberWrapper.

The [[PrimitiveValue]] internal property of the newly constructed object
is set to ToNumber(value) if value was supplied, else to +0.

The [[Extensible]] internal property of the newly constructed object is
set to TRUE.

The value of the [[Prototype]] internal property of the Number
constructor is the Function prototype object (15.3.4).

Besides the internal properties and the LENGTH property (whose value is
1), the Number constructor has the following properties:

The initial value of NUMBER.PROTOTYPE is the Number prototype object
(15.7.4).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

The value of NUMBER.MAX_VALUE is the largest positive finite value of
the Number type, which is approximately 1.7976931348623157 × 10^308^.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

The value of NUMBER.MIN_VALUE is the smallest positive value of the
Number type, which is approximately 5 × 10^324^.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

The value of NUMBER.NAN is NAN.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

The value of Number.NEGATIVE_INFINITY is −∞.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

The value of Number.POSITIVE_INFINITY is +∞.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

The Number prototype object is itself a Number object with a
[[NativeBrand]] internal property whose value is NumberWrapper. Its
value is +0.

The value of the [[Prototype]] internal property of the Number prototype
object is the standard built-in Object prototype object (15.2.4).

Unless explicitly stated otherwise, the methods of the Number prototype
object defined below are not generic and the this value passed to them
must be either a Number value or an object that has a [[NativeBrand]]
internal property whose value is NumberWrapper.

In the following descriptions of functions that are properties of the
Number prototype object, the phrase “this Number object” refers to
either the object that is the THIS value for the invocation of the
function or, if Type(THIS value) is Number, an object that is created as
if by the expression NEW NUMBER(THIS value) where NUMBER is the standard
built-in constructor with that name. Also, the phrase “this Number
value” refers to either the Number value represented by this Number
object, that is, the value of the [[PrimitiveValue]] internal property
of this Number object or the THIS value if its type is Number. A
TYPEERROR exception is thrown if the THIS value is neither an object
that has a [[NativeBrand]] internal property whose value is
NumberWrapper or a value whose type is Number.

The initial value of NUMBER.PROTOTYPE.CONSTRUCTOR is the built-in NUMBER
constructor.

The optional radix should be an integer value in the inclusive range 2
to 36. If radix not present or is UNDEFINED the Number 10 is used as
the value of radix. If ToInteger(radix) is the Number 10 then this
Number value is given as an argument to the ToString abstract operation;
the resulting String value is returned.

If ToInteger(radix) is not an integer between 2 and 36 inclusive throw
a RANGEERROR exception. If ToInteger(radix) is an integer from 2 to
36, but not 10, the result is a String representation of this Number
value using the specified radix. Letters A-Z are used for digits with
values 10 through 35. The precise algorithm is implementation-dependent
if the radix is not 10, however the algorithm should be a generalisation
of that specified in 9.8.1.

The TOSTRING function is not generic; it throws a TYPEERROR exception if
its THIS value is not a Number or a Number object. Therefore, it cannot
be transferred to other kinds of objects for use as a method.

Produces a String value that represents this Number value formatted
according to the conventions of the host environment’s current locale.
This function is implementation-dependent, and it is permissible, but
not encouraged, for it to return the same thing as TOSTRING.

NOTE The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that implementations
do not use this parameter position for anything else.

Returns this Number value.

The VALUEOF function is not generic; it throws a TYPEERROR exception if
its THIS value is not a Number or a Number object. Therefore, it cannot
be transferred to other kinds of objects for use as a method.

Return a String containing this Number value represented in decimal
fixed-point notation with fractionDigits digits after the decimal
point. If fractionDigits is UNDEFINED, 0 is assumed. Specifically,
perform the following steps:

The LENGTH property of the TOFIXED method is 1.

If the TOFIXED method is called with more than one argument, then the
behaviour is undefined (see clause 15).

An implementation is permitted to extend the behaviour of TOFIXED for
values of fractionDigits less than 0 or greater than 20. In this case
TOFIXED would not necessarily throw RANGEERROR for such values.

NOTE The output of TOFIXED may be more precise than TOSTRING for some
values because toString only prints enough significant digits to
distinguish the number from adjacent number values. For example,

(1000000000000000128).TOSTRING() returns "1000000000000000100",
while (1000000000000000128).TOFIXED(0) returns "1000000000000000128".

Return a String containing this Number value represented in decimal
exponential notation with one digit before the significand's decimal
point and fractionDigits digits after the significand's decimal point.
If fractionDigits is UNDEFINED, include as many significand digits as
necessary to uniquely specify the Number (just like in ToString except
that in this case the Number is always output in exponential notation).
Specifically, perform the following steps:

The LENGTH property of the TOEXPONENTIAL method is 1.

If the TOEXPONENTIAL method is called with more than one argument, then
the behaviour is undefined (see clause 15).

An implementation is permitted to extend the behaviour of TOEXPONENTIAL
for values of fractionDigits less than 0 or greater than 20. In this
case TOEXPONENTIAL would not necessarily throw RANGEERROR for such
values.

NOTE For implementations that provide more accurate conversions than
required by the rules above, it is recommended that the following
alternative version of step 9.b.i be used as a guideline:

Return a String containing this Number value represented either in
decimal exponential notation with one digit before the significand's
decimal point and precision–1 digits after the significand's decimal
point or in decimal fixed notation with precision significant digits.
If precision is UNDEFINED, call ToString (9.8.1) instead.
Specifically, perform the following steps:

The LENGTH property of the TOPRECISION method is 1.

If the TOPRECISION method is called with more than one argument, then
the behaviour is undefined (see clause 15).

An implementation is permitted to extend the behaviour of TOPRECISION
for values of precision less than 1 or greater than 21. In this case
TOPRECISION would not necessarily throw RANGEERROR for such values.

Number instances inherit properties from the Number prototype object and
have a [[NativeBrand]] internal property whose value is NumberWrapper.
Number instances also have a [[PrimitiveValue]] internal property.

The [[PrimitiveValue]] internal property is the Number value represented
by this Number object.

The Math object is a single object that has some named properties, some
of which are functions.

The value of the [[Prototype]] internal property of the Math object is
the standard built-in Object prototype object (15.2.4). The Math object
has a [[NativeBrand]] internal property whose value is NativeMath.

The Math object does not have a [[Construct]] internal property; it is
not possible to use the Math object as a constructor with the NEW
operator.

The Math object does not have a [[Call]] internal property; it is not
possible to invoke the Math object as a function.

NOTE In this specification, the phrase “the Number value for x” has a
technical meaning defined in 8.5.

The Number value for e, the base of the natural logarithms, which is
approximately 2.7182818284590452354.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

The Number value for the natural logarithm of 10, which is approximately
2.302585092994046.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

The Number value for the natural logarithm of 2, which is approximately
0.6931471805599453.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

The Number value for the base-2 logarithm of e, the base of the
natural logarithms; this value is approximately 1.4426950408889634.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

NOTE The value of MATH.LOG2E is approximately the reciprocal of the
value of MATH.LN2.

The Number value for the base-10 logarithm of e, the base of the
natural logarithms; this value is approximately 0.4342944819032518.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

NOTE The value of MATH.LOG10E is approximately the reciprocal of the
value of MATH.LN10.

The Number value for π, the ratio of the circumference of a circle to
its diameter, which is approximately 3.1415926535897932.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

The Number value for the square root of ½, which is approximately
0.7071067811865476.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

NOTE The value of MATH.SQRT1_2 is approximately the reciprocal of the
value of MATH.SQRT2.

The Number value for the square root of 2, which is approximately
1.4142135623730951.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Each of the following MATH object functions applies the ToNumber
abstract operator to each of its arguments (in left-to-right order if
there is more than one) and then performs a computation on the resulting
Number value(s).

In the function descriptions below, the symbols NaN, −0, +0, −∞ and +∞
refer to the Number values described in 8.5.

NOTE The behaviour of the functions ACOS, ASIN, ATAN, ATAN2, COS, EXP,
LOG, POW, SIN, SQRT, and TAN is not precisely specified here except to
require specific results for certain argument values that represent
boundary cases of interest. For other argument values, these functions
are intended to compute approximations to the results of familiar
mathematical functions, but some latitude is allowed in the choice of
approximation algorithms. The general intent is that an implementer
should be able to use the same mathematical library for ECMAScript on a
given hardware platform that is available to C programmers on that
platform.

Although the choice of algorithms is left to the implementation, it is
recommended (but not specified by this standard) that implementations
use the approximation algorithms for IEEE 754 arithmetic contained in
FDLIBM, the freely distributable mathematical library from Sun
Microsystems (http://www.netlib.org/fdlibm).

Returns the absolute value of x; the result has the same magnitude as
x but has positive sign.

-   If x is NaN, the result is NaN.

-   If x is −0, the result is +0.

-   If x is −∞, the result is +∞.

Returns an implementation-dependent approximation to the arc cosine of
x. The result is expressed in radians and ranges from +0 to +π.

-   If x is NaN, the result is NaN.

-   If x is greater than 1, the result is NaN.

-   If x is less than −1, the result is NaN.

-   If x is exactly 1, the result is +0.

Returns an implementation-dependent approximation to the arc sine of
x. The result is expressed in radians and ranges from −π/2 to +π/2.

-   If x is NaN, the result is NaN.

-   If x is greater than 1, the result is NaN.

-   If x is less than –1, the result is NaN.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

Returns an implementation-dependent approximation to the arc tangent of
x. The result is expressed in radians and ranges from −π/2 to +π/2.

-   If x is NaN, the result is NaN.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

-   If x is +∞, the result is an implementation-dependent
      approximation to +π/2.

-   If x is −∞, the result is an implementation-dependent
      approximation to −π/2.

Returns an implementation-dependent approximation to the arc tangent of
the quotient y_/_x of the arguments y and x, where the signs of
y and x are used to determine the quadrant of the result. Note that
it is intentional and traditional for the two-argument arc tangent
function that the argument named y be first and the argument named x
be second. The result is expressed in radians and ranges from −π to +π.

-   If either x or y is NaN, the result is NaN.

-   If y>0 and x is +0, the result is an implementation-dependent
      approximation to +π/2.

-   If y>0 and x is −0, the result is an implementation-dependent
      approximation to +π/2.

-   If y is +0 and x>0, the result is +0.

-   If y is +0 and x is +0, the result is +0.

-   If y is +0 and x is −0, the result is an
      implementation-dependent approximation to +π.

-   If y is +0 and x<0, the result is an implementation-dependent
      approximation to +π.

-   If y is −0 and x>0, the result is −0.

-   If y is −0 and x is +0, the result is −0.

-   If y is −0 and x is −0, the result is an
      implementation-dependent approximation to −π.

-   If y is −0 and x<0, the result is an implementation-dependent
      approximation to −π.

-   If y<0 and x is +0, the result is an implementation-dependent
      approximation to −π/2.

-   If y<0 and x is −0, the result is an implementation-dependent
      approximation to −π/2.

-   If y>0 and y is finite and x is +∞, the result is +0.

-   If y>0 and y is finite and x is −∞, the result if an
      implementation-dependent approximation to +π.

-   If y<0 and y is finite and x is +∞, the result is −0.

-   If y<0 and y is finite and x is −∞, the result is an
      implementation-dependent approximation to −π.

-   If y is +∞ and x is finite, the result is an
      implementation-dependent approximation to +π/2.

-   If y is −∞ and x is finite, the result is an
      implementation-dependent approximation to −π/2.

-   If y is +∞ and x is +∞, the result is an
      implementation-dependent approximation to +π/4.

-   If y is +∞ and x is −∞, the result is an
      implementation-dependent approximation to +3π/4.

-   If y is −∞ and x is +∞, the result is an
      implementation-dependent approximation to −π/4.

-   If y is −∞ and x is −∞, the result is an
      implementation-dependent approximation to −3π/4.

Returns the smallest (closest to −∞) Number value that is not less than
x and is equal to a mathematical integer. If x is already an
integer, the result is x.

-   If x is NaN, the result is NaN.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

-   If x is +∞, the result is +∞.

-   If x is −∞, the result is −∞.

-   If x is less than 0 but greater than -1, the result is −0.

The value of MATH.CEIL(X) is the same as the value of -MATH.FLOOR(-X).

Returns an implementation-dependent approximation to the cosine of x.
The argument is expressed in radians.

-   If x is NaN, the result is NaN.

-   If x is +0, the result is 1.

-   If x is −0, the result is 1.

-   If x is +∞, the result is NaN.

-   If x is −∞, the result is NaN.

Returns an implementation-dependent approximation to the exponential
function of x (e raised to the power of x, where e is the base
of the natural logarithms).

-   If x is NaN, the result is NaN.

-   If x is +0, the result is 1.

-   If x is −0, the result is 1.

-   If x is +∞, the result is +∞.

-   If x is −∞, the result is +0.

Returns the greatest (closest to +∞) Number value that is not greater
than x and is equal to a mathematical integer. If x is already an
integer, the result is x.

-   If x is NaN, the result is NaN.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

-   If x is +∞, the result is +∞.

-   If x is −∞, the result is −∞.

-   If x is greater than 0 but less than 1, the result is +0.

NOTE The value of MATH.FLOOR(X) is the same as the value of
-MATH.CEIL(-X).

-   Returns an implementation-dependent approximation to the natural
      logarithm of x.

-   If x is NaN, the result is NaN.

-   If x is less than 0, the result is NaN.

-   If x is +0 or −0, the result is −∞.

-   If x is 1, the result is +0.

-   If x is +∞, the result is +∞.

Given zero or more arguments, calls ToNumber on each of the arguments
and returns the largest of the resulting values.

-   If no arguments are given, the result is −∞.

-   If any value is NaN, the result is NaN.

-   The comparison of values to determine the largest value is done
      using the Abstract Relational Comparision Alogrithm ( 11.8.1)
      except that +0 is considered to be larger than −0.

The LENGTH property of the MAX method is 2.

Given zero or more arguments, calls ToNumber on each of the arguments
and returns the smallest of the resulting values.

-   If no arguments are given, the result is +∞.

-   If any value is NaN, the result is NaN.

-   The comparison of values to determine the smallest value is done
      using the Abstract Relational Comparision Alogrithm (11.8.1)
      except that +0 is considered to be larger than −0.

The LENGTH property of the MIN method is 2.

Returns an implementation-dependent approximation to the result of
raising x to the power y.

-   If y is NaN, the result is NaN.

-   If y is +0, the result is 1, even if x is NaN.

-   If y is −0, the result is 1, even if x is NaN.

-   If x is NaN and y is nonzero, the result is NaN.

-   If abs(x)>1 and y is +∞, the result is +∞.

-   If abs(x)>1 and y is −∞, the result is +0.

-   If abs(x)==1 and y is +∞, the result is NaN.

-   If abs(x)==1 and y is −∞, the result is NaN.

-   If abs(x)<1 and y is +∞, the result is +0.

-   If abs(x)<1 and y is −∞, the result is +∞.

-   If x is +∞ and y>0, the result is +∞.

-   If x is +∞ and y<0, the result is +0.

-   If x is −∞ and y>0 and y is an odd integer, the result is −∞.

-   If x is −∞ and y>0 and y is not an odd integer, the result
      is +∞.

-   If x is −∞ and y<0 and y is an odd integer, the result is −0.

-   If x is −∞ and y<0 and y is not an odd integer, the result
      is +0.

-   If x is +0 and y>0, the result is +0.

-   If x is +0 and y<0, the result is +∞.

-   If x is −0 and y>0 and y is an odd integer, the result is −0.

-   If x is −0 and y>0 and y is not an odd integer, the result
      is +0.

-   If x is −0 and y<0 and y is an odd integer, the result is −∞.

-   If x is −0 and y<0 and y is not an odd integer, the result
      is +∞.

-   If x<0 and x is finite and y is finite and y is not an
      integer, the result is NaN.

Returns a Number value with positive sign, greater than or equal to 0
but less than 1, chosen randomly or pseudo randomly with approximately
uniform distribution over that range, using an implementation-dependent
algorithm or strategy. This function takes no arguments.

Returns the Number value that is closest to x and is equal to a
mathematical integer. If two integer Number values are equally close to
x, then the result is the Number value that is closer to +∞. If x is
already an integer, the result is x.

-   If x is NaN, the result is NaN.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

-   If x is +∞, the result is +∞.

-   If x is −∞, the result is −∞.

-   If x is greater than 0 but less than 0.5, the result is +0.

-   If x is less than 0 but greater than or equal to -0.5, the result
      is −0.

NOTE 1 MATH.ROUND(3.5) returns 4, but MATH.ROUND(–3.5) returns –3.

NOTE 2 The value of MATH.ROUND(X) is the same as the value of
MATH.FLOOR(X+0.5), except when X is −0 or is less than 0 but greater
than or equal to -0.5; for these cases MATH.ROUND(X) returns −0, but
MATH.FLOOR(X+0.5) returns +0.

Returns an implementation-dependent approximation to the sine of x.
The argument is expressed in radians.

-   If x is NaN, the result is NaN.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

-   If x is +∞ or −∞, the result is NaN.

Returns an implementation-dependent approximation to the square root of
x.

-   If x is NaN, the result is NaN.

-   If x is less than 0, the result is NaN.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

-   If x is +∞, the result is +∞.

Returns an implementation-dependent approximation to the tangent of x.
The argument is expressed in radians.

-   If x is NaN, the result is NaN.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

-   If x is +∞ or −∞, the result is NaN.

The following functions are abstract operations that operate on time
values (defined in 15.9.1.1). Note that, in every case, if any argument
to one of these functions is NAN, the result will be NAN.

A Date object contains a Number indicating a particular instant in time
to within a millisecond. Such a Number is called a _time value_. A time
value may also be NAN, indicating that the Date object does not
represent a specific instant of time.

Time is measured in ECMAScript in milliseconds since 01 January, 1970
UTC. In time values leap seconds are ignored. It is assumed that there
are exactly 86,400,000 milliseconds per day. ECMAScript Number values
can represent all integers from –9,007,199,254,740,992 to
9,007,199,254,740,992; this range suffices to measure times to
millisecond precision for any instant that is within approximately
285,616 years, either forward or backward, from 01 January, 1970 UTC.

The actual range of times supported by ECMAScript Date objects is
slightly smaller: exactly –100,000,000 days to 100,000,000 days measured
relative to midnight at the beginning of 01 January, 1970 UTC. This
gives a range of 8,640,000,000,000,000 milliseconds to either side of 01
January, 1970 UTC.

The exact moment of midnight at the beginning of 01 January, 1970 UTC is
represented by the value +0.

A given time value t belongs to day number

  Day(t) = floor(t / msPerDay)

where the number of milliseconds per day is

  msPerDay = 86400000

The remainder is called the time within the day:

  TimeWithinDay(t) = t modulo msPerDay

ECMAScript uses an extrapolated Gregorian system to map a day number to
a year number and to determine the month and date within that year. In
this system, leap years are precisely those which are (divisible by 4)
and ((not divisible by 100) or (divisible by 400)). The number of days
in year number y is therefore defined by

  DaysInYear(y) = 365 if (y modulo 4) ≠ 0
  = 366 if (y modulo 4) = 0 and (y modulo 100) ≠ 0
  = 365 if (y modulo 100) = 0 and (y modulo 400) ≠ 0
  = 366 if (y modulo 400) = 0

All non-leap years have 365 days with the usual number of days per month
and leap years have an extra day in February. The day number of the
first day of year y is given by:

  DayFromYear(y) = 365 × (y−1970) + floor((y−1969)/4) −
  floor((y−1901)/100) + floor((y−1601)/400)

The time value of the start of a year is:

  TimeFromYear(y) = msPerDay × DayFromYear(y)

A time value determines a year by:

  YearFromTime(t) = the largest integer y (closest to positive
  infinity) such that TimeFromYear(y) ≤ t

The leap-year function is 1 for a time within a leap year and otherwise
is zero:

  InLeapYear(t) = 0 if DaysInYear(YearFromTime(t)) = 365
  = 1 if DaysInYear(YearFromTime(t)) = 366

Months are identified by an integer in the range 0 to 11, inclusive. The
mapping MonthFromTime(t) from a time value t to a month number is
defined by:

  MonthFromTime(t) = 0 if 0 ≤ DayWithinYear(t) < 31
   = 1 if 31 ≤ DayWithinYear (t) < 59+InLeapYear(t)
   = 2 if 59+InLeapYear(t) ≤ DayWithinYear (t) < 90+InLeapYear(t)
   = 3 if 90+InLeapYear(t) ≤ DayWithinYear (t) < 120+InLeapYear(t)
   = 4 if 120+InLeapYear(t) ≤ DayWithinYear (t) <
  151+InLeapYear(t)
   = 5 if 151+InLeapYear(t) ≤ DayWithinYear (t) <
  181+InLeapYear(t)
   = 6 if 181+InLeapYear(t) ≤ DayWithinYear (t) <
  212+InLeapYear(t)
   = 7 if 212+InLeapYear(t) ≤ DayWithinYear (t) <
  243+InLeapYear(t)
   = 8 if 243+InLeapYear(t) ≤ DayWithinYear (t) <
  273+InLeapYear(t)
   = 9 if 273+InLeapYear(t) ≤ DayWithinYear (t) <
  304+InLeapYear(t)
   = 10 if 304+InLeapYear(t) ≤ DayWithinYear (t) <
  334+InLeapYear(t)
   = 11 if 334+InLeapYear(t) ≤ DayWithinYear (t) <
  365+InLeapYear(t)

where

  DayWithinYear(t) = Day(t_)−DayFromYear(YearFromTime(_t))

A month value of 0 specifies January; 1 specifies February; 2 specifies
March; 3 specifies April; 4 specifies May; 5 specifies June; 6 specifies
July; 7 specifies August; 8 specifies September; 9 specifies October; 10
specifies November; and 11 specifies December. Note that
MonthFromTime(0) = 0, corresponding to Thursday, 01 January, 1970.

A date number is identified by an integer in the range 1 through 31,
inclusive. The mapping DateFromTime(t) from a time value t to a
month number is defined by:

  DateFromTime(t) = DayWithinYear(t)+1 if MonthFromTime(t)=0
   = DayWithinYear(t)−30 if MonthFromTime(t)=1
   = DayWithinYear(t_)−58−InLeapYear(_t) if MonthFromTime(t)=2
   = DayWithinYear(t_)−89−InLeapYear(_t) if MonthFromTime(t)=3
   = DayWithinYear(t_)−119−InLeapYear(_t) if MonthFromTime(t)=4
   = DayWithinYear(t_)−150−InLeapYear(_t) if MonthFromTime(t)=5
   = DayWithinYear(t_)−180−InLeapYear(_t) if MonthFromTime(t)=6
   = DayWithinYear(t_)−211−InLeapYear(_t) if MonthFromTime(t)=7
   = DayWithinYear(t_)−242−InLeapYear(_t) if MonthFromTime(t)=8
   = DayWithinYear(t_)−272−InLeapYear(_t) if MonthFromTime(t)=9
   = DayWithinYear(t_)−303−InLeapYear(_t) if MonthFromTime(t)=10
   = DayWithinYear(t_)−333−InLeapYear(_t) if MonthFromTime(t)=11

The weekday for a particular time value t is defined as

  WeekDay(t) = (Day(t) + 4) modulo 7

A weekday value of 0 specifies Sunday; 1 specifies Monday; 2 specifies
Tuesday; 3 specifies Wednesday; 4 specifies Thursday; 5 specifies
Friday; and 6 specifies Saturday. Note that WeekDay(0) = 4,
corresponding to Thursday, 01 January, 1970.

An implementation of ECMAScript is expected to determine the local time
zone adjustment. The local time zone adjustment is a value LocalTZA
measured in milliseconds which when added to UTC represents the local
standard time. Daylight saving time is not reflected by LocalTZA.
The value LocalTZA does not vary with time but depends only on the
geographic location.

An implementation of ECMAScript is expected to determine the daylight
saving time algorithm. The algorithm to determine the daylight saving
time adjustment DaylightSavingTA(t), measured in milliseconds, must
depend only on four things:

(1) the time since the beginning of the year

  t – TimeFromYear(YearFromTime(t))

(2) whether t is in a leap year

  InLeapYear(t)

(3) the week day of the beginning of the year

  WeekDay(TimeFromYear(YearFromTime(t)))

and (4) the geographic location.

The implementation of ECMAScript should not try to determine whether the
exact time was subject to daylight saving time, but just whether
daylight saving time would have been in effect if the current daylight
saving time algorithm had been used at the time. This avoids
complications such as taking into account the years that the locale
observed daylight saving time year round.

If the host environment provides functionality for determining daylight
saving time, the implementation of ECMAScript is free to map the year in
question to an equivalent year (same leap-year-ness and same starting
week day for the year) for which the host environment provides daylight
saving time information. The only restriction is that all equivalent
years should produce the same result.

Conversion from UTC to local time is defined by

  LocalTime(t) = t + LocalTZA + DaylightSavingTA(t)

Conversion from local time to UTC is defined by

  UTC(t) = t – LocalTZA – DaylightSavingTA(t – LocalTZA)

Note that UTC(LocalTime(t)) is not necessarily always equal to t.

The following functions are useful in decomposing time values:

  HourFromTime(t) = floor(t / msPerHour) modulo HoursPerDay

  MinFromTime(t) = floor(t / msPerMinute) modulo MinutesPerHour

  SecFromTime(t) = floor(t / msPerSecond) modulo SecondsPerMinute

  msFromTime(t) = t modulo msPerSecond

where

  HoursPerDay = 24

  MinutesPerHour = 60

  SecondsPerMinute = 60

  msPerSecond = 1000

  msPerMinute = 60000 = msPerSecond × SecondsPerMinute

  msPerHour = 3600000 = msPerMinute × MinutesPerHour

The operator MakeTime calculates a number of milliseconds from its four
arguments, which must be ECMAScript Number values. This operator
functions as follows:

The operator MakeDay calculates a number of days from its three
arguments, which must be ECMAScript Number values. This operator
functions as follows:

The operator MakeDate calculates a number of milliseconds from its two
arguments, which must be ECMAScript Number values. This operator
functions as follows:

The operator TimeClip calculates a number of milliseconds from its
argument, which must be an ECMAScript Number value. This operator
functions as follows:

NOTE The point of step 3 is that an implementation is permitted a choice
of internal representations of time values, for example as a 64-bit
signed integer or as a 64-bit floating-point value. Depending on the
implementation, this internal representation may or may not distinguish
−0 and +0.

ECMAScript defines a string interchange format for date-times based upon
a simplification of the ISO 8601 Extended Format. The format is as
follows: YYYY-MM-DDTHH:MM:SS.SSSZ

Where the fields are as follows:

This format includes date-only forms:

YYYY
YYYY-MM
YYYY-MM-DD

It also includes “date-time” forms that consist of one of the above
date-only forms immediately followed by one of the following time forms
with an optional time zone offset appended:

THH:MM
THH:MM:SS
THH:MM:SS.SSS

All numbers must be base 10. If the MM or DD fields are absent “01” is
used as the value. If the HH, MM, or SS fields are absent “00” is used
as the value and the value of an absent SSS field is “000”. If the time
zone offset is absent, the date-time is in interpreted as a local time.

Illegal values (out-of-bounds as well as syntax errors) in a format
string means that the format string is not a valid instance of this
format.

NOTE 1 As every day both starts and ends with midnight, the two
notations 00:00 and 24:00 are available to distinguish the two midnights
that can be associated with one date. This means that the following two
notations refer to exactly the same point in time: 1995-02-04T24:00 and
1995-02-05T00:00

NOTE 2 There exists no international standard that specifies
abbreviations for civil time zones like CET, EST, etc. and sometimes the
same abbreviation is even used for two very different time zones. For
this reason, ISO 8601 and this format specifies numeric representations
of date and time.

ECMAScript requires the ability to specify 6 digit years (extended
years); approximately 285,426 years, either forward or backward, from 01
January, 1970 UTC. To represent years before 0 or after 9999, ISO 8601
permits the expansion of the year representation, but only by prior
agreement between the sender and the receiver. In the simplified
ECMAScript format such an expanded year representation shall have 2
extra year digits and is always prefixed with a + or – sign. The year 0
is considered positive and hence prefixed with a + sign.

NOTE Examples of extended years:

  -283457-03-21T15:00:59.008Z   283458 B.C.
  -000001-01-01T00:00:00Z          2 B.C.
  +000000-01-01T00:00:00Z         1 B.C.
  +000001-01-01T00:00:00Z         1 A.D.
  +001970-01-01T00:00:00Z         1970 A.D.
  +002009-12-15T00:00:00Z         2009 A.D.
  +287396-10-12T08:59:00.992Z 287396 A.D.

When DATE is called as a function rather than as a constructor, it
returns a String representing the current time (UTC).

NOTE The function call DATE(…) is not equivalent to the object creation
expression NEW DATE(…) with the same arguments.

All of the arguments are optional; any arguments supplied are accepted
but are completely ignored. A String is created and returned as if by
the expression (NEW DATE()).TOSTRING() where DATE is the standard
built-in constructor with that name and TOSTRING is the standard
built-in method DATE.PROTOTYPE.TOSTRING.

When DATE is called as part of a NEW expression, it is a constructor: it
initialises the newly created object.

When DATE is called with two to seven arguments, it computes the date
from year, month, and (optionally) date, hours, minutes,
seconds and ms.

The [[Prototype]] internal property of the newly constructed object is
set to the original Date prototype object, the one that is the initial
value of DATE.PROTOTYPE (15.9.4.1).

The newly constructed object has a [[NativeBrand]] internal property
whose value is NativeDate.

The [[Extensible]] internal property of the newly constructed object is
set to TRUE.

The [[PrimitiveValue]] internal property of the newly constructed object
is set as follows:

The [[Prototype]] internal property of the newly constructed object is
set to the original Date prototype object, the one that is the initial
value of DATE.PROTOTYPE (15.9.4.1).

The newly constructed object has a [[NativeBrand]] internal property
whose value is NativeDate.

The [[Extensible]] internal property of the newly constructed object is
set to TRUE.

The [[PrimitiveValue]] internal property of the newly constructed object
is set as follows:

The [[Prototype]] internal property of the newly constructed object is
set to the original Date prototype object, the one that is the initial
value of DATE.PROTOTYPE (15.9.4.1).

The newly constructed object has a [[NativeBrand]] internal property
whose value is NativeDate.

The [[Extensible]] internal property of the newly constructed object is
set to TRUE.

The [[PrimitiveValue]] internal property of the newly constructed object
is set to the time value (UTC) identifying the current time.

The value of the [[Prototype]] internal property of the Date constructor
is the Function prototype object (15.3.4).

Besides the internal properties and the LENGTH property (whose value is
7), the Date constructor has the following properties:

The initial value of DATE.PROTOTYPE is the built-in Date prototype
object (15.9.5).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

The PARSE function applies the ToString operator to its argument and
interprets the resulting String as a date and time; it returns a Number,
the UTC time value corresponding to the date and time. The String may be
interpreted as a local time, a UTC time, or a time in some other time
zone, depending on the contents of the String. The function first
attempts to parse the format of the String according to the rules called
out in Date Time String Format (15.9.1.15). If the String does not
conform to that format the function may fall back to any
implementation-specific heuristics or implementation-specific date
formats. Unrecognisable Strings or dates containing illegal element
values in the format String shall cause DATE.PARSE to return NAN.

If x is any Date object whose milliseconds amount is zero within a
particular implementation of ECMAScript, then all of the following
expressions should produce the same numeric value in that
implementation, if all the properties referenced have their initial
values:

  X.VALUEOF()

  DATE.PARSE(X.TOSTRING())

  DATE.PARSE(X.TOUTCSTRING())

  DATE.PARSE(X.TOISOSTRING())

However, the expression

  DATE.PARSE(x.TOLOCALESTRING())

is not required to produce the same Number value as the preceding three
expressions and, in general, the value produced by DATE.PARSE is
implementation-dependent when given any String value that does not
conform to the Date Time String Format (15.9.1.15) and that could not be
produced in that implementation by the TOSTRING or TOUTCSTRING method.

When the UTC function is called with fewer than two arguments, the
behaviour is implementation-dependent. When the UTC function is called
with two to seven arguments, it computes the date from year, month
and (optionally) date, hours, minutes, seconds and ms. The
following steps are taken:

The LENGTH property of the UTC function is 7.

NOTE The UTC function differs from the Date constructor in two ways: it
returns a time value as a Number, rather than creating a Date object,
and it interprets the arguments in UTC rather than as local time.

The NOW function return a Number value that is the time value
designating the UTC date and time of the occurrence of the call to NOW.

The Date prototype object is itself a Date object and has a
[[NativeBrand]] internal property whose value is NativeDate. Its
[[PrimitiveValue]] is NAN.

The value of the [[Prototype]] internal property of the Date prototype
object is the standard built-in Object prototype object (15.2.4).

In following descriptions of functions that are properties of the Date
prototype object, the phrase “this Date object” refers to the object
that is the THIS value for the invocation of the function. Unless
explicitly noted otherwise, none of these functions are generic; a
TYPEERROR exception is thrown if the THIS value is not an object with a
[[NativeBrand]] internal property whose value is NativeDate. Also, the
phrase “this time value” refers to the Number value for the time
represented by this Date object, that is, the value of the
[[PrimitiveValue]] internal property of this Date object.

The initial value of DATE.PROTOTYPE.CONSTRUCTOR is the built-in DATE
constructor.

This function returns a String value. The contents of the String are
implementation-dependent, but are intended to represent the Date in the
current time zone in a convenient, human-readable form.

NOTE For any Date value d whose milliseconds amount is zero, the
result of Date.parse(d.toString()) is equal to d.valueOf(). See
15.9.4.2.

This function returns a String value. The contents of the String are
implementation-dependent, but are intended to represent the “date”
portion of the Date in the current time zone in a convenient,
human-readable form.

This function returns a String value. The contents of the String are
implementation-dependent, but are intended to represent the “time”
portion of the Date in the current time zone in a convenient,
human-readable form.

This function returns a String value. The contents of the String are
implementation-dependent, but are intended to represent the Date in the
current time zone in a convenient, human-readable form that corresponds
to the conventions of the host environment’s current locale.

NOTE The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that implementations
do not use this parameter position for anything else.

This function returns a String value. The contents of the String are
implementation-dependent, but are intended to represent the “date”
portion of the Date in the current time zone in a convenient,
human-readable form that corresponds to the conventions of the host
environment’s current locale.

NOTE The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that implementations
do not use this parameter position for anything else.

This function returns a String value. The contents of the String are
implementation-dependent, but are intended to represent the “time”
portion of the Date in the current time zone in a convenient,
human-readable form that corresponds to the conventions of the host
environment’s current locale.

NOTE The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that implementations
do not use this parameter position for anything else.

The VALUEOF function returns a Number, which is this time value.

Returns the difference between local time and UTC time in minutes.

If ms is not specified, this behaves as if ms were specified with
the value GETMILLISECONDS().

The LENGTH property of the SETSECONDS method is 2.

If ms is not specified, this behaves as if ms were specified with
the value GETUTCMILLISECONDS().

The LENGTH property of the SETUTCSECONDS method is 2.

If sec is not specified, this behaves as if sec were specified with
the value GETSECONDS().

If ms is not specified, this behaves as if ms were specified with
the value GETMILLISECONDS().

The LENGTH property of the SETMINUTES method is 3.

If sec is not specified, this behaves as if sec were specified with
the value GETUTCSECONDS().

If ms is not specified, this function behaves as if ms were
specified with the value return by GETUTCMILLISECONDS().

The LENGTH property of the SETUTCMINUTES method is 3.

If min is not specified, this behaves as if min were specified with
the value GETMINUTES().

If sec is not specified, this behaves as if sec were specified with
the value GETSECONDS().

If ms is not specified, this behaves as if ms were specified with
the value GETMILLISECONDS().

The LENGTH property of the SETHOURS method is 4.

If min is not specified, this behaves as if min were specified with
the value GETUTCMINUTES().

If sec is not specified, this behaves as if sec were specified with
the value GETUTCSECONDS().

If ms is not specified, this behaves as if ms were specified with
the value GETUTCMILLISECONDS().

The LENGTH property of the SETUTCHOURS method is 4.

If date is not specified, this behaves as if date were specified
with the value GETDATE().

The LENGTH property of the SETMONTH method is 2.

If date is not specified, this behaves as if date were specified
with the value GETUTCDATE().

The LENGTH property of the SETUTCMONTH method is 2.

If month is not specified, this behaves as if month were specified
with the value GETMONTH().

If date is not specified, this behaves as if date were specified
with the value GETDATE().

The LENGTH property of the SETFULLYEAR method is 3.

If month is not specified, this behaves as if month were specified
with the value GETUTCMONTH().

If date is not specified, this behaves as if date were specified
with the value GETUTCDATE().

The LENGTH property of the SETUTCFULLYEAR method is 3.

This function returns a String value. The contents of the String are
implementation-dependent, but are intended to represent the Date in a
convenient, human-readable form in UTC.

NOTE The intent is to produce a String representation of a date that is
more readable than the format specified in 15.9.1.15. It is not
essential that the chosen format be unambiguous or easily machine
parsable. If an implementation does not have a preferred human-readable
format it is recommended to use the format defined in 15.9.1.15 but with
a space rather than a “T” used to separate the date and time elements.

This function returns a String value represent the instance in time
represented by this Date object. The format of the String is the Date
Time string format defined in 15.9.1.15. All fields are present in the
String. The time zone is always UTC, denoted by the suffix Z. If the
time value of this object is not a finite Number a RANGEERROR exception
is thrown.

This function provides a String representation of a Date object for use
by JSON.STRINGIFY (15.12.3).

When the TOJSON method is called with argument key, the following
steps are taken:

NOTE 1 The argument is ignored.

NOTE 2 The TOJSON function is intentionally generic; it does not require
that its THIS value be a Date object. Therefore, it can be transferred
to other kinds of objects for use as a method. However, it does require
that any such object have a TOISOSTRING method. An object is free to use
the argument key to filter its stringification.

Date instances inherit properties from the Date prototype object and
have a [[NativeBrand]] internal whose value is NativeDate. Date
instances also have a [[PrimitiveValue]] internal property.

The [[PrimitiveValue]] internal property is time value represented by
this Date object.

A RegExp object contains a regular expression and the associated flags.

NOTE The form and functionality of regular expressions is modelled after
the regular expression facility in the Perl 5 programming language.

The REGEXP constructor applies the following grammar to the input
pattern String. An error occurs if the grammar cannot interpret the
String as an expansion of Pattern.

Syntax

Pattern ::

Disjunction

Disjunction ::

Alternative
 Alternative | Disjunction

Alternative ::

[empty]
Alternative Term

Term ::

Assertion
Atom
Atom Quantifier

Assertion ::

^
$
\ B
\ B
( ? = Disjunction )
( ? ! Disjunction )

Quantifier ::

QuantifierPrefix
QuantifierPrefix ?

QuantifierPrefix ::

*
+
?
{ DecimalDigits }
{ DecimalDigits , }
{ DecimalDigits , DecimalDigits }

Atom ::

PatternCharacter
.
\ AtomEscape
CharacterClass
( Disjunction )
( ? : Disjunction )

PatternCharacter ::

SourceCharacter BUT NOT ONE OF
 ^ $ \ . * + ? ( ) [ ] { } |

AtomEscape ::

DecimalEscape
CharacterEscape
CharacterClassEscape

CharacterEscape ::

ControlEscape
C ControlLetter
HexEscapeSequence
UnicodeEscapeSequence
IdentityEscape

ControlEscape :: ONE OF

F N R T V

ControlLetter :: ONE OF

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

IdentityEscape ::

SourceCharacter BUT NOT IdentifierPart
<ZWJ>
<ZWNJ>

DecimalEscape ::

DecimalIntegerLiteral [lookahead ∉ DecimalDigit]

CharacterClassEscape :: ONE OF

D D S S W W

CharacterClass ::

[ [lookahead ∉ {^}] ClassRanges ]
[ ^ ClassRanges ]

ClassRanges ::

[empty]
NonemptyClassRanges

NonemptyClassRanges ::

ClassAtom
ClassAtom NonemptyClassRangesNoDash
ClassAtom - ClassAtom ClassRanges

NonemptyClassRangesNoDash ::

ClassAtom
ClassAtomNoDash NonemptyClassRangesNoDash
ClassAtomNoDash - ClassAtom ClassRanges

ClassAtom ::

-
ClassAtomNoDash

ClassAtomNoDash ::

SourceCharacter BUT NOT ONE OF \ OR ] OR -
\ ClassEscape

ClassEscape ::

DecimalEscape
B
CharacterEscape
CharacterClassEscape

A regular expression pattern is converted into an internal procedure
using the process described below. An implementation is encouraged to
use more efficient algorithms than the ones listed below, as long as the
results are the same. The internal procedure is used as the value of a
RegExp object’s [[Match]] internal property.

The descriptions below use the following variables:

-   Input is the String being matched by the regular expression
      pattern. The notation input_[_n] means the n^th^ character of
      input, where n can range between 0 (inclusive) and
      InputLength (exclusive).

-   InputLength is the number of characters in the Input String.

-   NcapturingParens is the total number of left capturing parentheses
      (i.e. the total number of times the Atom :: ( Disjunction )
      production is expanded) in the pattern. A left capturing
      parenthesis is any ( pattern character that is matched by the (
      terminal of the Atom :: ( Disjunction ) production.

-   IgnoreCase is the setting of the RegExp object's IGNORECASE
      property.

-   Multiline is the setting of the RegExp object’s MULTILINE
      property.

Furthermore, the descriptions below use the following internal data
structures:

-   A CharSet is a mathematical set of characters.

-   A State is an ordered pair (endIndex, captures) where
      endIndex is an integer and captures is an internal array of
      NcapturingParens values. States are used to represent partial
      match states in the regular expression matching algorithms. The
      endIndex is one plus the index of the last input character
      matched so far by the pattern, while captures holds the results
      of capturing parentheses. The n^th^ element of captures is
      either a String that represents the value obtained by the n^th^
      set of capturing parentheses or UNDEFINED if the n^th^ set of
      capturing parentheses hasn’t been reached yet. Due to
      backtracking, many States may be in use at any time during the
      matching process.

-   A MatchResult is either a State or the special token FAILURE
      that indicates that the match failed.

-   A Continuation procedure is an internal closure (i.e. an internal
      procedure with some arguments already bound to values) that takes
      one State argument and returns a MatchResult result. If an
      internal closure references variables bound in the function that
      creates the closure, the closure uses the values that these
      variables had at the time the closure was created. The
      Continuation attempts to match the remaining portion (specified
      by the closure's already-bound arguments) of the pattern against
      the input String, starting at the intermediate state given by its
      State argument. If the match succeeds, the Continuation
      returns the final State that it reached; if the match fails, the
      Continuation returns FAILURE.

-   A Matcher procedure is an internal closure that takes two
      arguments -- a State and a Continuation -- and returns a
      MatchResult result. A Matcher attempts to match a middle
      subpattern (specified by the closure's already-bound arguments) of
      the pattern against the input String, starting at the intermediate
      state given by its State argument. The Continuation argument
      should be a closure that matches the rest of the pattern. After
      matching the subpattern of a pattern to obtain a new State, the
      Matcher then calls Continuation on that new State to test if
      the rest of the pattern can match as well. If it can, the
      Matcher returns the State returned by Continuation; if not,
      the Matcher may try different choices at its choice points,
      repeatedly calling Continuation until it either succeeds or all
      possibilities have been exhausted.

-   An AssertionTester procedure is an internal closure that takes a
      State argument and returns a Boolean result. The assertion
      tester tests a specific condition (specified by the closure's
      already-bound arguments) against the current place in the input
      String and returns TRUE if the condition matched or FALSE if not.

-   An EscapeValue is either a character or an integer. An
      EscapeValue is used to denote the interpretation of a
      DecimalEscape escape sequence: a character ch means that the
      escape sequence is interpreted as the character ch, while an
      integer n means that the escape sequence is interpreted as a
      backreference to the n^th^ set of capturing parentheses.

The production Pattern :: Disjunction evaluates as follows:

1.  Let Input be the given String str. This variable will be used
      throughout the algorithms in 15.10.2.

2.  Let InputLength be the length of Input. This variable will be
      used throughout the algorithms in 15.10.2.

3.  Let c be a Continuation that always returns its State argument as
      a successful MatchResult.

4.  Let cap be an internal array of NcapturingParens UNDEFINED
      values, indexed 1 through NcapturingParens.

5.  Let x be the State (index, cap).

6.  Call m_(_x, c) and return its result.

NOTE A Pattern evaluates ("compiles") to an internal procedure value.
REGEXP.PROTOTYPE.EXEC can then apply this procedure to a String and an
offset within the String to determine whether the pattern would match
starting at exactly that offset within the String, and, if it does
match, what the values of the capturing parentheses would be. The
algorithms in 15.10.2 are designed so that compiling a pattern may throw
a SYNTAXERROR exception; on the other hand, once the pattern is
successfully compiled, applying its result internal procedure to find a
match in a String cannot throw an exception (except for any host-defined
exceptions that can occur anywhere such as out-of-memory).

The production Disjunction :: Alternative evaluates by evaluating
Alternative to obtain a Matcher and returning that Matcher.

The production Disjunction :: Alternative | Disjunction evaluates
as follows:

NOTE The | regular expression operator separates two alternatives. The
pattern first tries to match the left Alternative (followed by the
sequel of the regular expression); if it fails, it tries to match the
right Disjunction (followed by the sequel of the regular expression).
If the left Alternative, the right Disjunction, and the sequel all
have choice points, all choices in the sequel are tried before moving on
to the next choice in the left Alternative. If choices in the left
Alternative are exhausted, the right Disjunction is tried instead of
the left Alternative. Any capturing parentheses inside a portion of
the pattern skipped by | produce UNDEFINED values instead of Strings.
Thus, for example,

  /a|ab/.exec("abc")

returns the result "A" and not "AB". Moreover,

  /((a)|(ab))((c)|(bc))/.exec("abc")

returns the array

  ["abc", "a", "a", undefined, "bc", undefined, "bc"]

and not

  ["abc", "ab", undefined, "ab", "c", "c", undefined]

The production Alternative :: [empty] evaluates by returning a Matcher
that takes two arguments, a State x and a Continuation c, and
returns the result of calling c_(_x).

The production Alternative :: Alternative Term evaluates as
follows:

NOTE Consecutive Terms try to simultaneously match consecutive
portions of the input String. If the left Alternative, the right
Term, and the sequel of the regular expression all have choice points,
all choices in the sequel are tried before moving on to the next choice
in the right Term, and all choices in the right Term are tried
before moving on to the next choice in the left Alternative.

The production Term :: Assertion evaluates by returning an internal
Matcher closure that takes two arguments, a State x and a Continuation
c, and performs the following:

The production Term :: Atom evaluates by evaluating Atom to obtain
a Matcher and returning that Matcher.

The production Term :: Atom Quantifier evaluates as follows:

The abstract operation RepeatMatcher takes eight parameters, a Matcher
m, an integer min, an integer (or ∞) max, a Boolean greedy, a
State x, a Continuation c, an integer parenIndex, and an integer
parenCount, and performs the following:

NOTE 1 An Atom followed by a Quantifier is repeated the number of
times specified by the Quantifier. A Quantifier can be non-greedy,
in which case the Atom pattern is repeated as few times as possible
while still matching the sequel, or it can be greedy, in which case the
Atom pattern is repeated as many times as possible while still
matching the sequel. The Atom pattern is repeated rather than the
input String that it matches, so different repetitions of the Atom can
match different input substrings.

NOTE 2 If the Atom and the sequel of the regular expression all have
choice points, the Atom is first matched as many (or as few, if
non-greedy) times as possible. All choices in the sequel are tried
before moving on to the next choice in the last repetition of Atom.
All choices in the last (n^th^) repetition of Atom are tried before
moving on to the next choice in the next-to-last (n–1)^st^ repetition of
Atom; at which point it may turn out that more or fewer repetitions of
Atom are now possible; these are exhausted (again, starting with
either as few or as many as possible) before moving on to the next
choice in the (n-1)^st^ repetition of Atom and so on.

Compare

  /a[a-z]{2,4}/.exec("abcdefghi")

which returns "ABCDE" with

  /a[a-z]{2,4}?/.exec("abcdefghi")

which returns "ABC".

Consider also

  /(aa|aabaac|ba|b|c)*/.exec("aabaac")

which, by the choice point ordering above, returns the array

  ["aaba", "ba"]

and not any of:

  ["aabaac", "aabaac"]

  ["aabaac", "c"]

The above ordering of choice points can be used to write a regular
expression that calculates the greatest common divisor of two numbers
(represented in unary notation). The following example calculates the
gcd of 10 and 15:

  "aaaaaaaaaa,aaaaaaaaaaaaaaa".replace(/^(a+)\1*,\1+$/,"$1")

which returns the gcd in unary notation "AAAAA".

NOTE 3 Step 4 of the RepeatMatcher clears Atom's captures each time
Atom is repeated. We can see its behaviour in the regular expression

  /(z)((a+)?(b+)?(c))*/.exec("zaacbbbcac")

which returns the array

  ["zaacbbbcac", "z", "ac", "a", undefined, "c"]

and not

  ["zaacbbbcac", "z", "ac", "a", "bbb", "c"]

because each iteration of the outermost * clears all captured Strings
contained in the quantified Atom, which in this case includes capture
Strings numbered 2, 3, 4, and 5.

NOTE 4 Step 1 of the RepeatMatcher's d closure states that, once the
minimum number of repetitions has been satisfied, any more expansions of
Atom that match the empty String are not considered for further
repetitions. This prevents the regular expression engine from falling
into an infinite loop on patterns such as:

  /(a*)*/.exec("b")

or the slightly more complicated:

  /(a*)b\1+/.exec("baaaac")

which returns the array

  ["b", ""]

The production Assertion :: ^ evaluates by returning an internal
AssertionTester closure that takes a State argument x and performs the
following:

The production Assertion :: $ evaluates by returning an internal
AssertionTester closure that takes a State argument x and performs the
following:

The production Assertion :: \ B evaluates by returning an internal
AssertionTester closure that takes a State argument x and performs the
following:

The production Assertion :: \ B evaluates by returning an internal
AssertionTester closure that takes a State argument x and performs the
following:

The production Assertion :: ( ? = Disjunction ) evaluates as
follows:

The production Assertion :: ( ? ! Disjunction ) evaluates as
follows:

The abstract operation IsWordChar takes an integer parameter e and
performs the following:

  --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
  a   b   c   d   e   f   g   h   i   j   k   l   m   n   o   p   q   r   s   t   u   v   w   x   y   z
  A   B   C   D   E   F   G   H   I   J   K   L   M   N   O   P   Q   R   S   T   U   V   W   X   Y   Z
  0   1   2   3   4   5   6   7   8   9   _                                                           
  --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---

The production Quantifier :: QuantifierPrefix evaluates as follows:

The production Quantifier :: QuantifierPrefix ? evaluates as
follows:

The production QuantifierPrefix :: * evaluates by returning the two
results 0 and ∞.

The production QuantifierPrefix :: + evaluates by returning the two
results 1 and ∞.

The production QuantifierPrefix :: ? evaluates by returning the two
results 0 and 1.

The production QuantifierPrefix :: { DecimalDigits } evaluates as
follows:

The production QuantifierPrefix :: { DecimalDigits , } evaluates as
follows:

The production QuantifierPrefix :: { DecimalDigits , DecimalDigits
} evaluates as follows:

The production Atom :: PatternCharacter evaluates as follows:

The production Atom :: . evaluates as follows:

The production Atom :: \ AtomEscape evaluates by evaluating
AtomEscape to obtain a Matcher and returning that Matcher.

The production Atom :: CharacterClass evaluates as follows:

The production Atom :: ( Disjunction ) evaluates as follows:

The production Atom :: ( ? : Disjunction ) evaluates by evaluating
Disjunction to obtain a Matcher and returning that Matcher.

The abstract operation CharacterSetMatcher takes two arguments, a
CharSet A and a Boolean flag invert, and performs the following:

a.  If there exists a member a of set A such that
      Canonicalize_(_a) == cc, return FAILURE.

The abstract operation Canonicalize takes a character parameter ch
and performs the following steps:

NOTE 1 Parentheses of the form ( Disjunction ) serve both to group the
components of the Disjunction pattern together and to save the result
of the match. The result can be used either in a backreference (\
followed by a nonzero decimal number), referenced in a replace String,
or returned as part of an array from the regular expression matching
internal procedure. To inhibit the capturing behaviour of parentheses,
use the form (?: Disjunction ) instead.

NOTE 2 The form (?= Disjunction ) specifies a zero-width positive
lookahead. In order for it to succeed, the pattern inside Disjunction
must match at the current position, but the current position is not
advanced before matching the sequel. If Disjunction can match at the
current position in several ways, only the first one is tried. Unlike
other regular expression operators, there is no backtracking into a (?=
form (this unusual behaviour is inherited from Perl). This only matters
when the Disjunction contains capturing parentheses and the sequel of
the pattern contains backreferences to those captures.

For example,

  /(?=(a+))/.exec("baaabac")

matches the empty String immediately after the first B and therefore
returns the array:

  ["", "aaa"]

To illustrate the lack of backtracking into the lookahead, consider:

  /(?=(a+))a*b\1/.exec("baaabac")

This expression returns

  ["aba", "a"]

and not:

  ["aaaba", "a"]

NOTE 3 The form (?! Disjunction ) specifies a zero-width negative
lookahead. In order for it to succeed, the pattern inside Disjunction
must fail to match at the current position. The current position is not
advanced before matching the sequel. Disjunction can contain capturing
parentheses, but backreferences to them only make sense from within
Disjunction itself. Backreferences to these capturing parentheses from
elsewhere in the pattern always return UNDEFINED because the negative
lookahead must fail for the pattern to succeed. For example,

  /(.*?)a(?!(a+)b\2c)\2(.*)/.exec("baaabaac")

looks for an A not immediately followed by some positive number n of
A's, a B, another n A's (specified by the first \2) and a C. The second
\2 is outside the negative lookahead, so it matches against UNDEFINED
and therefore always succeeds. The whole expression returns the array:

  ["baaabaac", "ba", undefined, "abaac"]

In case-insignificant matches all characters are implicitly converted to
upper case immediately before they are compared. However, if converting
a character to upper case would expand that character into more than one
character (such as converting "SS" (\u00DF) into "SS"), then the
character is left as-is instead. The character is also left as-is if it
is not an ASCII character but converting it to upper case would make it
into an ASCII character. This prevents Unicode characters such as \u0131
and \u017F from matching regular expressions such as /[AZ]/I, which are
only intended to match ASCII letters. Furthermore, if these conversions
were allowed, then /[^\W]/I would match each of A, B, …, H, but not I or
S.

The production AtomEscape :: DecimalEscape evaluates as follows:

The production AtomEscape :: CharacterEscape evaluates as follows:

The production AtomEscape :: CharacterClassEscape evaluates as
follows:

NOTE An escape sequence of the form \ followed by a nonzero decimal
number n matches the result of the nth set of capturing parentheses
(see 15.10.2.11). It is an error if the regular expression has fewer
than n capturing parentheses. If the regular expression has n or
more capturing parentheses but the nth one is UNDEFINED because it has
not captured anything, then the backreference always succeeds.

The production CharacterEscape :: ControlEscape evaluates by
returning the character according to Table 25.

Table 25 — ControlEscape Character Values

  ------------------ ------------- ---------------------- ----------
  _CONTROLESCAPE _   _CODE UNIT_   NAME                 SYMBOL
  T                  \U0009        horizontal tab         <HT>
  N                  \U000A        line feed (new line)   <LF>
  V                  \U000B        vertical tab           <VT>
  F                  \U000C        form feed              <FF>
  R                  \U000D        carriage return        <CR>
  ------------------ ------------- ---------------------- ----------

The production CharacterEscape :: C ControlLetter evaluates as
follows:

The production CharacterEscape :: HexEscapeSequence evaluates by
evaluating the CV of the HexEscapeSequence (see 7.8.4) and returning
its character result.

The production CharacterEscape :: UnicodeEscapeSequence evaluates by
evaluating the CV of the UnicodeEscapeSequence (see 7.8.4) and
returning its character result.

The production CharacterEscape :: IdentityEscape evaluates by
returning the character represented by IdentityEscape.

The production DecimalEscape :: DecimalIntegerLiteral [lookahead ∉
DecimalDigit] evaluates as follows:

The definition of “the MV of DecimalIntegerLiteral” is in 7.8.3.

NOTE If \ is followed by a decimal number n whose first digit is not
0, then the escape sequence is considered to be a backreference. It is
an error if n is greater than the total number of left capturing
parentheses in the entire regular expression. \0 represents the <NUL>
character and cannot be followed by a decimal digit.

The production CharacterClassEscape :: D evaluates by returning the
ten-element set of characters containing the characters 0 through 9
inclusive.

The production CharacterClassEscape :: D evaluates by returning the
set of all characters not included in the set returned by
CharacterClassEscape :: D.

The production CharacterClassEscape :: S evaluates by returning the
set of characters containing the characters that are on the right-hand
side of the WhiteSpace (7.2) or LineTerminator (7.3) productions.

The production CharacterClassEscape :: S evaluates by returning the
set of all characters not included in the set returned by
CharacterClassEscape :: S.

The production CharacterClassEscape :: W evaluates by returning the
set of characters containing the sixty-three characters:

  --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
  a   b   c   d   e   f   g   h   i   j   k   l   m   n   o   p   q   r   s   t   u   v   w   x   y   z
  A   B   C   D   E   F   G   H   I   J   K   L   M   N   O   P   Q   R   S   T   U   V   W   X   Y   Z
  0   1   2   3   4   5   6   7   8   9   _                                                           
  --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---

The production CharacterClassEscape :: W evaluates by returning the
set of all characters not included in the set returned by
CharacterClassEscape :: W.

The production CharacterClass :: [ [lookahead ∉ {^}] ClassRanges ]
evaluates by evaluating ClassRanges to obtain a CharSet and returning
that CharSet and the Boolean FALSE.

The production CharacterClass :: [ ^ ClassRanges ] evaluates by
evaluating ClassRanges to obtain a CharSet and returning that CharSet
and the Boolean TRUE.

The production ClassRanges :: [empty] evaluates by returning the empty
CharSet.

The production ClassRanges :: NonemptyClassRanges evaluates by
evaluating NonemptyClassRanges to obtain a CharSet and returning that
CharSet.

The production NonemptyClassRanges :: ClassAtom evaluates by
evaluating ClassAtom to obtain a CharSet and returning that CharSet.

The production NonemptyClassRanges :: ClassAtom
NonemptyClassRangesNoDash evaluates as follows:

The production NonemptyClassRanges :: ClassAtom - ClassAtom
ClassRanges evaluates as follows:

The abstract operation CharacterRange takes two CharSet parameters A
and B and performs the following:

The production NonemptyClassRangesNoDash :: ClassAtom evaluates by
evaluating ClassAtom to obtain a CharSet and returning that CharSet.

The production NonemptyClassRangesNoDash :: ClassAtomNoDash
NonemptyClassRangesNoDash evaluates as follows:

The production NonemptyClassRangesNoDash :: ClassAtomNoDash -
ClassAtom ClassRanges evaluates as follows:

NOTE 1 ClassRanges can expand into single ClassAtoms and/or ranges
of two ClassAtoms separated by dashes. In the latter case the
ClassRanges includes all characters between the first ClassAtom and
the second ClassAtom, inclusive; an error occurs if either ClassAtom
does not represent a single character (for example, if one is \W) or if
the first ClassAtom's code unit value is greater than the second
ClassAtom's code unit value.

NOTE 2 Even if the pattern ignores case, the case of the two ends of a
range is significant in determining which characters belong to the
range. Thus, for example, the pattern /[E-F]/I matches only the letters
E, F, E, and F, while the pattern /[E-F]/I matches all upper and
lower-case ASCII letters as well as the symbols [, \, ], ^, _, and `.

NOTE 3 A - character can be treated literally or it can denote a range.
It is treated literally if it is the first or last character of
ClassRanges, the beginning or end limit of a range specification, or
immediately follows a range specification.

The production ClassAtom :: - evaluates by returning the CharSet
containing the one character -.

The production ClassAtom :: ClassAtomNoDash evaluates by evaluating
ClassAtomNoDash to obtain a CharSet and returning that CharSet.

The production ClassAtomNoDash :: SourceCharacter BUT NOT ONE OF \
OR ] OR - evaluates by returning a one-element CharSet containing the
character represented by SourceCharacter.

The production ClassAtomNoDash :: \ ClassEscape evaluates by
evaluating ClassEscape to obtain a CharSet and returning that CharSet.

The production ClassEscape :: DecimalEscape evaluates as follows:

The production ClassEscape :: B evaluates by returning the CharSet
containing the one character <BS> (Unicode value 0008).

The production ClassEscape :: CharacterEscape evaluates by
evaluating CharacterEscape to obtain a character and returning a
one-element CharSet containing that character.

The production ClassEscape :: CharacterClassEscape evaluates by
evaluating CharacterClassEscape to obtain a CharSet and returning that
CharSet.

NOTE A ClassAtom can use any of the escape sequences that are allowed
in the rest of the regular expression except for \B, \B, and
backreferences. Inside a CharacterClass, \B means the backspace
character, while \B and backreferences raise errors. Using a
backreference inside a ClassAtom causes an error.

If pattern is an object R that has a [[NativeBrand]] internal
property whose value is NativeRegExp and flags is UNDEFINED, then
return R unchanged. Otherwise call the standard built-in REGEXP
constructor (15.10.4.1) as if by the expression NEW REGEXP(pattern,
flags) and return the object constructed by that constructor.

When REGEXP is called as part of a NEW expression, it is a constructor:
it initialises the newly created object.

If pattern is an object R that has a [[NativeBrand]] internal
property whose value is NativeRegExp and flags is UNDEFINED, then let
P be the pattern used to construct R and let F be the flags used
to construct R. If pattern is an object R that has a
[[NativeBrand]] internal property whose value is NativeRegExp and
flags is not UNDEFINED, then throw a TYPEERROR exception. Otherwise,
let P be the empty String if pattern is UNDEFINED and
ToString(pattern) otherwise, and let F be the empty String if
flags is UNDEFINED and ToString(flags) otherwise.

If the characters of P do not have the syntactic form Pattern, then
throw a SYNTAXERROR exception. Otherwise let the newly constructed
object have a [[Match]] internal property obtained by evaluating
("compiling") the characters of P as a Pattern as described in
15.10.2.

If F contains any character other than "G", "I", or "M", or if it
contains the same character more than once, then throw a SYNTAXERROR
exception.

If a SYNTAXERROR exception is not thrown, then:

Let S be a String in the form of a Pattern equivalent to P, in
which certain characters are escaped as described below. S may or may
not be identical to P or pattern; however, the internal procedure
that would result from evaluating S as a Pattern must behave
identically to the internal procedure given by the constructed object's
[[Match]] internal property.

The characters / occurring in the pattern shall be escaped in S as
necessary to ensure that the String value formed by concatenating the
Strings "/", S, "/", and F can be parsed (in an appropriate lexical
context) as a RegularExpressionLiteral that behaves identically to the
constructed regular expression. For example, if P is "/", then S
could be "\/" or "\U002F", among other possibilities, but not "/",
because /// followed by F would be parsed as a SingleLineComment
rather than a RegularExpressionLiteral. If P is the empty String,
this specification can be met by letting S be "(?:)".

The following properties of the newly constructed object are data
properties with the attributes that are specified in 15.10.7. The
[[Value]] of each property is set as follows:

The SOURCE property of the newly constructed object is set to S.

The GLOBAL property of the newly constructed object is set to a Boolean
value that is TRUE if F contains the character "G" and FALSE
otherwise.

The IGNORECASE property of the newly constructed object is set to a
Boolean value that is TRUE if F contains the character "I" and FALSE
otherwise.

The MULTILINE property of the newly constructed object is set to a
Boolean value that is TRUE if F contains the character "M" and FALSE
otherwise.

The LASTINDEX property of the newly constructed object is set to 0.

The [[Prototype]] internal property of the newly constructed object is
set to the standard built-in RegExp prototype object as specified in
15.10.6.

The newly constructed object has a [[NativeBrand]] internal property
whose value is NativeRegExp

NOTE If pattern is a StringLiteral, the usual escape sequence
substitutions are performed before the String is processed by RegExp. If
pattern must contain an escape sequence to be recognised by RegExp, any
backslash \ characters must be escaped within the StringLiteral to
prevent them being removed when the contents of the StringLiteral are
formed.

The value of the [[Prototype]] internal property of the RegExp
constructor is the standard built-in Function prototype object (15.3.4).

Besides the internal properties and the LENGTH property (whose value is
2), the RegExp constructor has the following properties:

The initial value of REGEXP.PROTOTYPE is the RegExp prototype object
(15.10.6).

This property shall have the attributes { [[Writable]]: FALSE,
[[Enumerable]]: FALSE, [[Configurable]]: FALSE }.

The value of the [[Prototype]] internal property of the RegExp prototype
object is the standard built-in Object prototype object (15.2.4). The
RegExp prototype object is itself a regular expression object; it has a
[[NativeBrand]] internal property whose value is NativeRegExp . The
initial values of the RegExp prototype object’s data properties
(15.10.7) are set as if the object was created by the expression NEW
REGEXP() where REGEXP is that standard built-in constructor with that
name.

The RegExp prototype object does not have a VALUEOF property of its own;
however, it inherits the VALUEOF property from the Object prototype
object.

In the following descriptions of functions that are properties of the
RegExp prototype object, the phrase “this RegExp object” refers to the
object that is the THIS value for the invocation of the function; a
TYPEERROR exception is thrown if the THIS value is not an object that
has a [[NativeBrand]] internal property whose value is NativeRegExp.

The initial value of REGEXP.PROTOTYPE.CONSTRUCTOR is the standard
built-in REGEXP constructor.

Performs a regular expression match of string against the regular
expression and returns an Array object containing the results of the
match, or NULL if string did not match.

The String ToString(string) is searched for an occurrence of the
regular expression pattern as follows:

The following steps are taken:

Return the String value formed by concatenating the Strings "/", the
String value of the SOURCE property of this RegExp object, and "/"; plus
"G" if the GLOBAL property is TRUE, "I" if the IGNORECASE property is
TRUE, and "M" if the MULTILINE property is TRUE.

NOTE The returned String has the form of a RegularExpressionLiteral
that evaluates to another RegExp object with the same behaviour as this
object.

RegExp instances inherit properties from the RegExp prototype object and
have a [[NativeBrand]] internal property whose value is NativeRegExp.
RegExp instances also have a [[Match]] internal property and a LENGTH
property.

The value of the [[Match]] internal property is an implementation
dependent representation of the Pattern of the RegExp object.

RegExp instances also have the following properties.

The value of the SOURCE property is a String in the form of a Pattern
representing the current regular expression. This property shall have
the attributes { [[Writable]]: FALSE, [[Enumerable]]: FALSE,
[[Configurable]]: FALSE }.

The value of the GLOBAL property is a Boolean value indicating whether
the flags contained the character “G”. This property shall have the
attributes { [[Writable]]: FALSE, [[Enumerable]]: FALSE,
[[Configurable]]: FALSE }.

The value of the IGNORECASE property is a Boolean value indicating
whether the flags contained the character “I”. This property shall have
the attributes { [[Writable]]: FALSE, [[Enumerable]]: FALSE,
[[Configurable]]: FALSE }.

The value of the MULTILINE property is a Boolean value indicating
whether the flags contained the character “M”. This property shall have
the attributes { [[Writable]]: FALSE, [[Enumerable]]: FALSE,
[[Configurable]]: FALSE }.

The value of the LASTINDEX property specifies the String position at
which to start the next match. It is coerced to an integer when used
(see 15.10.6.2). This property shall have the attributes { [[Writable]]:
TRUE, [[Enumerable]]: FALSE, [[Configurable]]: FALSE }.

NOTE Unlike the other standard built-in properties of RegExp instances,
LASTINDEX is writable.

Instances of Error objects are thrown as exceptions when runtime errors
occur. The Error objects may also serve as base objects for user-defined
exception classes.

When ERROR is called as a function rather than as a constructor, it
creates and initialises a new Error object. Thus the function call
ERROR(…) is equivalent to the object creation expression NEW ERROR(…)
with the same arguments.

The [[Prototype]] internal property of the newly constructed object is
set to the original Error prototype object, the one that is the initial
value of ERROR.PROTOTYPE (15.11.3.1).

The newly constructed object has a [[NativeBrand]] internal property
whose value is NativeError.

The [[Extensible]] internal property of the newly constructed object is
set to TRUE.

If the argument message is not UNDEFINED, the MESSAGE own property of
the newly constructed object is set to ToString(message).

When ERROR is called as part of a NEW expression, it is a constructor:
it initialises the newly created object.

The [[Prototype]] internal property of the newly constructed object is
set to the original Error prototype object, the one that is the initial
value of ERROR.PROTOTYPE (15.11.3.1).

The newly constructed object has a [[NativeBrand]] internal property
whose value is NativeError .

The [[Extensible]] internal property of the newly constructed object is
set to TRUE.

If the argument message is not UNDEFINED, the MESSAGE own property of
the newly constructed object is set to ToString(message).

The value of the [[Prototype]] internal property of the Error
constructor is the Function prototype object (15.3.4).

Besides the internal properties and the LENGTH property (whose value is
1), the Error constructor has the following property:

The initial value of ERROR.PROTOTYPE is the Error prototype object
(15.11.4).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

The Error prototype object is itself an Error object and has a
[[NativeBrand]] internal property whose value is NativeError .

The value of the [[Prototype]] internal property of the Error prototype
object is the standard built-in Object prototype object (15.2.4).

The initial value of ERROR.PROTOTYPE.CONSTRUCTOR is the built-in ERROR
constructor.

The initial value of ERROR.PROTOTYPE.NAME is "ERROR".

The initial value of ERROR.PROTOTYPE.MESSAGE is the empty String.

The following steps are taken:

Error instances inherit properties from the Error prototype object and
have a [[NativeBrand]] internal property whose value is NativeError .
Error instances have no special properties.

One of the NativeError objects below is thrown when a runtime error is
detected. All of these objects share the same structure, as described in
15.11.7.

This exception is not currently used within this specification. This
object remains for compatibility with previous editions of this
specification.

Indicates a numeric value has exceeded the allowable range. See
15.4.2.2, 15.4.5.1, 15.7.4.2, 15.7.4.5, 15.7.4.6, 15.7.4.7, and
15.9.5.43.

Indicate that an invalid reference value has been detected. See 8.7.1,
8.7.2, 10.2.1, 10.2.1.1.4, 10.2.1.2.4, and 11.13.1.

Indicates that a parsing error has occurred. See 11.1.5, 11.3.1, 11.3.2,
11.4.1, 11.4.4, 11.4.5, 11.13.1, 11.13.2, 12.2.1, 12.10.1, 12.14.1,
13.1, 15.1.2.1, 15.3.2.1, 15.10.2.2, 15.10.2.5, 15.10.2.9, 15.10.2.15,
15.10.2.19, 15.10.4.1, and 15.12.2.

Indicates the actual type of an operand is different than the expected
type. See 8.6.2, 8.7.2, 8.10.5, 8.12.5, 8.12.7, 8.12.8, 8.12.9, 9.9,
9.10, 10.2.1, 10.2.1.1.3, 10.6, 11.2.2, 11.2.3, 11.4.1, 11.8.6, 11.8.7,
11.3.1, 13.2, 13.2.3, 15, 15.2.3.2, 15.2.3.3, 15.2.3.4, 15.2.3.5,
15.2.3.6, 15.2.3.7, 15.2.3.8, 15.2.3.9, 15.2.3.10, 15.2.3.11, 15.2.3.12,
15.2.3.13, 15.2.3.14, 15.2.4.3, 15.3.4.2, 15.3.4.3, 15.3.4.4, 15.3.4.5,
15.3.4.5.2, 15.3.4.5.3, 15.3.5, 15.3.5.3, 15.3.5.4, 15.4.4.3, 15.4.4.11,
15.4.4.16, 15.4.4.17, 15.4.4.18, 15.4.4.19, 15.4.4.20, 15.4.4.21,
15.4.4.22, 15.4.5.1, 15.5.4.2, 15.5.4.3, 15.6.4.2, 15.6.4.3, 15.7.4,
15.7.4.2, 15.7.4.4, 15.9.5, 15.9.5.44, 15.10.4.1, 15.10.6, 15.11.4.4 and
15.12.3.

Indicates that one of the global URI handling functions was used in a
way that is incompatible with its definition. See 15.1.3.

When an ECMAScript implementation detects a runtime error, it throws an
instance of one of the NativeError objects defined in 15.11.6. Each of
these objects has the structure described below, differing only in the
name used as the constructor name instead of NativeError, in the NAME
property of the prototype object, and in the implementation-defined
MESSAGE property of the prototype object.

For each error object, references to NativeError in the definition
should be replaced with the appropriate error object name from 15.11.6.

When a NativeError constructor is called as a function rather than as
a constructor, it creates and initialises a new object. A call of the
object as a function is equivalent to calling it as a constructor with
the same arguments.

The [[Prototype]] internal property of the newly constructed object is
set to the prototype object for this error constructor. The newly
constructed object has a [[NativeBrand]] internal property whose value
is NativeError . The [[Extensible]] internal property of the newly
constructed object is set to TRUE.

If the argument message is not UNDEFINED, the MESSAGE own property of
the newly constructed object is set to ToString(message).

When a NativeError constructor is called as part of a NEW expression,
it is a constructor: it initialises the newly created object.

The [[Prototype]] internal property of the newly constructed object is
set to the prototype object for this NativeError constructor. The
newly constructed object has a [[NativeBrand]] internal property whose
value is NativeError . The [[Extensible]] internal property of the newly
constructed object is set to TRUE.

If the argument message is not UNDEFINED, the MESSAGE own property of
the newly constructed object is set to ToString(message).

The value of the [[Prototype]] internal property of a NativeError
constructor is the Function prototype object (15.3.4).

Besides the internal properties and the LENGTH property (whose value is
1), each NativeError constructor has the following property:

The initial value of NATIVEERROR.PROTOTYPE is a NativeError
prototype object (15.11.7.7). Each NativeError constructor has a
separate prototype object.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Each NativeError prototype object is an Error object and has a
[[NativeBrand]] internal property whose value is NativeError .

The value of the [[Prototype]] internal property of each NativeError
prototype object is the standard built-in Error prototype object
(15.11.4).

The initial value of the CONSTRUCTOR property of the prototype for a
given NativeError constructor is the NativeError constructor
function itself (15.11.7).

The initial value of the NAME property of the prototype for a given
NativeError constructor is the name of the constructor (the name used
instead of NativeError).

The initial value of the MESSAGE property of the prototype for a given
NativeError constructor is the empty String.

NOTE The prototypes for the NativeError constructors do not themselves
provide a TOSTRING function, but instances of errors will inherit it
from the Error prototype object.

NativeError instances inherit properties from their NativeError
prototype object and have a [[NativeBrand]] internal property whose
value is NativeError . NativeError instances have no special
properties.

The JSON object is a single object that contains two functions, PARSE
and STRINGIFY, that are used to parse and construct JSON texts. The JSON
Data Interchange Format is described in RFC 4627
<http://www.ietf.org/rfc/rfc4627.txt>. The JSON interchange format used
in this specification is exactly that described by RFC 4627 with two
exceptions:

-   The top level JSONText production of the ECMAScript JSON grammar
    may consist of any JSONValue rather than being restricted to being
    a JSONObject or a JSONArray as specified by RFC 4627.

-   Conforming implementations of JSON.PARSE and JSON.STRINGIFY must
    support the exact interchange format described in this specification
    without any deletions or extensions to the format. This differs from
    RFC 4627 which permits a JSON parser to accept non-JSON forms and
    extensions.

The value of the [[Prototype]] internal property of the JSON object is
the standard built-in Object prototype object (15.2.4). The JSON object
has a [[NativeBrand]] internal property whose value is NativeJSON . The
value of the [[Extensible]] internal property of the JSON object is set
to TRUE.

The JSON object does not have a [[Construct]] internal property; it is
not possible to use the JSON object as a constructor with the NEW
operator.

The JSON object does not have a [[Call]] internal property; it is not
possible to invoke the JSON object as a function.

JSON.stringify produces a String that conforms to the following JSON
grammar. JSON.parse accepts a String that conforms to the JSON grammar.

JSON is similar to ECMAScript source text in that it consists of a
sequence of characters conforming to the rules of SourceCharacter. The
JSON Lexical Grammar defines the tokens that make up a JSON text similar
to the manner that the ECMAScript lexical grammar defines the tokens of
an ECMAScript source text. The JSON Lexical grammar only recognises the
white space character specified by the production JSONWhiteSpace. The
JSON lexical grammar shares some productions with the ECMAScript lexical
grammar. All nonterminal symbols of the grammar that do not begin with
the characters “JSON” are defined by productions of the ECMAScript
lexical grammar.

Syntax

JSONWhiteSpace ::

<TAB>
<CR>
<LF>
<SP>

JSONString ::

" JSONStringCharacters~opt~ "

JSONStringCharacters ::

JSONStringCharacter JSONStringCharacters~opt~

JSONStringCharacter ::

SourceCharacter BUT NOT ONE OF " OR \ OR U+0000 THROUGH U+001F

\ JSONEscapeSequence

JSONEscapeSequence ::

JSONEscapeCharacter

UnicodeEscapeSequence

JSONEscapeCharacter :: ONE OF

" / \ B F N R T

JSONNumber ::

-~opt~ DecimalIntegerLiteral JSONFraction~opt~ ExponentPart~opt~

JSONFraction ::

. DecimalDigits

JSONNullLiteral ::

NullLiteral

JSONBooleanLiteral ::

BooleanLiteral

The JSON Syntactic Grammar defines a valid JSON text in terms of tokens
defined by the JSON lexical grammar. The goal symbol of the grammar is
JSONText.

Syntax

JSONText :

JSONValue

JSONValue :

JSONNullLiteral
JSONBooleanLiteral
JSONObject
JSONArray
JSONString
JSONNumber

JSONObject :

{ }
{ JSONMemberList }

JSONMember :

JSONString : JSONValue

JSONMemberList :

JSONMember
JSONMemberList , JSONMember

JSONArray :

[ ]
[ JSONElementList ]

JSONElementList :

JSONValue
JSONElementList , JSONValue

The PARSE function parses a JSON text (a JSON-formatted String) and
produces an ECMAScript value. The JSON format is a restricted form of
ECMAScript literal. JSON objects are realized as ECMAScript objects.
JSON arrays are realized as ECMAScript arrays. JSON strings, numbers,
booleans, and null are realized as ECMAScript Strings, Numbers,
Booleans, and NULL. JSON uses a more limited set of white space
characters than WhiteSpace and allows Unicode code points U+2028 and
U+2029 to directly appear in JSONString literals without using an
escape sequence. The process of parsing is similar to 11.1.4 and 11.1.5
as constrained by the JSON grammar.

The optional reviver parameter is a function that takes two
parameters, (key and value). It can filter and transform the
results. It is called with each of the key_/_value pairs produced by
the parse, and its return value is used instead of the original value.
If it returns what it received, the structure is not modified. If it
returns UNDEFINED then the property is deleted from the result.

The abstract operation Walk is a recursive abstract operation that takes
two parameters: a holder object and the String name of a property in
that object. Walk uses the value of reviver that was originally passed
to the above parse function.

It is not permitted for a conforming implementation of JSON.PARSE to
extend the JSON grammars. If an implementation wishes to support a
modified or extended JSON interchange format it must do so by defining a
different parse function.

NOTE In the case where there are duplicate name Strings within an
object, lexically preceding values for the same key shall be
overwritten.

The STRINGIFY function returns a String in JSON format representing an
ECMAScript value. It can take three parameters. The value parameter is
an ECMAScript value, which is usually an object or array, although it
can also be a String, Boolean, Number or NULL. The optional replacer
parameter is either a function that alters the way objects and arrays
are stringified, or an array of Strings and Numbers that acts as a white
list for selecting the object properties that will be stringified. The
optional space parameter is a String or Number that allows the result
to have white space injected into it to improve human readability.

These are the steps in stringifying an object:

The abstract operation Str_(_key, holder) has access to
ReplacerFunction from the invocation of the STRINGIFY method. Its
algorithm is as follows:

The abstract operation Quote_(_value) wraps a String value in double
quotes and escapes characters within it.

  backspace "B"

  formfeed "F"

  newline "N"

  carriage return "R"

  tab "T"

The abstract operation JO_(_value) serializes an object. It has access
to the stack, indent, gap, and PropertyList of the invocation of
the stringify method.

The abstract operation JA_(_value) serializes an array. It has access
to the stack, indent, and gap of the invocation of the stringify
method. The representation of arrays includes only the elements between
zero and ARRAY.LENGTH – 1 inclusive. Named properties are excluded from
the stringification. An array is stringified as an open left bracket,
elements separated by comma, and a closing right bracket.

NOTE 1 JSON structures are allowed to be nested to any depth, but they
must be acyclic. If value is or contains a cyclic structure, then the
stringify function must throw a TYPEERROR exception. This is an example
of a value that cannot be stringified:

  a = [];

  a[0] = a;

  my_text = JSON.stringify(a); // This must throw an TypeError.

NOTE 2 Symbolic primitive values are rendered as follows:

-   The NULL value is rendered in JSON text as the String null.

-   The UNDEFINED value is not rendered.

-   The TRUE value is rendered in JSON text as the String true.

-   The FALSE value is rendered in JSON text as the String false.

NOTE 3 String values are wrapped in double quotes. The characters " and
\ are escaped with \ prefixes. Control characters are replaced with
escape sequences \UHHHH, or with the shorter forms, \B (backspace), \F
(formfeed), \N (newline), \R (carriage return), \T (tab).

NOTE 4 Finite numbers are stringified as if by calling
ToString(number). NAN and Infinity regardless of sign are represented
as the String NULL.

NOTE 5 Values that do not have a JSON representation (such as UNDEFINED
and functions) do not produce a String. Instead they produce the
undefined value. In arrays these values are represented as the String
NULL. In objects an unrepresentable value causes the property to be
excluded from stringification.

NOTE 6 An object is rendered as an opening left brace followed by zero
or more properties, separated with commas, closed with a right brace. A
property is a quoted String representing the key or property name, a
colon, and then the stringified property value. An array is rendered as
an opening left bracket followed by zero or more values, separated with
commas, closed with a right bracket.

An implementation must report most errors at the time the relevant
ECMAScript language construct is evaluated. An _early error_ is an error
that can be detected and reported prior to the evaluation of any
construct in the Program containing the error. An implementation must
report early errors in a Program prior to the first evaluation of that
Program. Early errors in EVAL code are reported at the time EVAL is
called but prior to evaluation of any construct within the EVAL code.
All errors that are not early errors are runtime errors.

An implementation must treat any instance of the following kinds of
errors as an early error:

-   Any syntax error.

-   Attempts to define an ObjectLiteral that has multiple GET property
    assignments with the same name or multiple SET property assignments
    with the same name.

-   Attempts to define an ObjectLiteral that has both a data property
    assignment and a GET or SET property assignment with the same name.

-   Errors in regular expression literals that are not
    implementation-defined syntax extensions.

-   Attempts in strict mode code to define an ObjectLiteral that has
    multiple data property assignments with the same name.

-   The occurrence of a WithStatement in strict mode code.

-   The occurrence of an Identifier value appearing more than once
    within a FormalParameterList of an individual strict mode
    FunctionDeclaration or FunctionExpression.

-   Improper uses of RETURN, BREAK, and CONTINUE.

-   Attempts to call PutValue on any value for which an early
    determination can be made that the value is not a Reference (for
    example, executing the assignment statement 3=4).

An implementation shall not treat other kinds of errors as early errors
even if the compiler can prove that a construct cannot execute without
error under any circumstances. An implementation may issue an early
warning in such a case, but it should not report the error until the
relevant construct is actually executed.

An implementation shall report all errors as specified, except for the
following:

-   An implementation may extend program syntax and regular expression
      pattern or flag syntax. To permit this, all operations (such as
      calling EVAL, using a regular expression literal, or using the
      FUNCTION or REGEXP constructor) that are allowed to throw
      SYNTAXERROR are permitted to exhibit implementation-defined
      behaviour instead of throwing SYNTAXERROR when they encounter an
      implementation-defined extension to the program syntax or regular
      expression pattern or flag syntax.

-   An implementation may provide additional types, values, objects,
      properties, and functions beyond those described in this
      specification. This may cause constructs (such as looking up a
      variable in the global scope) to have implementation-defined
      behaviour instead of throwing an error (such as REFERENCEERROR).

-   An implementation may define behaviour other than throwing
      RANGEERROR for TOFIXED, TOEXPONENTIAL, and TOPRECISION when the
      fractionDigits or precision argument is outside the specified
      range.

(informative)
Grammar Summary


Lexical Grammar

SourceCharacter :: See clause 6

any Unicode code unit

InputElementDiv :: See clause 7

WhiteSpace
LineTerminator
Comment
Token
DivPunctuator

InputElementRegExp :: See clause 7

WhiteSpace
LineTerminator
Comment
Token
RegularExpressionLiteral

WhiteSpace :: See 7.2

<TAB>
<VT>
<FF>
<SP>
<NBSP>
<BOM>
<USP>

LineTerminator :: See 7.3

<LF>
<CR>
<LS>
<PS>

LineTerminatorSequence :: See 7.3

<LF>
<CR> [lookahead ∉ <LF> ]
<LS>
<PS>
<CR> <LF>

Comment :: See 7.4

MultiLineComment
SingleLineComment

MultiLineComment :: See 7.4

/* MultiLineCommentChars~opt~ */

MultiLineCommentChars :: See 7.4

MultiLineNotAsteriskChar MultiLineCommentChars~opt~
* PostAsteriskCommentChars~opt~

PostAsteriskCommentChars :: See 7.4

MultiLineNotForwardSlashOrAsteriskChar MultiLineCommentChars~opt~
* PostAsteriskCommentChars~opt~

MultiLineNotAsteriskChar :: See 7.4

SourceCharacter BUT NOT *

MultiLineNotForwardSlashOrAsteriskChar :: See 7.4

SourceCharacter BUT NOT ONE OF / OR *

SingleLineComment :: See 7.4

// SingleLineCommentChars~opt~

SingleLineCommentChars :: See 7.4

SingleLineCommentChar SingleLineCommentChars~opt~

SingleLineCommentChar :: See 7.4

SourceCharacter BUT NOT LineTerminator

Token :: See 7.5

IdentifierName
Punctuator
NumericLiteral
StringLiteral

Identifier :: See 7.6

IdentifierName BUT NOT ReservedWord

IdentifierName :: See 7.6

IdentifierStart
IdentifierName IdentifierPart

IdentifierStart :: See 7.6

UnicodeLetter
$
_
\ UnicodeEscapeSequence

IdentifierPart :: See 7.6

IdentifierStart
UnicodeCombiningMark
UnicodeDigit
UnicodeConnectorPunctuation
<ZWNJ>
<ZWJ>

UnicodeLetter :: See 7.6

any character in the Unicode categories “Uppercase letter (Lu)”,
“Lowercase letter (Ll)”, “Titlecase letter (Lt)”, “Modifier letter
(Lm)”, “Other letter (Lo)”, or “Letter number (Nl)”.

UnicodeCombiningMark :: See 7.6

any character in the Unicode categories “Non-spacing mark (Mn)” or
“Combining spacing mark (Mc)”

UnicodeDigit :: See 7.6

any character in the Unicode category “Decimal number (Nd)”

UnicodeConnectorPunctuation :: See 7.6

any character in the Unicode category “Connector punctuation (Pc)”

ReservedWord :: See 7.6.1

Keyword
FutureReservedWord
NullLiteral
BooleanLiteral

Keyword :: ONE OF See 7.6.1.1

  ---------- ---------- ------------ --------
  break      do         instanceof   typeof
  case       else       new          var
  catch      finally    return       void
  continue   for        switch       while
  debugger   function   this         with
  default    if         throw        
  delete     in         try          
  ---------- ---------- ------------ --------

FutureReservedWord :: ONE OF See 7.6.1.2

  ------- -------- --------- -------
  class   enum     extends   super
  const   export   import    
  ------- -------- --------- -------

  The following tokens are also considered to be FutureReservedWords
  when parsing strict mode code (see 10.1.1).

  ------------ --------- ----------- --------
  implements   let       private     public
  interface    package   protected   static
  yield                              
  ------------ --------- ----------- --------

Punctuator :: ONE OF See 7.7

  ----- ------ ----- ----- ----- -----
  {     }      (     )     [     ]
  .     ;      ,     <     >     <=
  >=    ==     !=    ===   !==   
  +     -      *     %     ++    --
  <<    >>     >>>   &     |     ^
  !     ~      &&    ||    ?     :
  =     +=     -=    *=    %=    <<=
  >>=   >>>=   &=    |=    ^=    
  ----- ------ ----- ----- ----- -----

DivPunctuator :: ONE OF See 7.7

  --- ---- -- -- -- --
  /   /=            
  --- ---- -- -- -- --

Literal :: See 7.8

NullLiteral
BooleanLiteral
NumericLiteral
StringLiteral
RegularExpressionLiteral

NullLiteral :: See 7.8.1

NULL

BooleanLiteral :: See 7.8.2

TRUE
FALSE

NumericLiteral :: See 7.8.3

DecimalLiteral
HexIntegerLiteral

DecimalLiteral :: See 7.8.3

DecimalIntegerLiteral . DecimalDigits~opt~ ExponentPart~opt~
. DecimalDigits ExponentPart~opt~
DecimalIntegerLiteral ExponentPart~opt~

DecimalIntegerLiteral :: See 7.8.3

0
NonZeroDigit DecimalDigits~opt~

DecimalDigits :: See 7.8.3

DecimalDigit
DecimalDigits DecimalDigit

DecimalDigit :: ONE OF See 7.8.3

0 1 2 3 4 5 6 7 8 9

NonZeroDigit :: ONE OF See 7.8.3

1 2 3 4 5 6 7 8 9

ExponentPart :: See 7.8.3

ExponentIndicator SignedInteger

ExponentIndicator :: ONE OF See 7.8.3

E E

SignedInteger :: See 7.8.3

DecimalDigits
+ DecimalDigits
- DecimalDigits

HexIntegerLiteral :: See 7.8.3

0X HexDigit
0X HexDigit
HexIntegerLiteral HexDigit

HexDigit :: ONE OF See 7.8.3

0 1 2 3 4 5 6 7 8 9 A B C D E F A B C D E F

StringLiteral :: See 7.8.4

" DoubleStringCharacters~opt~ "
' SingleStringCharacters~opt~ '

DoubleStringCharacters :: See 7.8.4

DoubleStringCharacter DoubleStringCharacters~opt~

SingleStringCharacters :: See 7.8.4

SingleStringCharacter SingleStringCharacters~opt~

DoubleStringCharacter :: See 7.8.4

SourceCharacter BUT NOT ONE OF " OR \ OR LineTerminator
\ EscapeSequence
LineContinuation

SingleStringCharacter :: See 7.8.4

SourceCharacter BUT NOT ONE OF ' OR \ OR LineTerminator
\ EscapeSequence
LineContinuation

LineContinuation :: See 7.8.4

\ LineTerminatorSequence

EscapeSequence :: See 7.8.4

CharacterEscapeSequence
0 [lookahead ∉ DecimalDigit]
HexEscapeSequence
UnicodeEscapeSequence

CharacterEscapeSequence :: See 7.8.4

SingleEscapeCharacter
NonEscapeCharacter

SingleEscapeCharacter :: ONE OF See 7.8.4

' " \ B F N R T V

NonEscapeCharacter :: See 7.8.4

SourceCharacter BUT NOT ONE OF EscapeCharacter OR LineTerminator

EscapeCharacter :: See 7.8.4

SingleEscapeCharacter
DecimalDigit
X
U

HexEscapeSequence :: See 7.8.4

X HexDigit HexDigit

UnicodeEscapeSequence :: See 7.8.4

U HexDigit HexDigit HexDigit HexDigit

RegularExpressionLiteral :: See 7.8.5

/ RegularExpressionBody / RegularExpressionFlags

RegularExpressionBody :: See 7.8.5

RegularExpressionFirstChar RegularExpressionChars

RegularExpressionChars :: See 7.8.5

[empty]
RegularExpressionChars RegularExpressionChar

RegularExpressionFirstChar :: See 7.8.5

RegularExpressionNonTerminator BUT NOT ONE OF * OR \ OR / OR [
RegularExpressionBackslashSequence
RegularExpressionClass

RegularExpressionChar :: See 7.8.5

RegularExpressionNonTerminator BUT NOT \ OR / OR [
RegularExpressionBackslashSequence
RegularExpressionClass

RegularExpressionBackslashSequence :: See 7.8.5

\ RegularExpressionNonTerminator

RegularExpressionNonTerminator :: See 7.8.5

SourceCharacter BUT NOT LineTerminator

RegularExpressionClass :: See 7.8.5

[ RegularExpressionClassChars ]

RegularExpressionClassChars :: See 7.8.5

[empty]
RegularExpressionClassChars RegularExpressionClassChar

RegularExpressionClassChar :: See 7.8.5

RegularExpressionNonTerminator BUT NOT ] OR \
RegularExpressionBackslashSequence

RegularExpressionFlags :: See 7.8.5

[empty]
RegularExpressionFlags IdentifierPart


Number Conversions

StringNumericLiteral ::: See 9.3.1

StrWhiteSpace~opt~
StrWhiteSpace~opt~ StrNumericLiteral StrWhiteSpace~opt~

StrWhiteSpace ::: See 9.3.1

StrWhiteSpaceChar StrWhiteSpace~opt~

StrWhiteSpaceChar ::: See 9.3.1

WhiteSpace
LineTerminator

StrNumericLiteral ::: See 9.3.1

StrDecimalLiteral
HexIntegerLiteral

StrDecimalLiteral ::: See 9.3.1

StrUnsignedDecimalLiteral
+ StrUnsignedDecimalLiteral
- StrUnsignedDecimalLiteral

StrUnsignedDecimalLiteral ::: See 9.3.1

INFINITY
DecimalDigits . DecimalDigits~opt~ ExponentPart~opt~
. DecimalDigits ExponentPart~opt~
DecimalDigits ExponentPart~opt~

DecimalDigits ::: See 9.3.1

DecimalDigit
DecimalDigits DecimalDigit

DecimalDigit ::: ONE OF See 9.3.1

0 1 2 3 4 5 6 7 8 9

ExponentPart ::: See 9.3.1

ExponentIndicator SignedInteger

ExponentIndicator ::: ONE OF See 9.3.1

E E

SignedInteger ::: See 9.3.1

DecimalDigits
+ DecimalDigits
- DecimalDigits

HexIntegerLiteral ::: See 9.3.1

0X HexDigit
0X HexDigit
HexIntegerLiteral HexDigit

HexDigit ::: ONE OF See 9.3.1

0 1 2 3 4 5 6 7 8 9 A B C D E F A B C D E F


Expressions

PrimaryExpression : See 11.1

THIS
Identifier
Literal
ArrayLiteral
ObjectLiteral
( Expression )

ArrayLiteral : See 11.1.4

[ Elision~opt~ ]
[ ElementList ]
[ ElementList , Elision~opt~ ]

ElementList : See 11.1.4

Elision~opt~ AssignmentExpression
ElementList , Elision~opt~ AssignmentExpression

Elision : See 11.1.4

,
Elision ,

ObjectLiteral : See 11.1.5

{ }
{ PropertyNameAndValueList }
{ PropertyNameAndValueList , }

PropertyNameAndValueList : See 11.1.5

PropertyAssignment
PropertyNameAndValueList , PropertyAssignment

PropertyAssignment : See 11.1.5

PropertyName : AssignmentExpression
GET PropertyName ( ) { FunctionBody }
SET PropertyName ( PropertySetParameterList ) { FunctionBody }

PropertyName : See 11.1.5

IdentifierName
StringLiteral
NumericLiteral

PropertySetParameterList : See 11.1.5

Identifier

MemberExpression : See 11.2

PrimaryExpression
FunctionExpression
MemberExpression [ Expression ]
MemberExpression . IdentifierName
NEW MemberExpression Arguments

NewExpression : See 11.2

MemberExpression
NEW NewExpression

CallExpression : See 11.2

MemberExpression Arguments
CallExpression Arguments
CallExpression [ Expression ]
CallExpression . IdentifierName

Arguments : See 11.2

( )
( ArgumentList )

ArgumentList : See 11.2

AssignmentExpression
ArgumentList , AssignmentExpression

LeftHandSideExpression : See 11.2

NewExpression
CallExpression

PostfixExpression : See 11.3

LeftHandSideExpression
LeftHandSideExpression [no LineTerminator here] ++
LeftHandSideExpression [no LineTerminator here] --

UnaryExpression : See 11.4

PostfixExpression
DELETE UnaryExpression
VOID UnaryExpression
TYPEOF UnaryExpression
++ UnaryExpression
-- UnaryExpression
+ UnaryExpression
- UnaryExpression
~ UnaryExpression
! UnaryExpression

MultiplicativeExpression : See 11.5

UnaryExpression
MultiplicativeExpression * UnaryExpression
MultiplicativeExpression / UnaryExpression
MultiplicativeExpression % UnaryExpression

AdditiveExpression : See 11.6

MultiplicativeExpression
AdditiveExpression + MultiplicativeExpression
AdditiveExpression - MultiplicativeExpression

ShiftExpression : See 11.7

AdditiveExpression
ShiftExpression << AdditiveExpression
ShiftExpression >> AdditiveExpression
ShiftExpression >>> AdditiveExpression

RelationalExpression : See 11.8

ShiftExpression
RelationalExpression < ShiftExpression
RelationalExpression > ShiftExpression
RelationalExpression <= ShiftExpression
RelationalExpression >= ShiftExpression
RelationalExpression INSTANCEOF ShiftExpression
RelationalExpression IN ShiftExpression

RelationalExpressionNoIn : See 11.8

ShiftExpression
RelationalExpressionNoIn < ShiftExpression
RelationalExpressionNoIn > ShiftExpression
RelationalExpressionNoIn <= ShiftExpression
RelationalExpressionNoIn >= ShiftExpression
RelationalExpressionNoIn INSTANCEOF ShiftExpression

EqualityExpression : See 11.9

RelationalExpression
EqualityExpression == RelationalExpression
EqualityExpression != RelationalExpression
EqualityExpression === RelationalExpression
EqualityExpression !== RelationalExpression

EqualityExpressionNoIn : See 11.9

RelationalExpressionNoIn
EqualityExpressionNoIn == RelationalExpressionNoIn
EqualityExpressionNoIn != RelationalExpressionNoIn
EqualityExpressionNoIn === RelationalExpressionNoIn
EqualityExpressionNoIn !== RelationalExpressionNoIn

BitwiseANDExpression : See 11.10

EqualityExpression
BitwiseANDExpression & EqualityExpression

BitwiseANDExpressionNoIn : See 11.10

EqualityExpressionNoIn
BitwiseANDExpressionNoIn & EqualityExpressionNoIn

BitwiseXORExpression : See 11.10

BitwiseANDExpression
BitwiseXORExpression ^ BitwiseANDExpression

BitwiseXORExpressionNoIn : See 11.10

BitwiseANDExpressionNoIn
BitwiseXORExpressionNoIn ^ BitwiseANDExpressionNoIn

BitwiseORExpression : See 11.10

BitwiseXORExpression
BitwiseORExpression | BitwiseXORExpression

BitwiseORExpressionNoIn : See 11.10

BitwiseXORExpressionNoIn
BitwiseORExpressionNoIn | BitwiseXORExpressionNoIn

LogicalANDExpression : See 11.11

BitwiseORExpression
LogicalANDExpression && BitwiseORExpression

LogicalANDExpressionNoIn : See 11.11

BitwiseORExpressionNoIn
LogicalANDExpressionNoIn && BitwiseORExpressionNoIn

LogicalORExpression : See 11.11

LogicalANDExpression
LogicalORExpression || LogicalANDExpression

LogicalORExpressionNoIn : See 11.11

LogicalANDExpressionNoIn
LogicalORExpressionNoIn || LogicalANDExpressionNoIn

ConditionalExpression : See 11.12

LogicalORExpression
LogicalORExpression ? AssignmentExpression : AssignmentExpression

ConditionalExpressionNoIn : See 11.12

LogicalORExpressionNoIn
LogicalORExpressionNoIn ? AssignmentExpression :
AssignmentExpressionNoIn

AssignmentExpression : See 11.13

ConditionalExpression
LeftHandSideExpression = AssignmentExpression
LeftHandSideExpression AssignmentOperator AssignmentExpression

AssignmentExpressionNoIn : See 11.13

ConditionalExpressionNoIn
LeftHandSideExpression = AssignmentExpressionNoIn
LeftHandSideExpression AssignmentOperator AssignmentExpressionNoIn

AssignmentOperator : ONE OF See 11.13

  ---- ---- ---- ---- ---- ----- ----- ------ ---- ---- ----
  *=   /=   %=   +=   -=   <<=   >>=   >>>=   &=   ^=   |=
  ---- ---- ---- ---- ---- ----- ----- ------ ---- ---- ----

Expression : See 11.14

AssignmentExpression
Expression , AssignmentExpression

ExpressionNoIn : See 11.14

AssignmentExpressionNoIn
ExpressionNoIn , AssignmentExpressionNoIn


Statements

Statement : See clause 12

Block
VariableStatement
EmptyStatement
ExpressionStatement
IfStatement
IterationStatement
ContinueStatement
BreakStatement
ReturnStatement
WithStatement
LabelledStatement
SwitchStatement
ThrowStatement
TryStatement
DebuggerStatement

Block : See 12.1

{ StatementList~opt~ }

StatementList : See 12.1

Statement
StatementList Statement

VariableStatement : See 12.2

VAR VariableDeclarationList ;

VariableDeclarationList : See 12.2

VariableDeclaration
VariableDeclarationList , VariableDeclaration

VariableDeclarationListNoIn : See 12.2

VariableDeclarationNoIn
VariableDeclarationListNoIn , VariableDeclarationNoIn

VariableDeclaration : See 12.2

Identifier Initialiser~opt~

VariableDeclarationNoIn : See 12.2

Identifier InitialiserNoIn~opt~

Initialiser : See 12.2

= AssignmentExpression

InitialiserNoIn : See 12.2

= AssignmentExpressionNoIn

EmptyStatement : See 12.3

;

ExpressionStatement : See 12.4

[lookahead ∉ {{, FUNCTION}] Expression ;

IfStatement : See 12.5

IF ( Expression ) Statement ELSE Statement
IF ( Expression ) Statement

IterationStatement : See 12.6

DO Statement WHILE ( Expression );
WHILE ( Expression ) Statement
FOR (ExpressionNoIn~opt~; Expression~opt~ ; Expression~opt~ ) Statement
FOR ( VAR VariableDeclarationListNoIn; Expression~opt~ ; Expression~opt~
) Statement
FOR ( LeftHandSideExpression IN Expression ) Statement
FOR ( VAR VariableDeclarationNoIn IN Expression ) Statement

ContinueStatement : See 12.7

CONTINUE ;
CONTINUE [no LineTerminator here] Identifier ;

BreakStatement : See 12.8

BREAK ;
BREAK [no LineTerminator here] Identifier ;

ReturnStatement : See 12.9

RETURN ;
RETURN [no LineTerminator here] Expression ;

WithStatement : See 12.10

WITH ( Expression ) Statement

SwitchStatement : See 12.11

SWITCH ( Expression ) CaseBlock

CaseBlock : See 12.11

{ CaseClauses~opt~ }
{ CaseClauses~opt~ DefaultClause CaseClauses~opt~ }

CaseClauses : See 12.11

CaseClause
CaseClauses CaseClause

CaseClause : See 12.11

CASE Expression : StatementList~opt~

DefaultClause : See 12.11

DEFAULT : StatementList~opt~

LabelledStatement : See 12.12

Identifier : Statement

ThrowStatement : See 12.13

THROW [no LineTerminator here] Expression ;

TryStatement : See 12.14

TRY Block Catch~
~TRY Block Finally~
~TRY Block Catch Finally

Catch : See 12.14

CATCH ( Identifier ) Block

Finally : See 12.14

FINALLY Block

DebuggerStatement : See 12.15

DEBUGGER ;


Functions and Programs

FunctionDeclaration : See clause 13

FUNCTION Identifier ( FormalParameterList~opt~ ) { FunctionBody }

FunctionExpression : See clause 13

FUNCTION Identifier~opt~ ( FormalParameterList~opt~ ) { FunctionBody }

FormalParameterList : See clause 13

Identifier
FormalParameterList , Identifier

FunctionBody : See clause 13

SourceElements~opt~

Program : See clause 14

SourceElements~opt~

SourceElements : See clause 14

SourceElement
SourceElements SourceElement

SourceElement : See clause 14

Statement
FunctionDeclaration


Universal Resource Identifier Character Classes

uri ::: See 15.1.3

uriCharacters~opt~

uriCharacters ::: See 15.1.3

uriCharacter uriCharacters~opt~

uriCharacter ::: See 15.1.3

uriReserved
uriUnescaped
uriEscaped

uriReserved ::: ONE OF See 15.1.3

; / ? : @ & = + $ ,

uriUnescaped ::: See 15.1.3

uriAlpha
DecimalDigit
uriMark

uriEscaped ::: See 15.1.3

% HexDigit HexDigit

uriAlpha ::: ONE OF See 15.1.3

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

uriMark ::: ONE OF See 15.1.3

- _ . ! ~ * ' ( )


Regular Expressions

Pattern :: See 15.10.1

Disjunction

Disjunction :: See 15.10.1

Alternative
 Alternative | Disjunction

Alternative :: See 15.10.1

[empty]
Alternative Term

Term :: See 15.10.1

Assertion
Atom
Atom Quantifier

Assertion :: See 15.10.1

^
$
\ B
\ B
( ? = Disjunction )
( ? ! Disjunction )

Quantifier :: See 15.10.1

QuantifierPrefix
QuantifierPrefix ?

QuantifierPrefix :: See 15.10.1

*
+
?
{ DecimalDigits }
{ DecimalDigits , }
{ DecimalDigits , DecimalDigits }

Atom :: See 15.10.1

PatternCharacter
.
\ AtomEscape
CharacterClass
( Disjunction )
( ? : Disjunction )

PatternCharacter :: See 15.10.1

SourceCharacter BUT NOT ONE OF-
 ^ $ \ . * + ? ( ) [ ] { } |

AtomEscape :: See 15.10.1

DecimalEscape
CharacterEscape
CharacterClassEscape

CharacterEscape :: See 15.10.1

ControlEscape
C ControlLetter
HexEscapeSequence
UnicodeEscapeSequence
IdentityEscape

ControlEscape :: ONE OF See 15.10.1

F N R T V

ControlLetter :: ONE OF See 15.10.1

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

IdentityEscape :: See 15.10.1

SourceCharacter BUT NOT IdentifierPart
<ZWJ>
<ZWNJ>

DecimalEscape :: See 15.10.1

DecimalIntegerLiteral [lookahead ∉ DecimalDigit]

CharacterClassEscape :: ONE OF See 15.10.1

D D S S W W

CharacterClass :: See 15.10.1

[ [lookahead ∉ {^}] ClassRanges ]
[ ^ ClassRanges ]

ClassRanges :: See 15.10.1

[empty]
NonemptyClassRanges

NonemptyClassRanges :: See 15.10.1

ClassAtom
ClassAtom NonemptyClassRangesNoDash
ClassAtom – ClassAtom ClassRanges

NonemptyClassRangesNoDash :: See 15.10.1

ClassAtom
ClassAtomNoDash NonemptyClassRangesNoDash
ClassAtomNoDash – ClassAtom ClassRanges

ClassAtom :: See 15.10.1

-
ClassAtomNoDash

ClassAtomNoDash :: See 15.10.1

SourceCharacter BUT NOT ONE OF \ OR ] OR -
\ ClassEscape

ClassEscape :: See 15.10.1

DecimalEscape
B
CharacterEscape
CharacterClassEscape


JSON

JSON Lexical Grammar

JSONWhiteSpace :: See 15.12.1.1

_<TAB>
<CR>
<LF>
<SP>_

JSONString :: See 15.12.1.1

" JSONStringCharacters~opt~ "

JSONStringCharacters :: See 15.12.1.1

JSONStringCharacter JSONStringCharacters~opt~

JSONStringCharacter :: See 15.12.1.1

SourceCharacter BUT NOT ONE OF " OR \ OR U+0000 THROUGH U+001F

\ JSONEscapeSequence

JSONEscapeSequence :: See 15.12.1.1

JSONEscapeCharacter

UnicodeEscapeSequence

JSONEscapeCharacter :: ONE OF See 15.12.1.1

" / \ B F N R T

JSONNumber :: See 15.12.1.1

-~opt~ DecimalIntegerLiteral JSONFraction~opt~ ExponentPart~opt~

JSONFraction :: See 15.12.1.1

. DecimalDigits

JSONNullLiteral :: See 15.12.1.1

NullLiteral

JSONBooleanLiteral :: See 15.12.1.1

BooleanLiteral

JSON Syntactic Grammar

JSONText : See 15.12.1.2

JSONValue

JSONValue : See 15.12.1.2

JSONNullLiteral
JSONBooleanLiteral
JSONObject
JSONArray
JSONString
JSONNumber

JSONObject : See 15.12.1.2

{ }
{ JSONMemberList }

JSONMember : See 15.12.1.2

JSONString : JSONValue

JSONMemberList : See 15.12.1.2

JSONMember
JSONMemberList , JSONMember

JSONArray : See 15.12.1.2

[ ]
[ JSONElementList ]

JSONElementList : See 15.12.1.2

JSONValue
JSONElementList , JSONValue

(normative)
Additional ECMAScript Features for Web Browsers

The ECMAScript language syntax and semantics defined in this annex are
required when the ECMAScript host is a web browser. The content of this
annex is normative but optional if the ECMAScript host is not a web
browser.


Additional Syntax

Numeric Literals

The syntax and semantics of 7.8.3 is extended as follows except that
this extension is not allowed for strict mode code:

Syntax

NumericLiteral ::

DecimalLiteral
HexIntegerLiteral
OctalIntegerLiteral

OctalIntegerLiteral ::

0 OctalDigit
OctalIntegerLiteral OctalDigit

OctalDigit :: ONE OF

0 1 2 3 4 5 6 7

Semantics

-   The MV of NumericLiteral :: OctalIntegerLiteral is the MV of
      OctalIntegerLiteral.

-   The MV of OctalDigit :: 0 is 0.

-   The MV of OctalDigit :: 1 is 1.

-   The MV of OctalDigit :: 2 is 2.

-   The MV of OctalDigit :: 3 is 3.

-   The MV of OctalDigit :: 4 is 4.

-   The MV of OctalDigit :: 5 is 5.

-   The MV of OctalDigit :: 6 is 6.

-   The MV of OctalDigit :: 7 is 7.

-   The MV of OctalIntegerLiteral :: 0 OctalDigit is the MV of
      OctalDigit.

-   The MV of OctalIntegerLiteral :: OctalIntegerLiteral
      OctalDigit is (the MV of OctalIntegerLiteral times 8) plus the
      MV of OctalDigit.

String Literals

The syntax and semantics of 7.8.4 is extended as follows except that
this extension is not allowed for strict mode code:

Syntax

EscapeSequence ::

CharacterEscapeSequence
OctalEscapeSequence
HexEscapeSequence
UnicodeEscapeSequence

OctalEscapeSequence ::

OctalDigit [lookahead ∉ DecimalDigit]
ZeroToThree OctalDigit [lookahead ∉ DecimalDigit]
FourToSeven OctalDigit
ZeroToThree OctalDigit OctalDigit

ZeroToThree :: ONE OF

0 1 2 3

FourToSeven :: ONE OF

4 5 6 7

Semantics

-   The CV of EscapeSequence :: OctalEscapeSequence is the CV of the
    OctalEscapeSequence.

-   The CV of OctalEscapeSequence :: OctalDigit [lookahead ∉
    DecimalDigit] is the character whose code unit value is the MV of
    the OctalDigit.

-   The CV of OctalEscapeSequence :: ZeroToThree OctalDigit
    [lookahead ∉ DecimalDigit] is the character whose code unit value
    is (8 times the MV of the ZeroToThree) plus the MV of the
    OctalDigit.

-   The CV of OctalEscapeSequence :: FourToSeven OctalDigit is the
    character whose code unit value is (8 times the MV of the
    FourToSeven) plus the MV of the OctalDigit.

-   The CV of OctalEscapeSequence :: ZeroToThree OctalDigit
    OctalDigit is the character whose code unit value is (64 (that is,
    8^2^) times the MV of the ZeroToThree) plus (8 times the MV of the
    first OctalDigit) plus the MV of the second OctalDigit.

-   The MV of ZeroToThree :: 0 is 0.

-   The MV of ZeroToThree :: 1 is 1.

-   The MV of ZeroToThree :: 2 is 2.

-   The MV of ZeroToThree :: 3 is 3.

-   The MV of FourToSeven :: 4 is 4.

-   The MV of FourToSeven :: 5 is 5.

-   The MV of FourToSeven :: 6 is 6.

-   The MV of FourToSeven :: 7 is 7.


Additional Properties

When the ECMAScript host is a web browser the following these additional
properties of the standard native objects are defined.

escape (string)

The ESCAPE function is a property of the global object. It computes a
new version of a String value in which certain characters have been
replaced by a hexadecimal escape sequence.

For those characters being replaced whose code unit value is 0XFF or
less, a two-digit escape sequence of the form %xx is used. For those
characters being replaced whose code unit value is greater than 0XFF, a
four-digit escape sequence of the form %Uxxxx is used.

When the ESCAPE function is called with one argument string, the
following steps are taken:

NOTE The encoding is partly based on the encoding described in RFC 1738,
but the entire encoding specified in this standard is described above
without regard to the contents of RFC 1738. This encoding does not
reflect changes to RFC 1738 made by RFC 3986.

unescape (string)

The UNESCAPE function is a property of the global object. It computes a
new version of a String value in which each escape sequence of the sort
that might be introduced by the ESCAPE function is replaced with the
character that it represents.

When the UNESCAPE function is called with one argument string, the
following steps are taken:

String.prototype.substr (start, length)

The SUBSTR method takes two arguments, start and length, and returns
a substring of the result of converting the this object to a String,
starting from character position start and running for length
characters (or through the end of the String if length is UNDEFINED).
If start is negative, it is treated as (sourceLength_+_start) where
sourceLength is the length of the String. The result is a String
value, not a String object. The following steps are taken:

The LENGTH property of the SUBSTR method is 2.

NOTE The SUBSTR function is intentionally generic; it does not require
that its THIS value be a String object. Therefore it can be transferred
to other kinds of objects for use as a method.

Date.prototype.getYear ( )

NOTE The GETFULLYEAR method is preferred for nearly all purposes,
because it avoids the “year 2000 problem.”

When the GETYEAR method is called with no arguments, the following steps
are taken:

Date.prototype.setYear (year)

NOTE The SETFULLYEAR method is preferred for nearly all purposes,
because it avoids the “year 2000 problem.”

When the SETYEAR method is called with one argument year, the
following steps are taken:

Date.prototype.toGMTString ( )

NOTE The property TOUTCSTRING is preferred. The TOGMTSTRING property is
provided principally for compatibility with old code. It is recommended
that the TOUTCSTRING property be used in new ECMAScript code.

The Function object that is the initial value of
DATE.PROTOTYPE.TOGMTSTRING is the same Function object that is the
initial value of DATE.PROTOTYPE.TOUTCSTRING.

(informative)
The Strict Mode of ECMAScript

THE STRICT MODE RESTRICTION AND EXCEPTIONS

-   The identifiers "IMPLEMENTS", "INTERFACE", "LET", "PACKAGE",
      "PRIVATE", "PROTECTED", "PUBLIC", "STATIC", and "YIELD" are
      classified as FutureReservedWord tokens within strict mode code.
      (7.6.12).

-   A conforming implementation, when processing strict mode code, may
      not extend the syntax of NumericLiteral (7.8.3) to include
      OctalIntegerLiteral as described in B.1.1.

-   A conforming implementation, when processing strict mode code (see
      10.1.1), may not extend the syntax of EscapeSequence to include
      OctalEscapeSequence as described in B.1.2.

-   Assignment to an undeclared identifier or otherwise unresolvable
      reference does not create a property in the global object. When a
      simple assignment occurs within strict mode code, its
      LeftHandSide must not evaluate to an unresolvable Reference. If
      it does a REFERENCEERROR exception is thrown (8.7.2). The
      LeftHandSide also may not be a reference to a data property with
      the attribute value {[[Writable]]:FALSE}, to an accessor property
      with the attribute value {[[Set]]:UNDEFINED}, nor to a
      non-existent property of an object whose [[Extensible]] internal
      property has the value FALSE. In these cases a TYPEERROR exception
      is thrown (11.13.1).

-   The identifier EVAL or ARGUMENTS may not appear as the
      LeftHandSideExpression of an Assignment operator (11.13) or of a
      PostfixExpression (11.3) or as the UnaryExpression operated
      upon by a Prefix Increment (11.4.4) or a Prefix Decrement (11.4.5)
      operator.

-   Arguments objects for strict mode functions define non-configurable
      accessor properties named "CALLER" and "CALLEE" which throw a
      TYPEERROR exception on access (10.6).

-   Arguments objects for strict mode functions do not dynamically share
      their array indexed property values with the corresponding formal
      parameter bindings of their functions. (10.6).

-   For strict mode functions, if an arguments object is created the
      binding of the local identifier ARGUMENTS to the arguments object
      is immutable and hence may not be the target of an assignment
      expression. (10.5).

-   It is a SYNTAXERROR if strict mode code contains an ObjectLiteral
      with more than one definition of any data property (11.1.5).

-   It is a SYNTAXERROR if the Identifier "EVAL" or the Identifier
      "ARGUMENTS" occurs as the Identifier in a
      PropertySetParameterList of a PropertyAssignment that is
      contained in strict code or if its FunctionBody is strict code
      (11.1.5).

-   Strict mode eval code cannot instantiate variables or functions in
      the variable environment of the caller to eval. Instead, a new
      variable environment is created and that environment is used for
      declaration binding instantiation for the eval code (10.4.2).

-   If THIS is evaluated within strict mode code, then the THIS value is
      not coerced to an object. A THIS value of NULL or UNDEFINED is not
      converted to the global object and primitive values are not
      converted to wrapper objects. The THIS value passed via a function
      call (including calls made using FUNCTION.PROTOTYPE.APPLY and
      FUNCTION.PROTOTYPE.CALL) do not coerce the passed this value to an
      object (10.4.3, 11.1.1, 15.3.4.3, 15.3.4.4).

-   When a DELETE operator occurs within strict mode code, a SYNTAXERROR
      is thrown if its UnaryExpression is a direct reference to a
      variable, function argument, or function name(11.4.1).

-   When a DELETE operator occurs within strict mode code, a TYPEERROR
      is thrown if the property to be deleted has the attribute {
      [[Configurable]]:FALSE } (11.4.1).

-   It is a SYNTAXERROR if a VariableDeclaration or
      VariableDeclarationNoIn occurs within strict code and its
      Identifier is EVAL or ARGUMENTS (12.2.1).

-   Strict mode code may not include a WithStatement. The occurrence
      of a WithStatement in such a context is an SYNTAXERROR (12.10).

-   It is a SYNTAXERROR if a TryStatement with a Catch occurs within
      strict code and the Identifier of the Catch production is EVAL
      or ARGUMENTS (12.14.1)

-   It is a SYNTAXERROR if the identifier EVAL or ARGUMENTS appears
      within a FormalParameterList of a strict mode
      FunctionDeclaration or FunctionExpression (13.1)

-   A strict mode function may not have two or more formal parameters
      that have the same name. An attempt to create such a function
      using a FunctionDeclaration, FunctionExpression, or FUNCTION
      constructor is a SYNTAXERROR (13.1, 15.3.2).

-   An implementation may not extend, beyond that defined in this
      specification, the meanings within strict mode functions of
      properties named CALLER or ARGUMENTS of function instances.
      ECMAScript code may not create or modify properties with these
      names on function objects that correspond to strict mode functions
      (10.6, 13.2, 15.3.4.5.3).

-   It is a SYNTAXERROR to use within strict mode code the identifiers
      EVAL or ARGUMENTS as the Identifier of a FunctionDeclaration
      or FunctionExpression or as a formal parameter name (13.1).
      Attempting to dynamically define such a strict mode function using
      the FUNCTION constructor (15.3.2) will throw a SYNTAXERROR
      exception.

(informative)
Corrections and Clarifications in the 5^th^ Edition
with Possible 3^rd^ Edition Compatibility Impact

Throughout: In the Edition 3 specification the meaning of phrases such
as “as if by the expression NEW ARRAY()” are subject to
misinterpretation. In the Edition 5 specification text for all internal
references and invocations of standard built-in objects and methods has
been clarified by making it explicit that the intent is that the actual
built-in object is to be used rather than the current dynamic value of
the correspondingly named property.

11.8.1: ECMAScript generally uses a left to right evaluation order,
however the Edition 3 specification language for the > and <= operators
resulted in a partial right to left order. The specification has been
corrected for these operators such that it now specifies a full left to
right evaluation order. However, this change of order is potentially
observable if side-effects occur during the evaluation process.

11.1.4: Edition 5 clarifies the fact that a trailing comma at the end of
an ArrayInitialiser does not add to the length of the array. This is
not a semantic change from Edition 3 but some implementations may have
previously misinterpreted this.

11.2.3: Edition 5 reverses the order of steps 2 and 3 of the algorithm.
The original order as specified in Editions 1 through 3 was incorrectly
specified such that side-effects of evaluating Arguments could affect
the result of evaluating MemberExpression.

12.4: In Edition 3, an object is created, as if by NEW OBJECT()to serve
as the scope for resolving the name of the exception parameter passed to
a CATCH clause of a TRY statement. If the actual exception object is a
function and it is called from within the CATCH clause, the scope object
will be passed as the THIS value of the call. The body of the function
can then define new properties on its THIS value and those property
names become visible identifiers bindings within the scope of the CATCH
clause after the function returns. In Edition 5, when an exception
parameter is called as a function, UNDEFINED is passed as the THIS
value.

13: In Edition 3, the algorithm for the production FunctionExpression
with an Identifier adds an object created as if by NEW OBJECT() to the
scope chain to serve as a scope for looking up the name of the function.
The identifier resolution rules (10.1.4 in Edition 3) when applied to
such an object will, if necessary, follow the object’s prototype chain
when attempting to resolve an identifier. This means all the properties
of Object.prototype are visible as identifiers within that scope. In
practice most implementations of Edition 3 have not implemented this
semantics. Edition 5 changes the specified semantics by using a
Declarative Environment Record to bind the name of the function.

14: In Edition 3, the algorithm for the production SourceElements :
_SourceElements SourceElement_ did not correctly propagate statement
result values in the same manner as Block. This could result in the
EVAL function producing an incorrect result when evaluating a Program
text. In practice most implementations of Edition 3 have implemented the
correct propagation rather than what was specified in Edition 5.

15.10.6: RegExp.prototype is now a RegExp object rather than an instance
of Object. The value of its [[Class]] internal property which is
observable using Object.prototype.toString is now “RegExp” rather than
“Object”.

(informative)
Additions and Changes in the 5^th^ Edition that
Introduce Incompatibilities with the 3^rd^ Edition

7.1: Unicode format control characters are no longer stripped from
ECMAScript source text before processing. In Edition 5, if such a
character appears in a StringLiteral or RegularExpressionLiteral the
character will be incorporated into the literal where in Edition 3 the
character would not be incorporated into the literal.

7.2: Unicode character <BOM> is now treated as whitespace and its
presence in the middle of what appears to be an identifier could result
in a syntax error which would not have occurred in Edition 3

7.3: Line terminator characters that are preceded by an escape sequence
are now allowed within a string literal token. In Edition 3 a syntax
error would have been produced.

7.8.5: Regular expression literals now return a unique object each time
the literal is evaluated. This change is detectable by any programs that
test the object identity of such literal values or that are sensitive to
the shared side effects.

7.8.5: Edition 5 requires early reporting of any possible RegExp
constructor errors that would be produced when converting a
RegularExpressionLiteral to a RegExp object. Prior to Edition 5
implementations were permitted to defer the reporting of such errors
until the actual execution time creation of the object.

7.8.5: In Edition 5 unescaped “/” characters may appear as a
CharacterClass in a regular expression literal. In Edition 3 such a
character would have been interpreted as the final character of the
literal.

10.4.2: In Edition 5, indirect calls to the EVAL function use the global
environment as both the variable environment and lexical environment for
the eval code. In Edition 3, the variable and lexical environments of
the caller of an indirect EVAL was used as the environments for the eval
code.

15.4.4: In Edition 5 all methods of ARRAY.PROTOTYPE are intentionally
generic. In Edition 3 TOSTRING and TOLOCALESTRING were not generic and
would throw a TYPEERROR exception if applied to objects that were not
instances of Array.

10.6: In Edition 5 the array indexed properties of argument objects that
correspond to actual formal parameters are enumerable. In Edition 3,
such properties were not enumerable.

10.6: In Edition 5 the value of the [[Class]] internal property of an
arguments object is "ARGUMENTS". In Edition 3, it was "OBJECT". This is
observable if TOSTRING is called as a method of an arguments object.

12.6.4: for-in statements no longer throw a TYPEERROR if the IN
expression evaluates to NULL or UNDEFINED. Instead, the statement
behaves as if the value of the expression was an object with no
enumerable properties.

15: In Edition 5, the following new properties are defined on built-in
objects that exist in Edition 3: OBJECT.GETPROTOTYPEOF,
OBJECT.GETOWNPROPERTYDESCRIPTOR, OBJECT.GETOWNPROPERTYNAMES,
OBJECT.CREATE, OBJECT.DEFINEPROPERTY, OBJECT.DEFINEPROPERTIES,
OBJECT.SEAL, OBJECT.FREEZE, OBJECT.PREVENTEXTENSIONS, OBJECT.ISSEALED,
OBJECT.ISFROZEN, OBJECT.ISEXTENSIBLE, OBJECT.KEYS,
FUNCTION.PROTOTYPE.BIND, ARRAY.PROTOTYPE.INDEXOF,
ARRAY.PROTOTYPE.LASTINDEXOF, ARRAY.PROTOTYPE.EVERY,
ARRAY.PROTOTYPE.SOME, ARRAY.PROTOTYPE.FOREACH, ARRAY.PROTOTYPE.MAP,
ARRAY.PROTOTYPE.FILTER, ARRAY.PROTOTYPE.REDUCE,
ARRAY.PROTOTYPE.REDUCERIGHT, STRING.PROTOTYPE.TRIM, DATE.NOW,
DATE.PROTOTYPE.TOISOSTRING, DATE.PROTOTYPE.TOJSON.

15: Implementations are now required to ignore extra arguments to
standard built-in methods unless otherwise explicitly specified. In
Edition 3 the handling of extra arguments was unspecified and
implementations were explicitly allowed to throw a TYPEERROR exception.

15.1.1: The value properties NAN, INFINITY, and UNDEFINED of the Global
Object have been changed to be read-only properties.

15.1.2.1. Implementations are no longer permitted to restrict the use of
eval in ways that are not a direct call. In addition, any invocation of
eval that is not a direct call uses the global environment as its
variable environment rather than the caller’s variable environment.

15.1.2.2: The specification of the function PARSEINT no longer allows
implementations to treat Strings beginning with a 0 character as octal
values.

15.3.4.3: In Edition 3, a TYPEERROR is thrown if the second argument
passed to FUNCTION.PROTOTYPE.APPLY is neither an array object nor an
arguments object. In Edition 5, the second argument may be any kind of
generic array-like object that has a valid LENGTH property.

15.3.4.3, 15.3.4.4: In Edition 3 passing UNDEFINED or NULL as the first
argument to either FUNCTION.PROTOTYPE.APPLY or FUNCTION.PROTOTYPE.CALL
causes the global object to be passed to the indirectly invoked target
function as the THIS value. If the first argument is a primitive value
the result of calling ToObject on the primitive value is passed as the
THIS value. In Edition 5, these transformations are not performed and
the actual first argument value is passed as the THIS value. This
difference will normally be unobservable to existing ECMAScript Edition
3 code because a corresponding transformation takes place upon
activation of the target function. However, depending upon the
implementation, this difference may be observable by host object
functions called using APPLY or CALL. In addition, invoking a standard
built-in function in this manner with NULL or UNDEFINED passed as the
this value will in many cases cause behaviour in Edition 5
implementations that differ from Edition 3 behaviour. In particular, in
Edition 5 built-in functions that are specified to actually use the
passed THIS value as an object typically throw a TYPEERROR exception if
passed NULL or UNDEFINED as the THIS value.

15.3.5.2: In Edition 5, the PROTOTYPE property of Function instances is
not enumerable. In Edition 3, this property was enumerable.

15.5.5.2: In Edition 5, the individual characters of a String object’s
[[PrimitiveValue] may be accessed as array indexed properties of the
String object. These properties are non-writable and non-configurable
and shadow any inherited properties with the same names. In Edition 3,
these properties did not exist and ECMAScript code could dynamically add
and remove writable properties with such names and could access
inherited properties with such names.

15.9.4.2: DATE.PARSE is now required to first attempt to parse its
argument as an ISO format string. Programs that use this format but
depended upon implementation specific behaviour (including failure) may
behave differently.

15.10.2.12: In Edition 5, \S now additionally matches <BOM>.

15.10.4.1: In Edition 3, the exact form of the String value of the
SOURCE property of an object created by the REGEXP constructor is
implementation defined. In Edition 5, the String must conform to certain
specified requirements and hence may be different from that produced by
an Edition 3 implementation.

15.10.6.4: In Edition 3, the result of REGEXP.PROTOTYPE.TOSTRING need
not be derived from the value of the RegExp object’s SOURCE property. In
Edition 5 the result must be derived from the SOURCE property in a
specified manner and hence may be different from the result produced by
an Edition 3 implementation.

15.11.2.1, 15.11.4.3: In Edition 5, if an initial value for the MESSAGE
property of an Error object is not specified via the ERROR constructor
the initial value of the property is the empty String. In Edition 3,
such an initial value is implementation defined.

15.11.4.4: In Edition 3, the result of ERROR.PROTOTYPE.TOSTRING is
implementation defined. In Edition 5, the result is fully specified and
hence may differ from some Edition 3 implementations.

15.12: In Edition 5, the name JSON is defined in the global environment.
In Edition 3, testing for the presence of that name will show it to be
undefined unless it is defined by the program or implementation.

(informative)
Technically Significant Corrections and Clarifications in the 5.1
Edition

7.8.4: CV definitions added for DoubleStringCharacter ::
LineContinuation and SingleStringCharacter :: LineContinuation.

10.2.1.1.3: The argument S is not ignored. It controls whether an
exception is thrown when attempting to set an immutable binding.

10.2.1.2.2: In algorithm step 5, TRUE is passed as the last argument to
[[DefineOwnProperty]].

10.5: Former algorithm step 5.e is now 5.f and a new step 5.e was added
to restore compatibility with 3^rd^ Edition when redefining global
functions.

11.5.3: In the final bullet item, use of IEEE 754 round-to-nearest mode
is specified.

12.6.3: Missing ToBoolean restored in step 3.a.ii of both algorithms.

12.6.4: Additional final sentences in each of the last two paragraphs
clarify certain property enumeration requirements.

12.7, 12.8, 12.9: BNF modified to clarify that a CONTINUE or BREAK
statement without an Identifier or a RETURN statement without an
Expression may have a LineTerminator before the semi-colon.

12.14: Step 3 of algorithm 1 and step 2.a of algorithm 3 are corrected
such that the value field of B is passed as a parameter rather than
B itself.

15.1.2.2: In step 2 of algorithm, clarify that S may be the empty
string.

15.1.2.3: In step 2 of algorithm clarify that trimmedString may be the
empty string.

15.1.3: Added notes clarifying that ECMAScript’s URI syntax is based
upon RFC 2396 and not the newer RFC 3986. In the algorithm for Decode, a
step was removed that immediately preceded the current step 4.d.vii.10.a
because it tested for a condition that cannot occur.

15.2.3.7: Corrected use of variable P in steps 5 and 6 of algorithm.

15.2.4.2: Edition 5 handling of UNDEFINED and NULL as THIS value caused
existing code to fail. Specification modified to maintain compatibility
with such code. New steps 1 and 2 added to the algorithm.

15.3.4.3: Steps 5 and 7 of Edition 5 algorithm have been deleted because
they imposed requirements upon the argArray argument that are
inconsistent with other uses of generic array-like objects.

15.4.4.12: In step 9.a, incorrect reference to relativeStart was
replaced with a reference to actualStart.

15.4.4.15: Clarified that the default value for fromIndex is the
length minus 1 of the array.

15.4.4.18: In step 9 of the algorithm, UNDEFINED is now the specified
return value.

15.4.4.22: In step 9.c.ii the first argument to the [[Call]] internal
method has been changed to UNDEFINED for consistency with the definition
of Array.prototype.reduce.

15.4.5.1: In Algorithm steps 3.l.ii and 3.l.iii the variable name was
inverted resulting in an incorrectly inverted test.

15.5.4.9: Normative requirement concerning canonically equivalent
strings deleted from paragraph following algorithm because it is listed
as a recommendation in NOTE 2.

15.5.4.14: In split algorithm step 11.a and 13.a, the positional order
of the arguments to SplitMatch was corrected to match the actual
parameter signature of SplitMatch. In step 13.a.iii.7.d, lengthA
replaces A.length.

15.5.5.2: In first paragraph, removed the implication that the
individual character property access had “array index” semantics.
Modified algorithm steps 3 and 5 such that they do not enforce “array
index” requirement.

15.9.1.15: Specified legal value ranges for fields that lacked them.
Eliminated “time-only” formats. Specified default values for all
optional fields.

15.10.2.2: The step numbers of the algorithm for the internal closure
produced by step 2 were incorrectly numbered in a manner that implied
that they were steps of the outer algorithm.

15.10.2.6: In the abstract operation IsWordChar the first character in
the list in step 3 is “A” rather than “A”.

15.10.2.8: In the algorithm for the closure returned by the abstract
operation CharacterSetMatcher, the variable defined by step 3 and
passed as an argument in step 4 was renamed to ch in order to avoid a
name conflict with a formal parameter of the closure.

15.10.6.2: Step 9.e was deleted because It performed an extra increment
of i.

15.11.1.1: Removed requirement that the message own property is set to
the empty String when the message argument is UNDEFINED.

15.11.1.2: Removed requirement that the message own property is set to
the empty String when the message argument is UNDEFINED.

15.11.4.4: Steps 6-10 modified/added to correctly deal with missing or
empty message property value.

15.11.1.2: Removed requirement that the message own property is set to
the empty String when the message argument is UNDEFINED.

15.12.3: In step 10.b.iii of the JA internal operation, the last
element of the concatenation is “]”.

B.2.1: Added to NOTE that the encoding is based upon RFC 1738 rather
than the newer RFC 3986.

Annex C: An item was added corresponding to 7.6.12 regarding
FutureReservedWords in strict mode.

Bibliography

IEEE Std 754-2008: IEEE Standard for Floating-Point Arithmetic.
Institute of Electrical and Electronic Engineers, New York (2008)

The Unicode Consortium. The Unicode Standard, Version 3.0, defined by:
The Unicode Standard, Version 3.0 (Reading, MA, Addison-Wesley, 2000.
ISBN 0-201-61633-5)

Unicode Inc. (2010), Unicode Technical Report #15: Unicode Normalization
Forms

ISO 8601:2004(E) _Data elements and interchange formats – Information
interchange -- Representation of dates and times_

RFC 1738 "Uniform Resource Locators (URL)", available at
<http://tools.ietf.org/html/rfc1738>

RFC 2396 "Uniform Resource Identifiers (URI): Generic Syntax", available
at <http://tools.ietf.org/html/rfc2396>

RFC 3629 "UTF-8, a transformation format of ISO 10646", available at
<http://tools.ietf.org/html/rfc3629>

RFC 4627 "The application/json Media Type for JavaScript Object Notation
(JSON)" , available at <http://tools.ietf.org/html/rfc4627>

[1] Note: Please note that for ECMAScript Edition 4 the Ecma standard
number “ECMA-262 Edition 4” was reserved but not used in the Ecma
publication process. Therefore “ECMA-262 Edition 4” as an Ecma
International publication does not exist.
