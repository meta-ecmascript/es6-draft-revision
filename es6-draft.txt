Contents Page

Introduction vii

1 Scope 1

2 Conformance 1

3 _Normative references_ 1

4 Overview 2

4.1 _Web Scripting_ 3

4.2 _ECMAScript Overview_ 3

4.2.1 Objects 4

4.2.2 _The Strict Variant of ECMAScript_ 5

4.3 _Terms and definitions_ 6

4.4 _Organization of This Specification_ 10

5 _Notational Conventions_ 10

5.1 _Syntactic and Lexical Grammars_ 10

5.1.1 _Context-Free Grammars_ 10

5.1.2 _The Lexical and RegExp Grammars_ 11

5.1.3 _The Numeric String Grammar_ 11

5.1.4 _The Syntactic Grammar_ 11

5.1.5 _Grammar Notation_ 12

5.2 _Algorithm Conventions_ 17

5.3 _Static Semantic Rules_ 19

6 _ECMAScript Data Types and Values_ 19

6.1 _ECMAScript Language Types_ 20

6.1.1 _The Undefined Type_ 20

6.1.2 _The Null Type_ 20

6.1.3 _The Boolean Type_ 20

6.1.4 _The String Type_ 20

6.1.5 _The Symbol Type_ 21

6.1.6 _The Number Type_ 22

6.1.7 _The Object Type_ 24

6.2 _ECMAScript Specification Types_ 34

6.2.1 _The List and Record Specification Type_ 34

6.2.2 _The Completion Record Specification Type_ 34

6.2.3 _The Reference Specification Type_ 36

6.2.4 _The Property Descriptor Specification Type_ 37

6.2.5 _The Lexical Environment and Environment Record Specification
Types_ 40

6.2.6 _Data Blocks_ 40

7 _Abstract Operations_ 41

7.1 _Type Conversion_ 41

7.1.1 _ToPrimitive ( input [, PreferredType] )_ 41

7.1.2 _ToBoolean ( argument )_ 42

7.1.3 _ToNumber ( argument )_ 43

7.1.4 _ToInteger ( argument )_ 45

7.1.5 _ToInt32 ( argument ) — Signed 32 Bit Integer_ 46

7.1.6 _ToUint32 ( argument ) — Unsigned 32 Bit Integer_ 46

7.1.7 _ToInt16 ( argument ) — Signed 16 Bit Integer_ 46

7.1.8 _ToUint16 ( argument ) — Unsigned 16 Bit Integer_ 47

7.1.9 _ToInt8 ( argument ) — Signed 8 Bit Integer_ 47

7.1.10 _ToUint8 ( argument ) — Unsigned 8 Bit Integer_ 47

7.1.11 _ToUint8Clamp ( argument ) — Unsigned 8 Bit Integer, Clamped_
47

7.1.12 _ToString ( argument )_ 48

7.1.13 _ToObject ( argument )_ 49

7.1.14 _ToPropertyKey ( argument )_ 50

7.1.15 _ToLength ( argument )_ 50

7.1.16 _CanonicalNumericIndexString ( argument )_ 50

7.2 _Testing and Comparison Operations_ 51

7.2.1 _RequireObjectCoercible ( argument )_ 51

7.2.2 _IsArray ( argument )_ 51

7.2.3 _IsCallable ( argument )_ 51

7.2.4 _IsConstructor ( argument )_ 51

7.2.5 _IsExtensible (O)_ 52

7.2.6 _IsInteger ( argument )_ 52

7.2.7 _IsPropertyKey ( argument )_ 52

7.2.8 _IsRegExp ( argument )_ 52

7.2.9 _SameValue(x, y)_ 52

7.2.10 _SameValueZero(x, y)_ 53

7.2.11 _Abstract Relational Comparison_ 53

7.2.12 _Abstract Equality Comparison_ 54

7.2.13 _Strict Equality Comparison_ 55

7.3 _Operations on Objects_ 55

7.3.1 _Get (O, P)_ 55

7.3.2 _GetV (V, P)_ 56

7.3.3 _Put (O, P, V, Throw)_ 56

7.3.4 _CreateDataProperty (O, P, V)_ 56

7.3.5 _CreateDataPropertyOrThrow (O, P, V)_ 56

7.3.6 _DefinePropertyOrThrow (O, P, desc)_ 57

7.3.7 _DeletePropertyOrThrow (O, P)_ 57

7.3.8 _GetMethod (O, P)_ 57

7.3.9 _HasProperty (O, P)_ 58

7.3.10 _HasOwnProperty (O, P)_ 58

7.3.11 _Call(F, V, [argumentsList])_ 58

7.3.12 _Invoke(O,P, [argumentsList])_ 58

7.3.13 _Construct (F, [argumentsList], [newTarget])_ 59

7.3.14 _SetIntegrityLevel (O, level)_ 59

7.3.15 _TestIntegrityLevel (O, level)_ 59

7.3.16 _CreateArrayFromList (elements)_ 60

7.3.17 _CreateListFromArrayLike (obj [, elementTypes] )_ 60

7.3.18 _OrdinaryHasInstance (C, O)_ 61

7.3.19 _SpeciesConstructor ( O, defaultConstructor )_ 61

7.3.20 _EnumerableOwnNames (O)_ 61

7.3.21 _GetFunctionRealm ( obj ) Abstract Operation_ 62

7.4 _Operations on Iterator Objects_ 62

7.4.1 _GetIterator ( obj, method )_ 62

7.4.2 _IteratorNext ( iterator, value )_ 62

7.4.3 _IteratorComplete ( iterResult )_ 63

7.4.4 _IteratorValue ( iterResult )_ 63

7.4.5 _IteratorStep ( iterator )_ 63

7.4.6 _IteratorClose( iterator, completion )_ 63

7.4.7 _CreateIterResultObject ( value, done )_ 63

7.4.8 _CreateListIterator ( list )_ 64

7.4.9 _CreateCompoundIterator ( iterator1, iterator2 )_ 64

8 _Executable Code and Execution Contexts_ 65

8.1 _Lexical Environments_ 65

8.1.1 _Environment Records_ 66

8.1.2 _Lexical Environment Operations_ 82

8.2 _Code Realms_ 84

8.2.1 _CreateRealm ( ) Abstract Operation_ 84

8.2.2 _CreateIntrinsics ( realmRec ) Abstract Operation_ 84

8.2.3 _SetRealmGlobalObj ( realmRec, globalObj ) Abstract Operation_
85

8.2.4 _SetDefaultGlobalBindings ( realmRec ) Abstract Operation_ 85

8.3 _Execution Contexts_ 86

8.3.1 _ResolveBinding ( name ) Abstract Operation_ 87

8.3.2 _GetThisEnvironment ( ) Abstract Operation_ 87

8.3.3 _ResolveThisBinding ( ) Abstract Operation_ 87

8.3.4 _GetNewTarget ( ) Abstract Operation_ 88

8.3.5 _GetGlobalObject ( ) Abstract Operation_ 88

8.4 _Jobs and Job Queues_ 88

8.4.1 _EnqueueJob ( queueName, job, arguments) Abstract Operation_ 89

8.4.2 _NextJob result_ 89

8.5 Initialization 90

8.5.1 _InitializeFirstRealm ( realm ) Abstract Operation_ 90

8.6 _Host Provided Services_ 91

8.6.1 _HostGetSource (sourceCodeId) Abstract Operation_ 91

8.6.2 _HostNormalizeModuleName ( unnormalizedName, referrerId)
Abstract Operation_ 91

9 _Ordinary and Exotic Objects Behaviours_ 91

9.1 _Ordinary Object Internal Methods and Internal Slots_ 91

9.1.1 _[[GetPrototypeOf]] ( )_ 92

9.1.2 _[[SetPrototypeOf]] (V)_ 92

9.1.3 _[[IsExtensible]] ( )_ 92

9.1.4 _[[PreventExtensions]] ( )_ 92

9.1.5 _[[GetOwnProperty]] (P)_ 93

9.1.6 _[[DefineOwnProperty]] (P, Desc)_ 93

9.1.7 [[HasProperty]](P) 95

9.1.8 _[[Get]] (P, Receiver)_ 95

9.1.9 _[[Set]] ( P, V, Receiver)_ 96

9.1.10 _[[Delete]] (P)_ 96

9.1.11 _[[Enumerate]] ()_ 96

9.1.12 _[[OwnPropertyKeys]] ( )_ 97

9.1.13 _ObjectCreate(proto, internalSlotsList) Abstract Operation_ 98

9.1.14 _OrdinaryCreateFromConstructor ( constructor,
intrinsicDefaultProto, internalSlotsList )_ 98

9.1.15 _GetPrototypeFromConstructor ( constructor,
intrinsicDefaultProto )_ 98

9.2 _ECMAScript Function Objects_ 98

9.2.1 _[[GetOwnProperty]] (P)_ 100

9.2.2 _[[Call]] ( thisArgument, argumentsList)_ 100

9.2.3 _[[Construct]] ( argumentsList, newTarget)_ 101

9.2.4 _FunctionAllocate (functionPrototype, strict [,functionKind] )
Abstract Operation_ 102

9.2.5 _FunctionInitialize (F, kind, Strict, ParameterList, Body,
Scope) Abstract Operation_ 103

9.2.6 _FunctionCreate (kind, ParameterList, Body, Scope, Strict)
Abstract Operation_ 103

9.2.7 _GeneratorFunctionCreate (kind, ParameterList, Body, Scope,
Strict) Abstract Operation_ 103

9.2.8 _AddRestrictedFunctionProperties ( F, realm ) Abstract
Operation_ 104

9.2.9 _MakeConstructor (F, writablePrototype, prototype) Abstract
Operation_ 104

9.2.10 _MakeClassConstructor ( F) Abstract Operation_ 105

9.2.11 _MakeMethod ( F, homeObject) Abstract Operation_ 105

9.2.12 _SetFunctionName (F, name, prefix) Abstract Operation_ 105

9.2.13 _FunctionDeclarationInstantiation(func, argumentsList, env )
Abstract Operation_ 105

9.3 _Built-in Function Objects_ 108

9.3.1 _[[Call]] ( thisArgument, argumentsList)_ 109

9.3.2 _[[Construct]] (argumentsList, newTarget)_ 109

9.3.3 _CreateBuiltinFunction(realm, steps, prototype,
internalSlotsList) Abstract Operation_ 110

9.4 _Built-in Exotic Object Internal Methods and Slots_ 110

9.4.1 _Bound Function Exotic Objects_ 110

9.4.2 _Array Exotic Objects_ 111

9.4.3 _String Exotic Objects_ 114

9.4.4 _Arguments Exotic Objects_ 116

9.4.5 _Integer Indexed Exotic Objects_ 121

9.4.6 _Module Namespace Exotic Objects_ 125

9.5 _Proxy Object Internal Methods and Internal Slots_ 128

9.5.1 _[[GetPrototypeOf]] ( )_ 129

9.5.2 _[[SetPrototypeOf]] (V)_ 129

9.5.3 _[[IsExtensible]] ( )_ 130

9.5.4 _[[PreventExtensions]] ( )_ 130

9.5.5 _[[GetOwnProperty]] (P)_ 131

9.5.6 _[[DefineOwnProperty]] (P, Desc)_ 132

9.5.7 _[[HasProperty]] (P)_ 133

9.5.8 _[[Get]] (P, Receiver)_ 133

9.5.9 _[[Set]] ( P, V, Receiver)_ 134

9.5.10 _[[Delete]] (P)_ 134

9.5.11 _[[Enumerate]] ()_ 135

9.5.12 _[[OwnPropertyKeys]] ( )_ 135

9.5.13 _[[Call]] (thisArgument, argumentsList)_ 136

9.5.14 _[[Construct]] ( argumentsList, newTarget)_ 137

9.5.15 _ProxyCreate(target, handler) Abstract Operation_ 137

10 _ECMAScript Language: Source Code_ 138

10.1 _Source Text_ 138

10.1.1 _Static Semantics: UTF-16Encoding_ 138

10.1.2 _Static Semantics: UTF16Decode(lead, trail)_ 138

10.2 _Types of Source Code_ 139

10.2.1 _Strict Mode Code_ 139

10.2.2 _Non-ECMAScript Functions_ 140

11 _ECMAScript Language: Lexical Grammar_ 140

11.1 _Unicode Format-Control Characters_ 141

11.2 _White Space_ 141

11.3 _Line Terminators_ 142

11.4 Comments 143

11.5 Tokens 144

11.6 _Names and Keywords_ 144

11.6.1 _Identifier Names_ 146

11.6.2 _Reserved Words_ 146

11.7 Punctuators 147

11.8 Literals 148

11.8.1 _Null Literals_ 148

11.8.2 _Boolean Literals_ 148

11.8.3 _Numeric Literals_ 148

11.8.4 _String Literals_ 151

11.8.5 _Regular Expression Literals_ 154

11.8.6 _Template Literal Lexical Components_ 156

11.9 _Automatic Semicolon Insertion_ 158

11.9.1 _Rules of Automatic Semicolon Insertion_ 158

11.9.2 _Examples of Automatic Semicolon Insertion_ 160

12 _ECMAScript Language: Expressions_ 161

12.1 Identifiers 161

12.1.1 _Static Semantics: Early Errors_ 162

12.1.2 _Static Semantics: BoundNames_ 162

12.1.3 _Static Semantics: IsValidSimpleAssignmentTarget_ 162

12.1.4 _Static Semantics: StringValue_ 163

12.1.5 _Runtime Semantics: BindingInitialization_ 163

12.1.6 _Runtime Semantics: Evaluation_ 164

12.2 _Primary Expression_ 164

12.2.0 Semantics 165

12.2.1 _The this Keyword_ 166

12.2.2 _Identifier Reference_ 166

12.2.3 Literals 167

12.2.4 _Array Initializer_ 167

12.2.5 _Object Initializer_ 170

12.2.6 _Function Defining Expressions_ 174

12.2.7 _Regular Expression Literals_ 174

12.2.8 _Template Literals_ 175

12.2.9 _The Grouping Operator_ 179

12.3 _Left-Hand-Side Expressions_ 180

12.3.1 _Static Semantics_ 181

12.3.2 _Property Accessors_ 184

12.3.3 _The new Operator_ 185

12.3.4 _Function Calls_ 186

12.3.5 _The super Keyword_ 187

12.3.6 _Argument Lists_ 188

12.3.7 _Tagged Templates_ 189

12.3.8 _Meta Properties_ 190

12.4 _Postfix Expressions_ 190

12.4.1 _Static Semantics: Early Errors_ 190

12.4.2 _Static Semantics: IsFunctionDefinition_ 190

12.4.3 _Static Semantics: IsValidSimpleAssignmentTarget_ 190

12.4.4 _Postfix Increment Operator_ 191

12.4.5 _Postfix Decrement Operator_ 191

12.5 _Unary Operators_ 191

12.5.1 _Static Semantics: Early Errors_ 191

12.5.2 _Static Semantics: IsFunctionDefinition_ 192

12.5.3 _Static Semantics: IsValidSimpleAssignmentTarget_ 192

12.5.4 _The delete Operator_ 192

12.5.5 _The void Operator_ 193

12.5.6 _The typeof Operator_ 193

12.5.7 _Prefix Increment Operator_ 194

12.5.8 _Prefix Decrement Operator_ 194

12.5.9 _Unary + Operator_ 195

12.5.10 _Unary - Operator_ 195

12.5.11 _Bitwise NOT Operator ( ~ )_ 195

12.5.12 _Logical NOT Operator ( ! )_ 195

12.6 _Multiplicative Operators_ 196

12.6.1 _Static Semantics: IsFunctionDefinition_ 196

12.6.2 _Static Semantics: IsValidSimpleAssignmentTarget_ 196

12.6.3 _Runtime Semantics: Evaluation_ 196

12.7 _Additive Operators_ 198

12.7.1 _Static Semantics: IsFunctionDefinition_ 198

12.7.2 _Static Semantics: IsValidSimpleAssignmentTarget_ 198

12.7.3 _The Addition operator ( + )_ 199

12.7.4 _The Subtraction Operator ( - )_ 199

12.7.5 _Applying the Additive Operators to Numbers_ 200

12.8 _Bitwise Shift Operators_ 200

12.8.1 _Static Semantics: IsFunctionDefinition_ 200

12.8.2 _Static Semantics: IsValidSimpleAssignmentTarget_ 201

12.8.3 _The Left Shift Operator ( << )_ 201

12.8.4 _The Signed Right Shift Operator ( >> )_ 201

12.8.5 _The Unsigned Right Shift Operator ( >>> )_ 202

12.9 _Relational Operators_ 202

12.9.1 _Static Semantics: IsFunctionDefinition_ 203

12.9.2 _Static Semantics: IsValidSimpleAssignmentTarget_ 203

12.9.3 _Runtime Semantics: Evaluation_ 203

12.9.4 _Runtime Semantics: InstanceofOperator(O, C)_ 204

12.10 _Equality Operators_ 205

12.10.1 _Static Semantics: IsFunctionDefinition_ 205

12.10.2 _Static Semantics: IsValidSimpleAssignmentTarget_ 205

12.10.3 _Runtime Semantics: Evaluation_ 206

12.11 _Binary Bitwise Operators_ 207

12.11.1 _Static Semantics: IsFunctionDefinition_ 207

12.11.2 _Static Semantics: IsValidSimpleAssignmentTarget_ 207

12.11.3 _Runtime Semantics: Evaluation_ 207

12.12 _Binary Logical Operators_ 208

12.12.1 _Static Semantics: IsFunctionDefinition_ 208

12.12.2 _Static Semantics: IsValidSimpleAssignmentTarget_ 208

12.12.3 _Runtime Semantics: Evaluation_ 208

12.13 _Conditional Operator ( ? : )_ 209

12.13.1 _Static Semantics: IsFunctionDefinition_ 209

12.13.2 _Static Semantics: IsValidSimpleAssignmentTarget_ 209

12.13.3 _Runtime Semantics: Evaluation_ 209

12.14 _Assignment Operators_ 210

12.14.1 _Static Semantics: Early Errors_ 210

12.14.2 _Static Semantics: IsFunctionDefinition_ 210

12.14.3 _Static Semantics: IsValidSimpleAssignmentTarget_ 211

12.14.4 _Runtime Semantics: Evaluation_ 211

12.14.5 _Destructuring Assignment_ 212

12.15 _Comma Operator ( , )_ 217

12.15.1 _Static Semantics: IsFunctionDefinition_ 217

12.15.2 _Static Semantics: IsValidSimpleAssignmentTarget_ 217

12.15.3 _Runtime Semantics: Evaluation_ 217

13 _ECMAScript Language: Statements and Declarations_ 218

13.0 _Statement Semantics_ 218

13.0.1 _Static Semantics: ContainsDuplicateLabels_ 218

13.0.2 _Static Semantics: ContainsUndefinedBreakTarget_ 219

13.0.3 _Static Semantics: ContainsUndefinedContinueTarget_ 219

13.0.4 _Static Semantics: DeclarationPart_ 219

13.0.5 _Static Semantics: VarDeclaredNames_ 220

13.0.6 _Static Semantics: VarScopedDeclarations_ 220

13.0.7 _Runtime Semantics: LabelledEvaluation_ 220

13.0.8 _Runtime Semantics: Evaluation_ 221

13.1 Block 221

13.1.1 _Static Semantics: Early Errors_ 221

13.1.2 _Static Semantics: ContainsDuplicateLabels_ 221

13.1.3 _Static Semantics: ContainsUndefinedBreakTarget_ 222

13.1.4 _Static Semantics: ContainsUndefinedContinueTarget_ 222

13.1.5 _Static Semantics: LexicallyDeclaredNames_ 223

13.1.6 _Static Semantics: LexicallyScopedDeclarations_ 223

13.1.7 _Static Semantics: TopLevelLexicallyDeclaredNames_ 223

13.1.8 _Static Semantics: TopLevelLexicallyScopedDeclarations_ 224

13.1.9 _Static Semantics: TopLevelVarDeclaredNames_ 224

13.1.10 _Static Semantics: TopLevelVarScopedDeclarations_ 225

13.1.11 _Static Semantics: VarDeclaredNames_ 225

13.1.12 _Static Semantics: VarScopedDeclarations_ 226

13.1.13 _Runtime Semantics: Evaluation_ 226

13.1.14 _Runtime Semantics: BlockDeclarationInstantiation( code, env
)_ 227

13.2 _Declarations and the Variable Statement_ 227

13.2.1 _Let and Const Declarations_ 227

13.2.2 _Variable Statement_ 229

13.2.3 _Destructuring Binding Patterns_ 231

13.3 _Empty Statement_ 239

13.3.1 _Runtime Semantics: Evaluation_ 239

13.4 _Expression Statement_ 239

13.4.1 _Runtime Semantics: Evaluation_ 240

13.5 _The if Statement_ 240

13.5.1 _Static Semantics: Early Errors_ 240

13.5.2 _Static Semantics: ContainsDuplicateLabels_ 240

13.5.3 _Static Semantics: ContainsUndefinedBreakTarget_ 240

13.5.4 _Static Semantics: ContainsUndefinedContinueTarget_ 241

13.5.5 _Static Semantics: VarDeclaredNames_ 241

13.5.6 _Static Semantics: VarScopedDeclarations_ 241

13.5.7 _Runtime Semantics: Evaluation_ 242

13.6 _Iteration Statements_ 242

13.6.0 Semantics 243

13.6.1 _The do-while Statement_ 243

13.6.2 _The while Statement_ 245

13.6.3 _The for Statement_ 246

13.6.4 _The for-in and for-of Statements_ 250

13.7 _The continue Statement_ 256

13.7.1 _Static Semantics: Early Errors_ 257

13.7.2 _Static Semantics: ContainsUndefinedContinueTarget_ 257

13.7.3 _Runtime Semantics: Evaluation_ 257

13.8 _The break Statement_ 257

13.8.1 _Static Semantics: Early Errors_ 257

13.8.2 _Static Semantics: ContainsUndefinedBreakTarget_ 257

13.8.3 _Runtime Semantics: Evaluation_ 258

13.9 _The return Statement_ 258

13.9.1 _Runtime Semantics: Evaluation_ 258

13.10 _The with Statement_ 258

13.10.1 _Static Semantics: Early Errors_ 259

13.10.2 _Static Semantics: ContainsDuplicateLabels_ 259

13.10.3 _Static Semantics: ContainsUndefinedBreakTarget_ 259

13.10.4 _Static Semantics: ContainsUndefinedContinueTarget_ 259

13.10.5 _Static Semantics: VarDeclaredNames_ 259

13.10.6 _Static Semantics: VarScopedDeclarations_ 260

13.10.7 _Runtime Semantics: Evaluation_ 260

13.11 _The switch Statement_ 260

13.11.1 _Static Semantics: Early Errors_ 260

13.11.2 _Static Semantics: ContainsDuplicateLabels_ 261

13.11.3 _Static Semantics: ContainsUndefinedBreakTarget_ 261

13.11.4 _Static Semantics: ContainsUndefinedContinueTarget_ 262

13.11.5 _Static Semantics: LexicallyDeclaredNames_ 263

13.11.6 _Static Semantics: LexicallyScopedDeclarations_ 264

13.11.7 _Static Semantics: VarDeclaredNames_ 264

13.11.8 _Static Semantics: VarScopedDeclarations_ 265

13.11.9 _Runtime Semantics: CaseBlockEvaluation_ 266

13.11.10 _Runtime Semantics: CaseSelectorEvaluation_ 267

13.11.11 _Runtime Semantics: Evaluation_ 267

13.12 _Labelled Statements_ 268

13.12.1 _Static Semantics: Early Errors_ 268

13.12.2 _Static Semantics: ContainsDuplicateLabels_ 268

13.12.3 _Static Semantics: ContainsUndefinedBreakTarget_ 269

13.12.4 _Static Semantics: ContainsUndefinedContinueTarget_ 269

13.12.5 _Static Semantics: IsLabelledFunction ( stmt )_ 269

13.12.6 _Static Semantics: LexicallyDeclaredNames_ 270

13.12.7 _Static Semantics: LexicallyScopedDeclarations_ 270

13.12.8 _Static Semantics: TopLevelLexicallyDeclaredNames_ 270

13.12.9 _Static Semantics: TopLevelLexicallyScopedDeclarations_ 270

13.12.10 _Static Semantics: TopLevelVarDeclaredNames_ 270

13.12.11 _Static Semantics: TopLevelVarScopedDeclarations_ 271

13.12.12 _Static Semantics: VarDeclaredNames_ 271

13.12.13 _Static Semantics: VarScopedDeclarations_ 271

13.12.14 _Runtime Semantics: LabelledEvaluation_ 271

13.12.15 _Runtime Semantics: Evaluation_ 272

13.13 _The throw Statement_ 272

13.13.1 _Runtime Semantics: Evaluation_ 272

13.14 _The try Statement_ 272

13.14.1 _Static Semantics: Early Errors_ 273

13.14.2 _Static Semantics: ContainsDuplicateLabels_ 273

13.14.3 _Static Semantics: ContainsUndefinedBreakTarget_ 274

13.14.4 _Static Semantics: ContainsUndefinedContinueTarget_ 274

13.14.5 _Static Semantics: VarDeclaredNames_ 275

13.14.6 _Static Semantics: VarScopedDeclarations_ 275

13.14.7 _Runtime Semantics: CatchClauseEvaluation_ 276

13.14.8 _Runtime Semantics: Evaluation_ 276

13.15 _The debugger statement_ 277

13.15.1 _Runtime Semantics: Evaluation_ 277

14 _ECMAScript Language: Functions and Classes_ 277

14.1 _Function Definitions_ 277

14.1.1 _Directive Prologues and the Use Strict Directive_ 278

14.1.2 _Static Semantics: Early Errors_ 278

14.1.3 _Static Semantics: BoundNames_ 279

14.1.4 _Static Semantics: Contains_ 280

14.1.5 _Static Semantics: ContainsExpression_ 280

14.1.6 _Static Semantics: ExpectedArgumentCount_ 280

14.1.7 _Static Semantics: FormalParameters_ 281

14.1.8 _Static Semantics: HasInitializer_ 281

14.1.9 _Static Semantics: HasName_ 281

14.1.10 _Static Semantics: IsAnonymousFunctionDefinition ( production)
Abstract Operation_ 282

14.1.11 _Static Semantics: IsConstantDeclaration_ 282

14.1.12 _Static Semantics: IsFunctionDefinition_ 282

14.1.13 _Static Semantics: IsSimpleParameterList_ 282

14.1.14 _Static Semantics: IsStrict_ 283

14.1.15 _Static Semantics: LexicallyDeclaredNames_ 283

14.1.16 _Static Semantics: LexicallyScopedDeclarations_ 283

14.1.17 _Static Semantics: NeedsSuperBinding_ 283

14.1.18 _Static Semantics: VarDeclaredNames_ 284

14.1.19 _Static Semantics: VarScopedDeclarations_ 284

14.1.20 _Runtime Semantics: EvaluateBody_ 284

14.1.21 _Runtime Semantics: IteratorBindingInitialization_ 284

14.1.22 _Runtime Semantics: InstantiateFunctionObject_ 285

14.1.23 _Runtime Semantics: Evaluation_ 286

14.2 _Arrow Function Definitions_ 286

14.2.1 _Static Semantics: Early Errors_ 287

14.2.2 _Static Semantics: BoundNames_ 287

14.2.3 _Static Semantics: Contains_ 287

14.2.4 _Static Semantics: ContainsExpression_ 288

14.2.5 _Static Semantics: CoveredFormalsList_ 288

14.2.6 _Static Semantics: ExpectedArgumentCount_ 288

14.2.7 _Static Semantics: HasInitializer_ 289

14.2.8 _Static Semantics: HasName_ 289

14.2.9 _Static Semantics: IsSimpleParameterList_ 289

14.2.10 _Static Semantics: LexicallyDeclaredNames_ 289

14.2.11 _Static Semantics: LexicallyScopedDeclarations_ 289

14.2.12 _Static Semantics: NeedsSuperBinding_ 290

14.2.13 _Static Semantics: VarDeclaredNames_ 290

14.2.14 _Static Semantics: VarScopedDeclarations_ 290

14.2.15 _Runtime Semantics: IteratorBindingInitialization_ 290

14.2.16 _Runtime Semantics: EvaluateBody_ 291

14.2.17 _Runtime Semantics: Evaluation_ 291

14.3 _Method Definitions_ 291

14.3.1 _Static Semantics: Early Errors_ 292

14.3.2 _Static Semantics: ComputedPropertyContains_ 292

14.3.3 _Static Semantics: ExpectedArgumentCount_ 292

14.3.4 _Static Semantics: HasComputedPropertyKey_ 292

14.3.5 _Static Semantics: HasDirectSuper_ 292

14.3.6 _Static Semantics: PropName_ 293

14.3.7 _Static Semantics: NeedsSuperBinding_ 293

14.3.8 _Static Semantics: SpecialMethod_ 293

14.3.9 _Runtime Semantics: DefineMethod_ 294

14.3.10 _Runtime Semantics: PropertyDefinitionEvaluation_ 294

14.4 _Generator Function Definitions_ 295

14.4.1 _Static Semantics: Early Errors_ 295

14.4.2 _Static Semantics: BoundNames_ 296

14.4.3 _Static Semantics: ComputedPropertyContains_ 296

14.4.4 _Static Semantics: Contains_ 296

14.4.5 _Static Semantics: HasComputedPropertyKey_ 297

14.4.6 _Static Semantics: HasDirectSuper_ 297

14.4.7 _Static Semantics: HasName_ 297

14.4.8 _Static Semantics: IsConstantDeclaration_ 297

14.4.9 _Static Semantics: IsFunctionDefinition_ 297

14.4.10 _Static Semantics: PropName_ 297

14.4.11 _Static Semantics: NeedsSuperBinding_ 298

14.4.12 _Runtime Semantics: EvaluateBody_ 298

14.4.13 _Runtime Semantics: InstantiateFunctionObject_ 298

14.4.14 _Runtime Semantics: PropertyDefinitionEvaluation_ 299

14.4.15 _Runtime Semantics: Evaluation_ 299

14.5 _Class Definitions_ 301

14.5.1 _Static Semantics: Early Errors_ 302

14.5.2 _Static Semantics: BoundNames_ 302

14.5.3 _Static Semantics: ConstructorMethod_ 302

14.5.4 _Static Semantics: Contains_ 303

14.5.5 _Static Semantics: ComputedPropertyContains_ 303

14.5.6 _Static Semantics: HasName_ 304

14.5.7 _Static Semantics: IsConstantDeclaration_ 304

14.5.8 _Static Semantics: IsFunctionDefinition_ 304

14.5.9 _Static Semantics: IsStatic_ 304

14.5.10 _Static Semantics: NonConstructorMethodDefinitions_ 304

14.5.11 _Static Semantics: PrototypePropertyNameList_ 305

14.5.12 _Static Semantics: PropName_ 305

14.5.13 _Static Semantics: StaticPropertyNameList_ 305

14.5.14 _Runtime Semantics: ClassDefinitionEvaluation_ 305

14.5.15 _Runtime Semantics: BindingClassDeclarationEvaluation_ 307

14.5.16 _Runtime Semantics: Evaluation_ 307

14.6 _Tail Position Calls_ 308

14.6.1 _Static Semantics: IsInTailPosition(nonterminal) Abstract
Operation_ 308

14.6.2 _Static Semantics: HasProductionInTailPosition_ 308

14.6.3 _Runtime Semantics: PrepareForTailCall ( )_ 312

15 _ECMAScript Language: Scripts and Modules_ 313

15.1 Scripts 313

15.1.1 _Static Semantics: Early Errors_ 313

15.1.2 _Static Semantics: IsStrict_ 313

15.1.3 _Static Semantics: LexicallyDeclaredNames_ 313

15.1.4 _Static Semantics: LexicallyScopedDeclarations_ 314

15.1.5 _Static Semantics: VarDeclaredNames_ 314

15.1.6 _Static Semantics: VarScopedDeclarations_ 314

15.1.7 _Runtime Semantics: ScriptEvaluation_ 314

15.1.8 _Runtime Semantics: GlobalDeclarationInstantiation (script,
env)_ 315

15.1.9 _Runtime Semantics: ScriptEvaluationJob (sourceCodeId_) 316

15.2 Modules 317

15.2.1 _Module Semantics_ 317

15.2.2 Imports 331

15.2.3 Exports 334

16 _Error Handling and Language Extensions_ 341

16.1 _Forbidden Extensions_ 342

17 _ECMAScript Standard Built-in Objects_ 343

18 _The Global Object_ 344

18.1 _Value Properties of the Global Object_ 345

18.1.1 Infinity 345

18.1.2 NaN 345

18.1.3 undefined 345

18.2 _Function Properties of the Global Object_ 345

18.2.1 _eval (x)_ 345

18.2.2 _isFinite (number)_ 348

18.2.3 _isNaN (number)_ 348

18.2.4 _parseFloat (string)_ 348

18.2.5 _parseInt (string , radix)_ 348

18.2.6 _URI Handling Functions_ 349

18.3 _Constructor Properties of the Global Object_ 355

18.3.1 _Array ( . . . )_ 355

18.3.2 _ArrayBuffer ( . . . )_ 355

18.3.3 _Boolean ( . . . )_ 355

18.3.4 _DataView ( . . . )_ 355

18.3.5 _Date ( . . . )_ 355

18.3.6 _Error ( . . . )_ 355

18.3.7 _EvalError ( . . . )_ 355

18.3.8 _Float32Array ( . . . )_ 355

18.3.9 _Float64Array ( . . . )_ 355

18.3.10 _Function ( . . . )_ 355

18.3.11 _Int8Array ( . . . )_ 355

18.3.12 _Int16Array ( . . . )_ 355

18.3.13 _Int32Array ( . . . )_ 356

18.3.14 _Map ( . . . )_ 356

18.3.15 _Number ( . . . )_ 356

18.3.16 _Object ( . . . )_ 356

18.3.17 _Proxy ( . . . )_ 356

18.3.18 _Promise ( . . . )_ 356

18.3.19 _RangeError ( . . . )_ 356

18.3.20 _ReferenceError ( . . . )_ 356

18.3.21 _RegExp ( . . . )_ 356

18.3.22 _Set ( . . . )_ 356

18.3.23 _String ( . . . )_ 356

18.3.24 _Symbol ( . . . )_ 356

18.3.25 _SyntaxError ( . . . )_ 356

18.3.26 _TypeError ( . . . )_ 357

18.3.27 _Uint8Array ( . . . )_ 357

18.3.28 _Uint8ClampedArray ( . . . )_ 357

18.3.29 _Uint16Array ( . . . )_ 357

18.3.30 _Uint32Array ( . . . )_ 357

18.3.31 _URIError ( . . . )_ 357

18.3.32 _WeakMap ( . . . )_ 357

18.3.33 _WeakSet ( . . . )_ 357

18.4 _Other Properties of the Global Object_ 357

18.4.1 JSON 357

18.4.2 Math 357

18.4.3 Reflect 357

19 _Fundamental Objects_ 358

19.1 _Object Objects_ 358

19.1.1 _The Object Constructor_ 358

19.1.2 _Properties of the Object Constructor_ 358

19.1.3 _Properties of the Object Prototype Object_ 362

19.1.4 _Properties of Object Instances_ 364

19.2 _Function Objects_ 364

19.2.1 _The Function Constructor_ 364

19.2.2 _Properties of the Function Constructor_ 366

19.2.3 _Properties of the Function Prototype Object_ 367

19.2.4 _Function Instances_ 370

19.3 _Boolean Objects_ 371

19.3.1 _The Boolean Constructor_ 371

19.3.2 _Properties of the Boolean Constructor_ 371

19.3.3 _Properties of the Boolean Prototype Object_ 371

19.3.4 _Properties of Boolean Instances_ 372

19.4 _Symbol Objects_ 372

19.4.1 _The Symbol Constructor_ 372

19.4.2 _Properties of the Symbol Constructor_ 372

19.4.3 _Properties of the Symbol Prototype Object_ 375

19.4.4 _Properties of Symbol Instances_ 376

19.5 _Error Objects_ 376

19.5.1 _The Error Constructor_ 376

19.5.2 _Properties of the Error Constructor_ 377

19.5.3 _Properties of the Error Prototype Object_ 377

19.5.4 _Properties of Error Instances_ 378

19.5.5 _Native Error Types Used in This Standard_ 378

19.5.6 NativeError Object Structure 378

20 _Numbers and Dates_ 380

20.1 _Number Objects_ 380

20.1.1 _The Number Constructor_ 380

20.1.2 _Properties of the Number Constructor_ 381

20.1.3 _Properties of the Number Prototype Object_ 383

20.1.4 _Properties of Number Instances_ 388

20.2 _The Math Object_ 388

20.2.1 _Value Properties of the Math Object_ 388

20.2.2 _Function Properties of the Math Object_ 389

20.3 _Date Objects_ 398

20.3.1 _Overview of Date Objects and Definitions of Abstract
Operations_ 398

20.3.2 _The Date Constructor_ 404

20.3.3 _Properties of the Date Constructor_ 405

20.3.4 _Properties of the Date Prototype Object_ 407

20.3.5 _Properties of Date Instances_ 417

21 _Text Processing_ 417

21.1 _String Objects_ 417

21.1.1 _The String Constructor_ 417

21.1.2 _Properties of the String Constructor_ 418

21.1.3 _Properties of the String Prototype Object_ 420

21.1.4 _Properties of String Instances_ 434

21.1.5 _String Iterator Objects_ 435

21.2 _RegExp (Regular Expression) Objects_ 436

21.2.1 Patterns 436

21.2.2 _Pattern Semantics_ 439

21.2.3 _The RegExp Constructor_ 454

21.2.4 _Properties of the RegExp Constructor_ 456

21.2.5 _Properties of the RegExp Prototype Object_ 457

21.2.6 _Properties of RegExp Instances_ 466

22 _Indexed Collections_ 467

22.1 _Array Objects_ 467

22.1.1 _The Array Constructor_ 467

22.1.2 _Properties of the Array Constructor_ 468

22.1.3 _Properties of the Array Prototype Object_ 471

22.1.4 _Properties of Array Instances_ 495

22.1.5 _Array Iterator Objects_ 496

22.2 TypedArray Objects 497

22.2.1 _The %TypedArray% Intrinsic Object_ 498

22.2.2 _Properties of the %TypedArray% Intrinsic Object_ 501

22.2.3 _Properties of the %TypedArrayPrototype% Object_ 504

22.2.4 _The TypedArray Constructors_ 516

22.2.5 _Properties of the TypedArray Constructors_ 516

22.2.6 _Properties of TypedArray Prototype Objects_ 517

22.2.7 _Properties of TypedArray Instances_ 517

23 _Keyed Collection_ 517

23.1 _Map Objects_ 517

23.1.1 _The Map Constructor_ 518

23.1.2 _Properties of the Map Constructor_ 519

23.1.3 _Properties of the Map Prototype Object_ 519

23.1.4 _Properties of Map Instances_ 522

23.1.5 _Map Iterator Objects_ 522

23.2 _Set Objects_ 524

23.2.1 _The Set Constructor_ 524

23.2.2 _Properties of the Set Constructor_ 525

23.2.3 _Properties of the Set Prototype Object_ 525

23.2.4 _Properties of Set Instances_ 528

23.2.5 _Set Iterator Objects_ 528

23.3 _WeakMap Objects_ 530

23.3.1 _The WeakMap Constructor_ 530

23.3.2 _Properties of the WeakMap Constructor_ 531

23.3.3 _Properties of the WeakMap Prototype Object_ 532

23.3.4 _Properties of WeakMap Instances_ 533

23.4 _WeakSet Objects_ 533

23.4.1 _The WeakSet Constructor_ 534

23.4.2 _Properties of the WeakSet Constructor_ 534

23.4.3 _Properties of the WeakSet Prototype Object_ 535

23.4.4 _Properties of WeakSet Instances_ 536

24 _Structured Data_ 536

24.1 _ArrayBuffer Objects_ 536

24.1.1 _Abstract Operations For ArrayBuffer Objects_ 536

24.1.2 _The ArrayBuffer Constructor_ 539

24.1.3 _Properties of the ArrayBuffer Constructor_ 539

24.1.4 _Properties of the ArrayBuffer Prototype Object_ 540

24.1.5 _Properties of the ArrayBuffer Instances_ 541

24.2 _DataView Objects_ 541

24.2.1 _Abstract Operations For DataView Objects_ 541

24.2.2 _The DataView Constructor_ 542

24.2.3 _Properties of the DataView Constructor_ 543

24.2.4 _Properties of the DataView Prototype Object_ 543

24.2.5 _Properties of DataView Instances_ 547

24.3 _The JSON Object_ 547

24.3.1 _JSON.parse ( text [ , reviver ] )_ 547

24.3.2 _JSON.stringify ( value [ , replacer [ , space ] ] )_ 549

24.3.3 _JSON [ @@toStringTag ]_ 554

25 _Control Abstraction Objects_ 554

25.1 Iteration 554

25.1.1 _Common Iteration Interfaces_ 554

25.1.2 _The %IteratorPrototype% Object_ 555

25.2 _GeneratorFunction Objects_ 555

25.2.1 _The GeneratorFunction Constructor_ 556

25.2.2 _Properties of the GeneratorFunction Constructor_ 557

25.2.3 _Properties of the GeneratorFunction Prototype Object_ 557

25.2.4 _GeneratorFunction Instances_ 558

25.3 _Generator Objects_ 559

25.3.1 _Properties of Generator Prototype_ 559

25.3.2 _Properties of Generator Instances_ 560

25.3.3 _Generator Abstract Operations_ 560

25.4 _Promise Objects_ 562

25.4.1 _Promise Abstract Operations_ 563

25.4.2 _Promise Jobs_ 567

25.4.3 _The Promise Constructor_ 567

25.4.4 _Properties of the Promise Constructor_ 568

25.4.5 _Properties of the Promise Prototype Object_ 572

25.4.6 _Properties of Promise Instances_ 573

26 Reflection 574

26.1 _The Reflect Object_ 574

26.1.1 _Reflect.apply ( target, thisArgument, argumentsList )_ 574

26.1.2 _Reflect.construct ( target, argumentsList [, newTarget] )_ 574

26.1.3 _Reflect.defineProperty ( target, propertyKey, attributes )_
575

26.1.4 _Reflect.deleteProperty ( target, propertyKey )_ 575

26.1.5 _Reflect.enumerate ( target )_ 575

26.1.6 _Reflect.get ( target, propertyKey [ , receiver ])_ 575

26.1.7 _Reflect.getOwnPropertyDescriptor ( target, propertyKey )_ 575

26.1.8 _Reflect.getPrototypeOf ( target )_ 576

26.1.9 _Reflect.has ( target, propertyKey )_ 576

26.1.10 _Reflect.isExtensible (target)_ 576

26.1.11 _Reflect.ownKeys ( target )_ 576

26.1.12 _Reflect.preventExtensions ( target )_ 576

26.1.13 _Reflect.set ( target, propertyKey, V [ , receiver ] )_ 576

26.1.14 _Reflect.setPrototypeOf ( target, proto )_ 577

26.2 _Proxy Objects_ 577

26.2.1 _The Proxy Constructor_ 577

26.2.2 _Properties of the Proxy Constructor_ 577

26.3 _Module Namespace Objects_ 578

26.3.1 @@toStringTag 578

26.3.2 _[ @@iterator ] ( )_ 578

_Annex A (informative) Grammar Summary_ 579

A.1 _Lexical Grammar_ 579

A.2 Expressions 586

A.3 Statements 591

A.4 _Functions and Classes_ 595

A.5 _Scripts and Modules_ 597

A.6 _Number Conversions_ 599

A.7 _Universal Resource Identifier Character Classes_ 600

A.8 _Regular Expressions_ 600

_Annex B (normative) Additional ECMAScript Features for Web Browsers_
605

B.1 _Additional Syntax_ 605

B.1.1 _Numeric Literals_ 605

B.1.2 _String Literals_ 606

B.1.3 _HTML-like Comments_ 607

B.1.4 _Regular Expressions Patterns_ 608

B.2 _Additional Built-in Properties_ 611

B.2.1 _Additional Properties of the Global Object_ 611

B.2.2 _Additional Properties of the Object.prototype Object_ 613

B.2.3 _Additional Properties of the String.prototype Object_ 613

B.2.4 _Additional Properties of the Date.prototype Object_ 616

B.2.5 _Additional Properties of the RegExp.prototype Object_ 617

B.3 _Other Additional Features_ 617

B.3.1 __proto_ Property Names in Object Initializers_ 617

B.3.2 _Labelled Function Declarations_ 618

B.3.3 _Block-Level Function Declarations Web Legacy Compatibility
Semantics_ 618

B.3.4 _FunctionDeclarations in IfStatement Statement Clauses_ 620

B.3.5 _VariableStatements in Catch blocks_ 620

_Annex C (informative) The Strict Mode of ECMAScript_ 621

_Annex D (informative) Corrections and Clarifications with Possible
Compatibility Impact_ 623

D.1 _In Edition 6_ 623

D.2 _In Edition 5.1_ 623

D.3 _In Edition 5_ 625

_Annex E (informative) Additions and Changes That Introduce
Incompatibilities with Prior Editions_ 627

E.1 _In the 6^th^ Edition_ 627

E.2 _In the 5^th^ Edition_ 629

Introduction

This Ecma Standard is based on several originating technologies, the
most well known being JavaScript (Netscape) and JScript (Microsoft). The
language was invented by Brendan Eich at Netscape and first appeared in
that company’s Navigator 2.0 browser. It has appeared in all subsequent
browsers from Netscape and in all browsers from Microsoft starting with
Internet Explorer 3.0.

The development of this Standard started in November 1996. The first
edition of this Ecma Standard was adopted by the Ecma General Assembly
of June 1997.

That Ecma Standard was submitted to ISO/IEC JTC 1 for adoption under the
fast-track procedure, and approved as international standard ISO/IEC
16262, in April 1998. The Ecma General Assembly of June 1998 approved
the second edition of ECMA-262 to keep it fully aligned with ISO/IEC
16262. Changes between the first and the second edition are editorial in
nature.

The third edition of the Standard introduced powerful regular
expressions, better string handling, new control statements, try/catch
exception handling, tighter definition of errors, formatting for numeric
output and minor changes in anticipation of forthcoming
internationalization facilities and future language growth. The third
edition of the ECMAScript standard was adopted by the Ecma General
Assembly of December 1999 and published as ISO/IEC 16262:2002 in June
2002.

After publication of the third edition, ECMAScript achieved massive
adoption in conjunction with the World Wide Web where it has become the
programming language that is supported by essentially all web browsers.
Significant work was done to develop a fourth edition of ECMAScript.
However, that work was not completed and not published[1] as the fourth
edition of ECMAScript. The fifth edition of ECMAScript (published as
ECMA-262 5^th^ edition) codified de facto interpretations of the
language specification that have become common among browser
implementations and added support for new features that had emerged
since the publication of the third edition. Such features include
accessor properties, reflective creation and inspection of objects,
program control of property attributes, additional array manipulation
functions, support for the JSON object encoding format, and a strict
mode that provides enhanced error checking and program security.

The edition 5.1 of the ECMAScript Standard is fully aligned with the
third edition of the international standard ISO/IEC 16262:2011.

Goals for the sixth edition include providing better support for large
applications, library creation, and for use of ECMAScript as a
compilation target for other languages. The sixth edition is the most
extensive update to ECMAScript since the publication of the first
edition. Some of its major enhancements include modules, class
declarations, lexical block scoping, iterators and generators, promises
for asynchronous programming, destructuring patterns, and proper tail
calls. The ECMAScript library of built-ins has been expanded to support
additional data abstractions including maps, sets, and arrays of binary
numeric values as well as additional support for the Unicode
supplemental characters in strings and regular expressions. The
built-ins are now extensible via subclassing.

ECMAScript is now one of the world’s most widely used comprehensive
general purpose programming languages. It has been adopted not just by
browsers but also for servers and embedded applications.

New uses and requirements for ECMAScript continue to emerge. The sixth
edition provides the foundation for regular, incremental language and
library enhancements.

This Ecma Standard has been adopted by the General Assembly of <month>
<year>.

"DISCLAIMER

_This draft document may be copied and furnished to others, and
derivative works that comment on or otherwise explain it or assist in
its implementation may be prepared, copied, published, and distributed,
in whole or in part, without restriction of any kind, provided that the
above copyright notice and this section are included on all such copies
and derivative works. However, this document itself may not be modified
in any way, including by removing the copyright notice or references to
Ecma International, except as needed for the purpose of developing any
document or deliverable produced by Ecma International._

_This disclaimer is valid only prior to final version of this document.
After approval all rights on the standard are reserved by Ecma
International._

_The limited permissions are granted through the standardization phase
and will not be revoked by Ecma International or its successors or
assigns during this time._

_This document and the information contained herein is provided on an
"AS IS" basis and ECMA INTERNATIONAL DISCLAIMS ALL WARRANTIES, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
THE INFORMATION HEREIN WILL NOT INFRINGE ANY OWNERSHIP RIGHTS OR ANY
IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE."_

ECMAScript 2015 Language Specification



SCOPE


This Standard defines the ECMAScript 2015 general purpose programming
language.



CONFORMANCE


A conforming implementation of ECMAScript must provide and support all
the types, values, objects, properties, functions, and program syntax
and semantics described in this specification.

A conforming implementation of ECMAScript must interpret source code
input in conformance with the Unicode Standard, Version 5.1.0 or later
and ISO/IEC 10646. If the adopted ISO/IEC 10646-1 subset is not
otherwise specified, it is presumed to be the Unicode set, collection
10646.

A conforming implementation of ECMAScript that provides an application
programming interface that supports programs that need to adapt to the
linguistic and cultural conventions used by different human languages
and countries must implement the interface defined by the most recent
edition of ECMA-402 that is compatible with this specification.

A conforming implementation of ECMAScript may provide additional types,
values, objects, properties, and functions beyond those described in
this specification. In particular, a conforming implementation of
ECMAScript may provide properties not described in this specification,
and values for those properties, for objects that are described in this
specification.

A conforming implementation of ECMAScript may support program and
regular expression syntax not described in this specification. In
particular, a conforming implementation of ECMAScript may support
program syntax that makes use of the “future reserved words” listed in
subclause 11.6.2.2 of this specification.

A conforming implementation of ECMAScript must not implement any
extension that is listed as a Forbidden Extension in subclause 16.1.



NORMATIVE REFERENCES


The following referenced documents are indispensable for the application
of this document. For dated references, only the edition cited applies.
For undated references, the latest edition of the referenced document
(including any amendments) applies.

IEEE Std 754-2008: _IEEE Standard for Floating-Point Arithmetic_.
Institute of Electrical and Electronic Engineers, New York (2008)

ISO/IEC 10646:2003: _Information Technology – Universal Multiple-Octet
Coded Character Set (UCS) plus Amendment 1:2005, Amendment 2:2006,
Amendment 3:2008, and Amendment 4:2008_, plus additional amendments and
corrigenda, or successor

_The Unicode Standard, Version 5.0_, as amended by Unicode 5.1.0, or
successor

_Unicode Standard Annex #15, Unicode Normalization Forms, version
Unicode 5.1.0_, or successor

_Unicode Standard Annex #31, Unicode Identifiers and Pattern Syntax,
version Unicode 5.1.0_, or successor.

ECMA-402, _ECMAScript Internationalization API Specification_.
http://www.ecma-international.org/publications/standards/Ecma-402.htm

ECMA-404, _The JSON Data Interchange Format_.
http://www.ecma-international.org/publications/standards/Ecma-404.htm



OVERVIEW


This section contains a non-normative overview of the ECMAScript
language.

ECMAScript is an object-oriented programming language for performing
computations and manipulating computational objects within a host
environment. ECMAScript as defined here is not intended to be
computationally self-sufficient; indeed, there are no provisions in this
specification for input of external data or output of computed results.
Instead, it is expected that the computational environment of an
ECMAScript program will provide not only the objects and other
facilities described in this specification but also certain
environment-specific objects, whose description and behaviour are beyond
the scope of this specification except to indicate that they may provide
certain properties that can be accessed and certain functions that can
be called from an ECMAScript program.

ECMAScript was originally designed to be used as a scripting language,
but has become widely used as a general purpose programming language. A
_SCRIPTING LANGUAGE_ is a programming language that is used to
manipulate, customize, and automate the facilities of an existing
system. In such systems, useful functionality is already available
through a user interface, and the scripting language is a mechanism for
exposing that functionality to program control. In this way, the
existing system is said to provide a host environment of objects and
facilities, which completes the capabilities of the scripting language.
A scripting language is intended for use by both professional and
non-professional programmers.

ECMAScript was originally designed to be a _WEB SCRIPTING LANGUAGE_,
providing a mechanism to enliven Web pages in browsers and to perform
server computation as part of a Web-based client-server architecture.
ECMAScript is now used to provide core scripting capabilities for a
variety of host environments. Therefore the core language is specified
in this document apart from any particular host environment.

ECMAScript usage has moved beyond simple scripting and it is now used
for the full spectrum of programming tasks in many different
environments and scales. As the usage of ECMAScript has expanded, so has
the features and facilities it provides. ECMAScript is now a fully
featured general propose programming language.

Some of the facilities of ECMAScript are similar to those used in other
programming languages; in particular C, Java, Self, and Scheme as
described in:

ISO/IEC 9899:1996, Programming Languages – C.

Gosling, James, Bill Joy and Guy Steele. The Java^^ Language
Specification. Addison Wesley Publishing Con 1996.

Ungar, David, and Smith, Randall B. Self: The Power of Simplicity.
OOPSLA '87 Conference Proceedings, pp. 227–241, Orlando, FL, October
1987.

IEEE Standard for the Scheme Programming Language. IEEE Std 1178-1990.


Web Scripting

A web browser provides an ECMAScript host environment for client-side
computation including, for instance, objects that represent windows,
menus, pop-ups, dialog boxes, text areas, anchors, frames, history,
cookies, and input/output. Further, the host environment provides a
means to attach scripting code to events such as change of focus, page
and image loading, unloading, error and abort, selection, form
submission, and mouse actions. Scripting code appears within the HTML
and the displayed page is a combination of user interface elements and
fixed and computed text and images. The scripting code is reactive to
user interaction and there is no need for a main program.

A web server provides a different host environment for server-side
computation including objects representing requests, clients, and files;
and mechanisms to lock and share data. By using browser-side and
server-side scripting together, it is possible to distribute computation
between the client and server while providing a customized user
interface for a Web-based application.

Each Web browser and server that supports ECMAScript supplies its own
host environment, completing the ECMAScript execution environment.


ECMAScript Overview

The following is an informal overview of ECMAScript—not all parts of the
language are described. This overview is not part of the standard
proper.

ECMAScript is object-based: basic language and host facilities are
provided by objects, and an ECMAScript program is a cluster of
communicating objects. In ECMAScript, an OBJECT is a collection of
zero or more PROPERTIES each with ATTRIBUTES that determine how each
property can be used—for example, when the Writable attribute for a
property is set to FALSE, any attempt by executed ECMAScript code to
assign a different value to the property fails. Properties are
containers that hold other objects, _PRIMITIVE VALUES_, or FUNCTIONS.
A primitive value is a member of one of the following built-in types:
UNDEFINED, NULL, BOOLEAN, NUMBER, STRING, and SYMBOL; an object is a
member of the built-in type OBJECT; and a function is a callable object.
A function that is associated with an object via a property is called a
METHOD.

ECMAScript defines a collection of _BUILT-IN OBJECTS_ that round out the
definition of ECMAScript entities. These built-in objects include the
global object; objects that are fundamental to the runtime semantics of
the language including OBJECT, FUNCTION, BOOLEAN, SYMBOL, and various
ERROR objects; objects that represent and manipulate numeric values
including MATH, NUMBER, and DATE; the text processing objects STRING and
REGEXP; objects that are indexed collections of values including ARRAY
and nine different kinds of Typed Arrays whose elements all have a
specific numeric data representation; keyed collections including MAP
and SET objects; objects supporting structured data including the JSON
object, ARRAYBUFFER, and DATAVIEW; objects supporting control
abstractions including generator functions and PROMISE objects; and,
reflection objects including PROXY and REFLECT.

ECMAScript also defines a set of built-in OPERATORS. ECMAScript
operators include various unary operations, multiplicative operators,
additive operators, bitwise shift operators, relational operators,
equality operators, binary bitwise operators, binary logical operators,
assignment operators, and the comma operator.

Large ECMAScript programs are supported by MODULES which allow a
program to be be divided into multiple sequences of statements and
declarations. Each module explicitly identifies declarations it uses
that need to be provided by other modules and which of its declarations
are available for use by other modules.

ECMAScript syntax intentionally resembles Java syntax. ECMAScript syntax
is relaxed to enable it to serve as an easy-to-use scripting language.
For example, a variable is not required to have its type declared nor
are types associated with properties, and defined functions are not
required to have their declarations appear textually before calls to
them.

Objects

ECMAScript objects are not fundamentally class-based such as those in
C++, Smalltalk, or Java. Instead objects may be created in various ways
including via a literal notation or via CONSTRUCTORS which create
objects and then execute code that initializes all or part of them by
assigning initial values to their properties. Each constructor is a
function that has a property named “PROTOTYPE” that is used to implement
_PROTOTYPE-BASED INHERITANCE_ and _SHARED PROPERTIES_. Objects are
created by using constructors in NEW expressions; for example, NEW
DATE(2009,11) creates a new Date object. Invoking a constructor without
using NEW has consequences that depend on the constructor. For example,
DATE() produces a string representation of the current date and time
rather than an object.

Every object created by a constructor has an implicit reference (called
the object’s prototype) to the value of its constructor’s “PROTOTYPE”
property. Furthermore, a prototype may have a non-null implicit
reference to its prototype, and so on; this is called the _prototype
chain_. When a reference is made to a property in an object, that
reference is to the property of that name in the first object in the
prototype chain that contains a property of that name. In other words,
first the object mentioned directly is examined for such a property; if
that object contains the named property, that is the property to which
the reference refers; if that object does not contain the named
property, the prototype for that object is examined next; and so on.

  --
  --

Figure 1 — Object/Prototype Relationships

In a class-based object-oriented language, in general, state is carried
by instances, methods are carried by classes, and inheritance is only of
structure and behaviour. In ECMAScript, the state and methods are
carried by objects, while structure, behaviour, and state are all
inherited.

All objects that do not directly contain a particular property that
their prototype contains share that property and its value. Figure 1
illustrates this:

CF is a constructor (and also an object). Five objects have been created
by using NEW expressions: CF~1~, CF~2~, CF~3~, CF~4~, and CF~5~. Each of
these objects contains properties named q1 and q2. The dashed lines
represent the implicit prototype relationship; so, for example, CF~3~’s
prototype is CF~P~. The constructor, CF, has two properties itself,
named P1 and P2, which are not visible to CF~P~, CF~1~, CF~2~, CF~3~,
CF~4~, or CF~5~. The property named CFP1 in CF~P~ is shared by CF~1~,
CF~2~, CF~3~, CF~4~, and CF~5~ (but not by CF), as are any properties
found in CF~P~’s implicit prototype chain that are not named q1, q2, or
CFP1. Notice that there is no implicit prototype link between CF and
CF~P~.

Unlike most class-based object languages, properties can be added to
objects dynamically by assigning values to them. That is, constructors
are not required to name or assign values to all or any of the
constructed object’s properties. In the above diagram, one could add a
new shared property for CF~1~, CF~2~, CF~3~, CF~4~, and CF~5\ ~by
assigning a new value to the property in CF~P~.

Although ECMAScript objects are not inherently class-based, it is often
convenient to define class-like abstractions based upon a common pattern
of constructor functions, prototype objects, and methods. The ECMAScript
built-in objects themselves follow such a class-like pattern. The
ECMAScript language includes syntactic class definitions that permit
programmers to concisely define objects that conform to the same
class-like abstraction pattern used by the built-in objects.

The Strict Variant of ECMAScript

The ECMAScript Language recognizes the possibility that some users of
the language may wish to restrict their usage of some features available
in the language. They might do so in the interests of security, to avoid
what they consider to be error-prone features, to get enhanced error
checking, or for other reasons of their choosing. In support of this
possibility, ECMAScript defines a strict variant of the language. The
strict variant of the language excludes some specific syntactic and
semantic features of the regular ECMAScript language and modifies the
detailed semantics of some features. The strict variant also specifies
additional error conditions that must be reported by throwing error
exceptions in situations that are not specified as errors by the
non-strict form of the language.

The strict variant of ECMAScript is commonly referred to as the _strict
mode_ of the language. Strict mode selection and use of the strict mode
syntax and semantics of ECMAScript is explicitly made at the level of
individual ECMAScript code units. Because strict mode is selected at the
level of a syntactic code unit, strict mode only imposes restrictions
that have local effect within such a code unit. Strict mode does not
restrict or modify any aspect of the ECMAScript semantics that must
operate consistently across multiple code units. A complete ECMAScript
program may be composed for both strict mode and non-strict mode
ECMAScript code units. In this case, strict mode only applies when
actually executing code that is defined within a strict mode code unit.

In order to conform to this specification, an ECMAScript implementation
must implement both the full unrestricted ECMAScript language and the
strict mode variant of the ECMAScript language as defined by this
specification. In addition, an implementation must support the
combination of unrestricted and strict mode code units into a single
composite program.


Terms and definitions

For the purposes of this document, the following terms and definitions
apply.

4.3.1

type

set of data values as defined in clause 660 of this specification

4.3.2

primitive value

member of one of the types Undefined, Null, Boolean, Number, Symbol, or
String as defined in clause 6

NOTE A primitive value is a datum that is represented directly at the
lowest level of the language implementation.

4.3.3

object

member of the type Object

NOTE An object is a collection of properties and has a single prototype
object. The prototype may be the null value.

4.3.4

constructor

function object that creates and initializes objects

NOTE The value of a constructor’s “prototype” property is a prototype
object that is used to implement inheritance and shared properties.

4.3.5

prototype

object that provides shared properties for other objects

NOTE When a constructor creates an object, that object implicitly
references the constructor’s “PROTOTYPE” property for the purpose of
resolving property references. The constructor’s “PROTOTYPE” property
can be referenced by the program expression constructor.PROTOTYPE, and
properties added to an object’s prototype are shared, through
inheritance, by all objects sharing the prototype. Alternatively, a new
object may be created with an explicitly specified prototype by using
the OBJECT.CREATE built-in function.

4.3.6

ordinary object

object that has the default behaviour for the essential internal methods
that must be supported by all objects.

4.3.7

exotic object

object that does not have the default behaviour for one or more of the
essential internal methods that must be supported by all objects.

NOTE Any object that is not an ordinary object is an exotic object.

4.3.8

standard object

object whose semantics are defined by this specification

4.3.9

built-in object

object specified and supplied by an ECMAScript implementation

NOTE Standard built-in objects are defined in this specification. An
ECMAScript implementation may specify and supply additional kinds of
built-in objects. A _built-in constructor_ is a built-in object that is
also a constructor.

4.3.10

undefined value

primitive value used when a variable has not been assigned a value

4.3.11

Undefined type

type whose sole value is the UNDEFINED value

4.3.12

null value

primitive value that represents the intentional absence of any object
value

4.3.13

Null type

type whose sole value is the null value

4.3.14

Boolean value

member of the Boolean type

NOTE There are only two Boolean values, TRUE and FALSE

4.3.15

Boolean type

type consisting of the primitive values TRUE and FALSE

4.3.16

Boolean object

member of the Object type that is an instance of the standard built-in
BOOLEAN constructor

NOTE A Boolean object is created by using the BOOLEAN constructor in a
NEW expression, supplying a Boolean value as an argument. The resulting
object has an internal slot whose value is the Boolean value. A Boolean
object can be coerced to a Boolean value.

4.3.17

String value

primitive value that is a finite ordered sequence of zero or more 16-bit
unsigned integer

NOTE A String value is a member of the String type. Each integer value
in the sequence usually represents a single 16-bit unit of UTF-16 text.
However, ECMAScript does not place any restrictions or requirements on
the values except that they must be 16-bit unsigned integers.

4.3.18

String type

set of all possible String values

4.3.19

String object

member of the Object type that is an instance of the standard built-in
STRING constructor

NOTE A String object is created by using the STRING constructor in a NEW
expression, supplying a String value as an argument. The resulting
object has an internal slot whose value is the String value. A String
object can be coerced to a String value by calling the STRING
constructor as a function (21.1.1.1).

4.3.20

Number value

primitive value corresponding to a double-precision 64-bit binary format
IEEE 754 value

NOTE A Number value is a member of the Number type and is a direct
representation of a number.

4.3.21

Number type

set of all possible Number values including the special “Not-a-Number”
(NaN) value, positive infinity, and negative infinity

4.3.22

Number object

member of the Object type that is an instance of the standard built-in
NUMBER constructor

NOTE A Number object is created by using the NUMBER constructor in a NEW
expression, supplying a Number value as an argument. The resulting
object has an internal slot whose value is the Number value. A Number
object can be coerced to a Number value by calling the NUMBER
constructor as a function (20.1.1.1).

4.3.23

Infinity

number value that is the positive infinite Number value

4.3.24

NaN

number value that is an IEEE 754 “Not-a-Number” value

4.3.25

Symbol value

primitive value that represents a unique, non-String Object property key

4.3.26

Symbol type

set of all possible Symbol values

4.3.27

Symbol object

member of the Object type that is an instance of the standard built-in
SYMBOL constructor

4.3.28

function

member of the Object type that may be invoked as a subroutine

NOTE In addition to its properties, a function contains executable code
and state that determine how it behaves when invoked. A function’s code
may or may not be written in ECMAScript.

4.3.29

built-in function

built-in object that is a function

NOTE Examples of built-in functions include PARSEINT and MATH.EXP. An
implementation may provide implementation-dependent built-in functions
that are not described in this specification.

4.3.30

property

association between a key and a value that is a part of an object. The
key be either a String value or a Symbol value

NOTE Depending upon the form of the property the value may be
represented either directly as a data value (a primitive value, an
object, or a function object) or indirectly by a pair of accessor
functions.

4.3.31

method

function that is the value of a property

NOTE When a function is called as a method of an object, the object is
passed to the function as its THIS value.

4.3.32

built-in method

method that is a built-in function

NOTE Standard built-in methods are defined in this specification, and an
ECMAScript implementation may specify and provide other additional
built-in methods.

4.3.33

attribute

internal value that defines some characteristic of a property

4.3.34

own property

property that is directly contained by its object

4.3.35

inherited property

property of an object that is not an own property but is a property
(either own or inherited) of the object’s prototype


Organization of This Specification

The remainder of this specification is organized as follows:

Clause 5 defines the notational conventions used throughout the
specification.

Clauses 6−9 define the execution environment within which ECMAScript
programs operate.

Clauses 10−16 define the actual ECMAScript programming language
including its syntactic encoding and the execution semantics of all
language features.

Clauses 17−26 define the ECMAScript standard library. It includes the
definitions of all of the standard objects that are available for use by
ECMAScript programs as they execute.



NOTATIONAL CONVENTIONS


Syntactic and Lexical Grammars

Context-Free Grammars

A _context-free grammar_ consists of a number of productions. Each
production has an abstract symbol called a nonterminal as its
_left-hand side_, and a sequence of zero or more nonterminal and
terminal symbols as its _right-hand side_. For each grammar, the
terminal symbols are drawn from a specified alphabet.

A _chain production_ is a production that has exactly one nonterminal
symbol on its right-hand side along with zero or more terminal symbols.

Starting from a sentence consisting of a single distinguished
nonterminal, called the _goal symbol_, a given context-free grammar
specifies a language, namely, the (perhaps infinite) set of possible
sequences of terminal symbols that can result from repeatedly replacing
any nonterminal in the sequence with a right-hand side of a production
for which the nonterminal is the left-hand side.

The Lexical and RegExp Grammars

A _lexical grammar_ for ECMAScript is given in clause 11. This grammar
has as its terminal symbols Unicode code points that conform to the
rules for SourceCharacter defined in 10.1. It defines a set of
productions, starting from the goal symbol InputElementDiv or
InputElementRegExp, that describe how sequences of such code points
are translated into a sequence of input elements.

Input elements other than white space and comments form the terminal
symbols for the syntactic grammar for ECMAScript and are called
ECMAScript tokens. These tokens are the reserved words, identifiers,
literals, and punctuators of the ECMAScript language. Moreover, line
terminators, although not considered to be tokens, also become part of
the stream of input elements and guide the process of automatic
semicolon insertion (11.9). Simple white space and single-line comments
are discarded and do not appear in the stream of input elements for the
syntactic grammar. A MultiLineComment (that is, a comment of the form
“/*…*/” regardless of whether it spans more than one line) is likewise
simply discarded if it contains no line terminator; but if a
MultiLineComment contains one or more line terminators, then it is
replaced by a single line terminator, which becomes part of the stream
of input elements for the syntactic grammar.

A _RegExp grammar_ for ECMAScript is given in 21.2.1. This grammar also
has as its terminal symbols the code points as defined by
SourceCharacter. It defines a set of productions, starting from the
goal symbol Pattern, that describe how sequences of code points are
translated into regular expression patterns.

Productions of the lexical and RegExp grammars are distinguished by
having two colons “::” as separating punctuation. The lexical and RegExp
grammars share some productions.

The Numeric String Grammar

Another grammar is used for translating Strings into numeric values.
This grammar is similar to the part of the lexical grammar having to do
with numeric literals and has as its terminal symbols SourceCharacter.
This grammar appears in 7.1.3.1.

Productions of the numeric string grammar are distinguished by having
three colons “:::” as punctuation.

The Syntactic Grammar

The _syntactic grammar_ for ECMAScript is given in clauses 11, 12, 13,
14, and 15. This grammar has ECMAScript tokens defined by the lexical
grammar as its terminal symbols (5.1.2). It defines a set of
productions, starting from two alternative goal symbols Script and
Module, that describe how sequences of tokens can form syntactically
correct independent components of an ECMAScript programs.

When a stream of code points is to be parsed as an ECMAScript Script
or Module, it is first converted to a stream of input elements by
repeated application of the lexical grammar; this stream of input
elements is then parsed by a single application of the syntactic
grammar. The input stream is syntactically in error if the tokens in the
stream of input elements cannot be parsed as a single instance of the
goal nonterminal (Script or Module), with no tokens left over.

Productions of the syntactic grammar are distinguished by having just
one colon “:” as punctuation.

The syntactic grammar as presented in clauses 12, 13, 14 and 15 is
actually not a complete account of which token sequences are accepted as
a correct ECMAScript Script or Module. Certain additional token
sequences are also accepted, namely, those that would be described by
the grammar if only semicolons were added to the sequence in certain
places (such as before line terminator characters). Furthermore, certain
token sequences that are described by the grammar are not considered
acceptable if a line terminator character appears in certain “awkward”
places.

In certain cases in order to avoid ambiguities the syntactic grammar
uses generalized productions that permit token sequences that do not
from a valid ECMAScript Script or Module. For example, this
technique is used for object literals and object destructuring patterns.
In such cases a more restrictive _supplemental grammar_ is provided that
further restricts the acceptable token sequences. In certain contexts,
when explicitly specific, the input elements corresponding to such a
production are parsed again using a goal symbol of a supplemental
grammar. The input stream is syntactically in error if the tokens in the
stream of input elements parsed by a cover grammar cannot be parsed as a
single instance of the corresponding supplemental goal symbol, with no
tokens left over.

Grammar Notation

Terminal symbols of the lexical, RegExp, and numeric string grammars,
and some of the terminal symbols of the other grammars, are shown in
FIXED WIDTH font, both in the productions of the grammars and throughout
this specification whenever the text directly refers to such a terminal
symbol. These are to appear in a script exactly as written. All terminal
symbol code points specified in this way are to be understood as the
appropriate Unicode code points from the Basic Latin range, as opposed
to any similar-looking code points from other Unicode ranges.

Nonterminal symbols are shown in italic type. The definition of a
nonterminal (also called a “production”) is introduced by the name of
the nonterminal being defined followed by one or more colons. (The
number of colons indicates to which grammar the production belongs.) One
or more alternative right-hand sides for the nonterminal then follow on
succeeding lines. For example, the syntactic definition:

WhileStatement :

WHILE ( Expression ) Statement

states that the nonterminal WhileStatement represents the token WHILE,
followed by a left parenthesis token, followed by an Expression,
followed by a right parenthesis token, followed by a Statement. The
occurrences of Expression and Statement are themselves nonterminals.
As another example, the syntactic definition:

ArgumentList :

AssignmentExpression
ArgumentList , AssignmentExpression

states that an ArgumentList may represent either a single
AssignmentExpression or an ArgumentList, followed by a comma,
followed by an AssignmentExpression. This definition of ArgumentList
is recursive, that is, it is defined in terms of itself. The result is
that an ArgumentList may contain any positive number of arguments,
separated by commas, where each argument expression is an
AssignmentExpression. Such recursive definitions of nonterminals are
common.

The subscripted suffix “~opt~”, which may appear after a terminal or
nonterminal, indicates an optional symbol. The alternative containing
the optional symbol actually specifies two right-hand sides, one that
omits the optional element and one that includes it. This means that:

VariableDeclaration :

BindingIdentifier Initializer~opt~

is a convenient abbreviation for:

VariableDeclaration :

BindingIdentifier
BindingIdentifier Initializer

and that:

IterationStatement :

FOR ( LexicalDeclaration Expression~opt~ ; Expression~opt~ ) Statement

is a convenient abbreviation for:

IterationStatement :

FOR ( LexicalDeclaration ; Expression~opt~ ) Statement
FOR ( LexicalDeclaration Expression ; Expression~opt~ ) Statement

which in turn is an abbreviation for:

IterationStatement :

FOR ( LexicalDeclaration ; ) Statement
FOR ( LexicalDeclaration ; Expression ) Statement
FOR ( LexicalDeclaration Expression ; ) Statement
FOR ( LexicalDeclaration Expression ; Expression ) Statement

so, in this example, the nonterminal IterationStatement actually has
four alternative right-hand sides.

A production may be parameterized by a subscripted annotation of the
form “~[parameters]~”, which may appear as a suffix to the nonterminal
symbol defined by the production. “~parameters~” may be either a single
name or a comma separated list of names. A parameterized production is
shorthand for a set of productions defining all combinations of the
parameter names, preceded by an underscore, appended to the
parameterized nonterminal symbol. This means that:

StatementList~[Return]~ :

ReturnStatement
ExpressionStatement

is a convenient abbreviation for:

StatementList :

ReturnStatement
ExpressionStatement

StatementList_Return :

ReturnStatement
ExpressionStatement

and that:

StatementList~[Return,\ In]~ :

ReturnStatement
ExpressionStatement

is an abbreviation for:

StatementList :

ReturnStatement
ExpressionStatement

StatementList_Return :

ReturnStatement
ExpressionStatement

StatementList_In :

ReturnStatement
ExpressionStatement

StatementListReturnIn :

ReturnStatement
ExpressionStatement

Multiple parameters produce a combinatory number of productions, not all
of which are necessarily referenced in a complete grammar.

References to nonterminals on the right-hand side of a production can
also be parameterized. For example:

StatementList :

ReturnStatement
ExpressionStatement~[In]~

is equivalent to saying:

StatementList :

ReturnStatement
ExpressionStatement_In

A nonterminal reference may have both a parameter list and an “~opt~”
suffix. For example:

VariableDeclaration :

BindingIdentifier Initializer~[In]opt~

is an abbreviation for:

VariableDeclaration :

BindingIdentifier
BindingIdentifier Initializer_In

Prefixing a parameter name with “~?~” on a right-hand side nonterminal
reference makes that parameter value dependent upon the occurrence of
the parameter name on the reference to the current production’s
left-hand side symbol. For example:

VariableDeclaration~[In]~ :

BindingIdentifier Initializer~[?In]~

is an abbreviation for:

VariableDeclaration :

BindingIdentifier Initializer

VariableDeclaration_In :

BindingIdentifier Initializer_In

If a right-hand side alternative is prefixed with “[+parameter]” that
alternative is only available if the named parameter was used in
referencing the production’s nonterminal symbol. If a right-hand side
alternative is prefixed with “[~parameter]” that alternative is only
available if the named parameter was not used in referencing the
production’s nonterminal symbol. This means that:

StatementList~[Return]~ :

[+Return] ReturnStatement
ExpressionStatement

is an abbreviation for:

StatementList :

ExpressionStatement

StatementList_Return :

ReturnStatement
ExpressionStatement

and that

StatementList~[Return]~ :

[~Return] ReturnStatement
ExpressionStatement

is an abbreviation for:

StatementList :

ReturnStatement
ExpressionStatement

StatementList_Return :

ExpressionStatement

When the words “ONE OF” follow the colon(s) in a grammar definition,
they signify that each of the terminal symbols on the following line or
lines is an alternative definition. For example, the lexical grammar for
ECMAScript contains the production:

NonZeroDigit :: ONE OF

1 2 3 4 5 6 7 8 9

which is merely a convenient abbreviation for:

NonZeroDigit ::

1
2
3
4
5
6
7
8
9

If the phrase “[empty]” appears as the right-hand side of a production,
it indicates that the production's right-hand side contains no terminals
or nonterminals.

If the phrase “[lookahead ∉ set]” appears in the right-hand side of a
production, it indicates that the production may not be used if the
immediately following input token is a member of the given set. The
set can be written as a list of terminals enclosed in curly brackets.
For convenience, the set can also be written as a nonterminal, in which
case it represents the set of all terminals to which that nonterminal
could expand. If the set consists of a single terminal the phrase
“[lookahead ≠ terminal]” may be used.

For example, given the definitions

DecimalDigit :: ONE OF

0 1 2 3 4 5 6 7 8 9

DecimalDigits ::

DecimalDigit
DecimalDigits DecimalDigit

the definition

LookaheadExample ::

N [lookahead ∉ {1, 3, 5, 7, 9}] DecimalDigits
DecimalDigit [lookahead ∉ DecimalDigit ]

matches either the letter N followed by one or more decimal digits the
first of which is even, or a decimal digit not followed by another
decimal digit.

If the phrase “[no LineTerminator here]” appears in the right-hand
side of a production of the syntactic grammar, it indicates that the
production is _a restricted production_: it may not be used if a
LineTerminator occurs in the input stream at the indicated position.
For example, the production:

ThrowStatement :

THROW [no LineTerminator here] Expression ;

indicates that the production may not be used if a LineTerminator
occurs in the script between the THROW token and the Expression.

Unless the presence of a LineTerminator is forbidden by a restricted
production, any number of occurrences of LineTerminator may appear
between any two consecutive tokens in the stream of input elements
without affecting the syntactic acceptability of the script.

The lexical grammar has multiple goal symbols and the appropriate goal
symbol to use depends upon the syntactic grammar context. If a phrase of
the form “[Lexical goal LexicalGoalSymbol]” appears on the
right-hand-side of a syntactic production then the next token must be
lexically recognized using the indicated goal symbol. In the absence of
such a phrase the default lexical goal symbol is used.

When an alternative in a production of the lexical grammar or the
numeric string grammar appears to be a multi-code point token, it
represents the sequence of code points that would make up such a token.

The right-hand side of a production may specify that certain expansions
are not permitted by using the phrase “BUT NOT” and then indicating the
expansions to be excluded. For example, the production:

Identifier ::

IdentifierName BUT NOT ReservedWord

means that the nonterminal Identifier may be replaced by any sequence
of code points that could replace IdentifierName provided that the
same sequence of code points could not replace ReservedWord.

Finally, a few nonterminal symbols are described by a descriptive phrase
in sans-serif type in cases where it would be impractical to list all
the alternatives:

SourceCharacter ::

any Unicode code point


Algorithm Conventions

The specification often uses a numbered list to specify steps in an
algorithm. These algorithms are used to precisely specify the required
semantics of ECMAScript language constructs. The algorithms are not
intended to imply the use of any specific implementation technique. In
practice, there may be more efficient algorithms available to implement
a given feature.

Algorithms may be explicitly parameterized, in which case the names and
usage of the parameters must be provided as part of the algorithm’s
definition. In order to facilitate their use in multiple parts of this
specification, some algorithms, called abstract operations, are
named and written in parameterized functional form so that they may be
referenced by name from within other algorithms.

Algorithms may be associated with productions of one of the ECMAScript
grammars. A production that has multiple alternative definitions will
typically have a distinct algorithm for each alternative. When an
algorithm is associated with a grammar production, it may reference the
terminal and nonterminal symbols of the production alternative as if
they were parameters of the algorithm. When used in this manner,
nonterminal symbols refer to the actual alternative definition that is
matched when parsing the script source code.

When an algorithm is associated with a production alternative, the
alternative is typically shown without any “[ ]” grammar annotations.
Such annotations should only affect the syntactic recognition of the
alternative and have no effect on the associated semantics for the
alternative.

Unless explicitly specified otherwise, all chain productions have an
implicit definition for every algorithm that might be applied to that
production’s left-hand side nonterminal. The implicit definition simply
reapplies the same algorithm name with the same parameters, if any, to
the chain production’s sole right-hand side nonterminal and then returns
the result. For example, assume there is a production:

Block :

{ StatementList }

but there is no corresponding Evaluation algorithm that is explicitly
specified for that production. If in some algorithm there is a statement
of the form: “Return the result of evaluating Block” it is implicit
that an Evaluation algorithm exists of the form:

RUNTIME SEMANTICS: EVALUATION

Block : { StatementList }

1.  Return the result of evaluating StatementList.

For clarity of expression, algorithm steps may be subdivided into
sequential substeps. Substeps are indented and may themselves be further
divided into indented substeps. Outline numbering conventions are used
to identify substeps with the first level of substeps labelled with
lower case alphabetic characters and the second level of substeps
labelled with lower case roman numerals. If more than three levels are
required these rules repeat with the fourth level using numeric labels.
For example:

1.  Top-level step

    a.  Substep.

    b.  Substep.

    c.  i.  Subsubstep.

            1.  Subsubsubstep

                a.  Subsubsubsubstep

                    i.  Subsubsubsubsubstep

A step or substep may be written as an “if” predicate that conditions
its substeps. In this case, the substeps are only applied if the
predicate is true. If a step or substep begins with the word “else”, it
is a predicate that is the negation of the preceding “if” predicate step
at the same level.

A step may specify the iterative application of its substeps.

A step that begins with “Assert:” asserts an invariant condition of its
algorithm. Such assertions are used to make explicit algorithmic
invariants that would otherwise be implicit. Such assertions add no
additional semantic requirements and hence need not be checked by an
implementation. They are used simply to clarify algorithms.

Mathematical operations such as addition, subtraction, negation,
multiplication, division, and the mathematical functions defined later
in this clause should always be understood as computing exact
mathematical results on mathematical real numbers, which do not include
infinities and do not include a negative zero that is distinguished from
positive zero. Algorithms in this standard that model floating-point
arithmetic include explicit steps, where necessary, to handle infinities
and signed zero and to perform rounding. If a mathematical operation or
function is applied to a floating-point number, it should be understood
as being applied to the exact mathematical value represented by that
floating-point number; such a floating-point number must be finite, and
if it is +0 or −0 then the corresponding mathematical value is simply 0.

The mathematical function abs(x) produces the absolute value of x,
which is −x if x is negative (less than zero) and otherwise is x
itself.

The mathematical function sign(x) produces 1 if x is positive and −1
if x is negative. The sign function is not used in this standard for
cases when x is zero.

The mathematical function min(x~1~, x~2~, ..., x~n~) produces the
mathematically smallest of x~1~ through x~n~. The mathematical
function max(x~1~, x~2~, ..., x~n~) produces the mathematically
largest of x~1~ through x~n~.

The notation “x modulo y” (y must be finite and nonzero) computes
a value k of the same sign as y (or zero) such that abs(k) <
abs(y) and x_−_k = q × y for some integer q.

The mathematical function floor(x) produces the largest integer
(closest to positive infinity) that is not larger than x.

NOTE floor(x) = x_−(_x modulo 1).


Static Semantic Rules

Context-free grammars are not sufficiently powerful to express all the
rules that define whether a stream of input elements form a valid
ECMAScript Script or Module that may be evaluated. In some
situations additional rules are needed that may be expressed using
either ECMAScript algorithm conventions or prose requirements. Such
rules are always associated with a production of a grammar and are
called the _static semantics_ of the production.

Static Semantic Rules have names and typically are defined using an
algorithm. Named Static Semantic Rules are associated with grammar
productions and a production that has multiple alternative definitions
will typically have for each alternative a distinct algorithm for each
applicable named static semantic rule.

Unless otherwise specified every grammar production alternative in this
specification implicitly has a definition for a static semantic rule
named Contains which takes an argument named symbol whose value is a
terminal or nonterminal of the grammar that includes the associated
production. The default definition of Contains is:

1.  For each terminal and nonterminal grammar symbol, sym, in the
    definition of this production do

    a.  If sym is the same grammar symbol as symbol, return TRUE.

    b.  If sym is a nonterminal, then

        i.  Let contained be the result of sym Contains symbol.

        ii. If contained is TRUE, return TRUE.

2.  Return FALSE.

The above definition is explicitly over-ridden for specific productions.

A special kind of static semantic rule is an Early Error Rule. Early
error rules define early error conditions (see clause 16) that are
associated with specific grammar productions. Evaluation of most early
error rules are not explicitly invoked within the algorithms of this
specification. A conforming implementation must, prior to the first
evaluation of a Script, validate all of the early error rules of the
productions used to parse that Script. If any of the early error rules
are violated the Script is invalid and cannot be evaluated.



ECMASCRIPT DATA TYPES AND VALUES 


Algorithms within this specification manipulate values each of which has
an associated type. The possible value types are exactly those defined
in this clause. Types are further subclassified into ECMAScript language
types and specification types.

Within this specification, the notation “Type(x)” is used as shorthand
for “the type of x” where “type” refers to the ECMAScript language and
specification types defined in this clause. When the term “empty” is
used as if it was naming a value, it is equivalent to saying “no value
of any type”.


ECMAScript Language Types

An ECMAScript language type corresponds to values that are directly
manipulated by an ECMAScript programmer using the ECMAScript language.
The ECMAScript language types are Undefined, Null, Boolean, String,
Symbol, Number, and Object. An ECMAScript language value is a value that
is characterized by an ECMAScript language type.

The Undefined Type

The Undefined type has exactly one value, called UNDEFINED. Any variable
that has not been assigned a value has the value UNDEFINED.

The Null Type

The Null type has exactly one value, called NULL.

The Boolean Type

The Boolean type represents a logical entity having two values, called
TRUE and FALSE.

The String Type

The String type is the set of all finite ordered sequences of zero or
more 16-bit unsigned integer values (“elements”). The String type is
generally used to represent textual data in a running ECMAScript
program, in which case each element in the String is treated as a UTF-16
code unit value. Each element is regarded as occupying a position within
the sequence. These positions are indexed with nonnegative integers. The
first element (if any) is at index 0, the next element (if any) at index
1, and so on. The length of a String is the number of elements (i.e.,
16-bit values) within it. The empty String has length zero and therefore
contains no elements.

Where ECMAScript operations interpret String values, each element is
interpreted as a single UTF-16 code unit. However, ECMAScript does not
place any restrictions or requirements on the sequence of code units in
a String value, so they may be ill-formed when interpreted as UTF-16
code unit sequences. Operations that do not interpret String contents
treat them as sequences of undifferentiated 16-bit unsigned integers. No
operations ensure that Strings are in a normalized form. Only operations
that are explicitly specified to be language or locale sensitive produce
language-sensitive results

NOTE The rationale behind this design was to keep the implementation of
Strings as simple and high-performing as possible. If ECMAScript source
code is in Normalized Form C, string literals are guaranteed to also be
normalized, as long as they do not contain any Unicode escape sequences.

Some operations interpret String contents as UTF-16 encoded Unicode code
points. In that case the interpretation is:

-   A code unit in the range 0 to 0xD7FF or in the range 0xE000 to
    0xFFFF is interpreted as a code point with the same value.

-   A sequence of two code units, where the first code unit c1 is in
    the range 0xD800 to 0xDBFF and the second code unit c2 is in the
    range 0xDC00 to 0xDFFF, is a surrogate pair and is interpreted as a
    code point with the value (c1 - 0xD800) × 0x400 + (c2 –
    0xDC00) + 0x10000.

-   A code unit that is in the range 0xD800 to 0xDFFF, but is not part
    of a surrogate pair, is interpreted as a code point with the same
    value.

The Symbol Type

The Symbol type is the set of all non-String values that may be used as
the key of an Object property (6.1.7).

Each possible Symbol value is unique and immutable.

Each Symbol value immutably holds an associated value called
[[Description]] that is either UNDEFINED or a String value.

Well-Known Symbols

Well-known symbols are built-in Symbol values that are explicitly
referenced by algorithms of this specification. They are typically used
as the keys of properties whose values serve as extension points of a
specification algorithm. Unless otherwise specified, well-known symbols
values are shared by all Code Realms (8.2).

Within this specification a well-known symbol is referred to by using a
notation of the form @@name, where “name” is one of the values listed in
Table 1.

Table 1— Well-known Symbols

  ----------------------- ----------------------------- ---------------------------------------------------------------------------------------------------------------------------------------------------------------------
  _SPECIFICATION NAME _   [[DESCRIPTION]]             _VALUE AND PURPOSE_
                                                        
  @@hasInstance           "SYMBOL.HASINSTANCE"          A method that determines if a constructor object recognizes an object as one of the constructor’s instances. Called by the semantics of the INSTANCEOF operator.
  @@isConcatSpreadable    "SYMBOL.ISCONCATSPREADABLE"   A Boolean valued property that if true indicates that an object should be flattened to its array elements by ARRAY.PROTOTYPE.CONCAT.
                                                        
  @@iterator              "SYMBOL.ITERATOR"             A method that returns the default iterator for an object. Called by the semantics of the for-of statement.
  @@match                 "SYMBOL.MATCH "               A regular expression method that matches the regular expression against a string. Called by the STRING.PROTOTYPE.MATCH method.
  @@replace               "SYMBOL.REPLACE "             A regular expression method that replaces matched substrings of a string. Called by the STRING.PROTOTYPE.REPLACE method.
  @@search                "SYMBOL.SEARCH"               A regular expression method that returns the index within a string that matches the regular expression. Called by the STRING.PROTOTYPE.SEARCH method.
  @@species               "SYMBOL.SPECIES"              A property whose value is the constructor function that is used to create derived objects.
  @@split                 "SYMBOL.SPLIT"                A regular expression method that splits a string at the indices that match the regular expression. Called by the STRING.PROTOTYPE.SPLIT method.
  @@toPrimitive           "SYMBOL.TOPRIMITIVE"          A method that converts an object to a corresponding primitive value. Called by the ToPrimitive abstract operation.
  @@toStringTag           "SYMBOL.TOSTRINGTAG"          A property whose String value that is used in the creation of the default string description of an object. Called by the built-in method Object.prototype.toString.
  @@unscopables           "SYMBOL.UNSCOPABLES"          A property whose value is an Object whose own property names are property names that are excluded from the WITH environment bindings of the associated object.
  ----------------------- ----------------------------- ---------------------------------------------------------------------------------------------------------------------------------------------------------------------

The Number Type

The Number type has exactly 18437736874454810627 (that is,
2^64^−2^53^+3) values, representing the double-precision 64-bit format
IEEE 754 values as specified in the IEEE Standard for Binary
Floating-Point Arithmetic, except that the 9007199254740990 (that is,
2^53^−2) distinct “Not-a-Number” values of the IEEE Standard are
represented in ECMAScript as a single special NAN value. (Note that the
NAN value is produced by the program expression NAN.) In some
implementations, external code might be able to detect a difference
between various Not-a-Number values, but such behaviour is
implementation-dependent; to ECMAScript code, all NaN values are
indistinguishable from each other.

NOTE The bit pattern that might be observed in an ArrayBuffer (see 24.1)
after a Number value has been stored into it is not necessarily the same
as the internal representation of that Number value used by the
ECMAScript implementation.

There are two other special values, called POSITIVE INFINITY and
NEGATIVE INFINITY. For brevity, these values are also referred to for
expository purposes by the symbols +∞ and −∞, respectively. (Note that
these two infinite Number values are produced by the program expressions
+INFINITY (or simply INFINITY) and -INFINITY.)

The other 18437736874454810624 (that is, 2^64^−2^53^) values are called
the finite numbers. Half of these are positive numbers and half are
negative numbers; for every finite positive Number value there is a
corresponding negative value having the same magnitude.

Note that there is both a POSITIVE ZERO and a NEGATIVE ZERO. For
brevity, these values are also referred to for expository purposes by
the symbols +0 and −0, respectively. (Note that these two different zero
Number values are produced by the program expressions +0 (or simply 0)
and -0.)

The 18437736874454810622 (that is, 2^64^−2^53^−2) finite nonzero values
are of two kinds:

18428729675200069632 (that is, 2^64^−2^54^) of them are normalized,
having the form

  s × m × 2^e^

where s is +1 or −1, m is a positive integer less than 2^53^ but not
less than 2^52^, and e is an integer ranging from −1074 to 971,
inclusive.

The remaining 9007199254740990 (that is, 2^53^−2) values are
denormalized, having the form

  s × m × 2^e^

where s is +1 or −1, m is a positive integer less than 2^52^, and
e is −1074.

Note that all the positive and negative integers whose magnitude is no
greater than 2^53^ are representable in the Number type (indeed, the
integer 0 has two representations, +0 and -0).

A finite number has an _odd significand_ if it is nonzero and the
integer m used to express it (in one of the two forms shown above) is
odd. Otherwise, it has an _even significand_.

In this specification, the phrase “the Number value for x” where x
represents an exact nonzero real mathematical quantity (which might even
be an irrational number such as π) means a Number value chosen in the
following manner. Consider the set of all finite values of the Number
type, with −0 removed and with two additional values added to it that
are not representable in the Number type, namely 2^1024^ (which is +1 ×
2^53^ × 2^971^) and −2^1024^ (which is −1 × 2^53^ × 2^971^). Choose the
member of this set that is closest in value to x. If two values of the
set are equally close, then the one with an even significand is chosen;
for this purpose, the two extra values 2^1024^ and −2^1024^ are
considered to have even significands. Finally, if 2^1024^ was chosen,
replace it with +∞; if −2^1024^ was chosen, replace it with −∞; if +0
was chosen, replace it with −0 if and only if x is less than zero; any
other chosen value is used unchanged. The result is the Number value for
x. (This procedure corresponds exactly to the behaviour of the IEEE
754 “round to nearest, ties to even” mode.)

Some ECMAScript operators deal only with integers in specific ranges
such as −2^31^ through 2^31^−1, inclusive, or in the range 0 through
2^16^−1, inclusive. These operators accept any value of the Number type
but first convert each such value to an integer value in the expected
range. See the descriptions of the numeric conversion operations in 7.1.

The Object Type

An Object is logically a collection of properties. Each property is
either a data property, or an accessor property:

-   A _data property_ associates a key value with an ECMAScript language
    value and a set of Boolean attributes.

-   An _accessor property_ associates a key value with one or two
    accessor functions, and a set of Boolean attributes. The accessor
    functions are used to store or retrieve an ECMAScript language value
    that is associated with the property.

-   

Properties are identified using key values. A key value is either an
ECMAScript String value or a Symbol value. All String and Symbol values,
including the empty string, are valid as property keys.

An _integer index_ is a String-valued property key that is a canonical
numeric String (see 7.1.16) and whose numeric value is either +0 or a
positive integer ≤ 2^53^−1. An _array index_ is an integer index whose
numeric value i is in the range +0 ≤ i < 2^32^−1.

Property keys are used to access properties and their values. There are
two kinds of access for properties: get and set, corresponding to
value retrieval and assignment, respectively. The properties accessible
via get and set access includes both _own properties_ that are a direct
part of an object and _inherited properties_ which are provided by
another associated object via a property inheritance relationship.
Inherited properties may be either own or inherited properties of the
associated object. Each own property of an object must each have a key
value that is distinct from the key values of the other own properties
of that object.

All objects are logically collections of properties, but there are
multiple forms of objects that differ in their semantics for accessing
and manipulating their properties. O_rdinary objects_ are the most
common form of objects and have the default object semantics. An _exotic
object_ is any form of object whose property semantics differ in any way
from the default semantics.

Property Attributes

Attributes are used in this specification to define and explain the
state of Object properties. A data property associates a key value with
the attributes listed in Table 2.

Table 2 — Attributes of a Data Property

  _ATTRIBUTE NAME_   _VALUE DOMAIN_                 DESCRIPTION
  ------------------ ------------------------------ ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  [[Value]]          Any ECMAScript language type   The value retrieved by a get access of the property.
  [[Writable]]       Boolean                        If FALSE, attempts by ECMAScript code to change the property’s [[Value]] attribute using [[Set]] will not succeed.
  [[Enumerable]]     Boolean                        If TRUE, the property will be enumerated by a for-in enumeration (see 13.6.4). Otherwise, the property is said to be non-enumerable.
  [[Configurable]]   Boolean                        If FALSE, attempts to delete the property, change the property to be an accessor property, or change its attributes (other than [[Value]], or changing [[Writable]] to FALSE) will fail.

An accessor property associates a key value with the attributes listed
in Table 3.

Table 3 — Attributes of an Accessor Property

  _ATTRIBUTE NAME_   _VALUE DOMAIN_          DESCRIPTION
  ------------------ ----------------------- ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  [[Get]]            Object or Undefined   If the value is an Object it must be a function Object. The function’s [[Call]] internal method (Table 6) is called with an empty arguments list to retrieve the property value each time a get access of the property is performed.
  [[Set]]            Object or Undefined   If the value is an Object it must be a function Object. The function’s [[Call]] internal method (Table 6) is called with an arguments list containing the assigned value as its sole argument each time a set access of the property is performed. The effect of a property's [[Set]] internal method may, but is not required to, have an effect on the value returned by subsequent calls to the property's [[Get]] internal method.
  [[Enumerable]]     Boolean                 If TRUE, the property is to be enumerated by a for-in enumeration (see 13.6.4). Otherwise, the property is said to be non-enumerable.
  [[Configurable]]   Boolean                 If FALSE, attempts to delete the property, change the property to be a data property, or change its attributes will fail.

If the initial values of a property’s attributes are not explicitly
specified by this specification, the default value defined in Table 4 is
used.

Table 4 — Default Attribute Values

  ATTRIBUTE NAME     DEFAULT VALUE
  ------------------ ---------------
  [[Value]]          UNDEFINED
  [[Get]]            UNDEFINED
  [[Set]]            UNDEFINED
  [[Writable]]       FALSE
  [[Enumerable]]     FALSE
  [[Configurable]]   FALSE

Object Internal Methods and Internal Slots

The actual semantics of objects, in ECMAScript, are specified via
algorithms called _internal methods_. Each object in an ECMAScript
engine is associated with a set of internal methods that defines its
runtime behaviour. These internal methods are not part of the ECMAScript
language. They are defined by this specification purely for expository
purposes. However, each object within an implementation of ECMAScript
must behave as specified by the internal methods associated with it. The
exact manner in which this is accomplished is determined by the
implementation.

Internal method names are polymorphic. This means that different object
values may perform different algorithms when a common internal method
name is invoked upon them. If, at runtime, the implementation of an
algorithm attempts to use an internal method of an object that the
object does not support, a TYPEERROR exception is thrown.

Internal slots correspond to internal state that is associated with
objects and used by various ECMAScript specification algorithms.
Internal slots are not object properties and they are not inherited.
Depending upon the specific internal slot specification, such state may
consist of values of any ECMAScript language type or of specific
ECMAScript specification type values. Unless explicitly specified
otherwise, internal slots are allocated as part of the process of
creating an object and may not be dynamically added to an object. Unless
specified otherwise, the initial value of an internal slot is the value
UNDEFINED. Various algorithms within this specification create objects
that have internal slots. However, the ECMAScript language provides no
direct way to associate internal slots with an object.

Internal methods and internal slots are identified within this
specification using names enclosed in double square brackets [[ ]].

Table 5 summarizes the _essential internal methods_ used by this
specification that are applicable to all objects created or manipulated
by ECMAScript code. Every object must have algorithms for all of the
essential internal methods. However, all objects do not necessarily use
the same algorithms for those methods.

The “Signature” column of Table 5 and other similar tables describes the
invocation pattern for each internal method. The invocation pattern
always includes a parenthesized list of descriptive parameter names. If
a parameter name is the same as an ECMAScript type name then the name
describes the required type of the parameter value. If an internal
method explicitly returns a value, its parameter list is followed by the
symbol “→” and the type name of the returned value. The type names used
in signatures refer to the types defined in clause 6 augmented by the
following additional names. “any” means the value may be any
ECMAScript language type. An internal method implicitly returns a
Completion Record as described in 6.2.2. In addition to its parameters,
an internal method always has access to the object upon which it is
invoked as a method.

Table 5 — Essential Internal Methods

  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  _INTERNAL METHOD_       SIGNATURE                                       DESCRIPTION
  ----------------------- ------------------------------------------------- ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  [[GetPrototypeOf]]      ()→Object or Null                               Determine the object that provides inherited properties for this object. A NULL value indicates that there are no inherited properties.

  [[SetPrototypeOf]]      (Object or Null)→Boolean                      Associate with this object another object that provides inherited properties. Passing NULL indicates that there are no inherited properties. Returns TRUE indicating that the operation was completed successfully or FALSE indicating that the operation was not successful.

  [[IsExtensible]]        ( )→Boolean                                     Determine whether it is permitted to add additional properties to this object.

  [[PreventExtensions]]   ( )→Boolean                                     Control whether new properties may be added to this object. Returns TRUE if the operation was successful or FALSE if the operation was unsuccessful.

  [[GetOwnProperty]]      (propertyKey) →                                 Returns a Property Descriptor for the own property of this object whose key is propertyKey, or UNDEFINED if no such property exists.
                                                                            
                          Undefined or Property Descriptor                  

  [[HasProperty]]         (propertyKey) → Boolean                       Returns a Boolean value indicating whether this object already has either an own or inherited property whose key is propertyKey.

  [[Get]]                 (propertyKey, Receiver) _→ any_               Return the value of the property whose key is propertyKey from this object. If any ECMAScript code must be executed to retrieve the property value, Receiver is used as the THIS value when evaluating the code.

  [[Set]]                 (propertyKey_,_value, Receiver) _→ Boolean_   Set the value of this object property whose key is propertyKey to value. If any ECMAScript code must be executed to set the property value, Receiver is used as the THIS value when evaluating the code. Returns TRUE if that the property value was set or FALSE if that it could not be set.

  [[Delete]]              (propertyKey) → Boolean                       Removes the own property whose key is propertyKey from this object . Return FALSE if the property was not deleted and is still present. Return TRUE if the property was deleted or is not present.

  [[DefineOwnProperty]]   (_propertyKey, PropertyDescriptor_) → Boolean   Creates or alters the this object own property, whose key is propertyKey, to have the state described by PropertyDescriptor. Returns TRUE if that the property was successfully created/updated or FALSE if that the property could not be created or updated.

  [[Enumerate]]           ()→Object                                       Returns an iterator object that produces the keys of the string-keyed enumerable properties of the object.

  [[OwnPropertyKeys]]     ()→List of propertyKey                          Returns a List whose elements are all of the own property keys for the object.
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Table 6 summarizes additional essential internal methods that are
supported by objects that may be called as functions.

Table 6 — Additional Essential Internal Methods of Function Objects

  _INTERNAL METHOD_   SIGNATURE                            DESCRIPTION
  ------------------- -------------------------------------- ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  [[Call]]            (any, a List of any) → any     Executes code associated with this object. Invoked via a function call expression. The arguments to the internal method are a THIS value and a list containing the arguments passed to the function by a call expression. Objects that implement this internal method are callable.
  [[Construct]]       (a List of any, Object) → Object   Creates an object. Invoked via the NEW or SUPER operators. The first arguments to the internal method is a list containing the arguments of the operator. The second argument is the object to which the NEW operator was initially applied. Objects that implement this internal method are called constructors. A Function object is not necessarily a constructor and such non-constructor Function objects do not have a [[Construct]] internal method.

The semantics of the essential internal methods for ordinary objects and
standard exotic objects are specified in clause 8.6. If any specified
use of an internal method of an exotic object is not supported by an
implementation, that usage must throw a TYPEERROR exception when
attempted.

Invariants of the Essential Internal Methods

The Internal Methods of Objects of an ECMAScript engine must conform to
the list of invariants specified below. Ordinary ECMAScript Objects as
well as all standard exotic objects in this specification maintain these
invariants. ECMAScript Proxy objects maintain these invariants by means
of runtime checks on the result of traps invoked on the [[ProxyHandler]]
object.

Any implementation provided exotic objects must also maintain these
invariants for those objects. Violation of these invariants may cause
ECMAScript code to have unpredictable behaviour and create security
issues. However, violation of these invariants must never compromise the
memory safety of an implementation.

Definitions:

● The target of an internal method is the object the internal method
is called upon.

● A target is non-extensible if it has been observed to return false
from its [[IsExtensible]] internal method, or true from its
[[PreventExtensions]] internal method.

● A non-existent property is a property that does not exist as an own
property on a non-extensible target.

● All references to SameValue are according to the definition of
SameValue algorithm specified in 7.2.3.

[[GETPROTOTYPEOF]] ( )

● The Type of the return value must be either Object or Null.

● If target is non-extensible, and [[GetPrototypeOf]] returns a value v,
then any future calls to [[GetPrototypeOf]] should return the SameValue
as v.

NOTE An object’s prototype chain should have finite length (that is,
starting from any object, recursively applying the [[GetPrototypeOf]]
internal method to its result should eventually lead to the value null).
However, this requirement is not enforceable as an object level
invariant if the prototype chain includes any exotic objects that do not
use the ordinary object definition of [[GetPrototypeOf]]. Such a
circular prototype chain may result in infinite loops when accessing
object properties.

[[SETPROTOTYPEOF]] (V)

● The Type of the return value must be Boolean.

● If target is non-extensible, [[SetPrototypeOf]] must return false,
unless V is the SameValue as the target’s observed [[GetPrototypeOf]]
value.

[[PREVENTEXTENSIONS]] ( )

● The Type of the return value must be Boolean.

● If [[PreventExtensions]] returns true, all future calls to
[[IsExtensible]] on the target must return false and the target is now
considered non-extensible.

[[GETOWNPROPERTY]] (P)

● The Type of the return value must be either Property Descriptor or
Undefined.

● If the Type of the return value is Property Descriptor, the return
value must be a complete property descriptor (see 6.2.4.6).

● If a property P is described as a data property with Desc.[[Value]]
equal to v and Desc.[[Writable]] and Desc.[[Configurable]] are both
false, then the SameValue must be returned for the Desc.[[Value]]
attribute of the property on all future calls to [[GetOwnProperty]] ( P
).

● If P’s attributes other than [[Writable]] may change over time or if
the property might disappear, then P’s [[Configurable]] attribute must
be true.

● If the [[Writable]] attribute may change from false to true, then the
[[Configurable]] attribute must be true.

● If the target is non-extensible and P is non-existent, then all future
calls to [[GetOwnProperty]] (P) on the target must describe P as
non-existent (i.e. [[GetOwnProperty]] (P) must return undefined).

NOTE As a consequence of the third invariant, if a property is described
as a data property and it may return different values over time, then
either or both of the Desc.[[Writable]] and Desc.[[Configurable]]
attributes must be true even if no mechanism to change the value is
exposed via the other internal methods.

[[DEFINEOWNPROPERTY]] (P, DESC)

● The Type of the return value must be Boolean.

● [[DefineOwnProperty]] must return false if P has previously been
observed as a non-configurable own property of the target, unless
either:

  1. P is a non-configurable writable own data property. A
  non-configurable writable data property can be changed into a
  non-configurable non-writable data property.

2. All attributes in Desc are the SameValue as P’s attributes.

● [[DefineOwnProperty]] (P, Desc) must return false if target is
non-extensible and P is a non-existent own property. That is, a
non-extensible target object cannot be extended with new properties.

[[HASPROPERTY]] ( P )

● The Type of the return value must be Boolean.

● If P was previously observed as a non-configurable data or accessor
own property of the target, [[HasProperty]] must return true.

[[GET]] (P, RECEIVER)

● If P was previously observed as a non-configurable, non-writable own
data property of the target with value v, then [[Get]] must return the
SameValue.

● If P was previously observed as a non-configurable own accessor
property of the target whose [[Get]] attribute is undefined, the [[Get]]
operation must return undefined.

[[SET]] ( P, V, RECEIVER)

● The Type of the return value must be Boolean.

● If P was previously observed as a non-configurable, non-writable own
data property of the target, then [[Set]] must return false unless V is
the SameValue as P’s [[Value]] attribute.

● If P was previously observed as a non-configurable own accessor
property of the target whose [[Set]] attribute is undefined, the [[Set]]
operation must return false.

[[DELETE]] ( P )

● The Type of the return value must be Boolean.

● If P was previously observed to be a non-configurable own data or
accessor property of the target, [[Delete]] must return false.

[[ENUMERATE]] ( )

● The Type of the return value must be Object.

[[OWNPROPERTYKEYS]] ( )

●

 The return value must be a List.

●  The Type of each element of the returned List is either String or
Symbol.

● The returned List must contain at least the keys of all
non-configurable own properties that have previously been observed.

● If the object is non-extensible, the returned List must contain only
the keys of all own properties of the object that are observable using
[[GetOwnProperty]].

[[CONSTRUCT]] ( )

● The Type of the return value must be Object.

Well-Known Intrinsic Objects

Well-known intrinsics are built-in objects that are explicitly
referenced by the algorithms of this specification and which usually
have Realm specific identities. Unless otherwise specified each
intrinsic object actually corresponds to a set of similar objects, one
per Realm.

Within this specification a reference such as %name% means the intrinsic
object, associated with the current Realm, corresponding to the name.
Determination of the current Realm and its intrinsics is described in
8.1.2.5. The well-known intrinsics are listed in Table 7.

Table 7 — Well-known Intrinsic Objects

  --------------------------- --------------- --------------------------------------------------------------------------------------------------
  _INTRINSIC NAME_            _GLOBAL NAME_   _ECMASCRIPT LANGUAGE ASSOCIATION_

                                              

  %ObjectPrototype%                           The initial value of the "PROTOTYPE" data property of the intrinsic %Object%. (19.1.3)

  %ThrowTypeError%                            A function object that unconditionally throws a new instance of %TypeError%.

  %FunctionPrototype%                         The initial value of the "prototype" data property of the intrinsic %Function%.

  %Object%                    "Object"        The Object constructor (19.1.1)

  %ObjProto_toString%                         The initial value of the "TOSTRING" data property of the intrinsic %ObjectPrototype%. (19.1.3.6)

  %eval%                      "EVAL"          The EVAL function (18.2.1).

  %Function%                  "FUNCTION"      The FUNCTION constructor (19.2.1)

                                              

  %Array%                     "ARRAY"         The ARRAY constructor (22.1.1)

  %ArrayPrototype%                            The initial value of the "PROTOTYPE" data property of the intrinsic %Array%.

  %ArrayProto_values%                         The initial value of the "VALUES" data property of the intrinsic %ArrayPrototype%. (22.1.3.29)

  %ArrayIteratorPrototype%                    The prototype object used for
                                              Iterator objects created by the CreateArrayIterator abstract operation.

  %String%                    "STRING"        The STRING constructor (21.1.1)

  %StringPrototype%                           The initial value of the "PROTOTYPE" data property of the intrinsic %String%.

  %StringIteratorPrototype%                   The prototype object used for
                                              Iterator objects created by the CreateStringIterator abstract operation

  %Boolean%                   "BOOLEAN"       The initial value of the global object property named "BOOLEAN".

  %BooleanPrototype%                          The initial value of the "PROTOTYPE" data property of the intrinsic %Boolean%.

  %Number%                    "NUMBER"        The initial value of the global object property named "NUMBER".

  %NumberPrototype%                           The initial value of the "PROTOTYPE" data property of the intrinsic %Number%.

  %Date%                      "DATE"          The initial value of the global object property named "DATE".

  %DatePrototype%                             The initial value of the "PROTOTYPE" data property of the intrinsic %Date%.

  %RegExp%                    "REGEXP"        The initial value of the global object property named "REGEXP".

  %RegExpPrototype%                           The initial value of the "PROTOTYPE" data property of the intrinsic %RegExp%.

  %Map%                       "MAP"           The initial value of the global object property named "MAP".

  %MapPrototype%                              The initial value of the "PROTOTYPE" data property of the intrinsic %Map%.

  %MapIteratorPrototype%                      The prototype object used for
                                              Iterator objects created by the CreateMapIterator abstract operation

  %WeakMap%                   "WEAKMAP"       The initial value of the global object property named "WEAKMAP".

  %WeakMapPrototype%                          The initial value of the "PROTOTYPE" data property of the intrinsic %WeakMap%.

  %Set%                       "SET"           The initial value of the global object property named "SET".

  %SetPrototype%                              The initial value of the "PROTOTYPE" data property of the intrinsic %Set%.

  %WeakSet%                   "WEAKSET"       The initial value of the global object property named "WEAKSET".

  %WeakSetPrototype%                          The initial value of the "PROTOTYPE" data property of the intrinsic %WeakSet%.

  %SetIteratorPrototype%                      The prototype object used for
                                              Iterator objects created by the CreateSetIterator abstract operation

  %GeneratorFunction%                         The constructor of generator functions.

  %Generator%                                 The initial value of the PROTOTYPE property of the %GeneratorFunction% intrinsic

  %GeneratorPrototype%                        The initial value of the PROTOTYPE property of the %Generator% intrinsic

  %Error%                                     

  %EvalError%                                 

  %RangeError%                                

  %ReferenceError%                            

  %SyntaxError%                               

  %TypeError%                                 

  %URIError%                                  

                                              

  %ErrorPrototype%                            

  %EvalErrorPrototype%                        

  %RangeErrorPrototype%                       

  %ReferenceErrorPrototype%                   

  %SyntaxErrorPrototype%                      

  %TypeErrorPrototype%                        

  %URIErrorPrototype%                         

  %ArrayBuffer%                               

  %ArrayBufferPrototype%                      The initial value of the "PROTOTYPE" data property of the intrinsic %ArrayBuffer%.

  %TypedArray%                                

  %TypedArrayPrototype%                       The initial value of the "PROTOTYPE" data property of the intrinsic %TypedArray%.

  %Int8Array%                                 

  %Int8ArrayPrototype%                        

  %DataView%                                  

  %DataViewPrototype%                         

                                              

                                              

                                              

  %Promise%                                   

  %PromisePrototype%                          

                                              

                                              

                                              

                                              

  %Symbol%                                    

  %IteratorPrototype%                         An object that all standard built-in iterator objects indirectly inherit from.
  --------------------------- --------------- --------------------------------------------------------------------------------------------------


 ECMAScript Specification Types

A specification type corresponds to meta-values that are used within
algorithms to describe the semantics of ECMAScript language constructs
and ECMAScript language types. The specification types are Reference,
List, Completion, Property Descriptor, Lexical Environment, Environment
Record, and Data Block. Specification type values are specification
artefacts that do not necessarily correspond to any specific entity
within an ECMAScript implementation. Specification type values may be
used to describe intermediate results of ECMAScript expression
evaluation but such values cannot be stored as properties of objects or
values of ECMAScript language variables.

The List and Record Specification Type

The List type is used to explain the evaluation of argument lists (see
12.3.6) in NEW expressions, in function calls, and in other algorithms
where a simple ordered list of values is needed. Values of the List type
are simply ordered sequences of list elements containing the individual
values. These sequences may be of any length. The elements of a list may
be randomly accessed using 0-origin indices. For notational convenience
an array-like syntax can be used to access List elements. For example,
arguments[2] is shorthand for saying the 3^rd^ element of the List
arguments.

For notational convenience within this specification, a literal syntax
can be used to express a new List value. For example, «1, 2» defines a
List value that has two elements each of which is initialized to a
specific value. A new empty List can be expressed as «».

The Record type is used to describe data aggregations within the
algorithms of this specification. A Record type value consists of one or
more named fields. The value of each field is either an ECMAScript value
or an abstract value represented by a name associated with the Record
type. Field names are always enclosed in double brackets, for example
[[value]].

For notational convenience within this specification, an object
literal-like syntax can be used to express a Record value. For example,
{[[field1]]: 42, [[field2]]: FALSE, [[field3]]: EMPTY} defines a Record
value that has three fields, each of which is initialized to a specific
value. Field name order is not significant. Any fields that are not
explicitly listed are considered to be absent.

In specification text and algorithms, dot notation may be used to refer
to a specific field of a Record value. For example, if R is the record
shown in the previous paragraph then R.[[field2]] is shorthand for “the
field of R named [[field2]]”.

Schema for commonly used Record field combinations may be named, and
that name may be used as a prefix to a literal Record value to identify
the specific kind of aggregations that is being described. For example:
PropertyDescriptor{[[Value]]: 42, [[Writable]]: FALSE, [[Configurable]]:
TRUE}.

The Completion Record Specification Type

The Completion type is a Record used to explain the runtime propagation
of values and control flow such as the behaviour of statements (BREAK,
CONTINUE, RETURN and THROW) that perform nonlocal transfers of control.

Values of the Completion type are Record values whose fields are defined
as by Table 8.

Table 8 — Completion Record Fields

  -------------- -------------------------------------------------- --------------------------------------------------
  _FIELD NAME_   VALUE                                            MEANING
  [[type]]       One of NORMAL, BREAK, CONTINUE, RETURN, or THROW   The type of completion that occurred.
  [[value]]      any ECMAScript language value or EMPTY             The value that was produced.
  [[target]]     any ECMAScript string or EMPTY                     The target label for directed control transfers.
  -------------- -------------------------------------------------- --------------------------------------------------

The term “abrupt completion” refers to any completion with a [[type]]
value other than NORMAL.

NormalCompletion

The abstract operation NormalCompletion with a single argument, such
as:

1.  Return NormalCompletion(argument).

Is a shorthand that is defined as follows:

1.  Return Completion{[[type]]: normal, [[value]]: argument,
    [[target]]:empty}.

Implicit Completion Values

The algorithms of this specification often implicitly return Completion
Records whose [[type]] is NORMAL. Unless it is otherwise obvious from
the context, an algorithm statement that returns a value that is not a
Completion Record, such as:

1.  Return "Infinity".

Generally means the same thing as:

1.  Return NormalCompletion("INFINITY").

A “return” statement without a value in an algorithm step means the same
thing as:

1.  Return NormalCompletion(UNDEFINED).

Similarly, any reference to a Completion Record value that is in a
context that does not explicitly require a complete Completion Record
value is equivalent to an explicit reference to the [[value]] field of
the Completion Record value unless the Completion Record is an abrupt
completion.

Throw an Exception

Algorithms steps that say to throw an exception, such as

1.  Throw a TYPEERROR exception.

mean the same things as:

1.  Return Completion{[[type]]: throw, [[value]]: a newly created
    TYPEERROR object, [[target]]:empty}.

ReturnIfAbrupt

Algorithms steps that say

1.  ReturnIfAbrupt(argument).

mean the same thing as:

1.  If argument is an abrupt completion, return argument.

2.  Else if argument is a Completion Record, let argument be
    argument.[[value]].

The Reference Specification Type

NOTE The Reference type is used to explain the behaviour of such
operators as DELETE, TYPEOF, the assignment operators, the SUPER keyword
and other language features. For example, the left-hand operand of an
assignment is expected to produce a reference.

A REFERENCE is a resolved name or property binding. A Reference consists
of three components, the base value, the _referenced name_ and the
Boolean valued _strict reference_ flag. The base value is either
UNDEFINED, an Object, a Boolean, a String, a Symbol, a Number, or an
environment record (8.1.1). A base value of UNDEFINED indicates that
the Reference could not be resolved to a binding. The _referenced name_
is a String or Symbol value.

A Super Reference is a Reference that is used to represents a name
binding that was expressed using the super keyword. A Super Reference
has an additional thisValue component and its base value will never
be an environment record.

The following abstract operations are used in this specification to
access the components of references:

-   GetBase(V). Returns the base value component of the reference V.

-   GetReferencedName(V). Returns the _referenced name_ component of the
      reference V.

-   IsStrictReference(V). Returns the _strict reference_ flag component
      of the reference V.

-   HasPrimitiveBase(V). Returns TRUE if Type(base) is Boolean,
      String, Symbol, or Number.

-   IsPropertyReference(V). Returns TRUE if either the base value is
      an object or HasPrimitiveBase(V) is TRUE; otherwise returns FALSE.

-   -   IsUnresolvableReference(V). Returns TRUE if the base value is
      UNDEFINED and FALSE otherwise.

-   IsSuperReference(V). Returns TRUE if this reference has a
      thisValue component.

The following abstract operations are used in this specification to
operate on references:

GetValue (V)

1.  ReturnIfAbrupt(V).

2.  If Type(V) is not Reference, return V.

3.  Let base be GetBase(V).

4.  If IsUnresolvableReference(V), throw a REFERENCEERROR exception.

5.  If IsPropertyReference(V), then

    a.  If HasPrimitiveBase(V) is TRUE, then

        i.  Assert: In this case, base will never be NULL or
            UNDEFINED.

        ii. Let base be ToObject(base).

    b.  Return the result of calling the [[Get]] internal method of
        base passing GetReferencedName(V) and GetThisValue(V) as
        the arguments.

6.  Else base must be an environment record,

    a.  Return the result of calling the GetBindingValue (see 8.1.1)
        concrete method of base passing GetReferencedName(V) and
        IsStrictReference(V) as arguments.

NOTE The object that may be created in step 5.a.ii is not accessible
outside of the above abstract operation and the ordinary object [[Get]]
internal method. An implementation might choose to avoid the actual
creation of the object.

PutValue (V, W)

1.  ReturnIfAbrupt(V).

2.  ReturnIfAbrupt(W).

3.  If Type(V) is not Reference, throw a REFERENCEERROR exception.

4.  Let base be GetBase(V).

5.  If IsUnresolvableReference(V), then

    a.  If IsStrictReference(V) is TRUE, then

        i.  Throw REFERENCEERROR exception.

    b.  Let globalObj be the result of the abstract operation
        GetGlobalObject.

    c.  Return Put(globalObj_,GetReferencedName(_V), W, FALSE).

6.  Else if IsPropertyReference(V), then

    a.  If HasPrimitiveBase(V) is TRUE, then

        i.  Assert: In this case, base will never be NULL or
            UNDEFINED.

        ii. Set base to ToObject(base).

    b.  Let succeeded be the result of calling the [[Set]] internal
        method of base passing GetReferencedName(V), W, and
        GetThisValue(V) as arguments.

    c.  ReturnIfAbrupt(succeeded).

    d.  If succeeded is FALSE and IsStrictReference(V) is TRUE,
        throw a TYPEERROR exception.

    e.  Return.

7.  Else base must be an environment record.

    a.  Return the result of calling the SetMutableBinding (8.1.1)
        concrete method of base, passing GetReferencedName(V), W,
        and IsStrictReference(V) as arguments.

NOTE The object that may be created in step 6.a.ii is not accessible
outside of the above algorithm and the ordinary object [[Set]] internal
method. An implementation might choose to avoid the actual creation of
that object.

GetThisValue (V)

1.  Assert: IsPropertyReference(V) is TRUE.

2.  If IsSuperReference(V), then

    a.  Return the value of the thisValue component of the reference
        V.

3.  Return GetBase(V).

InitializeReferencedBinding (V, W)

1.  ReturnIfAbrupt(V).

2.  ReturnIfAbrupt(W).

3.  Assert: Type(V) is Reference.

4.  Assert: IsUnresolvableReference(V) is FALSE.

5.  Let base be GetBase(V).

6.  Assert: base is an Environment Record.

7.  Return the result of calling the InitializeBinding concrete method
    of base passing GetReferencedName(V) and W as the arguments.

The Property Descriptor Specification Type

The Property Descriptor type is used to explain the manipulation and
reification of Object property attributes. Values of the Property
Descriptor type are Records. Each field’s name is an attribute name and
its value is a corresponding attribute value as specified in 6.1.7.1. In
addition, any field may be present or absent. The schema name used
within this specification to tag literal descriptions of Property
Descriptor records is “PropertyDescriptor”.

Property Descriptor values may be further classified as data Property
Descriptors and accessor Property Descriptors based upon the existence
or use of certain fields. A data Property Descriptor is one that
includes any fields named either [[Value]] or [[Writable]]. An accessor
Property Descriptor is one that includes any fields named either [[Get]]
or [[Set]]. Any Property Descriptor may have fields named [[Enumerable]]
and [[Configurable]]. A Property Descriptor value may not be both a data
Property Descriptor and an accessor Property Descriptor; however, it may
be neither. A generic Property Descriptor is a Property Descriptor value
that is neither a data Property Descriptor nor an accessor Property
Descriptor. A fully populated Property Descriptor is one that is either
an accessor Property Descriptor or a data Property Descriptor and that
has all of the fields that correspond to the property attributes defined
in either Table 2 or Table 3.

The following abstract operations are used in this specification to
operate upon Property Descriptor values:

IsAccessorDescriptor ( Desc )

When the abstract operation IsAccessorDescriptor is called with Property
Descriptor Desc, the following steps are taken:

1.  If Desc is UNDEFINED, return FALSE.

2.  If both Desc.[[Get]] and Desc.[[Set]] are absent, return FALSE.

3.  Return TRUE.

IsDataDescriptor ( Desc )

When the abstract operation IsDataDescriptor is called with Property
Descriptor Desc, the following steps are taken:

1.  If Desc is UNDEFINED, return FALSE.

2.  If both Desc.[[Value]] and Desc.[[Writable]] are absent, return
    FALSE.

3.  Return TRUE.

IsGenericDescriptor ( Desc )

When the abstract operation IsGenericDescriptor is called with Property
Descriptor Desc, the following steps are taken:

1.  If Desc is UNDEFINED, return FALSE.

2.  If IsAccessorDescriptor(Desc) and IsDataDescriptor(Desc) are
    both FALSE, return TRUE.

3.  Return FALSE.

FromPropertyDescriptor ( Desc )

When the abstract operation FromPropertyDescriptor is called with
Property Descriptor Desc, the following steps are taken:

1.  If Desc is UNDEFINED, return UNDEFINED.

2.  3.  Let obj be ObjectCreate(%ObjectPrototype%).

4.  Assert: obj is an extensible ordinary object with no own
    properties.

5.  If Desc has a [[Value]] field, then

6.  a.  Call CreateDataProperty(obj, "VALUE", Desc.[[Value]]).

    b.  

7.  If Desc has a [[Writable]] field, then

8.  a.  Call CreateDataProperty(obj, "WRITABLE", Desc.[[Writable]]).

    b.  

9.  If Desc has a [[Get]] field, then

    a.  Call CreateDataProperty(obj, "GET", Desc.[[Get]]).

10. If Desc has a [[Set]] field, then

    a.  Call CreateDataProperty(obj, "SET", Desc.[[Set]])

11. If Desc has an [[Enumerable]] field, then

    a.  Call CreateDataProperty(obj, "ENUMERABLE",
        Desc.[[Enumerable]]).

    b.  

12. If Desc has a [[Configurable]] field, then

    a.  Call CreateDataProperty(obj , "CONFIGURABLE",
        Desc.[[Configurable]]).

    b.  

13. Assert: all of the above CreateDataProperty operations return TRUE.

14. Return obj.

ToPropertyDescriptor ( Obj )

When the abstract operation ToPropertyDescriptor is called with object
Obj, the following steps are taken:

1.  ReturnIfAbrupt(Obj).

2.  If Type(Obj) is not Object throw a TYPEERROR exception.

3.  Let desc be a new Property Descriptor that initially has no
    fields.

4.  If HasProperty(Obj, "ENUMERABLE") is TRUE, then

    a.  Let enum be Get(Obj, "ENUMERABLE").

    b.  ReturnIfAbrupt(enum).

    c.  Set the [[Enumerable]] field of desc to ToBoolean(enum).

5.  If HasProperty(Obj, "CONFIGURABLE") is TRUE, then

    a.  Let conf be Get(Obj, "CONFIGURABLE").

    b.  ReturnIfAbrupt(conf).

    c.  Set the [[Configurable]] field of desc to ToBoolean(conf).

6.  If HasProperty(Obj, "VALUE") is TRUE, then

    a.  Let value be Get(Obj, "VALUE").

    b.  ReturnIfAbrupt(value).

    c.  Set the [[Value]] field of desc to value.

7.  If HasProperty(Obj, "WRITABLE") is TRUE, then

    a.  Let writable be Get(Obj, "WRITABLE").

    b.  ReturnIfAbrupt(writable).

    c.  Set the [[Writable]] field of desc to ToBoolean(writable).

8.  If HasProperty(Obj, "GET") is TRUE, then

    a.  Let getter be Get(Obj, "GET").

    b.  ReturnIfAbrupt(getter).

    c.  If IsCallable(getter) is FALSE and getter is not UNDEFINED,
        throw a TYPEERROR exception.

    d.  Set the [[Get]] field of desc to getter.

9.  If HasProperty(Obj, "SET") is TRUE, then

    a.  Let setter be Get(Obj, "SET").

    b.  ReturnIfAbrupt(setter).

    c.  If IsCallable(setter) is FALSE and setter is not UNDEFINED,
        throw a TYPEERROR exception.

    d.  Set the [[Set]] field of desc to setter.

10. If either desc.[[Get]] or desc.[[Set]] are present, then

    a.  If either desc.[[Value]] or desc.[[Writable]] are present,
        throw a TYPEERROR exception.

11. 12. Return desc.

CompletePropertyDescriptor ( Desc )

When the abstract operation CompletePropertyDescriptor is called with
Property Descriptor Desc the following steps are taken:

1.  2.  ReturnIfAbrupt(Desc).

3.  Assert: Desc is a Property Descriptor

4.  5.  Let like be Record{[[Value]]: UNDEFINED, [[Writable]]: FALSE,
    [[Get]]: UNDEFINED, [[Set]]: UNDEFINED, [[Enumerable]]: FALSE,
    [[Configurable]]: FALSE}.

6.  a.  b.  

7.  If either IsGenericDescriptor(Desc) or IsDataDescriptor(Desc) is
    TRUE, then

    a.  If Desc does not have a [[Value]] field, set Desc.[[Value]]
        to like.[[Value]].

    b.  If Desc does not have a [[Writable]] field, set
        Desc.[[Writable]] to like.[[Writable]].

8.  Else,

9.  a.  If Desc does not have a [[Get]] field, set Desc.[[Get]] to
        like.[[Get]].

    b.  If Desc does not have a [[Set]] field, set Desc.[[Set]] to
        like.[[Set]].

10. If Desc does not have an [[Enumerable]] field, set
    Desc.[[Enumerable]] to like.[[Enumerable]].

11. If Desc does not have a [[Configurable]] field, set
    Desc.[[Configurable]] to like.[[Configurable]].

12. Return Desc.

The Lexical Environment and Environment Record Specification Types

The Lexical Environment and Environment Record types are used to explain
the behaviour of name resolution in nested functions and blocks. These
types and the operations upon them are defined in 8.1.

Data Blocks

The Data Block specification type is used to describe a distinct and
mutable sequence of byte-sized (8 bit) numeric values. A Data Block
value is created with a fixed number of bytes that each have the initial
value 0.

For notational convenience within this specification, an array-like
syntax can be used to express to the individual bytes of a Data Block
value. This notation presents a Data Block value as a 0-origined integer
indexed sequence of bytes. For example, if db is a 5 byte Data Block
value then db[2] can be used to express access to its 3^rd^ byte.

The following abstract operations are used in this specification to
operate upon Data Block values:

CreateByteDataBlock(size)

When the abstract operation CreateByteDataBlock is called with integer
argument size, the following steps are taken:

1.  Assert: size≥0.

2.  Let db be a new Data Block value consisting of size bytes. If it
    is impossible to create such a Data Block, throw a RANGEERROR
    exception.

3.  Set all of the bytes of db to 0.

4.  Return db.

CopyDataBlockBytes(toBlock, toIndex, fromBlock, fromIndex, count)

When the abstract operation CopyDataBlockBytes is called the following
steps are taken:

1.  Assert: fromBlock and toBlock are distinct Data Block values.

2.  Assert: fromIndex, toIndex, and count are positive integer
    values.

3.  Let fromSize be the number of bytes in fromBlock.

4.  Assert: fromIndex_+_count ≤ fromSize.

5.  Let toSize be the number of bytes in toBlock.

6.  Assert: toIndex_+_count ≤ toSize.

7.  Repeat, while count>0

    a.  Set toBlock_[_toIndex] to the value of
        fromBlock_[_fromIndex].

    b.  Increment toIndex and fromIndex each by 1.

    c.  Decrement count by 1.

8.  Return NormalCompletion(empty)



ABSTRACT OPERATIONS 


These operations are not a part of the ECMAScript language; they are
defined here to solely to aid the specification of the semantics of the
ECMAScript language. Other, more specialized abstract operations are
defined throughout this specification.


Type Conversion

The ECMAScript language implicitly performs automatic type conversion as
needed. To clarify the semantics of certain constructs it is useful to
define a set of conversion abstract operations. The conversion abstract
operations are polymorphic; they can accept a value of any ECMAScript
language type or of a Completion Record value. But no other
specification types are used with these operations.

ToPrimitive ( input [, PreferredType] )

The abstract operation ToPrimitive takes an input argument and an
optional argument PreferredType. The abstract operation ToPrimitive
converts its input argument to a non-Object type. If an object is
capable of converting to more than one primitive type, it may use the
optional hint PreferredType to favour that type. Conversion occurs
according to Table 9:

Table 9 — ToPrimitive Conversions

  ------------------- -----------------------------------------------------------------------------------------------------------------------------------------------------
  _INPUT TYPE_        RESULT
  Completion Record   If input is an abrupt completion, return input. Otherwise return ToPrimitive(input.[[value]]) also passing the optional hint PreferredType.
  Undefined           Return input.
  Null                Return input.
  Boolean             Return input.
  Number              Return input.
  String              Return input.
  Symbol              Return input.
  Object              Perform the steps following this table.
  ------------------- -----------------------------------------------------------------------------------------------------------------------------------------------------

When Type(input) is Object, the following steps are taken:

1.  If PreferredType was not passed, let hint be "DEFAULT".

2.  Else if PreferredType is hint String, let hint be "STRING".

3.  Else PreferredType is hint Number, let hint be "NUMBER".

4.  Let exoticToPrim be GetMethod(input, @@toPrimitive).

5.  ReturnIfAbrupt(exoticToPrim).

6.  If exoticToPrim is not UNDEFINED, then

    a.  Let result be Call(exoticToPrim, input, «hint»).

    b.  ReturnIfAbrupt(result).

    c.  If Type(result) is not Object, return result.

    d.  Throw a TYPEERROR exception.

7.  If hint is "DEFAULT", let hint be "NUMBER".

8.  9.  Return OrdinaryToPrimitive(input,hint).

When the abstract operation OrdinaryToPrimitive is called with arguments
O and hint, the following steps are taken:

1.  Assert: Type(O) is Object

2.  Assert: Type(hint) is String and its value is either "STRING" or
    "NUMBER".

3.  If hint is "STRING", then

    a.  Let methodNames be the List ( "TOSTRING", "VALUEOF").

4.  Else,

    a.  Let methodNames be the List ( "VALUEOF", "TOSTRING").

5.  For each name in methodNames in List order, do

    a.  Let method be Get(O, name).

    b.  ReturnIfAbrupt(method).

    c.  If IsCallable(method) is TRUE, then

        i.  Let result be Call(method, O).

        ii. ReturnIfAbrupt(result).

        iii. If Type(result) is not Object, return result.

6.  Throw a TYPEERROR exception.

NOTE When ToPrimitive is called with no hint, then it generally behaves
as if the hint were Number. However, objects may over-ride this
behaviour by defining a @@toPrimitive method. Of the objects defined in
this specification only Date objects (see 20.3.4.45) and Symbol objects
(see 19.4.3.4) over-ride the default ToPrimitive behaviour. Date objects
treat no hint as if the hint were String.

ToBoolean ( argument )

The abstract operation ToBoolean converts argument to a value of type
Boolean according to Table 10:

Table 10 — ToBoolean Conversions

  ------------------- -------------------------------------------------------------------------------------------------------------
  _ARGUMENT TYPE_     RESULT
  Completion Record   If argument is an abrupt completion, return argument. Otherwise return ToBoolean(argument.[[value]]).
  Undefined           Return FALSE.
  Null                Return FALSE.
  Boolean             Return argument.
  Number              Return FALSE if argument is +0, −0, or NAN; otherwise return TRUE.
  String              Return FALSE if argument is the empty String (its length is zero); otherwise return TRUE.
  Symbol              Return TRUE.
  Object              Return TRUE.
  ------------------- -------------------------------------------------------------------------------------------------------------

ToNumber ( argument )

The abstract operation ToNumber converts argument to a value of type
Number according to Table 11:

Table 11 — ToNumber Conversions

  ------------------- ------------------------------------------------------------------------------------------------------------
  _ARGUMENT TYPE_     RESULT

  Completion Record   If argument is an abrupt completion, return argument. Otherwise return ToNumber(argument.[[value]]).

  Undefined           Return NAN.

  Null                Return +0.

  Boolean             Return 1 if argument is TRUE. Return +0 if argument is FALSE.

  Number              Return argument (no conversion).

  String              See grammar and conversion algorithm below.

  Symbol              Throw a TYPEERROR exception.

  Object              Apply the following steps:
                      
                      Let primValue be ToPrimitive(argument, hint Number).
                      
                      Return ToNumber(primValue).
  ------------------- ------------------------------------------------------------------------------------------------------------

ToNumber Applied to the String Type

ToNumber applied to Strings applies the following grammar to the input
String interpreted as a sequence of UTF-16 encoded code points (6.1.4).
If the grammar cannot interpret the String as an expansion of
StringNumericLiteral, then the result of ToNumber is NAN.

NOTE The terminal symbols of this grammar are all composed of Unicode
BMP code points so the result will be NAN if the string contains the
UTF-16 encoding of any supplementary code points or any unpaired
surrogate code points

Syntax

StringNumericLiteral :::

StrWhiteSpace~opt~
StrWhiteSpace~opt~ StrNumericLiteral StrWhiteSpace~opt~

StrWhiteSpace :::

StrWhiteSpaceChar StrWhiteSpace~opt~

StrWhiteSpaceChar :::

WhiteSpace
LineTerminator

StrNumericLiteral :::

StrDecimalLiteral
BinaryIntegerLiteral
OctalIntegerLiteral
HexIntegerLiteral

StrDecimalLiteral :::

StrUnsignedDecimalLiteral
+ StrUnsignedDecimalLiteral
- StrUnsignedDecimalLiteral

StrUnsignedDecimalLiteral :::

INFINITY
 DecimalDigits . DecimalDigits~opt~ ExponentPart~opt~
. DecimalDigits ExponentPart~opt~
DecimalDigits ExponentPart~opt~

DecimalDigits :::

DecimalDigit
DecimalDigits DecimalDigit

DecimalDigit ::: ONE OF

0 1 2 3 4 5 6 7 8 9

ExponentPart :::

ExponentIndicator SignedInteger

ExponentIndicator ::: ONE OF

E E

SignedInteger :::

DecimalDigits
+ DecimalDigits
- DecimalDigits

All grammar symbols not explicitly defined above have the definitions
used in the Lexical Grammar for numeric literals (11.8.3)

NOTE Some differences should be noted between the syntax of a
StringNumericLiteral and a NumericLiteral (see 11.8.3):

-   A StringNumericLiteral may include leading and/or trailing white
    space and/or line terminators.

-   A StringNumericLiteral that is decimal may have any number of
    leading 0 digits.

-   A StringNumericLiteral that is decimal may include a + or - to
    indicate its sign.

-   A StringNumericLiteral that is empty or contains only white space
    is converted to +0.

-   INFINITY AND –INFINITY are recognized as a StringNumericLiteral
    but not as a NumericLiteral.

Runtime Semantics: MV’s

The conversion of a String to a Number value is similar overall to the
determination of the Number value for a numeric literal (see 11.8.3),
but some of the details are different, so the process for converting a
String numeric literal to a value of Number type is given here. This
value is determined in two steps: first, a mathematical value (MV) is
derived from the String numeric literal; second, this mathematical value
is rounded as described below. The MV on any grammar symbol, not
provided below, is the MV for that symbol defined in 11.8.3.1.

-   The MV of StringNumericLiteral ::: [empty] is 0.

-   The MV of StringNumericLiteral ::: StrWhiteSpace is 0.

-   The MV of StringNumericLiteral ::: StrWhiteSpace~opt~
      StrNumericLiteral StrWhiteSpace~opt~ is the MV of
      StrNumericLiteral, no matter whether white space is present or
      not.

-   The MV of StrNumericLiteral ::: StrDecimalLiteral is the MV of
      StrDecimalLiteral.

-   The MV of StrNumericLiteral ::: BinaryIntegerLiteral is the MV
      of BinaryIntegerLiteral.

-   The MV of StrNumericLiteral ::: OctalIntegerLiteral is the MV of
      OctalIntegerLiteral.

-   The MV of StrNumericLiteral ::: HexIntegerLiteral is the MV of
      HexIntegerLiteral.

-   The MV of StrDecimalLiteral ::: StrUnsignedDecimalLiteral is the
      MV of StrUnsignedDecimalLiteral.

-   The MV of StrDecimalLiteral ::: + StrUnsignedDecimalLiteral is
      the MV of StrUnsignedDecimalLiteral.

-   The MV of StrDecimalLiteral ::: - StrUnsignedDecimalLiteral is
      the negative of the MV of StrUnsignedDecimalLiteral. (Note that
      if the MV of StrUnsignedDecimalLiteral is 0, the negative of
      this MV is also 0. The rounding rule described below handles the
      conversion of this signless mathematical zero to a floating-point
      +0 or −0 as appropriate.)

-   The MV of StrUnsignedDecimalLiteral ::: INFINITY is 10^10000^ (a
      value so large that it will round to +∞).

-   The MV of StrUnsignedDecimalLiteral ::: DecimalDigits. is the MV
      of DecimalDigits.

-   The MV of StrUnsignedDecimalLiteral ::: DecimalDigits .
      DecimalDigits is the MV of the first DecimalDigits plus (the
      MV of the second DecimalDigits times 10^−n^), where n is the
      number of code points in the second DecimalDigits.

-   The MV of StrUnsignedDecimalLiteral ::: DecimalDigits.
      ExponentPart is the MV of DecimalDigits times 10^e^, where
      e is the MV of ExponentPart.

-   The MV of StrUnsignedDecimalLiteral ::: DecimalDigits.
      _DecimalDigits ExponentPart_ is (the MV of the first
      DecimalDigits plus (the MV of the second DecimalDigits times
      10^−n^)) times 10^e^, where n is the number of code points
      in the second DecimalDigits and e is the MV of ExponentPart.

-   The MV of StrUnsignedDecimalLiteral ::: . DecimalDigits is the
      MV of DecimalDigits times 10^−n^, where n is the number of
      code points in DecimalDigits.

-   The MV of StrUnsignedDecimalLiteral ::: . _DecimalDigits
      ExponentPart_ is the MV of DecimalDigits times 10^e_−_n^,
      where n is the number of code points in DecimalDigits and e
      is the MV of ExponentPart.

-   The MV of StrUnsignedDecimalLiteral ::: DecimalDigits is the MV
      of DecimalDigits.

-   The MV of StrUnsignedDecimalLiteral ::: DecimalDigits
      ExponentPart is the MV of DecimalDigits times 10^e^, where
      e is the MV of ExponentPart.

Once the exact MV for a String numeric literal has been determined, it
is then rounded to a value of the Number type. If the MV is 0, then the
rounded value is +0 unless the first non white space code point in the
String numeric literal is ‘-’, in which case the rounded value is −0.
Otherwise, the rounded value must be the Number value for the MV (in the
sense defined in 6.1.6), unless the literal includes a
StrUnsignedDecimalLiteral and the literal has more than 20 significant
digits, in which case the Number value may be either the Number value
for the MV of a literal produced by replacing each significant digit
after the 20th with a 0 digit or the Number value for the MV of a
literal produced by replacing each significant digit after the 20th with
a 0 digit and then incrementing the literal at the 20th digit position.
A digit is significant if it is not part of an ExponentPart and

-   it is not 0; or

-   there is a nonzero digit to its left and there is a nonzero digit,
    not in the ExponentPart, to its right.

ToInteger ( argument )

The abstract operation ToInteger converts argument to an integral
numeric value. This abstract operation functions as follows:

1.  Let number be ToNumber(argument).

2.  ReturnIfAbrupt(number).

3.  If number is NAN, return +0.

4.  If number is +0, −0, +∞, or −∞, return number.

5.  Return the number value that is the same sign as number and whose
    magnitude is floor(abs(number)).

ToInt32 ( argument ) — Signed 32 Bit Integer

The abstract operation ToInt32 converts argument to one of 2^32^
integer values in the range −2^31^ through 2^31^−1, inclusive. This
abstract operation functions as follows:

1.  Let number be ToNumber(argument).

2.  ReturnIfAbrupt(number).

3.  If number is NAN, +0, −0, +∞, or −∞, return +0.

4.  Let int be the mathematical value that is the same sign as
    number and whose magnitude is floor(abs(number)).

5.  Let int32bit be int modulo 2^32^.

6.  If int32bit ≥ 2^31^, return int32bit − 2^32^, otherwise return
    int32bit.

NOTE Given the above definition of ToInt32:

-   The ToInt32 abstract operation is idempotent: if applied to a result
    that it produced, the second application leaves that value
    unchanged.

-   ToInt32(ToUint32(x)) is equal to ToInt32(x) for all values of
    x. (It is to preserve this latter property that +∞ and −∞ are
    mapped to +0.)

-   ToInt32 maps −0 to +0.

ToUint32 ( argument ) — Unsigned 32 Bit Integer

The abstract operation ToUint32 converts argument to one of 2^32^
integer values in the range 0 through 2^32^−1, inclusive. This abstract
operation functions as follows:

1.  Let number be ToNumber(argument).

2.  ReturnIfAbrupt(number).

3.  If number is NAN, +0, −0, +∞, or −∞, return +0.

4.  Let int be the mathematical value that is the same sign as
    number and whose magnitude is floor(abs(number)).

5.  Let int32bit be int modulo 2^32^.

6.  Return int32bit.

NOTE Given the above definition of ToUint32:

-   Step 6 is the only difference between ToUint32 and ToInt32.

-   The ToUint32 abstract operation is idempotent: if applied to a
    result that it produced, the second application leaves that value
    unchanged.

-   ToUint32(ToInt32(x)) is equal to ToUint32(x) for all values of
    x. (It is to preserve this latter property that +∞ and −∞ are
    mapped to +0.)

-   ToUint32 maps −0 to +0.

ToInt16 ( argument ) — Signed 16 Bit Integer

The abstract operation ToInt16 converts argument to one of 2^16^
integer values in the range −32768 through 32767, inclusive. This
abstract operation functions as follows:

1.  Let number be ToNumber(argument).

2.  ReturnIfAbrupt(number).

3.  If number is NAN, +0, −0, +∞, or −∞, return +0.

4.  Let int be the mathematical value that is the same sign as
    number and whose magnitude is floor(abs(number)).

5.  Let int16bit be int modulo 2^16^.

6.  If int16bit ≥ 2^15^, return int16bit − 2^16^, otherwise return
    int16bit.

ToUint16 ( argument ) — Unsigned 16 Bit Integer

The abstract operation ToUint16 converts argument to one of 2^16^
integer values in the range 0 through 2^16^−1, inclusive. This abstract
operation functions as follows:

1.  Let number be ToNumber(argument).

2.  ReturnIfAbrupt(number).

3.  If number is NAN, +0, −0, +∞, or −∞, return +0.

4.  Let int be the mathematical value that is the same sign as
    number and whose magnitude is floor(abs(number)).

5.  Let int16bit be int modulo 2^16^.

6.  Return int16bit.

NOTE Given the above definition of ToUint16:

-   The substitution of 2^16^ for 2^32^ in step 5 is the only difference
    between ToUint32 and ToUint16.

-   ToUint16 maps −0 to +0.

ToInt8 ( argument ) — Signed 8 Bit Integer

The abstract operation ToInt8 converts argument to one of 2^8^ integer
values in the range −128 through 127, inclusive. This abstract operation
functions as follows:

1.  Let number be ToNumber(argument).

2.  ReturnIfAbrupt(number).

3.  If number is NAN, +0, −0, +∞, or −∞, return +0.

4.  Let int be the mathematical value that is the same sign as
    number and whose magnitude is floor(abs(number)).

5.  Let int8bit be int modulo 2^8^.

6.  If int8bit ≥ 2^7^, return int8bit − 2^8^, otherwise return
    int8bit.

ToUint8 ( argument ) — Unsigned 8 Bit Integer

The abstract operation ToUint8 converts argument to one of 2^8^
integer values in the range 0 through 255, inclusive. This abstract
operation functions as follows:

1.  Let number be ToNumber(argument).

2.  ReturnIfAbrupt(number).

3.  If number is NAN, +0, −0, +∞, or −∞, return +0.

4.  Let int be the mathematical value that is the same sign as
    number and whose magnitude is floor(abs(number)).

5.  Let int8bit be int modulo 2^8^.

6.  Return int8bit.

ToUint8Clamp ( argument ) — Unsigned 8 Bit Integer, Clamped

The abstract operation ToUint8Clamp converts argument to one of 2^8^
integer values in the range 0 through 255, inclusive. This abstract
operation functions as follows:

1.  Let number be ToNumber(argument).

2.  ReturnIfAbrupt(number).

3.  If number is NAN, return +0.

4.  If number ≤ 0, return +0.

5.  If number ≥ 255, return 255.

6.  Let f be floor(number).

7.  If f + 0.5 < number, return f + 1.

8.  If number < _f +_ 0.5, return f.

9.  If f is odd, return f + 1.

10. Return f.

NOTE Note that unlike the other ECMAScript integer conversion abstract
operation, ToUint8Clamp rounds rather than truncates non-integer values
and does not convert +∞ to 0. ToUint8Clamp does “round half to even”
tie-breaking. This differs from MATH.ROUND which does “round half up”
tie-breaking.

ToString ( argument )

The abstract operation ToString converts argument to a value of type
String according to Table 12:

Table 12 — ToString Conversions

  ------------------- ------------------------------------------------------------------------------------------------------------
  _ARGUMENT TYPE_     RESULT

  Completion Record   If argument is an abrupt completion, return argument. Otherwise return ToString(argument.[[value]]).

  Undefined           Return "UNDEFINED".

  Null                Return "NULL".

  Boolean             If argument is TRUE, return "TRUE".
                      
                      If argument is FALSE, return "FALSE".

  Number              See 7.1.12.1.

  String              Return argument.

  Symbol              Throw a TYPEERROR exception.

  Object              Apply the following steps:
                      
                      1. Let primValue be ToPrimitive(argument, hint String).
                      
                      2. Return ToString(primValue).
  ------------------- ------------------------------------------------------------------------------------------------------------

ToString Applied to the Number Type

The abstract operation ToString converts a Number m to String format
as follows:

1.  If m is NAN, return the String "NAN".

2.  If m is +0 or −0, return the String "0".

3.  If m is less than zero, return the String concatenation of the
    String "-" and ToString(−m).

4.  If m is +∞, return the String "INFINITY".

5.  Otherwise, let n, k, and s be integers such that k ≥ 1,
    10^k−1^ ≤ s < 10^k^, the Number value for s × 10^n−k^ is
    m, and k is as small as possible. Note that k is the number of
    digits in the decimal representation of s, that s is not
    divisible by 10, and that the least significant digit of s is not
    necessarily uniquely determined by these criteria.

6.  If k ≤ n ≤ 21, return the String consisting of the code points
    of the k digits of the decimal representation of s (in order,
    with no leading zeroes), followed by n−k occurrences of the code
    point U+0030 (DIGIT ZERO).

7.  If 0 < n ≤ 21, return the String consisting of the code points of
    the most significant n digits of the decimal representation of
    s, followed by the code point U+002E (FULL STOP), followed by the
    code points of the remaining k−n digits of the decimal
    representation of s.

8.  If −6 < n ≤ 0, return the String consisting of the code point
    U+0030 (DIGIT ZERO), followed by a the code point U+002E (FULL
    STOP), followed by −n occurrences of the code point U+0030 (DIGIT
    ZERO), followed by the code points of the k digits of the decimal
    representation of s.

9.  Otherwise, if k = 1, return the String consisting of the code
    point of the single digit of s, followed by code point U+0065
    (LATIN SMALL LETTER E), followed by the code point U+002B (PLUS
    SIGN) or the code point U+002D (HYPHEN-MINUS) according to whether
    n−1 is positive or negative, followed by the code points of the
    decimal representation of the integer abs(n−1) (with no leading
    zeroes).

10. Return the String consisting of the code point of the most
    significant digit of the decimal representation of s, followed by
    code point U+002E (FULL STOP), followed by the code points of the
    remaining k−1 digits of the decimal representation of s,
    followed by code point U+0065 (LATIN SMALL LETTER E), followed by
    code point U+002B (PLUS SIGN) or the code point U+002D
    (HYPHEN-MINUS) according to whether n−1 is positive or negative,
    followed by the code points of the decimal representation of the
    integer abs(n−1) (with no leading zeroes).

NOTE 1 The following observations may be useful as guidelines for
implementations, but are not part of the normative requirements of this
Standard:

-   If x is any Number value other than −0, then ToNumber(ToString(x))
    is exactly the same Number value as x.

-   The least significant digit of s is not always uniquely determined
    by the requirements listed in step 5.

NOTE 2 For implementations that provide more accurate conversions than
required by the rules above, it is recommended that the following
alternative version of step 5 be used as a guideline:

  Otherwise, let n, k, and s be integers such that k ≥ 1,
  10^k−1^ ≤ s < 10^k^, the Number value for s × 10^n_−_k^ is
  m, and k is as small as possible. If there are multiple
  possibilities for s, choose the value of s for which s ×
  10^n_−_k^ is closest in value to m. If there are two such possible
  values of s, choose the one that is even. Note that k is the
  number of digits in the decimal representation of s and that s is
  not divisible by 10.

NOTE 3 Implementers of ECMAScript may find useful the paper and code
written by David M. Gay for binary-to-decimal conversion of
floating-point numbers:

  Gay, David M. Correctly Rounded Binary-Decimal and Decimal-Binary
  Conversions. Numerical Analysis, Manuscript 90-10. AT&T Bell
  Laboratories (Murray Hill, New Jersey). November 30, 1990. Available
  as
  http://cm.bell-labs.com/cm/cs/doc/90/4-10.ps.gz. Associated code
  available as
  http://netlib.sandia.gov/fp/dtoa.c and as
  http://netlib.sandia.gov/fp/g_fmt.c and may also be found at the
  various NETLIB mirror sites.

ToObject ( argument )

The abstract operation ToObject converts argument to a value of type
Object according to Table 13:

Table 13 — ToObject Conversions

  ------------------- ---------------------------------------------------------------------------------------------------------------------------------------------------
  _ARGUMENT TYPE_     RESULT
  Completion Record   If argument is an abrupt completion, return argument. Otherwise return ToObject(argument.[[value]]).
  Undefined           Throw a TYPEERROR exception.
  Null                Throw a TYPEERROR exception.
  Boolean             Return a new Boolean object whose [[BooleanData]] internal slot is set to the value of argument. See 19.3 for a description of Boolean objects.
  Number              Return a new Number object whose [[NumberData]] internal slot is set to the value of argument. See 20.1 for a description of Number objects.
  String              Return a new String object whose [[StringData]] internal slot is set to the value of argument. See 21.1 for a description of String objects.
  Symbol              Return a new Symbol object whose [[SymbolData]] internal slot is set to the value of argument. See 19.4 for a description of Symbol objects.
  Object              Return argument.
  ------------------- ---------------------------------------------------------------------------------------------------------------------------------------------------

ToPropertyKey ( argument ) 

The abstract operation ToPropertyKey converts argument to a value that
can be used as a property key by performing the following steps:

1.  Let key be ToPrimitive(argument, hint String).

2.  ReturnIfAbrupt(key).

3.  If Type(key) is Symbol, then

    a.  Return key.

4.  Return ToString(key).

ToLength ( argument ) 

The abstract operation ToLength converts argument to an integer
suitable for use as the length of an array-like object. It performs the
following steps:

1.  ReturnIfAbrupt(argument).

2.  Let len be ToInteger(argument).

3.  ReturnIfAbrupt(len).

4.  If len ≤ +0, return +0.

5.  Return min(len, 2^53^-1).

CanonicalNumericIndexString ( argument )

The abstract operation CanonicalNumericIndexString returns argument
converted to a numeric value if it is a String representation of a
Number that would be produced by ToString, or the string "-0".
Otherwise, it returns UNDEFINED. This abstract operation functions as
follows:

1.  Assert: Type(argument) is String.

2.  If argument is "-0", return −0.

3.  Let n be ToNumber(argument).

4.  5.  If SameValue(ToString(n), argument) is FALSE, return
    UNDEFINED.

6.  7.  Return n.

A _canonical numeric string_ is any String value for which the
CanonicalNumericIndexString abstraction operation does not return
UNDEFINED.


Testing and Comparison Operations

RequireObjectCoercible ( argument )

The abstract operation RequireObjectCoercible throws an error if
argument is a value that cannot be converted to an Object using
ToObject. It is defined by Table 14:

Table 14 — RequireObjectCoercible Results

  _ARGUMENT TYPE_     RESULT
  ------------------- --------------------------------------------------------------------------------------------------------------------------
  Completion Record   If argument is an abrupt completion, return argument. Otherwise return RequireObjectCoercible(argument.[[value]]).
  Undefined           Throw a TYPEERROR exception.
  Null                Throw a TYPEERROR exception.
  Boolean             Return argument.
  Number              Return argument.
  String              Return argument.
  Symbol              Return argument.
  Object              Return argument.

IsArray ( argument )

The abstract operation IsArray takes one argument argument, and
performs the following steps:

1.  If Type(argument) is not Object, return FALSE.

2.  If argument is an Array exotic object, return TRUE.

3.  If argument is a Proxy exotic object, then

    a.  Let target be the value of the [[ProxyTarget]] internal slot
        of argument.

    b.  c.  Return IsArray(target).

4.  Return FALSE.

IsCallable ( argument )

The abstract operation IsCallable determines if argument, which must
be an ECMAScript language value or a Completion Record, is a callable
function with a [[Call]] internal method.:

  -- --
     
     
     
     
     
     
     
     
     
  -- --

1.  ReturnIfAbrupt(argument).

2.  If Type(argument) is not Object, return FALSE.

3.  If argument has a [[Call]] internal method, return TRUE.

4.  Return FALSE.

IsConstructor ( argument )

The abstract operation IsConstructor determines if argument, which
must be an ECMAScript language value or a Completion Record, is a
function object with a [[Construct]] internal method.

1.  ReturnIfAbrupt(argument).

2.  If Type(argument) is not Object, return FALSE.

3.  If argument has a [[Construct]] internal method, return TRUE.

4.  Return FALSE.

IsExtensible (O)

The abstract operation IsExtensible is used to determine whether
additional properties can be added to the object that is O. A Boolean
value is returned. This abstract operation performs the following steps:

1.  Assert: Type(O) is Object.

2.  Return the result of calling the [[IsExtensible]] internal method of
    O.

IsInteger ( argument )

The abstract operation IsInteger determines if argument is a finite
integer numeric value.

1.  ReturnIfAbrupt(argument).

2.  If Type(argument) is not Number, return FALSE.

3.  If argument is NAN, +∞, or −∞, return FALSE.

4.  If floor(abs(argument)) ≠ abs(argument), return FALSE.

5.  Return TRUE.

IsPropertyKey ( argument )

The abstract operation IsPropertyKey determines if argument, which
must be an ECMAScript language value or a Completion Record, is a value
that may be used as a property key.

1.  ReturnIfAbrupt(argument).

2.  If Type(argument) is String, return TRUE.

3.  If Type(argument) is Symbol, return TRUE.

4.  Return FALSE.

IsRegExp ( argument ) 

The abstract operation IsRegExp with argument argument performs the
following steps:

1.  If Type(argument) is not Object, return FALSE.

2.  Let isRegExp be Get(argument, @@match).

3.  ReturnIfAbrupt(isRegExp).

4.  If isRegExp is not UNDEFINED, return ToBoolean(isRegExp).

5.  If argument has a [[RegExpMatcher]] internal slot, return TRUE.

6.  Return FALSE.

SameValue(x, y)

The internal comparison abstract operation SameValue(x, y), where
x and y are ECMAScript language values, produces TRUE or FALSE. Such
a comparison is performed as follows:

1.  ReturnIfAbrupt(x).

2.  ReturnIfAbrupt(y).

3.  If Type(x) is different from Type(y), return FALSE.

4.  If Type(x) is Undefined, return TRUE.

5.  If Type(x) is Null, return TRUE.

6.  If Type(x) is Number, then

    a.  If x is NaN and y is NaN, return TRUE.

    b.  If x is +0 and y is -0, return FALSE.

    c.  If x is -0 and y is +0, return FALSE.

    d.  If x is the same Number value as y, return TRUE.

    e.  Return FALSE.

7.  If Type(x) is String, then

    a.  If x and y are exactly the same sequence of code units (same
        length and same code units at corresponding indices) return
        TRUE; otherwise, return FALSE.

8.  If Type(x) is Boolean, then

    a.  If x and y are both TRUE or both FALSE, return TRUE;
        otherwise, return FALSE.

9.  If Type(x) is Symbol, then

    a.  If x and y are both the same Symbol value, return TRUE;
        otherwise, return FALSE.

10. Return TRUE if x and y are the same Object value. Otherwise,
    return FALSE.

SameValueZero(x, y)

The internal comparison abstract operation SameValueZero(x, y),
where x and y are ECMAScript language values, produces TRUE or
FALSE. Such a comparison is performed as follows:

1.  ReturnIfAbrupt(x).

2.  ReturnIfAbrupt(y).

3.  If Type(x) is different from Type(y), return FALSE.

4.  If Type(x) is Undefined, return TRUE.

5.  If Type(x) is Null, return TRUE.

6.  If Type(x) is Number, then

    a.  If x is NaN and y is NaN, return TRUE.

    b.  If x is +0 and y is -0, return TRUE.

    c.  If x is -0 and y is +0, return TRUE.

    d.  If x is the same Number value as y, return TRUE.

    e.  Return FALSE.

7.  If Type(x) is String, then

    a.  If x and y are exactly the same sequence of code units (same
        length and same code units at corresponding indices) return
        TRUE; otherwise, return FALSE.

8.  If Type(x) is Boolean, then

    a.  If x and y are both TRUE or both FALSE, return TRUE;
        otherwise, return FALSE.

9.  If Type(x) is Symbol, then

    a.  If x and y are both the same Symbol value, return TRUE;
        otherwise, return FALSE.

10. Return TRUE if x and y are the same Object value. Otherwise,
    return FALSE.

NOTE SameValueZero differs from SameValue only in its treatment of +0
and -0.

Abstract Relational Comparison 

The comparison x < y, where x and y are values, produces TRUE,
FALSE, or UNDEFINED (which indicates that at least one operand is NAN).
In addition to x and y the algorithm takes a Boolean flag named
LeftFirst as a parameter. The flag is used to control the order in
which operations with potentially visible side-effects are performed
upon x and y. It is necessary because ECMAScript specifies left to
right evaluation of expressions. The default value of LeftFirst is
TRUE and indicates that the x parameter corresponds to an expression
that occurs to the left of the y parameter’s corresponding expression.
If LeftFirst is FALSE, the reverse is the case and operations must be
performed upon y before x. Such a comparison is performed as
follows:

1.  ReturnIfAbrupt(x).

2.  ReturnIfAbrupt(y).

3.  If the LeftFirst flag is TRUE, then

    a.  Let px be ToPrimitive(x, hint Number).

    b.  ReturnIfAbrupt(px).

    c.  Let py be ToPrimitive(y, hint Number).

    d.  ReturnIfAbrupt(py).

4.  Else the order of evaluation needs to be reversed to preserve left
    to right evaluation

    a.  Let py be ToPrimitive(y, hint Number).

    b.  ReturnIfAbrupt(py).

    c.  Let px be ToPrimitive(x, hint Number).

    d.  ReturnIfAbrupt(px).

5.  If both px and py are Strings, then

    a.  If py is a prefix of px, return FALSE. (A String value p
        is a prefix of String value q if q can be the result of
        concatenating p and some other String r. Note that any
        String is a prefix of itself, because r may be the empty
        String.)

    b.  If px is a prefix of py, return TRUE.

    c.  Let k be the smallest nonnegative integer such that the code
        unit at index k within px is different from the code unit at
        index k within py. (There must be such a k, for neither
        String is a prefix of the other.)

    d.  Let m be the integer that is the code unit value at index k
        within px.

    e.  Let n be the integer that is the code unit value at index k
        within py.

    f.  If m < n, return TRUE. Otherwise, return FALSE.

6.  Else,

7.  a.  Let nx be ToNumber(px). Because px and py are primitive
        values evaluation order is not important.

    b.  ReturnIfAbrupt(nx).

    c.  Let ny be ToNumber(py).

    d.  ReturnIfAbrupt(ny).

    e.  If nx is NAN, return UNDEFINED.

    f.  If ny is NAN, return UNDEFINED.

    g.  If nx and ny are the same Number value, return FALSE.

    h.  If nx is +0 and ny is −0, return FALSE.

    i.  If nx is −0 and ny is +0, return FALSE.

    j.  If nx is +∞, return FALSE.

    k.  If ny is +∞, return TRUE.

    l.  If ny is −∞, return FALSE.

    m.  If nx is −∞, return TRUE.

    n.  If the mathematical value of nx is less than the mathematical
        value of ny —note that these mathematical values are both
        finite and not both zero—return TRUE. Otherwise, return FALSE.

NOTE 1 Step 5 differs from step 11 in the algorithm for the addition
operator + (12.7.3) in using “and” instead of “or”.

NOTE 2 The comparison of Strings uses a simple lexicographic ordering on
sequences of code unit values. There is no attempt to use the more
complex, semantically oriented definitions of character or string
equality and collating order defined in the Unicode specification.
Therefore String values that are canonically equal according to the
Unicode standard could test as unequal. In effect this algorithm assumes
that both Strings are already in normalized form. Also, note that for
strings containing supplementary characters, lexicographic ordering on
sequences of UTF-16 code unit values differs from that on sequences of
code point values.

Abstract Equality Comparison 

The comparison x == y, where x and y are values, produces TRUE
or FALSE. Such a comparison is performed as follows:

1.  ReturnIfAbrupt(x).

2.  ReturnIfAbrupt(y).

3.  If Type(x) is the same as Type(y), then

    a.  Return the result of performing Strict Equality Comparison x
        === y.

4.  If x is NULL and y is UNDEFINED, return TRUE.

5.  If x is UNDEFINED and y is NULL, return TRUE.

6.  If Type(x) is Number and Type(y) is String,
    return the result of the comparison x == ToNumber(y).

7.  If Type(x) is String and Type(y) is Number,
    return the result of the comparison ToNumber(x) == y.

8.  9.  If Type(x) is Boolean, return the result of the comparison
    ToNumber(x) == y.

10. If Type(y) is Boolean, return the result of the comparison x ==
    ToNumber(y).

11. If Type(x) is either String, Number, or Symbol and Type(y) is
    Object, then
    return the result of the comparison x == ToPrimitive(y).

12. If Type(x) is Object and Type(y) is either String, Number, or
    Symbol, then
    return the result of the comparison ToPrimitive(x) == y.

13. Return FALSE.

Strict Equality Comparison 

The comparison x === y, where x and y are values, produces TRUE
or FALSE. Such a comparison is performed as follows:

1.  If Type(x) is different from Type(y), return FALSE.

2.  If Type(x) is Undefined, return TRUE.

3.  If Type(x) is Null, return TRUE.

4.  If Type(x) is Number, then

    a.  If x is NAN, return FALSE.

    b.  If y is NAN, return FALSE.

    c.  If x is the same Number value as y, return TRUE.

    d.  If x is +0 and y is −0, return TRUE.

    e.  If x is −0 and y is +0, return TRUE.

    f.  Return FALSE.

5.  If Type(x) is String, then

    a.  If x and y are exactly the same sequence of code units (same
        length and same code units at corresponding indices), return
        TRUE.

    b.  Else, return FALSE.

6.  If Type(x) is Boolean, then

    a.  If x and y are both TRUE or both FALSE, return TRUE.

    b.  Else, return FALSE.

7.  If x and y are the same Symbol value, return TRUE.

8.  If x and y are the same Object value, return TRUE.

9.  Return FALSE.

NOTE This algorithm differs from the SameValue Algorithm (7.2.3) in its
treatment of signed zeroes and NaNs.


 Operations on Objects

Get (O, P)

The abstract operation Get is used to retrieve the value of a specific
property of an object. The operation is called with arguments O and
P where O is the object and P is the property key. This abstract
operation performs the following steps:

1.  Assert: Type(O) is Object.

2.  Assert: IsPropertyKey(P) is TRUE.

3.  4.  Return the result of calling the [[Get]] internal method of O
    passing P and O as the arguments.

GetV (V, P)

The abstract operation GetV is used to retrieve the value of a specific
property of an ECMAScript language value. If the value is not an object,
the property lookup is performed using a wrapper object appropriate for
the type of the value. The operation is called with arguments V and P
where V is the value and P is the property key. This abstract
operation performs the following steps:

1.  2.  Assert: IsPropertyKey(P) is TRUE.

3.  Let O be ToObject(V).

4.  ReturnIfAbrupt(O).

5.  Return the result of calling the [[Get]] internal method of O
    passing P and V as the arguments.

Put (O, P, V, Throw)

The abstract operation Put is used to set the value of a specific
property of an object. The operation is called with arguments O, P,
V, and Throw where O is the object, P is the property key, V
is the new value for the property and Throw is a Boolean flag. This
abstract operation performs the following steps:

1.  Assert: Type(O) is Object.

2.  Assert: IsPropertyKey(P) is TRUE.

3.  Assert: Type(Throw) is Boolean.

4.  Let success be the result of calling the [[Set]] internal method
    of O passing P, V, and O as the arguments.

5.  ReturnIfAbrupt(success).

6.  If success is FALSE and Throw is TRUE, throw a TYPEERROR
    exception.

7.  Return success.

CreateDataProperty (O, P, V)

The abstract operation CreateDataProperty is used to create a new own
property of an object. The operation is called with arguments O, P,
and V where O is the object, P is the property key, and V is the
value for the property. This abstract operation performs the following
steps:

1.  Assert: Type(O) is Object.

2.  Assert: IsPropertyKey(P) is TRUE.

3.  Let newDesc be the PropertyDescriptor{[[Value]]: V,
    [[Writable]]: TRUE, [[Enumerable]]: TRUE, [[Configurable]]: TRUE}.

4.  Return the result of calling the [[DefineOwnProperty]] internal
    method of O passing P and newDesc as arguments.

NOTE This abstract operation creates a property whose attributes are set
to the same defaults used for properties created by the ECMAScript
language assignment operator. Normally, the property will not already
exist. If it does exist and is not configurable or if O is not
extensible, [[DefineOwnProperty]] will return FALSE.

CreateDataPropertyOrThrow (O, P, V)

The abstract operation CreateDataPropertyOrThrow is used to create a new
own property of an object. It throws a TYPEERROR exception if the
requested property update cannot be performed. The operation is called
with arguments O, P, and V where O is the object, P is the
property key, and V is the value for the property. This abstract
operation performs the following steps:

1.  Assert: Type(O) is Object.

2.  Assert: IsPropertyKey(P) is TRUE.

3.  Let success be CreateDataProperty(O, P, V).

4.  ReturnIfAbrupt(success).

5.  If success is FALSE, throw a TYPEERROR exception.

6.  Return success.

NOTE This abstract operation creates a property whose attributes are set
to the same defaults used for properties created by the ECMAScript
language assignment operator. Normally, the property will not already
exist. If it does exist and is not configurable or if O is not
extensible, [[DefineOwnProperty]] will return FALSE causing this
operation to throw a TYPEERROR exception.

DefinePropertyOrThrow (O, P, desc)

The abstract operation DefinePropertyOrThrow is used to call the
[[DefineOwnProperty]] internal method of an object in a manner that will
throw a TYPEERROR exception if the requested property update cannot be
performed. The operation is called with arguments O, P, and desc
where O is the object, P is the property key, and desc is the
Property Descriptor for the property. This abstract operation performs
the following steps:

1.  Assert: Type(O) is Object.

2.  Assert: IsPropertyKey(P) is TRUE.

3.  Let success be the result of calling the [[DefineOwnProperty]]
    internal method of O passing P and desc as arguments.

4.  ReturnIfAbrupt(success).

5.  If success is FALSE, throw a TYPEERROR exception.

6.  Return success.

DeletePropertyOrThrow (O, P)

The abstract operation DeletePropertyOrThrow is used to remove a
specific own property of an object. It throws an exception if the
property is not configurable. The operation is called with arguments O
and P where O is the object and P is the property key. This
abstract operation performs the following steps:

1.  Assert: Type(O) is Object.

2.  Assert: IsPropertyKey(P) is TRUE.

3.  Let success be the result of calling the [[Delete]] internal
    method of O passing P as the argument.

4.  ReturnIfAbrupt(success).

5.  If success is FALSE, throw a TYPEERROR exception.

6.  Return success.

GetMethod (O, P)

The abstract operation GetMethod is used to get the value of a specific
property of an object when the value of the property is expected to be a
function. The operation is called with arguments O and P where O
is the object, P is the property key. This abstract operation performs
the following steps:

1.  2.  Assert: IsPropertyKey(P) is TRUE.

3.  Let func be GetV(O, P).

4.  ReturnIfAbrupt(func).

5.  If func is either UNDEFINED or NULL, return UNDEFINED.

6.  If IsCallable(func) is FALSE, throw a TYPEERROR exception.

7.  Return func.

HasProperty (O, P)

The abstract operation HasProperty is used to determine whether an
object has a property with the specified property key. The property may
be either an own or inherited. A Boolean value is returned. The
operation is called with arguments O and P where O is the object
and P is the property key. This abstract operation performs the
following steps:

1.  Assert: Type(O) is Object.

2.  Assert: IsPropertyKey(P) is TRUE.

3.  Return the result of calling the [[HasProperty]] internal method of
    O with argument P.

HasOwnProperty (O, P)

The abstract operation HasOwnProperty is used to determine whether an
object has an own property with the specified property key. A Boolean
value is returned. The operation is called with arguments O and P
where O is the object and P is the property key. This abstract
operation performs the following steps:

1.  Assert: Type(O) is Object.

2.  Assert: IsPropertyKey(P) is TRUE.

3.  Let desc be the result of calling the [[GetOwnProperty]] internal
    method of O passing P as the argument.

4.  ReturnIfAbrupt(desc).

5.  If desc is UNDEFINED, return FALSE.

6.  Return TRUE.

Call(F, V, [argumentsList])

The abstract operation Call is used to call the [[Call]] internal method
of a function object. The operation is called with arguments F, V ,
and optionally argumentsList where F is the function object, V is
an ECMAScript language value that is the THIS value of the [[Call]], and
argumentsList is the value passed to the corresponding argument of the
internal method. If argumentsList is not present, an empty List is
used as its value. This abstract operation performs the following steps:

1.  ReturnIfAbrupt(F).

2.  If argumentsList was not passed, let argumentsList be a new
    empty List.

3.  If IsCallable(F) is FALSE, throw a TYPEERROR exception.

4.  Return the result of calling the [[Call]] internal method of F
    with arguments V and argumentsList.

Invoke(O,P, [argumentsList])

The abstract operation Invoke is used to call a method property of an
object. The operation is called with arguments O, P , and optionally
argumentsList where O serves as both the lookup point for the
property and the THIS value of the call, P is the property key, and
argumentsList is the list of arguments values passed to the method. If
argumentsList is not present, an empty List is used as its value. This
abstract operation performs the following steps:

1.  Assert: P is a valid property key.

2.  If argumentsList was not passed, let argumentsList be a new
    empty List.

3.  4.  5.  Let func be GetV(O, P).

6.  7.  8.  9.  Return Call(func, O, argumentsList).

Construct (F, [argumentsList], [newTarget])

The abstract operation Construct is used to call the [[Construct]]
internal method of a function object. The operation is called with
arguments F, and optionally argumentsList, and newTarget where F
is the function object. argumentsList and newTarget are the values
to be passed as the corresponding arguments of the internal method. If
argumentsList is not present, an empty List is used as its value. If
newTarget is not present, F is used as its value. This abstract
operation performs the following steps:

1.  If newTarget was not passed, let newTarget be F.

2.  If argumentsList was not passed, let argumentsList be a new
    empty List.

3.  Assert: IsConstructor (F) is TRUE.

4.  Assert: IsConstructor (newTarget) is TRUE.

5.  Return the result of calling the [[Construct]] internal method of
    F passing argumentsList and newTarget as the arguments.

NOTE If newTarget is not passed, this operation is equivalent to: NEW
F(...ARGUMENTSLIST)

SetIntegrityLevel (O, level)

The abstract operation SetIntegrityLevel is used to fix the set of own
properties of an object. This abstract operation performs the following
steps:

1.  Assert: Type(O) is Object.

2.  Assert: level is either "SEALED" or "FROZEN".

3.  Let status be the result of calling the [[PreventExtensions]]
    internal method of O.

4.  ReturnIfAbrupt(status).

5.  If status is FALSE, return FALSE.

6.  Let keys be the result of calling the [[OwnPropertyKeys]] internal
    method of O.

7.  8.  ReturnIfAbrupt(keys).

9.  10. If level is "SEALED", then

    a.  Repeat for each element k of keys,

        i.  Let status be DefinePropertyOrThrow(O, k,
            PropertyDescriptor{ [[Configurable]]: FALSE}).

        ii. ReturnIfAbrupt(status).

            1.  

11. Else level is "FROZEN",

    a.  Repeat for each element k of keys,

        i.  Let currentDesc be the result of calling the
            [[GetOwnProperty]] internal method of O with argument k.

        ii. ReturnIfAbrupt(currentDesc).

            1.  

        iii. iv. v.  If currentDesc is not UNDEFINED, then

            1.  If IsAccessorDescriptor(currentDesc) is TRUE, then

                a.  Let desc be the
                    PropertyDescriptor{[[Configurable]]: FALSE}.

            2.  Else,

            3.  a.  Let desc be the PropertyDescriptor {
                    [[Configurable]]: FALSE, [[Writable]]: FALSE }.

            4.  Let status be DefinePropertyOrThrow(O, k, desc).

            5.  ReturnIfAbrupt(status).

                a.  

12. 13. Return TRUE.

TestIntegrityLevel (O, level)

The abstract operation TestIntegrityLevel is used to determine if the
set of own properties of an object are fixed. This abstract operation
performs the following steps:

1.  Assert: Type(O) is Object.

2.  Assert: level is either "SEALED" or "FROZEN".

3.  Let status be IsExtensible(O).

4.  ReturnIfAbrupt(status).

5.  If status is TRUE, return FALSE

6.  NOTE If the object is extensible, none of its properties are
    examined.

7.  Let keys be the result of calling the [[OwnPropertyKeys]] internal
    method of O.

8.  9.  ReturnIfAbrupt(keys).

10. 11. Let configurable be FALSE.

12. Let writable be FALSE.

13. Repeat for each element k of keys,

    a.  Let currentDesc be the result of calling the
        [[GetOwnProperty]] internal method of O with k.

    b.  ReturnIfAbrupt(currentDesc).

    c.  d.  e.  f.  g.  If currentDesc is not UNDEFINED, then

        i.  If currentDesc.[[Configurable]] is TRUE, return FALSE.

        ii. If IsDataDescriptor(currentDesc) is TRUE, then

            1.  If currentDesc.[[Writable]] is TRUE, return FALSE.

            2.  

14. 15. 16. 17. 18. 19. Return TRUE.

CreateArrayFromList (elements)

The abstract operation CreateArrayFromList is used to create an Array
object whose elements are provided by a List. This abstract operation
performs the following steps:

1.  Assert: elements is a List whose elements are all ECMAScript
    language values.

2.  Let array be ArrayCreate(0) (see 9.4.2.2).

3.  Let n be 0.

4.  For each element e of elements

    a.  Let status be the result of CreateDataProperty(array,
        ToString(n), e).

    b.  Assert: status is TRUE.

    c.  Increment n by 1.

5.  Return array.

CreateListFromArrayLike (obj [, elementTypes] )

The abstract operation CreateListFromArrayLike is used to create a List
value whose elements are provided by the indexed properties of an
array-like object. The optional argument elementTypes is a List
containing the names of ECMAScript Language Types that are allowed for
element values of the List that is created. This abstract operation
performs the following steps:

1.  ReturnIfAbrupt(obj).

2.  If elementTypes was not passed, let elementTypes be (Undefined,
    Null, Boolean, String, Symbol, Number, Object).

3.  If Type(obj) is not Object, throw a TYPEERROR exception.

4.  Let len be ToLength(Get(obj, "LENGTH")).

5.  6.  ReturnIfAbrupt(len).

7.  Let list be an empty List.

8.  Let index be 0.

9.  Repeat while index < len

    a.  Let indexName be ToString(index).

    b.  Let next be Get(obj, indexName).

    c.  ReturnIfAbrupt(next).

    d.  If Type(next) is not an element of elementTypes, throw a
        TYPEERROR exception.

    e.  Append next as the last element of list.

    f.  Set index to index + 1.

10. Return list.

OrdinaryHasInstance (C, O)

The abstract operation OrdinaryHasInstance implements the default
algorithm for determining if an object O inherits from the instance
object inheritance path provided by constructor C. This abstract
operation performs the following steps:

1.  If IsCallable(C) is FALSE, return FALSE.

2.  If C has a [[BoundTargetFunction]] internal slot, then

    a.  Let BC be the value of C’s [[BoundTargetFunction]] internal
        slot.

    b.  Return InstanceofOperator(O_,_BC) (see 12.9.4).

3.  If Type(O) is not Object, return FALSE.

4.  Let P be Get(C, "PROTOTYPE").

5.  ReturnIfAbrupt(P).

6.  If Type(P) is not Object, throw a TYPEERROR exception.

7.  Repeat

    a.  Set O to the result of calling the [[GetPrototypeOf]] internal
        method of O with no arguments.

    b.  ReturnIfAbrupt(O).

    c.  If O is NULL, return FALSE.

    d.  If SameValue(P, O) is TRUE, return TRUE.

1.  2.  3.  4.  5.  a.  b.  i.  ii. 

    c.  

6.  

1.  

2.  

    a.  b.  c.  d.  e.  f.  

3.  4.  5.  6.  

1.  2.  3.  4.  a.  b.  c.  

5.  6.  7.  8.  

SpeciesConstructor ( O, defaultConstructor )

The abstract operation SpeciesConstructor is used to retrieve the
constructor that should be used to create new objects that are derived
from the argument object O. The defaultConstructor argument is the
constructor to use if O does not have a @@species property. This
abstract operation performs the following steps:

1.  Assert: Type(O) is Object.

2.  Let C be Get(O, "CONSTRUCTOR").

3.  ReturnIfAbrupt(C).

4.  If C is UNDEFINED, return defaultConstructor.

5.  If Type(C) is not Object, throw a TYPEERROR exception.

6.  Let S be Get(C, @@species).

7.  ReturnIfAbrupt(S).

8.  If S is either UNDEFINED or NULL, return defaultConstructor.

9.  If IsConstructor(S) is TRUE, return S.

10. Throw a TYPEERROR exception.

1.  2.  3.  4.  

EnumerableOwnNames (O)

When the abstract operation EnumerableOwnNames is called with Object O
the following steps are taken:

1.  Assert: Type(O) is Object.

2.  Let ownKeys be the result of calling the [[OwnPropertyKeys]]
    internal method of O with no arguments.

3.  ReturnIfAbrupt(ownKeys).

4.  5.  6.  Let names be a new empty List.

7.  8.  Repeat, for each element key of ownKeys in List order

    a.  b.  c.  If Type(key) is String, then

        i.  Let desc be the resulting of calling the
            [[GetOwnProperty]] internal method of O with argument
            key.

        ii. ReturnIfAbrupt(desc).

        iii. If desc is not UNDEFINED, then

            1.  If desc.[[Enumerable]] is TRUE, append key to
                names.

9.  Order the elements of names so they are in the same relative order
    as would be produced by the Iterator that would be returned if the
    [[Enumerate]] internal method was invoked on O.

    a.  

10. Return names.

NOTE The order of elements is returned list is the same as the
enumeration order that used by a for-in statement.

GetFunctionRealm ( obj ) Abstract Operation

The abstract operation GetFunctionRealm with argument obj performs the
following steps:

1.  Assert: obj is a callable object.

2.  If obj has a [[Realm]] internal slot, then

    a.  Return obj’s [[Realm]] internal slot.

3.  If obj is a Bound Function exotic object, then

    a.  Let target be obj’s [[BoundTargetFunction]] internal slot.

    b.  Return GetFunctionRealm(target).

4.  If obj is a Proxy exotic object, then

    a.  Let proxyTarget be the value of obj’s [[ProxyTarget]]
        internal slot.

    b.  If proxyTarget is not null, return
        GetFunctionRealm(proxyTarget).

5.  Return the running execution context’s Realm.

NOTE Step 5 will only be reached if target is a revoked proxy function
or a non-standard exotic function object that does not have a [[Realm]]
internal slot.


Operations on Iterator Objects

See Common Iteration Interfaces (25.1).

1.  2.  

3.  4.  5.  

1.  

GetIterator ( obj, method )

The abstract operation GetIterator with argument obj and optional
argument method performs the following steps:

1.  ReturnIfAbrupt(obj).

2.  If method was not passed, then

    a.  Let method be GetMethod(obj, @@iterator).

    b.  ReturnIfAbrupt(method).

3.  4.  Let iterator be Call(method_,_obj).

5.  ReturnIfAbrupt(iterator_)_.

6.  If Type(iterator) is not Object, throw a TYPEERROR exception.

7.  Return iterator.

1.  2.  3.  

IteratorNext ( iterator, value )

The abstract operation IteratorNext with argument iterator and
optional argument value performs the following steps:

1.  If value was not passed, then

    a.  Let result be Invoke(iterator, "NEXT", «‍ »).

2.  Else,

    a.  Let result be Invoke(iterator, "NEXT", «‍value»).

3.  ReturnIfAbrupt(result).

4.  If Type(result) is not Object, throw a TYPEERROR exception.

5.  Return result.

IteratorComplete ( iterResult )

The abstract operation IteratorComplete with argument iterResult
performs the following steps:

1.  Assert: Type(iterResult) is Object.

2.  Return ToBoolean(Get(iterResult, "DONE")).

3.  

IteratorValue ( iterResult )

The abstract operation IteratorValue with argument iterResult performs
the following steps:

1.  Assert: Type(iterResult) is Object.

2.  Return Get(iterResult, "VALUE").

IteratorStep ( iterator )

The abstract operation IteratorStep with argument iterator requests
the next value from iterator and returns either FALSE indicating that
the iterator has reached its end or the IteratorResult object if a next
value is available. IteratorStep performs the following steps:

1.  Let result be IteratorNext(iterator).

2.  ReturnIfAbrupt(result).

3.  Let done be IteratorComplete(result).

4.  ReturnIfAbrupt(done).

5.  If done is TRUE, return FALSE.

6.  Return result.

IteratorClose( iterator, completion )

The abstract operation IteratorClose with arguments iterator and
completion is used to notify an iterator that should perform any
actions it would normally perform when it has reached its completed
state:

1.  Assert: Type(iterator) is Object.

2.  Assert: completion is a Completion Record.

3.  Let return be GetMethod(iterator, "RETURN").

4.  ReturnIfAbrupt(return).

5.  If return is UNDEFINED, return completion.

6.  Let innerResult be Call(return, iterator, «‍ »).

7.  If completion.[[type]] is throw, return completion.

8.  If innerResult.[[type]] is throw,

9.  return innerResult.

10. If Type(innerResult.[[value]]) is not Object, throw a TypeError
    exception.

11. Return completion.

CreateIterResultObject ( value, done )

The abstract operation CreateIterResultObject with arguments value and
done creates an object that supports the IteratorResult interface by
performing the following steps:

1.  Assert: Type(done) is Boolean.

2.  Let obj be ObjectCreate(%ObjectPrototype%).

3.  Perform CreateDataProperty(obj, "VALUE", value).

4.  Perform CreateDataProperty(obj, "DONE", done).

5.  Return obj.

CreateListIterator ( list ) 

The abstract operation CreateListIterator with argument list creates
an Iterator (25.1.1.2) object whose next method returns the successive
elements of list. It performs the following steps:

1.  Let iterator be ObjectCreate(%IteratorPrototype%,
    «[[IteratorNext]], [[IteratedList]], [[ListIteratorNextIndex]]»).

2.  Set iterator’s [[IteratedList]] internal slot to list.

3.  Set iterator’s [[ListIteratorNextIndex]] internal slot to 0.

4.  Let next be a new built-in function object as defined in
    ListIterator NEXT (7.4.8.1).

5.  Set iterator’s [[IteratorNext]] internal slot to next.

6.  Let status be the result of CreateDataProperty(iterator, "NEXT",
    next).

7.  Return iterator.

ListIterator next( ) 

The ListIterator NEXT method is a standard built-in function object
(clause 17) that performs the following steps:

1.  Let O be the THIS value.

2.  Let f be the active function object.

3.  If O does not have a [[IteratorNext]] internal slot, throw a
    TYPEERROR exception.

4.  Let next be the value of the [[IteratorNext]] internal slot of
    O.

5.  If SameValue(f, next) is FALSE, throw a TYPEERROR exception.

6.  If O does not have a [[IteratedList]] internal slot, throw a
    TYPEERROR exception.

7.  Let list be the value of the [[IteratedList]] internal slot of
    O.

8.  Let index be the value of the [[ListIteratorNextIndex]] internal
    slot of O.

9.  Let len be the number of elements of list.

10. If index ≥ len, then

    a.  Return CreateIterResultObject(UNDEFINED, TRUE).

11. Set the value of the [[ListIteratorNextIndex]] internal slot of O
    to index+1.

12. Return CreateIterResultObject(list_[_index], FALSE).

NOTE A ListIterator NEXT method will throw an exception if applied to
any object other than the one with which it was originally associated.

1.  2.  

CreateCompoundIterator ( iterator1, iterator2 ) 

The abstract operation CreateCompoundIterator with arguments iterator1
and iterator2 creates an Iterator (25.1.1.2) object whose next method
returns the successive elements of iterator1 followed by the
successive elements of iterator2. It performs the following steps:

1.  Let iterator be ObjectCreate(%IteratorPrototype%, «‍[[Iterator1]],
    [[Iterator2]], [[State]], [[IteratorNext]]»).

2.  Set iterator’s [[Iterator1]] internal slot to iterator1.

3.  Set iterator’s [[Iterator2]] internal slot to iterator2.

4.  Set iterator’s [[State]] internal slot to 1.

5.  Let next be a new built-in function object as defined in
    CompoundIterator NEXT (7.4.9.1).

6.  Set iterator’s [[IteratorNext]] internal slot to next.

7.  Let status be the result of CreateDataProperty(iterator, "NEXT",
    next).

8.  Return iterator.

CompoundIterator next( ) 

The CompoundIterator NEXT method is a standard built-in function object
that performs the following steps:

1.  Let O be the THIS value.

2.  Let f be the active function object.

3.  If O does not have a [[IteratorNext]] internal slot, throw a
    TYPEERROR exception.

4.  Let next be the value of the [[IteratorNext]] internal slot of
    O.

5.  If SameValue(f, next) is FALSE, throw a TYPEERROR exception.

6.  If O does not have a [[Iterator1]] internal slot, throw a
    TYPEERROR exception.

7.  Assert: O is an object created and initialized by
    CreateCompoundIterator.

8.  Let state be the value of O’s [[State]] internal slot.

9.  If state = 1, then

    a.  Let iterator1 be the value of O’s [[Iterator1]] internal
        slot.

    b.  Let result1 be IteratorStep(iterator1).

    c.  If result1 is not FALSE, then

        i.  Return result1.

    d.  Set O’s [[State]] internal slot to 2.

10. Let iterator2 be the value of O’s [[Iterator2]] internal slot.

11. Return IteratorNext(iterator2).

NOTE A CompoundIterator NEXT method will throw an exception if applied
to any object other than the one with which it was originally
associated.


1.  2.  

1.  2.  

1.  

2.  3.  4.  5.  6.  

1.  



EXECUTABLE CODE AND EXECUTION CONTEXTS


Lexical Environments

A _Lexical Environment_ is a specification type used to define the
association of Identifiers to specific variables and functions based
upon the lexical nesting structure of ECMAScript code. A Lexical
Environment consists of an Environment Record and a possibly null
reference to an outer Lexical Environment. Usually a Lexical
Environment is associated with some specific syntactic structure of
ECMAScript code such as a FunctionDeclaration, a BlockStatement, or
a Catch clause of a TryStatement and a new Lexical Environment is
created each time such code is evaluated.

An _Environment Record_ records the identifier bindings that are created
within the scope of its associated Lexical Environment.

The outer environment reference is used to model the logical nesting of
Lexical Environment values. The outer reference of a (inner) Lexical
Environment is a reference to the Lexical Environment that logically
surrounds the inner Lexical Environment. An outer Lexical Environment
may, of course, have its own outer Lexical Environment. A Lexical
Environment may serve as the outer environment for multiple inner
Lexical Environments. For example, if a FunctionDeclaration contains
two nested FunctionDeclarations then the Lexical Environments of each
of the nested functions will have as their outer Lexical Environment the
Lexical Environment of the current evaluation of the surrounding
function.

A _global environment_ is a Lexical Environment which does not have an
outer environment. The global environment’s outer environment reference
is NULL. A global environment’s environment record may be prepopulated
with identifier bindings and includes an associated _global object_
whose properties provide some of the global environment’s identifier
bindings. This global object is the value of a global environment’s THIS
binding. As ECMAScript code is executed, additional properties may be
added to the global object and the initial properties may be modified.

A _module environment_ is a Lexical Environment that contains the
bindings for the top level declarations of a Module. It also contains
the bindings that are explicitly imported by the Module. The outer
environment of a module environment is a global environment.

A _function environment_ is a Lexical Environment that corresponds to
the invocation of an ECMAScript function object. A function environment
may establish a new THIS binding. A function environment also captures
the state necessary to support SUPER method invocations.

Lexical Environments and Environment Record values are purely
specification mechanisms and need not correspond to any specific
artefact of an ECMAScript implementation. It is impossible for an
ECMAScript program to directly access or manipulate such values.

Environment Records

There are two primary kinds of Environment Record values used in this
specification: _declarative environment records_ and _object environment
records_. Declarative environment records are used to define the effect
of ECMAScript language syntactic elements such as
FunctionDeclarations, VariableDeclarations, and Catch clauses that
directly associate identifier bindings with ECMAScript language values.
Object environment records are used to define the effect of ECMAScript
elements such as WithStatement that associate identifier bindings with
the properties of some object. Global Environment Records and Function
Environment Records are specializations that are used for specifically
for Script global declarations and for top-level declarations within
functions.

For specification purposes Environment Record values can be thought of
as existing in a simple object-oriented hierarchy where Environment
Record is an abstract class with three concrete subclasses, declarative
environment record, object environment record, and global environment
record. Function environment records and module environment records are
subclasses of declarative environment record. The abstract class
includes the abstract specification methods defined in Table 16. These
abstract methods have distinct concrete algorithms for each of the
concrete subclasses.

Table 16 — Abstract Methods of Environment Records

  METHOD                       PURPOSE
  ------------------------------ -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  HasBinding(N)                  Determine if an environment record has a binding for the String value N. Return TRUE if it does and FALSE if it does not
  CreateMutableBinding(N, D)     Create a new but uninitialized mutable binding in an environment record. The String value N is the text of the bound name. If the optional Boolean argument D is TRUE the binding is may be subsequently deleted.
  CreateImmutableBinding(N, S)   Create a new but uninitialized immutable binding in an environment record. The String value N is the text of the bound name. If S is TRUE then attempts to access the value of the binding before it is initialized or set it after it has been initialized will always throw an exception, regardless of the strict mode setting of operations that reference that binding. S is an optional parameter that defaults to FALSE.
  InitializeBinding(N,V)         Set the value of an already existing but uninitialized binding in an environment record. The String value N is the text of the bound name. V is the value for the binding and is a value of any ECMAScript language type.
  SetMutableBinding(N,V, S)      Set the value of an already existing mutable binding in an environment record. The String value N is the text of the bound name. V is the value for the binding and may be a value of any ECMAScript language type. S is a Boolean flag. If S is TRUE and the binding cannot be set throw a TYPEERROR exception.
  GetBindingValue(N,S)           Returns the value of an already existing binding from an environment record. The String value N is the text of the bound name. S is used to identify strict mode references. If S is TRUE and the binding does not exist throw a REFERENCEERROR exception. If the binding exists but is uninitialized a REFERENCEERROR is thrown, regardless of the value of S.
  DeleteBinding(N)               Delete a binding from an environment record. The String value N is the text of the bound name. If a binding for N exists, remove the binding and return TRUE. If the binding exists but cannot be removed return FALSE. If the binding does not exist return TRUE.
  HasThisBinding()               Determine if an environment record establishes a THIS binding. Return TRUE if it does and FALSE if it does not.
  HasSuperBinding()              Determine if an environment record establishes a SUPER method binding. Return TRUE if it does and FALSE if it does not.
  WithBaseObject ()              If this environment record is associated with a WITH statement, return the with object. Otherwise, return UNDEFINED.

Declarative Environment Records

Each declarative environment record is associated with an ECMAScript
program scope containing variable, constant, let, class, module, import,
and/or function declarations. A declarative environment record binds the
set of identifiers defined by the declarations contained within its
scope.

The behaviour of the concrete specification methods for Declarative
Environment Records is defined by the following algorithms.

HasBinding(N)

The concrete environment record method HasBinding for declarative
environment records simply determines if the argument identifier is one
of the identifiers bound by the record:

1.  Let envRec be the declarative environment record for which the
    method was invoked.

2.  If envRec has a binding for the name that is the value of N,
    return TRUE.

3.  Return FALSE.

CreateMutableBinding (N, D)

The concrete Environment Record method CreateMutableBinding for
declarative environment records creates a new mutable binding for the
name N that is uninitialized. A binding must not already exist in this
Environment Record for N. If Boolean argument D is provided and has
the value TRUE the new binding is marked as being subject to deletion.

1.  Let envRec be the declarative environment record for which the
    method was invoked.

2.  Assert: envRec does not already have a binding for N.

3.  Create a mutable binding in envRec for N and record that it is
    uninitialized. If D is TRUE record that the newly created binding
    may be deleted by a subsequent DeleteBinding call.

4.  Return NormalCompletion(empty).

CreateImmutableBinding (N, S)

The concrete Environment Record method CreateImmutableBinding for
declarative environment records creates a new immutable binding for the
name N that is uninitialized. A binding must not already exist in this
environment record for N. If Boolean argument S is provided and has
the value TRUE the new binding is marked as a strict binding.

1.  Let envRec be the declarative environment record for which the
    method was invoked.

2.  Assert: envRec does not already have a binding for N.

3.  Create an immutable binding in envRec for N and record that it
    is uninitialized. If S is TRUE record that the newly created
    binding is a strict binding.

4.  Return NormalCompletion(empty).

5.  

InitializeBinding (N,V)

The concrete Environment Record method InitializeBinding for declarative
environment records is used to set the bound value of the current
binding of the identifier whose name is the value of the argument N to
the value of argument V. An uninitialized binding for N must already
exist.

1.  Let envRec be the declarative environment record for which the
    method was invoked.

2.  Assert: envRec must have an uninitialized binding for N.

3.  Set the bound value for N in envRec to V.

4.  Record that the binding for N in envRec has been initialized.

5.  Return NormalCompletion(empty).

SetMutableBinding (N,V,S)

The concrete Environment Record method SetMutableBinding for declarative
environment records attempts to change the bound value of the current
binding of the identifier whose name is the value of the argument N to
the value of argument V. A binding for N normally already exist, but
in rare cases it may not. If the binding is an immutable binding, a
TYPEERROR is thrown if S is TRUE.

1.  Let envRec be the declarative environment record for which the
    method was invoked.

2.  If envRec does not have a binding for N, then

    a.  If S is TRUE throw a REFERENCEERROR exception.

    b.  Call the CreateMutableBinding concrete method of envRec with
        arguments N and TRUE.

    c.  Call the InitializeBinding concrete method of envRec with
        arguments N and V.

    d.  Return NormalCompletion(empty).

3.  If the binding for N in envRec is a strict binding, let S be
    TRUE.

4.  If the binding for N in envRec has not yet been initialized
    throw a REFERENCEERROR exception.

5.  Else if the binding for N in envRec is a mutable binding, change
    its bound value to V.

6.  Else this must be an attempt to change the value of an immutable
    binding so if S is TRUE throw a TYPEERROR exception.

7.  Return NormalCompletion(empty).

NOTE An example of ECMAScript code that results in a missing binding at
step 2 is:

function f(){eval("var x; x = (delete x, 0);")}

GetBindingValue(N,S)

The concrete Environment Record method GetBindingValue for declarative
environment records simply returns the value of its bound identifier
whose name is the value of the argument N. If the binding exists but
is uninitialized a REFERENCEERROR is thrown, regardless of the value of
S.

1.  Let envRec be the declarative environment record for which the
    method was invoked.

2.  Assert: envRec has a binding for N.

3.  a.  

4.  If the binding for N in envRec is an uninitialized binding,

5.  throw a REFERENCEERROR exception.

6.  7.  Return the value currently bound to N in envRec.

DeleteBinding (N)

The concrete Environment Record method DeleteBinding for declarative
environment records can only delete bindings that have been explicitly
designated as being subject to deletion.

1.  Let envRec be the declarative environment record for which the
    method was invoked.

2.  If envRec does not have a binding for the name that is the value
    of N, return TRUE.

3.  If the binding for N in envRec cannot be deleted, return FALSE.

4.  Remove the binding for N from envRec.

5.  Return TRUE.

HasThisBinding () 

Regular Declarative Environment Records do not provide a THIS binding.

1.  Return FALSE.

HasSuperBinding ()

Regular Declarative Environment Records do not provide a SUPER binding.

1.  Return FALSE.

 WithBaseObject()

Declarative Environment Records always return UNDEFINED as their
WithBaseObject.

1.  Return UNDEFINED.

Object Environment Records

Each object environment record is associated with an object called its
_binding object_. An object environment record binds the set of string
identifier names that directly correspond to the property names of its
binding object. Property keys that are not strings in the form of an
IdentifierName are not included in the set of bound identifiers. Both
own and inherited properties are included in the set regardless of the
setting of their [[Enumerable]] attribute. Because properties can be
dynamically added and deleted from objects, the set of identifiers bound
by an object environment record may potentially change as a side-effect
of any operation that adds or deletes properties. Any bindings that are
created as a result of such a side-effect are considered to be a mutable
binding even if the Writable attribute of the corresponding property has
the value FALSE. Immutable bindings do not exist for object environment
records.

Object environment records created for WITH statements (13.10) can
provide their binding object as an implicit this value for use in
function calls. The capability is controlled by a withEnvironment
Boolean value that is associated with each object environment record. By
default, the value of withEnvironment is FALSE for any object
environment record.

The behaviour of the concrete specification methods for Object
Environment Records is defined by the following algorithms.

HasBinding(N)

The concrete Environment Record method HasBinding for object environment
records determines if its associated binding object has a property whose
name is the value of the argument N:

1.  Let envRec be the object environment record for which the method
    was invoked.

2.  3.  Let bindings be the binding object for envRec.

4.  Let foundBinding be HasProperty(bindings, N)

5.  ReturnIfAbrupt(foundBinding).

6.  If foundBinding is FALSE, return FALSE.

7.  If the withEnvironment flag of envRec is FALSE, return TRUE.

8.  Let unscopables be Get(bindings, @@unscopables).

9.  ReturnIfAbrupt(unscopables).

10. If Type(unscopables) is Object, then

    a.  Let blocked be Get(unscopables, N).

    b.  ReturnIfAbrupt(blocked).

    c.  If ToBoolean(blocked) is TRUE, return FALSE.

11. a.  b.  c.  i.  ii. iii. iv. v.  vi. vii. viii. ix. 

    d.  e.  

12. Return TRUE.

CreateMutableBinding (N, D)

The concrete Environment Record method CreateMutableBinding for object
environment records creates in an environment record’s associated
binding object a property whose name is the String value and initializes
it to the value UNDEFINED. If Boolean argument D is provided and has
the value TRUE the new property’s [[Configurable]] attribute is set to
TRUE, otherwise it is set to FALSE.

1.  Let envRec be the object environment record for which the method
    was invoked.

2.  Let bindings be the binding object for envRec.

3.  If D is TRUE then let configValue be TRUE otherwise let
    configValue be FALSE.

4.  Return DefinePropertyOrThrow(bindings, N,
    PropertyDescriptor{[[Value]]:UNDEFINED, [[Writable]]: TRUE,
    [[Enumerable]]: TRUE , [[Configurable]]: configValue}).

NOTE Normally envRec will not have a binding for N but if it does,
the semantics of DefinePropertyOrThrow may result in an existing binding
being replaced or shadowed or cause an abrupt completion to be returned.

CreateImmutableBinding (N, S)

The concrete Environment Record method CreateImmutableBinding is never
used within this specification in association with Object environment
records.

InitializeBinding (N,V)

The concrete Environment Record method InitializeBinding for object
environment records is used to set the bound value of the current
binding of the identifier whose name is the value of the argument N to
the value of argument V. An uninitialized binding for N must already
exist.

1.  Let envRec be the object environment record for which the method
    was invoked.

2.  Assert: envRec must have an uninitialized binding for N.

3.  Record that the binding for N in envRec has been initialized.

4.  Return the result of calling the SetMutableBinding concrete method
    of envRec with N, V, and FALSE as arguments.

SetMutableBinding (N,V,S)

The concrete Environment Record method SetMutableBinding for object
environment records attempts to set the value of the environment
record’s associated binding object’s property whose name is the value of
the argument N to the value of argument V. A property named N
normally already exists but if it does not or is not currently writable,
error handling is determined by the value of the Boolean argument S.

1.  Let envRec be the object environment record for which the method
    was invoked.

2.  Let bindings be the binding object for envRec.

3.  Return Put(bindings, N, V, and S).

GetBindingValue(N,S)

The con

crete Environment Record method GetBindingValue for object environment
records returns the value of its associated binding object’s property
whose name is the String value of the argument identifier N. The
property should already exist but if it does not the result depends upon
the value of the S argument:

1.  Let envRec be the object environment record for which the method
    was invoked.

2.  Let bindings be the binding object for envRec.

3.  4.  a.  b.  c.  i.  ii. iii. iv. 1.  2.  3.  a.  b.  

        v.  1.  

    d.  e.  

5.  Let value be HasProperty(bindings, N).

6.  ReturnIfAbrupt(value).

7.  If value is FALSE, then

    a.  If S is FALSE, return the value UNDEFINED, otherwise throw a
        REFERENCEERROR exception.

8.  Return Get(bindings, N).

9.  10. 11. 

DeleteBinding (N)

The concrete Environment Record method DeleteBinding for object
environment records can only delete bindings that correspond to
properties of the environment object whose [[Configurable]] attribute
have the value TRUE.

1.  Let envRec be the object environment record for which the method
    was invoked.

2.  Let bindings be the binding object for envRec.

3.  Return the result of calling the [[Delete]] internal method of
    bindings passing N as the argument.

HasThisBinding ()

Regular Object Environment Records do not provide a THIS binding.

1.  Return FALSE.

HasSuperBinding ()

Regular Object Environment Records do not provide a SUPER binding.

1.  Return FALSE.

 WithBaseObject()

Object Environment Records return UNDEFINED as their WithBaseObject
unless their withEnvironment flag is TRUE.

1.  Let envRec be the object environment record for which the method
    was invoked.

2.  If the withEnvironment flag of envRec is TRUE, return the
    binding object for envRec.

3.  Otherwise, return UNDEFINED.

Function Environment Records

A function environment record is a declarative environment record that
is used to represent the top-level scope of a function and, if the
function is not an ArrowFunction, provides a THIS binding. If a
function is not an ArrowFunction function and references SUPER, its
function environment record also contains the state that is used to
perform SUPER method invocations from within the function.

Function environment records have the additional state fields listed in
Table 17.

Table 17 — Additional Fields of Function Environment Records

  COMPONENT                   PURPOSE
  ----------------------------- ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  [[thisValue]]                 If the value is EMPTY, this is an ArrowFunction and does not have a local this value. Otherwise, this is the THIS value used for this invocation of the function.
  [[thisInitializationState]]   If FALSE, the [[thisValue]] field has not yet been initialized, otherwise TRUE.
  [[FunctionObject]]            The Function Object whose invocation caused this environment record to be created.
  [[HomeObject]]                If the associated function has SUPER property accesses and is not an ArrowFunction, [[HomeObject]] is the object that the function is bound to as a method. The default value for [[HomeObject]] is UNDEFINED.
  [[NewTarget]]                 If this environment record was created by the [[Construct]] internal method, [[NewTarget]] is the value of the [[Construct]] newTarget parameter. Otherwise, its value is UNDEFINED.
  [[topLex]]                    The lexical environment record that contains the bindings for lexical declarations that occur at the top-level of the function. For strict mode functions, this is the same as current function environment record.

Function environment records support all of Declarative Environment
Record methods listed in Table 16 and share the same specifications for
all of those methods except for HasThisBinding and HasSuperBinding. In
addition, Function Environment Records support the methods listed in
Table 18:

Table 18 — Additional Methods of Function Environment Records

  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  METHOD           PURPOSE
  ------------------ ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  BindThisValue      Set the [[thisValue]] and record that it has been initialized.
                     
  (V)                

  GetThisBinding()   Return the value of this environment record’s THIS binding.

  GetSuperBase()     Return the object that is the base for SUPER property accesses bound in this environment record. The object is derived from this environment record’s [[HomeObject]] field. The value UNDEFINED indicates that SUPER property accesses will produce runtime errors.

                     
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

The behaviour of the additional concrete specification methods for
Function Environment Records is defined by the following algorithms:

BindThisValue(V)

1.  Let envRec be the function environment record for which the method
    was invoked.

2.  Assert: envRec.[[thisInitializationState]] is FALSE.

3.  Set envRec.[[thisValue]] to V.

4.  If envRec.[[thisInitializationState]] is TRUE, throw a
    REFERENCEERROR exception

5.  Set envRec.[[thisInitializationState]] to TRUE.

6.  Return V.

HasThisBinding ()

1.  Let envRec be the function environment record for which the method
    was invoked.

2.  If envRec.[[thisValue]] has the value empty, return FALSE;
    otherwise, return TRUE.

HasSuperBinding ()

1.  Let envRec be the function environment record for which the method
    was invoked.

2.  If envRec.[[thisValue]] has the value empty, return FALSE.

3.  If envRec.[[HomeObject]] has the value UNDEFINED, return FALSE,
    otherwise, return TRUE.

GetThisBinding ()

1.  Let envRec be the function environment record for which the method
    was invoked.

2.  If envRec.[[thisInitializationState]] is FALSE, throw a
    REFERENCEERROR exception.

3.  Return envRec.[[thisValue]].

GetSuperBase ()

1.  Let envRec be the function environment record for which the method
    was invoked.

2.  Let home be the value of envRec.[[HomeObject]].

3.  If home has the value UNDEFINED, return UNDEFINED.

4.  Assert: Type(home) is Object.

5.  Return the result of calling home’s [[GetPrototypeOf]] internal
    method.

1.  

Global Environment Records

A global environment record is used to represent the outer most scope
that is shared by all of the ECMAScript Script elements that are
processed in a common Realm (8.2). A global environment record provides
the bindings for built-in globals (clause 18), properties of the global
object, and for all declarations that are not function code and that
occur within Script productions.

A global environment record is logically a single record but it is
specified as a composite encapsulating an object environment record and
a declarative environment record. The object environment record has as
its base object the global object of the associated Realm. This global
object is also the value of the global environment record’s
GetThisBinding concrete method. The object environment record component
of a global environment record contains the bindings for all built-in
globals (clause 18) and all bindings introduced by a
FunctionDeclaration, GeneratorDeclaration, or VariableStatement
contained in global code. The bindings for all other ECMAScript
declarations in global code are contained in the declarative environment
record component of the global environment record.

Properties may be created directly on a global object. Hence, the object
environment record component of a global environment record may contain
both bindings created explicitly by FunctionDeclaration,
GeneratorDeclaration, or VariableDeclaration declarations and
binding created implicitly as properties of the global object. In order
to identify which bindings were explicitly created using declarations, a
global environment record maintains a list of the names bound using its
CreateGlobalVarBindings and CreateGlobalFunctionBindings concrete
methods.

Global environment records have the additional fields listed in Table 19
and the additional methods listed in Table 20.

Table 19 — Fields of Global Environment Records

  COMPONENT             PURPOSE
  ----------------------- -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  [[ObjectRecord]]        An Object Environment Record whose base object is the global object. It contains global built-in bindings as well as FunctionDeclaration, GeneratorDeclaration, and VariableDeclaration bindings in global code for the associated Realm.
  [[DeclarativeRecord]]   A Declarative Environment Record that contains bindings for all declarations in global code for the associated Realm code except for FunctionDeclaration, GeneratorDeclaration, and VariableDeclaration bindings.
  [[VarNames]]            A List containing the string names bound by FunctionDeclaration, GeneratorDeclaration, and VariableDeclaration declarations in global code for the associated Realm.

Table 20 — Additional Methods of Global Environment Records

  METHOD                               PURPOSE
  -------------------------------------- -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  GetThisBinding()                       Return the value of this environment record’s THIS binding.
  HasVarDeclaration (N)                  Determines if the argument identifier has a binding in this environment record that was created using a VariableDeclaration, FunctionDeclaration, or GeneratorDeclaration.
  HasLexicalDeclaration (N)              Determines if the argument identifier has a binding in this environment record that was created using a lexical declaration such as a LexicalDeclaration or a ClassDeclaration.
  HasRestrictedGlobalProperty (N)        Determines if the argument is the name of a global object property that may not be shadowed by a global lexically binding.
  CanDeclareGlobalVar (N)                Determines if a corresponding CreateGlobalVarBinding call would succeed if called for the same argument N.
  CanDeclareGlobalFunction (N)           Determines if a corresponding CreateGlobalFunctionBinding call would succeed if called for the same argument N.
  CreateGlobalVarBinding(N, D)           Used to create global VAR bindings in the [[ObjectRecord]] component of a global environment record. The binding will be a mutable binding. The corresponding global object property will have attribute values appropriate for a VAR. The String value N is bound name. If D is TRUE the binding may be subsequently deleted. This is logically equivalent to CreateMutableBinding but it allows var declarations to receive special treatment.
  CreateGlobalFunctionBinding(N, V, D)   Used to create and initialize global FUNCTION bindings in the [[ObjectRecord]] component of a global environment record. The binding will be a mutable binding. The corresponding global object property will have attribute values appropriate for a FUNCTION.The String value N is the text of the bound name. V is the initial value of the binding. If the optional Boolean argument D is TRUE the binding is may be subsequently deleted. This is logically equivalent to CreateMutableBinding followed by a SetMutableBinding but it allows function declarations to receive special treatment.
                                         

The behaviour of the concrete specification methods for Global
Environment Records is defined by the following algorithms.

HasBinding(N)

The concrete environment record method HasBinding for global environment
records simply determines if the argument identifier is one of the
identifiers bound by the record:

1.  Let envRec be the global environment record for which the method
    was invoked.

2.  Let DclRec be envRec.[[DeclarativeRecord]].

3.  If the result of calling DclRec’s HasBinding concrete method with
    argument N is TRUE, return TRUE.

4.  Let ObjRec be envRec.[[ObjectRecord]].

5.  Return the result of calling ObjRec’s HasBinding concrete method
    with argument N.

6.  

CreateMutableBinding (N, D)

The concrete environment record method CreateMutableBinding for global
environment records creates a new mutable binding for the name N that
is uninitialized. The binding is created in the associated
DeclarativeRecord. A binding for N must not already exist in the
DeclarativeRecord. If Boolean argument D is provided and has the value
TRUE the new binding is marked as being subject to deletion.

1.  Let envRec be the global environment record for which the method
    was invoked.

2.  Let DclRec be envRec.[[DeclarativeRecord]].

3.  Let alreadyThere be the result of calling the HasBinding concrete
    method of DclRec with argument N.

4.  ReturnIfAbrupt(alreadyThere).

5.  If alreadyThere is TRUE, throw a TYPEERROR exception.

6.  Return the result of calling the CreateMutableBinding concrete
    method of DclRec with arguments N and D.

CreateImmutableBinding (N, S)

The concrete Environment Record method CreateImmutableBinding for global
environment records creates a new immutable binding for the name N
that is uninitialized. A binding must not already exist in this
environment record for N. If Boolean argument S is provided and has
the value TRUE the new binding is marked as a strict binding.

1.  Let envRec be the global environment record for which the method
    was invoked.

2.  Let DclRec be envRec.[[DeclarativeRecord]].

3.  Let alreadyThere be the result of calling the HasBinding concrete
    method of DclRec with argument N.

4.  ReturnIfAbrupt(alreadyThere).

5.  If alreadyThere is TRUE, throw a TYPEERROR exception.

6.  7.  Return the result of calling the CreateImmutableBinding concrete
    method of DclRec with argument N and S.

InitializeBinding (N,V)

The concrete Environment Record method InitializeBinding for global
environment records is used to set the bound value of the current
binding of the identifier whose name is the value of the argument N to
the value of argument V. An uninitialized binding for N must already
exist.

1.  Let envRec be the global environment record for which the method
    was invoked.

2.  Let DclRec be envRec.[[DeclarativeRecord]].

3.  If the result of calling DclRec’s HasBinding concrete method with
    argument N is TRUE, then

    a.  Return the result of calling DclRec’s InitializeBinding
        concrete method with arguments N and V.

4.  Assert: If the binding exists it must be in the object environment
    record.

5.  Let ObjRec be envRec.[[ObjectRecord]].

6.  Return the result of calling ObjRec’s InitializeBinding concrete
    method with arguments N and V.

SetMutableBinding (N,V,S)

The concrete Environment Record method SetMutableBinding for global
environment records attempts to change the bound value of the current
binding of the identifier whose name is the value of the argument N to
the value of argument V. If the binding is an immutable binding, a
TYPEERROR is thrown if S is TRUE. A property named N normally already
exists but if it does not or is not currently writable, error handling
is determined by the value of the Boolean argument S.

1.  Let envRec be the global environment record for which the method
    was invoked.

2.  Let DclRec be envRec.[[DeclarativeRecord]].

3.  If the result of calling DclRec’s HasBinding concrete method with
    argument N is TRUE, then

    a.  Return the result of calling the SetMutableBinding concrete
        method of DclRec with arguments N, V, and S.

4.  Let ObjRec be envRec.[[ObjectRecord]].

5.  Return the result of calling the SetMutableBinding concrete method
    of ObjRec with arguments N, V, and S.

GetBindingValue(N,S)

The concrete Environment Record method GetBindingValue for global
environment records returns the value of its bound identifier whose name
is the value of the argument N. If the binding is an uninitialized
binding throw a REFERENCEERROR exception. A property named N normally
already exists but if it does not or is not currently writable, error
handling is determined by the value of the Boolean argument S.

1.  Let envRec be the global environment record for which the method
    was invoked.

2.  Let DclRec be envRec.[[DeclarativeRecord]].

3.  If the result of calling DclRec’s HasBinding concrete method with
    argument N is TRUE, then

    a.  Return the result of calling the GetBindingValue concrete method
        of DclRec with arguments N and S.

4.  Let ObjRec be envRec.[[ObjectRecord]].

5.  Return the result of calling the GetBindingValue concrete method of
    ObjRec with arguments N, and S.

DeleteBinding (N)

The concrete Environment Record method DeleteBinding for global
environment records can only delete bindings that have been explicitly
designated as being subject to deletion.

1.  Let envRec be the global environment record for which the method
    was invoked.

2.  Let DclRec be envRec.[[DeclarativeRecord]].

3.  If the result of calling DclRec’s HasBinding concrete method with
    argument N is TRUE, then

    a.  Return the result of calling the DeleteBinding concrete method
        of DclRec with argument N.

4.  Let ObjRec be envRec.[[ObjectRecord]].

5.  If the result of calling ObjRec’s HasBinding concrete method with
    argument N is TRUE, then

    a.  Let status be the result of calling the DeleteBinding concrete
        method of ObjRec with argument N.

    b.  ReturnIfAbrupt(status).

    c.  If status is TRUE, then

        i.  Let varNames be envRec.[[VarNames]] List.

        ii. If N is an element of varNames, remove that element from
            the varNames.

    d.  Return status.

6.  Return TRUE.

HasThisBinding ()

Global Environment Records always provide a THIS binding whose value is
the associated global object.

1.  Return TRUE.

HasSuperBinding ()

1.  Return FALSE.

 WithBaseObject()

Global Environment Records always return UNDEFINED as their
WithBaseObject.

1.  Return UNDEFINED.

GetThisBinding ()

1.  Let envRec be the global environment record for which the method
    was invoked.

2.  Let ObjRec be envRec.[[ObjectRecord]].

3.  Let bindings be the binding object for ObjRec.

4.  Return bindings.

HasVarDeclaration (N)

The concrete environment record method HasVarDeclaration for global
environment records determines if the argument identifier has a binding
in this record that was created using a VariableStatement or a
FunctionDeclaration:

1.  Let envRec be the global environment record for which the method
    was invoked.

2.  Let varDeclaredNames be envRec.[[VarNames]].

3.  If varDeclaredNames contains the value of N, return TRUE.

4.  5.  Return FALSE.

6.  

HasLexicalDeclaration (N)

The concrete environment record method HasLexicalDeclaration for global
environment records determines if the argument identifier has a binding
in this record that was created using a lexical declaration such as a
LexicalDeclaration or a ClassDeclaration:

1.  Let envRec be the global environment record for which the method
    was invoked.

2.  Let DclRec be envRec.[[DeclarativeRecord]].

3.  Return the result of calling DclRec’s HasBinding concrete method
    with argument N.

4.  

HasRestrictedGlobalProperty (N)

The concrete environment record method HasRestrictedGlobalProperty for
global environment records determines if the argument identifier is the
name of a property of the global object that must not be shadowed by a
global lexically binding:

1.  Let envRec be the global environment record for which the method
    was invoked.

2.  Let ObjRec be envRec.[[ObjectRecord]].

3.  Let globalObject be the binding object for ObjRec.

4.  Let existingProp be the result of calling the [[GetOwnProperty]]
    internal method of globalObject with argument N.

5.  ReturnIfAbrupt(existingProp).

6.  If existingProp is UNDEFINED, return FALSE.

7.  If existingProp.[[Configurable]] is TRUE, return FALSE.

8.  Return TRUE.

NOTE Properties may exist upon a global object that were directly
created rather than being declared using a var or function declaration.
A global lexical binding may not be created that has the same name as a
non-configurable property of the global object. The global property
UNDEFINED is an example of such a property.

CanDeclareGlobalVar (N)

The concrete environment record method CanDeclareGlobalVar for global
environment records determines if a corresponding CreateGlobalVarBinding
call would succeed if called for the same argument N. Redundant var
declarations and var declarations for pre-existing global object
properties are allowed.

1.  Let envRec be the global environment record for which the method
    was invoked.

2.  Let ObjRec be envRec.[[ObjectRecord]].

3.  If the result of calling ObjRec’s HasBinding concrete method with
    argument N is TRUE, return TRUE.

4.  Let bindings be the binding object for ObjRec.

5.  6.  Let extensible be IsExtensible(bindings).

7.  Return extensible.

8.  

 CanDeclareGlobalFunction (N)

The concrete environment record method CanDeclareGlobalFunction for
global environment records determines if a corresponding
CreateGlobalFunctionBinding call would succeed if called for the same
argument N.

1.  Let envRec be the global environment record for which the method
    was invoked.

2.  Let ObjRec be envRec.[[ObjectRecord]].

3.  Let globalObject be the binding object for ObjRec.

4.  Let extensible be IsExtensible(globalObject).

5.  ReturnIfAbrupt(extensible).

6.  If the result of calling ObjRec’s HasBinding concrete method with
    argument N is FALSE, return extensible.

7.  Let existingProp be the result of calling the [[GetOwnProperty]]
    internal method of globalObject with argument N.

8.  ReturnIfAbrupt(existingProp).

9.  If existingProp is UNDEFINED, return extensible.

10. If existingProp.[[Configurable]] is TRUE, return TRUE.

11. If IsDataDescriptor(existingProp) is TRUE and existingProp has
    attribute values {[[Writable]]: TRUE, [[Enumerable]]: TRUE}, return
    TRUE.

12. Return FALSE.

13. 

 CreateGlobalVarBinding (N, D)

The concrete Environment Record method CreateGlobalVarBinding for global
environment records creates a mutable binding in the associated object
environment record and records the bound name in the associated
[[VarNames]] List. If a binding already exists, it is reused.

1.  Let envRec be the global environment record for which the method
    was invoked.

2.  Let ObjRec be envRec.[[ObjectRecord]].

3.  If the result of calling ObjRec’s HasBinding concrete method with
    argument N is FALSE, then

    a.  Let status be the result of calling the CreateMutableBinding
        concrete method of ObjRec with arguments N and D.

    b.  ReturnIfAbrupt(status).

4.  Let varDeclaredNames be envRec.[[VarNames]].

5.  If varDeclaredNames does not contain the value of N, then

6.  a.  Append N to varDeclaredNames.

7.  Return NormalCompletion(empty).

8.  

CreateGlobalFunctionBinding (N, V, D)

The concrete Environment Record method CreateGlobalFunctionBinding for
global environment records creates a mutable binding in the associated
object environment record and records the bound name in the associated
[[VarNames]] List. If a binding already exists, it is replaced.

1.  Let envRec be the global environment record for which the method
    was invoked.

2.  Let ObjRec be envRec.[[ObjectRecord]].

3.  Let globalObject be the binding object for ObjRec.

4.  Let existingProp be the result of calling the [[GetOwnProperty]]
    internal method of globalObject with argument N.

5.  ReturnIfAbrupt(existingProp).

6.  If existingProp is UNDEFINED or existingProp.[[Configurable]] is
    TRUE, then

    a.  Let desc be the PropertyDescriptor{[[Value]]:V,
        [[Writable]]: TRUE, [[Enumerable]]: TRUE , [[Configurable]]:
        D}.

7.  Else,

    a.  Let desc be the PropertyDescriptor{[[Value]]:V }.

8.  Let status be DefinePropertyOrThrow(globalObject, N, desc).

9.  ReturnIfAbrupt(status).

10. Let varDeclaredNames be envRec.[[VarNames]].

11. If varDeclaredNames does not contain the value of N, then

12. a.  Append N to varDeclaredNames.

13. Return NormalCompletion(empty).

14. 

NOTE Global function declarations are always represented as own
properties of the global object. If possible, an existing own property
is reconfigured to have a standard set of attribute values.

Module Environment Records

A module environment record is a declarative environment record that is
used to represent the outer scope of an ECMAScript Module. In
additional to normal mutable and immutable bindings, module environment
records also provide immutable import bindings which are bindings that
provide indirect access to a target binding that exists in another
environment record.

Module environment records support all of the Declarative Environment
Record methods listed in Table 16 and share the same specifications for
all of those methods except for GetBindingValue, DeleteBinding,
HasThisBinding and GetThisBinding. In addition, module environment
records support the methods listed in Table 21:

Table 21 — Additional Methods of Module Environment Records

  METHOD                         PURPOSE
  -------------------------------- --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  CreateImportBinding(N, M, N2 )   Create an immutable indirect binding in a module environment record. The String value N is the text of the bound name. M is a Module Record (see 15.2.1.15), and N2 is a binding that exists in M’s module environment record.
  GetThisBinding()                 Return the value of this environment record’s THIS binding.

The behaviour of the additional concrete specification methods for
Module Environment Records is defined by the following algorithms:

GetBindingValue(N,S)

The concrete Environment Record method GetBindingValue for module
environment records returns the value of its bound identifier whose name
is the value of the argument N. However, if the binding is an indirect
binding the value of the target binding is returned. If the binding
exists but is uninitialized a REFERENCEERROR is thrown, regardless of
the value of S.

1.  Let envRec be the module environment record for which the method
    was invoked.

2.  Assert: envRec has a binding for N.

3.  If the binding for N is an indirect binding, then

    a.  Assert: M and N2 are the indirection values provided when
        this binding for N was created.

    b.  Let targetER be M.[[Environment]]’s environment record.

    c.  Return the result of calling the GetBindingValue concrete method
        of targetER with arguments N2 and S.

4.  If the binding for N in envRec is an uninitialized binding,
    throw a REFERENCEERROR exception.

5.  Return the value currently bound to N in envRec.

NOTE Because a Module is always strict mode code, calls to
GetBindingValue should always pass TRUE as the value of S.

DeleteBinding (N)

The concrete Environment Record method DeleteBinding for module
environment records refuses to delete bindings.

1.  Let envRec be the module environment record for which the method
    was invoked.

2.  If envRec does not have a binding for the name that is the value
    of N, return TRUE.

3.  Return FALSE.

NOTE Because the bindings of a module environment record are not
deletable.

HasThisBinding () 

Module Environment Records provide a THIS binding.

1.  Return TRUE.

GetThisBinding ()

1.  Return UNDEFINED.

CreateImportBinding (N, M, N2)

The concrete Environment Record method CreateImportBinding for module
environment records creates a new initialized immutable indirect binding
for the name N. A binding must not already exist in this environment
record for N. M is a Module Record (see 15.2.1.15), and N2 is the
name of a binding that exists in M’s module environment record. Accesses
to the value of the new binding will indirectly access the bound value
of value of the target binding.

1.  Let envRec be the module environment record for which the method
    was invoked.

2.  Assert: envRec does not already have a binding for N.

3.  Assert: M is a Module Record.

4.  Assert: When M.[[Environment]] is instantiated it will have a
    direct binding for N2.

5.  Create an immutable indirect binding in envRec for N that
    references M and N2 as its target binding _and r_ecord that the
    binding is initialized.

6.  Return NormalCompletion(empty).

Lexical Environment Operations

The following abstract operations are used in this specification to
operate upon lexical environments:

GetIdentifierReference (lex, name, strict) Abstract Operation

The abstract operation GetIdentifierReference is called with a Lexical
Environment lex, a String name, and a Boolean flag strict. The
value of lex may be NULL. When called, the following steps are
performed:

1.  If lex is the value NULL, then

    a.  Return a value of type Reference whose base value is UNDEFINED,
        whose referenced name is name, and whose strict reference flag
        is strict.

2.  Let envRec be lex’s environment record.

3.  Let exists be the result of calling the HasBinding concrete method
    of envRec passing name as the argument.

4.  ReturnIfAbrupt(exists).

5.  If exists is TRUE, then

    a.  Return a value of type Reference whose base value is envRec,
        whose referenced name is name, and whose strict reference flag
        is strict.

6.  Else

    a.  Let outer be the value of lex’s outer environment reference.

    b.  Return GetIdentifierReference(outer, name, strict).

NewDeclarativeEnvironment (E) Abstract Operation

When the abstract operation NewDeclarativeEnvironment is called with
either a Lexical Environment or NULL as argument E the following steps
are performed:

1.  Let env be a new Lexical Environment.

2.  Let envRec be a new declarative environment record containing no
    bindings.

3.  Set env’s environment record to be envRec.

4.  Set the outer lexical environment reference of env to E.

5.  Return env.

NewObjectEnvironment (O, E) Abstract Operation

When the abstract operation NewObjectEnvironment is called with an
Object O and a Lexical Environment E (or NULL) as arguments, the
following steps are performed:

1.  Let env be a new Lexical Environment.

2.  Let envRec be a new object environment record containing O as
    the binding object.

3.  4.  Set env’s environment record to envRec.

5.  Set the outer lexical environment reference of env to E.

6.  Return env.

NewFunctionEnvironment (F) Abstract Operation

When the abstract operation NewFunctionEnvironment is called with an
ECMAScript function Object F as its argument, the following steps are
performed:

1.  2.  3.  Let env be a new Lexical Environment.

4.  Let envRec be a new Function environment record containing no
    bindings.

5.  6.  Set envRec.[[FunctionObject]] to F.

7.  Set envRec.[[thisInitializationState]] to FALSE.

8.  If F’s [[ThisMode]] internal slot is lexical, set
    envRec.[[thisValue]] to empty.

9.  If F’s [[NeedsSuper]] internal slot is TRUE, then

    a.  Let home be the value of F’s [[HomeObject]] internal slot.

    b.  If home is UNDEFINED, throw a REFERENCEERROR exception.

    c.  Set envRec.[[HomeObject]] to home.

    d.  

10. Else,

    a.  Set envRec.[[HomeObject]] to UNDEFINED.

11. Set envRec.[[NewTarget]] to UNDEFINED.

12. Set env’s environment record to be envRec.

13. Set the outer lexical environment reference of env to the value of
    F’s [[Environment]] internal slot.

14. Return env.

NewGlobalEnvironment ( G ) Abstract Operation

When the abstract operation NewGlobalEnvironment is called with an
ECMAScript Object G as its argument, the following steps are
performed:

1.  Let env be a new Lexical Environment.

2.  Let objRec be a new object environment record containing G as
    the binding object.

3.  Set objRec’s unscopables to an empty List.

4.  Let dclRec be a new declarative environment record containing no
    bindings.

5.  Let globalRec be a new global environment record.

6.  Set globalRec.[[ObjectRecord]] to objRec.

7.  Set globalRec.[[DeclarativeRecord]] to dclRec.

8.  Set globalRec.[[VarNames]] to a new empty List.

9.  Set env’s environment record to globalRec.

10. Set the outer lexical environment reference of env to NULL

11. Return env.

NewModuleEnvironment (E) Abstract Operation

When the abstract operation NewModuleEnvironment is called with a
Lexical Environment argument E the following steps are performed:

1.  Let env be a new Lexical Environment.

2.  Let envRec be a new module environment record containing no
    bindings.

3.  Set env’s environment record to be envRec.

4.  Set the outer lexical environment reference of env to E.

5.  Return env.


Code Realms

Before it is evaluated, all ECMAScript code must be associated with a
Realm. Conceptually, a realm consists of a set of intrinsic objects,
an ECMAScript global environment, all of the ECMAScript code that is
loaded within the scope of that global environment, and other associated
state and resources.

A Realm is specified as a Record with the fields specified in Table 22:

Table 22 — Realm Record Fields

  ----------------- ---------------------------------------------------------------------------- --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  _FIELD NAME_      VALUE                                                                      MEANING
  [[intrinsics]]    A record whose field names are intrinsic keys and whose values are objects   These are the intrinsic values used by code associated with this Realm
  [[globalThis]]    An object                                                                    The global object for this Realm
  [[globalEnv]]     An ECMAScript environment                                                    The global environment for this Realm
                                                                                                 
                                                                                                 
                                                                                                 
                                                                                                 
  [[templateMap]]   A List of Record{ [[strings]]: List, [[array]]: Object}.                     Template objects are canonicalized separately for each Realm using its [[templateMap]]. Each [[strings]] value is a List containing in source code order the raw string values of a TemplateLiteral that has been evaluated. The associated [[array]] value is the corresponding template object that is passed to a tag function.
  [[modules]]       A List of ModuleRecords.                                                     An initially empty List containing the ModuleRecord for each module that has been loaded by this Realm.
                                                                                                 
  ----------------- ---------------------------------------------------------------------------- --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

CreateRealm ( ) Abstract Operation

The abstract operation CreateRealm with no arguments performs the
following steps:

1.  Let realmRec be a new Record.

2.  Let intrinsics be CreateIntrinsics(realmRec).

3.  4.  5.  6.  7.  8.  Set realmRec.[[globalThis]] to UNDEFINED.

9.  10. Set realmRec.[[globalEnv]] to UNDEFINED.

11. Set realmRec.[[templateMap]] to a new empty List.

12. Set realmRec.[[modules]] to a new empty List.

13. Return realmRec.

CreateIntrinsics ( realmRec ) Abstract Operation

When the abstract operation CreateIntrinsics with argument realmRec
performs the following steps:

1.  Let intrinsics be a new Record.

2.  Set realmRec.[[intrinsics]] to intrinsics.

3.  Let objProto be ObjectCreate(NULL).

4.  Set intrinsics.[[%ObjectPrototype%]] to objProto.

5.  Let throwerSteps be the algorithm steps of the %ThrowTypeError%
    function (9.2.8.1).

6.  Let thrower be CreateBuiltinFunction(realmRec, throwerSteps,
    NULL).

7.  8.  9.  10. 11. 12. Set intrinsics.[[%ThrowTypeError%]] to
    thrower.

13. Let noSteps be an empty sequence of algorithm steps.

14. Let funcProto be the CreateBuiltinFunction(realmRec, noSteps,
    objProto).

15. Set intrinsics.[[%FunctionPrototype%]] to funcProto.

16. Call the [[SetPrototypeOf]] internal method of thrower with
    argument funcProto.

17. Perform AddRestrictedFunctionProperties(funcProto, realmRec).

18. Set fields of intrinsics with the values listed in Table 7 that
    have not already been handled above. The field names are the names
    listed in column one of the table. The value of each field is a new
    object value fully and recursively populated with property values as
    defined by the specification of each object in clauses 18-26. All
    object property values are newly created object values. All values
    that are built-in function objects are created by performing
    CreateBuiltinFunction(realmRec, <steps>, <prototype>, <slots>)
    where <steps> is the definition of that function provided by this
    specification, <prototype> is the specified value of the function’s
    [[Prototype]] internal slot and <slots> is a list of the names, if
    any, of the functions specified internal slots. The creation of the
    intrinsics and their properties must be ordered to avoid any
    dependencies upon objects that have not yet been created.

19. Return intrinsics.

SetRealmGlobalObj ( realmRec, globalObj ) Abstract Operation

The abstract operation SetRealmGlobalObj with arguments realmRec and
globalObj performs the following steps:

1.  If globalObj is UNDEFINED, then

    a.  Let intrinsics be realmRec.[[intrinsics]].

    b.  Let globalObj be
        ObjectCreate(intrinsics.[[%ObjectPrototype%]]).

2.  Assert: Type(globalObj) is Object.

3.  Set realmRec.[[globalThis]] to newGlobal.

4.  Let newGlobalEnv be NewGlobalEnvironment(newGlobal).

5.  Set realmRec.[[globalEnv]] to newGlobalEnv.

6.  Return realmRec.

SetDefaultGlobalBindings ( realmRec ) Abstract Operation

The abstract operation SetDefaultGlobalBindings with argument realmRec
performs the following steps:

1.  Let global be realmRec.[[globalThis]].

2.  For each property of the Global Object specified in clause 18, do

    a.  Let name be the string value of the property name.

    b.  Let desc be the fully populated data property descriptor for
        the property containing the specified attributes for the
        property. For properties whose values are functions, the value
        of the [[Value]] attribute is the corresponding intrinsic
        function object from realmRec.

    c.  Let status be DefinePropertyOrThrow(global, name, desc).

    d.  ReturnIfAbrupt(status).

3.  Return global.


Execution Contexts

An _execution context_ is a specification device that is used to track
the runtime evaluation of code by an ECMAScript implementation. At any
point in time, there is at most one execution context that is actually
executing code. This is known as the running execution context. A
stack is used to track execution contexts. The running execution context
is always the top element of this stack. A new execution context is
created whenever control is transferred from the executable code
associated with the currently running execution context to executable
code that is not associated with that execution context. The newly
created execution context is pushed onto the stack and becomes the
running execution context.

An execution context contains whatever implementation specific state is
necessary to track the execution progress of its associated code. Each
execution context has at least the state components listed in Table 23.

Table 23 —State Components for All Execution Contexts

  COMPONENT             PURPOSE
  ----------------------- ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  code evaluation state   Any state needed to perform, suspend, and resume evaluation of the code associated with this execution context.
  Function                If this execution context is evaluating the code of a function object, then the value of this component is that function object. If the context is evaluating the code of a Script or Module, the value is NULL.
  Realm                   The Realm from which associated code accesses ECMAScript resources.

Evaluation of code by the running execution context may be suspended at
various points defined within this specification. Once the running
execution context has been suspended a different execution context may
become the running execution context and commence evaluating its code.
At some later time a suspended execution context may again become the
running execution context and continue evaluating its code at the point
where it had previously been suspended. Transition of the running
execution context status among execution contexts usually occurs in
stack-like last-in/first-out manner. However, some ECMAScript features
require non-LIFO transitions of the running execution context.

The value of the Realm component of the running execution context is
also called the _current Realm_. The value of the Function component of
the running execution context is also called the _active function_
object.

Execution contexts for ECMAScript code have the additional state
components listed in Table 24.

Table 24 — Additional State Components for ECMAScript Code Execution
Contexts

  COMPONENT           PURPOSE
  --------------------- -------------------------------------------------------------------------------------------------------------------------------------------
  LexicalEnvironment    Identifies the Lexical Environment used to resolve identifier references made by code within this execution context.
  VariableEnvironment   Identifies the Lexical Environment whose environment record holds bindings created by VariableStatements within this execution context.

The LexicalEnvironment and VariableEnvironment components of an
execution context are always Lexical Environments. When an execution
context is created its LexicalEnvironment and VariableEnvironment
components initially have the same value.

Execution contexts representing the evaluation of generator objects have
the additional state components listed in Table 25.

Table 25 — Additional State Components for Generator Execution Contexts

  COMPONENT   PURPOSE
  ------------- ----------------------------------------------------------------
  Generator     The GeneratorObject that this execution context is evaluating.

In most situations only the running execution context (the top of the
execution context stack) is directly manipulated by algorithms within
this specification. Hence when the terms “LexicalEnvironment”, and
“VariableEnvironment” are used without qualification they are in
reference to those components of the running execution context.

An execution context is purely a specification mechanism and need not
correspond to any particular artefact of an ECMAScript implementation.
It is impossible for ECMAScript code to directly access or observe an
execution context.

ResolveBinding ( name ) Abstract Operation

The ResolveBinding abstract operation is used to determine the binding
of name passed as a string value using the LexicalEnvironment of the
running execution context. During execution of ECMAScript code,
ResolveBinding is performed using the following algorithm:

1.  Let env be the running execution context’s LexicalEnvironment.

2.  If the syntactic production that is being evaluated is contained in
    strict mode code, let strict be TRUE, else let strict be FALSE.

3.  Return GetIdentifierReference(env, name, strict ).

NOTE The result of ResolveBinding is always a Reference value with its
referenced name component equal to the name argument.

GetThisEnvironment ( ) Abstract Operation

The abstract operation GetThisEnvironment finds the environment record
that currently supplies the binding of the keyword THIS.
GetThisEnvironment performs the following steps:

1.  Let lex be the running execution context’s LexicalEnvironment.

2.  Repeat

    a.  Let envRec be lex’s environment record.

    b.  Let exists be the result of calling the HasThisBinding
        concrete method of envRec.

    c.  If exists is TRUE, return envRec.

    d.  Let outer be the value of lex’s outer environment reference.

    e.  Let lex be outer.

NOTE The loop in step 2 will always terminate because the list of
environments always ends with the global environment which has a THIS
binding.

ResolveThisBinding ( ) Abstract Operation

The abstract operation ResolveThisBinding determines the binding of the
keyword THIS using the LexicalEnvironment of the running execution
context. ResolveThisBinding performs the following steps:

1.  Let envRec be GetThisEnvironment( ).

2.  Return the result of calling the GetThisBinding concrete method of
    envRec.

GetNewTarget ( ) Abstract Operation

The abstract operation GetNewTarget determines the NewTarget value using
the LexicalEnvironment of the running execution context. GetNewTarget
performs the following steps:

1.  Let envRec be GetThisEnvironment( ).

2.  Assert: envRec has a [[NewTarget]] field.

3.  Return envRec.[[NewTarget]].

GetGlobalObject ( ) Abstract Operation

The abstract operation GetGlobalObject returns the global object used by
the currently running execution context. GetGlobalObject performs the
following steps:

1.  Let ctx be the running execution context.

2.  3.  Let currentRealm be ctx’s Realm.

4.  Return currentRealm.[[globalThis]].

1.  2.  3.  


Jobs and Job Queues

A Job is an abstract operation that initiates an ECMAScript computation
when no other ECMAScript computation is currently in progress. A Job
abstract operation may be defined to accept an arbitrary set of job
parameters.

Execution of a Job can be initiated only when there is no running
execution context and the execution context stack is empty. A PendingJob
is a request for the future execution of a Job. A PendingJob is an
internal Record whose fields are specified in Table 26. Once execution
of a Job is initiated, the Job always executes to completion. No other
Job may be initiated until the currently running Job completes. However,
the currently running Job or external events may cause the enqueuing of
additional PendingJobs that may be initiated sometime after completion
of the currently running Job.

Table 26 — PendingJob Record Fields

  ----------------- -------------------------------------- ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  _FIELD NAME_      VALUE                                MEANING
  [[Job]]           The name of a Job abstract operation   This is the abstract operation that is performed when execution of this PendingJob is initiated. Jobs are abstract operations that use NextJob rather than Return to indicate that they have completed.
  [[Arguments]]     A List                                 The List of argument values that are to be passed to [[Job]] when it is activated.
  [[Realm]]         A Realm Record                         The Realm for the initial execution context when this Pending Job is initiated.
  [[HostDefined]]   Any, default value is UNDEFINED.       Field reserved for use by host environments that need to associate additional information with a pending Job.
  ----------------- -------------------------------------- ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

A Job Queue is a FIFO queue of PendingJob records. Each Job Queue has a
name and the full set of available Job Queues are defined by an
ECMAScript implementation. Every ECMAScript implementation has at least
the Job Queues defined in Table 27.

Table 27 — Required Job Queues

  NAME        PURPOSE
  ------------- -----------------------------------------------------------------------------------------------------
  ScriptJobs    Jobs that validate and evaluate ECMAScript Script and Module code units. See clauses 10 and 15.
  PromiseJobs   Jobs that are responses to the settlement of a Promise (see 25.4).

A request for the future execution of a Job is made by enqueueing, on a
Job Queue, a PendingJob record that includes a Job abstract operation
name and any necessary argument values. When there is no running
execution context and the execution context stack is empty, the
ECMAScript implementation removes the first PendingJob from a Job Queue
and uses the information contained in it to create an execution context
and starts execution of the associated Job abstract operation.

The PendingJob records from a single Job Queue are always initiated in
FIFO order. This specification does not define the order in which
multiple Job Queues are serviced. An ECMAScript implementation may
interweave the FIFO evaluation of the PendingJob records of a Job Queue
with the evaluation of the PendingJob records of one or more other Job
Queues. An implementation must define what occurs when there are no
running execution context and all Job Queues are empty.

NOTE Typically an ECMAScript implementation will have its Job Queues
pre-initialized with at least one PendingJob and one of those Jobs will
be the first to be executed. An implementation might choose to free all
resources and terminate if the current Job completes and all Job Queues
are empty. Alternatively, it might choose to wait for a some
implementation specific agent or mechanism to enqueue new PendingJob
requests.

The following abstract operations are used to create and manage Jobs and
Job Queues:

EnqueueJob ( queueName, job, arguments) Abstract Operation

The EnqueueJob abstract operation requires three arguments: queueName,
job, and arguments. It performs the following steps:

1.  Assert: Type(queueName) is String and its value is the name of a
    Job Queue recognized by this implementation.

2.  Assert: job is the name of a Job.

3.  Assert: arguments is a List that has the same number of elements
    as the number of parameters required by job.

4.  Let callerContext be the running execution context.

5.  Let callerRealm be callerContext’s Realm.

6.  Let pending be PendingJob{ [[Job]]: job, [[Arguments]]:
    arguments, [[Realm]]: callerRealm, [[HostDefined]]: UNDEFINED }.

7.  Perform any implementation or host environment defined processing of
    pending. This may including modify the [[HostDefined]] field or
    any other field of pending.

8.  Add pending at the back of the Job Queue named by queueName.

9.  Return NormalCompletion(empty).

NextJob result 

An algorithm step such as:

1.  NextJob result.

is used in Job abstract operations in place of:

1.  Return result.

Job abstract operations must not contain a Return step or a
ReturnIfAbrupt step. The NextJob result operation is equivalent to the
following steps:

1.  If result is an abrupt completion, perform implementation defined
    unhandled exception processing.

2.  Suspend the running execution context and remove it from the
    execution context stack.

3.  Assert: The execution context stack is now empty.

4.  Let nextQueue be a non-empty Job Queue chosen in an implementation
    defined manner. If all Job Queues are empty, the result is
    implementation defined.

5.  Let nextPending be the PendingJob record at the front of
    nextQueue. Remove that record from nextQueue.

6.  Let newContext be a new execution context.

7.  Set newContext’s Realm to nextPending.[[Realm]].

8.  Push newContext onto the execution context stack; newContext is
    now the running execution context.

9.  Perform any implementation or host environment defined job
    initialization using nextPending.

10. Perform the abstract operation named by nextPending.[[Job]] using
    the elements of nextPending.[[Arguments]] as its arguments.


Initialization

An ECMAScript implementation performs the following steps prior to the
execution of any Jobs or the evaluation of any ECMAScript code:

1.  Let realm be CreateRealm().

2.  Let newContext be a new execution context.

3.  Set the Function of newContext to NULL.

4.  Set the Realm of newContext to realm.

5.  Push newContext onto the execution context stack; newContext is
    now the running execution context.

6.  Let status be InitializeFirstRealm(realm).

7.  If status is an abrupt completion, then

    a.  Assert: The first realm could not be created.

    b.  Terminate ECMAScript execution.

8.  In an implementation dependent manner, obtain the sourceCodeId
    strings (see 8.6.1) for zero or more ECMAScript scripts and/or
    ECMAScript modules. For each such sourceCodeId do,

    a.  If the sourceCodeId identifies the source code of a script,
        then

        i.  Let source be the SourceCharacter sequence of the
            script.

        ii. EnqueueJob("ScriptJobs", ScriptEvaluationJob,
            «sourceCodeId»).

    b.  Else the sourceCodeId identifies the source code of a module,

        i.  ii. EnqueueJob("ScriptJobs", ModuleEvaluationJob,
            «‍sourceCodeId »).

9.  NextJob NormalCompletion(UNDEFINED).

InitializeFirstRealm ( realm ) Abstract Operation

The abstract operation InitializeFirstRealm with parameter realm
performs the following steps:

1.  Let intrinsics be CreateIntrinsics(realm).

2.  If this implementation requires use of an exotic object to serve as
    realm’s global object, let global be such an object created in
    an implementation defined manner. Otherwise, let global be
    UNDEFINED indicating that an ordinary object should be created as
    the global object.

3.  Perform SetRealmGlobalObject(realm, global).

4.  Let globalObj be SetDefaultGlobalBindings(realm).

5.  ReturnIfAbrupt(globalObj).

6.  Create any implementation defined global object properties on
    globalObj.

7.  Return NormalCompletion(UNDEFINED).


Host Provided Services

Host provided services are abstract operations used by this
specification to access resources of the host environment within which
an ECMAScript implementation is operating. The specific semantics must
be defined by the ECMAScript implementation.

HostGetSource (sourceCodeId) Abstract Operation

A sourceCodeId is a host defined string value that identifies a specific
source code resource. The abstract operation HostGetSource retrieves the
SourceCharacter sequence (see clause 10) that is identified by the
String sourceCodeId. The returned value is the SourceCharacter
sequence. If sourceCodeId does not identifiy a SourceCharacter
sequence or if the SourceCharacter sequence cannot be retrieved an
abrupt completion value is returned.

The argument value passed to this operation is a sourceCodeId that was
previously either directly provided by the host or returned from the
HostNormalizeModuleName abstract operation.

HostNormalizeModuleName ( unnormalizedName, referrerId) Abstract Operation

The abstract operation HostNormalizeModuleName translates an
unnormalized module name string to a host defined sourceCodeId that can
be used to retrieve the source code for the named module.
unnormalizedName is a String and is the name to be normalized.
referrerId is a String.and is the host supplied sourceCodeId of the
module that referenced unnormalizedName. The returned value is either
a String or UNDEFINED. If UNDEFINED is returned, the name cannot be
normalized to a sourceCodeId that is usable to retrieve source code.

A host must supply a stable mapping of unnormalized names to
sourceCodeIds. Multiple successive calls to HostNormalizeModuleName,
with the same arguments, must return the same String value.

Many different unnormalized names may be mapped to the same
sourceCodeId. The actual normalization mapping is implementation defined
but typically includes processes such as alphabetic case normalization
and expansion of relative and abbreviated file system paths.

NOTE The referrerId argument is intended to support relative naming
syntax that might be used within an unnormalized name. The actual
relative naming semantic, if any, are host defined.



ORDINARY AND EXOTIC OBJECTS BEHAVIOURS 


Ordinary Object Internal Methods and Internal Slots

All ordinary objects have an internal slot called [[Prototype]]. The
value of this internal slot is either NULL or an object and is used for
implementing inheritance. Data properties of the [[Prototype]] object
are inherited (are visible as properties of the child object) for the
purposes of get access, but not for set access. Accessor properties are
inherited for both get access and set access.

Every ordinary object has a Boolean-valued [[Extensible]] internal slot
that controls whether or not properties may be added to the object. If
the value of the [[Extensible]] internal slot is FALSE then additional
properties may not be added to the object. In addition, if
[[Extensible]] is FALSE the value of the [[Prototype]] internal slot of
the object may not be modified. Once the value of an object’s
[[Extensible]] internal slot has been set to FALSE it may not be
subsequently changed to TRUE.

In the following algorithm descriptions, assume O is an ordinary
object, P is a property key value, V is any ECMAScript language
value, and Desc is a Property Descriptor record.

[[GetPrototypeOf]] ( )

When the [[GetPrototypeOf]] internal method of O is called the
following steps are taken:

1.  Return the value of the [[Prototype]] internal slot of O.

[[SetPrototypeOf]] (V)

When the [[SetPrototypeOf]] internal method of O is called with
argument V the following steps are taken:

1.  Assert: Either Type(V) is Object or Type(V) is Null.

2.  Let extensible be the value of the [[Extensible]] internal slot of
    O.

3.  Let current be the value of the [[Prototype]] internal slot of
    O.

4.  If SameValue(V, current), return TRUE.

5.  If extensible is FALSE, return FALSE.

6.  If V is not NULL, then

    a.  Let p be V.

    b.  Repeat, while p is not NULL

        i.  If SameValue(p, O) is TRUE, return FALSE.

        ii. Let nextp be the result of calling the [[GetPrototypeOf]]
            internal method of p with no arguments.

        iii. ReturnIfAbrupt(nextp).

        iv. Let p be nextp.

7.  Let extensible be the value of the [[Extensible]] internal slot of
    O.

8.  If extensible is FALSE, then

    a.  Let current2 be the value of the [[Prototype]] internal slot
        of O.

    b.  If SameValue(V, current2) is TRUE, return TRUE.

    c.  Return FALSE.

9.  Set the value of the [[Prototype]] internal slot of O to V.

10. Return TRUE.

[[IsExtensible]] ( )

When the [[IsExtensible]] internal method of O is called the following
steps are taken:

1.  Return the value of the [[Extensible]] internal slot of O.

[[PreventExtensions]] ( )

When the [[PreventExtensions]] internal method of O is called the
following steps are taken:

1.  Set the value of the [[Extensible]] internal slot of O to FALSE.

2.  Return TRUE.

[[GetOwnProperty]] (P)

When the [[GetOwnProperty]] internal method of O is called with
property key P, the following steps are taken:

1.  Return OrdinaryGetOwnProperty(O, P).

OrdinaryGetOwnProperty (O, P)

When the abstract operation OrdinaryGetOwnProperty is called with Object
O and with property key P, the following steps are taken:

1.  Assert: IsPropertyKey(P) is TRUE.

2.  If O does not have an own property with key P, return UNDEFINED.

3.  Let D be a newly created Property Descriptor with no fields.

4.  Let X be O’s own property whose key is P.

5.  If X is a data property, then

    a.  Set D.[[Value]] to the value of X’s [[Value]] attribute.

    b.  Set D.[[Writable]] to the value of X’s [[Writable]]
        attribute

6.  Else X is an accessor property, so

    a.  Set D.[[Get]] to the value of X’s [[Get]] attribute.

    b.  Set D.[[Set]] to the value of X’s [[Set]] attribute.

7.  Set D.[[Enumerable]] to the value of X’s [[Enumerable]]
    attribute.

8.  Set D.[[Configurable]] to the value of X’s [[Configurable]]
    attribute.

9.  Return D.

[[DefineOwnProperty]] (P, Desc)

When the [[DefineOwnProperty]] internal method of O is called with
property key P and Property Descriptor Desc, the following steps are
taken:

1.  Return OrdinaryDefineOwnProperty(O, P, Desc).

OrdinaryDefineOwnProperty (O, P, Desc)

When the abstract operation OrdinaryDefineOwnProperty is called with
Object O, property key P, and Property Descriptor Desc the
following steps are taken:

1.  Let current be the result of calling the [[GetOwnProperty]]
    internal method of O with argument P.

2.  ReturnIfAbrupt(current).

3.  Let extensible be the value of the [[Extensible]] internal slot of
    O.

4.  Return ValidateAndApplyPropertyDescriptor(O, P, extensible,
    Desc, current).

IsCompatiblePropertyDescriptor (Extensible, Desc, Current)

When the abstract operation IsCompatiblePropertyDescriptor is called
with Boolean value Extensible, and Property Descriptors Desc, and
Current the following steps are taken:

1.  Return ValidateAndApplyPropertyDescriptor(UNDEFINED, UNDEFINED,
    Extensible, Desc, Current).

ValidateAndApplyPropertyDescriptor (O, P, extensible, Desc, current)

When the abstract operation ValidateAndApplyPropertyDescriptor is called
with Object O, property key P, Boolean value extensible, and
Property Descriptors Desc, and current the following steps are
taken:

This algorithm contains steps that test various fields of the Property
Descriptor Desc for specific values. The fields that are tested in
this manner need not actually exist in Desc. If a field is absent then
its value is considered to be FALSE.

NOTE If UNDEFINED is passed as the O argument only validation is
performed and no object updates are performed.

1.  Assert: If O is not UNDEFINED then P is a valid property key.

2.  If current is UNDEFINED, then

    a.  If extensible is FALSE, return FALSE.

    b.  Assert: extensible is TRUE.

    c.  If IsGenericDescriptor(Desc) or IsDataDescriptor(Desc) is
        TRUE, then

        i.  If O is not UNDEFINED, create an own data property named
            P of object O whose [[Value]], [[Writable]],
            [[Enumerable]] and [[Configurable]] attribute values are
            described by Desc. If the value of an attribute field of
            Desc is absent, the attribute of the newly created
            property is set to its default value.

    d.  Else Desc must be an accessor Property Descriptor,

        i.  If O is not UNDEFINED, create an own accessor property
            named P of object O whose [[Get]], [[Set]],
            [[Enumerable]] and [[Configurable]] attribute values are
            described by Desc. If the value of an attribute field of
            Desc is absent, the attribute of the newly created
            property is set to its default value.

    e.  Return TRUE.

3.  Return TRUE, if every field in Desc is absent.

4.  Return TRUE, if every field in Desc also occurs in current and
    the value of every field in Desc is the same value as the
    corresponding field in current when compared using the SameValue
    algorithm.

5.  If the [[Configurable]] field of current is FALSE, then

    a.  Return FALSE, if the [[Configurable]] field of Desc is TRUE.

    b.  Return FALSE, if the [[Enumerable]] field of Desc is present
        and the [[Enumerable]] fields of current and Desc are the
        Boolean negation of each other.

6.  If IsGenericDescriptor(Desc) is TRUE, no further validation is
    required.

7.  Else if IsDataDescriptor(current) and IsDataDescriptor(Desc)
    have different results, then

    a.  Return FALSE, if the [[Configurable]] field of current is
        FALSE.

    b.  c.  If IsDataDescriptor(current) is TRUE, then

        i.  If O is not UNDEFINED, convert the property named P of
            object O from a data property to an accessor property.
            Preserve the existing values of the converted property’s
            [[Configurable]] and [[Enumerable]] attributes and set the
            rest of the property’s attributes to their default values.

    d.  Else,

        i.  If O is not UNDEFINED, convert the property named P of
            object O from an accessor property to a data property.
            Preserve the existing values of the converted property’s
            [[Configurable]] and [[Enumerable]] attributes and set the
            rest of the property’s attributes to their default values.

8.  Else if IsDataDescriptor(current) and IsDataDescriptor(Desc) are
    both TRUE, then

    a.  If the [[Configurable]] field of current is FALSE, then

        i.  Return FALSE, if the [[Writable]] field of current is
            FALSE and the [[Writable]] field of Desc is TRUE.

        ii. If the [[Writable]] field of current is FALSE, then

            1.  Return FALSE, if the [[Value]] field of Desc is
                present and SameValue(Desc.[[Value]],
                current.[[Value]]) is FALSE.

            2.  

    b.  Else the [[Configurable]] field of current is TRUE, so any
        change is acceptable.

9.  Else IsAccessorDescriptor(current) and
    IsAccessorDescriptor(Desc) are both TRUE,

    a.  If the [[Configurable]] field of current is FALSE, then

        i.  Return FALSE, if the [[Set]] field of Desc is present and
            SameValue(Desc.[[Set]], current.[[Set]]) is FALSE.

        ii. Return FALSE, if the [[Get]] field of Desc is present and
            SameValue(Desc.[[Get]], current.[[Get]]) is FALSE.

10. If O is not UNDEFINED, then

    a.  For each field of Desc that is present, set the corresponding
        attribute of the property named P of object O to the value
        of the field.

11. Return TRUE.

NOTE Step 8.b allows any field of Desc to be different from the
corresponding field of current if current’s [[Configurable]] field is
TRUE. This even permits changing the [[Value]] of a property whose
[[Writable]] attribute is FALSE. This is allowed because a TRUE
[[Configurable]] attribute would permit an equivalent sequence of calls
where [[Writable]] is first set to TRUE, a new [[Value]] is set, and
then [[Writable]] is set to FALSE.

 [[HasProperty]](P)

When the [[HasProperty]] internal method of O is called with property
key P, the following steps are taken:

1.  Return OrdinaryHasProperty(O, P).

OrdinaryHasProperty (O, P)

When the abstract operation OrdinaryHasProperty is called with Object
O and with property key P, the following steps are taken:

1.  Assert: IsPropertyKey(P) is TRUE.

2.  Let hasOwn be OrdinaryGetOwnProperty(O, P).

3.  ReturnIfAbrupt(hasOwn).

4.  If hasOwn is not UNDEFINED, return TRUE.

5.  Let parent be the result of calling the [[GetPrototypeOf]]
    internal method of O.

6.  ReturnIfAbrupt(parent).

7.  If parent is not NULL, then

    a.  Return the result of calling the [[HasProperty]] internal method
        of parent with argument P.

8.  Return FALSE.

[[Get]] (P, Receiver)

When the [[Get]] internal method of O is called with property key P
and ECMAScript language value Receiver the following steps are taken:

1.  Assert: IsPropertyKey(P) is TRUE.

2.  Let desc be the result of calling the [[GetOwnProperty]] internal
    method of O with argument P.

3.  ReturnIfAbrupt(desc).

4.  If desc is UNDEFINED, then

    a.  Let parent be the result of calling the [[GetPrototypeOf]]
        internal method of O.

    b.  ReturnIfAbrupt(parent).

    c.  If parent is NULL, return UNDEFINED.

    d.  Return the result of calling the [[Get]] internal method of
        parent with arguments P and Receiver.

5.  If IsDataDescriptor(desc) is TRUE, return desc.[[Value]].

6.  Otherwise, IsAccessorDescriptor(desc) must be TRUE so, let
    getter be desc.[[Get]].

7.  If getter is UNDEFINED, return UNDEFINED.

8.  Return Call(getter, Receiver).

[[Set]] ( P, V, Receiver)

When the [[Set]] internal method of O is called with property key P,
value V, and ECMAScript language value Receiver, the following steps
are taken:

1.  Assert: IsPropertyKey(P) is TRUE.

2.  Let ownDesc be the result of calling the [[GetOwnProperty]]
    internal method of O with argument P.

3.  ReturnIfAbrupt(ownDesc).

4.  If ownDesc is UNDEFINED, then

    a.  Let parent be the result of calling the [[GetPrototypeOf]]
        internal method of O.

    b.  ReturnIfAbrupt(parent).

    c.  If parent is not NULL, then

    d.  i.  Return the result of calling the [[Set]] internal method of
            parent with arguments P, V, and Receiver.

    e.  Else,

        i.  Let ownDesc be the PropertyDescriptor{[[Value]]:
            UNDEFINED, [[Writable]]: TRUE, [[Enumerable]]: TRUE,
            [[Configurable]]: TRUE}.

5.  If IsDataDescriptor(ownDesc) is TRUE, then

    a.  If ownDesc.[[Writable]] is FALSE, return FALSE.

    b.  If Type(Receiver) is not Object, return FALSE.

    c.  Let existingDescriptor be the result of calling the
        [[GetOwnProperty]] internal method of Receiver with argument
        P.

    d.  ReturnIfAbrupt(existingDescriptor).

    e.  If existingDescriptor is not UNDEFINED, then

        i.  Let valueDesc be the PropertyDescriptor{[[Value]]: V}.

        ii. Return the result of calling the [[DefineOwnProperty]]
            internal method of Receiver with arguments P and
            valueDesc.

    f.  Else Receiver does not currently have a property P,

        i.  Return CreateDataProperty(Receiver, P, V).

6.  Assert: IsAccessorDescriptor(ownDesc) is TRUE.

7.  Let setter be ownDesc.[[Set]].

8.  If setter is UNDEFINED, return FALSE.

9.  Let setterResult be Call(setter, Receiver, «V»).

10. ReturnIfAbrupt(setterResult).

11. Return TRUE.

 [[Delete]] (P)

When the [[Delete]] internal method of O is called with property key
P the following steps are taken:

1.  Assert: IsPropertyKey(P) is TRUE.

2.  Let desc be the result of calling the [[GetOwnProperty]] internal
    method of O with argument P.

3.  ReturnIfAbrupt(desc).

4.  If desc is UNDEFINED, return TRUE.

5.  If desc.[[Configurable]] is TRUE, then

    a.  Remove the own property with name P from O.

    b.  Return TRUE.

6.  Return FALSE.

[[Enumerate]] ()

When the [[Enumerate]] internal method of O is called the following
steps are taken:

1.  Return an Iterator object (25.1.1.2) whose NEXT method iterates over
    all the String-valued keys of enumerable properties of O. The
    Iterator object must inherit from %IteratorPrototype% (25.1.2). The
    mechanics and order of enumerating the properties is not specified
    but must conform to the rules specified below.

2.  

The iterator’s NEXT method processes object properties to determine
whether the property key should be returned as an iterator value.
Processed properties do not include properties whose property key is a
Symbol. Properties of the object being enumerated may be deleted during
enumeration. A property that is deleted before it is processed by the
iterator’s NEXT method is ignored. If new properties are added to the
object being enumerated during enumeration, the newly added properties
are not guaranteed to be processed in the active enumeration. A property
name will be returned by the iterator’s NEXT method at most once in any
enumeration.

Enumerating the properties of an object includes processing properties
of its prototype, and the prototype of the prototype, and so on,
recursively; but a property of a prototype is not processed if it has
the same name as a property that has already been processed by the
iterator’s NEXT method. The values of [[Enumerable]] attributes are not
considered when determining if a property of a prototype object has
already been processed.

The following is an informative definition of an ECMAScript generator
function that conforms to these rules:

function* enumerate(obj) {

if (Object(obj)!== obj) return undefined;

let visited = new Set;

while (obj !== null) {

for (let name of Object.getOwnPropertyNames(obj)) {

//any new properties added to obj by visitor are ignored.

if (!visited.has(name)) {

let desc = Object.getOwnPropertyDescriptor(obj,name);

if (desc) {

visited.add(name);

if (desc.enumerable) yield name;

}

}

}

obj = Object.getPrototypeOf(obj);

}

}

1.  

2.  

3.  4.  5.  

    1.  

6.  7.  a.  i.  ii. iii. iv. 

8.  9.  

[[OwnPropertyKeys]] ( )

When the [[OwnPropertyKeys]] internal method of O is called the
following steps are taken:

1.  Let keys be a new empty List.

2.  For each own property key P of O that is an integer index, in
    ascending numeric index order

    a.  Add P as the last element of keys.

3.  For each own property key P of O that is a String but is not an
    integer index, in property creation order

    a.  Add P as the last element of keys.

4.  For each own property key P of O that is a Symbol, in property
    creation order

    a.  Add P as the last element of keys.

5.  Return keys.

ObjectCreate(proto, internalSlotsList) Abstract Operation

The abstract operation ObjectCreate with argument proto (an object or
null) is used to specify the runtime creation of new ordinary objects.
The optional argument internalSlotsList is a List of the names of
additional internal slots that must be defined as part of the object. If
the list is not provided, an empty List is used. This abstract operation
performs the following steps:

1.  If internalSlotsList was not provided, let internalSlotsList be
    an empty List.

2.  Let obj be a newly created object with an internal slot for each
    name in internalSlotsList.

3.  Set obj’s essential internal methods to the default ordinary
    object definitions specified in 9.1.

4.  Set the [[Prototype]] internal slot of obj to proto.

5.  Set the [[Extensible]] internal slot of obj to TRUE.

6.  Return obj.

OrdinaryCreateFromConstructor ( constructor, intrinsicDefaultProto, internalSlotsList )

The abstract operation OrdinaryCreateFromConstructor creates an ordinary
object whose [[Prototype]] value is retrieved from a constructor’s
PROTOTYPE property, if it exists. Otherwise the intrinsic named by
intrinsicDefaultProto is used for [[Prototype]]. The optional
internalSlotsList is a List of the names of additional internal slots
that must be defined as part of the object. If the list is not provided,
an empty List is used. This abstract operation performs the following
steps:

1.  Assert: intrinsicDefaultProto is a string value that is this
    specification’s name of an intrinsic object. The corresponding
    object must be an intrinsic that is intended to be used as the
    [[Prototype]] value of an object.

2.  Let proto be GetPrototypeFromConstructor(constructor,
    intrinsicDefaultProto).

3.  ReturnIfAbrupt(proto).

4.  Return ObjectCreate(proto, internalSlotsList).

GetPrototypeFromConstructor ( constructor, intrinsicDefaultProto )

The abstract operation GetPrototypeFromConstructor determines the
[[Prototype]] value that should be used to create an object
corresponding to a specific constructor. The value is retrieved from the
constructor’s PROTOTYPE property, if it exists. Otherwise the intrinsic
named by intrinsicDefaultProto is used for [[Prototype]]. This
abstract operation performs the following steps:

1.  Assert: intrinsicDefaultProto is a string value that is this
    specification’s name of an intrinsic object. The corresponding
    object must be an intrinsic that is intended to be used as the
    [[Prototype]] value of an object.

2.  Assert: IsConstructor (constructor) is TRUE.

3.  Let proto be Get(constructor, "PROTOTYPE").

4.  ReturnIfAbrupt(proto).

5.  If Type(proto) is not Object, then

    a.  Let realm be GetFunctionRealm(constructor).

    b.  Let proto be realm’s intrinsic object named
        intrinsicDefaultProto.

6.  Return proto.

NOTE If constructor does not supply a [[Prototype]] value, the default
value that is used is obtained from the Code Realm of the constructor
function rather than from the running execution context.


ECMAScript Function Objects

ECMAScript function objects encapsulate parameterized ECMAScript code
closed over a lexical environment and support the dynamic evaluation of
that code. An ECMAScript function object is an ordinary object and has
the same internal slots and (except as noted below) and the same
internal methods as other ordinary objects. The code of an ECMAScript
function object may be either strict mode code (10.2.1) or non-strict
mode code.

ECMAScript function objects have the additional internal slots listed in
Table 28.

ECMAScript function objects whose code is not strict mode code (10.2.1)
provide an alternative definition for the [[GetOwnProperty]] internal
method. This alternative prevents the value of strict mode function from
being revealed as the value of a function object property named
"CALLER". The alternative definition exist solely to preclude a
non-standard legacy feature of some ECMAScript implementations from
revealing information about strict mode callers. If an implementation
does not provide such a feature, it need not implement this alternative
internal method for ECMAScript function objects. ECMAScript function
objects are considered to be ordinary objects even though they may use
the alternative definition of [[GetOwnProperty]].

Table 28 — Internal Slots of ECMAScript Function Objects

  _INTERNAL SLOT_        TYPE                      DESCRIPTION
  ---------------------- --------------------------- --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  [[Environment]]        Lexical Environment         The Lexical Environment that the function was closed over. Used as the outer environment when evaluating the code of the function.
  [[FormalParameters]]   Parse Node                  The root parse node of the source code that defines the function’s formal parameter list.
  [[FunctionKind]]       String                      Either "NORMAL", "CLASSCONSTRUCTOR" or "GENERATOR".
  [[ECMAScriptCode]]     Parse Node                  The root parse node of the source code that defines the function’s body.
  [[ConstructorKind]]    String                      Either "BASE" or "DERIVED".
  [[Realm]]              Realm Record                The Code Realm in which the function was created and which provides any intrinsic objects that are accessed when evaluating the function.
  [[ThisMode]]           (lexical, strict, global)   Defines how THIS references are interpreted within the formal parameters and code body of the function. LEXICAL means that THIS refers to the THIS value of a lexically enclosing function. STRICT means that the THIS value is used exactly as provided by an invocation of the function. GLOBAL means that a THIS value of UNDEFINED is interpreted as a reference to the global object.
  [[Strict]]             Boolean                     TRUE if this is a strict mode function, FALSE if this is not a strict mode function.
  [[NeedsSuper]]         Boolean                     TRUE if this function uses SUPER.
  [[HomeObject]]         Object                      If the function uses SUPER, this is the object whose [[GetPrototypeOf]] provides the object where SUPER property lookups begin.
                                                     
                                                     

All ECMAScript function objects have the [[Call]] internal method
defined here. ECMAScript functions that are also constructors in
addition have the [[Construct]] internal method. ECMAScript function
objects whose code is not strict mode code have the [[GetOwnProperty]]
internal method defined here.

[[GetOwnProperty]] (P)

When the [[GetOwnProperty]] internal method of a non-strict ECMAScript
function object F is called with property key P, the following steps
are taken:

1.  Let v be OrdinaryGetOwnProperty(F, P).

2.  3.  If IsDataDescriptor(v) is TRUE, then

4.  a.  If P is "CALLER", then

        i.  Let callerValue be v.[[Value]].

        ii. If callerValue is an ECMAScript Function object, then

        iii. 1.  If callerValue’s [[Strict]] internal slot is TRUE,
                set v.[[Value]] to NULL.

5.  Return v.

If an implementation extends non-strict ECMAScript function objects with
a built-in CALLER own property then it must use this definition of
[[GetOwnProperty]]. If an implementation does not provide such an
extension, the ordinary object [[GetOwnProperty]] internal method must
be used.

1.  2.  3.  4.  5.  6.  7.  8.  9.  10. 11. 12. 13. 14. 

[[Call]] ( thisArgument, argumentsList) 

The [[Call]] internal method for an ECMAScript function object F is
called with parameters thisArgument and argumentsList, a List of
ECMAScript language values. The following steps are taken:

1.  Assert: F is an ECMAScript function object.

2.  If F’s [[FunctionKind]] internal slot is "CLASSCONSTRUCTOR", throw
    a TYPEERROR exception.

3.  Let callerContext be the running execution context.

4.  Let calleeContext be PrepareForOrdinaryCall(F, NULL).

5.  ReturnIfAbrupt(calleeContext).

6.  Let status be OrdinaryCallBindThis(F, calleeContext,
    thisArgument).

7.  If status is an abrupt completion, then

    a.  Remove calleeContext from the execution context stack and
        restore callerContext as the running execution context.

    b.  Return status.

8.  Let result be OrdinaryCallEvaluateBody(F, calleeContext,
    argumentsList).

9.  Remove calleeContext from the execution context stack and restore
    callerContext as the running execution context.

10. If result.[[type]] is return, return
    NormalCompletion(result.[[value]]).

11. ReturnIfAbrupt(result).

12. Return NormalCompletion(UNDEFINED).

NOTE When calleeContext is removed from the execution context stack in
step 8 it must not be destroyed if it is suspended and retained for
later resumption by an accessible generator object.

PrepareForOrdinaryCall( F, newTarget )

When the abstract operation PrepareForOrdinaryCall is called with
function object F and ECMAScript language value newTarget, the
following steps are taken:

1.  Assert: Type(newTarget) is Undefined or Object.

2.  3.  Let callerContext be the running execution context.

4.  If callerContext is not already suspended, Suspend
    callerContext.

5.  Let calleeContext be a new ECMAScript Code execution context.

6.  Set the Function of calleeContext to F.

7.  Let calleeRealm be the value of F’s [[Realm]] internal slot.

8.  Set the Realm of calleeContext to calleeRealm.

9.  10. 11. 12. a.  

13. a.  b.  i.  1.  

        ii. 1.  2.  

14. Let localEnv be NewFunctionEnvironment(F).

15. ReturnIfAbrupt(localEnv).

16. Let localER be localEnv’s environment record.

17. Set localER.[[NewTarget]] to newTarget.

18. NOTE Any exception objects produced by NewFunctionEnvironment are
    associated with callerReam.

19. Set the LexicalEnvironment of calleeContext to localEnv.

20. Set the VariableEnvironment of calleeContext to localEnv.

21. Push calleeContext onto the execution context stack;
    calleeContext is now the running execution context.

22. Return calleeContext.

OrdinaryCallBindThis ( F, calleeContext, thisArgument )

When the abstract operation OrdinaryCallBindThis is called with function
object F, execution context calleeContext, and ECMAScript value
thisArgument the following steps are taken:

1.  Let thisMode be the value of F’s [[ThisMode]] internal slot.

2.  3.  If thisMode is lexical, return NormalCompletion(UNDEFINED).

4.  Let calleeRealm be the value of F’s [[Realm]] internal slot.

5.  Let localEnv to be the LexicalEnvironment of calleeContext.

6.  7.  8.  If thisMode is strict, let thisValue be thisArgument.

9.  Else

    a.  if thisArgument is NULL or UNDEFINED, then

        i.  Let thisValue be calleeRealm.[[globalThis]].

    b.  Else

    c.  i.  ii. iii. iv. v.  Let thisValue be
            ToObject(thisArgument).

        vi. Assert: thisValue is not an abrupt completion.

        vii. NOTE ToObject produces wrapper objects using calleeRealm.

10. Let envRec be localEnv’s environment record.

11. Return the result of calling the BindThisValue concrete method of
    envRec with argument thisValue.

OrdinaryCallEvaluateBody ( F, calleeContext, argumentsList )

When the abstract operation OrdinaryCallEvaluateBody is called with
function object F, execution context calleeContext, and List
argumentsList the following steps are taken:

1.  Let localEnv be the LexicalEnvironment of calleeContext.

2.  Let status be the result of performing
    FunctionDeclarationInstantiation using the function F,
    argumentsList , and localEnv as described in 9.2.13.

3.  4.  ReturnIfAbrupt(status)

5.  a.  b.  

6.  Return the result of EvaluateBody of the production that is the
    value of F's [[ECMAScriptCode]] internal slot passing F as the
    argument.

7.  8.  9.  

[[Construct]] ( argumentsList, newTarget)

The [[Construct]] internal method for an ECMAScript Function object F
is called with parameters argumentsList and newTarget.
argumentsList is a possibly empty List of ECMAScript language values.
The following steps are taken:

1.  Assert: F is an ECMAScript function object.

2.  Assert: Type(newTarget) is Object.

3.  Let callerContext be the running execution context.

4.  Let kind be F’s [[ConstructorKind]] internal slot.

5.  If kind is "BASE", then

    a.  Let thisArgument be OrdinaryCreateFromConstructor(newTarget,
        "%OBJECTPROTOTYPE%").

    b.  ReturnIfAbrupt(thisArgument).

6.  Let calleeContext be PrepareForOrdinaryCall(F, newTarget).

7.  ReturnIfAbrupt(calleeContext).

8.  Assert: calleeContext is now the active execution context.

9.  If kind is "BASE", then

    a.  Let status be OrdinaryCallBindThis(F, calleeContext,
        thisArgument).

    b.  If status is an abrupt completion, then

        i.  Remove calleeContext from the execution context stack and
            restore callerContext as the running execution context.

        ii. Return status.

10. Let constructorEnv be the LexicalEnvironment of calleeContext.

11. Let envRec be constructorEnv’s environment record.

12. Let result be OrdinaryCallEvaluateBody(F, calleeContext,
    argumentsList).

13. Remove calleeContext from the execution context stack and restore
    callerContext as the running execution context.

14. If result.[[type]] is return, then

    a.  If Type(result.[[value]]) is Object, return
        NormalCompletion(result.[[value]]).

    b.  If kind is "BASE", return NormalCompletion(thisArgument).

    c.  Throw a TYPEERROR exception.

15. ReturnIfAbrupt(result).

16. Return the result of calling the GetThisBinding concrete method of
    envRec’s with no arguments

1.  

FunctionAllocate (functionPrototype, strict [,functionKind] ) Abstract Operation

The abstract operation FunctionAllocate requires the two arguments
functionPrototype and strict. It also accepts one optional argument,
functionKind. FunctionAllocate performs the following steps:

1.  Assert: Type(functionPrototype) is Object.

2.  3.  Assert: If functionKind is present, its value is either
    "NORMAL", "NON-CONSTRUCTOR" or "GENERATOR".

4.  If functionKind is not present, let functionKind be "NORMAL".

5.  If functionKind is "NON-CONSTRUCTOR", then

    a.  Let functionKind be "NORMAL".

    b.  Let needsConstruct be FALSE.

6.  Else let needsConstruct be TRUE.

7.  Let F be a newly created ECMAScript function object with the
    internal slots listed in Table 28. All of those internal slots are
    initialized to UNDEFINED.

8.  Set F’s essential internal methods except for [[GetOwnProperty]]
    to the default ordinary object definitions specified in 9.1.

9.  If strict is TRUE, set F’s [[GetOwnProperty]] internal method to
    the default ordinary object definition specified in 9.1.5.

10. Else, set F’s [[GetOwnProperty]] internal method as specified in
    9.2.1.

11. Set F’s [[Call]] internal method to the definition specified in
    9.2.2.

12. If needsConstruct is TRUE, then

    a.  Set F’s [[Construct]] internal method to the definition
        specified in 9.2.3.

    b.  If functionKind is "GENERATOR", set the [[ConstructorKind]]
        internal slot of F to "DERIVED".

    c.  Else, set the [[ConstructorKind]] internal slot of F to
        "BASE".

    d.  NOTE Generator functions are tagged as "DERIVED" constructors to
        prevent [[Construct]] from preallocating a generator instance.
        Generator instance objects are allocated when EvaluateBody is
        applied to the GenerfatorBody of a generator function.

13. Set the [[Strict]] internal slot of F to strict.

14. Set the [[FunctionKind]] internal slot of F to functionKind.

15. Set the [[Prototype]] internal slot of F to functionPrototype.

16. Set the [[Extensible]] internal slot of F to TRUE.

17. Set the [[Realm]] internal slot of F to the running execution
    context’s Realm.

18. Return F.

FunctionInitialize (F, kind, Strict, ParameterList, Body, Scope) Abstract Operation

The abstract operation FunctionInitialize requires the arguments: a
function object F, kind which is one of (Normal, Method, Arrow), a
Boolean Strict, a parameter list production specified by
ParameterList, a body production specified by Body, a Lexical
Environment specified by Scope. FunctionInitialize performs the
following steps:

1.  Assert: F is an extensible object that does not have a LENGTH own
    property.

2.  Let len be the ExpectedArgumentCount of ParameterList.

3.  4.  Let realm be the value of F’s [[Realm]] internal slot.

5.  Let status be DefinePropertyOrThrow(F, "LENGTH",
    PropertyDescriptor{[[Value]]: len, [[Writable]]: FALSE,
    [[Enumerable]]: FALSE, [[Configurable]]: TRUE}).

6.  Assert: status is not an abrupt completion.

7.  a.  b.  

8.  Set the [[Strict]] internal slot of F to Strict.

9.  Set the [[Environment]] internal slot of F to the value of
    Scope.

10. Set the [[FormalParameters]] internal slot of F to ParameterList
    .

11. Set the [[ECMAScriptCode]] internal slot of F to Body.

12. If kind is Arrow, set the [[ThisMode]] internal slot of F to
    lexical.

13. Else if Strict is TRUE, set the [[ThisMode]] internal slot of F
    to strict.

14. Else set the [[ThisMode]] internal slot of F to global.

15. Return F.

FunctionCreate (kind, ParameterList, Body, Scope, Strict) Abstract Operation

The abstract operation FunctionCreate requires the arguments: kind
which is one of (Normal, Method, Arrow), a parameter list production
specified by ParameterList, a body production specified by Body, a
Lexical Environment specified by Scope, a Boolean flag Strict, and
optionally, an object functionPrototype. FunctionCreate performs the
following steps:

1.  If the functionPrototype argument was not passed, then

2.  a.  Let functionPrototype be the intrinsic object
        %FunctionPrototype%.

3.  If kind is not Normal, let allocKind be "NON-CONSTRUCTOR".

4.  Else let allocKind be "NORMAL".

5.  Let F be FunctionAllocate(functionPrototype, Strict,
    allocKind).

6.  Return FunctionInitialize(F, kind, Strict, ParameterList,
    Body, Scope).

7.  

GeneratorFunctionCreate (kind, ParameterList, Body, Scope, Strict) Abstract Operation

The abstract operation GeneratorFunctionCreate requires the arguments:
kind which is one of (Normal, Method), a parameter list production
specified by ParameterList, a body production specified by Body, a
Lexical Environment specified by Scope, and a Boolean flag Strict.
GeneratorFunctionCreate performs the following steps:

1.  2.  Let functionPrototype be the intrinsic object %Generator%.

3.  Let F be FunctionAllocate(functionPrototype, Strict,
    "GENERATOR").

4.  Return FunctionInitialize(F, kind, Strict, ParameterList,
    Body, Scope).

5.  

AddRestrictedFunctionProperties ( F, realm ) Abstract Operation

The abstract operation AddRestrictedFunctionProperties is called with a
function object F and Realm Record realm as its argument. It
performs the following steps:

1.  Assert: realm.[[intrinsics]].[[%ThrowTypeError%]] exists and has
    been initialized.

2.  Let thrower be realm.[[intrinsics]].[[%ThrowTypeError%]].

3.  a.  b.  

4.  5.  6.  Let status be DefinePropertyOrThrow(F, "CALLER",
    PropertyDescriptor {[[Get]]: thrower, [[Set]]: thrower,
    [[Enumerable]]: FALSE, [[Configurable]]: TRUE}).

7.  Assert: status is not an abrupt completion.

8.  Return DefinePropertyOrThrow(F , "ARGUMENTS", PropertyDescriptor
    {[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: FALSE,
    [[Configurable]]: TRUE}).

9.  Assert: The above returned value is not an abrupt completion.

%ThrowTypeError% ( )

The %ThrowTypeError% intrinsic is an anonymous built-in function object
that is defined once for each Realm. When %ThrowTypeError% is called it
performs the following steps:

1.  2.  Throw a TYPEERROR exception.

The value of the [[Extensible]] internal slot of a %ThrowTypeError%
function is FALSE.

The LENGTH property of a %ThrowTypeError% function has the attributes
{ [[Writable]]: FALSE, [[Enumerable]]: FALSE, [[Configurable]]: FALSE }.

1.  2.  3.  4.  

MakeConstructor (F, writablePrototype, prototype) Abstract Operation

The abstract operation MakeConstructor requires a Function argument F
and optionally, a Boolean writablePrototype and an object prototype.
If prototype is provided it is assumed to already contain, if needed,
a "CONSTRUCTOR" property whose value is F. This operation converts F
into a constructor by performing the following steps:

1.  Assert: F is an ECMAScript function object.

2.  Assert: F has a [[Constructor]] internal method.

3.  Assert: F is an extensible object that does not have a PROTOTYPE
    own property.

4.  Assert: If the prototype argument was provided it is an extensible
    object that does not have a CONSTRUCTOR own property.

5.  Let installNeeded be FALSE.

6.  If the prototype argument was not provided, then

7.  a.  Let installNeeded be TRUE.

    b.  Let prototype be ObjectCreate(%ObjectPrototype%).

8.  If the writablePrototype argument was not provided, then

9.  a.  Let writablePrototype be TRUE.

10. 11. a.  

12. a.  b.  

13. 14. If installNeeded, then

15. a.  Let status be DefinePropertyOrThrow(prototype,
        "CONSTRUCTOR", PropertyDescriptor{[[Value]]: F, [[Writable]]:
        writablePrototype, [[Enumerable]]: FALSE, [[Configurable]]:
        writablePrototype }).

    b.  Assert: status is not an abrupt completion.

16. Let status be DefinePropertyOrThrow(F, "PROTOTYPE",
    PropertyDescriptor{[[Value]]: prototype, [[Writable]]:
    writablePrototype, [[Enumerable]]: FALSE, [[Configurable]]:
    FALSE}).

17. Assert: status is not an abrupt completion.

18. Return NormalCompletion(UNDEFINED).

MakeClassConstructor ( F) Abstract Operation

The abstract operation MakeClassConstructor with argument F performs
the following steps:

1.  Assert: F is an ECMAScript function object.

2.  Assert: F’s [[FunctionKind]] internal slot is "NORMAL".

3.  Set F’s [[FunctionKind]] internal slot to "CLASSCONSTRUCTOR".

4.  Return NormalCompletion(UNDEFINED).

MakeMethod ( F, homeObject) Abstract Operation

The abstract operation MakeMethod with arguments F and homeObject
configures F as a method by performing the following steps:

1.  Assert: F is an ECMAScript function object.

2.  3.  Assert: Type(homeObject ) is either Undefined or Object.

4.  Set the [[NeedsSuper]] internal slot of F to TRUE.

5.  Set the [[HomeObject]] internal slot of F to homeObject.

6.  7.  Return NormalCompletion(UNDEFINED).

SetFunctionName (F, name, prefix) Abstract Operation

The abstract operation SetFunctionName requires a Function argument F,
a String or Symbol argument name and optionally a String argument
prefix. This operation adds a NAME property to F by performing the
following steps:

1.  Assert: F is an extensible object that does not have a NAME own
    property.

2.  3.  Assert: Type(name) is either Symbol or String.

4.  Assert: If prefix was passed then Type(prefix) is String.

5.  If Type(name) is Symbol, then

    a.  Let description be name’s [[Description]] value.

    b.  If description is UNDEFINED, let name be the empty String.

    c.  d.  Else, let name be the concatenation of "[", description,
        and "]".

6.  If prefix was passed, then

    a.  Let name be the concatenation of prefix, Unicode code point
        U+0020 (Space) , and name.

7.  Return DefinePropertyOrThrow(F, "NAME",
    PropertyDescriptor{[[Value]]: name, [[Writable]]: FALSE,
    [[Enumerable]]: FALSE, [[Configurable]]: TRUE}).

8.  Assert: the result is never an abrupt completion.

9.  10. 

1.  2.  3.  

1.  2.  3.  4.  a.  

5.  6.  

    a.  b.  

7.  8.  

9.  10. a.  b.  i.  

    c.  i.  

11. a.  

    b.  c.  

12. 

FunctionDeclarationInstantiation(func, argumentsList, env ) Abstract Operation

NOTE When an execution context is established for evaluating an
ECMAScript function a new Function Environment Record is created and
bindings for each formal parameter are instantiated in that environment
record. Each declaration in the function body is also instantiated. If
the function’s formal parameters do not include any default value
initializers then the body declarations are instantiated in the same
environment record as the parameters. If default value parameter
initializers exist, a second environment record is created for the body
declarations. Formal parameters and functions are initialized as part of
FunctionDeclarationInstantiation. All other bindings are initialized
during evaluation of the function body.

FunctionDeclarationInstantiation is performed as follows using arguments
_func, argumentsList_, and env. func is the function object that for
which the execution context is being established. env is the lexical
environment in which formal parameter bindings are to be created.

1.  Let envRec be env’s environment record.

2.  Let calleeContext be the running execution context.

3.  Let code be the value of the [[ECMAScriptCode]] internal slot of
    func.

4.  Let strict be the value of the [[Strict]] internal slot of func.

5.  Let formals be the value of the [[FormalParameters]] internal slot
    of func.

6.  Let parameterNames be the BoundNames of formals.

7.  If parameterNames has any duplicate entries, let hasDuplicates
    be TRUE. Otherwise, let hasDuplicates be FALSE.

8.  9.  Let simpleParameterList be IsSimpleParameterList of formals.

10. Let hasParameterExpressions be ContainsExpression of formals.

11. Let varNames be the VarDeclaredNames of code.

12. Let varDeclarations be the VarScopedDeclarations of code.

13. Let lexicalNames be the LexicallyDeclaredNames of code.

14. Let functionNames be an empty List.

15. Let functionsToInitialize be an empty List.

16. For each d in varDeclarations, in reverse list order do

    a.  If d is neither a VariableDeclaration or a ForBinding,
        then

        i.  Assert: d is either a FunctionDeclaration or a
            GeneratorDeclaration.

        ii. Let fn be the sole element of the BoundNames of d.

        iii. If fn is not an element of functionNames, then

            1.  2.  Insert fn as the first element of functionNames.

            3.  NOTE If there are multiple FunctionDeclarations or
                GeneratorDeclarations for the same name, the last
                declaration is used.

            4.  5.  Insert d as the first element of
                functionsToInitialize.

17. 18. Let argumentsObjectNeeded be TRUE.

19. If the value of the [[ThisMode]] internal slot of func is lexical,
    then

    a.  NOTE Arrow functions never have an arguments objects.

    b.  c.  d.  Let argumentsObjectNeeded be FALSE.

20. Else if "ARGUMENTS" is an element of parameterNames, then

    a.  b.  Let argumentsObjectNeeded be FALSE.

21. Else

22. if hasParameterExpressions is FALSE, then

23. If "ARGUMENTS" is an element of functionNames

    a.  or if "ARGUMENTS" is an element of lexicalNames, then

        i.  Let argumentsObjectNeeded be FALSE.

24. For each String paramName in parameterNames, do

    a.  Let alreadyDeclared be the result of calling envRec’s
        HasBinding concrete method passing paramName as the argument.

    b.  NOTE Early errors ensure that duplicate parameter names can only
        occur in non-strict functions that do not have parameter default
        values or rest parameters.

    c.  d.  If alreadyDeclared is FALSE, then

    e.  i.  Let status be the result of calling envRec’s
            CreateMutableBinding concrete method passing paramName as
            the argument.

        ii. If hasDuplicates is TRUE, then

            1.  Let status be the result of calling envRec’s
                InitializeBinding concrete method passing paramName
                and UNDEFINED as the argument.

        iii. Assert: status is never an abrupt completion for either
            of the above operations.

25. If argumentsObjectNeeded is TRUE, then

26. a.  If strict is TRUE or if simpleParameterList is FALSE, then

    b.  i.  Let ao be
            CreateUnmappedArgumentsObject(argumentsList_)_.

        ii. 

    c.  Else,

        i.  NOTE mapped argument object is only provided for non-strict
            functions that don’t have a rest parameter, any parameter
            default value initializers, or any destructured parameters .

        ii. Let ao be CreateMappedArgumentsObject(func, formals,
            argumentsList, env).

        iii. 

    d.  ReturnIfAbrupt(ao).

27. a.  i.  

    b.  i.  

    c.  d.  e.  i.  ii. 1.  

        iii. 1.  

        iv. 

    f.  

28. a.  If strict is TRUE, then

        i.  Let status be the result of calling envRec’s
            CreateImmutableBinding concrete method passing "ARGUMENTS"
            as the argument.

    b.  Else,

        i.  Let status be the result of calling envRec’s
            CreateMutableBinding concrete method passing "ARGUMENTS" as
            the argument.

    c.  Assert: status is never an abrupt completion.

    d.  e.  Call envRec’s InitializeBinding concrete method passing
        "ARGUMENTS" and ao as arguments.

    f.  Append "ARGUMENTS" to parameterNames.

29. If hasDuplicates is TRUE, then

    a.  Let formalStatus be the result of performing
        IteratorBindingInitialization for formals with
        CreateListIterator(argumentsList) and UNDEFINED as arguments.

30. Else,

    a.  Let formalStatus be the result of performing
        IteratorBindingInitialization for formals with
        CreateListIterator(argumentsList) and envRec as arguments.

31. ReturnIfAbrupt(formalStatus).

32. 33. 34. 35. 36. If hasParameterExpressions is FALSE, then

    a.  NOTE Only a single lexical environment is needed for the
        parameters and top-level vars.

    b.  c.  Let instantiatedVarNames be a copy of the List
        parameterNames.

    d.  For each n in varNames, do

        i.  If n is not an element of instantiatedVarNames, then

            1.  Append n to instantiatedVarNames.

            2.  Let status be the result of calling envRec’s
                CreateMutableBinding concrete method passing n as the
                argument.

            3.  Assert: status is never an abrupt completion.

            4.  Call envRec’s InitializeBinding concrete method
                passing n and UNDEFINED as arguments.

    e.  Let varEnv be env.

    f.  Let varEnvRec be envRec.

37. Else,

    a.  NOTE A separate environment record is needed to ensure that
        closures created by expressions in the formal parameter list do
        not have visibility of declarations in the function body.

    b.  Let varEnv be NewDeclarativeEnvironment(env).

    c.  Let varEnvRec be varEnv’s environment record.

38. a.  b.  Set the VariableEnvironment of calleeContext to varEnv.

    c.  Let instantiatedVarNames be a new emptyList.

    d.  For each n in varNames, do

        i.  If n is not an element of instantiatedVarNames, then

            1.  Append n to instantiatedVarNames.

            2.  Let status be the result of calling varEnvRec’s
                CreateMutableBinding concrete method passing n as the
                argument.

            3.  Assert: status is never an abrupt completion.

            4.  If n is not an element of parameterNames or if n
                is an element of functionNames, let initialValue be
                UNDEFINED.

            5.  else,

                a.  Let initialValue be the result of calling
                    envRec’s GetBindingValue concrete method passing
                    n and FALSE as the arguments.

                b.  ReturnIfAbrupt(initialValue).

            6.  Call varEnvRec’s InitializeBinding concrete method
                passing n and initialValue as arguments.

            7.  NOTE vars whose names are the same as a formal
                parameter, initially have the same value as the
                corresponding initialized parameter.

            8.  

39. If strict is FALSE, then

    a.  Let lexEnv be NewDeclarativeEnvironment(varEnv).

    b.  NOTE: Non-strict functions use a separate lexical environment
        record for top-level lexical declarations so that a direct EVAL
        (see 12.3.4.1) can determine whether any var scoped declarations
        introduced by the eval code conflict with pre-existing top-level
        lexically scoped declarations. This is not needed for strict
        functions because a strict direct EVAL always places all
        declarations into a new environment record.

    c.  

40. Else, let lexEnv be varEnv.

41. Let lexEnvRec be lexEnv’s environment record.

42. Set envRec.[[topLex]] to lexEnvRec.

43. Set the LexicalEnvironment of calleeContext to lexEnv.

44. Let lexDeclarations be the LexicallyScopedDeclarations of code.

45. For each element d in lexDeclarations do

    a.  NOTE A lexically declared name cannot be the same as a
        function/generator declaration, formal parameter, or a var name.
        Lexically declared names are only instantiated here but not
        initialized.

    b.  c.  For each element dn of the BoundNames of d do

        i.  If IsConstantDeclaration of d is TRUE, then

            1.  Let status be the result of calling lexEnvRec’s
                CreateImmutableBinding concrete method passing dn and
                TRUE as the arguments.

        ii. Else,

            1.  Let status be the result of calling lexEnvRec’s
                CreateMutableBinding concrete method passing dn and
                FALSE as the arguments.

    d.  Assert: status is never an abrupt completion.

46. For each production f in functionsToInitialize, do

    a.  Let fn be the sole element of the BoundNames of f.

    b.  Let fo be the result of performing InstantiateFunctionObject
        for f with argument lexEnv.

    c.  d.  Let status be the result of calling varEnvRec’s
        SetMutableBinding concrete method passing fn, fo and FALSE
        as the arguments.

    e.  Assert: status is never an abrupt completion.

47. Return NormalCompletion(empty).

NOTE B.3.2 provides an extension to the above algorithm that is
necessary for backwards compatibility with web browser implementations
of ECMAScript that predate the sixth edition of ECMA-262.


Built-in Function Objects

The built-in function objects defined in this specification may be
implemented as either ECMAScript function objects (9.2) whose behaviour
is provided using ECMAScript code or as implementation provided exotic
function objects whose behaviour is provided in some other manner. In
either case, the effect of calling such functions must conform to their
specifications. An implementation may also provide additional built-in
function objects that are not defined in this specification.

If a built-in function object is implemented as an exotic object it must
have the ordinary object behaviour specified in 9.1 except
[[GetOwnProperty]] which must be as specified in 9.2.1. All such exotic
function objects also have [[Prototype]], [[Extensible]], and [[Realm]]
internal slots.

Unless otherwise specified every built-in function object initially has
the %FunctionPrototype% object (19.2.3) as the initial value of its
[[Prototype]] internal slot.

The behaviour specified for each built-in function via algorithm steps
or other means is the specification of the function body behaviour for
both [[Call]] and [[Construct]] invocations of the function. For each
built-in function, when invoked with [[Call]], the [[Call]]
thisArgument provides the THIS value, the [[Call]] argumentsList
provides the named parameters, and the NewTarget value is UNDEFINED.
When invoked with [[Construct]], the THIS value is uninitialized, the
[[Construct]] argumentsList provides the named parameters, and the
[[Construct]] newTarget parameter provides the NewTarget value. If the
built-in function is implemented as an ECMAScript function object then
this specified behaviour must be implemented by the ECMAScript code that
is the body of the function. Built-in functions that are ECMAScript
function objects must be strict mode functions. If a built-in
constructor has any [[Call]] behaviour other than throwing a TYPEERROR
exception, an ECMAScript implementation of the function must be done in
a manner that does not cause the function’s [[FunctionKind]] internal
slot to have the value "CLASSCONSTRUCTOR".

Built-in function objects that are not identified as constructors do not
implement the [[Construct]] internal method unless otherwise specified
in the description of a particular function. When a built-in constructor
is called as part of a NEW expression the argumentsList parameter of
the invoked [[Construct]] internal method provides the values for the
built-in constructor’s named parameters.

Built-in functions that are not constructors do not have a PROTOTYPE
property unless otherwise specified in the description of a particular
function.

If a built-in function object is not implemented as an ECMAScript
function it must provide [[Call]] and [[Construct]] internal methods
that conforms to the following definitions:

[[Call]] ( thisArgument, argumentsList) 

The [[Call]] internal method for a built-in function object F is
called with parameters thisArgument and argumentsList, a List of
ECMAScript language values. The following steps are taken:

1.  Let callerContext be the running execution context.

2.  If callerContext is not already suspended, Suspend
    callerContext.

3.  Let calleeContext be a new execution context.

4.  Set the Function of calleeContext to F.

5.  Let calleeRealm be the value of F’s [[Realm]] internal slot.

6.  Set the Realm of calleeContext to calleeRealm.

7.  Perform any necessary implementation defined initialization of
    calleeContext.

8.  Push calleeContext onto the execution context stack;
    calleeContext is now the running execution context.

9.  Let result be the Completion Record that is the result of
    evaluating F in an implementation defined manner that conforms to
    the specification of F. thisArgument is the THIS value,
    argumentsList provides the named parameters, and the NewTarget
    value is UNDEFINED.

10. Remove calleeContext from the execution context stack and restore
    callerContext as the running execution context.

11. Return result.

NOTE 1 When calleeContext is removed from the execution context stack
it must not be destroyed if it has been suspended and retained by an
accessable generator object for later resumption.

[[Construct]] (argumentsList, newTarget)

The [[Construct]] internal method for built-in function object F is
called with parameters argumentsList and newTarget. The steps
performed as the same as [[Call]] (see 9.3.1) except that step 9 is
replaced by:

9.  Let result be the Completion Record that is the result of
    evaluating F in an implementation defined manner that conforms to
    the specification of F. The THIS value is uninitialized,
    argumentsList provides the named parameters, and newTarget
    provides the NewTarget value.

CreateBuiltinFunction(realm, steps, prototype, internalSlotsList) Abstract Operation

The abstract operation CreateBuiltinFunction takes arguments realm,
prototype, and steps. The optional argument internalSlotsList is a
List of the names of additional internal slot that must be defined as
part of the object. If the list is not provided, an empty List is used.
CreateBuiltinFunction returns a built-in function object created by the
following steps:

1.  Assert: realm is a Realm Record.

2.  Assert: steps is either a set of algorithm steps or other
    definition of a functions behaviour provided in this specification.

3.  4.  Let func be a new built-in function object that when called
    performs the action described by steps. The new function object
    has internal slots whose names are the elements of
    internalSlotsList. The initial value of each of those internal
    slots is UNDEFINED.

5.  6.  Set the [[Realm]] internal slot of func to realm.

7.  Set the [[Prototype]] internal slot of func to prototype.

8.  9.  Return func.

10. 


Built-in Exotic Object Internal Methods and Slots

This specification defines several kinds of built-in exotic objects.
These objects generally behave similar to ordinary objects except for a
few specific situations. The following exotic objects use the ordinary
object internal methods except where it is explicitly specified
otherwise below:

Bound Function Exotic Objects

A _bound function_ is an exotic object that wraps another function
object. A bound function is callable (it has a [[Call]] internal method
and may have a [[Construct]] internal method). Calling a bound function
generally results in a call of its wrapped function.

Bound function objects do not have the internal slots of ECMAScript
function objects defined in Table 28. Instead they have the internal
slots defined in Table 29.

Table 29 — Internal Slots of Exotic Bound Function Objects

  _INTERNAL SLOT_           TYPE            DESCRIPTION
  ------------------------- ----------------- ------------------------------------------------------------------------------------------------------
  [[BoundTargetFunction]]   Callable Object   The wrapped function object.
  [[BoundThis]]             Any               The value that is always passed as the THIS value when calling the wrapped function.
  [[BoundArguments]]        List of Any       A list of values whose elements are used as the first arguments to any call to the wrapped function.

Unlike ECMAScript function objects, bound function objects do not use an
alternative definition of the [[GetOwnProperty]] internal methods. Bound
function objects provide all of the essential internal methods as
specified in 9.1. However, they use the following definitions for the
essential internal methods of function objects.

[[Call]] ( thisArgument, argumentsList)

When the [[Call]] internal method of an exotic bound function object,
F, which was created using the bind function is called with parameters
thisArgument and argumentsList, a List of ECMAScript language
values, the following steps are taken:

1.  2.  Let target be the value of F’s [[BoundTargetFunction]]
    internal slot.

3.  Let boundThis be the value of F’s [[BoundThis]] internal slot.

4.  Let boundArgs be the value of F’s [[BoundArguments]] internal
    slot.

5.  6.  Let args be a new list containing the same values as the list
    boundArgs in the same order followed by the same values as the
    list argumentsList in the same order.

7.  Return Call(target, boundThis, args).

[[Construct]] (argumentsList, newTarget)

When the [[Construct]] internal method of an exotic bound function
object, F that was created using the bind function is called with a
list of arguments argumentsList and newTarget, the following steps
are taken:

1.  Let target be the value of F’s [[BoundTargetFunction]] internal
    slot.

2.  Assert: target has a [[Construct]] internal method.

3.  Let boundArgs be the value of F’s [[BoundArguments]] internal
    slot.

4.  Let args be a new list containing the same values as the list
    boundArgs in the same order followed by the same values as the
    list argumentsList in the same order.

5.  If SameValue(F, newTarget) is TRUE, let newTarget be target.

6.  Return Construct(target, args, newTarget).

BoundFunctionCreate (targetFunction, boundThis, boundArgs) Abstract Operation

The abstract operation BoundFunctionCreate with arguments
targetFunction, boundThis and boundArgs is used to specify the
creation of new Bound Function exotic objects. It performs the following
steps:

1.  Let proto be the intrinsic %FunctionPrototype%.

2.  Let obj be a newly created object.

3.  Set obj’s essential internal methods to the default ordinary
    object definitions specified in 9.1.

4.  Set the [[Call]] internal method of obj as described in 9.4.1.1.

5.  If targetFunction has a [[Construct]] internal method, then

    a.  Set the [[Construct]] internal method of obj as described in
        9.4.1.2.

6.  Set the [[Prototype]] internal slot of obj to proto.

7.  Set the [[Extensible]] internal slot of obj to TRUE.

8.  Set the [[BoundTargetFunction]] internal slot of obj to
    targetFunction.

9.  Set the [[BoundThis]] internal slot of obj to the value of
    boundThis.

10. Set the [[BoundArguments]] internal slot of obj to boundArgs.

11. Return obj.

BoundFunctionClone ( function ) Abstract Operation

The abstract operation BoundFunctionClone is called with argument
function it performs the following steps:

1.  Assert: function is a Bound Function exotic object.

2.  3.  Let new be a new Bound Function exotic object that has all of
    the same internal methods and internal slots as function.

4.  Set the value of each of new’s internal slots, except for
    [[Extensible]] to the value of function’s corresponding internal
    slot.

5.  6.  Set new’s [[Extensible]] internal slot to TRUE.

7.  8.  9.  10. Return new.

1.  2.  3.  a.  

4.  a.  

5.  

Array Exotic Objects

An _Array object_ is an exotic object that gives special treatment to
array index property keys (see 6.1.7). A property whose property name is
an array index is also called an element. Every Array object has a
LENGTH property whose value is always a nonnegative integer less than
2^32^. The value of the LENGTH property is numerically greater than the
name of every own property whose name is an array index; whenever an own
property of an Array object is created or changed, other properties are
adjusted as necessary to maintain this invariant. Specifically, whenever
an own property is added whose name is an array index, the value of the
LENGTH property is changed, if necessary, to be one more than the
numeric value of that array index; and whenever the value of the LENGTH
property is changed, every own property whose name is an array index
whose value is not smaller than the new length is deleted. This
constraint applies only to own properties of an Array object and is
unaffected by LENGTH or array index properties that may be inherited
from its prototypes.

NOTE A String property name P is an _array index_ if and only if
ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
to 2^32^−1.

Array exotic objects always have a non-configurable property named
"LENGTH".

Array exotic objects provide an alternative definition for the
[[DefineOwnProperty]] internal method. Except for that internal method,
Array exotic objects provide all of the other essential internal methods
as specified in 9.1.

[[DefineOwnProperty]] ( P, Desc)

When the [[DefineOwnProperty]] internal method of an Array exotic object
A is called with property key P, and Property Descriptor Desc the
following steps are taken:

1.  Assert: IsPropertyKey(P) is TRUE.

2.  If P is "LENGTH", then

    a.  Return ArraySetLength(A, Desc).

3.  Else if P is an array index, then

    a.  Let oldLenDesc be OrdinaryGetOwnProperty(A, "LENGTH").

    b.  Assert: oldLenDesc will never be UNDEFINED or an accessor
        descriptor because Array objects are created with a length data
        property that cannot be deleted or reconfigured.

    c.  Let oldLen be oldLenDesc.[[Value]].

    d.  Let index be ToUint32(P).

    e.  f.  Assert: index will never be an abrupt completion.

    g.  If index ≥ oldLen and oldLenDesc.[[Writable]] is FALSE,
        return FALSE.

    h.  Let succeeded be OrdinaryDefineOwnProperty(A, P, Desc).

    i.  Assert: succeeded is not an abrupt completion.

    j.  If succeeded is FALSE, return FALSE.

    k.  If index ≥ oldLen

        i.  Set oldLenDesc.[[Value]] to index + 1.

        ii. Let succeeded be OrdinaryDefineOwnProperty(A, "LENGTH",
            oldLenDesc).

        iii. iv. Assert: succeeded is TRUE.

    l.  Return TRUE.

4.  Return OrdinaryDefineOwnProperty(A, P, Desc).

ArrayCreate(length, proto) Abstract Operation

The abstract operation ArrayCreate with argument length (a positive
integer) and optional argument proto is used to specify the creation
of new Array exotic objects. It performs the following steps:

1.  Assert: length is an integer Number ≥ 0.

2.  If length is −0, let length be +0.

3.  If length>2^32^-1, throw a RANGEERROR exception.

4.  If the proto argument was not passed, let proto be the intrinsic
    object %ArrayPrototype%.

5.  Let A be a newly created Array exotic object.

6.  Set A’s essential internal methods except for
    [[DefineOwnProperty]] to the default ordinary object definitions
    specified in 9.1.

7.  Set the [[DefineOwnProperty]] internal method of A as specified in
    9.4.2.1.

8.  Set the [[Prototype]] internal slot of A to proto.

9.  Set the [[Extensible]] internal slot of A to TRUE.

10. a.  

11. a.  b.  

12. 13. Call OrdinaryDefineOwnProperty with arguments A, "LENGTH" and
    PropertyDescriptor{[[Value]]: length, [[Writable]]: TRUE,
    [[Enumerable]]: FALSE, [[Configurable]]: FALSE}.

14. Return A.

ArraySpeciesCreate(originalArray, length) Abstract Operation

The abstract operation ArraySpeciesCreate with arguments originalArray
and length is used to specify the creation of a new Array object using
a constructor function that is derived from originalArray. It performs
the following steps:

1.  Assert: length is an integer Number ≥ 0.

2.  If length is −0, let length be +0.

3.  Let C be UNDEFINED.

4.  5.  6.  If IsArray(originalArray) is TRUE, then

    a.  Let C be Get(originalArray, "CONSTRUCTOR").

    b.  ReturnIfAbrupt(C).

    c.  If IsConstructor(C) is TRUE, then

        i.  Let thisRealm be the running execution context’s Realm.

        ii. Let realmC be GetFunctionRealm(C).

        iii. If thisRealm and realmC are not the same Realm Record,
            then

            1.  If SameValue(C, realmC.[[intrinsics]].[[%Array%]])
                is TRUE, let C be UNDEFINED.

    d.  If Type(C) is Object, then

        i.  Let C be Get(C, @@species).

        ii. ReturnIfAbrupt(C).

7.  If C is UNDEFINED, return ArrayCreate(length).

8.  If IsConstructor(C) is FALSE, throw a TYPEERROR exception.

9.  Return Construct(C, «length»).

NOTE If originalArray was created using the standard built-in Array
constructor for a Realm that is not the Realm of the running execution
context, then a new Array is created using the Realm of the running
execution context. This maintains compatibility with Web browsers that
have historically had that behaviour for the Array.prototype methods
that now are defined using ArraySpeciesCreate.

ArraySetLength(A, Desc) Abstract Operation

When the abstract operation ArraySetLength is called with an Array
exotic object A, and Property Descriptor Desc the following steps
are taken:

1.  If the [[Value]] field of Desc is absent, then

    a.  Return OrdinaryDefineOwnProperty(A, "LENGTH", Desc).

2.  Let newLenDesc be a copy of Desc.

3.  Let newLen be ToUint32(Desc.[[Value]]).

4.  ReturnIfAbrupt(newLen).

5.  Let numberLen be ToNumber(Desc.[[Value]]).

6.  ReturnIfAbrupt(newLen).

7.  If newLen ≠ numberLen, throw a RANGEERROR exception.

8.  Set newLenDesc.[[Value]] to newLen.

9.  Let oldLenDesc be OrdinaryGetOwnProperty(A, "LENGTH").

10. Assert: oldLenDesc is not an abrupt completion.

11. Assert: oldLenDesc will never be UNDEFINED or an accessor
    descriptor because Array objects are created with a length data
    property that cannot be deleted or reconfigured.

12. Let oldLen be oldLenDesc.[[Value]].

13. If newLen ≥oldLen, then

    a.  Return OrdinaryDefineOwnProperty(A, "LENGTH", newLenDesc).

14. If oldLenDesc.[[Writable]] is FALSE, return FALSE.

15. If newLenDesc.[[Writable]] is absent or has the value TRUE, let
    newWritable be TRUE.

16. Else,

    a.  Need to defer setting the [[Writable]] attribute to FALSE in
        case any elements cannot be deleted.

    b.  Let newWritable be FALSE.

    c.  Set newLenDesc.[[Writable]] to TRUE.

17. Let succeeded be OrdinaryDefineOwnProperty(A, "LENGTH",
    newLenDesc).

18. Assert:succeeded is not an abrupt completion.

19. If succeeded is FALSE, return FALSE.

20. While newLen < oldLen repeat,

    a.  Set oldLen to oldLen – 1.

    b.  Let deleteSucceeded be the result of calling the [[Delete]]
        internal method of A passing ToString(oldLen).

    c.  Assert: deleteSucceeded is not an abrupt completion.

    d.  If deleteSucceeded is FALSE, then

        i.  Set newLenDesc.[[Value]] to oldLen+1.

        ii. If newWritable is FALSE, set newLenDesc.[[Writable]] to
            FALSE.

        iii. Let succeeded be OrdinaryDefineOwnProperty(A, "LENGTH",
            newLenDesc).

        iv. v.  Assert:succeeded is not an abrupt completion.

        vi. Return FALSE.

21. If newWritable is FALSE, then

    a.  Return OrdinaryDefineOwnProperty(A, "LENGTH",
        PropertyDescriptor{[[Writable]]: FALSE}). This call will always
        return TRUE.

22. Return TRUE.

NOTE In steps 3 and 4, if Desc.[[Value]] is an object then its VALUEOF
method is called twice. This is legacy behaviour that was specified with
this effect starting with the 2^nd^ Edition of this specification.

String Exotic Objects

A _String object_ is an exotic object that encapsulates a String value
and exposes virtual integer indexed data properties corresponding to the
individual code unit elements of the string value. Exotic String objects
always have a data property named "LENGTH" whose value is the number of
code unit elements in the encapsulated String value. Both the code unit
data properties and the "LENGTH" property are non-writable and
non-configurable.

Exotic String objects have the same internal slots as ordinary objects.
They also have a [[StringData]] internal slot.

Exotic String objects provide alternative definitions for the following
internal methods. All of the other exotic String object essential
internal methods that are not defined below are as specified in 9.1.

 [[GetOwnProperty]] ( P )

When the [[GetOwnProperty]] internal method of an exotic String object
S is called with property key P the following steps are taken:

1.  Assert: IsPropertyKey(P) is TRUE.

2.  Let desc be OrdinaryGetOwnProperty(S, P).

3.  4.  If desc is not UNDEFINED return desc.

5.  6.  Return StringGetIndexProperty(S, P).

StringGetIndexProperty (S, P)

When the abstract operation StringGetIndexProperty is called with an
exotic String object S and with property key P, the following steps
are taken:

1.  If Type(P) is not String, return UNDEFINED.

2.  Let index be CanonicalNumericIndexString (P).

3.  Assert: index is not an abrupt completion.

4.  If index is UNDEFINED, return UNDEFINED.

5.  If IsInteger(index) is FALSE, return UNDEFINED.

6.  If index = −0, return UNDEFINED.

7.  8.  Let str be the String value of the [[StringData]] internal
    slot of S.

9.  Let len be the number of elements in str.

10. If index < 0 or len ≤ index, return UNDEFINED.

11. Let resultStr be a String value of length 1, containing one code
    unit from str, specifically the code unit at index index.

12. Return a PropertyDescriptor{ [[Value]]: resultStr, [[Enumerable]]:
    TRUE, [[Writable]]: FALSE, [[Configurable]]: FALSE }.

[[HasProperty]](P)

When the [[HasProperty]] internal method of an exotic String object S
is called with property key P, the following steps are taken:

1.  Let hasOrdinary be OrdinaryHasProperty(S, P).

2.  If hasOrdinary is TRUE, return TRUE.

3.  Let desc be StringGetIndexProperty(S, P).

4.  If desc is UNDEFINED, return FALSE; otherwise, return TRUE.

[[Enumerate]] ()

When the [[Enumerate]] internal method of an exotic String object O is
called the following steps are taken:

1.  Let indexKeys be a new empty List.

2.  Let str be the String value of the [[StringData]] internal slot of
    O.

3.  Let len be the number of elements in str.

4.  For each integer i starting with 0 such that i < len, in
    ascending order,

    a.  Add ToString(i) as the last element of indexKeys

5.  Let ordinary be the result of calling the default ordinary object
    [[Enumerate]] internal method (9.1.11) on O.

6.  ReturnIfAbrupt(ordinary).

7.  Return CreateCompoundIterator(CreateListIterator(indexKeys),
    ordinary_)_.

[[OwnPropertyKeys]] ( )

When the [[OwnPropertyKeys]] internal method of a String exotic object
O is called the following steps are taken:

1.  Let keys be a new empty List.

2.  Let str be the String value of the [[StringData]] internal slot of
    O.

3.  Let len be the number of elements in str.

4.  For each integer i starting with 0 such that i < len, in
    ascending order,

    a.  Add ToString(i) as the last element of keys

5.  For each own property key P of O such that P is an integer
    index and ToInteger(P) ≥ len, in ascending numeric index order,

    a.  Add P as the last element of keys.

6.  For each own property key P of O such that Type(P) is String
    and P is not an integer index, in property creation order,

    a.  Add P as the last element of keys.

7.  For each own property key P of O such that Type(P) is Symbol,
    in property creation order,

    a.  Add P as the last element of keys.

8.  Return keys.

StringCreate( value, prototype) Abstract Operation

The abstract operation StringCreate with arguments value and
prototype is used to specify the creation of new exotic String
objects. It performs the following steps:

1.  ReturnIfAbrupt(prototype).

2.  Assert: Type(value) is String.

3.  Let S be a newly created String exotic object.

4.  Set the [[StringData]] internal slot of S to value.

5.  Set S’s essential internal methods to the default ordinary object
    definitions specified in 9.1.

6.  Set the [[GetOwnProperty]] internal method of S as specified in
    9.4.3.1.

7.  8.  Set the [[Enumerate]] internal method of S as specified in
    9.4.3.2.

9.  Set the [[OwnPropertyKeys]] internal method of S as specified in
    9.4.3.3.

10. Set the [[Prototype]] internal slot of S to prototype.

11. Set the [[Extensible]] internal slot of S to TRUE.

12. Let length be the number of code unit elements in value.

13. Let status be DefinePropertyOrThrow(S, "LENGTH",
    PropertyDescriptor{[[Value]]: length, [[Writable]]: FALSE,
    [[Enumerable]]: FALSE, [[Configurable]]: FALSE }).

14. Assert: status is not an abrupt completion.

15. Return S.

Arguments Exotic Objects

Most ECMAScript functions make an arguments objects available to their
code. Depending upon the characteristics of the function definition, its
argument object is either an ordinary object or an _arguments exotic
object_. An arguments exotic object is an exotic object whose array
index properties map to the formal parameters bindings of an invocation
of its associated ECMAScript function.

Arguments exotic objects have the same internal slots as ordinary
objects. They also have a [[ParameterMap]] internal slot. Ordinary
arguments objects also have a [[ParameterMap]] internal slot whose value
is always undefined. For ordinary argument objects the [[ParameterMap]]
internal slot is only used by OBJECT.PROTOTYPE.TOSTRING (19.1.3.6) to
identify them as such.

Arguments exotic objects provide alternative definitions for the
following internal methods. All of the other exotic arguments object
essential internal methods that are not defined below are as specified
in 9.1

NOTE 1 For non-strict mode functions the integer indexed data properties
of an arguments object whose numeric name values are less than the
number of formal parameters of the corresponding function object
initially share their values with the corresponding argument bindings in
the function’s execution context. This means that changing the property
changes the corresponding value of the argument binding and vice-versa.
This correspondence is broken if such a property is deleted and then
redefined or if the property is changed into an accessor property. For
strict mode functions, the values of the arguments object’s properties
are simply a copy of the arguments passed to the function and there is
no dynamic linkage between the property values and the formal parameter
values.

NOTE 2 The ParameterMap object and its property values are used as a
device for specifying the arguments object correspondence to argument
bindings. The ParameterMap object and the objects that are the values of
its properties are not directly observable from ECMAScript code. An
ECMAScript implementation does not need to actually create or use such
objects to implement the specified semantics.

NOTE 3 Arguments objects for strict mode functions define
non-configurable accessor properties named "CALLER" and "CALLEE" which
throw a TYPEERROR exception on access. The "CALLEE" property has a more
specific meaning for non-strict mode functions and a "CALLER" property
has historically been provided as an implementation-defined extension by
some ECMAScript implementations. The strict mode definition of these
properties exists to ensure that neither of them is defined in any other
manner by conforming ECMAScript implementations.

 [[GetOwnProperty]] (P)

The [[GetOwnProperty]] internal method of an arguments exotic object
when called with a property name P performs the following steps:

1.  Let args be the arguments object.

2.  Let desc be OrdinaryGetOwnProperty(args, P).

3.  If desc is UNDEFINED, return desc.

4.  Let map be the value of the [[ParameterMap]] internal slot of the
    arguments object.

5.  Let isMapped be HasOwnProperty(map, P).

6.  Assert: isMapped is never an abrupt completion.

7.  If the value of isMapped is true, then

    a.  Set desc.[[Value]] to Get(map, P).

1.  If IsDataDescriptor(desc) is TRUE and P is "CALLER" and
    desc.[[Value]] is a strict mode Function object, throw a TYPEERROR
    exception.

1.  Return desc.

2.  

If an implementation does not provide a built-in CALLER property for
argument exotic objects then step 8 of this algorithm is must be
skipped.

 [[DefineOwnProperty]] (P, Desc)

The [[DefineOwnProperty]] internal method of an arguments exotic object
when called with a property name P and Property Descriptor Desc
performs the following steps:

1.  Let args be the arguments object.

2.  Let map be the value of the [[ParameterMap]] internal slot of the
    arguments object.

3.  Let isMapped be HasOwnProperty(map, P).

4.  Let allowed be OrdinaryDefineOwnProperty(args, P, Desc).

5.  ReturnIfAbrupt(allowed).

6.  If allowed is FALSE, return FALSE.

7.  If the value of isMapped is TRUE, then

    a.  If IsAccessorDescriptor(Desc) is TRUE, then

        i.  Call the [[Delete]] internal method of map passing P as
            the argument.

    b.  Else

        i.  If Desc.[[Value]] is present, then

            1.  Let putStatus be Put(map, P, Desc.[[Value]],
                FALSE).

            2.  Assert: putStatus is TRUE because formal parameters
                mapped by argument objects are always writable.

            3.  

        ii. If Desc.[[Writable]] is present and its value is FALSE,
            then

            1.  Call the [[Delete]] internal method of map passing P
                as the argument.

8.  Return TRUE.

[[Get]] (P, Receiver)

The [[Get]] internal method of an arguments exotic object when called
with a property name P and ECMAScript language value Receiver
performs the following steps:

1.  Let args be the arguments object.

2.  Let map be the value of the [[ParameterMap]] internal slot of the
    arguments object.

3.  Let isMapped be HasOwnProperty(map, P).

4.  Assert: isMapped is not an abrupt completion.

5.  If the value of isMapped is FALSE, then

    a.  Let v be the result of calling the default ordinary object
        [[Get]] internal method (9.1.8) on args passing P and
        Receiver as the arguments.

6.  Else map contains a formal parameter mapping for P,

7.  a.  Let v be Get(map, P).

8.  ReturnIfAbrupt(v).

9.  

10. Return v.

[[Set]] ( P, V, Receiver)

The [[Set]] internal method of an arguments exotic object when called
with property key P, value V, and ECMAScript language value
Receiver performs the following steps:

1.  Let args be the arguments object.

2.  If SameValue(args, Receiver) is FALSE, then

    a.  Let isMapped be UNDEFINED.

3.  Else,

    a.  Let map be the value of the [[ParameterMap]] internal slot of
        the arguments object.

    b.  Let isMapped be HasOwnProperty(map, P).

    c.  Assert: isMapped is not an abrupt completion.

4.  If the value of isMapped is FALSE, then

    a.  Return the result of calling the default ordinary object [[Set]]
        internal method (9.1.9) on args passing P, V and
        Receiver as the arguments.

5.  Else map contains a formal parameter mapping for P,

6.  a.  Return Put(map, P, V, FALSE).

 [[Delete]] (P)

The [[Delete]] internal method of an arguments exotic object when called
with a property key P performs the following steps:

1.  Let map be the value of the [[ParameterMap]] internal slot of the
    arguments object.

2.  Let isMapped be HasOwnProperty(map, P).

3.  Assert: isMapped is not an abrupt completion.

4.  Let result be the result of calling the default [[Delete]]
    internal method for ordinary objects (9.1.10) on the arguments
    object passing P as the argument.

5.  ReturnIfAbrupt(result).

6.  If result is TRUE and the value of isMapped is TRUE, then

    a.  Call the [[Delete]] internal method of map passing P as the
        argument.

7.  Return result.

CreateUnmappedArgumentsObject(argumentsList) Abstract Operation

The abstract operation CreateUnmappedArgumentsObject called with an
argument argumentsList performs the following steps:

1.  Let len be the number of elements in argumentsList.

2.  Let obj be ObjectCreate(%ObjectPrototype%, «‍[[ParameterMap]]»).

3.  Set obj’s [[ParameterMap]] internal slot to UNDEFINED.

4.  Perform DefinePropertyOrThrow(obj, "LENGTH",
    PropertyDescriptor{[[Value]]: len, [[Writable]]: TRUE,
    [[Enumerable]]: FALSE, [[Configurable]]: TRUE}).

5.  Let index be 0.

6.  Repeat while index < len,

7.  a.  Let val be the element of argumentsList_[_index].

    b.  Perform CreateDataProperty(obj, ToString(index), val).

    c.  Let index be index + 1

1.  Perform DefinePropertyOrThrow(obj, @@iterator, PropertyDescriptor
    {[[Value]]:%ArrayProto_values%, [[Writable]]: TRUE, [[Enumerable]]:
    FALSE, [[Configurable]]: TRUE}).

2.  Perform DefinePropertyOrThrow(obj, "CALLER", PropertyDescriptor
    {[[Get]]: %ThrowTypeError%, [[Set]]: %ThrowTypeError%,
    [[Enumerable]]: FALSE, [[Configurable]]: FALSE}).

3.  Perform DefinePropertyOrThrow(obj, "CALLEE", PropertyDescriptor
    {[[Get]]: %ThrowTypeError%, [[Set]]: %ThrowTypeError%,
    [[Enumerable]]: FALSE, [[Configurable]]: FALSE}).

4.  Assert: the above property definitions will not produce an abrupt
    completion.

5.  Return obj

CreateMappedArgumentsObject ( func, formals, argumentsList, env ) Abstract Operation

The abstract operation CreateMappedArgumentsObject is called with object
func, grammar production formals, List argumentsList, and
environment record env. The following steps are performed:

1.  Assert: formals does not contain a rest parameter, any binding
    patterns, or any initializers. It may contain duplicate identifiers.

2.  Let len be the number of elements in argumentsList.

3.  Let obj be a newly created arguments exotic object with a
    [[ParameterMap]] internal slot.

4.  Set the [[GetOwnProperty]] internal method of obj as specified in
    9.4.4.1.

5.  Set the [[DefineOwnProperty]] internal method of obj as specified
    in 9.4.4.2.

6.  Set the [[Get]] internal method of obj as specified in 9.4.4.3.

7.  Set the [[Set]] internal method of obj as specified in 9.4.4.4.

8.  Set the [[Delete]] internal method of obj as specified in 9.4.4.5.

9.  Set the remainder of obj’s essential internal methods to the
    default ordinary object definitions specified in 9.1.

10. Set the [[Prototype]] internal slot of obj to %ObjectPrototype%.

11. Set the [[Extensible]] internal slot of obj to TRUE.

12. Let parameterNames be the BoundNames of formals.

13. Let numberOfParameters be the number of elements in
    parameterNames

14. Let index be 0.

15. Repeat while index < len ,

16. a.  Let val be the element of argumentsList_[_index].

    b.  Perform CreateDataProperty(obj, ToString(index), val).

    c.  Let index be index + 1

17. Perform DefinePropertyOrThrow(obj, "LENGTH",
    PropertyDescriptor{[[Value]]: len, [[Writable]]: TRUE,
    [[Enumerable]]: FALSE, [[Configurable]]: TRUE}).

18. Let map be ObjectCreate(NULL).

19. Let mappedNames be an empty List.

20. Let index be numberOfParameters − 1.

21. Repeat while index ≥ 0 ,

22. a.  Let name be the element of parameterNames_[_index].

    b.  If name is not an element of mappedNames, then

        i.  Add name as an element of the list mappedNames.

        ii. If index < len, then

        iii. 1.  Let g be MakeArgGetter(name, env).

            2.  Let p be MakeArgSetter(name, env).

            3.  Call the [[DefineOwnProperty]] internal method of map
                passing ToString(index) and the
                PropertyDescriptor{[[Set]]: p, [[Get]]:
                g,[[Enumerable]]: FALSE, [[Configurable]]: TRUE} as
                arguments.

    c.  Let index be index − 1

23. Set the [[ParameterMap]] internal slot of obj to map.

24. Perform DefinePropertyOrThrow(obj, @@iterator, PropertyDescriptor
    {[[Value]]:%ArrayProto_values%, [[Writable]]: TRUE, [[Enumerable]]:
    FALSE, [[Configurable]]: TRUE}).

25. Perform DefinePropertyOrThrow(obj, "CALLEE", PropertyDescriptor
    {[[Value]]: func, [[Writable]]: TRUE, [[Enumerable]]: FALSE,
    [[Configurable]]: TRUE}).

26. Assert: the above property definitions will not produce an abrupt
    completion.

27. Return obj

MakeArgGetter ( name, env) Abstract Operation

The abstract operation MakeArgGetter called with String name and
environment record env creates a built-in function object that when
executed returns the value bound for name in env. It performs the
following steps:

1.  Let realm be the current Realm.

2.  Let steps be the steps of an ArgGetter function as specified
    below.

3.  Let getter be CreateBuiltinFunction(realm, steps,
    %FunctionPrototype%, «‍[[name]], [[env]]» ).

4.  Set getter’s [[name]] internal slot to name.

5.  Set getter’s [[env]] internal slot to env.

6.  Return getter.

An ArgGetter function is an anonymous built-in function with [[name]]
and [[env]] internal slots. When an ArgGetter function f that expects
no arguments is called it performs the following steps:

1.  Let name be the value of f’s [[name]] internal slot.

2.  Let env be the value of f’s [[env]] internal slot

3.  4.  Return the result of calling the GetBindingValue concrete method
    of env with arguments name and FALSE.

NOTE ArgGetter functions are never directly accessible to ECMAScript
code.

MakeArgSetter ( name, env) Abstract Operation

The abstract operation MakeArgSetter called with String name and
environment record env creates a built-in function object that when
executed sets the value bound for name in env. It performs the
following steps:

1.  Let realm be the current Realm.

2.  Let steps be the steps of an ArgSetter function as specified
    below.

3.  Let setter be CreateBuiltinFunction(realm, steps,
    %FunctionPrototype%, «‍[[name]], [[env]]» ).

4.  Set setter’s [[name]] internal slot to name.

5.  Set setter’s [[env]] internal slot to env.

6.  Return setter.

An ArgSetter function is an anonymous built-in function with [[name]]
and [[env]] internal slots. When an ArgSetter function f is called
with argument value it performs the following steps:

1.  Let name be the value of f’s [[name]] internal slot.

2.  Let env be the value of f’s [[env]] internal slot

3.  4.  Return the result of calling the SetMutableBinding concrete
    method of env with arguments name, value, and FALSE.

NOTE ArgSetter functions are never directly accessible to ECMAScript
code.

Integer Indexed Exotic Objects

An _Integer Indexed object_ is an exotic object that performs special
handling of integer index property keys.

Integer Indexed exotic objects have the same internal slots as ordinary
objects additionally [[ViewedArrayBuffer]], [[ArrayLength]],
[[ByteOffset]], and [[TypedArrayName]] internal slots.

Integer Indexed Exotic objects provide alternative definitions for the
following internal methods. All of the other Integer Indexed exotic
object essential internal methods that are not defined below are as
specified in 9.1.

[[GetOwnProperty]] ( P )

When the [[GetOwnProperty]] internal method of an Integer Indexed exotic
object O is called with property key P the following steps are
taken:

1.  Assert: IsPropertyKey(P) is TRUE.

2.  Assert: O is an Object that has a [[ViewedArrayBuffer]] internal
    slot.

3.  If Type(P) is String, then

    a.  Let numericIndex be CanonicalNumericIndexString(P).

    b.  Assert: numericIndex is not an abrupt completion.

    c.  If numericIndex is not UNDEFINED, then

    d.  i.  Let value be IntegerIndexedElementGet (O,
            numericIndex).

        ii. ReturnIfAbrupt(value).

        iii. If value is UNDEFINED, return UNDEFINED.

        iv. Return a PropertyDescriptor{ [[Value]]: value,
            [[Enumerable]]: TRUE, [[Writable]]: TRUE, [[Configurable]]:
            FALSE }.

4.  Return OrdinaryGetOwnProperty(O, P).

[[HasProperty]](P)

When the [[HasProperty]] internal method of an Integer Indexed exotic
object O is called with property key P, the following steps are
taken:

1.  Assert: IsPropertyKey(P) is TRUE.

2.  Assert: O is an Object that has a [[ViewedArrayBuffer]] internal
    slot.

3.  If Type(P) is String, then

    a.  Let numericIndex be CanonicalNumericIndexString(P).

    b.  Assert: numericIndex is not an abrupt completion.

    c.  If numericIndex is not UNDEFINED, then

        i.  Let buffer be the value of O’s [[ViewedArrayBuffer]]
            internal slot.

        ii. If IsDetachedBuffer(buffer) is TRUE, throw a TYPEERROR
            exception.

        iii. If IsInteger(index) is FALSE, return FALSE

        iv. If index = −0, return FALSE.

        v.  Return TRUE.

4.  Return OrdinaryHasProperty(O, P).

[[DefineOwnProperty]] ( P, Desc)

When the [[DefineOwnProperty]] internal method of an Integer Indexed
exotic object O is called with property key P, and Property
Descriptor Desc the following steps are taken:

1.  Assert: IsPropertyKey(P) is TRUE.

2.  Assert: O is an Object that has a [[ViewedArrayBuffer]] internal
    slot.

3.  If Type(P) is String, then

    a.  b.  Let numericIndex be CanonicalNumericIndexString (P).

    c.  Assert: numericIndex is not an abrupt completion.

    d.  If numericIndex is not UNDEFINED, then

    e.  i.  

    a.  i.  ii. If IsInteger(numericIndex) is FALSE, return FALSE

        iii. iv. Let intIndex be numericIndex.

        v.  If intIndex = −0, return FALSE.

        vi. If intIndex < 0, return FALSE.

        vii. Let length be the value of O’s [[ArrayLength]] internal
            slot.

        viii. If intIndex ≥ length, return FALSE.

        ix. If IsAccessorDescriptor(Desc) is TRUE, return FALSE.

        x.  If Desc has a [[Configurable]] field and if
            Desc.[[Configurable]] is TRUE, return FALSE.

        xi. If Desc has an [[Enumerable]] field and if
            Desc.[[Enumerable]] is FALSE, return FALSE.

        xii. If Desc has a [[Writable]] field and if
            Desc.[[Writable]] is FALSE, return FALSE.

        xiii. If Desc has a [[Value]] field, then

        xiv. 1.  Let value be Desc.[[Value]].

            2.  Let status be IntegerIndexedElementSet (O,
                intIndex, value).

            3.  ReturnIfAbrupt(status).

        xv. Return TRUE.

4.  Return OrdinaryDefineOwnProperty(O, P, Desc).

[[Get]] (P, Receiver)

When the [[Get]] internal method of an Integer Indexed exotic object O
is called with property key P and ECMAScript language value Receiver
the following steps are taken:

1.  Assert: IsPropertyKey(P) is TRUE.

2.  If Type(P) is String and if SameValue(O, Receiver) is TRUE,
    then

    a.  Let numericIndex be CanonicalNumericIndexString (P).

    b.  Assert: numericIndex is not an abrupt completion.

    c.  If numericIndex is not UNDEFINED, then

    d.  i.  Return IntegerIndexedElementGet (O, numericIndex).

3.  Return the result of calling the default ordinary object [[Get]]
    internal method (9.1.8) on O passing P and Receiver as
    arguments.

[[Set]] ( P, V, Receiver)

When the [[Set]] internal method of an Integer Indexed exotic object O
is called with property key P, value V, and ECMAScript language
value Receiver, the following steps are taken:

1.  Assert: IsPropertyKey(P) is TRUE.

2.  If Type(P) is String and if SameValue(O, Receiver) is TRUE,
    then

    a.  Let numericIndex be CanonicalNumericIndexString (P).

    b.  Assert: numericIndex is not an abrupt completion.

    c.  If numericIndex is not UNDEFINED, then

    d.  i.  Return IntegerIndexedElementSet (O, numericIndex, V).

3.  Return the result of calling the default ordinary object [[Set]]
    internal method (9.1.8) on O passing P, V, and Receiver as
    arguments.

[[Enumerate]] ()

When the [[Enumerate]] internal method of an Integer Indexed exotic
object O is called the following steps are taken:

1.  Let indexKeys be a new empty List.

2.  Assert: O is an Object that has [[ViewedArrayBuffer]],
    [[ArrayLength]], [[ByteOffset]], and [[TypedArrayName]] internal
    slots.

3.  4.  5.  Let len be the value of O’s [[ArrayLength]] internal
    slot.

6.  For each integer i starting with 0 such that i < len, in
    ascending order,

    a.  Add ToString(i) as the last element of indexKeys.

7.  Let ordinary be the result of calling the default ordinary object
    [[Enumerate]] internal method (9.1.11) on O.

8.  ReturnIfAbrupt(ordinary).

9.  Return CreateCompoundIterator(CreateListIterator(indexKeys),
    ordinary_)_.

10. 

[[OwnPropertyKeys]] ()

When the [[OwnPropertyKeys]] internal method of an Integer Indexed
exotic object O is called the following steps are taken:

1.  Let keys be a new empty List.

2.  Assert: O is an Object that has [[ViewedArrayBuffer]],
    [[ArrayLength]], [[ByteOffset]], and [[TypedArrayName]] internal
    slots.

3.  4.  5.  Let len be the value of O’s [[ArrayLength]] internal
    slot.

6.  For each integer i starting with 0 such that i < len, in
    ascending order,

    a.  Add ToString(i) as the last element of keys.

7.  a.  

8.  For each own property key P of O such that Type(P) is String
    and P is not an integer index, in property creation order

    a.  Add P as the last element of keys.

9.  For each own property key P of O such that Type(P) is Symbol,
    in property creation order

    a.  Add P as the last element of keys.

10. Return keys.

IntegerIndexedObjectCreate (prototype, internalSlotsList) Abstract Operation

The abstract operation IntegerIndexedObjectCreate with arguments
prototype and internalSlotsList is used to specify the creation of
new Integer Indexed exotic objects. The argument internalSlotsList is
a List of the names of additional internal slots that must be defined as
part of the object. IntegerIndexedObjectCreate performs the following
steps:

1.  Let A be a newly created object with an internal slot for each
    name in internalSlotsList.

2.  Set A’s essential internal methods to the default ordinary object
    definitions specified in 9.1.

3.  Set the [[GetOwnProperty]] internal method of A as specified in
    9.4.5.1.

4.  Set the [[DefineOwnProperty]] internal method of A as specified in
    9.4.5.2.

5.  Set the [[Get]] internal method of A as specified in 9.4.5.3.

6.  Set the [[Set]] internal method of A as specified in 9.4.5.4.

7.  Set the [[Enumerate]] internal method of A as specified in
    9.4.5.5.

8.  Set the [[OwnPropertyKeys]] internal method of A as specified in
    9.4.5.6.

9.  Set the [[Prototype]] internal slot of A to prototype.

10. Set the [[Extensible]] internal slot of A to TRUE.

11. Return A.

IntegerIndexedElementGet ( O, index ) Abstract Operation

The abstract operation IntegerIndexedElementGet with arguments O and
index performs the following steps:

1.  Assert: Type(index) is Number.

2.  Assert: O is an Object that has [[ViewedArrayBuffer]],
    [[ArrayLength]], [[ByteOffset]], and [[TypedArrayName]] internal
    slots.

3.  Let buffer be the value of O’s [[ViewedArrayBuffer]] internal
    slot.

4.  5.  If IsDetachedBuffer(buffer) is TRUE, throw a TYPEERROR
    exception.

6.  If IsInteger(index) is FALSE, return UNDEFINED

7.  8.  If index = −0, return UNDEFINED.

9.  Let length be the value of O’s [[ArrayLength]] internal slot.

10. If index < 0 or index ≥ length, return UNDEFINED.

11. Let offset be the value of O’s [[ByteOffset]] internal slot.

12. Let arrayTypeName be the string value of O’s [[TypedArrayName]]
    internal slot.

13. Let elementSize be the Number value of the Element Size value
    specified in Table 46 for arrayTypeName.

14. Let indexedPosition = (index × elementSize) + offset.

15. Let elementType be the string value of the Element Type value in
    Table 46 for arrayTypeName.

16. Return GetValueFromBuffer(buffer, indexedPosition,
    elementType).

IntegerIndexedElementSet ( O, index, value ) Abstract Operation

The abstract operation IntegerIndexedElementSet with arguments O,
index, and value performs the following steps:

1.  Assert: Type(index) is Number.

2.  Assert: O is an Object that has [[ViewedArrayBuffer]],
    [[ArrayLength]], [[ByteOffset]], and [[TypedArrayName]] internal
    slots.

3.  Let numValue be ToNumber(value).

4.  ReturnIfAbrupt(numValue).

5.  Let buffer be the value of O’s [[ViewedArrayBuffer]] internal
    slot.

6.  7.  If IsDetachedBuffer(buffer) is TRUE, throw a TYPEERROR
    exception.

8.  If IsInteger(index) is FALSE, return FALSE

9.  10. If index = −0, return FALSE.

11. 12. Let length be the value of O’s [[ArrayLength]] internal
    slot.

13. 14. 15. If index < 0 or index ≥ length, return FALSE.

16. Let offset be the value of O’s [[ByteOffset]] internal slot.

17. Let arrayTypeName be the string value of O’s [[TypedArrayName]]
    internal slot.

18. Let elementSize be the Number value of the Element Size value
    specified in Table 46 for arrayTypeName.

19. Let indexedPosition = (index × elementSize) + offset.

20. Let elementType be the string value of the Element Type value in
    Table 46 for arrayTypeName.

21. Let status be SetValueInBuffer(buffer, indexedPosition,
    elementType, numValue).

22. ReturnIfAbrupt(status).

23. Return TRUE.

Module Namespace Exotic Objects

A _module namespace object_ is an exotic object that exposes the
bindings exported from an ECMAScript Module (See 15.2.3). There is a
one-to-one correspondence between the String-keyed own properties of a
module namespace exotic object and the binding names exported by the
Module. The exported bindings include any bindings that are indirectly
exported using export * export items. Each String-valued own property
key is the StringValue of the corresponding exported binding name. These
are the only String-keyed properties of a module namespace exotic
object. Each such property has the attributes {[[Configurable]]: FALSE,
[[Enumerable]]: TRUE}. Module namespace objects are not extensible.

Module namespace objects have the internal slots defined in Table 30.

Table 30 — Internal Slots of Module Namespace Exotic Objects

  _INTERNAL SLOT_   TYPE           DESCRIPTION
  ----------------- ---------------- --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  [[Module]]        Module Record    The Module Record whose exports this namespace exposes.
                                     
  [[Exports]]       List of String   A List containing the String values of the exported names exposed as own properties of this object. The list is ordered as if an Array of those string values had been sorted using ARRAY.PROTOTYPE.SORT using SortCompare as comparefn.
                                     

Module namespace exotic objects provide alternative definitions for all
of the internal methods.

[[GetPrototypeOf]] ( )

When the [[GetPrototypeOf]] internal method of a module namespace exotic
object O is called the following steps are taken:

1.  Return NULL.

[[SetPrototypeOf]] (V)

When the [[SetPrototypeOf]] internal method of a module namespace exotic
object O is called with argument V the following steps are taken:

1.  Assert: Either Type(V) is Object or Type(V) is Null.

2.  Return FALSE.

[[IsExtensible]] ( )

When the [[IsExtensible]] internal method of a module namespace exotic
object O is called the following steps are taken:

1.  Return FALSE.

[[PreventExtensions]] ( )

When the [[PreventExtensions]] internal method of a module namespace
exotic object O is called the following steps are taken:

1.  Return TRUE.

[[GetOwnProperty]] (P)

When the [[GetOwnProperty]] internal method of a module namespace exotic
object O is called with property key P, the following steps are
taken:

1.  If Type(P) is Symbol, return OrdinaryGetOwnProperty(O, P).

2.  Throw a TYPEERROR exception.

[[DefineOwnProperty]] (P, Desc)

When the [[DefineOwnProperty]] internal method of a module namespace
exotic object O is called with property key P and Property
Descriptor Desc, the following steps are taken:

1.  Return FALSE.

[[HasProperty]] (P)

When the [[HasProperty]] internal method of a module namespace exotic
object O is called with property key P, the following steps are
taken:

1.  If Type(P) is Symbol, return OrdinaryHasProperty(O, P).

2.  Let exports be the value of O’s [[Exports]] internal slot.

3.  If P is an element of exports, return TRUE.

4.  Return FALSE.

 [[Get]] (P, Receiver)

When the [[Get]] internal method of a module namespace exotic object O
is called with property key P and ECMAScript language value Receiver
the following steps are taken:

1.  Assert: IsPropertyKey(P) is TRUE.

2.  If Type(P) is Symbol, then

3.  a.  Return the result of calling the default ordinary object [[Get]]
        internal method (9.1.8) on O passing P and Receiver as
        arguments.

4.  Let exports be the value of O’s [[Exports]] internal slot.

5.  If P is not an element of exports, return UNDEFINED.

6.  Let m be the value of O’s [[Module]] internal slot.

7.  8.  9.  10. Let binding be ResolveExport(m, P, «» ).

11. If binding is an abrupt completion, then

    a.  Assert: The binding for P exported by the module is ambiguous.

    b.  Throw a REFERENCEERROR exception.

12. Let binding be binding.[[value]].

13. Assert: binding is not NULL.

14. Let targetModule be binding.[[module]],

15. 16. Assert: targetModule is not UNDEFINED.

17. 18. Let targetEnvRec be targetModule.[[Environment]]’s
    environment record.

19. Return the result of calling the GetBindingValue concrete method of
    targetEnvRec with arguments binding.[[bindingName]] and TRUE.

NOTE ResolveExport is idempotent and side-effect free. An implementation
might choose to pre-compute or cache the ResolveExport results for the
[[Exports]] of each module namespace exotic object.

[[Set]] ( P, V, Receiver)

When the [[Set]] internal method of a module namespace exotic object O
is called with property key P, value V, and ECMAScript language
value Receiver, the following steps are taken:

1.  Return FALSE.

[[Delete]] (P)

When the [[Delete]] internal method of a module namespace exotic object
O is called with property key P the following steps are taken:

1.  Assert: IsPropertyKey(P) is TRUE.

2.  Let exports be the value of O’s [[Exports]] internal slot.

3.  If P is an element of exports, return FALSE.

4.  Return TRUE.

[[Enumerate]] ()

When the [[Enumerate]] internal method of a module namespace exotic
object O is called the following steps are taken:

1.  Let exports be the value of O’s [[Exports]] internal slot.

2.  Return CreateListIterator(exports).

[[OwnPropertyKeys]] ( )

When the [[OwnPropertyKeys]] internal method of a namespace module
exotic object O is called the following steps are taken:

1.  Let exports be a copy of the value of O’s [[Exports]] internal
    slot.

2.  Let symbolKeys the result of calling the default ordinary object
    [[OwnPropertyKeys]] internal method (9.1.12) on O passing no
    arguments.

3.  Append all the entries of symbolKeys to the end of exports.

4.  Return exports.

ModuleNamespaceCreate (module, exports)

The abstract operation ModuleNamespaceCreate with arguments module,
and exports is used to specify the creation of new module namespace
exotic objects. It performs the following steps:

1.  Assert: module is a Module Record (see 15.2.1.15).

2.  Assert: module.[[Namespace]] is UNDEFINED.

3.  Assert: realm is a Realm Record.

4.  Assert: exports is a List of string values.

5.  Let M be a newly created object.

6.  Set M’s essential internal methods to the definitions specified in
    9.4.6.

7.  Set M’s [[Module]] internal slot to module.

8.  9.  Set M’s [[Exports]] internal slot to exports.

10. Create own properties of M corresponding to the definitions in
    26.3.

11. Set module.[[Namespace]] to M.

12. Return M.


Proxy Object Internal Methods and Internal Slots

A proxy object is an exotic object whose essential internal methods are
partially implemented using ECMAScript code. Every proxy objects has an
internal slot called [[ProxyHandler]]. The value of [[ProxyHandler]] is
an object, called the proxy’s _handler object_, or NULL. Methods (see
Table 31) of a handler object may be used to augment the implementation
for one or more of the proxy object’s internal methods. Every proxy
object also has an internal slot called [[ProxyTarget]] whose value is
either an object or the NULL value. This object is called the proxy’s
_target object_.

Table 31 — Proxy Handler Methods

  _INTERNAL METHOD_       _HANDLER METHOD_
  ----------------------- --------------------------
  [[GetPrototypeOf]]      GETPROTOTYPEOF
  [[SetPrototypeOf]]      SETPROTOTYPEOF
  [[IsExtensible]]        ISEXTENSIBLE
  [[PreventExtensions]]   PREVENTEXTENSIONS
  [[GetOwnProperty]]      GETOWNPROPERTYDESCRIPTOR
  [[HasProperty]]         HAS
  [[Get]]                 GET
  [[Set]]                 SET
  [[Delete]]              DELETEPROPERTY
  [[DefineOwnProperty]]   DEFINEPROPERTY
  [[Enumerate]]           ENUMERATE
  [[OwnPropertyKeys]]     OWNKEYS
  [[Call]]                APPLY
  [[Construct]]           CONSTRUCT

When a handler method is called to provide the implementation of a proxy
object internal method, the handler method is passed the proxy’s target
object as a parameter. A proxy’s handler object does not necessarily
have a method corresponding to every essential internal method. Invoking
an internal method on the proxy results in the invocation of the
corresponding internal method on the proxy’s target object if the
handler object does not have a method corresponding to the internal
trap.

The [[ProxyHandler]] and [[ProxyTarget]] internal slots of a proxy
object are always initialized when the object is created and typically
may not be modified. Some proxy objects are created in a manner that
permits them to be subsequently revoked. When a proxy is revoked, its
[[ProxyHander]] and [[ProxyTarget]] internal slots are set to NULL
causing subsequent invocations of internal methods on that proxy object
to throw a TYPEERROR exception.

Because proxy objects permit the implementation of internal methods to
be provided by arbitrary ECMAScript code, it is possible to define a
proxy object whose handler methods violates the invariants defined in
6.1.7.3. Some of the internal method invariants defined in 6.1.7.3 are
essential integrity invariants. These invariants are explicitly enforced
by the proxy object internal methods specified in this section. An
ECMAScript implementation must be robust in the presence of all possible
invariant violations.

In the following algorithm descriptions, assume O is an ECMAScript
proxy object, P is a property key value, V is any ECMAScript
language value and Desc is a Property Descriptor record.

[[GetPrototypeOf]] ( )

When the [[GetPrototypeOf]] internal method of an exotic Proxy object
O is called the following steps are taken:

1.  Let handler be the value of the [[ProxyHandler]] internal slot of
    O.

2.  3.  If handler is NULL, throw a TYPEERROR exception.

4.  Assert: Type(handler) is Object.

5.  Let target be the value of the [[ProxyTarget]] internal slot of
    O.

6.  7.  Let trap be GetMethod(handler, "GETPROTOTYPEOF").

8.  ReturnIfAbrupt(trap).

9.  If trap is UNDEFINED, then

    a.  Return the result of calling the [[GetPrototypeOf]] internal
        method of target.

10. Let handlerProto be Call(trap, handler, «target»).

11. ReturnIfAbrupt(handlerProto).

12. If Type(handlerProto) is neither Object nor Null, throw a
    TYPEERROR exception.

13. Let extensibleTarget be IsExtensible(target).

14. ReturnIfAbrupt(extensibleTarget).

15. If extensibleTarget is TRUE, return handlerProto.

16. Let targetProto be the result of calling the [[GetPrototypeOf]]
    internal method of target.

17. ReturnIfAbrupt(targetProto).

18. If SameValue(handlerProto, targetProto) is FALSE, throw a
    TYPEERROR exception.

19. Return handlerProto.

NOTE [[GetPrototypeOf]] for proxy objects enforces the following
invariant:

-   The result of [[GetPrototypeOf]] must be either an Object or NULL.

-   If the target object is not extensible, [[GetPrototypeOf]] applied
    to the proxy object must return the same value as [[GetPrototypeOf]
    applied to the proxy object’s target object.

[[SetPrototypeOf]] (V)

When the [[SetPrototypeOf]] internal method of an exotic Proxy object
O is called with argument V the following steps are taken:

1.  Assert: Either Type(V) is Object or Type(V) is Null.

2.  Let handler be the value of the [[ProxyHandler]] internal slot of
    O.

3.  4.  If handler is NULL, throw a TYPEERROR exception.

5.  Assert: Type(handler) is Object.

6.  Let target be the value of the [[ProxyTarget]] internal slot of
    O.

7.  8.  Let trap be GetMethod(handler, "SETPROTOTYPEOF").

9.  ReturnIfAbrupt(trap).

10. If trap is UNDEFINED, then

    a.  Return the result of calling the [[SetPrototypeOf]] internal
        method of target with argument V.

11. Let booleanTrapResult be ToBoolean(Call(trap, handler,
    «target, V»)).

12. 13. ReturnIfAbrupt(booleanTrapResult).

14. Let extensibleTarget be IsExtensible(target).

15. ReturnIfAbrupt(extensibleTarget).

16. If extensibleTarget is TRUE, return booleanTrapResult.

17. Let targetProto be the result of calling the [[GetPrototypeOf]]
    internal method of target.

18. ReturnIfAbrupt(targetProto).

19. If booleanTrapResult is TRUE and SameValue(V, targetProto) is
    FALSE, throw a TYPEERROR exception.

20. Return booleanTrapResult.

NOTE [[SetPrototypeOf]] for proxy objects enforces the following
invariant:

-   If the target object is not extensible, the argument value must be
    the same as the result of [[GetPrototypeOf]] applied to target
    object.

[[IsExtensible]] ( )

When the [[IsExtensible]] internal method of an exotic Proxy object O
is called the following steps are taken:

1.  Let handler be the value of the [[ProxyHandler]] internal slot of
    O.

2.  3.  If handler is NULL, throw a TYPEERROR exception.

4.  Assert: Type(handler) is Object.

5.  Let target be the value of the [[ProxyTarget]] internal slot of
    O.

6.  7.  Let trap be GetMethod(handler, "ISEXTENSIBLE").

8.  ReturnIfAbrupt(trap).

9.  If trap is UNDEFINED, then

    a.  Return the result of calling the [[IsExtensible]] internal
        method of target.

10. Let booleanTrapResult be ToBoolean(Call(trap, handler,
    «target»)).

11. 12. ReturnIfAbrupt(booleanTrapResult).

13. Let targetResult be the result of calling the [[IsExtensible]]
    internal method of target.

14. ReturnIfAbrupt(targetResult).

15. If SameValue(booleanTrapResult, targetResult) is FALSE, throw a
    TYPEERROR exception.

16. Return booleanTrapResult.

NOTE [[IsExtensible]] for proxy objects enforces the following
invariant:

-   [[IsExtensible]] applied to the proxy object must return the same
    value as [[IsExtensible]] applied to the proxy object’s target
    object with the same argument.

[[PreventExtensions]] ( )

When the [[PreventExtensions]] internal method of an exotic Proxy object
O is called the following steps are taken:

1.  Let handler be the value of the [[ProxyHandler]] internal slot of
    O.

2.  3.  If handler is NULL, throw a TYPEERROR exception.

4.  Assert: Type(handler) is Object.

5.  Let target be the value of the [[ProxyTarget]] internal slot of
    O.

6.  7.  Let trap be GetMethod(handler, "PREVENTEXTENSIONS").

8.  ReturnIfAbrupt(trap).

9.  If trap is UNDEFINED, then

    a.  Return the result of calling the [[PreventExtensions]] internal
        method of target.

10. Let booleanTrapResult be ToBoolean(Call(trap, handler,
    «target»)).

11. 12. ReturnIfAbrupt(booleanTrapResult).

13. If booleanTrapResult is TRUE, then

    a.  Let targetIsExtensible be the result of calling the
        [[IsExtensible]] internal method of target.

    b.  ReturnIfAbrupt(targetIsExtensible).

    c.  If targetIsExtensible is TRUE, throw a TYPEERROR exception.

14. Return booleanTrapResult.

NOTE [[PreventExtensions]] for proxy objects enforces the following
invariant:

-   [[PreventExtensions]] applied to the proxy object only returns TRUE
    if [[IsExtensible]] applied to the proxy object’s target object is
    FALSE.

 [[GetOwnProperty]] (P)

When the [[GetOwnProperty]] internal method of an exotic Proxy object
O is called with property key P, the following steps are taken:

1.  Assert: IsPropertyKey(P) is TRUE.

2.  Let handler be the value of the [[ProxyHandler]] internal slot of
    O.

3.  4.  If handler is NULL, throw a TYPEERROR exception.

5.  Assert: Type(handler) is Object.

6.  Let target be the value of the [[ProxyTarget]] internal slot of
    O.

7.  8.  Let trap be GetMethod(handler, "GETOWNPROPERTYDESCRIPTOR").

9.  ReturnIfAbrupt(trap).

10. If trap is UNDEFINED, then

    a.  Return the result of calling the [[GetOwnProperty]] internal
        method of target with argument P.

11. Let trapResultObj be Call(trap, handler, «target, P»).

12. ReturnIfAbrupt(trapResultObj).

13. If Type(trapResultObj) is neither Object nor Undefined, throw a
    TYPEERROR exception.

14. Let targetDesc be the result of calling the [[GetOwnProperty]]
    internal method of target with argument P.

15. ReturnIfAbrupt(targetDesc).

16. If trapResultObj is UNDEFINED, then

    a.  If targetDesc is UNDEFINED, return UNDEFINED.

    b.  If targetDesc.[[Configurable]] is FALSE, throw a TYPEERROR
        exception.

    c.  Let extensibleTarget be IsExtensible(target).

    d.  ReturnIfAbrupt(extensibleTarget).

    e.  If ToBoolean(extensibleTarget) is FALSE, throw a TYPEERROR
        exception.

    f.  Return UNDEFINED.

17. Let extensibleTarget be IsExtensible(target).

18. ReturnIfAbrupt(extensibleTarget).

19. Let resultDesc be ToPropertyDescriptor(trapResultObj).

20. ReturnIfAbrupt(resultDesc).

21. Call CompletePropertyDescriptor(resultDesc).

22. Let valid be IsCompatiblePropertyDescriptor (extensibleTarget,
    resultDesc, targetDesc).

23. If valid is FALSE, throw a TYPEERROR exception.

24. If resultDesc.[[Configurable]] is FALSE, then

    a.  If targetDesc is UNDEFINED or targetDesc.[[Configurable]] is
        TRUE, then

        i.  Throw a TYPEERROR exception.

        ii. 

25. Return resultDesc.

NOTE [[GetOwnProperty]] for proxy objects enforces the following
invariants:

-   The result of [[GetOwnProperty]] must be either an Object or
    UNDEFINED.

-   A property cannot be reported as non-existent, if it exists as a
    non-configurable own property of the target object.

-   A property cannot be reported as non-existent, if it exists as an
    own property of the target object and the target object is not
    extensible.

-   A property cannot be reported as existent, if it does not exists as
    an own property of the target object and the target object is not
    extensible.

-   A property cannot be reported as non-configurable, if it does not
    exists as an own property of the target object or if it exists as a
    configurable own property of the target object.

-   The result of [[GetOwnProperty]] can be applied to the target object
    using [[DefineOwnProperty]] and will not throw an exception.

[[DefineOwnProperty]] (P, Desc)

When the [[DefineOwnProperty]] internal method of an exotic Proxy object
O is called with property key P and Property Descriptor Desc, the
following steps are taken:

1.  Assert: IsPropertyKey(P) is TRUE.

2.  Let handler be the value of the [[ProxyHandler]] internal slot of
    O.

3.  4.  If handler is NULL, throw a TYPEERROR exception.

5.  Assert: Type(handler) is Object.

6.  Let target be the value of the [[ProxyTarget]] internal slot of
    O.

7.  8.  Let trap be GetMethod(handler, "DEFINEPROPERTY").

9.  ReturnIfAbrupt(trap).

10. If trap is UNDEFINED, then

    a.  Return the result of calling the [[DefineOwnProperty]] internal
        method of target with arguments P and Desc.

11. Let descObj be FromPropertyDescriptor(Desc).

12. 13. Let booleanTrapResult be ToBoolean(Call(trap, handler,
    «target, P, descObj»)).

14. 15. ReturnIfAbrupt(booleanTrapResult).

16. If booleanTrapResult is FALSE, return FALSE.

17. Let targetDesc be the result of calling the [[GetOwnProperty]]
    internal method of target with argument P.

18. ReturnIfAbrupt(targetDesc).

19. Let extensibleTarget be IsExtensible(target).

20. ReturnIfAbrupt(extensibleTarget).

21. If Desc has a [[Configurable]] field and if
    Desc.[[Configurable]] is FALSE, then

    a.  Let settingConfigFalse be TRUE.

22. Else let settingConfigFalse be FALSE.

23. If targetDesc is UNDEFINED, then

    a.  If extensibleTarget is FALSE, throw a TYPEERROR exception.

    b.  If settingConfigFalse is TRUE, throw a TYPEERROR exception.

24. Else targetDesc is not UNDEFINED,

    a.  If IsCompatiblePropertyDescriptor(extensibleTarget, Desc ,
        targetDesc) is FALSE, throw a TYPEERROR exception.

    b.  If settingConfigFalse is TRUE and
        targetDesc.[[Configurable]] is TRUE, throw a TYPEERROR
        exception.

25. Return TRUE.

NOTE [[DefineOwnProperty]] for proxy objects enforces the following
invariants:

-   A property cannot be added, if the target object is not extensible.

-   A property cannot be added as or modified to be non-configurable, if
    it does not exists as a non-configurable own property of the target
    object.

-   A property may not be non-configurable, if a corresponding
    configurable property of the target object exists.

-   If a property has a corresponding target object property then apply
    the Property Descriptor of the property to the target object using
    [[DefineOwnProperty]] will not throw an exception.

[[HasProperty]] (P)

When the [[HasProperty]] internal method of an exotic Proxy object O
is called with property key P, the following steps are taken:

1.  Assert: IsPropertyKey(P) is TRUE.

2.  Let handler be the value of the [[ProxyHandler]] internal slot of
    O.

3.  4.  If handler is NULL, throw a TYPEERROR exception.

5.  Assert: Type(handler) is Object.

6.  Let target be the value of the [[ProxyTarget]] internal slot of
    O.

7.  8.  Let trap be GetMethod(handler, "HAS").

9.  ReturnIfAbrupt(trap).

10. If trap is UNDEFINED, then

    a.  Return the result of calling the [[HasProperty]] internal method
        of target with argument P.

11. Let booleanTrapResult be ToBoolean(Call(trap, handler,
    «target, P»)).

12. 13. ReturnIfAbrupt(booleanTrapResult).

14. If booleanTrapResult is FALSE, then

    a.  Let targetDesc be the result of calling the [[GetOwnProperty]]
        internal method of target with argument P.

    b.  ReturnIfAbrupt(targetDesc).

    c.  If targetDesc is not UNDEFINED, then

        i.  If targetDesc.[[Configurable]] is FALSE, throw a TYPEERROR
            exception.

        ii. Let extensibleTarget be IsExtensible(target).

        iii. ReturnIfAbrupt(extensibleTarget).

        iv. If extensibleTarget is FALSE, throw a TYPEERROR exception.

15. Return booleanTrapResult.

NOTE [[HasProperty]] for proxy objects enforces the following
invariants:

-   A property cannot be reported as non-existent, if it exists as a
    non-configurable own property of the target object.

-   A property cannot be reported as non-existent, if it exists as an
    own property of the target object and the target object is not
    extensible.

[[Get]] (P, Receiver)

When the [[Get]] internal method of an exotic Proxy object O is called
with property key P and ECMAScript language value Receiver the
following steps are taken:

1.  Assert: IsPropertyKey(P) is TRUE.

2.  Let handler be the value of the [[ProxyHandler]] internal slot of
    O.

3.  4.  If handler is NULL, throw a TYPEERROR exception.

5.  Assert: Type(handler) is Object.

6.  Let target be the value of the [[ProxyTarget]] internal slot of
    O.

7.  8.  Let trap be GetMethod(handler, "GET").

9.  ReturnIfAbrupt(trap).

10. If trap is UNDEFINED, then

    a.  Return the result of calling the [[Get]] internal method of
        target with arguments P and Receiver.

11. Let trapResult be Call(trap, handler, «target, P,
    Receiver»).

12. ReturnIfAbrupt(trapResult).

13. Let targetDesc be the result of calling the [[GetOwnProperty]]
    internal method of target with argument P.

14. ReturnIfAbrupt(targetDesc).

15. If targetDesc is not UNDEFINED, then

    a.  If IsDataDescriptor(targetDesc) and
        targetDesc.[[Configurable]] is FALSE and
        targetDesc.[[Writable]] is FALSE, then

        i.  If SameValue(trapResult, targetDesc.[[Value]]) is FALSE,
            throw a TYPEERROR exception.

    b.  If IsAccessorDescriptor(targetDesc) and
        targetDesc.[[Configurable]] is FALSE and targetDesc.[[Get]]
        is UNDEFINED, then

        i.  If trapResult is not UNDEFINED, throw a TYPEERROR
            exception.

16. Return trapResult.

NOTE [[Get]] for proxy objects enforces the following invariants:

-   The value reported for a property must be the same as the value of
    the corresponding target object property if the target object
    property is a non-writable, non-configurable data property.

-   The value reported for a property must be UNDEFINED if the
    corresponding target object property is non-configurable accessor
    property that has UNDEFINED as its [[Get]] attribute.

[[Set]] ( P, V, Receiver)

When the [[Set]] internal method of an exotic Proxy object O is called
with property key P, value V, and ECMAScript language value
Receiver, the following steps are taken:

1.  Assert: IsPropertyKey(P) is TRUE.

2.  Let handler be the value of the [[ProxyHandler]] internal slot of
    O.

3.  4.  If handler is NULL, throw a TYPEERROR exception.

5.  Assert: Type(handler) is Object.

6.  Let target be the value of the [[ProxyTarget]] internal slot of
    O.

7.  8.  Let trap be GetMethod(handler, "SET").

9.  ReturnIfAbrupt(trap).

10. If trap is UNDEFINED, then

    a.  Return the result of calling the [[Set]] internal method of
        target with arguments P, V, and Receiver.

11. Let booleanTrapResult be ToBoolean(Call(trap, handler,
    «target, P, V, Receiver»)).

12. 13. ReturnIfAbrupt(booleanTrapResult).

14. If booleanTrapResult is FALSE, return FALSE.

15. Let targetDesc be the result of calling the [[GetOwnProperty]]
    internal method of target with argument P.

16. ReturnIfAbrupt(targetDesc).

17. If targetDesc is not UNDEFINED, then

    a.  If IsDataDescriptor(targetDesc) and
        targetDesc.[[Configurable]] is FALSE and
        targetDesc.[[Writable]] is FALSE, then

        i.  If SameValue(V, targetDesc.[[Value]]) is FALSE, throw a
            TYPEERROR exception.

    b.  If IsAccessorDescriptor(targetDesc) and
        targetDesc.[[Configurable]] is FALSE, then

        i.  If targetDesc.[[Set]] is UNDEFINED, throw a TYPEERROR
            exception.

18. Return TRUE.

NOTE [[Set]] for proxy objects enforces the following invariants:

-   Cannot change the value of a property to be different from the value
    of the corresponding target object property if the corresponding
    target object property is a non-writable, non-configurable data
    property.

-   Cannot set the value of a property if the corresponding target
    object property is a non-configurable accessor property that has
    UNDEFINED as its [[Set]] attribute.

 [[Delete]] (P)

When the [[Delete]] internal method of an exotic Proxy object O is
called with property name P the following steps are taken:

1.  Assert: IsPropertyKey(P) is TRUE.

2.  Let handler be the value of the [[ProxyHandler]] internal slot of
    O.

3.  4.  If handler is NULL, throw a TYPEERROR exception.

5.  Assert: Type(handler) is Object.

6.  Let target be the value of the [[ProxyTarget]] internal slot of
    O.

7.  8.  Let trap be GetMethod(handler, "DELETEPROPERTY").

9.  ReturnIfAbrupt(trap).

10. If trap is UNDEFINED, then

    a.  Return the result of calling the [[Delete]] internal method of
        target with argument P.

11. Let booleanTrapResult be ToBoolean(Call(trap, handler,
    «target, P»)).

12. 13. ReturnIfAbrupt(booleanTrapResult).

14. If booleanTrapResult is FALSE, return FALSE.

15. Let targetDesc be the result of calling the [[GetOwnProperty]]
    internal method of target with argument P.

16. ReturnIfAbrupt(targetDesc).

17. If targetDesc is UNDEFINED, return TRUE.

18. If targetDesc.[[Configurable]] is FALSE, throw a TYPEERROR
    exception.

19. Return TRUE.

NOTE [[Delete]] for proxy objects enforces the following invariant:

-   A property cannot be deleted, if it exists as a non-configurable own
    property of the target object.

[[Enumerate]] ()

When the [[Enumerate]] internal method of an exotic Proxy object O is
called the following steps are taken:

1.  Let handler be the value of the [[ProxyHandler]] internal slot of
    O.

2.  3.  If handler is NULL, throw a TYPEERROR exception.

4.  Assert: Type(handler) is Object.

5.  Let target be the value of the [[ProxyTarget]] internal slot of
    O.

6.  7.  Let trap be GetMethod(handler, "ENUMERATE").

8.  ReturnIfAbrupt(trap).

9.  If trap is UNDEFINED, then

    a.  Return the result of calling the [[Enumerate]] internal method
        of target.

10. Let trapResult be Call(trap, handler, «target»).

11. ReturnIfAbrupt(trapResult).

12. If Type(trapResult) is not Object, throw a TYPEERROR exception.

13. Return trapResult.

NOTE [[Enumerate]] for proxy objects enforces the following invariants:

-   The result of [[Enumerate]] must be an Object.

[[OwnPropertyKeys]] ( )

When the [[OwnPropertyKeys]] internal method of an exotic Proxy object
O is called the following steps are taken:

1.  Let handler be the value of the [[ProxyHandler]] internal slot of
    O.

2.  3.  If handler is NULL, throw a TYPEERROR exception.

4.  Assert: Type(handler) is Object.

5.  Let target be the value of the [[ProxyTarget]] internal slot of
    O.

6.  7.  Let trap be GetMethod(handler, "OWNKEYS").

8.  ReturnIfAbrupt(trap).

9.  If trap is UNDEFINED, then

    a.  Return the result of calling the [[OwnPropertyKeys]] internal
        method of target.

10. Let trapResultArray be Call(trap, handler, «target»).

11. Let trapResult be CreateListFromArrayLike(trapResultArray,
    «‍String, Symbol»).

12. ReturnIfAbrupt(trapResult).

13. 14. 15. Let extensibleTarget be IsExtensible(target).

16. ReturnIfAbrupt(extensibleTarget).

17. Let targetKeys be the result of calling the [[OwnPropertyKeys]]
    internal method of target.

18. ReturnIfAbrupt(targetKeys).

19. Assert: targetKeys is a List containing only String and Symbol
    values.

20. 21. 22. 23. Let targetConfigurableKeys be an empty List.

24. Let targetNonconfigurableKeys be an empty List.

25. 26. Repeat, for each element key of targetKeys,

    a.  b.  c.  Let desc the result of calling the [[GetOwnProperty]]
        internal method of target with argument key.

    d.  ReturnIfAbrupt(desc).

    e.  If desc is not UNDEFINED and desc.[[Configurable]] is FALSE,
        then

        i.  Append key as an element of targetNonconfigurableKeys.

    f.  Else,

        i.  Append key as an element of targetConfigurableKeys.

    g.  

27. If extensibleTarget is TRUE and targetNonconfigurableKeys is
    empty, then

    a.  Return trapResult.

28. 29. 30. Let uncheckedResultKeys be a new List which is a copy of
    trapResult.

31. 32. a.  b.  c.  d.  

33. Repeat, for each key that is an element of
    targetNonconfigurableKeys,

    a.  If key is not an element of uncheckedResultKeys, throw a
        TYPEERROR exception.

    b.  c.  Remove key from uncheckedResultKeys

34. If extensibleTarget is TRUE, return trapResult.

35. Repeat, for each key that is an element of
    targetConfigurableKeys,

    a.  If key is not an element of uncheckedResultKeys, throw a
        TYPEERROR exception.

    b.  c.  Remove key from uncheckedResultKeys

36. If uncheckedResultKeys is not empty, throw a TYPEERROR exception.

37. Return trapResult.

NOTE [[OwnPropertyKeys]] for proxy objects enforces the following
invariants:

-   The result of [[OwnPropertyKeys]] is a List.

-   The Type of each result List element is either String or Symbol.

-   The result List must contain the keys of all non-configurable own
    properties of the target object.

-   If the target object is not extensible, then the result List must
    contain all the keys of the own properties of the target object and
    no other values.

[[Call]] (thisArgument, argumentsList) 

The [[Call]] internal method of an exotic Proxy object O is called
with parameters thisArgument and argumentsList, a List of ECMAScript
language values. The following steps are taken:

1.  Let handler be the value of the [[ProxyHandler]] internal slot of
    O.

2.  3.  If handler is NULL, throw a TYPEERROR exception.

4.  Assert: Type(handler) is Object.

5.  Let target be the value of the [[ProxyTarget]] internal slot of
    O.

6.  7.  Let trap be GetMethod(handler, "APPLY").

8.  ReturnIfAbrupt(trap).

9.  If trap is UNDEFINED, then

    a.  Return Call(target, thisArgument, argumentsList).

10. Let argArray be CreateArrayFromList(argumentsList).

11. Return Call(trap, handler, «target, thisArgument,
    argArray»).

NOTE A Proxy exotic object only has a [[Call]] internal method if the
initial value of its [[ProxyTarget]] internal slot is an object that has
a [[Call]] internal method.

[[Construct]] ( argumentsList, newTarget)

The [[Construct]] internal method of an exotic Proxy object O is
called with parameters argumentsList which is a possibly empty List of
ECMAScript language values and newTarget. The following steps are
taken:

1.  Let handler be the value of the [[ProxyHandler]] internal slot of
    O.

2.  3.  If handler is NULL, throw a TYPEERROR exception.

4.  Assert: Type(handler) is Object.

5.  Let target be the value of the [[ProxyTarget]] internal slot of
    O.

6.  7.  Let trap be GetMethod(handler, "CONSTRUCT").

8.  ReturnIfAbrupt(trap).

9.  If trap is UNDEFINED, then

    a.  Assert: target has a [[Construct]] internal method.

    b.  Return Construct(target, argumentsList, newTarget).

10. Let argArray be CreateArrayFromList(argumentsList).

11. Let newObj be Call(trap, handler, «target, argArray,
    newTarget »).

12. ReturnIfAbrupt(newObj).

13. If Type(newObj) is not Object, throw a TYPEERROR exception.

14. Return newObj.

NOTE 1 A Proxy exotic object only has a [[Construct]] internal method if
the initial value of its [[ProxyTarget]] internal slot is an object that
has a [[Construct]] internal method.

NOTE 2 [[Construct]] for proxy objects enforces the following
invariants:

-   The result of [[Construct]] must be an Object.

ProxyCreate(target, handler) Abstract Operation

The abstract operation ProxyCreate with arguments target and handler
is used to specify the creation of new Proxy exotic objects. It performs
the following steps:

1.  If Type(target) is not Object, throw a TYPEERROR Exception.

2.  If Type(handler) is not Object, throw a TYPEERROR Exception.

3.  Let P be a newly created object.

4.  Set P’s essential internal methods (except for [[Call]] and
    [[Construct]]) to the definitions specified in 9.5.

5.  If IsCallable(target) is TRUE, then

    a.  Set the [[Call]] internal method of P as specified in 9.5.13.

    b.  If target has a [[Construct]] internal method, then

        i.  Set the [[Construct]] internal method of P as specified in
            9.5.14.

6.  Set the [[ProxyTarget]] internal slot of P to target.

7.  Set the [[ProxyHandler]] internal slot of P to handler.

8.  Return P.

9.  



ECMASCRIPT LANGUAGE: SOURCE CODE


Source Text

Syntax

SourceCharacter ::

  any Unicode code point

The ECMAScript code is expressed using Unicode, version 5.1 or later.
ECMAScript source text is a sequence of code points. All Unicode code
point values from U+0000 to U+10FFFF, including surrogate code points,
may occur in source text where permitted by the ECMAScript grammars. The
actual encodings used to store and interchange ECMAScript source text is
not relevant to this specification. Regardless of the external source
text encoding, a conforming ECMAScript implementation processes the
source text as if it was an equivalent sequence of SourceCharacter
values. Each SourceCharacter being a Unicode code point. Conforming
ECMAScript implementations are not required to perform any normalization
of text, or behave as though they were performing normalization of text.

The components of a combining character sequence are treated as
individual Unicode code points even though a user might think of the
whole sequence as a single character.

NOTE In string literals, regular expression literals, template literals
and identifiers, any Unicode code point may also be expressed using
Unicode escape sequences that explicitly express a code point’s numeric
value. Within a comment, such an escape sequence is effectively ignored
as part of the comment.

ECMAScript differs from the Java programming language in the behaviour
of Unicode escape sequences. In a Java program, if the Unicode escape
sequence \U000A, for example, occurs within a single-line comment, it is
interpreted as a line terminator (Unicode code point U+000A is line feed
(lf)) and therefore the next code point is not part of the comment.
Similarly, if the Unicode escape sequence \U000A occurs within a string
literal in a Java program, it is likewise interpreted as a line
terminator, which is not allowed within a string literal—one must write
\N instead of \U000A to cause a line feed (lf) to be part of the string
value of a string literal. In an ECMAScript program, a Unicode escape
sequence occurring within a comment is never interpreted and therefore
cannot contribute to termination of the comment. Similarly, a Unicode
escape sequence occurring within a string literal in an ECMAScript
program always contributes to the literal and is never interpreted as a
line terminator or as a code point that might terminate the string
literal.

Static Semantics: UTF-16Encoding

The UTF-16Encoding of a numeric code point value, cp, is determined as
follows:

1.  Assert: 0 ≤ cp ≤ 0x10FFFF.

2.  If cp ≤ 65535, return cp.

3.  Let cu1 be floor((cp – 65536) / 1024) + 0xD800.

4.  Let cu2 be ((cp – 65536) modulo 1024) + 0xDC00.

5.  Return the code unit sequence consisting of cu1 followed by cu2.

Static Semantics: UTF16Decode(lead, trail)

Two code units, lead and trail, that form a UTF-16 surrogate pair
are converted to a code point by performing the following steps:

1.  Assert: 0xD800 ≤ lead ≤ 0xDBFF and 0xDC00 ≤ trail ≤ 0xDFFF.

2.  Let cp be (lead–0xD800)×1024+( trail–0xDC00)+0x10000.

3.  Return the code point cp.


Types of Source Code

There are four types of ECMAScript code:

-   _Global code_ is source text that is treated as an ECMAScript
      Script. The global code of a particular Script does not
      include any source text that is parsed as part of a
      FunctionDeclaration, FunctionExpression,
      GeneratorDeclaration, GeneratorExpression, MethodDefinition,
      _ArrowFunction, ClassDeclaration_, or ClassExpression.

-   _Eval code_ is the source text supplied to the built-in EVAL
      function. More precisely, if the parameter to the built-in EVAL
      function is a String, it is treated as an ECMAScript Script. The
      eval code for a particular invocation of EVAL is the global code
      portion of that Script.

-   _Function code_ is source text that is parsed to supply the value of
      the [[ECMAScriptCode]] internal slot (see 9.1.14) of function and
      generator objects. It also includes the code that defines and
      initializes the formal parameters of the function. The _function
      code_ of a particular function or generator does not include any
      source text that is parsed as the function code of a nested
      FunctionDeclaration, FunctionExpression,
      GeneratorDeclaration, GeneratorExpression, MethodDefinition,
      _ArrowFunction, ClassDeclaration_, or ClassExpression.

-   -   _Module code_ is source text that is code that is provided as a
      ModuleBody. It is the code that is directly evaluated when a
      module is initialized. The module code of a particular module does
      not include any source text that is parsed as part of a nested
      FunctionDeclaration, FunctionExpression,
      GeneratorDeclaration, GeneratorExpression, MethodDefinition,
      _ArrowFunction, ClassDeclaration_, or ClassExpression.

-   

NOTE Function code is generally provided as the bodies of Function
Definitions (14.1), Arrow Function Definitions (14.2), Method
Definitions (14.3) and Generator Definitions (14.4). Function code is
also derived from the last argument to the Function constructor
(19.2.1.1) and the GeneratorFunction constructor (25.2.1.1).

Strict Mode Code

An ECMAScript Script syntactic unit may be processed using either
unrestricted or strict mode syntax and semantics. When processed using
strict mode the four types of ECMAScript code are referred to as module
code, strict global code, strict eval code, and strict function code.
Code is interpreted as strict mode code in the following situations:

-   Global code is strict global code if it begins with a Directive
      Prologue that contains a Use Strict Directive (see 14.1.1).

-   Module code is always strict code.

-   All parts of a ClassDeclaration or a ClassExpression are strict
      code.

-   Eval code is strict eval code if it begins with a Directive Prologue
      that contains a Use Strict Directive or if the call to eval is a
      direct call (see 12.3.4.1) to the eval function that is contained
      in strict mode code.

-   -   Function code is strict function code if its
      FunctionDeclaration, FunctionExpression,
      GeneratorDeclaration, GeneratorExpression, MethodDefinition,
      or ArrowFunction is contained in strict mode code or if it is
      within a FunctionBody that begins with a Directive Prologue that
      contains a Use Strict Directive.

-   Function code that is supplied as the last argument to the built-in
      Function constructor is strict function code if the last argument
      is a String that when processed as a FunctionBody begins with a
      Directive Prologue that contains a Use Strict Directive.

Non-ECMAScript Functions

An ECMAScript implementation may support the evaluation of exotic
function objects whose evaluative behaviour is expressed in some
implementation defined form of executable code other than via ECMAScript
code. Whether a function object is an ECMAScript code function or a
non-ECMAScript function is not semantically observable from the
perspective of an ECMAScript code function that calls or is called by
such a non-ECMAScript function.



ECMASCRIPT LANGUAGE: LEXICAL GRAMMAR


The source text of an ECMAScript Script or Module is first converted
into a sequence of input elements, which are tokens, line terminators,
comments, or white space. The source text is scanned from left to right,
repeatedly taking the longest possible sequence of code units as the
next input element.

There are several situations where the identification of lexical input
elements is sensitive to the syntactic grammar context that is consuming
the input elements. This requires multiple goal symbols for the lexical
grammar. The InputElementDiv goal symbol is the default goal symbol
and is used in those syntactic grammar contexts where a leading division
(/) or division-assignment (/=) operator is permitted. The
InputElementRegExp goal symbol is used in all syntactic grammar
contexts where a RegularExpressionLiteral is permitted. The
InputElementTemplateTail goal is used in syntactic grammar contexts
where a TemplateLiteral logically continues after a substitution
element.

NOTE There are no syntactic grammar contexts where both a leading
division or division-assignment, and a leading
RegularExpressionLiteral are permitted. This is not affected by
semicolon insertion (see 11.9); in examples such as the following:

  A = B
  /HI/G.EXEC(C).MAP(D);

where the first non-whitespace, non-comment code point after a
LineTerminator is SOLIDUS (/) and the syntactic context allows
division or division-assignment, no semicolon is inserted at the
LineTerminator. That is, the above example is interpreted in the same
way as:

  A = B / HI / G.EXEC(C).MAP(D);

Syntax

InputElementDiv ::

WhiteSpace
LineTerminator
Comment
Token
DivPunctuator
RightBracePunctuator

InputElementRegExp ::

WhiteSpace
LineTerminator
Comment
Token
RightBracePunctuator
RegularExpressionLiteral

InputElementTemplateTail ::

WhiteSpace
LineTerminator
Comment
Token
DivPunctuator
TemplateSubstitutionTail


Unicode Format-Control Characters

The Unicode format-control characters (i.e., the characters in category
“Cf” in the Unicode Character Database such as left-to-right mark or
right-to-left mark) are control codes used to control the formatting of
a range of text in the absence of higher-level protocols for this (such
as mark-up languages).

It is useful to allow format-control characters in source text to
facilitate editing and display. All format control characters may be
used within comments, and within string literals, template literals, and
regular expression literals.

U+200C (Zero width non-joiner) and U+200D (Zero width joiner) are
format-control characters that are used to make necessary distinctions
when forming words or phrases in certain languages. In ECMAScript source
text these code points may also be used in an IdentifierName (see
11.6.1) after the first character.

U+FEFF (Zero Width no-break space) is a format-control character used
primarily at the start of a text to mark it as Unicode and to allow
detection of the text's encoding and byte order. <ZWNBSP> characters
intended for this purpose can sometimes also appear after the start of a
text, for example as a result of concatenating files. In ECMAScript
source text <ZWNBSP> code points are treated as white space characters
(see 11.2).

The special treatment of certain format-control characters outside of
comments, string literals, and regular expression literals is summarized
in Table 32.

Table 32 — Format-Control Code Point Usage

  --------------- --------------------------- ---------------- ------------------
  _CODE POINT _   NAME                      ABBREVIATION   USAGE
  U+200C          Zero width non-joiner       <ZWNJ>           IdentifierPart
  U+200D          Zero width joiner           <ZWJ>            IdentifierPart
  U+FEFF          ZERO WIDTH NO-BREAK SPACE   <ZWNBSP>         Whitespace
  --------------- --------------------------- ---------------- ------------------


White Space

White space code points are used to improve source text readability and
to separate tokens (indivisible lexical units) from each other, but are
otherwise insignificant. White space code points may occur between any
two tokens and at the start or end of input. White space code points may
occur within a StringLiteral, a RegularExpressionLiteral, a
Template, or a TemplateSubstitutionTail where they are considered
significant code points forming part of a literal value. They may also
occur within a Comment, but cannot appear within any other kind of
token.

The ECMAScript white space code points are listed in Table 33.

Table 33 — Whitespace Code Point

  --------------------- ------------------------------------------------- ----------------
  _CODE POINT _         NAME                                            ABBREVIATION
  U+0009                Character Tabulation                              <TAB>
  U+000B                LINE TABULATION                                   <VT>
  U+000C                Form Feed (ff)                                    <FF>
  U+0020                Space                                             <SP>
  U+00A0                No-break space                                    <NBSP>
  U+FEFF                ZERO wIDTH nO-bREAK SPACE                         <ZWNBSP>
  Other category “Zs”   Any other Unicode “Separator, space” code point   <USP>
  --------------------- ------------------------------------------------- ----------------

ECMAScript implementations must recognize as Whitespace code points
listed in the “Separator, space” (Zs) category by Unicode 5.1.
ECMAScript implementations may also recognize as Whitespace additional
category Zs code points from subsequent editions of the Unicode
Standard.

NOTE Other than for the code points listed in Table 33, ECMAScript
Whitespace intentionally excludes all code points that have the
Unicode “White_Space” property but which are not classified in category
“Zs”.

Syntax

WhiteSpace ::

<TAB>
<VT>
<FF>
<SP>
<NBSP>
<zwnbsp>
<USP>


Line Terminators

Like white space code points, line terminator code points are used to
improve source text readability and to separate tokens (indivisible
lexical units) from each other. However, unlike white space code points,
line terminators have some influence over the behaviour of the syntactic
grammar. In general, line terminators may occur between any two tokens,
but there are a few places where they are forbidden by the syntactic
grammar. Line terminators also affect the process of automatic semicolon
insertion (11.9). A line terminator cannot occur within any token except
a StringLiteral, Template, or TemplateSubstitutionTail. Line
terminators may only occur within a StringLiteral token as part of a
LineContinuation.

A line terminator can occur within a MultiLineComment (11.4) but
cannot occur within a SingleLineComment.

Line terminators are included in the set of white space code points that
are matched by the \S class in regular expressions.

The ECMAScript line terminator code points are listed in Table 34.

Table 34 — Line Terminator Code Points

  --------------- ---------------------- ----------------
  _CODE POINT _   _UNICODE NAME_         ABBREVIATION
  U+000A          Line Feed (LF)         <LF>
  U+000D          Carriage Return (CR)   <CR>
  U+2028          Line separator         <LS>
  U+2029          Paragraph separator    <PS>
  --------------- ---------------------- ----------------

Only the Unicode code points in Table 34 are treated as line
terminators. Other new line or line breaking Unicode code points are not
treated as line terminators but are treated as white space if they meet
the requirements listed in Table 33. The sequence <CR><LF> is commonly
used as a line terminator. It should be considered a single
SourceCharacter for the purpose of reporting line numbers.

Syntax

LineTerminator ::

<LF>
<CR>
<LS>
<PS>

LineTerminatorSequence ::

<LF>
<CR> [lookahead ≠ <LF> ]
<LS>
<PS>
<CR> <LF>


Comments

Comments can be either single or multi-line. Multi-line comments cannot
nest.

Because a single-line comment can contain any Unicode code point except
a LineTerminator code point, and because of the general rule that a
token is always as long as possible, a single-line comment always
consists of all code points from the // marker to the end of the line.
However, the LineTerminator at the end of the line is not considered
to be part of the single-line comment; it is recognized separately by
the lexical grammar and becomes part of the stream of input elements for
the syntactic grammar. This point is very important, because it implies
that the presence or absence of single-line comments does not affect the
process of automatic semicolon insertion (see 11.9).

Comments behave like white space and are discarded except that, if a
MultiLineComment contains a line terminator code point, then the
entire comment is considered to be a LineTerminator for purposes of
parsing by the syntactic grammar.

Syntax

Comment ::

MultiLineComment
SingleLineComment

MultiLineComment ::

/* MultiLineCommentChars~opt~ */

MultiLineCommentChars ::

MultiLineNotAsteriskChar MultiLineCommentChars~opt~
* PostAsteriskCommentChars~opt~

PostAsteriskCommentChars ::

MultiLineNotForwardSlashOrAsteriskChar MultiLineCommentChars~opt~
* PostAsteriskCommentChars~opt~

MultiLineNotAsteriskChar ::

SourceCharacter BUT NOT *

MultiLineNotForwardSlashOrAsteriskChar ::

SourceCharacter BUT NOT ONE OF / OR *

SingleLineComment ::

// SingleLineCommentChars~opt~

SingleLineCommentChars ::

SingleLineCommentChar SingleLineCommentChars~opt~

SingleLineCommentChar ::

SourceCharacter BUT NOT LineTerminator


Tokens

Syntax

Token ::

IdentifierName
Punctuator
NumericLiteral
StringLiteral
Template

NOTE The DivPunctuator, RegularExpressionLiteral,
RightBracePunctuator, and TemplateSubstitutionTail productions
define tokens, but are not included in the Token production.


Names and Keywords

IdentifierName and ReservedWord are tokens that are interpreted
according to the Default Identifier Syntax given in Unicode Standard
Annex #31, Identifier and Pattern Syntax, with some small modifications.
ReservedWord is an enumerated subset of IdentifierName. The
syntactic grammar defines Identifier as an IdentifierName that is
not a ReservedWord (see 11.6.2). The Unicode identifier grammar is
based on character properties specified by the Unicode Standard. The
Unicode code points in the specified categories in version 5.1.0 of the
Unicode standard must be treated as in those categories by all
conforming ECMAScript implementations. ECMAScript implementations may
recognize identifier code points defined in later editions of the
Unicode Standard.

NOTE 1 This standard specifies specific code point additions: U+0024
(dollar sign) and U+005F (LOW LINE) are permitted anywhere in an
IdentifierName, and the characters U+200C (zero-width non-joiner) and
U+200D (zero-width joiner) are permitted anywhere after the first code
unit of an IdentifierName.

Unicode escape sequences are permitted in an IdentifierName, where
they contribute a single Unicode code point to the IdentifierName. The
code point is expressed by the HexDigits of the
UnicodeEscapeSequence (see 11.8.4). The \ preceding the
UnicodeEscapeSequence and the U and { } code units, if they appear, do
not contribute code points to the IdentifierName. A
UnicodeEscapeSequence cannot be used to put a code point into an
IdentifierName that would otherwise be illegal. In other words, if a \
UnicodeEscapeSequence sequence were replaced by the SourceCharacter
it contributes, the result must still be a valid IdentifierName that
has the exact same sequence of SourceCharacter elements as the
original IdentifierName. All interpretations of IdentifierName
within this specification are based upon their actual code points
regardless of whether or not an escape sequence was used to contribute
any particular code point.

Two IdentifierName that are canonically equivalent according to the
Unicode standard are not equal unless they are represented by the
exact same sequence of code points (in other words, conforming
ECMAScript implementations are only required to do bitwise comparison on
IdentifierName values).

Syntax

IdentifierName ::

IdentifierStart
IdentifierName IdentifierPart

IdentifierStart ::

UnicodeIDStart
$
_
\ UnicodeEscapeSequence

IdentifierPart ::

UnicodeIDContinue
$
_
\ UnicodeEscapeSequence
<ZWNJ>
<ZWJ>

UnicodeIDStart ::

any Unicode code point with the Unicode property “ID_Start” or
“OtherIDStart”

UnicodeIDContinue ::

any Unicode code point with the Unicode property “ID_Continue”,
“OtherIDContinue”, or “OtherIDStart”

The definitions of the nonterminal UnicodeEscapeSequence is given in
11.8.4.

Identifier Names

Static Semantics: Early Errors

IdentifierStart :: \ UnicodeEscapeSequence

-   It is a Syntax Error if SV(UnicodeEscapeSequence) is neither the
    UTF-16Encoding (10.1.1) of a single Unicode code point with the
    Unicode property “ID_Start” nor "$" or "_".

IdentifierPart :: \ UnicodeEscapeSequence

-   It is a Syntax Error if SV(UnicodeEscapeSequence) is neither the
    UTF-16Encoding (10.1.1) of a single Unicode code point with the
    Unicode property “ID_Continue” nor "$" or "_" nor the UTF-16Encoding
    of either <ZWNJ> or <ZWJ>.

Static Semantics: StringValue

See also: 11.8.4.2, 12.1.4.

IdentifierName ::

IdentifierStart
IdentifierName IdentifierPart

1.  Return the String value consisting of the sequence of code units
    corresponding to IdentifierName. In determining the sequence any
    occurrences of \ UnicodeEscapeSequence are first replaced with the
    code point represented by the UnicodeEscapeSequence and then the
    code points of the entire IdentifierName are converted to code
    units by UTF-16Encoding (10.1.1) each code point.

Reserved Words

A reserved word is an IdentifierName that cannot be used as an
Identifier.

Syntax

ReservedWord ::

Keyword
FutureReservedWord
NullLiteral
BooleanLiteral

NOTE The ReservedWord definitions are specified as literal sequences
of specific SourceCharacter elements. A code point in a ReservedWord
cannot be expressed by a \ UnicodeEscapeSequence.

Keywords

The following tokens are ECMAScript keywords and may not be used as
Identifiers in ECMAScript programs.

Syntax

Keyword :: ONE OF

  ---------- ---------- ------------ --------
  break      do         in           typeof
  case       else       instanceof   var
  catch      export     new          void
  class      extends    return       while
  const      finally    super        with
  continue   for        switch       yield
  debugger   function   this         
  default    if         throw        
  delete     import     try          
  ---------- ---------- ------------ --------

NOTE In some contexts YIELD is given the semantics of an Identifier.
See 12.1.1. In strict mode code, LET and STATIC are treated as reserved
keywords through static semantic restrictions (see 12.1.1, 13.2.1.1,
13.6.4.1, and 14.5.1) rather than the lexical grammar.

Future Reserved Words

The following tokens are reserved for used as keywords in future
language extensions.

Syntax

FutureReservedWord ::

  ------- -- -- --
  enum          
  await         
  ------- -- -- --

AWAIT is only treated as a FutureReservedWord when Module is the
goal symbol of the syntactic grammar.

NOTE Use of the following tokens within strict mode code (see 10.2.1) is
also reserved. That usage is restricted using static semantic
restrictions (see 12.1.1) rather than the lexical grammar:

  ------------ --------- ----------- --
  implements   package   protected   
  interface    private   public      
  ------------ --------- ----------- --

  -- -- -- -- --
              
              
  -- -- -- -- --


Punctuators

Syntax

Punctuator :: ONE OF

  ----- ------ ----- ----- ----- -----
  {     (      )     [     ]     .
  ...   ;      ,     <     >     <=
  >=    ==     !=    ===   !==   
  +     -      *     %     ++    --
  <<    >>     >>>   &     |     ^
  !     ~      &&    ||    ?     :
  =     +=     -=    *=    %=    <<=
  >>=   >>>=   &=    |=    ^=    =>
  ----- ------ ----- ----- ----- -----

DivPunctuator :: ONE OF

  --- ---- -- -- -- --
  /   /=            
  --- ---- -- -- -- --

RightBracePunctuator ::

  --- -- -- -- -- --
  }               
  --- -- -- -- -- --


Literals

Null Literals

Syntax

NullLiteral ::

NULL

Boolean Literals

Syntax

BooleanLiteral ::

TRUE
FALSE

Numeric Literals

Syntax

NumericLiteral ::

DecimalLiteral
BinaryIntegerLiteral
OctalIntegerLiteral
HexIntegerLiteral

DecimalLiteral ::

DecimalIntegerLiteral . DecimalDigits~opt~ ExponentPart~opt~
. DecimalDigits ExponentPart~opt~
DecimalIntegerLiteral ExponentPart~opt~

DecimalIntegerLiteral ::

0
NonZeroDigit DecimalDigits~opt~

DecimalDigits ::

DecimalDigit
DecimalDigits DecimalDigit

DecimalDigit :: ONE OF

0 1 2 3 4 5 6 7 8 9

NonZeroDigit :: ONE OF

1 2 3 4 5 6 7 8 9

ExponentPart ::

ExponentIndicator SignedInteger

ExponentIndicator :: ONE OF

E E

SignedInteger ::

DecimalDigits
+ DecimalDigits
- DecimalDigits

BinaryIntegerLiteral ::

0B BinaryDigits
0B BinaryDigits

BinaryDigits ::

BinaryDigit
BinaryDigits BinaryDigit

BinaryDigit :: ONE OF

0 1

OctalIntegerLiteral ::

0O OctalDigits
0O OctalDigits

OctalDigits ::

OctalDigit
OctalDigits OctalDigit

OctalDigit :: ONE OF

0 1 2 3 4 5 6 7

HexIntegerLiteral ::

0X HexDigits
0X HexDigits

HexDigits ::

HexDigit
HexDigits HexDigit

HexDigit :: ONE OF

0 1 2 3 4 5 6 7 8 9 A B C D E F A B C D E F

The SourceCharacter immediately following a NumericLiteral must not
be an IdentifierStart or DecimalDigit.

NOTE For example:

  3in

is an error and not the two input elements 3 and IN.

A conforming implementation, when processing strict mode code (see
10.2.1), must not extend, as described in B.1.1, the syntax of
NumericLiteral to include LegacyOctalIntegerLiteral, nor extend the
syntax of DecimalIntegerLiteral to include
NonOctalDecimalIntegerLiteral.

Static Semantics: MV’s

A numeric literal stands for a value of the Number type. This value is
determined in two steps: first, a mathematical value (MV) is derived
from the literal; second, this mathematical value is rounded as
described below.

-   The MV of NumericLiteral :: DecimalLiteral is the MV of
    DecimalLiteral.

-   The MV of NumericLiteral :: BinaryIntegerLiteral is the MV of
    BinaryIntegerLiteral.

-   The MV of NumericLiteral :: OctalIntegerLiteral is the MV of
    OctalIntegerLiteral.

-   The MV of NumericLiteral :: HexIntegerLiteral is the MV of
    HexIntegerLiteral.

-   The MV of DecimalLiteral :: DecimalIntegerLiteral . is the MV of
    DecimalIntegerLiteral.

-   The MV of DecimalLiteral :: DecimalIntegerLiteral .
    DecimalDigits is the MV of DecimalIntegerLiteral plus (the MV of
    DecimalDigits × 10^–n^), where n is the number of code points
    in DecimalDigits.

-   The MV of DecimalLiteral :: DecimalIntegerLiteral .
    ExponentPart is the MV of DecimalIntegerLiteral × 10^e^, where
    e is the MV of ExponentPart.

-   The MV of DecimalLiteral :: DecimalIntegerLiteral .
    _DecimalDigits ExponentPart_ is (the MV of DecimalIntegerLiteral
    plus (the MV of DecimalDigits × 10^–n^)) × 10^e^, where n is
    the number of code points in DecimalDigits and e is the MV of
    ExponentPart.

-   The MV of DecimalLiteral ::. DecimalDigits is the MV of
    DecimalDigits × 10^–n^, where n is the number of code points
    in DecimalDigits.

-   The MV of DecimalLiteral ::. _DecimalDigits ExponentPart_ is the
    MV of DecimalDigits × 10^e_–_n^, where n is the number of code
    points in DecimalDigits and e is the MV of ExponentPart.

-   The MV of DecimalLiteral :: DecimalIntegerLiteral is the MV of
    DecimalIntegerLiteral.

-   The MV of DecimalLiteral :: _DecimalIntegerLiteral ExponentPart_
    is the MV of DecimalIntegerLiteral × 10^e^, where e is the MV
    of ExponentPart.

-   The MV of DecimalIntegerLiteral :: 0 is 0.

-   The MV of DecimalIntegerLiteral :: NonZeroDigit is the MV of
    NonZeroDigit.

-   The MV of DecimalIntegerLiteral :: NonZeroDigit DecimalDigits
    is (the MV of NonZeroDigit × 10^n^) plus the MV of
    DecimalDigits, where n is the number of code points in
    DecimalDigits.

-   The MV of DecimalDigits :: DecimalDigit is the MV of
    DecimalDigit.

-   The MV of DecimalDigits :: DecimalDigits DecimalDigit is (the
    MV of DecimalDigits × 10) plus the MV of DecimalDigit.

-   The MV of ExponentPart :: _ExponentIndicator SignedInteger_ is the
    MV of SignedInteger.

-   The MV of SignedInteger :: DecimalDigits is the MV of
    DecimalDigits.

-   The MV of SignedInteger :: + DecimalDigits is the MV of
    DecimalDigits.

-   The MV of SignedInteger :: - DecimalDigits is the negative of
    the MV of DecimalDigits.

-   The MV of DecimalDigit :: 0 or of HexDigit :: 0 or of
    OctalDigit :: 0 or of BinaryDigit :: 0 is 0.

-   The MV of DecimalDigit :: 1 or of NonZeroDigit :: 1 or of
    HexDigit :: 1 or of OctalDigit :: 1 or
    of BinaryDigit :: 1 is 1.

-   The MV of DecimalDigit :: 2 or of NonZeroDigit :: 2 or of
    HexDigit :: 2 or of OctalDigit :: 2 is 2.

-   The MV of DecimalDigit :: 3 or of NonZeroDigit :: 3 or of
    HexDigit :: 3 or of OctalDigit :: 3 is 3.

-   The MV of DecimalDigit :: 4 or of NonZeroDigit :: 4 or of
    HexDigit :: 4 or of OctalDigit :: 4 is 4.

-   The MV of DecimalDigit :: 5 or of NonZeroDigit :: 5 or of
    HexDigit :: 5 or of OctalDigit :: 5 is 5.

-   The MV of DecimalDigit :: 6 or of NonZeroDigit :: 6 or of
    HexDigit :: 6 or of OctalDigit :: 6 is 6.

-   The MV of DecimalDigit :: 7 or of NonZeroDigit :: 7 or of
    HexDigit :: 7 or of OctalDigit :: 7 is 7.

-   The MV of DecimalDigit :: 8 or of NonZeroDigit :: 8 or of
    HexDigit :: 8 is 8.

-   The MV of DecimalDigit :: 9 or of NonZeroDigit :: 9 or of
    HexDigit :: 9 is 9.

-   The MV of HexDigit :: A or of HexDigit :: A is 10.

-   The MV of HexDigit :: B or of HexDigit :: B is 11.

-   The MV of HexDigit :: C or of HexDigit :: C is 12.

-   The MV of HexDigit :: D or of HexDigit :: D is 13.

-   The MV of HexDigit :: E or of HexDigit :: E is 14.

-   The MV of HexDigit :: F or of HexDigit :: F is 15.

-   The MV of BinaryIntegerLiteral :: 0B BinaryDigits is the MV of
    BinaryDigits.

-   The MV of BinaryIntegerLiteral :: 0B BinaryDigits is the MV of
    BinaryDigits.

-   The MV of BinaryDigits :: BinaryDigit is the MV of
    BinaryDigit.

-   The MV of BinaryDigits :: BinaryDigits BinaryDigit is (the MV
    of BinaryDigits × 2) plus the MV of BinaryDigit.

-   The MV of OctalIntegerLiteral :: 0O OctalDigits is the MV of
    OctalDigits.

-   The MV of OctalIntegerLiteral :: 0O OctalDigits is the MV of
    OctalDigits.

-   The MV of OctalDigits :: OctalDigit is the MV of OctalDigit.

-   The MV of OctalDigits :: OctalDigits OctalDigit is (the MV of
    OctalDigits × 8) plus the MV of OctalDigit.

-   The MV of HexIntegerLiteral :: 0X HexDigits is the MV of
    HexDigits.

-   The MV of HexIntegerLiteral :: 0X HexDigits is the MV of
    HexDigits.

-   The MV of HexDigits :: HexDigit is the MV of HexDigit.

-   The MV of HexDigits :: HexDigits HexDigit is (the MV of
    HexDigits × 16) plus the MV of HexDigit.

Once the exact MV for a numeric literal has been determined, it is then
rounded to a value of the Number type. If the MV is 0, then the rounded
value is +0; otherwise, the rounded value must be the Number value for
the MV (as specified in 6.1.6), unless the literal is a DecimalLiteral
and the literal has more than 20 significant digits, in which case the
Number value may be either the Number value for the MV of a literal
produced by replacing each significant digit after the 20th with a 0
digit or the Number value for the MV of a literal produced by replacing
each significant digit after the 20th with a 0 digit and then
incrementing the literal at the 20th significant digit position. A digit
is significant if it is not part of an ExponentPart and

-   it is not 0; or

-   there is a nonzero digit to its left and there is a nonzero digit,
      not in the ExponentPart, to its right.

String Literals

NOTE A string literal is zero or more Unicode code points enclosed in
single or double quotes. Unicode code points may also be represented by
an escape sequence. All code points may appear literally in a string
literal except for the closing quote code points, REVERSE SOLIDUS (\),
carriage return (CR), line separator, paragraph separator, and line feed
(LF). Any code points may appear in the form of an escape sequence.
String literals evaluate to ECMAScript String values. When generating
these string values Unicode code points are UTF-16 encoded as defined in
10.1.1. Code points belonging to Basic Multilingual Plane are encoded as
a single code unit element of the string. All other code points are
encoded as two code unit elements of the string.

Syntax

StringLiteral ::

" DoubleStringCharacters~opt~ "
' SingleStringCharacters~opt~ '

DoubleStringCharacters ::

DoubleStringCharacter DoubleStringCharacters~opt~

SingleStringCharacters ::

SingleStringCharacter SingleStringCharacters~opt~

DoubleStringCharacter ::

SourceCharacter BUT NOT ONE OF " OR \ OR LineTerminator
\ EscapeSequence
LineContinuation

SingleStringCharacter ::

SourceCharacter BUT NOT ONE OF ' OR \ OR LineTerminator
\ EscapeSequence
LineContinuation

LineContinuation ::

\ LineTerminatorSequence

EscapeSequence ::

CharacterEscapeSequence
0 [lookahead ∉ DecimalDigit]
HexEscapeSequence
UnicodeEscapeSequence

A conforming implementation, when processing strict mode code (see
10.2.1), must not extend the syntax of EscapeSequence to include
LegacyOctalEscapeSequence as described in B.1.2.

CharacterEscapeSequence ::

SingleEscapeCharacter
NonEscapeCharacter

SingleEscapeCharacter :: ONE OF

' " \ B F N R T V

NonEscapeCharacter ::

SourceCharacter BUT NOT ONE OF EscapeCharacter OR LineTerminator

EscapeCharacter ::

SingleEscapeCharacter
DecimalDigit
X
U

HexEscapeSequence ::

X HexDigit HexDigit

UnicodeEscapeSequence ::

U Hex4Digits
U{ HexDigits }

Hex4Digits ::

HexDigit HexDigit HexDigit HexDigit

The definition of the nonterminal HexDigit is given in 11.8.3.
SourceCharacter is defined in 10.1.

NOTE A line terminator code point cannot appear in a string literal,
except as part of a LineContinuation to produce the empty code points
sequence. The proper way to cause a line terminator code point to be
part of the String value of a string literal is to use an escape
sequence such as \N or \U000A.

Static Semantics: Early Errors

UnicodeEscapeSequence :: U{ HexDigits }

-   It is a Syntax Error if the MV of HexDigits > 1114111.

-   

Static Semantics: StringValue

See also: 11.6.1.2, 12.1.4.

StringLiteral ::

" DoubleStringCharacters~opt~ "
' SingleStringCharacters~opt~ '

1.  Return the String value whose elements are the SV of this
    StringLiteral.

Static Semantics: SV’s

A string literal stands for a value of the String type. The String value
(SV) of the literal is described in terms of code unit values
contributed by the various parts of the string literal. As part of this
process, some Unicode code points within the string literal are
interpreted as having a mathematical value (MV), as described below or
in 11.8.3.

-   The SV of StringLiteral :: "" is the empty code unit sequence.

-   The SV of StringLiteral :: '' is the empty code unit sequence.

-   The SV of StringLiteral :: " DoubleStringCharacters " is the SV
    of DoubleStringCharacters.

-   The SV of StringLiteral :: ' SingleStringCharacters ' is the SV
    of SingleStringCharacters.

-   The SV of DoubleStringCharacters :: DoubleStringCharacter is a
    sequence of one or two code units that is the SV of
    DoubleStringCharacter.

-   The SV of DoubleStringCharacters :: DoubleStringCharacter
    DoubleStringCharacters is a sequence of one or two code units that
    is the SV of DoubleStringCharacter followed by all the code units
    in the SV of DoubleStringCharacters in order.

-   The SV of SingleStringCharacters :: SingleStringCharacter is a
    sequence of one or two code units that is the SV of
    SingleStringCharacter.

-   The SV of SingleStringCharacters :: SingleStringCharacter
    SingleStringCharacters is a sequence of one or two code units that
    is the SV of SingleStringCharacter followed by all the code units
    in the SV of SingleStringCharacters in order.

-   The SV of DoubleStringCharacter :: SourceCharacter BUT NOT ONE
    OF " OR \ OR LineTerminator is the UTF-16Encoding (10.1.1) of the
    code point value of SourceCharacter.

-   The SV of DoubleStringCharacter :: \ EscapeSequence is the SV of
    the EscapeSequence.

-   The SV of DoubleStringCharacter :: LineContinuation is the empty
    code unit sequence.

-   The SV of SingleStringCharacter :: SourceCharacter BUT NOT ONE
    OF ' OR \ OR LineTerminator is the UTF-16Encoding (10.1.1) of the
    code point value of SourceCharacter.

-   The SV of SingleStringCharacter :: \ EscapeSequence is the SV of
    the EscapeSequence.

-   The SV of SingleStringCharacter :: LineContinuation is the empty
    code unit sequence.

-   The SV of EscapeSequence :: CharacterEscapeSequence is the SV of
    the CharacterEscapeSequence.

-   The SV of EscapeSequence :: 0 is the code unit value 0.

-   -   The SV of EscapeSequence :: HexEscapeSequence is the SV of
    the HexEscapeSequence.

-   The SV of EscapeSequence :: UnicodeEscapeSequence is the SV of
    the UnicodeEscapeSequence.

-   The SV of CharacterEscapeSequence :: SingleEscapeCharacter is
    the code unit whose value is determined by the
    SingleEscapeCharacter according to Table 35.

Table 35 — String Single Character Escape Sequences

  ------------------- ------------------- -------------------------- ----------
  _ESCAPE SEQUENCE_   _CODE UNIT VALUE_   _UNICODE CHARACTER NAME_   SYMBOL
  \B                  0X0008              BACKSPACE                  <BS>
  \T                  0X0009              CHARACTER TABULATION       <HT>
  \N                  0X000A              line feed (lf)             <LF>
  \V                  0X000B              LINE TABULATION            <VT>
  \F                  0X000C              form feed (ff)             <FF>
  \R                  0X000D              carriage return (cr)       <CR>
  \"                  0X0022              quotation Mark             "
  \'                  0X0027              apostrophe                 '
  \\                  0X005C              REverse Solidus            \
  ------------------- ------------------- -------------------------- ----------

-   The SV of CharacterEscapeSequence :: NonEscapeCharacter is the
    SV of the NonEscapeCharacter.

-   The SV of NonEscapeCharacter :: SourceCharacter BUT NOT ONE OF
    EscapeCharacter OR LineTerminator is the UTF-16Encoding (10.1.1)
    of the code point value of SourceCharacter.

-   The SV of HexEscapeSequence :: X HexDigit HexDigit is the code
    unit value that is (16 times the MV of the first HexDigit) plus
    the MV of the second HexDigit.

-   The SV of UnicodeEscapeSequence :: U Hex4Digits is the SV of
    Hex4Digits.

-   The SV of Hex4Digits :: HexDigit HexDigit HexDigit
    HexDigit is the code unit value that is (4096 times the MV of the
    first HexDigit) plus (256 times the MV of the second HexDigit)
    plus (16 times the MV of the third HexDigit) plus the MV of the
    fourth HexDigit.

-   The SV of UnicodeEscapeSequence :: U{ HexDigits } is the
    UTF-16Encoding (10.1.1) of the MV of HexDigits.

Regular Expression Literals

NOTE A regular expression literal is an input element that is converted
to a RegExp object (see 21.2) each time the literal is evaluated. Two
regular expression literals in a program evaluate to regular expression
objects that never compare as === to each other even if the two
literals' contents are identical. A RegExp object may also be created at
runtime by NEW REGEXP (see 21.2.3.2) or calling the REGEXP constructor
as a function (21.2.3.1).

The productions below describe the syntax for a regular expression
literal and are used by the input element scanner to find the end of the
regular expression literal. The source code comprising the
RegularExpressionBody and the RegularExpressionFlags are
subsequently parsed using the more stringent ECMAScript Regular
Expression grammar (21.2.1).

An implementation may extend the ECMAScript Regular Expression grammar
defined in 21.2.1, but it must not extend the RegularExpressionBody
and RegularExpressionFlags productions defined below or the
productions used by these productions.

Syntax

RegularExpressionLiteral ::

/ RegularExpressionBody / RegularExpressionFlags

RegularExpressionBody ::

RegularExpressionFirstChar RegularExpressionChars

RegularExpressionChars ::

[empty]
RegularExpressionChars RegularExpressionChar

RegularExpressionFirstChar ::

RegularExpressionNonTerminator BUT NOT ONE OF * OR \ OR / OR [
RegularExpressionBackslashSequence
RegularExpressionClass

RegularExpressionChar ::

RegularExpressionNonTerminator BUT NOT ONE OF \ OR / OR [
RegularExpressionBackslashSequence
RegularExpressionClass

RegularExpressionBackslashSequence ::

\ RegularExpressionNonTerminator

RegularExpressionNonTerminator ::

SourceCharacter BUT NOT LineTerminator

RegularExpressionClass ::

[ RegularExpressionClassChars ]

RegularExpressionClassChars ::

[empty]
RegularExpressionClassChars RegularExpressionClassChar

RegularExpressionClassChar ::

RegularExpressionNonTerminator BUT NOT ONE OF ] OR \
RegularExpressionBackslashSequence

RegularExpressionFlags ::

[empty]
RegularExpressionFlags IdentifierPart

NOTE Regular expression literals may not be empty; instead of
representing an empty regular expression literal, the code unit sequence
// starts a single-line comment. To specify an empty regular expression,
use: /(?:)/.

Static Semantics: Early Errors

RegularExpressionFlags :: _RegularExpressionFlags IdentifierPart_

-   It is a Syntax Error if IdentifierPart contains a Unicode escape
    sequence.

-   

Static Semantics: BodyText

RegularExpressionLiteral :: / RegularExpressionBody /
RegularExpressionFlags

1.  Return the source code that was recognized as
    RegularExpressionBody.

Static Semantics: FlagText

RegularExpressionLiteral :: / RegularExpressionBody /
RegularExpressionFlags

1.  Return the source code that was recognized as
    RegularExpressionFlags.

Template Literal Lexical Components

Syntax

Template ::

NoSubstitutionTemplate
TemplateHead

NoSubstitutionTemplate ::

` TemplateCharacters~opt~ `

TemplateHead ::

` TemplateCharacters~opt~ ${

TemplateSubstitutionTail ::

TemplateMiddle
TemplateTail

TemplateMiddle ::

} TemplateCharacters~opt~ ${

TemplateTail ::

} TemplateCharacters~opt~ `

TemplateCharacters ::

TemplateCharacter TemplateCharacters~opt~

TemplateCharacter ::

$ [lookahead ≠ { ]
\ EscapeSequence
LineContinuation
LineTerminatorSequence
SourceCharacter BUT NOT ONE OF ` OR \ OR $ OR LineTerminator

A conforming implementation must not use the extended definition of
EscapeSequence described in B.1.2 when parsing a TemplateCharacter.

NOTE TemplateSubstitutionTail is used by the
InputElementTemplateTail alternative lexical goal.

Static Semantics: TV’s and TRV’s

A template literal component is interpreted as a sequence of Unicode
code points. The Template Value (TV) of a literal component is described
in terms of code unit values (SV, 11.8.4) contributed by the various
parts of the template literal component. As part of this process, some
Unicode code points within the template component are interpreted as
having a mathematical value (MV, 11.8.3). In determining a TV, escape
sequences are replaced by the UTF-16 code unit(s) of the Unicode code
point represented by the escape sequence. The Template Raw Value (TRV)
is similar to a Template Value with the difference that in TRVs escape
sequences are interpreted literally.

-   The TV and TRV of NoSubstitutionTemplate :: `` is the empty code
    unit sequence.

-   The TV and TRV of TemplateHead :: `${ is the empty code unit
    sequence.

-   The TV and TRV of TemplateMiddle :: }${ is the empty code unit
    sequence.

-   The TV and TRV of TemplateTail :: }` is the empty code unit
    sequence.

-   The TV of NoSubstitutionTemplate :: ` TemplateCharacters ` is
    the TV of TemplateCharacters.

-   The TV of TemplateHead :: ` TemplateCharacters ${ is the TV of
    TemplateCharacters.

-   The TV of TemplateMiddle :: } TemplateCharacters ${ is the TV of
    TemplateCharacters.

-   The TV of TemplateTail :: } TemplateCharacters ` is the TV of
    TemplateCharacters.

-   The TV of TemplateCharacters :: TemplateCharacter is the TV of
    TemplateCharacter.

-   The TV of TemplateCharacters :: TemplateCharacter
    TemplateCharacters is a sequence consisting of the code units in
    the TV of TemplateCharacter followed by all the code units in the
    TV of TemplateCharacters in order.

-   The TV of TemplateCharacter :: SourceCharacter BUT NOT ONE OF `
    OR \ OR $ OR LineTerminator is the UTF-16Encoding (10.1.1) of the
    code point value of SourceCharacter.

-   The TV of TemplateCharacter :: $ is the code unit value 0x0024.

-   The TV of TemplateCharacter :: \ EscapeSequence is the SV of
    EscapeSequence.

-   The TV of TemplateCharacter :: LineContinuation is the TV of
    LineContinuation.

-   The TV of TemplateCharacter :: LineTerminatorSequence is the TRV
    of LineTerminatorSequence.

-   The TV of LineContinuation :: \ LineTerminatorSequence is the
    empty code unit sequence.

-   The TRV of NoSubstitutionTemplate :: ` TemplateCharacters ` is
    the TRV of TemplateCharacters.

-   The TRV of TemplateHead :: ` TemplateCharacters ${ is the TRV of
    TemplateCharacters.

-   The TRV of TemplateMiddle :: } TemplateCharacters ${ is the TRV
    of TemplateCharacters.

-   The TRV of TemplateTail :: } TemplateCharacters ` is the TRV of
    TemplateCharacters.

-   The TRV of TemplateCharacters :: TemplateCharacter is the TRV of
    TemplateCharacter.

-   The TRV of TemplateCharacters :: TemplateCharacter
    TemplateCharacters is a sequence consisting of the code units in
    the TRV of TemplateCharacter followed by all the code units in the
    TRV of TemplateCharacters, in order.

-   The TRV of TemplateCharacter :: SourceCharacter BUT NOT ONE OF `
    OR \ OR $ OR LineTerminator is the UTF-16Encoding (10.1.1) of the
    code point value of SourceCharacter.

-   The TRV of TemplateCharacter :: $ is the code unit value 0x0024.

-   The TRV of TemplateCharacter :: \ EscapeSequence is the sequence
    consisting of the code unit value 0x005C followed by the code units
    of TRV of EscapeSequence.

-   The TRV of TemplateCharacter :: LineContinuation is the TRV of
    LineContinuation.

-   The TRV of TemplateCharacter :: LineTerminatorSequence is the
    TRV of LineTerminatorSequence.

-   The TRV of EscapeSequence :: CharacterEscapeSequence is the TRV
    of the CharacterEscapeSequence.

-   The TRV of EscapeSequence :: 0 is the code unit value 0x0030.

-   -   The TRV of EscapeSequence :: HexEscapeSequence is the TRV of
    the HexEscapeSequence.

-   The TRV of EscapeSequence :: UnicodeEscapeSequence is the TRV of
    the UnicodeEscapeSequence.

-   The TRV of CharacterEscapeSequence :: SingleEscapeCharacter is
    the TRV of the SingleEscapeCharacter.

-   The TRV of CharacterEscapeSequence :: NonEscapeCharacter is the
    SV of the NonEscapeCharacter.

-   The TRV of SingleEscapeCharacter :: ONE OF ' " \ B F N R T V is
    the SV of the SourceCharacter that is that single code point.

-   The TRV of HexEscapeSequence :: X _HexDigit HexDigit_ is the
    sequence consisting of code unit value 0x0078 followed by TRV of the
    first HexDigit followed by the TRV of the second HexDigit.

-   The TRV of UnicodeEscapeSequence :: U Hex4Digits is the sequence
    consisting of code unit value 0x0075 followed by TRV of
    Hex4Digits.

-   The TRV of UnicodeEscapeSequence :: U{ HexDigits } is the
    sequence consisting of code unit value 0x0075 followed by code unit
    value 0x007B followed by TRV of HexDigits followed by code unit
    value 0x007D.

-   The TRV of Hex4Digits :: HexDigit HexDigit HexDigit
    HexDigit is the sequence consisting of the TRV of the first
    HexDigit followed by the TRV of the second HexDigit followed by
    the TRV of the third HexDigit followed by the TRV of the fourth
    HexDigit.

-   The TRV of HexDigits :: HexDigit is the TRV of HexDigit.

-   The TRV of HexDigits :: HexDigits HexDigit is the sequence
    consisting of TRV of HexDigits followed by TRV of HexDigit.

-   The TRV of a HexDigit is the SV of the SourceCharacter that is
    that HexDigit.

-   The TRV of LineContinuation :: \ LineTerminatorSequence is the
    sequence consisting of the code unit value 0x005C followed by the
    code units of TRV of LineTerminatorSequence.

-   The TRV of LineTerminatorSequence :: <LF> is the code unit value
    0x000A.

-   The TRV of LineTerminatorSequence :: <CR> is the code unit value
    0x000A.

-   The TRV of LineTerminatorSequence :: <LS> is the code unit value
    0x2028.

-   The TRV of LineTerminatorSequence :: <PS> is the code unit value
    0x2029.

-   The TRV of LineTerminatorSequence :: <CR><LF> is the sequence
    consisting of the code unit value 0x000A.

NOTE TV excludes the code units of LineContinuation while TRV includes
them. <CR><LF> and <CR> LineTerminatorSequences are normalized to <LF>
for both TV and TRV. An explicit EscapeSequence is needed to include a
<CR> or <CR><LF> sequence.


Automatic Semicolon Insertion

Certain ECMAScript statements (empty statement, LET, CONST, IMPORT, and
EXPORT declarations, variable statement, expression statement, DEBUGGER
statement, CONTINUE statement, BREAK statement, RETURN statement, and
THROW statement) must be terminated with semicolons. Such semicolons may
always appear explicitly in the source text. For convenience, however,
such semicolons may be omitted from the source text in certain
situations. These situations are described by saying that semicolons are
automatically inserted into the source code token stream in those
situations.

Rules of Automatic Semicolon Insertion

There are three basic rules of semicolon insertion:

1.  When, as a Script or Module is parsed from left to right, a
    token (called the _offending token_) is encountered that is not
    allowed by any production of the grammar, then a semicolon is
    automatically inserted before the offending token if one or more of
    the following conditions is true:

-   The offending token is separated from the previous token by at least
      one LineTerminator.

-   The offending token is }.

    1.  When, as the Script or Module is parsed from left to right,
        the end of the input stream of tokens is encountered and the
        parser is unable to parse the input token stream as a single
        complete ECMAScript Script or Module, then a semicolon is
        automatically inserted at the end of the input stream.

    2.  When, as the Script or Module is parsed from left to right,
        a token is encountered that is allowed by some production of the
        grammar, but the production is a _restricted production_ and the
        token would be the first token for a terminal or nonterminal
        immediately following the annotation “[no LineTerminator
        here]” within the restricted production (and therefore such a
        token is called a restricted token), and the restricted token is
        separated from the previous token by at least one
        LineTerminator, then a semicolon is automatically inserted
        before the restricted token.

However, there is an additional overriding condition on the preceding
rules: a semicolon is never inserted automatically if the semicolon
would then be parsed as an empty statement or if that semicolon would
become one of the two semicolons in the header of a FOR statement (see
13.6.3).

NOTE The following are the only restricted productions in the grammar:

PostfixExpression~[Yield]~ :

LeftHandSideExpression~[?Yield]~ [no LineTerminator here] ++
LeftHandSideExpression~[?Yield]~ [no LineTerminator here] --

ContinueStatement~[Yield]~ :

CONTINUE;
CONTINUE [no LineTerminator here] LabelIdentifier~[?Yield]~ ;

BreakStatement~[Yield]~ :

BREAK ;
BREAK [no LineTerminator here] LabelIdentifier~[?Yield]~ ;

ReturnStatement~[Yield]~ :

RETURN [no LineTerminator here] Expression ;
RETURN [no LineTerminator here] Expression~[In,\ ?Yield]~ ;

ThrowStatement~[Yield]~ :

THROW [no LineTerminator here] Expression~[In,\ ?Yield]~ ;

ArrowFunction~[In,\ Yield]~ :

ArrowParameters~[?Yield]~ [no LineTerminator here] =>
ConciseBody~[?In]~

YieldExpression~[In]~ :

YIELD [no LineTerminator here] * [Lexical goal InputElementRegExp]
AssignmentExpression~[?In,\ Yield]~
YIELD [no LineTerminator here] [Lexical goal InputElementRegExp]
AssignmentExpression~[?In,\ Yield]~

The practical effect of these restricted productions is as follows:

  When a ++ or -- token is encountered where the parser would treat it
  as a postfix operator, and at least one LineTerminator occurred
  between the preceding token and the ++ or -- token, then a semicolon
  is automatically inserted before the ++ or -- token.

  When a CONTINUE, BREAK, RETURN, THROW, or YIELD token is encountered
  and a LineTerminator is encountered before the next token, a
  semicolon is automatically inserted after the CONTINUE, BREAK, RETURN,
  THROW, or YIELD token.

The resulting practical advice to ECMAScript programmers is:

  A postfix ++ or -- operator should appear on the same line as its
  operand.

  An Expression in a RETURN or THROW statement or an
  AssignmentExpression in a YIELD expression should start on the same
  line as the RETURN, THROW, or YIELD token.

  An IdentifierReference in a BREAK or CONTINUE statement should be on
  the same line as the BREAK or CONTINUE token.

Examples of Automatic Semicolon Insertion

The source

  { 1 2 } 3

is not a valid sentence in the ECMAScript grammar, even with the
automatic semicolon insertion rules. In contrast, the source

  { 1
  2 } 3

is also not a valid ECMAScript sentence, but is transformed by automatic
semicolon insertion into the following:

  { 1
  ;2 ;} 3;

which is a valid ECMAScript sentence.

The source

  for (a; b
  )

is not a valid ECMAScript sentence and is not altered by automatic
semicolon insertion because the semicolon is needed for the header of a
FOR statement. Automatic semicolon insertion never inserts one of the
two semicolons in the header of a FOR statement.

The source

  return
  a + b

is transformed by automatic semicolon insertion into the following:

  return;
  a + b;

NOTE The expression A + B is not treated as a value to be returned by
the RETURN statement, because a LineTerminator separates it from the
token RETURN.

The source

  a = b
  ++c

is transformed by automatic semicolon insertion into the following:

  a = b;
  ++c;

NOTE The token ++ is not treated as a postfix operator applying to the
variable B, because a LineTerminator occurs between B and ++.

The source

  if (a > b)
  else c = d

is not a valid ECMAScript sentence and is not altered by automatic
semicolon insertion before the ELSE token, even though no production of
the grammar applies at that point, because an automatically inserted
semicolon would then be parsed as an empty statement.

The source

  a = b + c
  (d + e).print()

is not transformed by automatic semicolon insertion, because the
parenthesized expression that begins the second line can be interpreted
as an argument list for a function call:

a = b + c(d + e).print()

In the circumstance that an assignment statement must begin with a left
parenthesis, it is a good idea for the programmer to provide an explicit
semicolon at the end of the preceding statement rather than to rely on
automatic semicolon insertion.



ECMASCRIPT LANGUAGE: EXPRESSIONS 


Identifiers

SYNTAX

IdentifierReference~[Yield]~ :

Identifier
[~Yield] YIELD

BindingIdentifier~[Yield]~ :

  _Identifier
  _[~Yield] YIELD

LabelIdentifier~[Yield]~ :

Identifier
[~Yield] YIELD

Identifier :

IdentifierName BUT NOT ReservedWord

Static Semantics: Early Errors

-   

BindingIdentifier : Identifier

-   It is a Syntax Error if this production is contained in strict code
    and the StringValue of Identifier is "ARGUMENTS" or "EVAL".

-   

IdentifierReference~[Yield]~ : YIELD

BindingIdentifier~[Yield]~ : YIELD

LabelIdentifier~[Yield]~ : YIELD

-   It is a Syntax Error if this production has a ~[Yield]~ parameter.

-   It is a Syntax Error if this production is contained in strict
    code.

-   It is a Syntax Error if this production is within the
    GeneratorBody of a _GeneratorMethod, GeneratorDeclaration,_ or
    GeneratorExpression.

IdentifierReference~[Yield]~ : Identifier

BindingIdentifier~[Yield]~ : Identifier

LabelIdentifier~[Yield]~ : Identifier

-   It is a Syntax Error if this production has a ~[Yield]~ parameter
    and StringValue of Identifier is"YIELD".

Identifier :: IdentifierName BUT NOT ReservedWord

-   It is a Syntax Error if this phrase is contained in strict code and
    the StringValue of IdentifierName is: "IMPLEMENTS", "INTERFACE",
    "LET", "PACKAGE", "PRIVATE", "PROTECTED", "PUBLIC", "STATIC", or
    "YIELD".

-   -   It is a Syntax Error if StringValue of IdentifierName is the
    same string value as the StringValue of any ReservedWord except
    for YIELD.

NOTE StringValue of IdentifierName normalizes any Unicode escape
sequences in IdentifierName hence such escapes cannot be used to write
an Identifier whose code point sequence is the same as a
ReservedWord.

Static Semantics: BoundNames

See also: 13.2.1.2, 13.2.2.1, 13.6.4.2, 14.1.3, 14.2.2, 14.4.2, 14.5.2,
15.2.2.2, 15.2.3.1.

BindingIdentifier : Identifier

1.  Return a new List containing the StringValue of Identifier.

BindingIdentifier : YIELD

1.  Return a new List containing "YIELD".

Static Semantics: IsValidSimpleAssignmentTarget

See also: 12.2.0.4, 12.2.9.3, 12.3.1.3, 12.4.3, 12.5.3, 12.6.2, 12.7.2,
12.8.2, 12.9.2, 12.10.2, 12.11.2, 12.12.2, 12.13.2, 12.14.3, 12.15.2.

IdentifierReference : Identifier

1.  If this IdentifierReference is contained in strict code and
    StringValue of Identifier is "EVAL" or "ARGUMENTS", return FALSE.

2.  Return TRUE.

IdentifierReference : YIELD

1.  Return TRUE.

1.  

Static Semantics: StringValue

See also: 11.6.1.2, 11.8.4.2.

IdentifierReference : YIELD

BindingIdentifier : YIELD

LabelIdentifier : YIELD

1.  Return "YIELD".

1.  

Identifier : IdentifierName BUT NOT ReservedWord

1.  Return the StringValue of IdentifierName.

Runtime Semantics: BindingInitialization

  With arguments value and environment.

See also: 13.2.3.5, 13.6.4.8.

NOTE UNDEFINED is passed for environment to indicate that a PutValue
operation should be used to assign the initialization value. This is the
case for VAR statements and formal parameter lists of some non-strict
functions (See 9.2.13). In those cases a lexical binding is hoisted and
preinitialized prior to evaluation of its initializer.

BindingIdentifier : Identifier

1.  Let name be StringValue of Identifier.

2.  Return InitializeBoundName( name, value, environment).

1.  

BindingIdentifier : YIELD

1.  Return InitializeBoundName("YIELD", value, environment).

Runtime Semantics: InitializeBoundName(name, value, environment)

1.  Assert: Type(name) is String.

2.  If environment is not UNDEFINED, then

3.  a.  Let env be the environment record component of environment.

    b.  Call the InitializeBinding concrete method of env passing
        name and value as the arguments.

    c.  Return NormalCompletion(UNDEFINED).

4.  Else

    a.  Let lhs be ResolveBinding(name).

    b.  Return PutValue(lhs, value).

Runtime Semantics: Evaluation

IdentifierReference : Identifier

1.  Return ResolveBinding(StringValue of Identifier).

IdentifierReference : YIELD

1.  Return ResolveBinding("YIELD").

NOTE 1: The result of evaluating an IdentifierReference is always a
value of type Reference.

NOTE 2: In non-strict code, the keyword YIELD may be used as an
identifier. Evaluating the IdentifierReference production resolves the
binding of YIELD as if it was an Identifier. Early Error restriction
ensures that such an evaluation only can occur for non-strict code. See
13.2.1 for the handling of YIELD in binding creation contexts.


Primary Expression

Syntax

PrimaryExpression~[Yield]~ :

THIS
IdentifierReference~[?Yield]~
Literal
ArrayLiteral~[?Yield]~
ObjectLiteral~[?Yield]~
FunctionExpression
ClassExpression
GeneratorExpression
RegularExpressionLiteral
TemplateLiteral~[?Yield]~
CoverParenthesizedExpressionAndArrowParameterList~[?Yield]~

CoverParenthesizedExpressionAndArrowParameterList~[Yield]~ :

( Expression~[In,\ ?Yield]~ )
( )
( ... BindingIdentifier~[?Yield]~ )
( Expression~[In,\ ?Yield]~ , ... BindingIdentifier~[?Yield]~ )

Supplemental Syntax

When processing the production

PrimaryExpression~[Yield]~ :
CoverParenthesizedExpressionAndArrowParameterList_~[?Yield]~
_the interpretation of
CoverParenthesizedExpressionAndArrowParameterList is refined using the
following grammar:

ParenthesizedExpression~[Yield]~ :

( Expression~[In,\ ?Yield]~ )

Semantics

Static Semantics: CoveredParenthesizedExpression

CoverParenthesizedExpressionAndArrowParameterList~[Yield]~ : (
Expression~[In,\ ?Yield]~ )

1.  Return the result of parsing the lexical token stream matched by
    CoverParenthesizedExpressionAndArrowParameterList~[Yield]~ using
    either ParenthesizedExpression or
    ParenthesizedExpression~[Yield]~ as the goal symbol depending upon
    whether the ~[Yield]~ grammar parameter was present when
    CoverParenthesizedExpressionAndArrowParameterList was matched.

Static Semantics: IsFunctionDefinition

See also: 12.2.9.2, 12.3.1.2, 12.4.2, 12.5.2, 12.6.1, 12.7.1, 12.8.1,
12.9.1, 12.10.1, 12.11.1, 12.12.1, 12.13.1, 12.14.2, 12.15.1, 14.1.12,
14.4.9, 14.5.8.

PrimaryExpression :

THIS
IdentifierReference
Literal
ArrayLiteral
ObjectLiteral
RegularExpressionLiteral
TemplateLiteral

1.  Return FALSE.

PrimaryExpression :
CoverParenthesizedExpressionAndArrowParameterList

1.  Let expr be CoveredParenthesizedExpression of
    CoverParenthesizedExpressionAndArrowParameterList.

2.  Return IsFunctionDefinition of expr.

Static Semantics: IsIdentifierRef

See also: 12.3.1.3.

PrimaryExpression :

IdentifierReference

1.  Return TRUE.

PrimaryExpression :

THIS
Literal
ArrayLiteral
ObjectLiteral
FunctionExpression
ClassExpression
GeneratorExpression
RegularExpressionLiteral
TemplateLiteral
CoverParenthesizedExpressionAndArrowParameterList

1.  Return FALSE.

Static Semantics: IsValidSimpleAssignmentTarget

See also: 12.1.3, 12.2.9.3, 12.3.1.3, 12.4.3, 12.5.3, 12.6.2, 12.7.2,
12.8.2, 12.9.2, 12.10.2, 12.11.2, 12.12.2, 12.13.2, 12.14.3, 12.15.2.

PrimaryExpression :

THIS
Literal
ArrayLiteral
ObjectLiteral
FunctionExpression
ClassExpression
GeneratorExpression
RegularExpressionLiteral
TemplateLiteral

1.  Return FALSE.

1.  2.  

PrimaryExpression :
CoverParenthesizedExpressionAndArrowParameterList

1.  Let expr be CoveredParenthesizedExpression of
    CoverParenthesizedExpressionAndArrowParameterList.

2.  Return IsValidSimpleAssignmentTarget of expr.

The this Keyword

Runtime Semantics: Evaluation

PrimaryExpression : THIS

1.  Return ResolveThisBinding( ) .

Identifier Reference

See 12.1 for IdentifierReference.

1.  

Literals 

Syntax

Literal :

NullLiteral

BooleanLiteral
NumericLiteral
StringLiteral

Runtime Semantics: Evaluation

Literal : NullLiteral

1.  Return NULL.

Literal : BooleanLiteral

1.  Return FALSE if BooleanLiteral is the token FALSE.

2.  Return TRUE if BooleanLiteral is the token TRUE.

Literal : NumericLiteral

1.  Return the number whose value is MV of NumericLiteral as defined
    in 11.8.3.

Literal _: StringLiteral_

1.  Return the StringValue of StringLiteral as defined in 11.8.4.2.

Array Initializer

NOTE An ArrayLiteral is an expression describing the initialization of
an Array object, using a list, of zero or more expressions each of which
represents an array element, enclosed in square brackets. The elements
need not be literals; they are evaluated each time the array initializer
is evaluated.

Array elements may be elided at the beginning, middle or end of the
element list. Whenever a comma in the element list is not preceded by an
AssignmentExpression (i.e., a comma at the beginning or after another
comma), the missing array element contributes to the length of the Array
and increases the index of subsequent elements. Elided array elements
are not defined. If an element is elided at the end of an array, that
element does not contribute to the length of the Array.

Syntax

ArrayLiteral~[Yield]~ :

[ Elision~opt~ ]
[ ElementList~[?Yield]~ ]
[ ElementList~[?Yield]~ , Elision~opt~ ]

ElementList~[Yield]~ :

Elision~opt~ AssignmentExpression~[In,\ ?Yield]~
Elision~opt~ SpreadElement~[?Yield]~
ElementList~[?Yield]~ , Elision~opt~ AssignmentExpression~[In,\ ?Yield]~
ElementList~[?Yield]~ , Elision~opt~ SpreadElement~[?Yield]~

Elision :

,
Elision ,

SpreadElement~[Yield]~ :

... AssignmentExpression~[In,\ ?Yield]~

Static Semantics: ElisionWidth

Elision : ,

1.  Return the numeric value 1.

Elision : Elision ,

1.  Let preceding be the ElisionWidth of Elision.

2.  Return preceding+1.

Runtime Semantics: ArrayAccumulation

  With parameters array and nextIndex.

ElementList : Elision~opt~ AssignmentExpression

1.  Let padding be the ElisionWidth of Elision; if Elision is not
    present, use the numeric value zero.

2.  Let initResult be the result of evaluating AssignmentExpression.

3.  Let initValue be GetValue(initResult).

4.  ReturnIfAbrupt(initValue).

5.  Let created be CreateDataProperty(array,
    ToString(ToUint32(nextIndex+padding)), initValue).

6.  Assert: created is TRUE.

7.  Return nextIndex+padding+1.

ElementList : Elision~opt~ SpreadElement

1.  Let padding be the ElisionWidth of Elision; if Elision is not
    present, use the numeric value zero.

2.  Return the result of performing ArrayAccumulation for
    SpreadElement with arguments array and nextIndex_+_padding.

ElementList : ElementList , Elision~opt~ AssignmentExpression

1.  Let postIndex be the result of performing ArrayAccumulation for
    ElementList with arguments array and nextIndex.

2.  ReturnIfAbrupt(postIndex).

3.  Let padding be the ElisionWidth of Elision; if Elision is not
    present, use the numeric value zero.

4.  Let initResult be the result of evaluating AssignmentExpression.

5.  Let initValue be GetValue(initResult).

6.  ReturnIfAbrupt(initValue).

7.  Let created be CreateDataProperty(array,
    ToString(ToUint32(postIndex_+_padding)), initValue).

8.  Assert: created is TRUE.

9.  Return postIndex_+_padding+1.

ElementList : ElementList , Elision~opt~ SpreadElement

1.  Let postIndex be the result of performing ArrayAccumulation for
    ElementList with arguments array and nextIndex.

2.  ReturnIfAbrupt(postIndex).

3.  Let padding be the ElisionWidth of Elision; if Elision is not
    present, use the numeric value zero.

4.  Return the result of performing ArrayAccumulation for
    SpreadElement with arguments array and postIndex_+_padding.

SpreadElement : ... AssignmentExpression

1.  Let spreadRef be the result of evaluating AssignmentExpression.

2.  Let spreadObj be GetValue(spreadRef).

3.  4.  5.  Let iterator be GetIterator(spreadObj).

6.  ReturnIfAbrupt(iterator).

7.  Repeat

    a.  Let next be IteratorStep(iterator).

    b.  ReturnIfAbrupt(next).

    c.  If next is FALSE, return nextIndex.

    d.  Let nextValue be IteratorValue(next).

    e.  ReturnIfAbrupt(nextValue).

    f.  Let status be CreateDataProperty(array,
        ToString(ToUint32(nextIndex)), nextValue).

    g.  Assert: status is TRUE .

    h.  Let nextIndex be nextIndex + 1.

NOTE CreateDataProperty is used to ensure that own properties are
defined for the array even if the standard built-in Array prototype
object has been modified in a manner that would preclude the creation of
new own properties using [[Set]].

Runtime Semantics: Evaluation

ArrayLiteral : [ Elision~opt~ ]

1.  Let array be ArrayCreate(0).

2.  Let pad be the ElisionWidth of Elision; if Elision is not
    present, use the numeric value zero.

3.  Perform Put(array, "LENGTH", pad, FALSE).

4.  NOTE: The above Put cannot fail because of the nature of the object
    returned by ArrayCreate.

5.  Return array.

ArrayLiteral : [ ElementList ]

1.  Let array be ArrayCreate(0).

2.  Let len be the result of performing ArrayAccumulation for
    ElementList with arguments array and 0.

3.  ReturnIfAbrupt(len).

4.  Perform Put(array, "LENGTH", len, FALSE).

5.  NOTE: The above Put cannot fail because of the nature of the object
    returned by ArrayCreate.

6.  Return array.

ArrayLiteral : [ ElementList , Elision~opt~ ]

1.  Let array be ArrayCreate(0).

2.  Let len be the result of performing ArrayAccumulation for
    ElementList with arguments array and 0.

3.  ReturnIfAbrupt(len).

4.  Let padding be the ElisionWidth of Elision; if Elision is not
    present, use the numeric value zero.

5.  Perform Put(array, "LENGTH", ToUint32(padding_+_len), FALSE).

6.  NOTE: The above Put cannot fail because of the nature of the object
    returned by ArrayCreate.

7.  Return array.

-   -   

1.  2.  

1.  

1.  

1.  

1.  2.  3.  4.  a.  b.  c.  d.  e.  f.  g.  h.  i.  j.  

5.  6.  7.  8.  

1.  2.  3.  

4.  5.  6.  7.  8.  9.  a.  b.  c.  d.  e.  f.  g.  i.  ii. 

    h.  i.  j.  k.  l.  m.  

1.  2.  3.  4.  5.  a.  

6.  a.  

1.  2.  3.  4.  

1.  

Object Initializer

NOTE 1 An object initializer is an expression describing the
initialization of an Object, written in a form resembling a literal. It
is a list of zero or more pairs of property names and associated values,
enclosed in curly brackets. The values need not be literals; they are
evaluated each time the object initializer is evaluated.

Syntax

ObjectLiteral~[Yield]~ :

{ }
{ PropertyDefinitionList~[?Yield]~ }
{ PropertyDefinitionList~[?Yield]~ , }

PropertyDefinitionList~[Yield]~ :

PropertyDefinition~[?Yield]~
PropertyDefinitionList~[?Yield]~ , PropertyDefinition~[?Yield]~

PropertyDefinition~[Yield]~ :

IdentifierReference~[?Yield]~
CoverInitializedName~[?Yield]~
PropertyName~[?Yield]~ : AssignmentExpression~[In,\ ?Yield]~
MethodDefinition~[?Yield]~

PropertyName~[Yield,GeneratorParameter]~ :

LiteralPropertyName
[+GeneratorParameter] ComputedPropertyName
[~GeneratorParameter] ComputedPropertyName~[?Yield]~

LiteralPropertyName :

IdentifierName
StringLiteral
NumericLiteral

ComputedPropertyName~[Yield]~ :

[ AssignmentExpression~[In,\ ?Yield]~ ]

CoverInitializedName~[Yield]~ :

IdentifierReference~[?Yield]~ Initializer~[In,\ ?Yield]~

Initializer~[In,\ Yield]~ :

= AssignmentExpression~[?In,\ ?Yield]~

NOTE 2 MethodDefinition is defined in 14.3.

NOTE 3 In certain contexts, ObjectLiteral is used as a cover grammar
for a more restricted secondary grammar. The CoverInitializedName
production is necessary to fully cover these secondary grammars.
However, use of this production results in an early Syntax Error in
normal contexts where an actual ObjectLiteral is expected.

Static Semantics: Early Errors

PropertyDefinition : MethodDefinition

-   It is a Syntax Error if HasDirectSuper(MethodDefinition) is TRUE.

In addition to describing an actual object initializer the
ObjectLiteral productions are also used as a cover grammar for
ObjectAssignmentPattern (12.14.5). and may be recognized as part of a
CoverParenthesizedExpressionAndArrowParameterList. When
ObjectLiteral appears in a context where ObjectAssignmentPattern is
required the following Early Error rules are NOT applied. In addition,
they are not applied when initially parsing a
CoverParenthesizedExpressionAndArrowParameterList.

-   1.  2.  

PropertyDefinition : CoverInitializedName

-   Always throw a Syntax Error if this production is present

NOTE This production exists so that ObjectLiteral can serve as a cover
grammar for ObjectAssignmentPattern (12.14.5). It cannot occur in an
actual object initializer.

Static Semantics: ComputedPropertyContains

  With parameter symbol.

See also: 14.3.2, 14.4.30, 14.5.5.

PropertyName : LiteralPropertyName

1.  Return FALSE.

PropertyName : ComputedPropertyName

1.  Return the result of ComputedPropertyName Contains symbol.

Static Semantics: Contains

  With parameter symbol.

See also: 5.3, 12.3.1.1, 14.1.4, 14.2.3, 14.4.40, 14.5.4.

PropertyDefinition : MethodDefinition

1.  If symbol is MethodDefinition, return TRUE.

2.  Return the result of ComputedPropertyContains for MethodDefinition
    with argument symbol.

NOTE Static semantic rules that depend upon substructure generally do
not look into function definitions.

LiteralPropertyName : IdentifierName

1.  If symbol is a ReservedWord, return FALSE.

2.  If symbol is an Identifier and StringValue of symbol is the
    same value as the StringValue of IdentifierName, return TRUE;

3.  Return FALSE.

Static Semantics: HasComputedPropertyKey

See also: 14.3.4, 14.4.5

PropertyDefinitionList : PropertyDefinitionList ,
PropertyDefinition

1.  If HasComputedPropertyKey of PropertyDefinitionList is TRUE,
    return TRUE.

2.  Return HasComputedPropertyKey of PropertyDefinition.

PropertyDefinition : IdentifierReference

1.  Return FALSE.

PropertyDefinition : PropertyName : AssignmentExpression

1.  Return IsComputedPropertyKey of PropertyName.

Static Semantics: IsComputedPropertyKey

PropertyName : LiteralPropertyName

1.  Return FALSE.

PropertyName : ComputedPropertyName

1.  Return TRUE.

Static Semantics: PropName

See also: 14.3.5, 14.4.9, 14.5.12

PropertyDefinition : IdentifierReference

1.  Return StringValue of IdentifierReference.

PropertyDefinition : PropertyName : AssignmentExpression

1.  Return PropName of PropertyName.

LiteralPropertyName : IdentifierName

1.  Return StringValue of IdentifierName.

LiteralPropertyName : StringLiteral

1.  Return a String value whose code units are the SV of the
    StringLiteral.

LiteralPropertyName : NumericLiteral

1.  Let nbr be the result of forming the value of the
    NumericLiteral.

2.  Return ToString(nbr).

ComputedPropertyName : [ AssignmentExpression ]

1.  Return empty.

Static Semantics: PropertyNameList

PropertyDefinitionList : PropertyDefinition

1.  If PropName of PropertyDefinition is empty, return a new empty
    List.

2.  Return a new List containing PropName of PropertyDefinition.

PropertyDefinitionList : PropertyDefinitionList ,
PropertyDefinition

1.  Let list be PropertyNameList of PropertyDefinitionList.

2.  If PropName of PropertyDefinition is empty, return list.

3.  Append PropName of PropertyDefinition to the end of list.

4.  Return list.

Runtime Semantics: Evaluation

ObjectLiteral : { }

1.  Return ObjectCreate(%ObjectPrototype%).

ObjectLiteral :

 { PropertyDefinitionList }_
_ { PropertyDefinitionList , }

1.  Let obj be ObjectCreate(%ObjectPrototype%).

2.  Let status be the result of performing
    PropertyDefinitionEvaluation of PropertyDefinitionList with
    arguments obj and TRUE.

3.  ReturnIfAbrupt(status).

4.  Return obj.

1.  

1.  

LiteralPropertyName : IdentifierName

1.  Return StringValue of IdentifierName.

LiteralPropertyName : StringLiteral

1.  Return a String value whose code units are the SV of the
    StringLiteral.

LiteralPropertyName : NumericLiteral

1.  Let nbr be the result of forming the value of the
    NumericLiteral.

2.  Return ToString(nbr).

ComputedPropertyName : [ AssignmentExpression ]

1.  Let exprValue be the result of evaluating AssignmentExpression.

2.  Let propName be GetValue(exprValue).

3.  ReturnIfAbrupt(propName).

4.  Return ToPropertyKey(propName).

Runtime Semantics: PropertyDefinitionEvaluation

  With parameter object and enumerable.

See also: 14.3.10, 14.4.140, B.3.1

PropertyDefinitionList : PropertyDefinitionList ,
PropertyDefinition

1.  Let status be the result of performing
    PropertyDefinitionEvaluation of PropertyDefinitionList with
    arguments object and enumerable.

2.  ReturnIfAbrupt(status).

3.  Return the result of performing PropertyDefinitionEvaluation of
    PropertyDefinition with arguments object and enumerable.

4.  5.  6.  7.  8.  

PropertyDefinition : IdentifierReference

1.  Let propName be StringValue of IdentifierReference.

2.  Let exprValue be the result of evaluating IdentifierReference.

3.  ReturnIfAbrupt(exprValue).

4.  Let propValue be GetValue(exprValue).

5.  ReturnIfAbrupt(propValue).

6.  Assert: enumerable is TRUE.

7.  8.  Return CreateDataPropertyOrThrow(object, propName,
    propValue).

PropertyDefinition : PropertyName : AssignmentExpression

1.  Let propKey be the result of evaluating PropertyName.

2.  ReturnIfAbrupt(propKey).

3.  Let exprValueRef be the result of evaluating
    AssignmentExpression.

4.  Let propValue be GetValue(exprValueRef).

5.  ReturnIfAbrupt(propValue).

6.  If IsFunctionDefinition of AssignmentExpression is TRUE, then

    a.  Assert: propValue is an ECMAScript function object.

    b.  Let referencesSuper be the value of propValue’s
        [[NeedsSuper]] internal slot.

    c.  Let thisMode be the value of propValue’s [[ThisMode]]
        internal slot.

    d.  If thisMode is not lexical and referencesSuper is TRUE, then

        i.  If propValue’s [[HomeObject]] internal slot is UNDEFINED,
            then

            1.  Assert: AssignmentExpression is not a class definition
                whose constructor references SUPER.

            2.  Set propValue’s [[HomeObject]] internal slot to
                object.

            3.  

    e.  If IsAnonymousFunctionDefinition(AssignmentExpression) is
        TRUE, then

        i.  Let hasNameProperty be HasOwnProperty(propValue,
            "NAME").

        ii. ReturnIfAbrupt(hasNameProperty).

        iii. If hasNameProperty is FALSE,

        iv. perform SetFunctionName(propValue, propKey).

7.  Assert: enumerable is TRUE.

8.  9.  Return CreateDataPropertyOrThrow(object, propKey,
    propValue).

_NOTE An alternative semantics for this production is given in_ B.3.1.

Function Defining Expressions

See 14.1 for PrimaryExpression : FunctionExpression.

See 14.4 for PrimaryExpression : GeneratorExpression.

See 14.5 for PrimaryExpression : ClassExpression.

-   

1.  2.  3.  4.  5.  6.  7.  8.  9.  

Regular Expression Literals

Syntax

See 11.8.4.

Static Semantics: Early Errors

PrimaryExpression : RegularExpressionLiteral

-   It is a Syntax Error if BodyText of RegularExpressionLiteral
    cannot be recognized using the goal symbol Pattern of the
    ECMAScript RegExp grammar specified in 21.2.1.

-   -   It is a Syntax Error if FlagText of RegularExpressionLiteral
    contains any code points other than "G", "I", "M", "U", or "Y", or
    if it contains the same code point more than once.

Runtime Semantics: Evaluation

PrimaryExpression : RegularExpressionLiteral

1.  Let pattern be the string value consisting of the UTF-16Encoding
    of each code point of BodyText of RegularExpressionLiteral.

2.  Let flags be the string value consisting of the UTF-16Encoding of
    each code point of FlagText of RegularExpressionLiteral.

3.  Return RegExpCreate(pattern, flags).

Template Literals 

Syntax

TemplateLiteral~[Yield]~ :

NoSubstitutionTemplate
TemplateHead Expression~[In,\ ?Yield]~ [Lexical goal
InputElementTemplateTail] TemplateSpans~[?Yield]~

TemplateSpans~[Yield]~ :

TemplateTail
TemplateMiddleList~[?Yield]~ [Lexical goal InputElementTemplateTail]
TemplateTail

TemplateMiddleList~[Yield]~ :

TemplateMiddle Expression~[In,\ ?Yield]~
TemplateMiddleList~[?Yield]~ [Lexical goal InputElementTemplateTail]
TemplateMiddle Expression~[In,\ ?Yield]~

Static Semantics

Static Semantics: TemplateStrings

  With parameter raw.

TemplateLiteral : NoSubstitutionTemplate

1.  If raw is FALSE, then

    a.  Let string be the TV of NoSubstitutionTemplate.

2.  Else,

    a.  Let string be the TRV of NoSubstitutionTemplate.

3.  Return a List containing the single element, string.

TemplateLiteral : TemplateHead Expression TemplateSpans

1.  If raw is FALSE, then

    a.  Let head be the TV of TemplateHead.

2.  Else,

    a.  Let head be the TRV of TemplateHead.

3.  Let tail be TemplateStrings of TemplateSpans with argument
    raw.

4.  Return a List containing head followed by the element, in order of
    tail.

TemplateSpans : TemplateTail

1.  If raw is FALSE, then

    a.  Let tail be the TV of TemplateTail.

2.  Else,

    a.  Let tail be the TRV of TemplateTail.

3.  Return a List containing the single element, tail.

TemplateSpans : TemplateMiddleList TemplateTail

1.  Let middle be TemplateStrings of TemplateMiddleList with
    argument raw.

2.  If raw is FALSE, then

    a.  Let tail be the TV of TemplateTail.

3.  Else,

    a.  Let tail be the TRV of TemplateTail.

4.  Return a List containing the elements, in order, of middle
    followed by tail.

TemplateMiddleList : TemplateMiddle Expression

1.  If raw is FALSE, then

    a.  Let string be the TV of TemplateMiddle.

2.  Else,

    a.  Let string be the TRV of TemplateMiddle.

3.  Return a List containing the single element, string.

TemplateMiddleList : TemplateMiddleList TemplateMiddle
Expression

1.  Let front be TemplateStrings of TemplateMiddleList with argument
    raw.

2.  If raw is FALSE, then

    a.  Let last be the TV of TemplateMiddle.

3.  Else,

    a.  Let last be the TRV of TemplateMiddle.

4.  Append last as the last element of the List front.

5.  Return front.

Runtime Semantics

Runtime Semantics: ArgumentListEvaluation

See also: 12.3.6.1

TemplateLiteral : NoSubstitutionTemplate

1.  Let siteObj be the result of the abstract operation
    GetTemplateObject passing this TemplateLiteral production as the
    argument.

2.  Return a List containing the one element which is siteObj.

TemplateLiteral : _TemplateHead Expression_ TemplateSpans

1.  Let siteObj be the result of the abstract operation
    GetTemplateObject passing this TemplateLiteral production as the
    argument.

2.  Let firstSub be the result of evaluating Expression.

3.  4.  ReturnIfAbrupt(firstSub).

5.  Let restSub be SubstitutionEvaluation of TemplateSpans.

6.  ReturnIfAbrupt(restSub).

7.  Assert: restSub is a List.

8.  Return a List whose first element is siteObj, whose second
    elements is firstSub, and whose subsequent elements are the
    elements of restSub, in order. restSub may contain no elements.

9.  

Runtime Semantics: GetTemplateObject ( templateLiteral )

The abstract operation GetTemplateObject is called with a grammar
production, templateLiteral, as an argument. It performs the following
steps:

1.  a.  

2.  Let rawStrings be TemplateStrings of templateLiteral with
    argument TRUE.

3.  Let ctx be the running execution context.

4.  Let realm be the ctx’s Realm.

5.  Let templateRegistry be realm.[[templateMap]].

6.  For each element e of templateRegistry, do

    a.  If e.[[strings]] and rawStrings contain the same values in
        the same order, then

        i.  Return e.[[array]].

7.  Let cookedStrings be TemplateStrings of templateLiteral with
    argument FALSE.

8.  9.  Let count be the number of elements in the List
    cookedStrings.

10. Let template be ArrayCreate(count).

11. Let rawObj be ArrayCreate(count).

12. Let index be 0.

13. Repeat while index < count

    a.  Let prop be ToString(index).

    b.  Let cookedValue be the string value List
        cookedStrings_[_index].

    c.  Call the [[DefineOwnProperty]] internal method of template
        with arguments prop and PropertyDescriptor{[[Value]]:
        cookedValue, [[Enumerable]]: TRUE, [[Writable]]: FALSE,
        [[Configurable]]: FALSE}.

    d.  Let rawValue be the string value rawStrings_[_index].

    e.  Call the [[DefineOwnProperty]] internal method of rawObj with
        arguments prop and PropertyDescriptor{[[Value]]: rawValue,
        [[Enumerable]]: TRUE, [[Writable]]: FALSE, [[Configurable]]:
        FALSE}.

    f.  Let index be index+1.

14. Perform SetIntegrityLevel(rawObj, "FROZEN").

15. Call the [[DefineOwnProperty]] internal method of template with
    arguments "RAW" and PropertyDescriptor{[[Value]]: rawObj,
    [[Writable]]: FALSE, [[Enumerable]]: FALSE, [[Configurable]]:
    FALSE}.

16. Perform SetIntegrityLevel(template, "FROZEN").

17. Append the Record{[[strings]]: rawStrings, [[array]]: template}
    to templateRegistry.

18. Return template.

NOTE 1 The creation of a template object cannot result in an abrupt
completion.

NOTE 2 Each TemplateLiteral in the program code of a Realm is
associated with a unique template object that is used in the evaluation
of tagged Templates (12.2.8.2.4). The template objects are frozen and
the same template object is used each time a specific tagged Template is
evaluated. Whether template objects are created lazily upon first
evaluation of the TemplateLiteral or eagerly prior to first evaluation
is an implementation choice that is not observable to ECMAScript code.

NOTE 3 Future editions of this specification may define additional
non-enumerable properties of template objects.

Runtime Semantics: SubstitutionEvaluation

TemplateSpans : TemplateTail

1.  Return an empty List.

2.  

TemplateSpans : TemplateMiddleList TemplateTail

1.  Return the result of SubstitutionEvaluation of TemplateMiddleList.

2.  

TemplateMiddleList : _TemplateMiddle Expression_

1.  Let sub be the result of evaluating Expression.

2.  ReturnIfAbrupt(sub).

3.  Return a List containing only sub.

TemplateMiddleList : TemplateMiddleList TemplateMiddle
Expression

1.  Let preceding be the result of SubstitutionEvaluation of
    TemplateMiddleList .

2.  ReturnIfAbrupt(preceding).

3.  Let next be the result of evaluating Expression.

4.  ReturnIfAbrupt(next).

5.  Append next as the last element of the List preceding.

6.  Return preceding.

Runtime Semantics: Evaluation

TemplateLiteral : NoSubstitutionTemplate

1.  Return the string value whose code units are the elements of the TV
    of NoSubstitutionTemplate as defined in 11.8.6.

TemplateLiteral : TemplateHead Expression TemplateSpans

1.  Let head be the TV of TemplateHead as defined in 11.8.6.

2.  Let sub be the result of evaluating Expression.

3.  Let middle be ToString(sub).

4.  ReturnIfAbrupt(middle).

5.  Let tail be the result of evaluating TemplateSpans .

6.  ReturnIfAbrupt(tail).

7.  Return the string value whose code units are the elements of head
    followed by the elements of middle followed by the elements of
    tail.

NOTE The string conversion semantics applied to the Expression value
are like STRING.PROTOTYPE.CONCAT rather than the + operator.

TemplateSpans : TemplateTail

1.  Let tail be the TV of TemplateTail as defined in 11.8.6.

2.  Return the string consisting of the code units of tail.

TemplateSpans : TemplateMiddleList TemplateTail

1.  Let head be the result of evaluating TemplateMiddleList.

2.  ReturnIfAbrupt(head).

3.  Let tail be the TV of TemplateTail as defined in 11.8.6.

4.  Return the string whose code units are the elements of head
    followed by the elements of tail.

TemplateMiddleList : TemplateMiddle Expression

1.  Let head be the TV of TemplateMiddle as defined in 11.8.6.

2.  Let sub be the result of evaluating Expression.

3.  Let middle be ToString(sub).

4.  ReturnIfAbrupt(middle).

5.  Return the sequence of code units consisting of the code units of
    head followed by the elements of middle.

NOTE The string conversion semantics applied to the Expression value
are like STRING.PROTOTYPE.CONCAT rather than the + operator.

TemplateMiddleList : TemplateMiddleList TemplateMiddle
Expression

1.  Let rest be the result of evaluating TemplateMiddleList .

2.  ReturnIfAbrupt(rest).

3.  Let middle be the TV of TemplateMiddle as defined in 11.8.6.

4.  Let sub be the result of evaluating Expression.

5.  Let last be ToString(sub).

6.  ReturnIfAbrupt(last).

7.  Return the sequence of code units consisting of the elements of
    rest followed by the code units of middle followed by the
    elements of last.

NOTE The string conversion semantics applied to the Expression value
are like STRING.PROTOTYPE.CONCAT rather than the + operator.

The Grouping Operator

Static Semantics: Early Errors

PrimaryExpression :
CoverParenthesizedExpressionAndArrowParameterList

-   It is a Syntax Error if the lexical token sequence matched by
    CoverParenthesizedExpressionAndArrowParameterList cannot be parsed
    with no tokens left over using ParenthesizedExpression as the goal
    symbol.

-   All Early Errors rules for ParenthesizedExpression and its derived
    productions also apply to CoveredParenthesizedExpression of
    CoverParenthesizedExpressionAndArrowParameterList.

Static Semantics: IsFunctionDefinition

See also: 12.2.0.2, 12.3.1.2, 12.4.2, 12.5.2, 12.6.1, 12.7.1, 12.8.1,
12.9.1, 12.10.1, 12.11.1, 12.12.1, 12.13.1, 12.14.2, 12.15.1, 14.1.12,
14.4.9, 14.5.8.

ParenthesizedExpression : ( Expression )

1.  Return IsFunctionDefinition of Expression.

Static Semantics: IsValidSimpleAssignmentTarget

See also: 12.1.3, 12.2.0.3, 12.3.1.3, 12.4.3, 12.5.3, 12.6.2, 12.7.2,
12.8.2, 12.9.2, 12.10.2, 12.11.2, 12.12.2, 12.13.2, 12.14.3, 12.15.2.

ParenthesizedExpression : ( Expression )

1.  Return IsValidSimpleAssignmentTarget of Expression.

Runtime Semantics: Evaluation

PrimaryExpression :
CoverParenthesizedExpressionAndArrowParameterList

1.  Let expr be CoveredParenthesizedExpression of
    CoverParenthesizedExpressionAndArrowParameterList.

2.  Return the result of evaluating expr.

ParenthesizedExpression : ( Expression )

1.  Return the result of evaluating Expression. This may be of type
    Reference.

NOTE This algorithm does not apply GetValue to the result of evaluating
Expression. The principal motivation for this is so that operators
such as DELETE and TYPEOF may be applied to parenthesized expressions.


Left-Hand-Side Expressions

Syntax

MemberExpression~[Yield]~ :

[Lexical goal InputElementRegExp] PrimaryExpression~[?Yield]~
MemberExpression~[?Yield]~ [ Expression~[In,\ ?Yield]~ ]
MemberExpression~[?Yield]~ . IdentifierName
MemberExpression~[?Yield]~ TemplateLiteral~[?Yield]~
SuperProperty~[?Yield]~
MetaProperty
NEW MemberExpression~[?Yield]~ Arguments~[?Yield]~

SuperProperty~[Yield]~ :

SUPER [ Expression~[In,\ ?Yield]~ ]
SUPER . IdentifierName

NewExpression~[Yield]~ :

MemberExpression~[?Yield]~
NEW NewExpression~[?Yield]~

MetaProperty :

NewTarget

NewTarget :

NEW . TARGET

NewExpression~[Yield]~ :

MemberExpression~[?Yield]~
NEW NewExpression~[?Yield]~

CallExpression~[Yield]~ :

MemberExpression~[?Yield]~ Arguments~[?Yield]~
SuperCall~[?Yield]~
CallExpression~[?Yield]~ Arguments~[?Yield]~
CallExpression~[?Yield]~ [ Expression~[In,\ ?Yield]~ ]
CallExpression~[?Yield]~ . IdentifierName
CallExpression~[?Yield]~ TemplateLiteral~[?Yield]~

SuperCall~[Yield]~ :

SUPER Arguments~[?Yield]~

Arguments~[Yield]~ :

( )
( ArgumentList~[?Yield]~ )

ArgumentList~[Yield]~ :

AssignmentExpression~[In,\ ?Yield]~
... AssignmentExpression~[In,\ ?Yield]~
ArgumentList~[?Yield]~ , AssignmentExpression~[In,\ ?Yield]~
ArgumentList~[?Yield]~ , ... AssignmentExpression~[In,\ ?Yield]~

LeftHandSideExpression~[Yield]~ :

NewExpression~[?Yield]~
CallExpression~[?Yield]~

Static Semantics

Static Semantics: Contains

  With parameter symbol.

See also: 5.3, 12.2.5.2, 14.1.4, 14.2.3, 14.4.40, 14.5.4

MemberExpression : MemberExpression . IdentifierName

1.  If MemberExpression Contains symbol is TRUE, return TRUE.

2.  If symbol is a ReservedWord, return FALSE.

3.  If symbol is an Identifier and StringValue of symbol is the
    same value as the StringValue of IdentifierName, return TRUE;

4.  Return FALSE.

SuperProperty : SUPER . IdentifierName

1.  If symbol is the ReservedWord SUPER, return TRUE.

2.  If symbol is a ReservedWord, return FALSE.

3.  If symbol is an Identifier and StringValue of symbol is the
    same value as the StringValue of IdentifierName, return TRUE;

4.  Return FALSE.

1.  2.  3.  

1.  2.  3.  

CallExpression : CallExpression . IdentifierName

1.  If CallExpression Contains symbol is TRUE, return TRUE.

2.  If symbol is a ReservedWord, return FALSE.

3.  If symbol is an Identifier and StringValue of symbol is the
    same value as the StringValue of IdentifierName, return TRUE;

4.  Return FALSE.

Static Semantics: IsFunctionDefinition

See also: 12.2.0.2, 12.2.9.212.2.9.2, 12.4.2, 12.5.2, 12.6.1, 12.7.1,
12.8.1, 12.9.1, 12.10.1, 12.11.1, 12.12.1, 12.13.1, 12.14.2, 12.15.1,
14.1.12, 14.4.8, 14.5.8.

MemberExpression :

MemberExpression [ Expression ]
MemberExpression . IdentifierName
MemberExpression TemplateLiteral
SuperProperty
MetaProperty
NEW MemberExpression Arguments

NewExpression :

NEW NewExpression

CallExpression :

MemberExpression Arguments
SuperCall
CallExpression Arguments
CallExpression [ Expression ]
CallExpression. IdentifierName
CallExpression TemplateLiteral

1.  Return FALSE.

Static Semantics: IsDestructuring

See also: 13.6.4.5.

MemberExpression : PrimaryExpression

1.  If PrimaryExpression is either an ObjectLiteral or an
    ArrayLiteral, return TRUE.

2.  Return FALSE.

MemberExpression :

MemberExpression [ Expression ]
MemberExpression . IdentifierName
MemberExpression TemplateLiteral
SuperProperty
MetaProperty
NEW MemberExpression Arguments

NewExpression :

NEW NewExpression

CallExpression :

MemberExpression Arguments
SuperCall
CallExpression Arguments
CallExpression [ Expression ]
CallExpression. IdentifierName
CallExpression TemplateLiteral

1.  Return FALSE.

Static Semantics: IsIdentifierRef

See also: 12.2.0.3.

LeftHandSideExpression :

CallExpression

MemberExpression :

MemberExpression [ Expression ]
MemberExpression . IdentifierName
MemberExpression TemplateLiteral
SuperProperty
MetaProperty
NEW MemberExpression Arguments

NewExpression :

NEW NewExpression

1.  Return FALSE.

Static Semantics: IsValidSimpleAssignmentTarget

See also: 12.1.3, 12.2.0.3, 12.2.9.3, 12.4.3, 12.5.3, 12.6.2, 12.7.2,
12.8.2, 12.9.2, 12.10.2, 12.11.2, 12.12.2, 12.13.2, 12.14.3, 12.15.2.

CallExpression :

CallExpression [ Expression ]
CallExpression . IdentifierName

MemberExpression :

MemberExpression [ Expression ]
MemberExpression . IdentifierName
SuperProperty

1.  Return TRUE.

CallExpression :

MemberExpression Arguments
SuperCall
CallExpression Arguments
CallExpression TemplateLiteral

NewExpression :

NEW NewExpression

MemberExpression :

MemberExpression TemplateLiteral
NEW MemberExpression Arguments

NewTarget :

NEW . TARGET

1.  Return FALSE.

Property Accessors

NOTE Properties are accessed by name, using either the dot notation:

MemberExpression . IdentifierName
CallExpression . IdentifierName

or the bracket notation:

MemberExpression [ Expression ]
CallExpression [ Expression ]

The dot notation is explained by the following syntactic conversion:

MemberExpression . IdentifierName

is identical in its behaviour to

MemberExpression [ <identifier-name-string> ]

and similarly

CallExpression . IdentifierName

is identical in its behaviour to

CallExpression [ <identifier-name-string> ]

where <identifier-name-string> is the result of evaluating StringValue
of IdentifierName.

Runtime Semantics: Evaluation

MemberExpression : MemberExpression [ Expression ]

1.  Let baseReference be the result of evaluating MemberExpression.

2.  Let baseValue be GetValue(baseReference).

3.  ReturnIfAbrupt(baseValue).

4.  Let propertyNameReference be the result of evaluating
    Expression.

5.  Let propertyNameValue be GetValue(propertyNameReference).

6.  ReturnIfAbrupt(propertyNameValue).

7.  Let bv be RequireObjectCoercible(baseValue).

8.  ReturnIfAbrupt(bv).

9.  Let propertyKey be ToPropertyKey(propertyNameValue).

10. ReturnIfAbrupt(propertyKey).

11. If the code matched by the syntactic production that is being
    evaluated is strict mode code, let strict be TRUE, else let
    strict be FALSE.

12. Return a value of type Reference whose base value is bv and whose
    referenced name is propertyKey, and whose strict reference flag is
    strict.

MemberExpression : MemberExpression . IdentifierName

1.  Let baseReference be the result of evaluating MemberExpression.

2.  Let baseValue be GetValue(baseReference).

3.  ReturnIfAbrupt(baseValue).

4.  Let bv be RequireObjectCoercible(baseValue).

5.  ReturnIfAbrupt(bv).

6.  Let propertyNameString be StringValue of IdentifierName

7.  If the code matched by the syntactic production that is being
    evaluated is strict mode code, let strict be TRUE, else let
    strict be FALSE.

8.  Return a value of type Reference whose base value is bv and whose
    referenced name is propertyNameString, and whose strict reference
    flag is strict.

CallExpression : CallExpression [ Expression ]

Is evaluated in exactly the same manner as MemberExpression :
MemberExpression [ Expression ] except that the contained
CallExpression is evaluated in step 1.

CallExpression : CallExpression . IdentifierName

Is evaluated in exactly the same manner as MemberExpression :
MemberExpression . IdentifierName except that the contained
CallExpression is evaluated in step 1.

The new Operator

Runtime Semantics: Evaluation

NewExpression : NEW NewExpression

1.  2.  3.  4.  5.  Let thisNewExpression be this NewExpression.

6.  7.  8.  9.  10. Return EvaluateNew(thisNewExpression,
    NewExpression, empty).

MemberExpression : NEW MemberExpression Arguments

1.  Let thisMemberExpression be this MemberExpression.

2.  Return EvaluateNew(thisMemberExpression, MemberExpression,
    Arguments).

Runtime Semantics: EvaluateNew(thisCall, constructProduction, arguments)

The abstract operation EvaluateNew with arguments production and
arguments performs the following steps:

1.  Assert: thisCall is either a NewExpression or a
    MemberExpression.

2.  Assert: constructProduction is either a NewExpression or a
    MemberExpression.

3.  Assert: arguments is either empty or an Arguments production.

4.  Let ref be the result of evaluating constructProduction.

5.  Let constructor be GetValue(ref).

6.  ReturnIfAbrupt(constructor).

7.  If arguments is empty, let argList be an empty List.

8.  Else,

    a.  Let argList be ArgumentListEvaluation of arguments.

    b.  ReturnIfAbrupt(argList).

9.  If IsConstructor (constructor) is FALSE, throw a TYPEERROR
    exception.

10. 

11. Let tailCall be IsInTailPosition(thisCall). (See 14.6.1)

12. 

13. If tailCall is TRUE, perform the PrepareForTailCall abstract
    operation.

14. Let result be Construct(constructor, argList).

15. Assert: If tailCall is TRUE, the above call of Construct will not
    return here, but instead evaluation will continue as if the
    following return has already occurred.

16. Return result.

Function Calls

Runtime Semantics: Evaluation

CallExpression : MemberExpression Arguments

1.  Let ref be the result of evaluating MemberExpression.

2.  Let func be GetValue(ref).

3.  ReturnIfAbrupt(func).

4.  If Type(ref) is Reference and IsPropertyReference(ref) is FALSE
    and GetReferencedName(ref) is "EVAL", then

    a.  b.  If SameValue(func, %eval%) is TRUE, then

        i.  Let argList be ArgumentListEvaluation(Arguments).

        ii. ReturnIfAbrupt(argList).

        iii. If argList has no elements, return UNDEFINED.

        iv. Let evalText be the first element of argList.

        v.  If the source code matching this CallExpression is strict
            code, let strictCaller be TRUE. Otherwise let
            strictCaller be FALSE.

        vi. Let evalRealm be the running execution context’s Realm.

        vii. Return PerformEval(evalText, evalRealm, strictCaller,
            TRUE). .

5.  If Type(ref) is Reference, then

    a.  If IsPropertyReference(ref) is TRUE, then

        i.  Let thisValue be GetThisValue(ref).

    b.  Else, the base of ref is an Environment Record

        i.  Let thisValue be the result of calling the WithBaseObject
            concrete method of GetBase(ref).

6.  Else Type(ref) is not Reference,

    a.  Let thisValue be UNDEFINED.

7.  Let thisCall be this CallExpression.

8.  Let tailCall be IsInTailPosition(thisCall). (See 14.6.1)

9.  Return EvaluateDirectCall(func, thisValue, Arguments,
    tailCall).

A CallExpression whose evaluation executes step 4.a.vii is a _direct
eval_.

CallExpression : CallExpression Arguments

1.  Let ref be the result of evaluating CallExpression.

2.  Let thisCall be this CallExpression

3.  Let tailCall be IsInTailPosition(thisCall). (See 14.6.1)

4.  5.  Return EvaluateCall(ref, Arguments, tailCall).

Runtime Semantics: EvaluateCall( ref, arguments, tailPosition )

The abstract operation EvaluateCall takes as arguments a value ref, a
syntactic grammar production arguments, and a Boolean argument
tailPosition. It performs the following steps:

1.  Let func be GetValue(ref).

2.  ReturnIfAbrupt(func).

3.  4.  

5.  6.  7.  If Type(ref) is Reference, then

    a.  If IsPropertyReference(ref) is TRUE, then

        i.  Let thisValue be GetThisValue(ref).

    b.  Else, the base of ref is an Environment Record

        i.  Let thisValue be the result of calling the WithBaseObject
            concrete method of GetBase(ref).

8.  Else Type(ref) is not Reference,

    a.  Let thisValue be UNDEFINED.

9.  10. 11. 12. 13. Return EvaluateDirectCall(func, thisValue,
    arguments, tailPosition).

Runtime Semantics: EvaluateDirectCall( func, thisValue, arguments, tailPosition )

The abstract operation EvaluateDirectCall takes as arguments a value
func, a value thisValue, a syntactic grammar production arguments,
and a Boolean argument tailPosition. It performs the following steps:

1.  Let argList be ArgumentListEvaluation(arguments).

2.  ReturnIfAbrupt(argList).

3.  If Type(func) is not Object, throw a TYPEERROR exception.

4.  If IsCallable(func) is FALSE, throw a TYPEERROR exception.

5.  If tailPosition is TRUE, perform the PrepareForTailCall abstract
    operation.

6.  Let result be Call(func, thisValue, argList).

7.  Assert: If tailPosition is TRUE, the above call will not return
    here, but instead evaluation will continue as if the following
    return has already occurred.

8.  Assert: If result is not an abrupt completion then Type(result)
    is an ECMAScript language type.

9.  Return result.

The super Keyword

-   -   -   

Runtime Semantics: Evaluation

SuperProperty : SUPER [ Expression ]

1.  Let propertyNameReference be the result of evaluating
    Expression.

2.  Let propertyNameValue be GetValue(propertyNameReference).

3.  Let propertyKey be ToPropertyKey(propertyNameValue).

4.  ReturnIfAbrupt(propertyKey).

5.  If the code matched by the syntactic production that is being
    evaluated is strict mode code, let strict be TRUE, else let
    strict be FALSE.

6.  Return MakeSuperPropertyReference(propertyKey, strict).

SuperProperty : SUPER . IdentifierName

1.  Let propertyKey be StringValue of IdentifierName.

2.  If the code matched by the syntactic production that is being
    evaluated is strict mode code, let strict be TRUE, else let
    strict be FALSE.

3.  Return MakeSuperPropertyReference(propertyKey, strict).

4.  

1.  2.  3.  4.  5.  6.  7.  8.  9.  10. 11. a.  

12. 13. 14. 15. 16. 17. 18. 

1.  2.  3.  4.  5.  6.  7.  8.  9.  10. 11. 12. 13. 14. 15. 

SuperCall : SUPER Arguments

1.  2.  Let newTarget be GetNewTarget().

3.  If newTarget is UNDEFINED, throw a REFERENCEERROR exception.

4.  5.  6.  7.  Let func be GetSuperConstructor().

8.  ReturnIfAbrupt(func).

9.  Let argList be ArgumentListEvaluation of Arguments.

10. ReturnIfAbrupt(argList).

11. Let result be Construct(func, argList, newTarget).

12. ReturnIfAbrupt(result).

13. 14. Let thisER be GetThisEnvironment( ).

15. Return the result of calling the BindThisValue concrete method of
    thisER with argument result.

Runtime Semantics: GetSuperConstructor ( )

The abstract operation GetSuperConstructor performs the following steps:

1.  Let envRec be GetThisEnvironment( ).

2.  Assert: envRec is a Function environment record.

3.  Let activeFunction be envRec.[[FunctionObject]].

4.  Let superConstructor be the result of calling activeFunction’s
    [[GetPrototypeOf]] internal method.

5.  ReturnIfAbrupt(superConstructor).

6.  If IsConstructor(superConstructor) is FALSE, throw a TYPEERROR
    exception.

7.  Return superConstructor.

8.  

Runtime Semantics: MakeSuperPropertyReference(propertyKey, strict)

The abstract operation MakeSuperPropertyReference with arguments
propertyKey and strict performs the following steps:

1.  Let env be GetThisEnvironment( ).

2.  If the result of calling the HasSuperBinding concrete method of
    env is FALSE, throw a REFERENCEERROR exception.

3.  Let actualThis be the result of calling the GetThisBinding
    concrete method of env.

4.  ReturnIfAbrupt(actualThis).

5.  Let baseValue be the result of calling the GetSuperBase concrete
    method of env.

6.  Let bv be RequireObjectCoercible(baseValue).

7.  ReturnIfAbrupt(bv).

8.  a.  b.  

9.  Return a value of type Reference that is a Super Reference whose
    base value is bv, whose referenced name is propertyKey, whose
    thisValue is actualThis, and whose strict reference flag is
    strict.

10. 

Argument Lists

NOTE The evaluation of an argument list produces a List of values (see
6.2.1).

Runtime Semantics: ArgumentListEvaluation

See also: 12.2.8.2.1

Arguments : ( )

1.  Return an empty List.

ArgumentList : AssignmentExpression

1.  Let ref be the result of evaluating AssignmentExpression.

2.  Let arg be GetValue(ref).

3.  ReturnIfAbrupt(arg).

4.  Return a List whose sole item is arg.

ArgumentList : ... AssignmentExpression

1.  Let list be an empty List.

2.  Let spreadRef be the result of evaluating AssignmentExpression.

3.  Let spreadObj be GetValue(spreadRef).

4.  5.  6.  Let iterator be GetIterator(spreadObj).

7.  ReturnIfAbrupt(iterator).

8.  Repeat

    a.  Let next be IteratorStep(iterator).

    b.  ReturnIfAbrupt(next).

    c.  If next is FALSE, return list.

    d.  Let nextArg be IteratorValue(next).

    e.  ReturnIfAbrupt(nextArg).

    f.  Append nextArg as the last element of list.

ArgumentList : ArgumentList , AssignmentExpression

1.  Let precedingArgs be the result of evaluating ArgumentList.

2.  ReturnIfAbrupt(precedingArgs).

3.  Let ref be the result of evaluating AssignmentExpression.

4.  Let arg be GetValue(ref).

5.  ReturnIfAbrupt(arg).

6.  Append arg to the end of precedingArgs.

7.  Return precedingArgs.

ArgumentList : ArgumentList , ... AssignmentExpression

1.  Let precedingArgs be the result of evaluating ArgumentList.

2.  Let spreadRef be the result of evaluating AssignmentExpression.

3.  4.  5.  6.  Let iterator be GetIterator(GetValue(spreadRef) ).

7.  ReturnIfAbrupt(iterator).

8.  Repeat

    a.  Let next be IteratorStep(iterator).

    b.  ReturnIfAbrupt(next).

    c.  If next is FALSE, return precedingArgs.

    d.  Let nextArg be IteratorValue(next).

    e.  ReturnIfAbrupt(nextArg).

    f.  Append nextArg as the last element of precedingArgs.

Tagged Templates

NOTE A tagged template is a function call where the arguments of the
call are derived from a TemplateLiteral (12.2.8). The actual arguments
include a template object (12.2.8.2.2) and the values produced by
evaluating the expressions embedded within the TemplateLiteral.

Runtime Semantics: Evaluation

MemberExpression : MemberExpression TemplateLiteral

1.  Let tagRef be the result of evaluating MemberExpression.

2.  3.  Let thisCall be this MemberExpression.

4.  Let tailCall be IsInTailPosition(thisCall). (See 14.6.1)

5.  Return EvaluateCall(tagRef, TemplateLiteral, tailCall).

CallExpression : CallExpression TemplateLiteral

1.  Let tagRef be the result of evaluating CallExpression.

2.  3.  Let thisCall be this CallExpression.

4.  Let tailCall be IsInTailPosition(thisCall). (See 14.6.1)

5.  Return EvaluateCall(tagRef, TemplateLiteral, tailCall).

Meta Properties

Runtime Semantics: Evaluation

NewTarget : NEW . TARGET

1.  Return GetNewTarget().


Postfix Expressions

Syntax

PostfixExpression~[Yield]~ :

LeftHandSideExpression~[?Yield]~
LeftHandSideExpression~[?Yield]~ [no LineTerminator here] ++
LeftHandSideExpression~[?Yield]~ [no LineTerminator here] --

Static Semantics: Early Errors

PostfixExpression :

LeftHandSideExpression ++
LeftHandSideExpression --

-   It is an early Reference Error if IsValidSimpleAssignmentTarget of
    LeftHandSideExpression is FALSE.

Static Semantics: IsFunctionDefinition

See also: 12.2.0.2, 12.2.9.212.2.9.2, 12.3.1.2, 12.5.2, 12.6.1, 12.7.1,
12.8.1, 12.9.1, 12.10.1, 12.11.1, 12.12.1, 12.13.1, 12.14.2, 12.15.1,
14.1.12, 14.4.8, 14.5.8

PostfixExpression :

LeftHandSideExpression ++
LeftHandSideExpression --

1.  Return FALSE.

Static Semantics: IsValidSimpleAssignmentTarget

See also: 12.1.3, 12.2.0.3, 12.2.9.3, 12.3.1.3, 12.5.3, 12.6.2, 12.7.2,
12.8.2, 12.9.2, 12.10.2, 12.11.2, 12.12.2, 12.13.2, 12.14.3, 12.15.2.

PostfixExpression :

LeftHandSideExpression ++
LeftHandSideExpression --

1.  Return FALSE.

Postfix Increment Operator

Runtime Semantics: Evaluation

PostfixExpression : LeftHandSideExpression ++

1.  Let lhs be the result of evaluating LeftHandSideExpression.

2.  Let oldValue be ToNumber(GetValue(lhs)).

3.  ReturnIfAbrupt(oldValue).

4.  Let newValue be the result of adding the value 1 to oldValue,
    using the same rules as for the + operator (see 12.7.5).

5.  Let status be PutValue(lhs, newValue).

6.  ReturnIfAbrupt(status).

7.  Return oldValue.

Postfix Decrement Operator

Runtime Semantics: Evaluation

PostfixExpression : LeftHandSideExpression --

1.  Let lhs be the result of evaluating LeftHandSideExpression.

2.  Let oldValue be ToNumber(GetValue(lhs)).

3.  ReturnIfAbrupt(oldValue).

4.  Let newValue be the result of subtracting the value 1 from
    oldValue, using the same rules as for the - operator (12.7.5).

5.  Let status be PutValue(lhs, newValue).

6.  ReturnIfAbrupt(status).

7.  Return oldValue.


Unary Operators

Syntax

UnaryExpression~[Yield]~ :

PostfixExpression~[?Yield]~
DELETE UnaryExpression~[?Yield]~
VOID UnaryExpression~[?Yield]~
TYPEOF UnaryExpression~[?Yield]~
++ UnaryExpression~[?Yield]~
-- UnaryExpression~[?Yield]~
+ UnaryExpression~[?Yield]~
- UnaryExpression~[?Yield]~
~ UnaryExpression~[?Yield]~
! UnaryExpression~[?Yield]~

Static Semantics: Early Errors

UnaryExpression :

++ UnaryExpression
-- UnaryExpression

-   It is an early Reference Error if IsValidSimpleAssignmentTarget of
    UnaryExpression is FALSE.

Static Semantics: IsFunctionDefinition

See also: 12.2.0.2, 12.2.9.212.2.9.2, 12.3.1.2, 12.4.2, 12.6.1, 12.7.1,
12.8.1, 12.9.1, 12.10.1, 12.11.1, 12.12.1, 12.13.1, 12.14.2, 12.15.1,
14.1.12, 14.4.8, 14.5.8.

UnaryExpression :

DELETE UnaryExpression
VOID UnaryExpression
TYPEOF UnaryExpression
++ UnaryExpression
-- UnaryExpression
+ UnaryExpression
- UnaryExpression
~ UnaryExpression
! UnaryExpression

1.  Return FALSE.

Static Semantics: IsValidSimpleAssignmentTarget

See also: 12.1.3, 12.2.0.3, 12.2.9.3, 12.3.1.3, 12.4.3, 12.6.2, 12.7.2,
12.8.2, 12.9.2, 12.10.2, 12.11.2, 12.12.2, 12.13.2, 12.14.3, 12.15.2.

UnaryExpression :

DELETE UnaryExpression
VOID UnaryExpression
TYPEOF UnaryExpression
++ UnaryExpression
-- UnaryExpression
+ UnaryExpression
- UnaryExpression
~ UnaryExpression
! UnaryExpression

1.  Return FALSE.

The delete Operator

Static Semantics: Early Errors

UnaryExpression : DELETE UnaryExpression

-   It is a Syntax Error if the UnaryExpression is contained in strict
    code and the derived UnaryExpression is PrimaryExpression :
    IdentifierReference.

-   It is a Syntax Error if the derived UnaryExpression is
     _PrimaryExpression :
    CoverParenthesizedExpressionAndArrowParameterList
    _and CoverParenthesizedExpressionAndArrowParameterList ultimately
    derives a phrase that, if used in place of UnaryExpression, would
    produce a Syntax Error according to these rules. This rule is
    recursively applied.

  NOTE The last rule means that expressions such as
   DELETE (((FOO)))
  produce early errors because of recursive application of the first
  rule.

Runtime Semantics: Evaluation

UnaryExpression : DELETE UnaryExpression

1.  Let ref be the result of evaluating UnaryExpression.

2.  ReturnIfAbrupt(ref).

3.  If Type(ref) is not Reference, return TRUE.

4.  If IsUnresolvableReference(ref) is TRUE, then

    a.  Assert: IsStrictReference(ref) is FALSE.

    b.  Return TRUE.

5.  If IsPropertyReference(ref) is TRUE, then

    a.  If IsSuperReference(ref), throw a REFERENCEERROR exception.

    b.  Let deleteStatus be the result of calling the [[Delete]]
        internal method on ToObject(GetBase(ref)), providing
        GetReferencedName(ref) as the argument.

    c.  ReturnIfAbrupt(deleteStatus).

    d.  If deleteStatus is FALSE and IsStrictReference(ref) is TRUE,
        throw a TYPEERROR exception.

    e.  Return deleteStatus.

6.  Else ref is a Reference to an Environment Record binding,

    a.  Let bindings be GetBase(ref).

    b.  Return the result of calling the DeleteBinding concrete method
        of bindings, providing GetReferencedName(ref) as the
        argument.

NOTE When a DELETE operator occurs within strict mode code, a
SYNTAXERROR exception is thrown if its UnaryExpression is a direct
reference to a variable, function argument, or function name. In
addition, if a DELETE operator occurs within strict mode code and the
property to be deleted has the attribute { [[Configurable]]: FALSE }, a
TYPEERROR exception is thrown.

The void Operator

Runtime Semantics: Evaluation

UnaryExpression : VOID UnaryExpression

1.  Let expr be the result of evaluating UnaryExpression.

2.  Let status be GetValue(expr).

3.  ReturnIfAbrupt(status).

4.  Return UNDEFINED.

NOTE GetValue must be called even though its value is not used because
it may have observable side-effects.

The typeof Operator

Runtime Semantics: Evaluation

UnaryExpression : TYPEOF UnaryExpression

1.  Let val be the result of evaluating UnaryExpression.

2.  If Type(val) is Reference, then

    a.  If IsUnresolvableReference(val) is TRUE, return "UNDEFINED".

3.  Let val be GetValue(val).

4.  ReturnIfAbrupt(val).

5.  Return a String according to Table 36.

Table 36 — typeof Operator Results

  -------------------------------------------------------------- ----------------------------------------------------------------------------------------------------------
  _TYPE OF val_                                                  RESULT
  Undefined                                                      "UNDEFINED"
  Null                                                           "OBJECT"
  Boolean                                                        "BOOLEAN"
  Number                                                         "NUMBER"
  String                                                         "STRING"
  Symbol                                                         "SYMBOL"
  Object (ordinary and does not implement [[Call]])              "OBJECT"
  Object (standard exotic and does not implement [[Call]])       "OBJECT"
  Object (implements [[Call]])                                   "FUNCTION"
  Object (non-standard exotic and does not implement [[Call]])   Implementation-defined. Must not be "UNDEFINED", "BOOLEAN", "FUNCTION", "NUMBER", "SYMBOL", or "STRING".
  -------------------------------------------------------------- ----------------------------------------------------------------------------------------------------------

NOTE Implementations are discouraged from defining new TYPEOF result
values for non-standard exotic objects. If possible "OBJECT"should be
used for such objects.

Prefix Increment Operator

Runtime Semantics: Evaluation

UnaryExpression : ++ UnaryExpression

1.  Let expr be the result of evaluating UnaryExpression.

2.  Let oldValue be ToNumber(GetValue(expr)).

3.  ReturnIfAbrupt(oldValue).

4.  Let newValue be the result of adding the value 1 to oldValue,
    using the same rules as for the + operator (see 12.7.5).

5.  Let status be PutValue(expr, newValue).

6.  ReturnIfAbrupt(status).

7.  Return newValue.

Prefix Decrement Operator

Runtime Semantics: Evaluation

UnaryExpression : -- UnaryExpression

1.  Let expr be the result of evaluating UnaryExpression.

2.  Let oldValue be ToNumber(GetValue(expr)).

3.  ReturnIfAbrupt(oldValue).

4.  Let newValue be the result of subtracting the value 1 from
    oldValue, using the same rules as for the - operator (see 12.7.5).

5.  Let status be PutValue(expr, newValue).

6.  ReturnIfAbrupt(status).

7.  Return newValue.

Unary + Operator

NOTE The unary + operator converts its operand to Number type.

Runtime Semantics: Evaluation

UnaryExpression : + UnaryExpression

1.  Let expr be the result of evaluating UnaryExpression.

2.  Return ToNumber(GetValue(expr)).

Unary - Operator

NOTE The unary - operator converts its operand to Number type and then
negates it. Negating +0 produces −0, and negating −0 produces +0.

Runtime Semantics: Evaluation

UnaryExpression : - UnaryExpression

1.  Let expr be the result of evaluating UnaryExpression.

2.  Let oldValue be ToNumber(GetValue(expr)).

3.  ReturnIfAbrupt(oldValue).

4.  If oldValue is NAN, return NAN.

5.  Return the result of negating oldValue; that is, compute a Number
    with the same magnitude but opposite sign.

Bitwise NOT Operator ( ~ )

Runtime Semantics: Evaluation

UnaryExpression : ~ UnaryExpression

1.  Let expr be the result of evaluating UnaryExpression.

2.  Let oldValue be ToInt32(GetValue(expr)).

3.  ReturnIfAbrupt(oldValue).

4.  Return the result of applying bitwise complement to oldValue. The
    result is a signed 32-bit integer.

Logical NOT Operator ( ! )

Runtime Semantics: Evaluation

UnaryExpression : ! UnaryExpression

1.  Let expr be the result of evaluating UnaryExpression.

2.  Let oldValue be ToBoolean(GetValue(expr)).

3.  ReturnIfAbrupt(oldValue).

4.  If oldValue is TRUE, return FALSE.

5.  Return TRUE.


Multiplicative Operators

Syntax

MultiplicativeExpression~[Yield]~ :

UnaryExpression~[?Yield]~
MultiplicativeExpression~[?Yield]~ MultiplicativeOperator
UnaryExpression~[?Yield]~

MultiplicativeOperator : ONE OF

* / %

Static Semantics: IsFunctionDefinition

See also: 12.2.0.2, 12.2.9.212.2.9.2, 12.3.1.2, 12.4.2, 12.5.2, 12.7.1,
12.8.1, 12.9.1, 12.10.1, 12.11.1, 12.12.1, 12.13.1, 12.14.2, 12.15.1,
14.1.12, 14.4.8, 14.5.8.

MultiplicativeExpression :

MultiplicativeExpression MultiplicativeOperator UnaryExpression

1.  Return FALSE.

Static Semantics: IsValidSimpleAssignmentTarget

See also: 12.1.3, 12.2.0.3, 12.2.9.3, 12.3.1.3, 12.4.3, 12.5.3, 12.7.2,
12.8.2, 12.9.2, 12.10.2, 12.11.2, 12.12.2, 12.13.2, 12.14.3, 12.15.2.

MultiplicativeExpression : MultiplicativeExpression
MultiplicativeOperator UnaryExpression

1.  Return FALSE.

Runtime Semantics: Evaluation

MultiplicativeExpression : MultiplicativeExpression
MultiplicativeOperator UnaryExpression

1.  Let left be the result of evaluating MultiplicativeExpression.

2.  Let leftValue be GetValue(left).

3.  ReturnIfAbrupt(leftValue).

4.  Let right be the result of evaluating UnaryExpression.

5.  Let rightValue be GetValue(right).

6.  Let lnum be ToNumber(leftValue).

7.  ReturnIfAbrupt(lnum).

8.  Let rnum be ToNumber(rightValue).

9.  ReturnIfAbrupt(rnum).

10. Return the result of applying the MultiplicativeOperator (*, /, or
    %) to lnum and rnum as specified in 12.6.3.1, 12.6.3.2, or
    12.6.3.3.

Applying the * Operator

The * MultiplicativeOperator performs multiplication, producing the
product of its operands. Multiplication is commutative. Multiplication
is not always associative in ECMAScript, because of finite precision.

The result of a floating-point multiplication is governed by the rules
of IEEE 754 binary double-precision arithmetic:

-   If either operand is NAN, the result is NAN.

-   The sign of the result is positive if both operands have the same
      sign, negative if the operands have different signs.

-   Multiplication of an infinity by a zero results in NAN.

-   Multiplication of an infinity by an infinity results in an infinity.
      The sign is determined by the rule already stated above.

-   Multiplication of an infinity by a finite nonzero value results in a
      signed infinity. The sign is determined by the rule already stated
      above.

-   In the remaining cases, where neither an infinity nor NaN is
      involved, the product is computed and rounded to the nearest
      representable value using IEEE 754 round-to-nearest mode. If the
      magnitude is too large to represent, the result is then an
      infinity of appropriate sign. If the magnitude is too small to
      represent, the result is then a zero of appropriate sign. The
      ECMAScript language requires support of gradual underflow as
      defined by IEEE 754.

Applying the / Operator

The / MultiplicativeOperator performs division, producing the quotient
of its operands. The left operand is the dividend and the right operand
is the divisor. ECMAScript does not perform integer division. The
operands and result of all division operations are double-precision
floating-point numbers. The result of division is determined by the
specification of IEEE 754 arithmetic:

-   If either operand is NAN, the result is NAN.

-   The sign of the result is positive if both operands have the same
      sign, negative if the operands have different signs.

-   Division of an infinity by an infinity results in NAN.

-   Division of an infinity by a zero results in an infinity. The sign
      is determined by the rule already stated above.

-   Division of an infinity by a nonzero finite value results in a
      signed infinity. The sign is determined by the rule already stated
      above.

-   Division of a finite value by an infinity results in zero. The sign
      is determined by the rule already stated above.

-   Division of a zero by a zero results in NAN; division of zero by any
      other finite value results in zero, with the sign determined by
      the rule already stated above.

-   Division of a nonzero finite value by a zero results in a signed
      infinity. The sign is determined by the rule already stated above.

-   In the remaining cases, where neither an infinity, nor a zero, nor
      NAN is involved, the quotient is computed and rounded to the
      nearest representable value using IEEE 754 round-to-nearest mode.
      If the magnitude is too large to represent, the operation
      overflows; the result is then an infinity of appropriate sign. If
      the magnitude is too small to represent, the operation underflows
      and the result is a zero of the appropriate sign. The ECMAScript
      language requires support of gradual underflow as defined by IEEE
      754.

Applying the % Operator

The % MultiplicativeOperator yields the remainder of its operands from
an implied division; the left operand is the dividend and the right
operand is the divisor.

NOTE In C and C++, the remainder operator accepts only integral
operands; in ECMAScript, it also accepts floating-point operands.

The result of a floating-point remainder operation as computed by the %
operator is not the same as the “remainder” operation defined by IEEE
754. The IEEE 754 “remainder” operation computes the remainder from a
rounding division, not a truncating division, and so its behaviour is
not analogous to that of the usual integer remainder operator. Instead
the ECMAScript language defines % on floating-point operations to behave
in a manner analogous to that of the Java integer remainder operator;
this may be compared with the C library function fmod.

The result of an ECMAScript floating-point remainder operation is
determined by the rules of IEEE arithmetic:

-   If either operand is NAN, the result is NAN.

-   The sign of the result equals the sign of the dividend.

-   If the dividend is an infinity, or the divisor is a zero, or both,
      the result is NAN.

-   If the dividend is finite and the divisor is an infinity, the result
      equals the dividend.

-   If the dividend is a zero and the divisor is nonzero and finite, the
      result is the same as the dividend.

-   In the remaining cases, where neither an infinity, nor a zero, nor
      NAN is involved, the floating-point remainder r from a dividend n
      and a divisor d is defined by the mathematical relation r = n − (d
      × q) where q is an integer that is negative only if n/d is
      negative and positive only if n/d is positive, and whose magnitude
      is as large as possible without exceeding the magnitude of the
      true mathematical quotient of n and d. r is computed and rounded
      to the nearest representable value using IEEE 754 round-to-nearest
      mode.


Additive Operators

Syntax

AdditiveExpression~[Yield]~ :

MultiplicativeExpression~[?Yield]~
AdditiveExpression~[?Yield]~ + MultiplicativeExpression~[?Yield]~
AdditiveExpression~[?Yield]~ - MultiplicativeExpression~[?Yield]~

Static Semantics: IsFunctionDefinition

See also: 12.2.0.2, 12.2.9.2, 12.3.1.2, 12.4.2, 12.5.2, 12.6.1, 12.8.1,
12.9.1, 12.10.1, 12.11.1, 12.12.1, 12.13.1, 12.14.2, 12.15.1, 14.1.12,
14.4.8, 14.5.8.

AdditiveExpression :

AdditiveExpression + MultiplicativeExpression
AdditiveExpression - MultiplicativeExpression

1.  Return FALSE.

Static Semantics: IsValidSimpleAssignmentTarget

See also: 12.1.3, 12.2.0.3, 12.2.9.3, 12.3.1.3, 12.4.3, 12.5.3, 12.6.2,
12.8.2, 12.9.2, 12.10.2, 12.11.2, 12.12.2, 12.13.2, 12.14.3, 12.15.2.

AdditiveExpression :

AdditiveExpression + MultiplicativeExpression
AdditiveExpression - MultiplicativeExpression

1.  Return FALSE.

The Addition operator ( + )

NOTE The addition operator either performs string concatenation or
numeric addition.

Runtime Semantics: Evaluation

AdditiveExpression : AdditiveExpression + MultiplicativeExpression

1.  Let lref be the result of evaluating AdditiveExpression.

2.  Let lval be GetValue(lref).

3.  ReturnIfAbrupt(lval).

4.  Let rref be the result of evaluating MultiplicativeExpression.

5.  Let rval be GetValue(rref).

6.  ReturnIfAbrupt(rval).

7.  Let lprim be ToPrimitive(lval).

8.  ReturnIfAbrupt(lprim).

9.  Let rprim be ToPrimitive(rval).

10. ReturnIfAbrupt(rprim).

11. If Type(lprim) is String or Type(rprim) is String, then

12. a.  Let lstr be ToString(lprim).

    b.  ReturnIfAbrupt(lstr).

    c.  Let rstr be ToString(rprim).

    d.  ReturnIfAbrupt(rstr).

    e.  Return the String that is the result of concatenating lstr and
        rstr.

13. Let lnum be ToNumber(lprim).

14. ReturnIfAbrupt(lnum).

15. Let rnum be ToNumber(rprim).

16. ReturnIfAbrupt(rnum).

17. Return the result of applying the addition operation to lnum and
    rnum. See the Note below 12.7.5.

NOTE 1 No hint is provided in the calls to ToPrimitive in steps 7 and 9.
All standard objects except Date objects handle the absence of a hint as
if the hint Number were given; Date objects handle the absence of a hint
as if the hint String were given. Exotic objects may handle the absence
of a hint in some other manner.

NOTE 2 Step 11 differs from step 5 of the Abstract Relational Comparison
algorithm (7.2.9), by using the logical-or operation instead of the
logical-and operation.

The Subtraction Operator ( - )

Runtime Semantics: Evaluation

AdditiveExpression : AdditiveExpression - MultiplicativeExpression

1.  Let lref be the result of evaluating AdditiveExpression.

2.  Let lval be GetValue(lref).

3.  ReturnIfAbrupt(lval).

4.  Let rref be the result of evaluating MultiplicativeExpression.

5.  Let rval be GetValue(rref).

6.  ReturnIfAbrupt(rval).

7.  Let lnum be ToNumber(lval).

8.  ReturnIfAbrupt(lnum).

9.  Let rnum be ToNumber(rval).

10. ReturnIfAbrupt(rnum).

11. Return the result of applying the subtraction operation to lnum
    and rnum. See the note below 12.7.5.

Applying the Additive Operators to Numbers

The + operator performs addition when applied to two operands of numeric
type, producing the sum of the operands. The - operator performs
subtraction, producing the difference of two numeric operands.

Addition is a commutative operation, but not always associative.

The result of an addition is determined using the rules of IEEE 754
binary double-precision arithmetic:

-   If either operand is NAN, the result is NAN.

-   The sum of two infinities of opposite sign is NAN.

-   The sum of two infinities of the same sign is the infinity of that
      sign.

-   The sum of an infinity and a finite value is equal to the infinite
      operand.

-   The sum of two negative zeroes is −0. The sum of two positive
      zeroes, or of two zeroes of opposite sign, is +0.

-   The sum of a zero and a nonzero finite value is equal to the nonzero
      operand.

-   The sum of two nonzero finite values of the same magnitude and
      opposite sign is +0.

-   In the remaining cases, where neither an infinity, nor a zero, nor
      NaN is involved, and the operands have the same sign or have
      different magnitudes, the sum is computed and rounded to the
      nearest representable value using IEEE 754 round-to-nearest mode.
      If the magnitude is too large to represent, the operation
      overflows and the result is then an infinity of appropriate sign.
      The ECMAScript language requires support of gradual underflow as
      defined by IEEE 754.

NOTE The - operator performs subtraction when applied to two operands of
numeric type, producing the difference of its operands; the left operand
is the minuend and the right operand is the subtrahend. Given numeric
operands a and b, it is always the case that a–b produces the same
result as _a +(–b)_.


Bitwise Shift Operators

Syntax

ShiftExpression~[Yield]~ :

AdditiveExpression~[?Yield]~
ShiftExpression~[?Yield]~ << AdditiveExpression~[?Yield]~
ShiftExpression~[?Yield]~ >> AdditiveExpression~[?Yield]~
ShiftExpression~[?Yield]~ >>> AdditiveExpression~[?Yield]~

Static Semantics: IsFunctionDefinition

See also: 12.2.0.2, 12.2.9.2, 12.3.1.2, 12.4.2, 12.5.2, 12.6.1, 12.7.1,
12.9.1, 12.10.1, 12.11.1, 12.12.1, 12.13.1, 12.14.2, 12.15.1, 14.1.12,
14.4.8, 14.5.8.

ShiftExpression :

ShiftExpression << AdditiveExpression
ShiftExpression >> AdditiveExpression
ShiftExpression >>> AdditiveExpression

1.  Return FALSE.

Static Semantics: IsValidSimpleAssignmentTarget

See also: 12.1.3, 12.2.0.3, 12.2.9.3, 12.3.1.3, 12.4.3, 12.5.3, 12.6.2,
12.7.2, 12.9.2, 12.10.2, 12.11.2, 12.12.2, 12.13.2, 12.14.3, 12.15.2.

ShiftExpression :

ShiftExpression << AdditiveExpression
ShiftExpression >> AdditiveExpression
ShiftExpression >>> AdditiveExpression

1.  Return FALSE.

The Left Shift Operator ( << )

NOTE Performs a bitwise left shift operation on the left operand by the
amount specified by the right operand.

Runtime Semantics: Evaluation

ShiftExpression : ShiftExpression << AdditiveExpression

1.  Let lref be the result of evaluating ShiftExpression.

2.  Let lval be GetValue(lref).

3.  ReturnIfAbrupt(lval).

4.  Let rref be the result of evaluating AdditiveExpression.

5.  Let rval be GetValue(rref).

6.  ReturnIfAbrupt(rval).

7.  Let lnum be ToInt32(lval).

8.  ReturnIfAbrupt(lnum).

9.  Let rnum be ToUint32(rval).

10. ReturnIfAbrupt(rnum).

11. Let shiftCount be the result of masking out all but the least
    significant 5 bits of rnum, that is, compute rnum & 0x1F.

12. Return the result of left shifting lnum by shiftCount bits. The
    result is a signed 32-bit integer.

The Signed Right Shift Operator ( >> )

NOTE Performs a sign-filling bitwise right shift operation on the left
operand by the amount specified by the right operand.

Runtime Semantics: Evaluation

ShiftExpression : ShiftExpression >> AdditiveExpression

1.  Let lref be the result of evaluating ShiftExpression.

2.  Let lval be GetValue(lref).

3.  ReturnIfAbrupt(lval).

4.  Let rref be the result of evaluating AdditiveExpression.

5.  Let rval be GetValue(rref).

6.  ReturnIfAbrupt(rval).

7.  Let lnum be ToInt32(lval).

8.  ReturnIfAbrupt(lnum).

9.  Let rnum be ToUint32(rval).

10. ReturnIfAbrupt(rnum).

11. Let shiftCount be the result of masking out all but the least
    significant 5 bits of rnum, that is, compute rnum & 0x1F.

12. Return the result of performing a sign-extending right shift of
    lnum by shiftCount bits. The most significant bit is propagated.
    The result is a signed 32-bit integer.

The Unsigned Right Shift Operator ( >>> )

NOTE Performs a zero-filling bitwise right shift operation on the left
operand by the amount specified by the right operand.

Runtime Semantics: Evaluation

ShiftExpression : ShiftExpression >>> AdditiveExpression

1.  Let lref be the result of evaluating ShiftExpression.

2.  Let lval be GetValue(lref).

3.  ReturnIfAbrupt(lval).

4.  Let rref be the result of evaluating AdditiveExpression.

5.  Let rval be GetValue(rref).

6.  ReturnIfAbrupt(rval).

7.  Let lnum be ToUint32(lval).

8.  ReturnIfAbrupt(lnum).

9.  Let rnum be ToUint32(rval).

10. ReturnIfAbrupt(rnum).

11. Let shiftCount be the result of masking out all but the least
    significant 5 bits of rnum, that is, compute rnum & 0x1F.

12. Return the result of performing a zero-filling right shift of lnum
    by shiftCount bits. Vacated bits are filled with zero. The result
    is an unsigned 32-bit integer.


Relational Operators

NOTE The result of evaluating a relational operator is always of type
Boolean, reflecting whether the relationship named by the operator holds
between its two operands.

Syntax

RelationalExpression~[In,\ Yield]~ :

ShiftExpression~[?Yield]~
RelationalExpression~[?In,\ ?Yield]~ < ShiftExpression~[?Yield]~
RelationalExpression~[?In,\ ?Yield]~ > ShiftExpression~[?Yield]~
RelationalExpression~[?In,\ ?Yield]~ <= ShiftExpression~[?\ Yield]~
RelationalExpression~[?In,\ ?Yield]~ >= ShiftExpression~[?Yield]~
RelationalExpression~[?In,\ ?Yield]~ INSTANCEOF
ShiftExpression~[?Yield]~
[+In] RelationalExpression~[In,\ ?Yield]~ IN ShiftExpression~[?Yield]~

NOTE The [In] grammar parameter is needed to avoid confusing the IN
operator in a relational expression with the IN operator in a FOR
statement.

Static Semantics: IsFunctionDefinition

See also: 12.2.0.2, 12.2.9.2, 12.3.1.2, 12.4.2, 12.5.2, 12.6.1, 12.7.1,
12.8.1, 12.10.1, 12.11.1, 12.12.1, 12.13.1, 12.14.2, 12.15.1, 14.1.12,
14.4.8, 14.5.8.

RelationalExpression :

RelationalExpression < ShiftExpression
RelationalExpression > ShiftExpression
RelationalExpression <= ShiftExpression
RelationalExpression >= ShiftExpression
RelationalExpression INSTANCEOF ShiftExpression
RelationalExpression IN ShiftExpression

1.  Return FALSE.

Static Semantics: IsValidSimpleAssignmentTarget

See also: 12.1.3, 12.2.0.3, 12.2.9.3, 12.3.1.3, 12.4.3, 12.5.3, 12.6.2,
12.7.2, 12.8.2, 12.10.2, 12.11.2, 12.12.2, 12.13.2, 12.14.3, 12.15.2.

RelationalExpression :

RelationalExpression < ShiftExpression
RelationalExpression > ShiftExpression
RelationalExpression <= ShiftExpression
RelationalExpression >= ShiftExpression
RelationalExpression INSTANCEOF ShiftExpression
RelationalExpression IN ShiftExpression

1.  Return FALSE.

Runtime Semantics: Evaluation

RelationalExpression : RelationalExpression < ShiftExpression

1.  Let lref be the result of evaluating RelationalExpression.

2.  Let lval be GetValue(lref).

3.  ReturnIfAbrupt(lval).

4.  Let rref be the result of evaluating ShiftExpression.

5.  Let rval be GetValue(rref).

6.  Let r be the result of performing Abstract Relational Comparison
    lval < rval. (see 7.2.9)

7.  ReturnIfAbrupt(r).

8.  If r is UNDEFINED, return FALSE. Otherwise, return r.

RelationalExpression : RelationalExpression > ShiftExpression

1.  Let lref be the result of evaluating RelationalExpression.

2.  Let lval be GetValue(lref).

3.  ReturnIfAbrupt(lval).

4.  Let rref be the result of evaluating ShiftExpression.

5.  Let rval be GetValue(rref).

6.  Let r be the result of performing Abstract Relational Comparison
    rval < lval with LeftFirst equal to FALSE.

7.  ReturnIfAbrupt(r).

8.  If r is UNDEFINED, return FALSE. Otherwise, return r.

RelationalExpression : RelationalExpression <= ShiftExpression

1.  Let lref be the result of evaluating RelationalExpression.

2.  Let lval be GetValue(lref).

3.  ReturnIfAbrupt(lval).

4.  Let rref be the result of evaluating ShiftExpression.

5.  Let rval be GetValue(rref).

6.  Let r be the result of performing Abstract Relational Comparison
    rval < lval with LeftFirst equal to FALSE.

7.  ReturnIfAbrupt(r).

8.  If r is TRUE or UNDEFINED, return FALSE. Otherwise, return TRUE.

RelationalExpression : RelationalExpression >= ShiftExpression

1.  Let lref be the result of evaluating RelationalExpression.

2.  Let lval be GetValue(lref).

3.  ReturnIfAbrupt(lval).

4.  Let rref be the result of evaluating ShiftExpression.

5.  Let rval be GetValue(rref).

6.  Let r be the result of performing Abstract Relational Comparison
    lval < rval.

7.  8.  ReturnIfAbrupt(r).

9.  If r is TRUE or UNDEFINED, return FALSE. Otherwise, return TRUE.

RelationalExpression : RelationalExpression INSTANCEOF
ShiftExpression

1.  Let lref be the result of evaluating RelationalExpression.

2.  Let lval be GetValue(lref).

3.  ReturnIfAbrupt(lval).

4.  Let rref be the result of evaluating ShiftExpression.

5.  Let rval be GetValue(rref).

6.  ReturnIfAbrupt(rval).

7.  Return InstanceofOperator(lval, rval).

RelationalExpression : RelationalExpression IN ShiftExpression

1.  Let lref be the result of evaluating RelationalExpression.

2.  Let lval be GetValue(lref).

3.  ReturnIfAbrupt(lval).

4.  Let rref be the result of evaluating ShiftExpression.

5.  Let rval be GetValue(rref).

6.  ReturnIfAbrupt(rval).

7.  If Type(rval) is not Object, throw a TYPEERROR exception.

8.  Return HasProperty(rval, ToPropertyKey(lval)).

Runtime Semantics: InstanceofOperator(O, C)

The abstract operation InstanceofOperator(O, C) implements the
generic algorithm for determining if an object O inherits from the
inheritance path defined by constructor C. This abstract operation
performs the following steps:

1.  If Type(C) is not Object, throw a TYPEERROR exception.

2.  Let instOfHandler be GetMethod(C,@@hasInstance).

3.  ReturnIfAbrupt(instOfHandler).

4.  If instOfHandler is not UNDEFINED, then

    a.  Return ToBoolean(Call(instOfHandler, C, «O»)).

    b.  

5.  If IsCallable(C) is FALSE, throw a TYPEERROR exception.

6.  Return OrdinaryHasInstance(C, O).

NOTE Steps 5 and 6 provide compatibility with previous editions of
ECMAScript that did not use a @@hasInstance method to define the
INSTANCEOF operator semantics. If a function object does not define or
inherit @@hasInstance it uses the default INSTANCEOF semantics.


Equality Operators

NOTE The result of evaluating an equality operator is always of type
Boolean, reflecting whether the relationship named by the operator holds
between its two operands.

Syntax

EqualityExpression~[In,\ Yield]~ :

RelationalExpression~[?In,\ ?Yield]~
EqualityExpression~[?In,\ ?Yield]~ ==
RelationalExpression~[?In,\ ?Yield]~
EqualityExpression~[?In,\ ?Yield]~ !=
RelationalExpression~[?In,\ ?Yield]~
EqualityExpression~[?In,\ ?Yield]~ ===
RelationalExpression~[?In,\ ?Yield]~
EqualityExpression~[?In,\ ?Yield]~ !==
RelationalExpression~[?In,\ ?Yield]~

Static Semantics: IsFunctionDefinition

See also: 12.2.0.2, 12.2.9.2, 12.3.1.2, 12.4.2, 12.5.2, 12.6.1, 12.7.1,
12.8.1, 12.9.1, 12.11.1, 12.12.1, 12.13.1, 12.14.2, 12.15.1, 14.1.12,
14.4.8, 14.5.8.

EqualityExpression :

EqualityExpression == RelationalExpression
EqualityExpression != RelationalExpression
EqualityExpression === RelationalExpression
EqualityExpression !== RelationalExpression

1.  Return FALSE.

Static Semantics: IsValidSimpleAssignmentTarget

See also: 12.1.3, 12.2.0.3, 12.2.9.3, 12.3.1.3, 12.4.3, 12.5.3, 12.6.2,
12.7.2, 12.8.2, 12.9.2, 12.11.2, 12.12.2, 12.13.2, 12.14.3, 12.15.2.

EqualityExpression :

EqualityExpression == RelationalExpression
EqualityExpression != RelationalExpression
EqualityExpression === RelationalExpression
EqualityExpression !== RelationalExpression

1.  Return FALSE.

Runtime Semantics: Evaluation

EqualityExpression : EqualityExpression == RelationalExpression

1.  Let lref be the result of evaluating EqualityExpression.

2.  Let lval be GetValue(lref).

3.  ReturnIfAbrupt(lval).

4.  Let rref be the result of evaluating RelationalExpression.

5.  Let rval be GetValue(rref).

6.  ReturnIfAbrupt(rval).

7.  Return the result of performing Abstract Equality Comparison rval
    == lval.

8.  

EqualityExpression : EqualityExpression != RelationalExpression

1.  Let lref be the result of evaluating EqualityExpression.

2.  Let lval be GetValue(lref).

3.  ReturnIfAbrupt(lval).

4.  Let rref be the result of evaluating RelationalExpression.

5.  Let rval be GetValue(rref).

6.  ReturnIfAbrupt(rval).

7.  Let r be the result of performing Abstract Equality Comparison
    rval == lval.

8.  9.  If r is TRUE, return FALSE. Otherwise, return TRUE.

EqualityExpression : EqualityExpression === RelationalExpression

1.  Let lref be the result of evaluating EqualityExpression.

2.  Let lval be GetValue(lref).

3.  ReturnIfAbrupt(lval)

4.  Let rref be the result of evaluating RelationalExpression.

5.  Let rval be GetValue(rref).

6.  ReturnIfAbrupt(rval).

7.  Return the result of performing Strict Equality Comparison rval
    === lval.

8.  

EqualityExpression : EqualityExpression !== RelationalExpression

1.  Let lref be the result of evaluating EqualityExpression.

2.  Let lval be GetValue(lref).

3.  ReturnIfAbrupt(lval).

4.  Let rref be the result of evaluating RelationalExpression.

5.  Let rval be GetValue(rref).

6.  ReturnIfAbrupt(rval).

7.  Let r be the result of performing Strict Equality Comparison
    rval === lval.

8.  9.  If r is TRUE, return FALSE. Otherwise, return TRUE.

NOTE 1 Given the above definition of equality:

-   String comparison can be forced by: "" + A == "" + B.

-   Numeric comparison can be forced by: +A == +B.

-   Boolean comparison can be forced by: !A == !B.

NOTE 2 The equality operators maintain the following invariants:

-   A != B is equivalent to !(A == B).

-   A == B is equivalent to B == A, except in the order of evaluation of
      A and B.

NOTE 3 The equality operator is not always transitive. For example,
there might be two distinct String objects, each representing the same
String value; each String object would be considered equal to the String
value by the == operator, but the two String objects would not be equal
to each other. For Example:

-   NEW STRING("A") == "A" and "A" == NEW STRING("A")are both TRUE.

-   -   NEW STRING("A") == NEW STRING("A") is FALSE.

NOTE 4 Comparison of Strings uses a simple equality test on sequences of
code unit values. There is no attempt to use the more complex,
semantically oriented definitions of character or string equality and
collating order defined in the Unicode specification. Therefore Strings
values that are canonically equal according to the Unicode standard
could test as unequal. In effect this algorithm assumes that both
Strings are already in normalized form.


Binary Bitwise Operators

Syntax

BitwiseANDExpression~[In,\ Yield]~ :

EqualityExpression~[?In,\ ?Yield]~
BitwiseANDExpression~[?In,\ ?Yield]~ &
EqualityExpression~[?In,\ ?Yield]~

BitwiseXORExpression~[In,\ Yield]~ :

BitwiseANDExpression~[?In,\ ?Yield]~
BitwiseXORExpression~[?In,\ ?Yield]~ ^
BitwiseANDExpression~[?In,\ ?Yield]~

BitwiseORExpression~[In,\ Yield]~ :

BitwiseXORExpression~[?In,\ ?Yield]~
BitwiseORExpression~[?In,\ ?Yield]~ |
BitwiseXORExpression~[?In,\ ?Yield]~

Static Semantics: IsFunctionDefinition

See also: 12.2.0.2, 12.2.9.2, 12.3.1.2, 12.4.2, 12.5.2, 12.6.1, 12.7.1,
12.8.1, 12.9.1, 12.10.1, 12.12.1, 12.13.1, 12.14.2, 12.15.1, 14.1.12,
14.4.8, 14.5.8.

BitwiseANDExpression : BitwiseANDExpression & EqualityExpression

BitwiseXORExpression : BitwiseXORExpression ^ BitwiseANDExpression

BitwiseORExpression : BitwiseORExpression | BitwiseXORExpression

1.  Return FALSE.

Static Semantics: IsValidSimpleAssignmentTarget 

See also: 12.1.3, 12.2.0.3, 12.2.9.3, 12.3.1.3, 12.4.3, 12.5.3, 12.6.2,
12.7.2, 12.8.2, 12.9.2, 12.10.2, 12.12.2, 12.13.2, 12.14.3, 12.15.2.

BitwiseANDExpression : BitwiseANDExpression & EqualityExpression

BitwiseXORExpression : BitwiseXORExpression ^ BitwiseANDExpression

BitwiseORExpression : BitwiseORExpression | BitwiseXORExpression

1.  Return FALSE.

Runtime Semantics: Evaluation

The production A : _A @ B_, where @ is one of the bitwise operators in
the productions above, is evaluated as follows:

1.  Let lref be the result of evaluating A.

2.  Let lval be GetValue(lref).

3.  ReturnIfAbrupt(lval).

4.  Let rref be the result of evaluating B.

5.  Let rval be GetValue(rref).

6.  ReturnIfAbrupt(rval).

7.  Let lnum be ToInt32(lval).

8.  ReturnIfAbrupt(lnum).

9.  Let rnum be ToInt32(rval).

10. ReturnIfAbrupt(rnum).

11. Return the result of applying the bitwise operator @ to lnum and
    rnum. The result is a signed 32 bit integer.


Binary Logical Operators

Syntax

LogicalANDExpression~[In,\ Yield]~ :

BitwiseORExpression~[?In,\ ?Yield]~
LogicalANDExpression~[?In,\ ?Yield]~ &&
BitwiseORExpression~[?In,\ ?Yield]~

LogicalORExpression~[In,\ Yield]~ :

LogicalANDExpression~[?In,\ ?Yield]~
LogicalORExpression~[?In,\ ?Yield]~ ||
LogicalANDExpression~[?In,\ ?Yield]~

NOTE The value produced by a && or || operator is not necessarily of
type Boolean. The value produced will always be the value of one of the
two operand expressions.

Static Semantics: IsFunctionDefinition

See also: 12.2.0.2, 12.2.9.2, 12.3.1.2, 12.4.2, 12.5.2, 12.6.1, 12.7.1,
12.8.1, 12.9.1, 12.10.1, 12.11.1, 12.13.1, 12.14.2, 12.15.1, 14.1.12,
14.4.8, 14.5.8.

LogicalANDExpression : LogicalANDExpression && BitwiseORExpression

LogicalORExpression : LogicalORExpression || LogicalANDExpression

1.  Return FALSE.

Static Semantics: IsValidSimpleAssignmentTarget

See also: 12.1.3, 12.2.0.3, 12.2.9.3, 12.3.1.3, 12.4.3, 12.5.3, 12.6.2,
12.7.2, 12.8.2, 12.9.2, 12.10.2, 12.11.2, 12.13.2, 12.14.3, 12.15.2.

LogicalANDExpression : LogicalANDExpression && BitwiseORExpression

LogicalORExpression : LogicalORExpression || LogicalANDExpression

1.  Return FALSE.

Runtime Semantics: Evaluation

LogicalANDExpression : LogicalANDExpression && BitwiseORExpression

1.  Let lref be the result of evaluating LogicalANDExpression.

2.  Let lval be GetValue(lref).

3.  Let lbool be ToBoolean(lval).

4.  ReturnIfAbrupt(lbool).

5.  If lbool is FALSE, return lval.

6.  Let rref be the result of evaluating BitwiseORExpression.

7.  Return GetValue(rref).

LogicalORExpression : LogicalORExpression || LogicalANDExpression

1.  Let lref be the result of evaluating LogicalORExpression.

2.  Let lval be GetValue(lref).

3.  Let lbool be ToBoolean(lval).

4.  ReturnIfAbrupt(lbool).

5.  If lbool is TRUE, return lval.

6.  Let rref be the result of evaluating LogicalANDExpression.

7.  Return GetValue(rref).


Conditional Operator ( ? : )

Syntax

ConditionalExpression~[In,\ Yield]~ :

LogicalORExpression~[?In,\ ?Yield]~
LogicalORExpression~[?In,?Yield]~ ? AssignmentExpression~[In,\ ?Yield]~
: AssignmentExpression~[?In,\ ?Yield]~

NOTE The grammar for a ConditionalExpression in ECMAScript is slightly
different from that in C and Java, which each allow the second
subexpression to be an Expression but restrict the third expression to
be a ConditionalExpression. The motivation for this difference in
ECMAScript is to allow an assignment expression to be governed by either
arm of a conditional and to eliminate the confusing and fairly useless
case of a comma expression as the centre expression.

Static Semantics: IsFunctionDefinition

See also: 12.2.0.2, 12.2.9.2, 12.3.1.2, 12.4.2, 12.5.2, 12.6.1, 12.7.1,
12.8.1, 12.9.1, 12.10.1, 12.11.1, 12.12.1, 12.14.2, 12.15.1, 14.1.12,
14.4.8, 14.5.8.

ConditionalExpression : LogicalORExpression ? AssignmentExpression
: AssignmentExpression

1.  Return FALSE.

Static Semantics: IsValidSimpleAssignmentTarget

See also: 12.1.3, 12.2.0.3, 12.2.9.3, 12.3.1.3, 12.4.3, 12.5.3, 12.6.2,
12.7.2, 12.8.2, 12.9.2, 12.10.2, 12.11.2, 12.12.2, 12.14.3, 12.15.2.

ConditionalExpression : LogicalORExpression ? AssignmentExpression
: AssignmentExpression

1.  Return FALSE.

Runtime Semantics: Evaluation

ConditionalExpression : LogicalORExpression ? AssignmentExpression
: AssignmentExpression

1.  Let lref be the result of evaluating LogicalORExpression.

2.  Let lval be ToBoolean(GetValue(lref)).

3.  ReturnIfAbrupt(lval).

4.  If lval is TRUE, then

    a.  Let trueRef be the result of evaluating the first
        AssignmentExpression.

    b.  Return GetValue(trueRef).

5.  Else

    a.  Let falseRef be the result of evaluating the second
        AssignmentExpression.

    b.  Return GetValue(falseRef).


Assignment Operators

Syntax

AssignmentExpression~[In,\ Yield]~ :

ConditionalExpression~[?In,\ ?Yield]~
[+Yield] YieldExpression~[?In]~
ArrowFunction~[?In,\ ?Yield]~
LeftHandSideExpression~[?Yield]~ = AssignmentExpression~[?In,\ ?Yield]~
LeftHandSideExpression~[?Yield]~ AssignmentOperator
AssignmentExpression~[?In,\ ?Yield]~

AssignmentOperator : ONE OF

  ---- ---- ---- ---- ---- ----- ----- ------ ---- ---- ----
  *=   /=   %=   +=   -=   <<=   >>=   >>>=   &=   ^=   |=
  ---- ---- ---- ---- ---- ----- ----- ------ ---- ---- ----

Static Semantics: Early Errors

AssignmentExpression : LeftHandSideExpression =
AssignmentExpression

-   It is a Syntax Error if LeftHandSideExpression is either an
    ObjectLiteral or an ArrayLiteral and the lexical token sequence
    matched by LeftHandSideExpression cannot be parsed with no tokens
    left over using AssignmentPattern as the goal symbol.

-   -   -   It is an early Reference Error if LeftHandSideExpression
    is neither an ObjectLiteral nor an ArrayLiteral and
    IsValidSimpleAssignmentTarget of LeftHandSideExpression is FALSE.

AssignmentExpression : LeftHandSideExpression AssignmentOperator
AssignmentExpression

-   -   It is an early Reference Error if IsValidSimpleAssignmentTarget
    of LeftHandSideExpression is FALSE.

Static Semantics: IsFunctionDefinition

See also: 12.2.0.2, 12.2.9.2, 12.3.1.2, 12.4.2, 12.5.2, 12.6.1, 12.7.1,
12.8.1, 12.9.1, 12.10.1, 12.11.1, 12.12.1, 12.13.1, 12.15.1, 14.1.12,
14.4.8, 14.5.8.

AssignmentExpression : ArrowFunction

1.  Return TRUE.

AssignmentExpression :

YieldExpression
LeftHandSideExpression = AssignmentExpression
LeftHandSideExpression AssignmentOperator AssignmentExpression

1.  Return FALSE.

Static Semantics: IsValidSimpleAssignmentTarget

See also: 12.1.3, 12.2.0.3, 12.2.9.3, 12.3.1.3, 12.4.3, 12.5.3, 12.6.2,
12.7.2, 12.8.2, 12.9.2, 12.10.2, 12.11.2, 12.12.2, 12.13.2, 12.15.2.

AssignmentExpression :

YieldExpression
ArrowFunction
LeftHandSideExpression = AssignmentExpression
LeftHandSideExpression AssignmentOperator AssignmentExpression

1.  Return FALSE.

Runtime Semantics: Evaluation 

AssignmentExpression~[In,\ Yield]~ :
LeftHandSideExpression~[?Yield]~ =
AssignmentExpression~[?In,\ ?Yield]~

1.  If LeftHandSideExpression is neither an ObjectLiteral nor an
    ArrayLiteral, then

    a.  Let lref be the result of evaluating LeftHandSideExpression.

    b.  ReturnIfAbrupt(lref).

    c.  Let rref be the result of evaluating AssignmentExpression.

    d.  Let rval be GetValue(rref).

    e.  If IsAnonymousFunctionDefinition(AssignmentExpression) and
        IsIdentifierRef of LeftHandSideExpression are both TRUE, then

        i.  Let hasNameProperty be HasOwnProperty(rval, "NAME").

        ii. ReturnIfAbrupt(hasNameProperty).

        iii. If hasNameProperty is FALSE,

        iv. perform SetFunctionName(rval, GetReferencedName(lref)).

        v.  

    f.  Let status be PutValue(lref, rval).

    g.  ReturnIfAbrupt(status).

    h.  Return rval.

2.  Let assignmentPattern be the parse of the source code
    corresponding to LeftHandSideExpression using
    AssignmentPattern~[?Yield]~ as the goal symbol.

3.  Let rref be the result of evaluating AssignmentExpression.

4.  Let rval be GetValue(rref).

5.  ReturnIfAbrupt(rval).

6.  7.  Let status be the result of performing
    DestructuringAssignmentEvaluation of assignmentPattern using
    rval as the argument.

8.  ReturnIfAbrupt(status).

9.  Return rval.

AssignmentExpression : LeftHandSideExpression AssignmentOperator
AssignmentExpression

1.  Let lref be the result of evaluating LeftHandSideExpression.

2.  Let lval be GetValue(lref).

3.  ReturnIfAbrupt(lval).

4.  Let rref be the result of evaluating AssignmentExpression.

5.  Let rval be GetValue(rref).

6.  ReturnIfAbrupt(rval).

7.  Let op be the @ where AssignmentOperator is @=

8.  Let r be the result of applying op to lval and rval as if
    evaluating the expression lval op rval.

9.  Let status be PutValue(lref, r).

10. ReturnIfAbrupt(status).

11. Return r.

NOTE When an assignment occurs within strict mode code, it is an runtime
error if lref in step 1.f.of the first algorithm or step 9 of the
second algorithm it is an unresolvable reference. If it is, a
REFERENCEERROR exception is thrown. The LeftHandSide also may not be a
reference to a data property with the attribute value
{[[Writable]]:FALSE}, to an accessor property with the attribute value
{[[Set]]:UNDEFINED}, nor to a non-existent property of an object for
which the IsExtensible predicate returns the value FALSE. In these cases
a TYPEERROR exception is thrown.

Destructuring Assignment

Supplemental Syntax

In certain circumstances when processing the production
AssignmentExpression : LeftHandSideExpression =
AssignmentExpression the following grammar is used to refine the
interpretation of LeftHandSideExpression.

AssignmentPattern~[Yield]~ :

ObjectAssignmentPattern~[?Yield]~
ArrayAssignmentPattern~[?Yield]~

ObjectAssignmentPattern~[Yield]~ :

{ }
{ AssignmentPropertyList~[?Yield]~ }
{ AssignmentPropertyList~[?Yield]~ , }

ArrayAssignmentPattern~[Yield]~ :

[ Elision~opt~ AssignmentRestElement~[?Yield]opt~ ]
[ AssignmentElementList~[?Yield]~ ]
[ AssignmentElementList~[?Yield]~ , Elision~opt~
AssignmentRestElement~[?Yield]opt~ ]

AssignmentPropertyList~[Yield]~ :

AssignmentProperty~[?Yield]~
AssignmentPropertyList~[?Yield]~ , AssignmentProperty~[?Yield]~

AssignmentElementList~[Yield]~ :

AssignmentElisionElement~[?Yield]~
AssignmentElementList~[?Yield]~ , AssignmentElisionElement~[?Yield]~

AssignmentElisionElement~[Yield]~ :

Elision~opt~ AssignmentElement~[?Yield]~

AssignmentProperty~[Yield]~ :

IdentifierReference~[?Yield]~ Initializer~[In,?Yield]opt~
PropertyName : AssignmentElement~[?Yield]~

AssignmentElement~[Yield]~ :

DestructuringAssignmentTarget~[?Yield]~ Initializer~[In,?Yield]opt~

AssignmentRestElement~[Yield]~ :

... DestructuringAssignmentTarget~[?Yield]~

DestructuringAssignmentTarget~[Yield]~ :

LeftHandSideExpression~[?Yield]~

Static Semantics: Early Errors

AssignmentProperty : _IdentifierReference Initializer_~opt~

-   It is a Syntax Error if IsValidSimpleAssignment of
    IdentifierReference is FALSE.

-   -   

DestructuringAssignmentTarget : LeftHandSideExpression

-   It is a Syntax Error if LeftHandSideExpression is either an
    ObjectLiteral or an ArrayLiteral and if the lexical token
    sequence matched by LeftHandSideExpression cannot be parsed with
    no tokens left over using AssignmentPattern as the goal symbol.

-   It is a Syntax Error if LeftHandSideExpression is neither an
    ObjectLiteral nor an ArrayLiteral and
    IsValidSimpleAssignmentTarget(LeftHandSideExpression) is FALSE.

-   -   

Runtime Semantics: DestructuringAssignmentEvaluation 

  with parameter value

ObjectAssignmentPattern : { }

1.  Let valid be RequireObjectCoercible(value).

2.  ReturnIfAbrupt(valid).

3.  Return NormalCompletion(empty).

ArrayAssignmentPattern : [ ]

1.  Let iterator be GetIterator(value).

2.  ReturnIfAbrupt(iterator).

3.  Return IteratorClose(iterator, NormalCompletion(empty)).

ArrayAssignmentPattern : [ Elision ]

1.  Let iterator be GetIterator(value).

2.  ReturnIfAbrupt(iterator).

3.  Let result be the result of performing
    IteratorDestructuringAssignmentEvaluation of Elision with
    iterator as the argument.

4.  Return IteratorClose(iterator, result).

ArrayAssignmentPattern : [ Elision~opt~ AssignmentRestElement ]

1.  Let iterator be GetIterator(value).

2.  ReturnIfAbrupt(iterator).

3.  If Elision is present, then

    a.  Let status be the result of performing
        IteratorDestructuringAssignmentEvaluation of Elision with
        iterator as the argument.

    b.  If status is an abrupt completion, return
        IteratorClose(iterator, status).

4.  Let result be the result of performing
    IteratorDestructuringAssignmentEvaluation of AssignmentRestElement
    with iterator as the argument.

5.  Return IteratorClose(iterator, result).

ArrayAssignmentPattern : [ AssignmentElementList ]

1.  Let iterator be GetIterator(value).

2.  ReturnIfAbrupt(iterator).

3.  Let result be the result of performing
    IteratorDestructuringAssignmentEvaluation of AssignmentElementList
    using iterator as the argument.

4.  Return IteratorClose(iterator, result).

ArrayAssignmentPattern : [ AssignmentElementList , Elision~opt~
AssignmentRestElement~opt~ ]

1.  Let iterator be GetIterator(value).

2.  ReturnIfAbrupt(iterator).

3.  Let status be the result of performing
    IteratorDestructuringAssignmentEvaluation of AssignmentElementList
    using iterator as the argument.

4.  If status is an abrupt completion, return
    IteratorClose(iterator, status)..

5.  If Elision is present, then

    a.  Let status be the result of performing
        IteratorDestructuringAssignmentEvaluation of Elision with
        iterator as the argument.

    b.  If status is an abrupt completion, return
        IteratorClose(iterator, status)..

6.  If AssignmentRestElement is present, then

    a.  Let status be the result of performing
        IteratorDestructuringAssignmentEvaluation of
        AssignmentRestElement with iterator as the argument.

7.  Return IteratorClose(iterator, status).

8.  

AssignmentPropertyList : AssignmentPropertyList ,
AssignmentProperty

1.  Let status be the result of performing
    DestructuringAssignmentEvaluation for AssignmentPropertyList using
    value as the argument.

2.  ReturnIfAbrupt(status).

3.  Return the result of performing DestructuringAssignmentEvaluation
    for AssignmentProperty using value as the argument.

4.  

AssignmentProperty : _IdentifierReference Initializer_~opt~

1.  Let P be StringValue of IdentifierReference.

2.  Let lref be ResolveBinding(P).

3.  ReturnIfAbrupt(P).

4.  Let v be GetV(value, P).

5.  ReturnIfAbrupt(v).

6.  If Initializer~opt~ is present and v is UNDEFINED, then

    a.  Let defaultValue be the result of evaluating Initializer.

    b.  Let v be GetValue(defaultValue).

    c.  ReturnIfAbrupt(v).

    d.  If IsAnonymousFunctionDefinition(Initializer) is TRUE, then

        i.  Let hasNameProperty be HasOwnProperty(v, "NAME").

        ii. ReturnIfAbrupt(hasNameProperty).

        iii. If hasNameProperty is FALSE,

        iv. perform SetFunctionName(v, P).

            1.  

7.  8.  Return PutValue(lref_,_v).

AssignmentProperty : PropertyName : AssignmentElement

1.  Let name be the result of evaluating PropertyName.

2.  ReturnIfAbrupt(name).

3.  Return the result of performing
    KeyedDestructuringAssignmentEvaluation of AssignmentElement with
    value and name as the arguments.

Runtime Semantics: IteratorDestructuringAssignmentEvaluation 

  with parameters iterator

AssignmentElementList : AssignmentElisionElement

1.  Return the result of performing
    IteratorDestructuringAssignmentEvaluation of
    AssignmentElisionElement using iterator as the argument.

AssignmentElementList : AssignmentElementList ,
AssignmentElisionElement

1.  Let status be the result of performing
    IteratorDestructuringAssignmentEvaluation of AssignmentElementList
    using iterator as the argument.

2.  ReturnIfAbrupt(status).

3.  Return the result of performing
    IteratorDestructuringAssignmentEvaluation of
    AssignmentElisionElement using iterator as the argument.

AssignmentElisionElement : AssignmentElement

1.  Return the result of performing
    IteratorDestructuringAssignmentEvaluation of AssignmentElement
    with iterator as the argument.

AssignmentElisionElement : Elision AssignmentElement

1.  Let status be the result of performing
    IteratorDestructuringAssignmentEvaluation of Elision with
    iterator as the argument.

2.  ReturnIfAbrupt(status).

3.  Return the result of performing
    IteratorDestructuringAssignmentEvaluation of AssignmentElement
    with iterator as the argument.

Elision : ,

1.  Return IteratorStep(iterator).

Elision : Elision ,

1.  Let status be the result of performing
    IteratorDestructuringAssignmentEvaluation of Elision with
    iterator as the argument.

2.  ReturnIfAbrupt(status).

3.  Return IteratorStep(iterator).

AssignmentElement~[Yield]~ : DestructuringAssignmentTarget
Initializer~opt~

1.  If DestructuringAssignmentTarget is neither an ObjectLiteral nor
    an ArrayLiteral, then

    a.  Let lref be the result of evaluating
        DestructuringAssignmentTarget.

    b.  ReturnIfAbrupt(lref).

2.  Let next be IteratorStep(iterator).

3.  ReturnIfAbrupt(next).

4.  If next is FALSE, let value be UNDEFINED

5.  6.  Else

    a.  Let value be IteratorValue(next).

    b.  ReturnIfAbrupt(value).

7.  If Initializer is present and value is UNDEFINED, then

    a.  Let defaultValue be the result of evaluating Initializer.

    b.  Let v be GetValue(defaultValue)

    c.  ReturnIfAbrupt(v).

8.  Else, let v be value.

9.  If DestructuringAssignmentTarget is an ObjectLiteral or an
    ArrayLiteral, then

    a.  Let nestedAssignmentPattern be the parse of the source code
        corresponding to DestructuringAssignmentTarget using either
        AssignmentPattern or AssignmentPattern~[Yield]~ as the goal
        symbol depending upon whether this AssignmentElement has the
        ~Yield~ parameter.

    b.  c.  d.  Return the result of performing
        DestructuringAssignmentEvaluation of nestedAssignmentPattern
        with v as the argument.

10. If Initializer is present and value is UNDEFINED and
    IsAnonymousFunctionDefinition(Initializer) and IsIdentifierRef of
    DestructuringAssignmentTarget are both TRUE, then

    a.  Let hasNameProperty be HasOwnProperty(v, "NAME").

    b.  ReturnIfAbrupt(hasNameProperty).

    c.  If hasNameProperty is FALSE, perform

    d.  SetFunctionName(v, GetReferencedName(lref)).

        i.  

11. Return PutValue(lref, v).

NOTE Left to right evaluation order is maintained by evaluating a
DestructuringAssignmentTarget that is not a destructuring pattern
prior to accessing the iterator or evaluating the Initializer.

AssignmentRestElement~[Yield]~ : ... DestructuringAssignmentTarget

1.  If DestructuringAssignmentTarget is neither an ObjectLiteral nor
    an ArrayLiteral, then

    a.  Let lref be the result of evaluating
        DestructuringAssignmentTarget.

    b.  ReturnIfAbrupt(lref).

2.  a.  b.  

3.  Let A be ArrayCreate(0).

4.  Let n=0;

5.  Let accumulationFinished be FALSE.

6.  Repeat until accumulationFinished is TRUE.

    a.  Let next be IteratorStep(iterator).

    b.  ReturnIfAbrupt(next).

    c.  If next is FALSE, then

        i.  Let accumulationFinished be TRUE.

    d.  else,

        i.  Let nextValue be IteratorValue(next).

        ii. ReturnIfAbrupt(nextValue).

        iii. Let status be CreateDataProperty(A,
            ToString(ToUint32(n)), nextValue).

        iv. Assert: status is TRUE.

        v.  Increment n by 1.

7.  If DestructuringAssignmentTarget is neither an ObjectLiteral nor
    an ArrayLiteral, then

    a.  b.  

8.  a.  b.  c.  Return PutValue(lref, A).

9.  Let nestedAssignmentPattern be the parse of the source code
    corresponding to DestructuringAssignmentTarget using either
    AssignmentPattern or AssignmentPattern~[Yield]~ as the goal
    symbol depending upon whether this AssignmentElement has the
    ~Yield~ parameter.

10. Return the result of performing DestructuringAssignmentEvaluation of
    nestedAssignmentPattern with A as the argument.

Runtime Semantics: KeyedDestructuringAssignmentEvaluation 

  with parameters value and _propertyName _

AssignmentElement~[Yield]~ : DestructuringAssignmentTarget
Initializer~opt~

1.  If DestructuringAssignmentTarget is neither an ObjectLiteral nor
    an ArrayLiteral, then

    a.  Let lref be the result of evaluating
        DestructuringAssignmentTarget.

    b.  ReturnIfAbrupt(lref).

2.  Let v be GetV(value, propertyName).

3.  ReturnIfAbrupt(v).

4.  If Initializer is present and v is UNDEFINED, then

    a.  Let defaultValue be the result of evaluating Initializer.

    b.  Let rhsValue be GetValue(defaultValue)

    c.  ReturnIfAbrupt(rhsValue).

5.  Else, let rhsValue be v.

6.  If DestructuringAssignmentTarget is an ObjectLiteral or an
    ArrayLiteral, then

    a.  Let AssignmentPattern be the parse of the source code
        corresponding to DestructuringAssignmentTarget using either
        AssignmentPattern or AssignmentPattern~[Yield]~ as the goal
        symbol depending upon whether this AssignmentElement has the
        ~Yield~ parameter.

    b.  c.  d.  Return the result of performing
        DestructuringAssignmentEvaluation of AssignmentPattern with
        rhsValue as the argument.

7.  8.  If Initializer is present and v is UNDEFINED and
    IsAnonymousFunctionDefinition(Initializer) and IsIdentifierRef of
    DestructuringAssignmentTarget are both TRUE, then

    a.  Let hasNameProperty be HasOwnProperty(rhsValue, "NAME").

    b.  ReturnIfAbrupt(hasNameProperty).

    c.  If hasNameProperty is FALSE, perform

    d.  SetFunctionName(rhsValue, GetReferencedName(lref)).

        i.  

9.  Return PutValue(lref, rhsValue).


Comma Operator ( , )

Syntax

Expression~[In,\ Yield]~ :

AssignmentExpression~[?In,\ ?Yield]~
Expression~[?In,\ ?Yield]~ , AssignmentExpression~[?In,\ ?Yield]~

Static Semantics: IsFunctionDefinition

See also: 12.2.0.2, 12.2.9.2, 12.3.1.2, 12.4.2, 12.5.2, 12.6.1, 12.7.1,
12.8.1, 12.9.1, 12.10.1, 12.11.1, 12.12.1, 12.13.1, 12.14.2, 14.1.12,
14.4.8, 14.5.8.

Expression _: Expression_ , AssignmentExpression

1.  Return FALSE.

Static Semantics: IsValidSimpleAssignmentTarget

See also: 12.1.3, 12.2.0.3, 12.2.9.3, 12.3.1.3, 12.4.3, 12.5.3, 12.6.2,
12.7.2, 12.8.2, 12.9.2, 12.10.2, 12.11.2, 12.12.2, 12.13.2, 12.14.3.

Expression _: Expression_ , AssignmentExpression

1.  Return FALSE.

Runtime Semantics: Evaluation

Expression : Expression , AssignmentExpression

1.  Let lref be the result of evaluating Expression.

2.  ReturnIfAbrupt(GetValue(lref))

3.  Let rref be the result of evaluating AssignmentExpression.

4.  Return GetValue(rref).

NOTE GetValue must be called even though its value is not used because
it may have observable side-effects.



ECMASCRIPT LANGUAGE: STATEMENTS AND DECLARATIONS


Syntax

Statement~[Yield,\ Return]~ :

BlockStatement~[?Yield,\ ?Return]~
VariableStatement~[?Yield]~
EmptyStatement
ExpressionStatement~[?Yield]~
IfStatement~[?Yield,\ ?Return]~
BreakableStatement~[?Yield,\ ?Return]~
ContinueStatement~[?Yield]~
BreakStatement~[?Yield]~
[+Return] ReturnStatement~[?Yield]~
WithStatement~[?Yield,\ ?Return]~
LabelledStatement~[?Yield,\ ?Return]~
ThrowStatement~[?Yield]~
TryStatement~[?Yield,\ ?Return]~
DebuggerStatement

Declaration~[Yield]~ :

HoistableDeclaration ~[?Yield]~
ClassDeclaration~[?Yield]~
LexicalDeclaration~[In,\ ?Yield]~

HoistableDeclaration~[Yield,\ Default]~ :

FunctionDeclaration~[?Yield,?Default]~
GeneratorDeclaration~[?Yield,\ ?Default]~

BreakableStatement~[Yield,\ Return]~ :

IterationStatement~[?Yield,\ ?Return]~
SwitchStatement~[?Yield,\ ?Return]~


Statement Semantics

Static Semantics: ContainsDuplicateLabels

  With argument labelSet.

See also: 13.1.2, 13.5.2, 13.6.1.1, 13.6.2.1, 13.6.3.2, 13.6.4.3,
13.10.2, 13.11.2, 13.12.2, 13.14.2, 15.2.1.2.

Statement :

VariableStatement
EmptyStatement
ExpressionStatement
ContinueStatement
BreakStatement
ReturnStatement
ThrowStatement
DebuggerStatement

1.  Return FALSE.

Static Semantics: ContainsUndefinedBreakTarget

  With argument labelSet.

See also: 13.1.3, 13.5.3, 13.6.1.2, 13.6.2.2, 13.6.3.3, 13.6.4.4,
13.8.2, 13.10.3, 13.11.3, 13.12.3, 13.14.3, 15.2.1.3.

Statement :

VariableStatement
EmptyStatement
ExpressionStatement
ContinueStatement
ReturnStatement
ThrowStatement
DebuggerStatement

1.  Return FALSE.

Static Semantics: ContainsUndefinedContinueTarget

  With arguments iterationSet and labelSet.

See also: 13.1.4, 13.5.4, 13.6.1.3, 13.6.2.3, 13.6.3.4, 13.6.4.5,
13.7.2, 13.10.4, 13.11.4, 13.12.4,13.14.4, 15.2.1.4.

Statement :

VariableStatement
EmptyStatement
ExpressionStatement
BreakStatement
ReturnStatement
ThrowStatement
DebuggerStatement

1.  Return FALSE.

BreakableStatement : IterationStatement

1.  Let newIterationSet be a copy of iterationSet with all the
    elements of labelSet appended.

2.  Return ContainsUndefinedContinueTarget of IterationStatementList
    with arguments newIterationSet and « ».

Static Semantics: DeclarationPart

HoistableDeclaration : FunctionDeclaration

1.  Return FunctionDeclaration.

HoistableDeclaration : GeneratorDeclaration

1.  Return GeneratorDeclaration.

Declaration : ClassDeclaration

1.  Return ClassDeclaration.

Declaration : LexicalDeclaration

1.  Return LexicalDeclaration.

Static Semantics: VarDeclaredNames

See also: 13.1.11, 13.2.2.2, 13.5.5, 13.6.1.4, 13.6.2.4, 13.6.3.5,
13.6.4.7, 13.10.5, 13.11.7, 13.12.12, 13.14.5, 14.1.18, 14.2.13, 15.1.5,
15.2.1.13.

Statement :

EmptyStatement
ExpressionStatement
ContinueStatement
BreakStatement
ReturnStatement
ThrowStatement
DebuggerStatement

1.  Return a new empty List.

Static Semantics: VarScopedDeclarations

See also: 13.1.12, 13.2.2.3, 13.5.6, 13.6.1.5, 13.6.2.5, 13.6.3.6,
13.6.4.8, 13.10.6, 13.11.8, 13.12.13, 13.14.6, 14.1.19, 14.2.14, 15.1.6,
15.2.1.14.

Statement :

EmptyStatement
ExpressionStatement
ContinueStatement
BreakStatement
ReturnStatement
ThrowStatement
DebuggerStatement

1.  Return a new empty List.

Runtime Semantics: LabelledEvaluation

  With argument labelSet.

See also: 13.6.1.5, 13.6.2.5, 13.6.3.6, 13.6.4.11, 13.12.14.

BreakableStatement : IterationStatement

1.  Let stmtResult be the result of performing LabelledEvaluation of
    IterationStatement with argument labelSet.

2.  If stmtResult.[[type]] is break and stmtResult.[[target]] is
    empty, then

    a.  If stmtResult.[[value]] is empty, let stmtResult be
        NormalCompletion(UNDEFINED).

    b.  Else, let stmtResult be
        NormalCompletion(stmtResult.[[value]])

3.  Return stmtResult.

BreakableStatement : SwitchStatement

1.  Let stmtResult be the result of evaluating SwitchStatement.

2.  If stmtResult.[[type]] is break and stmtResult.[[target]] is
    empty, then

    a.  If stmtResult.[[value]] is empty, let stmtResult be
        NormalCompletion(UNDEFINED).

    b.  Else, let stmtResult be
        NormalCompletion(stmtResult.[[value]])

3.  Return stmtResult.

NOTE A BreakableStatement is one that can be exited via an unlabelled
BreakStatement.

Runtime Semantics: Evaluation

HoistableDeclaration :

FunctionDeclaration
GeneratorDeclaration

1.  Return NormalCompletion(empty).

BreakableStatement :

IterationStatement
SwitchStatement

1.  Let newLabelSet be a new empty List.

2.  Return the result of performing LabelledEvaluation of this
    BreakableStatement with argument newLabelSet.


Block

Syntax

BlockStatement~[Yield,\ Return]~ :

Block~[?Yield,\ ?Return]~

Block~[Yield,\ Return]~ :

{ StatementList~[?Yield,\ ?Return]opt~ }

StatementList~[Yield,\ Return]~ :

StatementListItem~[?Yield,\ ?Return]~
StatementList~[?Yield,\ ?Return]~ StatementListItem~[?Yield,\ ?Return]~

StatementListItem~[Yield,\ Return]~ :

Statement~[?Yield,\ ?Return]~
Declaration~[?Yield]~

Static Semantics: Early Errors

Block : { StatementList }

-   It is a Syntax Error if the LexicallyDeclaredNames of
    StatementList contains any duplicate entries.

-   It is a Syntax Error if any element of the LexicallyDeclaredNames of
    StatementList also occurs in the VarDeclaredNames of
    StatementList.

Static Semantics: ContainsDuplicateLabels

  With argument labelSet.

See also: 13.0.1, 13.5.2, 13.6.1.1, 13.6.2.1, 13.6.3.2, 13.6.4.3,
13.10.2, 13.11.2, 13.12.2, 13.14.2, 15.2.1.2.

Block : { }

1.  Return FALSE.

StatementList : StatementList StatementListItem

1.  Let hasDuplicates be ContainsDuplicateLabels of StatementList
    with argument labelSet.

2.  If hasDuplicates is TRUE, return TRUE.

3.  Return ContainsDuplicateLabels of StatementListItem with argument
    labelSet.

StatementListItem : Declaration

1.  Return FALSE.

Static Semantics: ContainsUndefinedBreakTarget

  With argument labelSet.

See also: 13.0.2, 13.5.3, 13.6.1.2, 13.6.2.2, 13.6.3.3, 13.6.4.4,
13.8.2, 13.10.3, 13.11.3, 13.12.3, 13.14.3, 15.2.1.3.

Block : { }

1.  Return FALSE.

StatementList : StatementList StatementListItem

1.  Let hasUndefinedLabels be ContainsUndefinedBreakTarget of
    StatementList with argument labelSet.

2.  If hasUndefinedLabels is TRUE, return TRUE.

3.  Return ContainsUndefinedBreakTarget of StatementListItem with
    argument labelSet.

StatementListItem : Declaration

1.  Return FALSE.

Static Semantics: ContainsUndefinedContinueTarget

  With arguments iterationSet and labelSet.

See also: 13.0.3, 13.5.4, 13.6.1.3, 13.6.2.3, 13.6.3.4, 13.6.4.5,
13.7.2, 13.10.4, 13.11.4, 13.12.4,13.14.4, 15.2.1.4.

Block : { }

1.  Return FALSE.

StatementList : StatementList StatementListItem

1.  Let hasUndefinedLabels be ContainsUndefinedContinueTarget of
    StatementList with arguments iterationSet and « ».

2.  If hasUndefinedLabels is TRUE, return TRUE.

3.  Return ContainsUndefinedContinueTarget of StatementListItem with
    arguments iterationSet and « ».

StatementListItem : Declaration

1.  Return FALSE.

Static Semantics: LexicallyDeclaredNames

See also: 13.11.2, 13.12.6, 14.1.15, 14.2.10, 15.1.3, 15.2.1.11.

Block : { }

1.  Return a new empty List.

StatementList : StatementList StatementListItem

1.  Let names be LexicallyDeclaredNames of StatementList.

2.  Append to names the elements of the LexicallyDeclaredNames of
    StatementListItem.

3.  Return names.

StatementListItem : Statement

1.  If Statement is Statement : LabelledStatement, return
    LexicallyDeclaredNames of Statement.

2.  Return a new empty List.

StatementListItem : Declaration

1.  Return the BoundNames of Declaration.

Static Semantics: LexicallyScopedDeclarations

See also: 13.11.5, 13.12.6, 14.1.16, 14.2.11, 15.1.4, 15.2.1.12,
15.2.3.8.

StatementList : StatementList StatementListItem

1.  Let declarations be LexicallyScopedDeclarations of
    StatementList.

2.  Append to declarations the elements of the
    LexicallyScopedDeclarations of StatementListItem.

3.  Return declarations.

StatementListItem : Statement

1.  If Statement is Statement : LabelledStatement, return
    LexicallyScopedDeclarations of Statement.

2.  Return a new empty List.

StatementListItem : Declaration

1.  Return a new List containing DeclarationPart of Declaration.

Static Semantics: TopLevelLexicallyDeclaredNames

See also: 13.12.8.

StatementList : StatementList StatementListItem

1.  Let names be TopLevelLexicallyDeclaredNames of StatementList.

2.  Append to names the elements of the TopLevelLexicallyDeclaredNames
    of StatementListItem.

3.  Return names.

StatementListItem : Statement

1.  Return a new empty List.

StatementListItem : Declaration

1.  If Declaration is Declaration : FunctionDeclaration, return a
    new empty List.

2.  If Declaration is Declaration : GeneratorDeclaration, return a
    new empty List.

3.  Return the BoundNames of Declaration.

NOTE At the top level of a function, or script, function declarations
are treated like var declarations rather than like lexical declarations.

Static Semantics: TopLevelLexicallyScopedDeclarations

See also: 13.12.9.

Block : { }

1.  Return a new empty List.

StatementList : StatementList StatementListItem

1.  Let declarations be TopLevelLexicallyScopedDeclarations of
    StatementList.

2.  Append to declarations the elements of the
    TopLevelLexicallyScopedDeclarations of StatementListItem.

3.  Return declarations.

StatementListItem : Statement

1.  Return a new empty List.

StatementListItem : Declaration

1.  If Declaration is Declaration : FunctionDeclaration, return a
    new empty List.

2.  If Declaration is Declaration : GeneratorDeclaration, return a
    new empty List.

3.  Return a new List containing Declaration.

Static Semantics: TopLevelVarDeclaredNames

See also: 13.12.10.

Block : { }

1.  Return a new empty List.

StatementList : StatementList StatementListItem

1.  Let names be TopLevelVarDeclaredNames of StatementList.

2.  Append to names the elements of the TopLevelVarDeclaredNames of
    StatementListItem.

3.  Return names.

StatementListItem : Declaration

1.  If Declaration is Declaration : FunctionDeclaration, return
    the BoundNames of Declaration.

2.  If Declaration is Declaration : GeneratorDeclaration, return
    the BoundNames of Declaration.

3.  Return a new empty List.

StatementListItem : Statement

1.  If Statement is Statement : LabelledStatement, return
    TopLevelVarDeclaredNames of Statement.

2.  Return VarDeclaredNames of Statement.

NOTE At the top level of a function or script, inner function
declarations are treated like var declarations.

Static Semantics: TopLevelVarScopedDeclarations

See also: 13.12.11.

Block : { }

1.  Return a new empty List.

StatementList : StatementList StatementListItem

1.  Let declarations be TopLevelVarScopedDeclarations of
    StatementList.

2.  Append to declarations the elements of the
    TopLevelVarScopedDeclarations of StatementListItem.

3.  Return declarations.

StatementListItem : Statement

1.  If Statement is Statement : LabelledStatement, return
    TopLevelVarScopedDeclarations of Statement.

2.  Return VarScopedDeclarations of Statement.

3.  

StatementListItem : Declaration

1.  If Declaration is Declaration : FunctionDeclaration, return a
    new List containing FunctionDeclaration.

2.  If Declaration is Declaration : GeneratorDeclaration, return a
    new List containing GeneratorDeclaration.

3.  Return a new empty List.

Static Semantics: VarDeclaredNames

See also: 13.0.5, 13.2.2.2, 13.5.5, 13.6.1.4, 13.6.2.4, 13.6.3.5,
13.6.4.7, 13.10.5, 13.11.7, 13.12.12, 13.14.5, 14.1.18, 14.2.13, 15.1.5,
15.2.1.13.

Block : { }

1.  Return a new empty List.

StatementList : StatementList StatementListItem

1.  Let names be VarDeclaredNames of StatementList.

2.  Append to names the elements of the VarDeclaredNames of
    StatementListItem.

3.  Return names.

StatementListItem : Declaration

1.  Return a new empty List.

Static Semantics: VarScopedDeclarations

See also: 13.0.6, 13.2.2.3, 13.5.6, 13.6.1.5, 13.6.2.5, 13.6.3.6,
13.6.4.8, 13.10.6, 13.11.8, 13.12.13, 13.14.6, 14.1.19, 14.2.14, 15.1.6,
15.2.1.14.

Block : { }

1.  Return a new empty List.

StatementList : StatementList StatementListItem

1.  Let declarations be VarScopedDeclarations of StatementList.

2.  Append to declarations the elements of the VarScopedDeclarations
    of StatementListItem.

3.  Return declarations.

1.  2.  

StatementListItem : Declaration

1.  Return a new empty List.

Runtime Semantics: Evaluation

Block : { }

1.  Return NormalCompletion(UNDEFINED).

Block : { StatementList }

1.  Let oldEnv be the running execution context’s LexicalEnvironment.

2.  Let blockEnv be NewDeclarativeEnvironment(oldEnv).

3.  Perform BlockDeclarationInstantiation(StatementList, blockEnv).

4.  Set the running execution context’s LexicalEnvironment to
    blockEnv.

5.  Let blockValue be the result of evaluating StatementList.

6.  Set the running execution context’s LexicalEnvironment to oldEnv.

7.  If blockValue.[[type]] is normal and blockValue.[[value]] is
    empty, then

8.  a.  Return NormalCompletion(UNDEFINED).

9.  Return blockValue.

NOTE No matter how control leaves the Block the LexicalEnvironment is
always restored to its former state.

StatementList : StatementList StatementListItem

1.  Let sl be the result of evaluating StatementList.

2.  ReturnIfAbrupt(sl).

3.  Let s be the result of evaluating StatementListItem.

4.  If s.[[type]] is throw, return s.

5.  6.  If s.[[value]] is empty, let V = sl.[[value]], otherwise
    let V = s.[[value]].

7.  Return Completion{[[type]]: s.[[type]], [[value]]: V,
    [[target]]: s.[[target]]}.

NOTE Steps 5 and 6 of the above algorithm ensure that the value of a
StatementList is the value of the last value producing item in the
StatementList. For example, the following calls to the EVAL function
all return the value 1:

  EVAL("1;;;;;")

  EVAL("1;{}")

  EVAL("1;VAR A;")

Runtime Semantics: BlockDeclarationInstantiation( code, env )

NOTE When a Block or CaseBlock production is evaluated a new
Declarative Environment Record is created and bindings for each block
scoped variable, constant, function, generator function, or class
declared in the block are instantiated in the environment record.

BlockDeclarationInstantiation is performed as follows using arguments
code and env. code is the grammar production corresponding to the
body of the block. env is the declarative environment record in which
bindings are to be created.

1.  Let declarations be the LexicallyScopedDeclarations of code.

2.  3.  For each element d in declarations do

    a.  i.  ii. iii. 

    b.  For each element dn of the BoundNames of d do

        i.  If IsConstantDeclaration of d is TRUE, then

            1.  Call env’s CreateImmutableBinding concrete method
                passing dn and TRUE as the arguments.

        ii. Else,

            1.  Let status be the result of calling env’s
                CreateMutableBinding concrete method passing dn and
                FALSE as the arguments.

            2.  Assert: status is never an abrupt completion.

    c.  If d is a GeneratorDeclaration production or a
        FunctionDeclaration production, then

        i.  Let fn be the sole element of the BoundNames of d

        ii. Let fo be the result of performing
            InstantiateFunctionObject for d with argument env.

        iii. Call env’s InitializeBinding concrete method passing
            fn, and fo as the arguments.

    d.  i.  

4.  a.  b.  c.  


Declarations and the Variable Statement

Let and Const Declarations

NOTE LET and CONST declarations define variables that are scoped to the
running execution context’s LexicalEnvironment. The variables are
created when their containing Lexical Environment is instantiated but
may not be accessed in any way until the variable’s LexicalBinding is
evaluated. A variable defined by a LexicalBinding with an
Initializer is assigned the value of its Initializer’s
AssignmentExpression when the LexicalBinding is evaluated, not when
the variable is created. If a LexicalBinding in a LET declaration does
not have an Initializer the variable is assigned the value UNDEFINED
when the LexicalBinding is evaluated.

Syntax

LexicalDeclaration~[In,\ Yield]~ :

LetOrConst BindingList~[?In,\ ?Yield]~ ;

LetOrConst :

LET
CONST

BindingList~[In,\ Yield]~ :

LexicalBinding~[?In,\ ?Yield]~
BindingList~[?In,\ ?Yield]~ , LexicalBinding~[?In,\ ?Yield]~

LexicalBinding~[In,\ Yield]~ :

BindingIdentifier~[?Yield]~ Initializer~[?In,\ ?Yield]opt
~BindingPattern~[?Yield]~ Initializer~[?In,\ ?Yield]~

Static Semantics: Early Errors

LexicalDeclaration : LetOrConst BindingList ;

-   It is a Syntax Error if the BoundNames of BindingList contains
    "LET".

-   It is a Syntax Error if the BoundNames of BindingList contains any
    duplicate entries.

LexicalBinding : BindingIdentifier Initializer~opt~

-   It is a Syntax Error if Initializer is not present and
    IsConstantDeclaration of the LexicalDeclaration containing this
    production is TRUE.

Static Semantics: BoundNames

See also: 12.1.2, 13.6.4.2, 14.1.3, 14.2.2, 14.4.2, 14.5.2, 15.2.2.2,
15.2.3.1.

LexicalDeclaration : LetOrConst BindingList ;

1.  Return the BoundNames of BindingList.

BindingList : BindingList , LexicalBinding

1.  Let names be the BoundNames of BindingList.

2.  Append to names the elements of the BoundNames of
    LexicalBinding.

3.  Return names.

LexicalBinding : BindingIdentifier Initializer~opt~

1.  Return the BoundNames of BindingIdentifier.

LexicalBinding : BindingPattern Initializer

1.  Return the BoundNames of BindingPattern.

Static Semantics: IsConstantDeclaration

See also: 14.1.11, 14.4.8, 14.5.7, 15.2.3.7.

LexicalDeclaration : LetOrConst BindingList ;

1.  Return IsConstantDeclaration of LetOrConst.

LetOrConst : LET

1.  Return FALSE.

LetOrConst : CONST

1.  Return TRUE.

Runtime Semantics: Evaluation

LexicalDeclaration : LetOrConst BindingList ;

1.  Let next be the result of evaluating BindingList.

2.  ReturnIfAbrupt(next).

3.  Return NormalCompletion(empty).

BindingList : BindingList , LexicalBinding

1.  Let next be the result of evaluating BindingList.

2.  ReturnIfAbrupt(next).

3.  Return the result of evaluating LexicalBinding.

LexicalBinding : BindingIdentifier

1.  Let lhs be ResolveBinding(StringValue of BindingIdentifier).

2.  Return InitializeReferencedBinding(lhs, UNDEFINED).

NOTE A static semantics rule ensures that this form of LexicalBinding
never occurs in a CONST declaration.

LexicalBinding : BindingIdentifier Initializer

1.  Let bindingId be StringValue of BindingIdentifier.

2.  Let lhs be ResolveBinding(bindingId).

3.  Let rhs be the result of evaluating Initializer.

4.  Let value be GetValue(rhs).

5.  ReturnIfAbrupt(value).

6.  If IsAnonymousFunctionDefinition(Initializer) is TRUE, then

    a.  Let hasNameProperty be HasOwnProperty(value, "NAME").

    b.  ReturnIfAbrupt(hasNameProperty).

    c.  If hasNameProperty is FALSE, perform

    d.  SetFunctionName(value, bindingId).

        i.  

7.  8.  Return InitializeReferencedBinding(lhs, value).

LexicalBinding : BindingPattern Initializer

1.  Let rhs be the result of evaluating Initializer.

2.  Let value be GetValue(rhs).

3.  ReturnIfAbrupt(value).

4.  5.  Let env be the running execution context’s LexicalEnvironment.

6.  Return the result of performing BindingInitialization for
    BindingPattern using value and env as the arguments.

Variable Statement

NOTE A VAR statement declares variables that are scoped to the running
execution context’s VariableEnvironment. Var variables are created when
their containing Lexical Environment is instantiated and are initialized
to UNDEFINED when created. Within the scope of any VariableEnvironment a
common BindingIdentifier may appear in more than one
VariableDeclaration but those declarations collective define only one
variable. A variable defined by a VariableDeclaration with an
Initializer is assigned the value of its Initializer’s
AssignmentExpression when the VariableDeclaration is executed, not
when the variable is created.

Syntax

VariableStatement~[Yield]~ :

VAR VariableDeclarationList~[In,\ ?Yield]~ ;

VariableDeclarationList~[In,\ Yield]~ :

VariableDeclaration~[?In,\ ?Yield]~
VariableDeclarationList~[?In,\ ?Yield]~ ,
VariableDeclaration~[?In,\ ?Yield]~

VariableDeclaration~[In,\ Yield]~ :

BindingIdentifier~[?Yield]~ Initializer~[?In,\ ?Yield]opt
~BindingPattern~[Yield]~ Initializer~[?In,\ ?Yield]~

Static Semantics: BoundNames

See also: 13.2.1.2, 12.1.2, 13.6.4.2, 14.1.3, 14.2.2, 14.4.2, 14.5.2,
15.2.2.2, 15.2.3.1.

VariableDeclarationList : VariableDeclarationList ,
VariableDeclaration

1.  Let names be BoundNames of VariableDeclarationList.

2.  Append to names the elements of BoundNames of
    VariableDeclaration.

3.  Return names.

VariableDeclaration : BindingIdentifier Initializer~opt~

1.  Return the BoundNames of BindingIdentifier.

VariableDeclaration : BindingPattern Initializer

1.  Return the BoundNames of BindingPattern.

Static Semantics: VarDeclaredNames

See also: 13.0.5, 13.1.11, 13.5.5, 13.6.1.4, 13.6.2.4, 13.6.3.5,
13.6.4.7, 13.10.5, 13.11.7, 13.12.12, 13.14.5, 14.1.18, 14.2.13, 15.1.5,
15.2.1.13.

VariableStatement : VAR VariableDeclarationList

1.  Return BoundNames of VariableDeclarationList.

Static Semantics: VarScopedDeclarations

See also: 13.0.6, 13.1.12, 13.5.6, 13.6.1.5, 13.6.2.5, 13.6.3.6,
13.6.4.8, 13.10.6, 13.11.8, 13.12.13, 13.14.6, 14.1.19, 14.2.14, 15.1.6,
15.2.1.14.

VariableDeclarationList : VariableDeclaration

1.  Return a new List containing VariableDeclaration.

VariableDeclarationList : VariableDeclarationList ,
VariableDeclaration

1.  Let declarations be VarScopedDeclarations of
    VariableDeclarationList.

2.  Append VariableDeclaration to declarations.

3.  Return declarations.

1.  

1.  

1.  

RUNTIME Semantics: Evaluation

VariableStatement : VAR VariableDeclarationList ;

1.  Let next be the result of evaluating VariableDeclarationList.

2.  ReturnIfAbrupt(next).

3.  Return NormalCompletion( empty).

VariableDeclarationList : VariableDeclarationList ,
VariableDeclaration

1.  Let next be the result of evaluating VariableDeclarationList.

2.  ReturnIfAbrupt(next).

3.  Return the result of evaluating VariableDeclaration.

VariableDeclaration : BindingIdentifier

1.  Return NormalCompletion(empty).

VariableDeclaration : BindingIdentifier Initializer

1.  Let bindingId be StringValue of BindingIdentifier.

2.  Let lhs be ResolveBinding(bindingId)

3.  ReturnIfAbrupt(lhs).

4.  Let rhs be the result of evaluating Initializer.

5.  Let value be GetValue(rhs).

6.  ReturnIfAbrupt(value).

7.  If IsAnonymousFunctionDefinition(Initializer) is TRUE, then

    a.  Let hasNameProperty be HasOwnProperty(value, "NAME").

    b.  ReturnIfAbrupt(hasNameProperty).

    c.  If hasNameProperty is FALSE,

    d.  perform SetFunctionName(value, bindingId).

        i.  

8.  Return PutValue(lhs, value).

NOTE If a VariableDeclaration is nested within a with statement and
the BindingIdentifier in the VariableDeclaration is the same as a
property name of the binding object of the with statement’s object
environment record, then step 7 will assign value to the property
instead of assigning to the VariableEnvironment binding of the
Identifier.

VariableDeclaration : BindingPattern Initializer

1.  Let rhs be the result of evaluating Initializer.

2.  Let rval be GetValue(rhs).

3.  ReturnIfAbrupt(rval).

4.  5.  Return the result of performing BindingInitialization for
    BindingPattern passing rval and UNDEFINED as arguments.

Destructuring Binding Patterns

Syntax

BindingPattern~[Yield,GeneratorParameter]~ :

ObjectBindingPattern~[?Yield,?GeneratorParameter]~
ArrayBindingPattern~[?Yield,?GeneratorParameter]~

ObjectBindingPattern~[Yield,GeneratorParameter]~ :

{ }
{ BindingPropertyList~[?Yield,?GeneratorParameter]~ }
{ BindingPropertyList~[?Yield,?GeneratorParameter]~ , }

ArrayBindingPattern~[Yield,GeneratorParameter]~ :

[ Elision~opt~ BindingRestElement~[?Yield,\ ?GeneratorParameter]opt~ ]
[ BindingElementList~[?Yield,\ ?GeneratorParameter]~ ]
[ BindingElementList~[?Yield,\ ?GeneratorParameter]~ , Elision~opt~
BindingRestElement~[?Yield,\ ?GeneratorParameter]opt~ ]

BindingPropertyList~[Yield,GeneratorParameter]~ :

BindingProperty~[?Yield,\ ?GeneratorParameter]~
BindingPropertyList~[?Yield,\ ?GeneratorParameter]~ ,
BindingProperty~[?Yield,\ ?GeneratorParameter]~

BindingElementList~[Yield,GeneratorParameter]~ :

BindingElisionElement~[?Yield,\ ?GeneratorParameter]~
BindingElementList~[?Yield,\ ?GeneratorParameter]~ ,
BindingElisionElement~[?Yield,\ ?GeneratorParameter]~

BindingElisionElement~[Yield,GeneratorParameter]~ :

Elision~opt~ BindingElement~[?Yield,\ ?GeneratorParameter]~

BindingProperty~[Yield,GeneratorParameter]~ :

SingleNameBinding~[?Yield,\ ?GeneratorParameter]
~ PropertyName~[?Yield,\ ?GeneratorParameter]~ :
BindingElement~[?Yield,\ ?GeneratorParameter]~

BindingElement~[Yield,~ ~GeneratorParameter\ ]~ :

SingleNameBinding~[?Yield,\ ?GeneratorParameter]
~[+GeneratorParameter] BindingPattern~[?Yield,GeneratorParameter]~
Initializer~[In]opt~
[~GeneratorParameter] BindingPattern~[?Yield]~
Initializer~[In,\ ?Yield]opt~

SingleNameBinding~[Yield,~ ~GeneratorParameter]~ :

[+GeneratorParameter] BindingIdentifier~[Yield]~ Initializer~[In]opt~
[~GeneratorParameter] BindingIdentifier~[?Yield]~
Initializer~[In,\ ?Yield]opt~

BindingRestElement~[Yield,\ GeneratorParameter]~ :

[+GeneratorParameter]... BindingIdentifier~[Yield]~
[~GeneratorParameter] ... BindingIdentifier~[?Yield]~

Static Semantics: BoundNames

See also: 13.2.1.2, 13.2.2.1, 13.6.4.2, 14.1.3, 14.2.2, 14.4.2, 14.5.2,
15.2.2.2, 15.2.3.1.

ObjectBindingPattern : { }

1.  Return an empty List.

ArrayBindingPattern : [ Elision~opt~ ]

1.  Return an empty List.

ArrayBindingPattern : [ Elision~opt~ BindingRestElement ]

1.  Return the BoundNames of BindingRestElement.

ArrayBindingPattern : [ BindingElementList , Elision~opt~ ]

1.  Return the BoundNames of BindingElementList.

ArrayBindingPattern : [ BindingElementList , Elision~opt~
BindingRestElement ]

1.  Let names be BoundNames of BindingElementList.

2.  Append to names the elements of BoundNames of
    BindingRestElement.

3.  Return names.

BindingPropertyList : BindingPropertyList , BindingProperty

1.  Let names be BoundNames of BindingPropertyList.

2.  Append to names the elements of BoundNames of BindingProperty.

3.  Return names.

BindingElementList : BindingElementList , BindingElisionElement

1.  Let names be BoundNames of BindingElementList.

2.  Append to names the elements of BoundNames of
    BindingElisionElement.

3.  Return names.

BindingElisionElement : Elision~opt~ BindingElement

1.  Return BoundNames of BindingElement.

BindingProperty : PropertyName : BindingElement

1.  Return the BoundNames of BindingElement.

SingleNameBinding : _BindingIdentifier Initializer_~opt~

1.  Return the BoundNames of BindingIdentifier.

BindingElement : _BindingPattern Initializer_~opt~

1.  Return the BoundNames of BindingPattern.

Static Semantics: ContainsExpression

See also: 14.1.5, 14.2.4.

ObjectBindingPattern : { }

1.  Return FALSE.

ArrayBindingPattern : [ Elision~opt~ ]

1.  Return FALSE.

ArrayBindingPattern : [ Elision~opt~ BindingRestElement ]

1.  Return FALSE.

ArrayBindingPattern : [ BindingElementList , Elision~opt~ ]

1.  Return ContainsExpression of BindingElementList.

ArrayBindingPattern : [ BindingElementList , Elision~opt~
BindingRestElement ]

1.  Return ContainsExpression of BindingElementList.

BindingPropertyList : BindingPropertyList , BindingProperty

1.  Let has be ContainsExpression of BindingPropertyList.

2.  If has is TRUE, return TRUE.

3.  Return ContainsExpression of BindingProperty.

BindingElementList : BindingElementList , BindingElisionElement

1.  Let has be ContainsExpression of BindingElementList.

2.  If has is TRUE, return TRUE.

3.  Return ContainsExpression of BindingElisionElement.

BindingElisionElement : Elision~opt~ BindingElement

1.  Return ContainsExpression of BindingElement.

BindingProperty : PropertyName : BindingElement

1.  Let has be IsComputedPropertyKey of PropertyName.

2.  If has is TRUE, return TRUE.

3.  Return the ContainsExpression of BindingElement.

BindingElement : _BindingPattern Initializer_

1.  Return TRUE.

SingleNameBinding : BindingIdentifier

1.  Return FALSE.

SingleNameBinding : _BindingIdentifier Initializer_

1.  Return TRUE.

Static Semantics: HasInitializer

See also: 13.2.3.3, 14.1.7, 14.2.7.

BindingElement : BindingPattern

1.  Return FALSE.

BindingElement : _BindingPattern Initializer_

1.  Return TRUE.

SingleNameBinding : BindingIdentifier

1.  Return FALSE.

SingleNameBinding : _BindingIdentifier Initializer_

1.  Return TRUE.

Static Semantics: IsSimpleParameterList

See also: 14.1.12, 14.2.8.

BindingElement : BindingPattern

1.  Return FALSE.

BindingElement : _BindingPattern Initializer_

1.  Return FALSE.

SingleNameBinding : BindingIdentifier

1.  Return TRUE.

SingleNameBinding : _BindingIdentifier Initializer_

1.  Return FALSE.

Runtime Semantics: BindingInitialization

  With parameters value and environment.

See also: 12.1.5, 13.6.4.8.

NOTE When UNDEFINED is passed for environment it indicates that a
PutValue operation should be used to assign the initialization value.
This is the case for formal parameter lists of non-strict functions. In
that case the formal parameter bindings are preinitialized in order to
deal with the possibility of multiple parameters with the same name.

BindingPattern : ObjectBindingPattern

1.  Let valid be RequireObjectCoercible(value).

2.  ReturnIfAbrupt(valid).

3.  4.  Return the result of performing BindingInitialization for
    ObjectBindingPattern using value and environment as arguments.

BindingPattern : ArrayBindingPattern

1.  2.  Let iterator be GetIterator(value).

3.  ReturnIfAbrupt(iterator).

4.  Let result be the result of performing
    IteratorBindingInitialization for ArrayBindingPattern using
    iterator, and environment as arguments.

5.  Return IteratorClose(iterator, result).

ObjectBindingPattern : { }

1.  Return NormalCompletion(empty).

2.  

BindingPropertyList : BindingPropertyList , BindingProperty

1.  Let status be the result of performing BindingInitialization for
    BindingPropertyList using value and environment as arguments.

2.  ReturnIfAbrupt(status).

3.  Return the result of performing BindingInitialization for
    BindingProperty using value and environment as arguments.

BindingProperty : SingleNameBinding

1.  Let name be the string that is the only element of BoundNames of
    SingleNameBinding.

2.  Return the result of performing KeyedBindingInitialization for
    SingleNameBinding using value, environment, and name as the
    arguments.

BindingProperty : PropertyName : BindingElement

1.  Let P be the result of evaluating PropertyName

2.  ReturnIfAbrupt(P).

3.  Return the result of performing KeyedBindingInitialization for
    BindingElement using value, environment, and P as arguments.

Runtime Semantics: IteratorBindingInitialization

  With parameters iterator, and environment.

See also: 14.1.21, 14.2.15.

NOTE When UNDEFINED is passed for environment it indicates that a
PutValue operation should be used to assign the initialization value.
This is the case for formal parameter lists of non-strict functions. In
that case the formal parameter bindings are preinitialized in order to
deal with the possibility of multiple parameters with the same name.

ArrayBindingPattern : [ ]

1.  Return NormalCompletion(empty).

2.  

ArrayBindingPattern : [ Elision ]

1.  Return the result of performing
    IteratorDestructuringAssignmentEvaluation of Elision with
    iterator as the argument.

ArrayBindingPattern : [ Elision~opt~ BindingRestElement ]

1.  If Elision is present, then

    a.  Let status be the result of performing
        IteratorDestructuringAssignmentEvaluation of Elision with
        iterator as the argument.

    b.  ReturnIfAbrupt(status).

2.  Return the result of performing IteratorBindingInitialization for
    BindingRestElement using iterator and environment as
    arguments.

ArrayBindingPattern : [ BindingElementList ]

1.  Return the result of performing IteratorBindingInitialization for
    BindingElementList using iterator and environment as
    arguments.

ArrayBindingPattern : [ BindingElementList , ]

1.  Return the result of performing IteratorBindingInitialization for
    BindingElementList using iterator and environment as
    arguments.

ArrayBindingPattern : [ BindingElementList , Elision ]

1.  Let status be the result of performing
    IteratorBindingInitialization for BindingElementList using
    iterator and environment as arguments.

2.  ReturnIfAbrupt(status).

3.  Return the result of performing
    IteratorDestructuringAssignmentEvaluation of Elision with
    iterator as the argument.

ArrayBindingPattern : [ BindingElementList , Elision~opt~
BindingRestElement ]

1.  Let status be the result of performing
    IteratorBindingInitialization for BindingElementList using
    iterator and environment as arguments.

2.  ReturnIfAbrupt(status).

3.  If Elision is present, then

    a.  Let status be the result of performing
        IteratorDestructuringAssignmentEvaluation of Elision with
        iterator as the argument.

    b.  ReturnIfAbrupt(status).

4.  Return the result of performing IteratorBindingInitialization for
    BindingRestElement using iterator and environment as
    arguments.

BindingElementList : BindingElisionElement

1.  Return the result of performing IteratorBindingInitialization for
    BindingElisionElement using iterator and environment as
    arguments.

BindingElementList : BindingElementList , BindingElisionElement

1.  Let status be the result of performing
    IteratorBindingInitialization for BindingElementList using
    iterator and environment as arguments.

2.  ReturnIfAbrupt(status).

3.  Return the result of performing IteratorBindingInitialization for
    BindingElisionElement using iterator and environment as
    arguments.

BindingElisionElement : BindingElement

1.  Return the result of performing IteratorBindingInitialization of
    BindingElement with iterator and environment as the arguments.

BindingElisionElement : Elision BindingElement

1.  Let status be the result of performing
    IteratorDestructuringAssignmentEvaluation of Elision with
    iterator as the argument.

2.  ReturnIfAbrupt(status).

3.  Return the result of performing IteratorBindingInitialization of
    BindingElement with iterator and environment as the arguments.

BindingElement : SingleNameBinding

1.  Return the result of performing IteratorBindingInitialization for
    SingleNameBinding using iterator and environment as the
    arguments.

SingleNameBinding : _BindingIdentifier Initializer_~opt~

1.  Let bindingId be StringValue of BindingIdentifier.

2.  Let lhs be ResolveBinding(bindingId).

3.  ReturnIfAbrupt(lhs).

4.  Let next be IteratorStep(iterator).

5.  ReturnIfAbrupt(next).

6.  If next is FALSE, let v be UNDEFINED

7.  8.  Else

    a.  Let v be IteratorValue(next).

    b.  ReturnIfAbrupt(v).

9.  If Initializer is present and v is UNDEFINED, then

    a.  Let defaultValue be the result of evaluating Initializer.

    b.  Let v be GetValue(defaultValue).

    c.  ReturnIfAbrupt(v).

    d.  If IsAnonymousFunctionDefinition(Initializer) is TRUE, then

        i.  Let hasNameProperty be HasOwnProperty(v, "NAME").

        ii. ReturnIfAbrupt(hasNameProperty).

        iii. If hasNameProperty is FALSE, perform

        iv. SetFunctionName(v, bindingId).

            1.  

10. If environment is UNDEFINED, return PutValue(lhs, v).

11. Return InitializeReferencedBinding(lhs, v).

BindingElement : _BindingPattern Initializer_~opt~

1.  Let next be IteratorStep(iterator).

2.  ReturnIfAbrupt(next).

3.  If next is FALSE, let v be UNDEFINED

4.  5.  Else

    a.  Let v be IteratorValue(next).

    b.  ReturnIfAbrupt(v).

6.  If Initializer is present and v is UNDEFINED, then

    a.  Let defaultValue be the result of evaluating Initializer.

    b.  Let v be GetValue(defaultValue).

    c.  ReturnIfAbrupt(v).

7.  8.  9.  10. Return the result of performing BindingInitialization of
    BindingPattern with v and environment as the arguments.

BindingRestElement : ... BindingIdentifier

1.  Let lhs be ResolveBinding(StringValue of BindingIdentifier).

2.  ReturnIfAbrupt(lhs).

3.  Let A be ArrayCreate(0).

4.  Let n=0.

5.  Repeat,

6.  a.  Let next be IteratorStep(iterator).

    b.  ReturnIfAbrupt(next).

    c.  If next is FALSE, then

        i.  If environment is UNDEFINED, then PutValue(lhs, A).

        ii. Return InitializeReferencedBinding(lhs, A).

    d.  Let nextValue be IteratorValue(next).

    e.  ReturnIfAbrupt(nextValue).

    f.  Let status be CreateDataProperty(A, ToString(ToUint32(n)),
        nextValue).

    g.  Assert: status is TRUE.

    h.  Increment n by 1.

Runtime Semantics: KeyedBindingInitialization

  With parameters value, environment, and propertyName.

NOTE When UNDEFINED is passed for environment it indicates that a
PutValue operation should be used to assign the initialization value.
This is the case for formal parameter lists of non-strict functions. In
that case the formal parameter bindings are preinitialized in order to
deal with the possibility of multiple parameters with the same name.

BindingElement : _BindingPattern Initializer_~opt~

1.  Let v be GetV(value, propertyName).

2.  ReturnIfAbrupt(v).

3.  If Initializer is present and v is UNDEFINED, then

    a.  Let defaultValue be the result of evaluating Initializer.

    b.  Let v be GetValue(defaultValue).

    c.  ReturnIfAbrupt(v).

4.  5.  6.  7.  Return the result of performing BindingInitialization
    for BindingPattern passing v and environment as arguments.

SingleNameBinding : _BindingIdentifier Initializer_~opt~

1.  Let bindingId be StringValue of BindingIdentifier.

2.  Let lhs be ResolveBinding(bindingId).

3.  ReturnIfAbrupt(lhs).

4.  Let v be GetV(value, propertyName).

5.  ReturnIfAbrupt(v).

6.  If Initializer is present and v is UNDEFINED, then

    a.  Let defaultValue be the result of evaluating Initializer.

    b.  Let v be GetValue(defaultValue).

    c.  ReturnIfAbrupt(v).

    d.  If IsAnonymousFunctionDefinition(Initializer) is TRUE, then

        i.  Let hasNameProperty be HasOwnProperty(v, "NAME").

        ii. ReturnIfAbrupt(hasNameProperty).

        iii. If hasNameProperty is FALSE, perform

        iv. SetFunctionName(v, bindingId).

            1.  

7.  If environment is UNDEFINED, return PutValue(lhs, v).

8.  Return InitializeReferencedBinding(lhs, v).


Empty Statement

Syntax

EmptyStatement :

;

Runtime Semantics: Evaluation

EmptyStatement : ;

1.  Return NormalCompletion(empty).


Expression Statement

Syntax

ExpressionStatement~[Yield]~ :

[lookahead ∉ {{, FUNCTION, CLASS, LET [ }] Expression~[In,\ ?Yield]~ ;

NOTE An ExpressionStatement cannot start with a left curly bracket
because that might make it ambiguous with a Block. Also, an
ExpressionStatement cannot start with the FUNCTION or CLASS keywords
because that would make it ambiguous with a FunctionDeclaration, a
GeneratorDeclaration, or a ClassDeclaration. An
ExpressionStatement cannot start with the two token sequence LET [
because that would make it ambiguous with a LET LexicalDeclaration
whose first LexicalBinding was an ArrayBindingPattern.

Runtime Semantics: Evaluation

ExpressionStatement : Expression ;

1.  Let exprRef be the result of evaluating Expression.

2.  Return GetValue(exprRef).

3.  4.  


The if Statement

Syntax

IfStatement~[Yield,\ Return]~ :

IF ( Expression~[In,\ ?Yield]~ ) Statement~[?Yield,\ ?Return]~ ELSE
Statement~[?Yield,\ ?Return]~
IF ( Expression~[In,\ ?Yield]~ ) Statement~[?Yield,\ ?Return]~

Each ELSE for which the choice of associated IF is ambiguous shall be
associated with the nearest possible IF that would otherwise have no
corresponding ELSE.

Static Semantics: Early Errors

IfStatement :

IF ( Expression) Statement ELSE Statement
IF ( Expression ) Statement

-   It is a Syntax Error if IsLabelledFunction(Statement) is TRUE for
    any occurrence of Statement in these rules.

NOTE It is only necessary to apply this rule if the extension specified
in B.3.2 is implemented.

Static Semantics: ContainsDuplicateLabels

  With argument labelSet.

See also: 13.0.1, 13.1.2, 13.6.1.1, 13.6.2.1, 13.6.3.2, 13.6.4.3,
13.10.2, 13.11.2, 13.12.2, 13.14.2, 15.2.1.2.

IfStatement : IF ( Expression ) Statement ELSE Statement

1.  Let hasUndefinedLabels be ContainsDuplicateLabels of the first
    statement with argument labelSet.

2.  If hasUndefinedLabels is TRUE, return TRUE.

3.  Return ContainsDuplicateLabels of the second statement with
    argument labelSet.

IfStatement : IF ( Expression ) Statement

1.  Return ContainsDuplicateLabels of statement with argument
    labelSet.

Static Semantics: ContainsUndefinedBreakTarget

  With argument labelSet.

See also: 13.0.2, 13.1.3, 13.6.1.2, 13.6.2.2, 13.6.3.3, 13.6.4.4,
13.8.2, 13.10.3, 13.11.3, 13.12.3, 13.14.3, 15.2.1.3.

IfStatement : IF ( Expression ) Statement ELSE Statement

1.  Let hasUndefinedLabels be ContainsUndefinedBreakTarget of the
    first Statement with argument labelSet.

2.  If hasUndefinedLabels is TRUE, return TRUE.

3.  Return ContainsUndefinedBreakTarget of the second Statement with
    argument labelSet.

IfStatement : IF ( Expression ) Statement

1.  Return ContainsUndefinedBreakTarget of Statement with argument
    labelSet.

Static Semantics: ContainsUndefinedContinueTarget

  With arguments iterationSet and labelSet.

See also: 13.0.3, 13.1.4, 13.6.1.3, 13.6.2.3, 13.6.3.4, 13.6.4.5,
13.7.2, 13.10.4, 13.11.4, 13.12.4,13.14.4, 15.2.1.4.

IfStatement : IF ( Expression ) Statement ELSE Statement

1.  Let hasUndefinedLabels be ContainsUndefinedContinueTarget of the
    first Statement with arguments iterationSet and « ».

2.  If hasUndefinedLabels is TRUE, return TRUE.

3.  Return ContainsUndefinedContinueTarget of the second Statement
    with arguments iterationSet and « ».

IfStatement : IF ( Expression ) Statement

1.  Return ContainsUndefinedContinueTarget of Statement with arguments
    iterationSet and « ».

Static Semantics: VarDeclaredNames

See also: 13.0.5, 13.1.11, 13.2.2.2, 13.6.1.4, 13.6.2.4, 13.6.3.5,
13.6.4.7, 13.10.5, 13.11.7, 13.12.12, 13.14.5, 14.1.18, 14.2.13, 15.1.5,
15.2.1.13.

IfStatement : IF ( Expression ) Statement ELSE Statement

1.  Let names be VarDeclaredNames of the first Statement.

2.  Append to names the elements of the VarDeclaredNames of the second
    Statement.

3.  Return names.

IfStatement : IF ( Expression ) Statement

1.  Return the VarDeclaredNames of Statement.

Static Semantics: VarScopedDeclarations

See also: 13.0.6, 13.1.12, 13.2.2.3, 13.6.1.5, 13.6.2.5, 13.6.3.6,
13.6.4.8, 13.10.6, 13.11.8, 13.12.13, 13.14.6, 14.1.19, 14.2.14, 15.1.6,
15.2.1.14.

IfStatement : IF ( Expression ) Statement ELSE Statement

1.  Let declarations be VarScopedDeclarations of the first
    Statement.

2.  Append to declarations the elements of the VarScopedDeclarations
    of the second Statement.

3.  Return declarations.

IfStatement : IF ( Expression ) Statement

1.  Return the VarDeclaredNames of Statement.

Runtime Semantics: Evaluation

IfStatement : IF ( Expression ) Statement ELSE Statement

1.  Let exprRef be the result of evaluating Expression.

2.  Let exprValue be ToBoolean(GetValue(exprRef)).

3.  ReturnIfAbrupt(exprValue).

4.  If exprValue is TRUE, then

    a.  Let stmtValue be the result of evaluating the first
        Statement.

5.  Else,

    a.  Let stmtValue be the result of evaluating the second
        Statement.

6.  If stmtValue.[[type]] is normal and stmtValue.[[value]] is
    empty, then

    a.  Return NormalCompletion(UNDEFINED).

7.  Return stmtValue.

IfStatement : IF ( Expression ) Statement

1.  Let exprRef be the result of evaluating Expression.

2.  Let exprValue be ToBoolean(GetValue(exprRef)).

3.  ReturnIfAbrupt(exprValue).

4.  If exprValue is FALSE, then

    a.  Return NormalCompletion(UNDEFINED).

5.  Else,

6.  a.  Let stmtValue be the result of evaluating Statement.

7.  If stmtValue.[[type]] is normal and stmtValue.[[value]] is
    empty, then

    a.  Return NormalCompletion(UNDEFINED).

8.  Return stmtValue.


Iteration Statements

Syntax

IterationStatement~[Yield,\ Return]~ :

  DO Statement~[?Yield,\ ?Return]~ WHILE ( Expression~[In,\ ?Yield]~ )
  ;~opt~

  WHILE ( Expression~[In,\ ?Yield]~ ) Statement~[?Yield,\ ?Return]~

  FOR ( [lookahead ∉ {LET [ }] Expression~[?Yield]opt~ ;
  Expression~[In,\ ?Yield]opt~ ; Expression~[In,\ ?Yield]opt~ )
  Statement~[?Yield,\ ?Return]~

  FOR ( VAR VariableDeclarationList~[?Yield]~;
  Expression~[In,\ ?Yield]opt~ ; Expression~[In,\ ?Yield]opt~ )
  Statement~[?Yield,\ ?Return]~

  FOR ( LexicalDeclaration~[?Yield]~ Expression~[In,\ ?Yield]opt~ ;
  Expression~[In,\ ?Yield]opt~ ) Statement~[?Yield,\ ?Return]~

  FOR ([lookahead ∉ {LET [ }] LeftHandSideExpression~[?Yield]~ IN
  Expression~[In,\ ?Yield]~ ) Statement~[?Yield,\ ?Return]~

  FOR ( VAR ForBinding~[?Yield]~ IN Expression~[In,\ ?Yield]~ )
  Statement~[?Yield,\ ?Return]~

  FOR ( ForDeclaration~[?Yield]~ IN Expression~[In,\ ?Yield]~ )
  Statement~[?Yield,\ ?Return]~

  FOR ([lookahead ≠ LET] LeftHandSideExpression~[?Yield]~ OF
  AssignmentExpression~[In,\ ?Yield]~ ) Statement~[?Yield, ?Return]~

  FOR ( VAR ForBinding~[?Yield]~ OF AssignmentExpression~[In,\ ?Yield]~
  ) Statement~[?Yield,\ ?Return]~

  FOR ( ForDeclaration~[?Yield]~ OF AssignmentExpression~[In,\ ?Yield]~
  ) Statement~[?Yield,\ ?Return]~

ForDeclaration~[Yield]~ :

LetOrConst ForBinding~[?Yield]~

ForBinding~[Yield]~ :

BindingIdentifier~[?Yield]~
BindingPattern~[?Yield]~

NOTE 1 A semicolon is not required after a DO-WHILE statement.

Semantics

Static Semantics: Early Errors

IterationStatement :

  DO Statement WHILE ( Expression ) ;~opt~

  WHILE ( Expression ) Statement

  FOR ( [lookahead ∉ {LET [ }] Expression~opt~ ; Expression~opt~ ;
  Expression~opt~ ) Statement

  FOR ( VAR VariableDeclarationList; Expression~opt~ ; Expression~opt~ )
  Statement

  FOR ( LexicalDeclaration Expression~opt~ ; Expression~opt~ ) Statement

  FOR ([lookahead ∉ {LET [ }] LeftHandSideExpression IN Expression)
  Statement

  FOR ( VAR ForBinding IN Expression ) Statement

  FOR ( ForDeclaration IN Expression) Statement

  FOR ([lookahead ≠ LET] LeftHandSideExpression OF AssignmentExpression
  ) Statement

  FOR ( VAR ForBinding OF AssignmentExpression ) Statement

  FOR ( ForDeclaration OF AssignmentExpression~[In,\ ?Yield]~ )
  Statement

-   It is a Syntax Error if IsLabelledFunction(Statement) is TRUE for
    any occurrence of Statement in these rules.

NOTE It is only necessary to apply this rule if the extension specified
in B.3.2 is implemented.

Runtime Semantics: LoopContinues(completion, labelSet) 

The abstract operation LoopContinues with arguments completion and
labelSet is defined by the following step:

1.  If completion.[[type]] is normal, return TRUE.

2.  If completion.[[type]] is not continue, return FALSE.

3.  If completion.[[target]] is empty, return TRUE.

4.  If completion.[[target]] is an element of labelSet, return TRUE.

5.  Return FALSE.

NOTE Within the Statement part of an IterationStatement a
ContinueStatement may be used to begin a new iteration.

The do-while Statement

Static Semantics: ContainsDuplicateLabels

  With argument labelSet.

See also: 13.0.1, 13.1.2, 13.5.2, 13.6.2.1, 13.6.3.2, 13.6.4.3, 13.10.2,
13.11.2, 13.12.2, 13.14.2, 15.2.1.2.

IterationStatement : DO Statement WHILE ( Expression );~opt~

1.  Return ContainsDuplicateLabels of Statement with argument
    labelSet.

Static Semantics: ContainsUndefinedBreakTarget

  With argument labelSet.

See also: 13.0.2, 13.1.3, 13.5.3, 13.6.2.2, 13.6.3.3, 13.6.4.4, 13.8.2,
13.10.3, 13.11.3, 13.12.3, 13.14.3, 15.2.1.3.

IterationStatement : DO Statement WHILE ( Expression );~opt~

1.  Return ContainsUndefinedBreakTarget of Statement with argument
    labelSet.

Static Semantics: ContainsUndefinedContinueTarget

  With arguments iterationSet and labelSet.

See also: 13.0.3, 13.1.4, 13.5.4, 13.6.2.3, 13.6.3.4, 13.6.4.5, 13.7.2,
13.10.4, 13.11.4, 13.12.4,13.14.4, 15.2.1.4.

IterationStatement : DO Statement WHILE ( Expression );~opt~

1.  Return ContainsUndefinedContinueTarget of Statement with arguments
    iterationSet and « ».

Static Semantics: VarDeclaredNames

See also: 13.0.5, 13.1.11, 13.2.2.2, 13.5.5, 13.6.2.4, 13.6.3.5,
13.6.4.7, 13.10.5, 13.11.7, 13.12.12, 13.14.5, 14.1.18, 14.2.13, 15.1.5,
15.2.1.13.

IterationStatement : DO Statement WHILE ( Expression );~opt~

1.  Return the VarDeclaredNames of Statement.

Static Semantics: VarScopedDeclarations

See also: 13.0.6, 13.1.12, 13.2.2.3, 13.5.6, 13.6.2.5, 13.6.3.6,
13.6.4.8, 13.10.6, 13.11.8, 13.12.13, 13.14.6, 14.1.19, 14.2.14, 15.1.6,
15.2.1.14.

IterationStatement : DO Statement WHILE ( Expression );~opt~

1.  Return the VarScopedDeclarations of Statement.

Runtime Semantics: LabelledEvaluation

  With argument labelSet.

See also: 13.0.6, 13.6.2.5, 13.6.3.6, 13.6.4.1113.6.4.11, 13.12.12.

IterationStatement : DO Statement WHILE ( Expression );~opt~

1.  Let V = UNDEFINED.

2.  Repeat

3.  a.  Let stmt be the result of evaluating Statement.

    b.  If LoopContinues (stmt_,_labelSet) is FALSE, return stmt.

    c.  If stmt.[[value]] is not empty, let V = stmt_.[[value]]_.

    d.  e.  Let exprRef be the result of evaluating Expression.

    f.  Let exprValue be GetValue(exprRef).

    g.  If exprValue.[[type]] is normal, then

    h.  i.  If ToBoolean(exprValue) is FALSE, return
            NormalCompletion(V).

    i.  Else

        i.  Assert: exprValue is an abrupt completion.

        ii. If LoopContinues (exprValue_,_labelSet) is FALSE, return
            exprValue.

The while Statement

Static Semantics: ContainsDuplicateLabels

  With argument labelSet.

See also: 13.0.1, 13.1.2, 13.5.2, 13.6.1.1, 13.6.3.2, 13.6.4.3, 13.10.2,
13.11.2, 13.12.2, 13.14.2, 15.2.1.2.

IterationStatement : WHILE ( Expression ) Statement

1.  Return ContainsDuplicateLabels of Statement with argument
    labelSet.

Static Semantics: ContainsUndefinedBreakTarget

  With argument labelSet.

See also: 13.0.2, 13.1.3, 13.5.3, 13.6.1.2, 13.6.3.3, 13.6.4.4, 13.8.2,
13.10.3, 13.11.3, 13.12.3, 13.14.3, 15.2.1.3.

IterationStatement : WHILE ( Expression ) Statement

1.  Return ContainsUndefinedBreakTarget of Statement with argument
    labelSet.

Static Semantics: ContainsUndefinedContinueTarget

  With arguments iterationSet and labelSet.

See also: 13.0.3, 13.1.4, 13.5.4, 13.6.1.3, 13.6.3.4, 13.6.4.5, 13.7.2,
13.10.4, 13.11.4, 13.12.4,13.14.4, 15.2.1.4.

IterationStatement : WHILE ( Expression ) Statement

1.  Return ContainsUndefinedContinueTarget of Statement with arguments
    iterationSet and « ».

Static Semantics: VarDeclaredNames

See also: 13.0.5, 13.1.11, 13.2.2.2, 13.5.5, 13.6.1.4, 13.6.3.5,
13.6.4.7, 13.10.5, 13.11.7, 13.12.12, 13.14.5, 14.1.18, 14.2.13, 15.1.5,
15.2.1.13.

IterationStatement : WHILE ( Expression ) Statement

1.  Return the VarDeclaredNames of Statement.

Static Semantics: VarScopedDeclarations

See also: 13.0.6, 13.1.12, 13.2.2.3, 13.5.6, 13.6.1.5, 13.6.3.6,
13.6.4.8, 13.10.6, 13.11.8, 13.12.13, 13.14.6, 14.1.19, 14.2.14, 15.1.6,
15.2.1.14.

IterationStatement : WHILE ( Expression ) Statement

1.  Return the VarScopedDeclarations of Statement.

Runtime Semantics: LabelledEvaluation

  With argument labelSet.

See also: 13.0.6, 13.6.1.5, 13.6.3.6, 13.6.4.1113.6.4.11, 13.12.12.

IterationStatement : WHILE ( Expression ) Statement

1.  Let V = UNDEFINED.

2.  Repeat

    a.  Let exprRef be the result of evaluating Expression.

    b.  Let exprValue be GetValue(exprRef).

    c.  If exprValue.[[type]] is normal, then

        i.  If ToBoolean(exprValue) is FALSE, return
            NormalCompletion(V).

    d.  Else,

        i.  Assert: exprValue is an abrupt completion.

        ii. If LoopContinues (exprValue_,_labelSet) is FALSE, return
            exprValue.

    e.  Let stmt be the result of evaluating Statement.

    f.  If LoopContinues (stmt_,_labelSet) is FALSE, return stmt.

    g.  If stmt.[[value]] is not empty, let V = stmt.[[value]].

    h.  

The for Statement

Static Semantics: Early Errors

IterationStatement : FOR ( LexicalDeclaration Expression~opt~ ;
Expression~opt~ ) Statement

-   It is a Syntax Error if any element of the BoundNames of
    LexicalDeclaration also occurs in the VarDeclaredNames of
    Statement.

Static Semantics: ContainsDuplicateLabels

  With argument labelSet.

See also: 13.0.1, 13.1.2, 13.5.2, 13.6.1.1, 13.6.2.1, 13.6.4.3, 13.10.2,
13.11.2, 13.14.2, 15.2.1.2.

IterationStatement :

  FOR ( [lookahead ∉ {LET [ }] Expression~opt~ ; Expression~opt~ ;
  Expression~opt~ ) Statement

  FOR ( VAR VariableDeclarationList; Expression~opt~ ; Expression~opt~ )
  Statement

  FOR ( LexicalDeclaration Expression~opt~ ; Expression~opt~ ) Statement

1.  Return ContainsDuplicateLabels of Statement with argument
    labelSet.

Static Semantics: ContainsUndefinedBreakTarget

  With argument labelSet.

See also: 13.0.2, 13.1.3, 13.5.3, 13.6.1.2, 13.6.2.2, 13.6.4.4, 13.8.2,
13.10.3, 13.11.3, 13.12.3, 13.14.3, 15.2.1.3.

IterationStatement :

  FOR ( [lookahead ∉ {LET [ }] Expression~opt~ ; Expression~opt~ ;
  Expression~opt~ ) Statement

  FOR ( VAR VariableDeclarationList; Expression~opt~ ; Expression~opt~ )
  Statement

  FOR ( LexicalDeclaration Expression~opt~ ; Expression~opt~ ) Statement

1.  Return ContainsUndefinedBreakTarget of Statement with argument
    labelSet.

Static Semantics: ContainsUndefinedContinueTarget

  With arguments iterationSet and labelSet.

See also: 13.0.3, 13.1.4, 13.5.4, 13.6.1.3, 13.6.2.3, 13.6.4.5, 13.7.2,
13.10.4, 13.11.4, 13.12.4,13.14.4, 15.2.1.4.

IterationStatement :

  FOR ( [lookahead ∉ {LET [ }] Expression~opt~ ; Expression~opt~ ;
  Expression~opt~ ) Statement

  FOR ( VAR VariableDeclarationList; Expression~opt~ ; Expression~opt~ )
  Statement

  FOR ( LexicalDeclaration Expression~opt~ ; Expression~opt~ ) Statement

1.  Return ContainsUndefinedContinueTarget of Statement with arguments
    iterationSet and « ».

Static Semantics: VarDeclaredNames

See also: 13.0.5, 13.1.11, 13.2.2.2, 13.5.5, 13.6.1.4, 13.6.2.4,
13.6.4.7, 13.10.5, 13.11.7, 13.12.12, 13.14.5, 14.1.18, 14.2.13, 15.1.5,
15.2.1.13.

IterationStatement : FOR ( Expression~opt~ ; Expression~opt~ ;
Expression~opt~ ) Statement

1.  Return the VarDeclaredNames of Statement.

IterationStatement : FOR ( VAR VariableDeclarationList ;
Expression~opt~ ; Expression~opt~ ) Statement

1.  Let names be BoundNames of VariableDeclarationList.

2.  Append to names the elements of the VarDeclaredNames of
    Statement.

3.  Return names.

IterationStatement : FOR ( LexicalDeclaration Expression~opt~ ;
Expression~opt~ ) Statement

1.  Return the VarDeclaredNames of Statement.

Static Semantics: VarScopedDeclarations

See also: 13.0.6, 13.1.12, 13.2.2.3, 13.5.6, 13.6.1.5, 13.6.2.5,
13.6.4.8, 13.10.6, 13.11.8, 13.12.13, 13.14.6, 14.1.19, 14.2.14, 15.1.6,
15.2.1.14.

IterationStatement : FOR ( Expression~opt~ ; Expression~opt~ ;
Expression~opt~ ) Statement

1.  Return the VarScopedDeclarations of Statement.

IterationStatement : FOR ( VAR VariableDeclarationList ;
Expression~opt~ ; Expression~opt~ ) Statement

1.  Let declarations be VarScopedDeclarations of
    VariableDeclarationList.

2.  Append to declarations the elements of the VarScopedDeclarations
    of Statement.

3.  Return declarations.

IterationStatement : FOR ( LexicalDeclaration Expression~opt~ ;
Expression~opt~ ) Statement

1.  Return the VarScopedDeclarations of Statement.

Runtime Semantics: LabelledEvaluation

  With argument labelSet.

See also: 13.0.6, 13.6.1.5, 13.6.2.5, 13.6.4.1113.6.4.11, 13.12.12.

IterationStatement : FOR ( Expression~opt~ ; Expression~opt~ ;
Expression~opt~ ) Statement

1.  If the first Expression is present, then

    a.  Let exprRef be the result of evaluating the first
        Expression.

    b.  Let exprValue be GetValue(exprRef).

    c.  d.  If LoopContinues(exprValue_,_labelSet) is FALSE, return
        exprValue.

2.  Return the result of performing ForBodyEvaluation with the second
    Expression as the testExpr argument, the third Expression as
    the incrementExpr argument, Statement as the stmt argument, «
    » as the perIterationBindings, and with labelSet.

3.  

IterationStatement : FOR ( VAR VariableDeclarationList ;
Expression~opt~ ; Expression~opt~ ) Statement

1.  Let varDcl be the result of evaluating VariableDeclarationList.

2.  If LoopContinues(varDcl_,_labelSet) is FALSE, return varDcl.

3.  Return the result of performing ForBodyEvaluation with the first
    Expression as the testExpr argument, the second Expression as
    the incrementExpr argument, Statement as the stmt argument,
    « » as the perIterationBindings, and with labelSet.

4.  

IterationStatement : FOR ( LexicalDeclaration Expression~opt~ ;
Expression~opt~ ) Statement

1.  Let oldEnv be the running execution context’s LexicalEnvironment.

2.  Let loopEnv be NewDeclarativeEnvironment(oldEnv).

3.  Let isConst be the result of performing IsConstantDeclaration of
    LexicalDeclaration.

4.  Let boundNames be the BoundNames of LexicalDeclaration.

5.  For each element dn of boundNames do

    a.  If isConst is TRUE, then

        i.  Call loopEnv’s CreateImmutableBinding concrete method
            passing dn and TRUE as the arguments.

    b.  Else,

        i.  Call loopEnv’s CreateMutableBinding concrete method
            passing dn and FALSE as the arguments.

        ii. Assert: The above call to CreateMutableBinding will never
            return an abrupt completion.

6.  Set the running execution context’s LexicalEnvironment to loopEnv.

7.  Let forDcl be the result of evaluating LexicalDeclaration.

8.  If LoopContinues(forDcl_,_labelSet) is FALSE, then

    a.  Set the running execution context’s LexicalEnvironment to
        oldEnv.

    b.  Return forDcl.

9.  If isConst is FALSE, let perIterationLets be boundNames
    otherwise let perIterationLets be « ».

10. Let bodyResult be the result of performing ForBodyEvaluation with
    the first Expression as the testExpr argument, the second
    Expression as the incrementExpr argument, Statement as the
    stmt argument, perIterationLets as the perIterationBindings,
    and with labelSet.

11. Set the running execution context’s LexicalEnvironment to oldEnv.

12. Return bodyResult.

Runtime Semantics: ForBodyEvaluation

The abstract operation ForBodyEvaluation with arguments testExpr,
incrementExpr, stmt, perIterationBindings, and labelSet is
performed as follows:

1.  Let V = UNDEFINED.

2.  Let status be
    CreatePerIterationEnvironment(perIterationBindings).

3.  ReturnIfAbrupt(status).

4.  Repeat

    a.  If testExpr is not [empty], then

        i.  Let testExprRef be the result of evaluating testExpr.

        ii. Let testExprValue be GetValue(testExprRef).

        iii. If testExprValue.[[type]] is normal, then

            1.  If ToBoolean(testExprValue) is FALSE, return
                NormalCompletion(V).

        iv. Else,

            1.  Assert: testExprValue is an abrupt completion.

            2.  If LoopContinues (testExprValue_,_labelSet) is FALSE,
                return testExprValue.

    b.  Let result be the result of evaluating stmt.

    c.  If LoopContinues (result_,_labelSet) is FALSE, return result

    d.  If result.[[value]] is not empty, let V =
        result.[[value]].

    e.  f.  Let status be
        CreatePerIterationEnvironment(perIterationBindings).

    g.  ReturnIfAbrupt(status).

    h.  If incrementExpr is not [empty], then

        i.  Let incExprRef be the result of evaluating
            incrementExpr.

        ii. Let incExprValue be GetValue(incExprRef).

        iii. iv. If LoopContinues(incExprValue_,_labelSet) is FALSE,
            return incExprValue.

Runtime Semantics: CreatePerIterationEnvironment

The abstract operation CreatePerIterationEnvironment with argument
perIterationBindings is performed as follows:

1.  If perIterationBindings has any elements, then

    a.  Let lastIterationEnv be the running execution context’s
        LexicalEnvironment.

    b.  Let outer be lastIterationEnv’s outer environment reference.

    c.  Assert: outer is not NULL.

    d.  Let thisIterationEnv be NewDeclarativeEnvironment(outer).

    e.  For each element bn of perIterationBindings do,

        i.  Let status be the result of calling thisIterationEnv’s
            CreateMutableBinding concrete method passing bn and FALSE
            as the arguments.

        ii. Assert: status is never an abrupt completion.

        iii. Let lastValue be the result of calling
            lastIterationEnv’s GetBindingValue concrete method passing
            bn and TRUE as the arguments.

        iv. ReturnIfAbrupt(lastValue).

        v.  Call the InitializeBinding concrete method of
            thisIterationEnv passing bn and lastValue as the
            arguments.

    f.  Set the running execution context’s LexicalEnvironment to
        thisIterationEnv.

2.  Return UNDEFINED

The for-in and for-of Statements

Static Semantics: Early Errors

IterationStatement :

  FOR ( LeftHandSideExpression IN Expression ) Statement

  FOR ( LeftHandSideExpression OF AssignmentExpression ) Statement

-   It is a Syntax Error if LeftHandSideExpression is either an
    ObjectLiteral or an ArrayLiteral and if the lexical token
    sequence matched by LeftHandSideExpression cannot be parsed with
    no tokens left over using AssignmentPattern as the goal symbol.

  If LeftHandSideExpression is either an ObjectLiteral or an
  ArrayLiteral and if the lexical token sequence matched by
  LeftHandSideExpression can be parsed with no tokens left over using
  AssignmentPattern as the goal symbol then the following rules are
  not applied. Instead, the Early Error rules for AssignmentPattern
  are used.

-   -   It is a Syntax Error if IsValidSimpleAssignmentTarget of
    LeftHandSideExpression is FALSE.

-   It is a Syntax Error if the LeftHandSideExpression is
    CoverParenthesizedExpressionAndArrowParameterList : ( Expression
    )
    and Expression derives a production that would produce a Syntax
    Error according to these rules if that production is substituted for
    LeftHandSideExpression. This rule is recursively applied.

  NOTE The last rule means that the other rules are applied even if
  parentheses surround Expression.

IterationStatement :

  FOR ( ForDeclaration IN Expression ) Statement

  FOR ( ForDeclaration OF AssignmentExpression ) Statement

-   It is a Syntax Error if the BoundNames of ForDeclaration contains
    "LET".

-   It is a Syntax Error if any element of the BoundNames of
    ForDeclaration also occurs in the VarDeclaredNames of Statement.

-   It is a Syntax Error if the BoundNames of ForDeclaration contains
    any duplicate entries.

Static Semantics: BoundNames

See also: 13.2.1.2, 13.2.2.1, 12.1.2, 14.1.3, 14.2.2, 14.4.2, 14.5.2,
15.2.2.2, 15.2.3.1.

ForDeclaration : LetOrConst ForBinding

1.  Return the BoundNames of ForBinding.

Static Semantics: ContainsDuplicateLabels

  With argument labelSet.

See also: 13.0.1, 13.1.2, 13.5.2, 13.6.1.1, 13.6.2.1, 13.6.3.2, 13.10.2,
13.11.2, 13.12.2, 13.14.2, 15.2.1.2.

IterationStatement :

  FOR ([lookahead ∉ {LET [ }] LeftHandSideExpression IN Expression)
  Statement

  FOR ( VAR ForBinding IN Expression ) Statement

  FOR ( ForDeclaration IN Expression) Statement

  FOR ([lookahead ≠ LET] LeftHandSideExpression OF AssignmentExpression
  ) Statement

  FOR ( VAR ForBinding OF AssignmentExpression ) Statement

  FOR ( ForDeclaration OF AssignmentExpression~[In,\ ?Yield]~ )
  Statement

1.  Return ContainsDuplicateLabels of Statement with argument
    labelSet.

Static Semantics: ContainsUndefinedBreakTarget

  With argument labelSet.

See also: 13.0.2, 13.1.3, 13.5.3, 13.6.1.2, 13.6.2.2, 13.6.3.3, 13.8.2,
13.10.3, 13.11.3, 13.12.3, 13.14.3, 15.2.1.3.

IterationStatement :

  FOR ([lookahead ∉ {LET [ }] LeftHandSideExpression IN Expression)
  Statement

  FOR ( VAR ForBinding IN Expression ) Statement

  FOR ( ForDeclaration IN Expression) Statement

  FOR ([lookahead ≠ LET] LeftHandSideExpression OF AssignmentExpression
  ) Statement

  FOR ( VAR ForBinding OF AssignmentExpression ) Statement

  FOR ( ForDeclaration OF AssignmentExpression~[In,\ ?Yield]~ )
  Statement

1.  Return ContainsUndefinedBreakTarget of Statement with argument
    labelSet.

Static Semantics: ContainsUndefinedContinueTarget

  With arguments iterationSet and labelSet.

See also: 13.0.3, 13.1.4, 13.5.4, 13.6.1.3, 13.6.2.3, 13.6.3.4, 13.7.2,
13.10.4, 13.11.4, 13.12.4,13.14.4, 15.2.1.4.

IterationStatement :

  FOR ([lookahead ∉ {LET [ }] LeftHandSideExpression IN Expression)
  Statement

  FOR ( VAR ForBinding IN Expression ) Statement

  FOR ( ForDeclaration IN Expression) Statement

  FOR ([lookahead ≠ LET] LeftHandSideExpression OF AssignmentExpression
  ) Statement

  FOR ( VAR ForBinding OF AssignmentExpression ) Statement

  FOR ( ForDeclaration OF AssignmentExpression~[In,\ ?Yield]~ )
  Statement

1.  Return ContainsUndefinedContinueTarget of Statement with arguments
    iterationSet and « ».

Static Semantics: IsDestructuring

See also: 12.3.1.3.

ForDeclaration : LetOrConst ForBinding

1.  Return IsDestructuring of ForBinding.

ForBinding : BindingIdentifier

1.  Return FALSE.

ForBinding : BindingPattern

1.  Return TRUE.

Static Semantics: VarDeclaredNames

See also: 13.0.5, 13.1.11, 13.2.2.2, 13.5.5, 13.6.1.4, 13.6.2.4,
13.6.3.5, 13.10.5, 13.11.7, 13.12.12, 13.14.5, 14.1.18, 14.2.13, 15.1.5,
15.2.1.13.

IterationStatement : FOR ( LeftHandSideExpression IN Expression )
Statement

1.  Return the VarDeclaredNames of Statement.

IterationStatement : FOR ( VAR ForBinding IN Expression )
Statement

1.  Let names be the BoundNames of ForBinding.

2.  Append to names the elements of the VarDeclaredNames of
    Statement.

3.  Return names.

IterationStatement : FOR ( ForDeclaration IN Expression )
Statement

1.  Return the VarDeclaredNames of Statement.

IterationStatement : FOR ( LeftHandSideExpression OF
AssignmentExpression ) Statement

1.  Return the VarDeclaredNames of Statement.

IterationStatement : FOR ( VAR ForBinding OF AssignmentExpression
) Statement

1.  Let names be the BoundNames of ForBinding.

2.  Append to names the elements of the VarDeclaredNames of
    Statement.

3.  Return names.

IterationStatement : FOR ( ForDeclaration OF AssignmentExpression
) Statement

1.  Return the VarDeclaredNames of Statement.

Static Semantics: VarScopedDeclarations

See also: 13.0.6, 13.1.12, 13.2.2.3, 13.5.6, 13.6.1.5, 13.6.2.5,
13.6.3.6, 13.10.6, 13.11.8, 13.12.13, 13.14.6, 14.1.19, 14.2.14, 15.1.6,
15.2.1.14.

IterationStatement : FOR ( LeftHandSideExpression IN Expression )
Statement

1.  Return the VarScopedDeclarations of Statement.

IterationStatement : FOR ( VAR ForBinding IN Expression )
Statement

1.  Let declarations be a List containing ForBinding.

2.  Append to declarations the elements of the VarScopedDeclarations
    of Statement.

3.  Return declarations.

IterationStatement : FOR ( ForDeclaration IN Expression )
Statement

1.  Return the VarScopedDeclarations of Statement.

IterationStatement : FOR ( LeftHandSideExpression OF
AssignmentExpression ) Statement

1.  Return the VarScopedDeclarations of Statement.

IterationStatement : FOR ( VAR ForBinding OF AssignmentExpression
) Statement

1.  Let declarations be a List containing ForBinding.

2.  Append to declarations the elements of the VarScopedDeclarations
    of Statement.

3.  Return declarations.

IterationStatement : FOR ( ForDeclaration OF AssignmentExpression
) Statement

1.  Return the VarScopedDeclarations of Statement.

Runtime Semantics: BindingInitialization

  With arguments value and environment.

See also: 12.1.5, 13.2.3.5.

NOTE UNDEFINED is passed for environment to indicate that a PutValue
operation should be used to assign the initialization value. This is the
case for VAR statements and the formal parameter lists of some
non-strict functions (see 9.2.13). In those cases a lexical binding is
hoisted and preinitialized prior to evaluation of its initializer.

ForDeclaration : LetOrConst ForBinding

1.  Return the result of performing BindingInitialization for
    ForBinding passing value and environment as the arguments.

1.  2.  3.  

Runtime Semantics: BindingInstantiation

  With argument environment.

ForDeclaration : LetOrConst ForBinding

1.  For each element name of the BoundNames of ForBinding do

    a.  If IsConstantDeclaration of LetOrConst is TRUE, then

        i.  Call environment’s CreateImmutableBinding concrete method
            with arguments name and TRUE.

    b.  Else,

    c.  i.  Call environment’s CreateMutableBinding concrete method
            with argument name.

        ii. Assert: The above call to CreateMutableBinding will never
            return an abrupt completion.

2.  

Runtime Semantics: LabelledEvaluation

  With argument labelSet.

See also: 13.0.6, 13.6.1.5, 13.6.2.5, 13.6.3.6, 13.12.140.

IterationStatement : FOR ( LeftHandSideExpression IN Expression )
Statement

1.  Let keyResult be ForIn/OfExpressionEvaluation( « », Expression,
    enumerate, labelSet).

2.  ReturnIfAbrupt(keyResult).

3.  Return ForIn/OfBodyEvaluation(LeftHandSideExpression, Statement,
    keyResult, assignment, labelSet).

IterationStatement : FOR ( VAR ForBinding IN Expression )
Statement

1.  Let keyResult be ForIn/OfExpressionEvaluation( « », Expression,
    enumerate, labelSet).

2.  ReturnIfAbrupt(keyResult).

3.  Return ForIn/OfBodyEvaluation(ForBinding, Statement,
    keyResult, varBinding, labelSet).

IterationStatement : FOR ( ForDeclaration IN Expression )
Statement

1.  Let keyResult be the result of performing
    ForIn/OfExpressionEvaluation(BoundNames of ForDeclaration,
    Expression, enumerate, labelSet).

2.  ReturnIfAbrupt(keyResult).

3.  Return ForIn/OfBodyEvaluation(ForDeclaration, Statement,
    keyResult, lexicalBinding, labelSet).

IterationStatement : FOR ( LeftHandSideExpression OF
AssignmentExpression ) Statement

1.  Let keyResult be the result of performing
    ForIn/OfExpressionEvaluation( « », AssignmentExpression, iterate,
    labelSet).

2.  ReturnIfAbrupt(keyResult).

3.  Return ForIn/OfBodyEvaluation(LeftHandSideExpression, Statement,
    keyResult, assignment, labelSet).

IterationStatement : FOR ( VAR ForBinding OF AssignmentExpression
) Statement

1.  Let keyResult be the result of performing
    ForIn/OfExpressionEvaluation( « », AssignmentExpression, iterate,
    labelSet).

2.  ReturnIfAbrupt(keyResult).

3.  Return ForIn/OfBodyEvaluation(ForBinding, Statement,
    keyResult, varBinding, labelSet).

IterationStatement : FOR ( ForDeclaration OF AssignmentExpression
) Statement

1.  Let keyResult be the result of performing
    ForIn/OfExpressionEvaluation( BoundNames of ForDeclaration,
    AssignmentExpression, iterate, labelSet).

2.  ReturnIfAbrupt(keyResult).

3.  Return ForIn/OfBodyEvaluation(ForDeclaration, Statement,
    keyResult, lexicalBinding, labelSet).

Runtime Semantics: ForIn/OfExpressionEvaluation Abstract Operation

The abstract operation ForIn/OfExpressionEvaluation is called with
arguments TDZnames, expr, iterationKind, and labelSet. The value
of iterationKind is either ENUMERATE or ITERATE.

1.  Let oldEnv be the running execution context’s LexicalEnvironment.

2.  If TDZnames is not an empty List, then

    a.  Assert: TDZnames has no duplicate entries.

    b.  Let TDZ be NewDeclarativeEnvironment(oldEnv).

    c.  For each string name in TDZnames, do

        i.  Let status be the result of calling TDZ’s
            CreateMutableBinding concrete method passing name and
            FALSE as the arguments.

        ii. Assert: status is never an abrupt completion.

    d.  Set the running execution context’s LexicalEnvironment to TDZ.

3.  Let exprRef be the result of evaluating the production that is
    expr.

4.  Set the running execution context’s LexicalEnvironment to oldEnv.

5.  Let exprValue be GetValue(exprRef).

6.  If exprValue is an abrupt completion,

7.  a.  If LoopContinues(exprValue_,_labelSet) is FALSE, return
        exprValue.

    b.  Else, return Completion{[[type]]: break, [[value]]: empty,
        [[target]]: empty}.

8.  If iterationKind is enumerate, then

    a.  If exprValue.[[value]] is NULL or UNDEFINED, then

        i.  Return Completion{[[type]]: break, [[value]]: empty,
            [[target]]: empty}.

    b.  Let obj be ToObject(exprValue).

9.  a.  Let keys be the result of calling the [[Enumerate]] internal
        method of obj with no arguments.

10. Else,

    a.  Assert: iterationKind is iterate.

    b.  Let keys be GetIterator(exprValue).

11. If keys is an abrupt completion, then

    a.  If LoopContinues(keys_,_labelSet) is FALSE, return keys.

    b.  Assert: keys.[[type]] is continue

    c.  Return Completion{[[type]]: break, [[value]]: empty, [[target]]:
        empty}.

12. Return keys.

Runtime Semantics: ForIn/OfBodyEvaluation

The abstract operation ForIn/OfBodyEvaluation is called with arguments
lhs, stmt, iterator, lhsKind, and labelSet. The value of
lhsKind is either ASSIGNMENT, VARBINDING or LEXICALBINDING.

1.  Let oldEnv be the running execution context’s LexicalEnvironment.

2.  Let V = UNDEFINED .

3.  Let destructuring be IsDestructuring of lhs.

4.  If destructuring is TRUE and if lhsKind is assignment, then

    a.  Assert: lhs is a LeftHandSideExpression.

    b.  Let assignmentPattern be the parse of the source code
        corresponding to lhs using AssignmentPattern as the goal
        symbol.

5.  Repeat

    a.  If lhsKind is either assignment or varBinding, then

        i.  If destructuring is FALSE, then

            1.  Let lhsRef be the result of evaluating lhs ( it may
                be evaluated repeatedly).

            2.  ReturnIfAbrupt(lhsRef).

    b.  Else

    c.  i.  Assert: lhsKind is lexicalBinding.

        ii. Assert: lhs is a ForDeclaration.

        iii. Let iterationEnv be NewDeclarativeEnvironment(oldEnv).

        iv. Set the running execution context’s LexicalEnvironment to
            iterationEnv.

        v.  Perform BindingInstantiation for lhs passing
            iterationEnv as the argument.

        vi. If destructuring is FALSE, then

            1.  Assert: lhs binds a single name.

            2.  Let lhsName be the sole element of BoundNames of
                lhs.

            3.  Let lhsRef be ResolveBinding(the sole element of
                lhs).

            4.  Assert: lhsRef is not an abrupt completion.

    d.  Let nextResult be IteratorStep(iterator).

    e.  f.  If nextResult is an abrupt completion, then

        i.  Set the running execution context’s LexicalEnvironment to
            oldEnv.

        ii. Return nextResult.

    g.  If nextResult is FALSE, then

        i.  Set the running execution context’s LexicalEnvironment to
            oldEnv.

        ii. Return NormalCompletion(V).

    h.  Let nextValue be IteratorValue(nextResult).

    i.  If nextValue is an abrupt completion, then

        i.  Set the running execution context’s LexicalEnvironment to
            oldEnv.

        ii. Return nextValue.

    j.  If destructuring is FALSE, then

        i.  If lhsKind is lexicalBinding, then

            1.  Let status be InitializeReferencedBinding(lhsRef,
                nextValue).

        ii. Else,

            1.  Let status be PutValue(lhsRef, nextValue).

    k.  Else,

        i.  ii. If lhsKind is assignment, then

            1.  2.  3.  4.  5.  6.  7.  8.  9.  10. Let status be the
                result of performing DestructuringAssignmentEvaluation
                of assignmentPattern using nextValue as the
                argument.

        iii. Else if lhsKind is varBinding, then

            1.  Assert: lhs is a ForBinding.

            2.  Let status be the result of performing
                BindingInitialization for lhs passing nextValue and
                UNDEFINED as the arguments.

        iv. Else,

        v.  1.  Assert: lhsKind is lexicalBinding.

            2.  Assert: lhs is a ForDeclaration.

            3.  4.  5.  Let status be the result of performing
                BindingInitialization for lhs passing nextValue and
                iterationEnv as arguments.

    l.  m.  n.  If status is an abrupt completion, then

        i.  Set the running execution context’s LexicalEnvironment to
            oldEnv.

        ii. Return IteratorClose(iterator, status).

    o.  p.  Let status be the result of evaluating stmt.

    q.  If status.[[type]] is normal and status.[[value]] is not
        empty, then

    r.  i.  Let V = status.[[value]].

    s.  Set the running execution context’s LexicalEnvironment to
        oldEnv.

    t.  If LoopContinues(status_,_labelSet) is FALSE, then

        i.  Return IteratorClose(iterator, status).

        ii. 

Runtime Semantics: Evaluation

ForBinding : BindingIdentifier

1.  Let bindingId be StringValue of BindingIdentifier.

2.  Return ResolveBinding(bindingId)

    i.  1.  a.  b.  

    ii. 1.  2.  

    iii. 


The continue Statement

Syntax

ContinueStatement~[Yield]~ :

CONTINUE ;
CONTINUE [no LineTerminator here] LabelIdentifier~[?Yield]~ ;

Static Semantics: Early Errors

ContinueStatement : CONTINUE ;

ContinueStatement : CONTINUE LabelIdentifier ;

-   It is a Syntax Error if this production is not nested, directly or
    indirectly (but not crossing function boundaries), within an
    IterationStatement.

Static Semantics: ContainsUndefinedContinueTarget

  With arguments iterationSet and labelSet.

See also: 13.0.3, 13.1.4, 13.5.4, 13.6.1.3, 13.6.2.3, 13.6.3.4,
13.6.4.5, 13.10.4, 13.11.4, 13.12.4,13.14.4, 15.2.1.4.

ContinueStatement : CONTINUE ;

1.  Return FALSE.

ContinueStatement : CONTINUE LabelIdentifier;

1.  If the StringValue of LabelIdentifier is not an element of
    iterationSet, return TRUE.

2.  Return FALSE.

-   -   

Runtime Semantics: Evaluation

ContinueStatement : CONTINUE ;

1.  Return Completion{[[type]]: continue, [[value]]: empty, [[target]]:
    empty}.

ContinueStatement : CONTINUE LabelIdentifier;

1.  Let label be the StringValue of LabelIdentifier.

2.  Return Completion{[[type]]: continue, [[value]]: empty, [[target]]:
    label }.


The break Statement

Syntax

BreakStatement~[Yield]~ :

BREAK ;
BREAK [no LineTerminator here] LabelIdentifier~[?Yield]~ ;

Static Semantics: Early Errors

BreakStatement : BREAK ;

-   It is a Syntax Error if this production is not nested, directly or
    indirectly (but not crossing function boundaries), within an
    IterationStatement or a SwitchStatement.

-   

Static Semantics: ContainsUndefinedBreakTarget

  With argument labelSet.

See also: 13.0.2, 13.1.3, 13.5.3, 13.6.1.2, 13.6.2.2, 13.6.3.3,
13.6.4.4, 13.10.3, 13.11.3, 13.12.3, 13.14.3, 15.2.1.3.

BreakStatement : BREAK ;

1.  Return FALSE.

BreakStatement : BREAK LabelIdentifier;

1.  If the StringValue of LabelIdentifier is not an element of
    labelSet, return TRUE.

2.  Return FALSE.

Runtime Semantics: Evaluation

BreakStatement : BREAK ;

1.  Return Completion{[[type]]: break, [[value]]: empty, [[target]]:
    empty}.

BreakStatement : BREAK LabelIdentifier;

1.  Let label be the StringValue of LabelIdentifier.

2.  Return Completion{[[type]]: break, [[value]]: empty, [[target]]:
    label }.


The return Statement

Syntax

ReturnStatement~[Yield]~ :

RETURN ;
RETURN [no LineTerminator here] Expression~[In,\ ?Yield]~ ;

NOTE A RETURN statement causes a function to cease execution and return
a value to the caller. If Expression is omitted, the return value is
UNDEFINED. Otherwise, the return value is the value of Expression.

Runtime Semantics: Evaluation

ReturnStatement : RETURN ;

1.  Return Completion{[[type]]: return, [[value]]: UNDEFINED,
    [[target]]: empty}.

ReturnStatement : RETURN Expression ;

1.  Let exprRef be the result of evaluating Expression.

2.  Let exprValue be GetValue(exprRef).

3.  ReturnIfAbrupt(exprValue).

4.  Return Completion{[[type]]: return, [[value]]: exprValue,
    [[target]]: empty}.


The with Statement

Syntax

WithStatement~[Yield,\ Return]~ :

WITH ( Expression~[In,\ ?Yield]~ ) Statement~[?Yield,\ ?Return]~

NOTE The WITH statement adds an object environment record for a computed
object to the lexical environment of the running execution context. It
then executes a statement using this augmented lexical environment.
Finally, it restores the original lexical environment.

Static Semantics: Early Errors

WithStatement : WITH ( Expression ) Statement

-   It is a Syntax Error if the code that matches this production is
    contained in strict code.

-   

-   It is a Syntax Error if IsLabelledFunction(Statement) is TRUE.

NOTE It is only necessary to apply the second rule if the extension
specified in B.3.2 is implemented.

Static Semantics: ContainsDuplicateLabels

  With argument labelSet.

See also: 13.0.1, 13.1.2, 13.5.2, 13.6.1.1, 13.6.2.1, 13.6.3.2,
13.6.4.3, 13.11.2, 13.12.2, 13.14.2, 15.2.1.2.

WithStatement : WITH ( Expression ) Statement

1.  Return ContainsDuplicateLabels of Statement with argument
    labelSet.

Static Semantics: ContainsUndefinedBreakTarget

  With argument labelSet.

See also: 13.0.2, 13.1.3, 13.5.3, 13.6.1.2, 13.6.2.2, 13.6.3.3,
13.6.4.4, 13.8.2, 13.11.3, 13.12.3, 13.14.3, 15.2.1.3.

WithStatement : WITH ( Expression ) Statement

1.  Return ContainsUndefinedBreakTarget of Statement with argument
    labelSet.

Static Semantics: ContainsUndefinedContinueTarget

  With arguments iterationSet and labelSet.

See also: 13.0.3, 13.1.4, 13.5.4, 13.6.1.3, 13.6.2.3, 13.6.3.4,
13.6.4.5, 13.7.2, 13.11.4, 13.12.4,13.14.4, 15.2.1.4.

WithStatement : WITH ( Expression ) Statement

1.  Return ContainsUndefinedContinueTarget of Statement with arguments
    iterationSet and « ».

Static Semantics: VarDeclaredNames

See also: 13.0.5, 13.1.11, 13.2.2.2, 13.5.5, 13.6.1.4, 13.6.2.4,
13.6.3.5, 13.6.4.7, 13.11.7, 13.12.12, 13.14.5, 14.1.18, 14.2.13,
15.1.5, 15.2.1.13.

WithStatement : WITH ( Expression ) Statement

1.  Return the VarDeclaredNames of Statement.

Static Semantics: VarScopedDeclarations

See also: 13.0.6, 13.1.12, 13.2.2.3, 13.5.6, 13.6.1.5, 13.6.2.5,
13.6.3.6, 13.6.4.8, 13.11.8, 13.12.13, 13.14.6, 14.1.19, 14.2.14,
15.1.6, 15.2.1.14.

WithStatement : WITH ( Expression ) Statement

1.  Return the VarScopedDeclarations of Statement.

Runtime Semantics: Evaluation

WithStatement : WITH ( Expression ) Statement

1.  Let val be the result of evaluating Expression.

2.  Let obj be ToObject(GetValue(val)).

3.  ReturnIfAbrupt(obj).

4.  Let oldEnv be the running execution context’s LexicalEnvironment.

5.  Let newEnv be NewObjectEnvironment(obj, oldEnv).

6.  Set the withEnvironment flag of newEnv’s environment record to
    TRUE.

7.  Set the running execution context’s LexicalEnvironment to newEnv.

8.  Let C be the result of evaluating Statement.

9.  10. Set the running execution context’s Lexical Environment to
    oldEnv.

11. Return C.

NOTE No matter how control leaves the embedded Statement, whether
normally or by some form of abrupt completion or exception, the
LexicalEnvironment is always restored to its former state.


The switch Statement

Syntax

SwitchStatement~[Yield,\ Return]~ :

SWITCH ( Expression~[In,\ ?Yield]~ ) CaseBlock~[?Yield,\ ?Return]~

CaseBlock~[Yield,\ Return]~ :

{ CaseClauses~[?Yield,\ ?Return]opt~ }
{ CaseClauses~[?Yield,\ ?Return]opt~ DefaultClause~[?Yield,\ ?Return]~
CaseClauses~[?Yield,\ ?Return]opt~ }

CaseClauses~[Yield,\ Return]~ :

CaseClause~[?Yield,\ ?Return]~
CaseClauses~[?Yield,\ ?Return]~ CaseClause~[?Yield,\ ?Return]~

CaseClause~[Yield,\ Return]~ :

CASE Expression~[In,\ ?Yield]~ : StatementList~[?Yield,\ ?Return]opt~

DefaultClause~[Yield,\ Return]~ :

DEFAULT : StatementList~[?Yield,\ ?Return]opt~

Static Semantics: Early Errors

CaseBlock : { CaseClauses }

-   It is a Syntax Error if the LexicallyDeclaredNames of CaseClauses
    contains any duplicate entries.

-   It is a Syntax Error if any element of the LexicallyDeclaredNames of
    CaseClauses also occurs in the VarDeclaredNames of CaseClauses.

Static Semantics: ContainsDuplicateLabels

  With argument labelSet.

See also: 13.0.1, 13.1.2, 13.5.2, 13.6.1.1, 13.6.2.1, 13.6.3.2,
13.6.4.3, 13.10.2, 13.12.2, 13.14.2, 15.2.1.2.

SwitchStatement : SWITCH ( Expression ) CaseBlock

1.  Return ContainsDuplicateLabels of CaseBlock with argument
    labelSet.

CaseBlock : { }

1.  Return FALSE.

CaseBlock : { CaseClauses~opt~ DefaultClause CaseClauses~opt~ }

1.  If the first CaseClauses is present, then

    a.  Let hasDuplicates be ContainsDuplicateLabels of the first
        CaseClauses with argument labelSet.

    b.  If hasDuplicates is TRUE, return TRUE.

2.  Let hasDuplicates be ContainsDuplicateLabels of DefaultClause
    with argument labelSet.

3.  If hasDuplicates is TRUE, return TRUE.

4.  If the second CaseClauses is not present, return FALSE.

5.  Return ContainsDuplicateLabels of the second CaseClauses with
    argument labelSet.

CaseClauses : CaseClauses CaseClause

1.  Let hasDuplicates be ContainsDuplicateLabels of CaseClauses with
    argument labelSet.

2.  If hasDuplicates is TRUE, return TRUE.

3.  Return ContainsDuplicateLabels of CaseClause with argument
    labelSet.

CaseClause : CASE Expression : StatementList~opt~

1.  If the StatementList is present, return ContainsDuplicateLabels of
    StatementList.

2.  Else return FALSE.

DefaultClause : DEFAULT : StatementList~opt~

1.  If the StatementList is present, return ContainsDuplicateLabels of
    StatementList with argument labelSet.

2.  Else return FALSE.

Static Semantics: ContainsUndefinedBreakTarget

  With argument labelSet.

See also: 13.0.2, 13.1.3, 13.5.3, 13.6.1.2, 13.6.2.2, 13.6.3.3,
13.6.4.4, 13.8.2, 13.10.3, 13.12.3, 13.14.3, 15.2.1.3.

SwitchStatement : SWITCH ( Expression ) CaseBlock

1.  Return ContainsUndefinedBreakTarget of CaseBlock with argument
    labelSet.

CaseBlock : { }

1.  Return FALSE.

CaseBlock : { CaseClauses~opt~ DefaultClause CaseClauses~opt~ }

1.  If the first CaseClauses is present, then

    a.  Let hasUndefinedLabels be ContainsUndefinedBreakTarget of the
        first CaseClauses with argument labelSet.

    b.  If hasUndefinedLabels is TRUE, return TRUE.

2.  Let hasUndefinedLabels be ContainsUndefinedBreakTarget of
    DefaultClause with argument labelSet.

3.  If hasUndefinedLabels is TRUE, return TRUE.

4.  If the second CaseClauses is not present, return FALSE.

5.  Return ContainsUndefinedBreakTarget of the second CaseClauses with
    argument labelSet.

CaseClauses : CaseClauses CaseClause

1.  Let hasUndefinedLabels be ContainsUndefinedBreakTarget of
    CaseClauses with argument labelSet.

2.  If hasUndefinedLabels is TRUE, return TRUE.

3.  Return ContainsUndefinedBreakTarget of CaseClause with argument
    labelSet.

CaseClause : CASE Expression : StatementList~opt~

1.  If the StatementList is present, return
    ContainsUndefinedBreakTarget of StatementList with argument
    labelSet.

2.  Else return FALSE.

DefaultClause : DEFAULT : StatementList~opt~

1.  If the StatementList is present, return
    ContainsUndefinedBreakTarget of StatementList with argument
    labelSet.

2.  Else return FALSE.

Static Semantics: ContainsUndefinedContinueTarget

  With arguments iterationSet and labelSet.

See also: 13.0.3, 13.1.4, 13.5.4, 13.6.1.3, 13.6.2.3, 13.6.3.4,
13.6.4.5, 13.7.2, 13.10.4, 13.12.4,13.14.4, 15.2.1.4.

SwitchStatement : SWITCH ( Expression ) CaseBlock

1.  Return ContainsUndefinedContinueTarget of CaseBlock with arguments
    iterationSet and « ».

CaseBlock : { }

1.  Return FALSE.

CaseBlock : { CaseClauses~opt~ DefaultClause CaseClauses~opt~ }

1.  If the first CaseClauses is present, then

    a.  Let hasUndefinedLabels be ContainsUndefinedContinueTarget of
        the first CaseClauses with arguments iterationSet and « ».

    b.  If hasUndefinedLabels is TRUE, return TRUE.

2.  Let hasUndefinedLabels be ContainsUndefinedContinueTarget of
    DefaultClause with arguments iterationSet and « ».

3.  If hasUndefinedLabels is TRUE, return TRUE.

4.  If the second CaseClauses is not present, return FALSE.

5.  Return ContainsUndefinedContinueTarget of the second CaseClauses
    with arguments iterationSet and « ».

CaseClauses : CaseClauses CaseClause

1.  Let hasUndefinedLabels be ContainsUndefinedContinueTarget of
    CaseClauses with arguments iterationSet and « ».

2.  If hasUndefinedLabels is TRUE, return TRUE.

3.  Return ContainsUndefinedContinueTarget of CaseClause with
    arguments iterationSet and « ».

CaseClause : CASE Expression : StatementList~opt~

1.  If the StatementList is present, return
    ContainsUndefinedContinueTarget of StatementList with arguments
    iterationSet and « ».

2.  Else return FALSE.

DefaultClause : DEFAULT : StatementList~opt~

1.  If the StatementList is present, return
    ContainsUndefinedContinueTarget of StatementList with arguments
    iterationSet and « ».

2.  Else return FALSE.

Static Semantics: LexicallyDeclaredNames

See also: 13.1.2, 13.12.6, 14.1.15, 14.2.10, 15.1.3, 15.2.1.11.

CaseBlock : { }

1.  Return a new empty List.

CaseBlock : { CaseClauses~opt~ DefaultClause CaseClauses~opt~ }

1.  If the first CaseClauses is present, let names be the
    LexicallyDeclaredNames of the first CaseClauses.

2.  Else let names be a new empty List.

3.  Append to names the elements of the LexicallyDeclaredNames of the
    DefaultClause.

4.  If the second CaseClauses is not present, return names.

5.  Else return the result of appending to names the elements of the
    LexicallyDeclaredNames of the second CaseClauses.

CaseClauses : CaseClauses CaseClause

1.  Let names be LexicallyDeclaredNames of CaseClauses.

2.  Append to names the elements of the LexicallyDeclaredNames of
    CaseClause.

3.  Return names.

CaseClause : CASE Expression : StatementList~opt~

1.  If the StatementList is present, return the LexicallyDeclaredNames
    of StatementList.

2.  Else return a new empty List.

DefaultClause : DEFAULT : StatementList~opt~

1.  If the StatementList is present, return the LexicallyDeclaredNames
    of StatementList.

2.  Else return a new empty List.

Static Semantics: LexicallyScopedDeclarations

See also: 13.1.613.1.2, 13.12.7, 14.1.16, 14.2.11, 15.1.4, 15.2.1.12,
15.2.3.8.

CaseBlock : { }

1.  Return a new empty List.

CaseBlock : { CaseClauses~opt~ DefaultClause CaseClauses~opt~ }

1.  If the first CaseClauses is present, let declarations be the
    LexicallyScopedDeclarations of the first CaseClauses.

2.  Else let declarations be a new empty List.

3.  Append to declarations the elements of the
    LexicallyScopedDeclarations of the DefaultClause.

4.  If the second CaseClauses is not present, return declarations.

5.  Else return the result of appending to declarations the elements
    of the LexicallyScopedDeclarations of the second CaseClauses.

CaseClauses : CaseClauses CaseClause

1.  Let declarations be LexicallyScopedDeclarations of CaseClauses.

2.  Append to declarations the elements of the
    LexicallyScopedDeclarations of CaseClause.

3.  Return declarations.

CaseClause : CASE Expression : StatementList~opt~

1.  If the StatementList is present, return the
    LexicallyScopedDeclarations of StatementList.

2.  Else return a new empty List.

DefaultClause : DEFAULT : StatementList~opt~

1.  If the StatementList is present, return the
    LexicallyScopedDeclarations of StatementList.

2.  Else return a new empty List.

Static Semantics: VarDeclaredNames

See also: 13.0.5, 13.1.11, 13.2.2.2, 13.5.5, 13.6.1.4, 13.6.2.4,
13.6.3.5, 13.6.4.7, 13.10.5, 13.12.12, 13.14.5, 14.1.18, 14.2.13,
15.1.5, 15.2.1.13.

SwitchStatement : SWITCH ( Expression ) CaseBlock

1.  Return the VarDeclaredNames of CaseBlock.

CaseBlock : { }

1.  Return a new empty List.

CaseBlock : { CaseClauses~opt~ DefaultClause CaseClauses~opt~ }

1.  If the first CaseClauses is present, let names be the
    VarDeclaredNames of the first CaseClauses.

2.  Else let names be a new empty List.

3.  Append to names the elements of the VarDeclaredNames of the
    DefaultClause.

4.  If the second CaseClauses is not present, return names.

5.  Else return the result of appending to names the elements of the
    VarDeclaredNames of the second CaseClauses.

CaseClauses : CaseClauses CaseClause

1.  Let names be VarDeclaredNames of CaseClauses.

2.  Append to names the elements of the VarDeclaredNames of
    CaseClause.

3.  Return names.

CaseClause : CASE Expression : StatementList~opt~

1.  If the StatementList is present, return the VarDeclaredNames of
    StatementList.

2.  Else return a new empty List.

DefaultClause : DEFAULT : StatementList~opt~

1.  If the StatementList is present, return the VarDeclaredNames of
    StatementList.

2.  Else return a new empty List.

Static Semantics: VarScopedDeclarations

See also: 13.0.6, 13.1.12, 13.2.2.3, 13.5.6, 13.6.1.5, 13.6.2.5,
13.6.3.6, 13.6.4.8, 13.10.6, 13.12.13, 13.14.6, 14.1.19, 14.2.14,
15.1.6, 15.2.1.14.

SwitchStatement : SWITCH ( Expression ) CaseBlock

1.  Return the VarScopedDeclarations of CaseBlock.

CaseBlock : { }

1.  Return a new empty List.

CaseBlock : { CaseClauses~opt~ DefaultClause CaseClauses~opt~ }

1.  If the first CaseClauses is present, let declarations be the
    VarScopedDeclarations of the first CaseClauses.

2.  Else let declarations be a new empty List.

3.  Append to declarations the elements of the VarScopedDeclarations
    of the DefaultClause.

4.  If the second CaseClauses is not present, return declarations.

5.  Else return the result of appending to declarations the elements
    of the VarScopedDeclarations of the second CaseClauses.

CaseClauses : CaseClauses CaseClause

1.  Let declarations be VarScopedDeclarations of CaseClauses.

2.  Append to declarations the elements of the VarScopedDeclarations
    of CaseClause.

3.  Return declarations.

CaseClause : CASE Expression : StatementList~opt~

1.  If the StatementList is present, return the VarScopedDeclarations
    of StatementList.

2.  Else return a new empty List.

DefaultClause : DEFAULT : StatementList~opt~

1.  If the StatementList is present, return the VarScopedDeclarations
    of StatementList.

2.  Else return a new empty List.

Runtime Semantics: CaseBlockEvaluation

  With argument input.

CaseBlock : { }

1.  Return NormalCompletion(UNDEFINED).

CaseBlock : { CaseClauses }

1.  Let V = UNDEFINED.

2.  Let A be the List of CaseClause items in CaseClauses, in
    source text order.

3.  Let searching be TRUE.

4.  Repeat, for each CaseClause, C, in A

    a.  If searching is TRUE, then

        i.  Let clauseSelector be the result of CaseSelectorEvaluation
            of C.

        ii. ReturnIfAbrupt(clauseSelector).

        iii. Let matched be the result of performing Strict Equality
            Comparison input === clauseSelector.

        iv. If matched is TRUE, then

            1.  Set searching to FALSE.

            2.  If C has a StatementList, then

            3.  a.  Let V be the result of evaluating C’s
                    StatementList.

                b.  ReturnIfAbrupt(V).

    b.  Else searching is FALSE,

    c.  d.  i.  If C has a StatementList, then

        ii. 1.  Let R be the result of evaluating C’s
                StatementList.

            2.  If R.[[value]] is not empty, let V = R.[[value]].

            3.  If R is an abrupt completion, return
                Completion{[[type]]: R.[[type]], [[value]]: V,
                [[target]]: R.[[target]]}.

5.  Return NormalCompletion(V).

CaseBlock : { CaseClauses~opt~ DefaultClause CaseClauses~opt~ }

1.  Let V = UNDEFINED.

2.  Let A be the list of CaseClause items in the first
    CaseClauses, in source text order. If the first CaseClauses is
    not present A is « ».

3.  Let found be FALSE.

4.  Repeat letting C be in order each CaseClause in A

    a.  If found is FALSE, then

        i.  Let clauseSelector be the result of CaseSelectorEvaluation
            of C.

        ii. If clauseSelector is an abrupt completion, then

            1.  If clauseSelector.[[value]] is empty, return
                Completion{[[type]]: clauseSelector.[[type]],
                [[value]]: UNDEFINED, [[target]]:
                clauseSelector.[[target]]}.

            2.  Else, return clauseSelector.

        iii. Let found be the result of performing Strict Equality
            Comparison input === clauseSelector.

    b.  If found is TRUE, then

        i.  Let R be the result of evaluating CaseClause C.

        ii. If R.[[value]] is not empty, let V = R.[[value]].

        iii. If R is an abrupt completion, return Completion{[[type]]:
            R.[[type]], [[value]]: V, [[target]]: R.[[target]]}.

5.  Let foundInB be FALSE.

6.  Let B be a new List containing the CaseClause items in the
    second CaseClauses, in source text order. If the second
    CaseClauses is not present B is « ».

7.  If found is FALSE, then

8.  a.  b.  Repeat, letting C be in order each CaseClause in B

        i.  If foundInB is FALSE, then

            1.  Let clauseSelector be the result of
                CaseSelectorEvaluation of C.

            2.  If clauseSelector is an abrupt completion, then

                a.  If clauseSelector.[[value]] is empty, return
                    Completion{[[type]]: clauseSelector.[[type]],
                    [[value]]: UNDEFINED, [[target]]:
                    clauseSelector.[[target]]}.

                b.  Else, return clauseSelector.

            3.  Let foundInB be the result of performing Strict
                Equality Comparison input === clauseSelector.

        ii. If foundInB is TRUE, then

            1.  Let R be the result of evaluating _CaseClause C_.

            2.  If R.[[value]] is not empty, let V = R.[[value]].

            3.  If R is an abrupt completion, return
                Completion{[[type]]: R.[[type]], [[value]]: V,
                [[target]]: R.[[target]]}.

9.  If foundInB is TRUE, return NormalCompletion(V).

10. Let R be the result of evaluating DefaultClause.

11. If R.[[value]] is not empty, let V = R.[[value]].

12. If R is an abrupt completion, return Completion{[[type]]:
    R.[[type]], [[value]]: V, [[target]]: R.[[target]]}.

13. 14. Repeat, letting C be in order each CaseClause in B (NOTE
    this is another complete iteration of the second CaseClauses)

    a.  Let R be the result of evaluating CaseClause C.

    b.  If R.[[value]] is not empty, let V = R.[[value]].

    c.  If R is an abrupt completion, return Completion{[[type]]:
        R.[[type]], [[value]]: V, [[target]]: R.[[target]]}.

15. Return NormalCompletion(V).

Runtime Semantics: CaseSelectorEvaluation

CaseClause : CASE Expression : StatementList~opt~

1.  Let exprRef be the result of evaluating Expression.

2.  Return GetValue(exprRef).

NOTE CaseSelectorEvaluation does not execute the associated
StatementList. It simply evaluates the Expression and returns the
value, which the CaseBlock algorithm uses to determine which
StatementList to start executing.

Runtime Semantics: Evaluation

SwitchStatement : SWITCH ( Expression ) CaseBlock

1.  Let exprRef be the result of evaluating Expression.

2.  Let switchValue be GetValue(exprRef).

3.  ReturnIfAbrupt(switchValue).

4.  Let oldEnv be the running execution context’s LexicalEnvironment.

5.  Let blockEnv be NewDeclarativeEnvironment(oldEnv).

6.  Perform BlockDeclarationInstantiation(CaseBlock, blockEnv).

7.  Let R be the result of performing CaseBlockEvaluation of
    CaseBlock with argument switchValue.

8.  Set the running execution context’s LexicalEnvironment to oldEnv.

9.  Return R.

NOTE No matter how control leaves the SwitchStatement the
LexicalEnvironment is always restored to its former state.

CaseClause : CASE Expression :

1.  Return NormalCompletion(empty).

CaseClause : CASE Expression : StatementList

1.  Return the result of evaluating StatementList.

DefaultClause : DEFAULT :

1.  Return NormalCompletion(empty).

DefaultClause : DEFAULT : StatementList

1.  Return the result of evaluating StatementList.


Labelled Statements

Syntax

LabelledStatement~[Yield,\ Return]~ :

LabelIdentifier~[?Yield]~ : LabelledItem~[?Yield,\ ?Return]~

LabelledItem~[Yield,\ Return]~ :

Statement~[?Yield,\ ?Return]
~FunctionDeclaration~[?Yield]~

NOTE A Statement may be prefixed by a label. Labelled statements are
only used in conjunction with labelled BREAK and CONTINUE statements.
ECMAScript has no GOTO statement. A Statement can be part of a
LabelledStatement, which itself can be part of a LabelledStatement,
and so on. The labels introduced this way are collectively referred to
as the “current label set” when describing the semantics of individual
statements. A LabelledStatement has no semantic meaning other than the
introduction of a label to a _label set_.

Static Semantics: Early Errors

-   

LabelledItem : FunctionDeclaration

-   It is a Syntax Error if any source code matches this rule.

NOTE An alternative definition for this rule is provided in B.3.2.

Static Semantics: ContainsDuplicateLabels

  With argument labelSet.

See also: 13.0.1, 13.1.2, 13.5.2, 13.6.1.1, 13.6.2.1, 13.6.3.2,
13.6.4.3, 13.10.2, 13.11.2, 13.14.2, 15.2.1.2.

LabelledStatement : LabelIdentifier : LabelledItem

1.  Let label be the StringValue of LabelIdentifier.

2.  If label is an element of labelSet, return TRUE.

3.  Let newLabelSet be a copy of labelSet with label appended.

4.  Return ContainsDuplicateLabels of LabelledItem with argument
    newLabelSet.

LabelledItem : FunctionDeclaration

1.  Return FALSE.

Static Semantics: ContainsUndefinedBreakTarget

  With argument labelSet.

See also: 13.0.2, 13.1.3, 13.5.3, 13.6.1.2, 13.6.2.2, 13.6.3.3,
13.6.4.4, 13.8.2, 13.10.3, 13.11.3, 13.14.3, 15.2.1.3.

LabelledStatement : LabelIdentifier : LabelledItem

1.  Let label be the StringValue of LabelIdentifier.

2.  Let newLabelSet be a copy of labelSet with label appended.

3.  Return ContainsUndefinedBreakTarget of LabelledItem with argument
    newLabelSet.

LabelledItem : FunctionDeclaration

1.  Return FALSE.

Static Semantics: ContainsUndefinedContinueTarget

  With arguments iterationSet and labelSet.

See also: 13.0.3, 13.1.4, 13.5.4, 13.6.1.3, 13.6.2.3, 13.6.3.4,
13.6.4.5, 13.7.2, 13.10.4, 13.11.4, 13.14.4, 15.2.1.4.

LabelledStatement : LabelIdentifier : LabelledItem

1.  Let label be the StringValue of LabelIdentifier.

2.  Let newLabelSet be a copy of labelSet with label appended.

3.  Return ContainsUndefinedContinueTarget of LabelledItem with
    arguments iterationSet and newLabelSet.

LabelledItem : FunctionDeclaration

1.  Return FALSE.

1.  

Static Semantics: IsLabelledFunction ( stmt )

The abstract operation IsLabelledFunction with argument stmt performs
the following steps:

1.  If stmt is not a LabelledStatement, return FALSE.

2.  Let item be the LabelledItem component of stmt.

3.  If item is LabelledItem : FunctionDeclaration, return TRUE.

4.  Let subStmt be the Statement component of item.

5.  Return IsLabelledFunction(subStmt).

Static Semantics: LexicallyDeclaredNames

See also: 13.1.2, 13.11.2, 14.1.15, 14.2.10, 15.1.3, 15.2.1.11.

LabelledStatement : LabelIdentifier : LabelledItem

1.  Return the LexicallyDeclaredNames of LabelledItem.

LabelledItem : Statement

1.  Return a new empty List.

LabelledItem : FunctionDeclaration

1.  Return BoundNames of FunctionDeclaration.

Static Semantics: LexicallyScopedDeclarations

See also: 13.1.6, 13.11.6, 14.1.16, 14.2.11, 15.1.4, 15.2.1.12,
15.2.3.8.

LabelledStatement : LabelIdentifier : LabelledItem

1.  Return the LexicallyScopedDeclarations of LabelledItem.

LabelledItem : Statement

1.  Return a new empty List.

LabelledItem : FunctionDeclaration

1.  Return a new List containing FunctionDeclaration.

Static Semantics: TopLevelLexicallyDeclaredNames

See also: 13.1.7.

LabelledStatement : LabelIdentifier : LabelledItem

1.  Return a new empty List.

Static Semantics: TopLevelLexicallyScopedDeclarations

See also: 13.1.8.

LabelledStatement : LabelIdentifier : LabelledItem

1.  Return a new empty List.

Static Semantics: TopLevelVarDeclaredNames

See also: 13.1.9.

LabelledStatement : LabelIdentifier : LabelledItem

1.  Return the TopLevelVarDeclaredNames of LabelledItem.

LabelledItem : Statement

1.  If Statement is Statement : LabelledStatement, return
    TopLevelVarDeclaredNames of Statement.

2.  Return VarDeclaredNames of Statement.

LabelledItem : FunctionDeclaration

1.  Return BoundNames of FunctionDeclaration.

Static Semantics: TopLevelVarScopedDeclarations

See also: 13.1.10.

LabelledStatement : LabelIdentifier : LabelledItem

1.  Return the TopLevelVarScopedDeclarations of LabelledItem.

LabelledItem : Statement

1.  If Statement is Statement : LabelledStatement, return
    TopLevelVarScopedDeclarations of Statement.

2.  Return VarScopedDeclarations of Statement.

LabelledItem : FunctionDeclaration

1.  Return a new List containing FunctionDeclaration.

Static Semantics: VarDeclaredNames

See also: 13.0.5, 13.1.11, 13.2.2.2, 13.5.5, 13.6.1.4, 13.6.2.4,
13.6.3.5, 13.6.4.7, 13.10.5, 13.11.7, 13.14.5, 14.1.18, 14.2.13, 15.1.5,
15.2.1.13.

LabelledStatement : LabelIdentifier : LabelledItem

1.  Return the VarDeclaredNames of LabelledItem.

LabelledItem : FunctionDeclaration

1.  Return a new empty List.

Static Semantics: VarScopedDeclarations

See also: 13.0.6, 13.1.12, 13.2.2.3, 13.5.6, 13.6.1.5, 13.6.2.5,
13.6.3.6, 13.6.4.8, 13.10.6, 13.11.8, 13.14.6, 14.1.19, 14.2.14, 15.1.6,
15.2.1.14.

LabelledStatement : LabelIdentifier : LabelledItem

1.  Return the VarScopedDeclarations of LabelledItem.

LabelledItem : FunctionDeclaration

1.  Return a new empty List.

Runtime Semantics: LabelledEvaluation

  With argument labelSet.

See also: 13.0.6, 13.6.1.5, 13.6.2.5, 13.6.3.6, 13.6.4.11.

LabelledStatement : LabelIdentifier : LabelledItem

1.  Let label be the StringValue of LabelIdentifier.

2.  Append label as an element of labelSet.

3.  Let stmtResult be the result of performing LabelledEvaluation of
    LabelledItem with argument labelSet.

4.  If stmtResult.[[type]] is break and
    SameValue(stmtResult.[[target]], label), then

    a.  Return NormalCompletion(stmtResult.[[value]]).

5.  Return stmtResult.

1.  1.  

LabelledItem : Statement

1.  2.  If Statement is either a LabelledStatement or a
    BreakableStatement, then

    a.  Return the result of performing LabelledEvaluation of
        Statement with argument labelSet.

3.  Else,

    a.  Return the result of evaluating Statement.

1.  a.  

2.  a.  

3.  

LabelledItem: FunctionDeclaration

1.  Return the result of evaluating FunctionDeclaration.

Runtime Semantics: Evaluation

LabelledStatement : LabelIdentifier : LabelledItem

1.  Let newLabelSet be a new empty List.

2.  Return the result of performing LabelledEvaluation of LabelledItem
    with argument newLabelSet.


The throw Statement

Syntax

ThrowStatement~[Yield]~ :

THROW [no LineTerminator here] Expression~[In,\ ?Yield]~ ;

Runtime Semantics: Evaluation

ThrowStatement : THROW Expression ;

1.  Let exprRef be the result of evaluating Expression.

2.  Let exprValue be GetValue(exprRef).

3.  ReturnIfAbrupt(exprValue).

4.  Return Completion{[[type]]: throw, [[value]]: exprValue,
    [[target]]: empty}.


The try Statement

Syntax

TryStatement~[Yield,\ Return]~ :

TRY Block~[?Yield,\ ?Return]~ Catch~[?Yield,\ ?Return]
~TRY Block~[?Yield,\ ?Return]~ Finally~[?Yield,\ ?Return]
~TRY Block~[?Yield,\ ?Return]~ Catch~[?Yield,\ ?Return]~
Finally~[?Yield,\ ?Return]~

Catch~[Yield,\ Return]~ :

CATCH ( CatchParameter~[?Yield]~ ) Block~[?Yield,\ ?Return]~

Finally~[Yield,\ Return]~ :

FINALLY Block~[?Yield,\ ?Return]~

CatchParameter~[Yield]~ :

BindingIdentifier~[?Yield]
~BindingPattern~[?Yield]~

NOTE The TRY statement encloses a block of code in which an exceptional
condition can occur, such as a runtime error or a THROW statement. The
CATCH clause provides the exception-handling code. When a catch clause
catches an exception, its CatchParameter is bound to that exception.

Static Semantics: Early Errors

Catch : CATCH ( CatchParameter ) Block

-   It is a Syntax Error if any element of the BoundNames of
    CatchParameter also occurs in the LexicallyDeclaredNames of
    Block.

-   It is a Syntax Error if any element of the BoundNames of
    CatchParameter also occurs in the VarDeclaredNames of Block.

NOTE An alternative static semantics for this production is given in
B.3.5.

Static Semantics: ContainsDuplicateLabels

  With argument labelSet.

See also: 13.0.1, 13.1.2, 13.5.2, 13.6.1.1, 13.6.2.1, 13.6.3.2,
13.6.4.3, 13.10.2, 13.11.2, 15.2.1.2.

TryStatement : TRY Block Catch

1.  Let hasDuplicates be ContainsDuplicateLabels of Block with
    argument labelSet.

2.  If hasDuplicates is TRUE, return TRUE.

3.  Return ContainsDuplicateLabels of Catch with argument labelSet.

TryStatement : TRY Block Finally

1.  Let hasDuplicates be ContainsDuplicateLabels of Block with
    argument labelSet.

2.  If hasDuplicates is TRUE, return TRUE.

3.  Return ContainsDuplicateLabels of Finally with argument
    labelSet.

TryStatement : TRY Block Catch Finally

1.  Let hasDuplicates be ContainsDuplicateLabels of Block with
    argument labelSet.

2.  If hasDuplicates is TRUE, return TRUE.

3.  Let hasDuplicates be ContainsDuplicateLabels of Catch with
    argument labelSet.

4.  If hasDuplicates is TRUE, return TRUE.

5.  Return ContainsDuplicateLabels of Finally with argument
    labelSet.

Catch : CATCH ( CatchParameter ) Block

1.  Return ContainsDuplicateLabels of Block with argument labelSet.

Static Semantics: ContainsUndefinedBreakTarget

  With argument labelSet.

See also: 13.0.2, 13.1.3, 13.5.3, 13.6.1.2, 13.6.2.2, 13.6.3.3,
13.6.4.4, 13.8.2, 13.10.3, 13.11.3, 13.12.3, 15.2.1.3.

TryStatement : TRY Block Catch

1.  Let hasUndefinedLabels be ContainsUndefinedBreakTarget of Block
    with argument labelSet.

2.  If hasUndefinedLabels is TRUE, return TRUE.

3.  Return ContainsUndefinedBreakTarget of Catch with argument
    labelSet.

TryStatement : TRY Block Finally

1.  Let hasUndefinedLabels be ContainsUndefinedBreakTarget of Block
    with argument labelSet.

2.  If hasUndefinedLabels is TRUE, return TRUE.

3.  Return ContainsUndefinedBreakTarget of Finally with argument
    labelSet.

TryStatement : TRY Block Catch Finally

1.  Let hasUndefinedLabels be ContainsUndefinedBreakTarget of Block
    with argument labelSet.

2.  If hasUndefinedLabels is TRUE, return TRUE.

3.  Let hasUndefinedLabels be ContainsUndefinedBreakTarget of Catch
    with argument labelSet.

4.  If hasUndefinedLabels is TRUE, return TRUE.

5.  Return ContainsUndefinedBreakTarget of Finally with argument
    labelSet.

Catch : CATCH ( CatchParameter ) Block

1.  Return ContainsUndefinedBreakTarget of Block with argument
    labelSet.

Static Semantics: ContainsUndefinedContinueTarget

  With arguments iterationSet and labelSet.

See also: 13.0.3, 13.1.4, 13.5.4, 13.6.1.3, 13.6.2.3, 13.6.3.4,
13.6.4.5, 13.7.2, 13.10.4, 13.11.4, 13.12.4, 15.2.1.4.

TryStatement : TRY Block Catch

1.  Let hasUndefinedLabels be ContainsUndefinedContinueTarget of
    Block with arguments iterationSet and « ».

2.  If hasUndefinedLabels is TRUE, return TRUE.

3.  Return ContainsUndefinedContinueTarget of Catch with arguments
    iterationSet and « ».

TryStatement : TRY Block Finally

1.  Let hasUndefinedLabels be ContainsUndefinedContinueTarget of
    Block with arguments iterationSet and « ».

2.  If hasUndefinedLabels is TRUE, return TRUE.

3.  Return ContainsUndefinedContinueTarget of Finally with arguments
    iterationSet and « ».

TryStatement : TRY Block Catch Finally

1.  Let hasUndefinedLabels be ContainsUndefinedContinueTarget of
    Block with arguments iterationSet and « ».

2.  If hasUndefinedLabels is TRUE, return TRUE.

3.  Let hasUndefinedLabels be ContainsUndefinedContinueTarget of
    Catch with arguments iterationSet and « ».

4.  If hasUndefinedLabels is TRUE, return TRUE.

5.  Return ContainsUndefinedContinueTarget of Finally with arguments
    iterationSet and « ».

Catch : CATCH ( CatchParameter ) Block

1.  Return ContainsUndefinedContinueTarget of Block with arguments
    iterationSet and « ».

Static Semantics: VarDeclaredNames

See also: 13.0.5, 13.1.11, 13.2.2.2, 13.5.5, 13.6.1.4, 13.6.2.4,
13.6.3.5, 13.6.4.7, 13.10.5, 13.11.7, 13.12.12, 14.1.18, 14.2.13,
15.1.5, 15.2.1.13.

TryStatement : TRY Block Catch

1.  Let names be VarDeclaredNames of Block.

2.  Append to names the elements of the VarDeclaredNames of Catch.

3.  Return names.

TryStatement : TRY Block Finally

1.  Let names be VarDeclaredNames of Block.

2.  Append to names the elements of the VarDeclaredNames of Finally.

3.  Return names.

TryStatement : TRY Block Catch Finally

1.  Let names be VarDeclaredNames of Block.

2.  Append to names the elements of the VarDeclaredNames of Catch.

3.  Append to names the elements of the VarDeclaredNames of Finally.

4.  Return names.

Catch : CATCH ( CatchParameter ) Block

1.  Return the VarDeclaredNames of Block.

Static Semantics: VarScopedDeclarations

See also: 13.0.6, 13.1.12, 13.2.2.3, 13.5.6, 13.6.1.5, 13.6.2.5,
13.6.3.6, 13.6.4.8, 13.10.6, 13.11.8, 13.12.13, 14.1.19, 14.2.14,
15.1.6, 15.2.1.14.

TryStatement : TRY Block Catch

1.  Let declarations be VarScopedDeclarations of Block.

2.  Append to declarations the elements of the VarScopedDeclarations
    of Catch.

3.  Return declarations.

TryStatement : TRY Block Finally

1.  Let declarations be VarScopedDeclarations of Block.

2.  Append to declarations the elements of the VarScopedDeclarations
    of Finally.

3.  Return declarations.

TryStatement : TRY Block Catch Finally

1.  Let declarations be VarScopedDeclarations of Block.

2.  Append to declarations the elements of the VarScopedDeclarations
    of Catch.

3.  Append to declarations the elements of the VarScopedDeclarations
    of Finally.

4.  Return declarations.

Catch : CATCH ( CatchParameter ) Block

1.  Return the VarScopedDeclarations of Block.

1.  2.  3.  

Runtime Semantics: CatchClauseEvaluation

with parameter thrownValue

Catch : CATCH ( CatchParameter ) Block

1.  Let oldEnv be the running execution context’s LexicalEnvironment.

2.  Let catchEnv be NewDeclarativeEnvironment(oldEnv).

3.  4.  For each element argName of the BoundNames of
    CatchParameter, do

    a.  Call the CreateMutableBinding concrete method of catchEnv
        passing argName as the argument.

    b.  Assert: The above call to CreateMutableBinding will never return
        an abrupt completion.

5.  Set the running execution context’s LexicalEnvironment to
    catchEnv.

6.  Let status be the result of performing BindingInitialization for
    CatchParameter passing thrownValue and catchEnv as arguments.

7.  8.  If status is an abrupt completion, then

9.  a.  Set the running execution context’s LexicalEnvironment to
        oldEnv.

    b.  Return status.

10. 11. 12. Let B be the result of evaluating Block.

13. Set the running execution context’s LexicalEnvironment to oldEnv.

14. Return B.

NOTE No matter how control leaves the Block the LexicalEnvironment is
always restored to its former state.

Runtime Semantics: Evaluation

TryStatement : TRY Block Catch

1.  Let B be the result of evaluating Block.

2.  If B.[[type]] is not throw, return B.

3.  Return the result of performing CatchClauseEvaluation of Catch
    with parameter B.[[value]].

TryStatement : TRY Block Finally

1.  Let B be the result of evaluating Block.

2.  Let F be the result of evaluating Finally.

3.  If F.[[type]] is normal, return B.

4.  Return F.

TryStatement : TRY _Block Catch Finally_

1.  Let B be the result of evaluating Block.

2.  If B.[[type]] is throw, then

    a.  Let C be the result of performing CatchClauseEvaluation of
        Catch with parameter B.[[value]].

3.  Else B.[[type]] is not throw,

    a.  Let C be B.

4.  Let F be the result of evaluating Finally.

5.  If F.[[type]] is normal, return C.

6.  Return F.


The debugger statement

Syntax

DebuggerStatement :

DEBUGGER ;

Runtime Semantics: Evaluation

NOTE Evaluating the DebuggerStatement production may allow an
implementation to cause a breakpoint when run under a debugger. If a
debugger is not present or active this statement has no observable
effect.

DebuggerStatement : DEBUGGER ;

1.  If an implementation defined debugging facility is available and
    enabled, then

    a.  Perform an implementation defined debugging action.

    b.  Let result be an implementation defined Completion value.

    c.  

2.  Else

    a.  Let result be NormalCompletion(empty).

3.  Return result.



ECMASCRIPT LANGUAGE: FUNCTIONS AND CLASSES 


NOTE Various ECMAScript language elements cause the creation of
ECMAScript function objects (9.1.14). Evaluation of such functions
starts with the execution of their [[Call]] internal method (9.2.2).


Function Definitions

Syntax

FunctionDeclaration~[Yield,\ Default]~ :

FUNCTION BindingIdentifier~[?Yield]~ ( FormalParameters ) { FunctionBody
}
[+Default] FUNCTION ( FormalParameters ) { FunctionBody }

FunctionExpression :

FUNCTION BindingIdentifier~opt~ ( FormalParameters ) { FunctionBody }

StrictFormalParameters~[Yield,\ GeneratorParameter]~ :

FormalParameters~[?Yield,\ ?GeneratorParameter]~

FormalParameters~[Yield,GeneratorParameter]~ :

[empty]
FormalParameterList~[?Yield,\ ?GeneratorParameter]~

FormalParameterList~[Yield,GeneratorParameter]~ :

FunctionRestParameter~[?Yield]~
FormalsList~[?Yield,\ ?GeneratorParameter]~
FormalsList~[?Yield,\ ?GeneratorParameter]~,
FunctionRestParameter~[?Yield]~

FormalsList~[Yield,GeneratorParameter]~ :

FormalParameter~[?Yield,\ ?GeneratorParameter]~
FormalsList~[?Yield,\ ?GeneratorParameter]~ ,
FormalParameter~[?Yield,?GeneratorParameter]~

FunctionRestParameter~[Yield]~ :

BindingRestElement~[?Yield]~

FormalParameter~[Yield,GeneratorParameter]~ :

BindingElement~[?Yield,\ ?GeneratorParameter]~

FunctionBody~[Yield]~ :

FunctionStatementList~[?Yield]~

FunctionStatementList~[Yield]~ :

StatementList~[?Yield,\ Return]opt~

Directive Prologues and the Use Strict Directive

A Directive Prologue is the longest sequence of ExpressionStatement
productions occurring as the initial StatementListItem productions of
a FunctionBody or a ScriptBody and where each ExpressionStatement
in the sequence consists entirely of a StringLiteral token followed by
a semicolon. The semicolon may appear explicitly or may be inserted by
automatic semicolon insertion. A Directive Prologue may be an empty
sequence.

A Use Strict Directive is an ExpressionStatement in a Directive
Prologue whose StringLiteral is either the exact code unit sequences
"USE STRICT" or 'USE STRICT'. A Use Strict Directive may not contain an
EscapeSequence or LineContinuation.

A Directive Prologue may contain more than one Use Strict Directive.
However, an implementation may issue a warning if this occurs.

NOTE The ExpressionStatement productions of a Directive Prologue are
evaluated normally during evaluation of the containing production.
Implementations may define implementation specific meanings for
ExpressionStatement productions which are not a Use Strict Directive
and which occur in a Directive Prologue. If an appropriate notification
mechanism exists, an implementation should issue a warning if it
encounters in a Directive Prologue an ExpressionStatement that is not
a Use Strict Directive and which does not have a meaning defined by the
implementation.

Static Semantics: Early Errors

FunctionDeclaration : FUNCTION BindingIdentifier (
FormalParameters ) { FunctionBody }
and
FunctionExpression : FUNCTION BindingIdentifier~opt~ (
FormalParameters ) { FunctionBody }

-   If the source code matching this production is strict code, the
    Early Error rules for StrictFormalParameters : FormalParameters
    are applied.

-   If the source code matching this production is strict code, it is a
    Syntax Error if BindingIdentifier is the IdentifierName EVAL or
    the IdentifierName ARGUMENTS.

-   -   It is a Syntax Error if any element of the BoundNames of
    FormalParameters also occurs in the LexicallyDeclaredNames of
    FunctionBody.

-   It is a Syntax Error if FormalParameters Contains SuperCall is
    TRUE.

-   It is a Syntax Error if FunctionBody Contains SuperCall is TRUE.

NOTE The LexicallyDeclaredNames of a FunctionBody does not include
identifiers bound using var or function declarations.

StrictFormalParameters : FormalParameters

-   It is a Syntax Error if BoundNames of FormalParameters contains
    any duplicate elements.

FormalParameters : FormalParameterList

-   It is a Syntax Error if IsSimpleParameterList of
    FormalParameterList is FALSE and BoundNames of
    FormalParameterList contains any duplicate elements.

NOTE Multiple occurrences of the same BindingIdentifier in a
FormalParameterList is only allowed for non-strict functions and
generator functions that have simple parameter lists.

FunctionBody : FunctionStatementList

-   It is a Syntax Error if the LexicallyDeclaredNames of
    FunctionStatementList contains any duplicate entries.

-   It is a Syntax Error if any element of the LexicallyDeclaredNames of
    FunctionStatementList also occurs in the VarDeclaredNames of
    FunctionStatementList.

-   It is a Syntax Error if ContainsDuplicateLabels of
    FunctionStatementList with argument « » is TRUE.

-   It is a Syntax Error if ContainsUndefinedBreakTarget of
    FunctionStatementList with argument « » is TRUE.

-   It is a Syntax Error if ContainsUndefinedContineTarget of
    FunctionStatementList with arguments « » and « » is TRUE.

Static Semantics: BoundNames

See also: 13.2.1.2, 13.2.2.1, 12.1.2, 13.6.4.2, 14.2.2, 14.4.2, 14.5.2,
15.2.2.2, 15.2.3.1.

FunctionDeclaration : FUNCTION BindingIdentifier (
FormalParameters ) { FunctionBody }

1.  Return the BoundNames of BindingIdentifier.

FunctionDeclaration : FUNCTION ( FormalParameters ) { FunctionBody
}

1.  Return «"*DEFAULT*"».

NOTE "*DEFAULT*" is used within this specification as a synthetic name
for hoistable anonymous functions that are defined using export
declarations.

FormalParameters : [empty]

1.  Return an empty List.

FormalParameterList : FormalsList , FunctionRestParameter

1.  Let names be BoundNames of FormalsList.

2.  Append to names the BoundNames of FunctionRestParameter.

3.  Return names.

FormalsList : _FormalsList ,_ FormalParameter

1.  Let names be BoundNames of FormalsList.

2.  Append to names the elements of BoundNames of FormalParameter.

3.  Return names.

Static Semantics: Contains

  With parameter symbol.

See also: 5.3, 12.2.5.2, 12.3.1.1, 14.2.3, 14.4.40, 14.5.4

FunctionDeclaration : FUNCTION BindingIdentifier (
FormalParameters ) { FunctionBody }

1.  Return FALSE.

FunctionExpression : FUNCTION BindingIdentifier~opt~ (
FormalParameters ) { FunctionBody }

1.  Return FALSE.

NOTE Static semantic rules that depend upon substructure generally do
not look into function definitions.

Static Semantics: ContainsExpression

See also: 13.2.3.2, 14.2.4.

FormalParameters : [empty]

1.  Return FALSE.

FormalParameterList : FunctionRestParameter

1.  Return FALSE.

FormalParameterList : FormalsList , FunctionRestParameter

1.  Return ContainsExpression of FormalsList.

FormalsList : _FormalsList ,_ FormalParameter

1.  If ContainsExpression of FormalsList is TRUE, return TRUE.

2.  Return ContainsExpression of FormalParameter.

Static Semantics: ExpectedArgumentCount

See also: 14.2.6, 14.3.2.

FormalParameters : [empty]

1.  Return 0.

FormalParameterList : FunctionRestParameter

1.  Return 0.

FormalParameterList : FormalsList , FunctionRestParameter

1.  Return the ExpectedArgumentCount of FormalsList.

NOTE The ExpectedArgumentCount of a FormalParameterList is the number
of FormalParameters to the left of either the rest parameter or the
first FormalParameter with an Initializer. A FormalParameter without
an initializer is allowed after the first parameter with an initializer
but such parameters are considered to be optional with UNDEFINED as
their default value.

FormalsList : FormalParameter

1.  If HasInitializer of FormalParameter is TRUE return 0

2.  Return 1.

FormalsList : FormalsList, FormalParameter

1.  Let count be the ExpectedArgumentCount of FormalsList.

2.  If HasInitializer of FormalsList is TRUE or HasInitializer of
    FormalParameter is TRUE, return count.

3.  Return count+1.

Static Semantics: FormalParameters

FunctionDeclaration : FUNCTION BindingIdentifier (
FormalParameters ) { FunctionBody }

1.  Return FormalParameters.

Static Semantics: HasInitializer

See also: 13.2.3.3, 14.2.7.

FormalParameters : [empty]

1.  Return FALSE.

FormalParameterList : FunctionRestParameter

1.  Return FALSE.

FormalParameterList : FormalsList , FunctionRestParameter

1.  If HasInitializer of FormalsList is TRUE, return TRUE.

2.  Return FALSE.

FormalsList : _FormalsList ,_ FormalParameter

1.  If HasInitializer of FormalsList is TRUE, return TRUE.

2.  Return HasInitializer of FormalParameter.

Static Semantics: HasName

See also: 14.2.8, 14.4.6, 14.5.6.

FunctionExpression : FUNCTION ( FormalParameters ) { FunctionBody
}

1.  Return FALSE.

FunctionExpression : FUNCTION BindingIdentifier ( FormalParameters
) { FunctionBody }

1.  Return TRUE.

Static Semantics: IsAnonymousFunctionDefinition ( production) Abstract Operation

The abstract operation IsAnonymousFunctionDefinition determines if its
argument is a function definition that does not bind a name. The
argument production is the result of parsing an AssignmentExpression
or Initializer. The following steps are taken:

1.  If IsFunctionDefinition of production is FALSE, return FALSE.

2.  Let hasName be the result of HasName of production.

3.  If hasName is TRUE, return FALSE.

4.  Return TRUE.

Static Semantics: IsConstantDeclaration

See also: 13.2.1.3, 14.4.8, 14.5.7, 15.2.3.7.

FunctionDeclaration : FUNCTION BindingIdentifier (
FormalParameters ) { FunctionBody }
FunctionDeclaration : FUNCTION ( FormalParameters ) { FunctionBody
}

1.  Return FALSE.

Static Semantics: IsFunctionDefinition

See also: 12.2.0.2, 12.2.9.212.2.9.2, 12.3.1.2, 12.4.2, 12.5.2, 12.6.1,
12.7.1, 12.8.1, 12.9.1, 12.10.1, 12.11.1, 12.12.1, 12.13.1, 12.14.2,
12.15.1, 14.4.8, 14.5.8.

FunctionExpression : FUNCTION ( FormalParameters ) { FunctionBody
}

1.  Return TRUE.

FunctionExpression : FUNCTION BindingIdentifier ( FormalParameters
) { FunctionBody }

1.  Return TRUE.

Static Semantics: IsSimpleParameterList

See also: 13.2.3.4, 14.2.8

FormalParameters : [empty]

1.  Return TRUE.

FormalParameterList : FunctionRestParameter

1.  Return FALSE.

FormalParameterList : FormalsList , FunctionRestParameter

1.  Return FALSE.

FormalsList : _FormalsList ,_ FormalParameter

1.  If IsSimpleParameterList of FormalsList is FALSE, return FALSE.

2.  Return IsSimpleParameterList of FormalParameter.

FormalParameter : BindingElement

1.  Return IsSimpleParameterList of BindingElement.

Static Semantics: IsStrict

See also: 15.1.2, 15.2.1.7.

FunctionStatementList : StatementList~opt~

1.  If this FunctionStatementList is contained in strict code or if
    StatementList is strict code, return TRUE. Otherwise, return
    FALSE.

Static Semantics: LexicallyDeclaredNames

See also: 13.1.2, 13.11.2, 13.12.6, 14.2.10, 15.1.3, 15.2.1.11.

FunctionStatementList : [empty]

1.  Return an empty List.

FunctionStatementList : StatementList

1.  Return TopLevelLexicallyDeclaredNames of StatementList.

Static Semantics: LexicallyScopedDeclarations

See also: 13.1.6, 13.11.6, 13.12.7, 14.2.11, 15.1.4, 15.2.1.12,
15.2.3.8.

FunctionStatementList : [empty]

1.  Return an empty List.

FunctionStatementList : StatementList

1.  Return the TopLevelLexicallyScopedDeclarations of StatementList.

Static Semantics: NeedsSuperBinding

See also: 14.2.12, 14.3.7, 14.4.11.

FunctionDeclaration : FUNCTION BindingIdentifier (
FormalParameters ) { FunctionBody }
FunctionDeclaration : FUNCTION ( FormalParameters ) { FunctionBody
}

1.  If FormalParameters Contains SuperProperty is TRUE, return TRUE.

2.  Return FunctionBody Contains SuperProperty.

FunctionExpression : FUNCTION BindingIdentifier~opt~ (
FormalParameters ) { FunctionBody }

1.  If FormalParameters Contains SuperProperty is TRUE, return TRUE.

2.  Return FunctionBody Contains SuperProperty.

FormalParameters : [empty]

1.  Return FALSE.

FormalParameters : FormalParameterList

1.  Return FormalParameterList Contains SuperProperty.

FunctionBody : FunctionStatementList

1.  Return FunctionStatementList Contains SuperProperty.

Static Semantics: VarDeclaredNames

See also: 13.0.5, 13.1.11, 13.2.2.2, 13.5.5, 13.6.1.4, 13.6.2.4,
13.6.3.5, 13.6.4.7, 13.10.5, 13.11.7, 13.12.12, 13.14.5, 14.2.13,
15.1.5, 15.2.1.13.

1.  

FunctionStatementList : [empty]

1.  Return an empty List.

FunctionStatementList : StatementList

1.  Return TopLevelVarDeclaredNames of StatementList.

Static Semantics: VarScopedDeclarations

See also: 13.0.6, 13.1.12, 13.2.2.3, 13.5.6, 13.6.1.5, 13.6.2.5,
13.6.3.6, 13.6.4.8, 13.10.6, 13.11.8, 13.12.13, 13.14.6, 14.2.14,
15.1.6, 15.2.1.14.

1.  

FunctionStatementList : [empty]

1.  Return an empty List.

FunctionStatementList : StatementList

1.  Return the TopLevelVarScopedDeclarations of StatementList.

Runtime Semantics: EvaluateBody

  With parameter functionObject.

See also: 14.2.16, 14.4.12.

FunctionBody : FunctionStatementList

1.  The code of this FunctionBody is strict mode code if it is
    contained in strict mode code or if the Directive Prologue (14.1.1)
    of its FunctionStatementList contains a Use Strict Directive or if
    any of the conditions in 10.2.1 apply. If the code of this
    FunctionBody is strict mode code, FunctionStatementList is
    evaluated in the following steps as strict mode code. Otherwise,
    StatementList is evaluated in the following steps as non-strict
    mode code.

2.  Return the result of evaluating FunctionStatementList.

3.  

4.  5.  

Runtime Semantics: IteratorBindingInitialization

  With parameters iterator and environment.

NOTE When UNDEFINED is passed for environment it indicates that a
PutValue operation should be used to assign the initialization value.
This is the case for formal parameter lists of non-strict functions. In
that case the formal parameter bindings are preinitialized in order to
deal with the possibility of multiple parameters with the same name.

See also: 13.2.3.6, 14.2.15.

FormalParameters : [empty]

1.  Return NormalCompletion(empty).

FormalParameterList : FormalsList , FunctionRestParameter

1.  Let restIndex be the result of performing
    IteratorBindingInitialization for FormalsList using iterator,
    and environment as the arguments.

2.  ReturnIfAbrupt(restIndex).

3.  Return the result of performing IteratorBindingInitialization for
    FunctionRestParameter using iterator and environment as the
    arguments.

FormalsList : FormalsList , FormalParameter

1.  Let status be the result of performing
    IteratorBindingInitialization for FormalsList using iterator and
    environment as the arguments.

2.  ReturnIfAbrupt(status).

3.  Return the result of performing IteratorBindingInitialization for
    FormalParameter using iterator and environment as the
    arguments.

Runtime Semantics: InstantiateFunctionObject

  With parameter scope.

See also: 14.4.13.

FunctionDeclaration : FUNCTION BindingIdentifier (
FormalParameters ) { FunctionBody }

1.  If the FunctionDeclaration is contained in strict code or if its
    FunctionBody is strict code, let strict be TRUE. Otherwise let
    strict be FALSE.

2.  Let name be StringValue of BindingIdentifier.

3.  Let F be FunctionCreate(Normal, FormalParameters, _FunctionBody,
    scope_, strict).

4.  If NeedsSuperBinding of FunctionDeclaration is TRUE, then

    a.  Perform MakeMethod(F, UNDEFINED).

5.  Perform MakeConstructor(F).

6.  Perform SetFunctionName(F, name).

7.  8.  Return F.

FunctionDeclaration : FUNCTION ( FormalParameters ) { FunctionBody
}

1.  If the FunctionDeclaration is contained in strict code or if its
    FunctionBody is strict code, let strict be TRUE. Otherwise let
    strict be FALSE.

2.  Let F be FunctionCreate(Normal, FormalParameters, _FunctionBody,
    scope_, strict).

3.  If NeedsSuperBinding of FunctionDeclaration is TRUE, then

    a.  Perform MakeMethod(F, UNDEFINED).

4.  Perform MakeConstructor(F).

5.  Perform SetFunctionName(F, "DEFAULT").

6.  Return F.

NOTE An anonymous FunctionDeclaration can only occur as part of an
EXPORT DEFAULT declaration.

Runtime Semantics: Evaluation

FunctionDeclaration : FUNCTION BindingIdentifier (
FormalParameters ) { FunctionBody }

FunctionDeclaration : FUNCTION( FormalParameters ) { FunctionBody
}

1.  Return NormalCompletion(empty)

FunctionExpression : FUNCTION ( FormalParameters ) { FunctionBody
}

1.  If the FunctionExpression is contained in strict code or if its
    FunctionBody is strict code, let strict be TRUE. Otherwise let
    strict be FALSE.

2.  Let scope be the LexicalEnvironment of the running execution
    context.

3.  Let closure be FunctionCreate(Normal, FormalParameters,
    _FunctionBody, scope_, strict).

4.  If NeedsSuperBinding of FunctionExpression is TRUE, then

    a.  Perform MakeMethod(closure, UNDEFINED).

5.  Perform MakeConstructor(closure).

6.  Return closure.

FunctionExpression : FUNCTION BindingIdentifier ( FormalParameters
) { FunctionBody }

1.  If the FunctionExpression is contained in strict code or if its
    FunctionBody is strict code, let strict be TRUE. Otherwise let
    strict be FALSE.

2.  Let runningContext be the running execution context’s Lexical
    Environment.

3.  Let funcEnv be NewDeclarativeEnvironment(runningContext ).

4.  Let envRec be funcEnv’s environment record.

5.  Let name be StringValue of BindingIdentifier.

6.  Call the CreateImmutableBinding concrete method of envRec passing
    name as the argument.

7.  Let closure be FunctionCreate(Normal, FormalParameters,
    _FunctionBody, funcEnv_, strict).

8.  If NeedsSuperBinding of FunctionExpression is TRUE, then

    a.  Perform MakeMethod(closure, UNDEFINED).

9.  Perform MakeConstructor(closure).

10. Perform SetFunctionName(closure, name).

11. 12. Call the InitializeBinding concrete method of envRec passing
    name and closure as the arguments.

13. Return NormalCompletion(closure).

NOTE 1 The BindingIdentifier in a FunctionExpression can be
referenced from inside the FunctionExpression's FunctionBody to
allow the function to call itself recursively. However, unlike in a
FunctionDeclaration, the BindingIdentifier in a FunctionExpression
cannot be referenced from and does not affect the scope enclosing the
FunctionExpression.

NOTE 2 A PROTOTYPE property is automatically created for every function
defined using a FunctionDeclaration or FunctionExpression, to allow
for the possibility that the function will be used as a constructor.

FunctionStatementList : [empty]

1.  Return NormalCompletion(UNDEFINED).


Arrow Function Definitions

Syntax

ArrowFunction~[In,\ Yield]~ :

ArrowParameters~[?Yield]~ [no LineTerminator here] =>
ConciseBody~[?In]~

ArrowParameters~[Yield]~ :

BindingIdentifier~[?Yield]~
CoverParenthesizedExpressionAndArrowParameterList~[?Yield]~

ConciseBody~[In]~ :

[lookahead ≠ {] AssignmentExpression~[?In]~
{ FunctionBody }

Supplemental Syntax

When the production

ArrowParameters~[Yield]~ :
CoverParenthesizedExpressionAndArrowParameterList~[?Yield]~

is recognized the following grammar is used to refine the interpretation
of

CoverParenthesizedExpressionAndArrowParameterList:

ArrowFormalParameters~[Yield,\ GeneratorParameter]~ :

( StrictFormalParameters~[?Yield,\ ?GeneratorParameter]~ )

Static Semantics: Early Errors

ArrowFunction : ArrowParameters => ConciseBody

-   

-   It is a Syntax Error if any element of the BoundNames of
    ArrowParameters also occurs in the LexicallyDeclaredNames of
    ConciseBody.

ArrowParameters~[Yield]~ :
CoverParenthesizedExpressionAndArrowParameterList~[?Yield]~

-   If the ~[Yield]~ grammar parameter is present on ArrowParameters,
    it is a Syntax Error if the lexical token sequence matched by
    CoverParenthesizedExpressionAndArrowParameterList~[?Yield]~ cannot
    be parsed with no tokens left over using
    ArrowFormalParameters~[Yield,\ GeneratorParameter]~ as the goal
    symbol.

-   If the ~[Yield]~ grammar parameter is not present on
    ArrowParameters, it is a Syntax Error if the lexical token
    sequence matched by
    CoverParenthesizedExpressionAndArrowParameterList~[?Yield]~ cannot
    be parsed with no tokens left over using ArrowFormalParameters as
    the goal symbol.

-   All early errors rules for ArrowFormalParameters and its derived
    productions also apply to CoveredFormalsList of
    CoverParenthesizedExpressionAndArrowParameterList~[?Yield]~.

NOTE The YIELD operator cannot be used within expressions that are part
of an ArrowFormalParameters.

Static Semantics: BoundNames

See also: 13.2.1.2, 13.2.2.1, 12.1.2, 13.6.4.2, 14.1.3, 14.4.2, 14.5.2,
15.2.2.2, 15.2.3.1.

ArrowParameters~[Yield]~ :
CoverParenthesizedExpressionAndArrowParameterList~[?Yield]~

1.  Let formals be CoveredFormalsList of
    CoverParenthesizedExpressionAndArrowParameterList~[?Yield]~.

2.  Return the BoundNames of formals.

Static Semantics: Contains

  With parameter symbol.

See also: 5.3, 12.2.5.2, 12.3.1.1, 14.1.4, 14.4.40, 14.5.4

ArrowFunction : ArrowParameters => ConciseBody

1.  If symbol is not one of SuperProperty, SuperCall, SUPER or
    THIS, return FALSE.

2.  If ArrowParameters Contains symbol is TRUE, return TRUE;

3.  Return ConciseBody Contains symbol .

NOTE Normally, Contains does not look inside most function forms
However, Contains is used to detect THIS and SUPER usage within an
ArrowFunction.

ArrowParameters~[Yield]~ :
CoverParenthesizedExpressionAndArrowParameterList~[?Yield]~

1.  Let formals be CoveredFormalsList of
    CoverParenthesizedExpressionAndArrowParameterList~[?Yield]~.

2.  Return formals Contains symbol.

Static Semantics: ContainsExpression

See also: 13.2.3.2, 14.1.5.

ArrowParameters : BindingIdentifier

1.  Return FALSE.

ArrowParameters~[Yield]~ :
CoverParenthesizedExpressionAndArrowParameterList~[?Yield]~

1.  Let formals be CoveredFormalsList of
    CoverParenthesizedExpressionAndArrowParameterList~[?Yield]~.

2.  Return the ContainsExpression of formals.

Static Semantics: CoveredFormalsList

ArrowParameters : BindingIdentifier

1.  Return BindingIdentifier.

CoverParenthesizedExpressionAndArrowParameterList~[Yield]~:

( Expression )
( )
( ... BindingIdentifier )
( Expression , ... BindingIdentifier )

1.  If the ~[Yield]~ grammar parameter is present for
    CoverParenthesizedExpressionAndArrowParameterList~[Yield]~ return
    the result of parsing the lexical token stream matched by
    CoverParenthesizedExpressionAndArrowParameterList~[Yield]~ using
    ArrowFormalParameters~[Yield,\ GeneratorParameter]~ as the goal
    symbol.

2.  If the ~[Yield]~ grammar parameter is not present for
    CoverParenthesizedExpressionAndArrowParameterList~[Yield]~ return
    the result of parsing the lexical token stream matched by
    CoverParenthesizedExpressionAndArrowParameterList using
    ArrowFormalParameters as the goal symbol.

Static Semantics: ExpectedArgumentCount

See also: 14.1.5, 14.3.2.

ArrowParameters : BindingIdentifier

1.  Return 1.

ArrowParameters~[Yield]~ :
CoverParenthesizedExpressionAndArrowParameterList~[?Yield]~

1.  Let formals be CoveredFormalsList of
    CoverParenthesizedExpressionAndArrowParameterList~[?Yield]~.

2.  Return the ExpectedArgumentCount of formals.

Static Semantics: HasInitializer

See also: 13.2.3.3, 14.1.7.

ArrowParameters : BindingIdentifier

1.  Return FALSE.

ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList

1.  Let formals be CoveredFormalsList of
    CoverParenthesizedExpressionAndArrowParameterList.

2.  Return the HasInitializer of formals.

Static Semantics: HasName

See also: 14.1.9, 14.4.6, 14.5.6.

ArrowFunction : ArrowParameters => ConciseBody

1.  Return FALSE.

Static Semantics: IsSimpleParameterList

See also: 13.2.3.4, 14.1.12.

ArrowParameters : BindingIdentifier

1.  Return TRUE.

ArrowParameters~[Yield]~ :
CoverParenthesizedExpressionAndArrowParameterList~[?Yield]~

1.  Let formals be CoveredFormalsList of
    CoverParenthesizedExpressionAndArrowParameterList~[?Yield]~.

2.  Return the IsSimpleParameterList of formals.

Static Semantics: LexicallyDeclaredNames

See also: 13.1.2, 13.11.2, 13.12.6, 14.1.15, 15.1.3, 15.2.1.11.

ConciseBody : AssignmentExpression

1.  Return an empty List.

Static Semantics: LexicallyScopedDeclarations

See also: 13.1.6, 13.11.6, 13.12.7, 14.1.16, 15.1.4, 15.2.1.12,
15.2.3.8.

ConciseBody : AssignmentExpression

1.  Return an empty List.

Static Semantics: NeedsSuperBinding

See also: 14.1.17, 14.3.7, 14.4.11.

ArrowFunction : ArrowParameters => ConciseBody

1.  Return FALSE.

NOTE NeedsSuperBinding is used to determine whether a function requires
its own super bindings. This is never the case for Arrow Functions.

Static Semantics: VarDeclaredNames

See also: 13.0.5, 13.1.11, 13.2.2.2, 13.5.5, 13.6.1.4, 13.6.2.4,
13.6.3.5, 13.6.4.7, 13.10.5, 13.11.7, 13.12.12, 13.14.5, 14.1.18,
15.1.5, 15.2.1.13.

ConciseBody : AssignmentExpression

1.  Return an empty List.

Static Semantics: VarScopedDeclarations

See also: 13.0.6, 13.1.12, 13.2.2.3, 13.5.6, 13.6.1.5, 13.6.2.5,
13.6.3.6, 13.6.4.8, 13.10.6, 13.11.8, 13.12.13, 13.14.6, 14.1.19,
15.1.6, 15.2.1.14.

ConciseBody : AssignmentExpression

1.  Return an empty List.

Runtime Semantics: IteratorBindingInitialization

  With parameters iterator and environment.

See also: 13.2.3.6, 14.1.21.

NOTE When UNDEFINED is passed for environment it indicates that a
PutValue operation should be used to assign the initialization value.
This is the case for formal parameter lists of non-strict functions. In
that case the formal parameter bindings are preinitialized in order to
deal with the possibility of multiple parameters with the same name.

ArrowParameters : BindingIdentifier

1.  Let next be IteratorStep(iterator).

2.  ReturnIfAbrupt(next).

3.  If next is FALSE, let v be UNDEFINED

4.  5.  Else

    a.  Let v be IteratorValue(next).

    b.  ReturnIfAbrupt(v).

6.  Return the result of performing BindingInitialization for
    BindingIdentifier using v and environment as the arguments.

ArrowParameters~[Yield]~ :
CoverParenthesizedExpressionAndArrowParameterList~[?Yield]~

1.  Let formals be CoveredFormalsList of
    CoverParenthesizedExpressionAndArrowParameterList~[?Yield]~.

2.  Return the result of performing IteratorBindingInitialization of
    formals with arguments iterator and environment.

Runtime Semantics: EvaluateBody

  With parameter functionObject.

See also: 14.1.20, 14.4.12.

ConciseBody : AssignmentExpression

1.  The code of this ConciseBody is strict mode code if it is
    contained in strict mode code or if any of the conditions in 10.2.1
    apply. If the code of this ConciseBody is strict mode code,
    AssignmentExpression is evaluated in the following steps as strict
    mode code. Otherwise, AssignmentExpression is evaluated in the
    following steps as non-strict mode code.

2.  Let exprRef be the result of evaluating AssignmentExpression.

3.  Let exprValue be GetValue(exprRef).

4.  5.  ReturnIfAbrupt(exprValue).

6.  Return Completion{[[type]]: return, [[value]]: exprValue,
    [[target]]: empty}.

Runtime Semantics: Evaluation

ArrowFunction~[Yield]~ : ArrowParameters~[?Yield]~ => ConciseBody

1.  If the code of this ArrowFunction is contained in strict mode code
    or if any of the conditions in 10.2.1 apply, let strict be TRUE.
    Otherwise let strict be FALSE.

2.  3.  Let scope be the LexicalEnvironment of the running execution
    context.

4.  Let parameters be CoveredFormalsList of
    ArrowParameters~[?Yield]~.

5.  Let closure be FunctionCreate(Arrow, parameters, _ConciseBody,
    scope_, strict).

6.  Return closure.

NOTE An ArrowFunction does not define local bindings for ARGUMENTS,
SUPER, or THIS. Any reference to ARGUMENTS, SUPER, or THIS within an
ArrowFunction must resolve to a binding in a lexically enclosing
environment. Typically this will be the Function Envionment of an
immediately enclosing function. Even though an ArrowFunction may
contain references to SUPER, the function object created in step 4 is
not made into a method by performing MakeMethod. An ArrowFunction that
references SUPER is always contained within a non-ArrowFunction and
the necessary state to implement SUPER is accessible via the scope
that is captured by the function object of the ArrowFunction.


Method Definitions

Syntax

MethodDefinition~[Yield]~ :

PropertyName~[?Yield]~ ( StrictFormalParameters ) { FunctionBody }
GeneratorMethod~[?Yield]~
GET PropertyName~[?Yield]~ ( ) { FunctionBody }
SET PropertyName~[?Yield]~ ( PropertySetParameterList ) { FunctionBody }

PropertySetParameterList :

FormalParameter

Static Semantics: Early Errors

-   

MethodDefinition : PropertyName ( StrictFormalParameters ) {
FunctionBody }

-   -   It is a Syntax Error if any element of the BoundNames of
    StrictFormalParameters also occurs in the LexicallyDeclaredNames
    of FunctionBody.

MethodDefinition : SET PropertyName ( PropertySetParameterList ) {
FunctionBody }

-   -   -   It is a Syntax Error if BoundNames of
    PropertySetParameterList contains any duplicate elements.

-   It is a Syntax Error if any element of the BoundNames of
    PropertySetParameterList also occurs in the LexicallyDeclaredNames
    of FunctionBody.

Static Semantics: ComputedPropertyContains

  With parameter symbol.

See also: 12.2.5.2, 14.4.30, 14.5.5.

MethodDefinition :

PropertyName ( StrictFormalParameters ) { FunctionBody }
GET PropertyName ( ) { FunctionBody }
SET PropertyName ( PropertySetParameterList ) { FunctionBody }

1.  Return the result of ComputedPropertyContains for PropertyName
    with argument symbol.

Static Semantics: ExpectedArgumentCount

See also: 14.1.5, 14.2.6.

PropertySetParameterList : FormalParameter

1.  If HasInitializer of FormalParameter is TRUE return 0

2.  Return 1.

Static Semantics: HasComputedPropertyKey

SEE ALSO: 12.2.5.4, 14.4.5

MethodDefinition :

PropertyName ( StrictFormalParameters ) { FunctionBody }
GET PropertyName ( ) { FunctionBody }
SET PropertyName ( PropertySetParameterList ) { FunctionBody }

1.  Return HasComputedPropertyKey of PropertyName.

Static Semantics: HasDirectSuper

See also: 14.4.6.

MethodDefinition : PropertyName ( StrictFormalParameters ) {
FunctionBody }

1.  2.  If StrictFormalParameters Contains SuperCall is TRUE, return
    TRUE.

3.  4.  Return FunctionBody Contains SuperCall.

MethodDefinition : GET PropertyName ( ) { FunctionBody }

1.  2.  Return FunctionBody Contains SuperCall.

MethodDefinition : SET PropertyName ( PropertySetParameterList ) {
FunctionBody }

1.  2.  If PropertySetParameterList Contains SuperCall is TRUE,
    return TRUE.

3.  4.  Return FunctionBody Contains SuperCall.

Static Semantics: PropName

SEE ALSO: 12.2.5.6, 14.4.10, 14.5.12

MethodDefinition :

PropertyName ( StrictFormalParameters ) { FunctionBody }
GET PropertyName ( ) { FunctionBody }
SET PropertyName ( PropertySetParameterList ) { FunctionBody }

1.  Return PropName of PropertyName.

Static Semantics: NeedsSuperBinding

See also: 14.1.17, 14.2.12, 14.4.11.

MethodDefinition : PropertyName ( StrictFormalParameters ) {
FunctionBody }

1.  If StrictFormalParameters Contains SuperProperty is TRUE, return
    TRUE.

2.  Return FunctionBody Contains SuperProperty.

MethodDefinition : GET PropertyName ( ) { FunctionBody }

1.  Return FunctionBody Contains SuperProperty.

MethodDefinition : SET PropertyName ( PropertySetParameterList ) {
FunctionBody }

1.  If PropertySetParameterList Contains SuperProperty is TRUE,
    return TRUE.

2.  Return FunctionBody Contains SuperProperty.

Static Semantics: SpecialMethod

MethodDefinition : PropertyName ( StrictFormalParameters ) {
FunctionBody }

1.  Return FALSE.

MethodDefinition :

GeneratorMethod
GET PropertyName ( ) { FunctionBody }
SET PropertyName ( PropertySetParameterList ) { FunctionBody }

1.  Return TRUE.

Runtime Semantics: DefineMethod

  With parameters object and optional parameter functionPrototype.

MethodDefinition : PropertyName ( StrictFormalParameters ) {
FunctionBody }

1.  Let propKey be the result of evaluating PropertyName.

2.  ReturnIfAbrupt(propKey).

3.  Let strict be IsStrict of FunctionBody.

4.  5.  Let scope be the running execution context’s
    LexicalEnvironment.

6.  Let closure be FunctionCreate(Method, StrictFormalParameters,
    _FunctionBody, scope_, strict). If functionPrototype was passed
    as a parameter then pass its value as the functionPrototype
    optional argument of FunctionCreate.

7.  If NeedsSuperBinding of MethodDefinition is TRUE, then

    a.  Perform MakeMethod(closure, object).

8.  9.  Return the Record{[[key]]: propKey, [[closure]]: closure}.

Runtime Semantics: PropertyDefinitionEvaluation

  With parameters object and enumerable.

See also: 12.2.5.9, 14.4.140, B.3.1

MethodDefinition : PropertyName ( StrictFormalParameters ) {
FunctionBody }

1.  Let methodDef be DefineMethod of MethodDefinition with argument
    object.

2.  3.  ReturnIfAbrupt(methodDef).

4.  Perform SetFunctionName(methodDef.[[closure]],
    methodDef.[[key]]).

5.  6.  Let desc be the Property Descriptor{[[Value]]:
    methodDef.[[closure]], [[Writable]]: TRUE, [[Enumerable]]:
    enumerable, [[Configurable]]: TRUE}.

7.  8.  Return DefinePropertyOrThrow(object, methodDef.[[key]],
    desc).

MethodDefinition : GeneratorMethod

See 14.4.

MethodDefinition : GET PropertyName ( ) { FunctionBody }

1.  Let propKey be the result of evaluating PropertyName.

2.  ReturnIfAbrupt(propKey).

3.  Let strict be IsStrict of FunctionBody.

4.  Let scope be the running execution context’s LexicalEnvironment.

5.  Let formalParameterList be the production FormalParameters :
    [empty]

6.  Let closure be FunctionCreate(Method, formalParameterList,
    _FunctionBody, scope_, strict).

7.  If NeedsSuperBinding of MethodDefinition is TRUE, then

    a.  Perform MakeMethod(closure, object).

8.  Perform SetFunctionName(closure, propKey, "GET").

9.  10. Let desc be the PropertyDescriptor{[[Get]]: closure,
    [[Enumerable]]: enumerable, [[Configurable]]: TRUE}

11. Return DefinePropertyOrThrow(object, propKey, desc).

MethodDefinition : SET PropertyName ( PropertySetParameterList ) {
FunctionBody}

1.  Let propKey be the result of evaluating PropertyName.

2.  ReturnIfAbrupt(propKey).

3.  Let strict be IsStrict of FunctionBody.

4.  Let scope be the running execution context’s LexicalEnvironment.

5.  Let closure be FunctionCreate(Method, PropertySetParameterList,
    _FunctionBody, scope_, strict).

6.  If NeedsSuperBinding of MethodDefinition is TRUE, then

    a.  Perform MakeMethod(closure, object).

7.  Perform SetFunctionName(closure, propKey, "SET").

8.  9.  Let desc be the PropertyDescriptor{[[Set]]: closure,
    [[Enumerable]]: enumerable, [[Configurable]]: TRUE}

10. Return DefinePropertyOrThrow(object, propKey, desc).


Generator Function Definitions

Syntax

GeneratorMethod~[Yield]~ :

* PropertyName~[?Yield]~
(StrictFormalParameters~[Yield,GeneratorParameter]~ ) {
GeneratorBody~[Yield]~ }

GeneratorDeclaration~[Yield,\ Default]~ :

FUNCTION * BindingIdentifier~[?Yield]~ (
FormalParameters~[Yield,GeneratorParameter]~ ) { GeneratorBody~[Yield]~
}
[+Default] FUNCTION * ( FormalParameters~[Yield,GeneratorParameter]~ ) {
GeneratorBody~[Yield]~ }

GeneratorExpression :

FUNCTION * BindingIdentifier~[Yield]opt~ (
FormalParameters~[Yield,GeneratorParameter]~ ) { GeneratorBody~[Yield]~
}

GeneratorBody~[Yield]~ :

FunctionBody~[?Yield]~

YieldExpression~[In]~ :

YIELD
YIELD [no LineTerminator here] [Lexical goal InputElementRegExp]
AssignmentExpression~[?In,\ Yield]~
YIELD [no LineTerminator here] * [Lexical goal InputElementRegExp]
AssignmentExpression~[?In,\ Yield]~

NOTE 1 YieldExpression cannot be used within the FormalParameters of
a generator function because any expressions that are part of
FormalParameters are evaluated before the resulting generator object
is in a resumable state.

NOTE 2 Abstract operations relating to generator objects are defined in
25.3.3.

Static Semantics: Early Errors

GeneratorMethod : * PropertyName ( StrictFormalParameters ) {
GeneratorBody }

-   It is a Syntax Error if HasDirectSuper(GeneratorMethod) is TRUE .

-   -   It is a Syntax Error if any element of the BoundNames of
    StrictFormalParameters also occurs in the LexicallyDeclaredNames
    of GeneratorBody.

GeneratorDeclaration : FUNCTION * BindingIdentifier (
FormalParameters ) { GeneratorBody }

-   It is a Syntax Error if HasDirectSuper(GeneratorDeclaration) is
    TRUE .

GeneratorExpression : FUNCTION * BindingIdentifier~opt~ (
FormalParameters ) { GeneratorBody }

-   It is a Syntax Error if HasDirectSuper(GeneratorExpression) is
    TRUE .

GeneratorDeclaration : FUNCTION * BindingIdentifier (
FormalParameters ) { GeneratorBody }
and
GeneratorExpression : FUNCTION * BindingIdentifier~opt~ (
FormalParameters ) { GeneratorBody }

-   -   If the source code matching this production is strict code, the
    Early Error rules for StrictFormalParameters : FormalParameters
    are applied.

-   If the source code matching this production is strict code, it is a
    Syntax Error if BindingIdentifier is the IdentifierName EVAL or
    the IdentifierName ARGUMENTS.

-   -   It is a Syntax Error if any element of the BoundNames of
    FormalParameters also occurs in the LexicallyDeclaredNames of
    GeneratorBody.

Static Semantics: BoundNames

See also: 13.2.1.2, 13.2.2.1, 12.1.2, 13.6.4.2, 14.1.3, 14.2.2, 14.5.2,
15.2.2.2, 15.2.3.1.

GeneratorDeclaration : FUNCTION * BindingIdentifier (
FormalParameters ) { GeneratorBody }

1.  Return the BoundNames of BindingIdentifier.

GeneratorDeclaration : FUNCTION * ( FormalParameters ) {
GeneratorBody }

1.  Return «"*DEFAULT*"».

NOTE "*DEFAULT*" is used within this specification as a synthetic name
for hoistable anonymous functions that are defined using export
declarations.

Static Semantics: ComputedPropertyContains

  With parameter symbol.

See also: 12.2.5.2, 14.3.2, 14.5.5.

GeneratorMethod : * PropertyName ( StrictFormalParameters ) {
GeneratorBody }

1.  Return the result of ComputedPropertyContains for PropertyName
    with argument symbol.

Static Semantics: Contains

  With parameter symbol.

See also: 5.3, 12.2.5.2, 12.3.1.1, 14.1.4, 14.2.3, 14.5.4

GeneratorDeclaration : FUNCTION * BindingIdentifier (
FormalParameters ) { GeneratorBody }

GeneratorDeclaration : FUNCTION * ( FormalParameters ) {
GeneratorBody }

1.  Return FALSE.

GeneratorExpression : FUNCTION * BindingIdentifier~opt~ (
FormalParameters ) { GeneratorBody }

1.  Return FALSE.

NOTE Static semantic rules that depend upon substructure generally do
not look into function definitions.

Static Semantics: HasComputedPropertyKey

SEE ALSO: 12.2.5.4, 14.3.4.

GeneratorMethod : * PropertyName ( StrictFormalParameters ) {
GeneratorBody }

1.  Return IsComputedPropertyKey of PropertyName.

Static Semantics: HasDirectSuper

See also: 14.3.5.

GeneratorMethod : * PropertyName ( StrictFormalParameters ) {
GeneratorBody }

1.  2.  If StrictFormalParameters Contains SuperCall is TRUE, return
    TRUE.

3.  4.  Return GeneratorBody Contains SuperCall.

Static Semantics: HasName

See also: 14.1.9, 14.2.8, 14.5.6.

GeneratorExpression : FUNCTION * ( FormalParameters ) {
GeneratorBody }

1.  Return FALSE.

GeneratorExpression : FUNCTION * BindingIdentifier (
FormalParameters ) { GeneratorBody }

1.  Return TRUE.

Static Semantics: IsConstantDeclaration

See also: 13.2.1.3, 14.1.11, 14.5.7, 15.2.3.7.

GeneratorDeclaration : FUNCTION * BindingIdentifier (
FormalParameters ) { GeneratorBody }
GeneratorDeclaration : FUNCTION * ( FormalParameters ) {
GeneratorBody }

1.  Return FALSE.

Static Semantics: IsFunctionDefinition

See also: 12.2.0.2, 12.2.9.212.2.9.2, 12.3.1.2, 12.4.2, 12.5.2, 12.6.1,
12.7.1, 12.8.1, 12.9.1, 12.10.1, 12.11.1, 12.12.1, 12.13.1, 12.14.2,
12.15.1, 14.1.12, 14.5.8.

GeneratorExpression : FUNCTION * ( FormalParameters ) {
GeneratorBody }

1.  Return TRUE.

GeneratorExpression : FUNCTION * BindingIdentifier (
FormalParameters ) { GeneratorBody }

1.  Return TRUE.

1.  

Static Semantics: PropName

SEE ALSO: 12.2.5.6, 14.3.5, 14.5.12

GeneratorMethod : * PropertyName ( StrictFormalParameters ) {
GeneratorBody }

1.  Return PropName of PropertyName.

Static Semantics: NeedsSuperBinding

See also: 14.1.17, 14.2.12, 14.3.7.

GeneratorDeclaration : FUNCTION * BindingIdentifier (
FormalParameters ) { GeneratorBody }
GeneratorDeclaration : FUNCTION * ( FormalParameters ) {
GeneratorBody }

1.  If FormalParameters Contains SuperProperty is TRUE, return TRUE.

2.  Return GeneratorBody Contains SuperProperty.

GeneratorExpression : FUNCTION * BindingIdentifier~opt~ (
FormalParameters ) { GeneratorBody }

1.  If FormalParameters Contains SuperProperty is TRUE, return TRUE.

2.  Return GeneratorBody Contains SuperProperty.

GeneratorMethod : * PropertyName ( StrictFormalParameters ) {
GeneratorBody }

1.  If StrictFormalParameters Contains SuperProperty is TRUE, return
    TRUE.

2.  Return GeneratorBody Contains SuperProperty.

1.  

1.  

Runtime Semantics: EvaluateBody

  With parameter functionObject.

See also: 14.1.20, 14.2.16.

GeneratorBody : FunctionBody

1.  2.  3.  Let G be

4.  5.  be OrdinaryCreateFromConstructor(functionObject,
    "%GENERATORPROTOTYPE%", «‍[[GeneratorState]], [[GeneratorContext]]»
    ).

6.  ReturnIfAbrupt(G).

    a.  

7.  Let result be GeneratorStart(G, FunctionBody).

8.  ReturnIfAbrupt(result).

9.  Return Completion{[[type]]: return, [[value]]: result, [[target]]:
    empty}.

NOTE If the generator was invoked using [[Call]], the THIS binding will
have already been initialized in the normal manner. If the generator was
invoked using [[Construct]], the THIS bind is not initialized and any
references to THIS within the FunctionBody with produce a
REFERENCEERROR exception.

1.  2.  3.  4.  5.  6.  

Runtime Semantics: InstantiateFunctionObject

  With parameter scope.

See also: 14.1.22.

GeneratorDeclaration : FUNCTION * BindingIdentifier (
FormalParameters ) { GeneratorBody }

1.  If the GeneratorDeclaration is contained in strict code or if its
    GeneratorBody is strict code, let strict be TRUE. Otherwise let
    strict be FALSE.

2.  Let name be StringValue of BindingIdentifier.

3.  4.  Let F be GeneratorFunctionCreate(Normal, FormalParameters,
    GeneratorBody, scope, strict).

5.  If NeedsSuperBinding of GeneratorDeclaration is TRUE, then

    a.  Perform MakeMethod(F, UNDEFINED).

6.  Let prototype be ObjectCreate(%GeneratorPrototype%).

7.  Perform MakeConstructor(F, TRUE, prototype).

8.  Perform SetFunctionName(F, name).

9.  10. Return F.

GeneratorDeclaration : FUNCTION * ( FormalParameters ) {
GeneratorBody }

1.  If the GeneratorDeclaration is contained in strict code or if its
    GeneratorBody is strict code, let strict be TRUE. Otherwise let
    strict be FALSE.

2.  Let F be GeneratorFunctionCreate(Normal, FormalParameters,
    GeneratorBody, scope, strict).

3.  If NeedsSuperBinding of GeneratorDeclaration is TRUE, then

    a.  Perform MakeMethod(F, UNDEFINED).

4.  Let prototype be ObjectCreate(%GeneratorPrototype%).

5.  Perform MakeConstructor(F, TRUE, prototype).

6.  Perform SetFunctionName(F, "DEFAULT").

7.  Return F.

NOTE An anonymous GeneratorDeclaration can only occur as part of an
EXPORT DEFAULT declaration.

Runtime Semantics: PropertyDefinitionEvaluation

  With parameter object and enumerable.

See also: 12.2.5.9, 14.3.10, B.3.1

GeneratorMethod : * PropertyName ( StrictFormalParameters ) {
GeneratorBody }

1.  Let propKey be the result of evaluating PropertyName.

2.  ReturnIfAbrupt(propKey).

3.  Let strict be IsStrict of GeneratorBody.

4.  5.  Let scope be the running execution context’s
    LexicalEnvironment.

6.  7.  Let closure be GeneratorFunctionCreate(Method,
    StrictFormalParameters, _GeneratorBody, scope_, strict).

8.  If NeedsSuperBinding of GeneratorMethod is TRUE, then

    a.  Perform MakeMethod(closure, object).

9.  Let prototype be ObjectCreate(%GeneratorPrototype%).

10. Perform MakeConstructor(closure, TRUE, prototype).

11. Perform SetFunctionName(closure, propKey).

12. Let desc be the Property Descriptor{[[Value]]: closure,
    [[Writable]]: TRUE, [[Enumerable]]: enumerable, [[Configurable]]:
    TRUE}.

13. 14. Return DefinePropertyOrThrow(object, propKey, desc).

Runtime Semantics: Evaluation

1.  

GeneratorExpression : FUNCTION * ( FormalParameters ) {
GeneratorBody }

1.  Let strict be IsStrict of GeneratorBody.

2.  3.  Let scope be the LexicalEnvironment of the running execution
    context.

4.  Let closure be GeneratorFunctionCreate(Normal, FormalParameters,
    _GeneratorBody, scope_, strict).

5.  If NeedsSuperBinding of GeneratorExpression is TRUE, then

    a.  Perform MakeMethod(closure, UNDEFINED).

6.  Let prototype be ObjectCreate(%GeneratorPrototype%).

7.  Perform MakeConstructor(closure, TRUE, prototype).

8.  Return closure.

GeneratorExpression : FUNCTION * BindingIdentifier (
FormalParameters ) { GeneratorBody }

1.  Let strict be IsStrict of GeneratorBody.

2.  3.  Let runningContext be the running execution context’s Lexical
    Environment.

4.  Let funcEnv be NewDeclarativeEnvironment(runningContext).

5.  Let envRec be funcEnv’s environment record.

6.  Let name be StringValue of BindingIdentifier.

7.  Call the CreateImmutableBinding concrete method of envRec passing
    name as the argument.

8.  Let closure be GeneratorFunctionCreate(Normal, FormalParameters,
    _GeneratorBody, funcEnv_, strict).

9.  If NeedsSuperBinding of GeneratorExpression is TRUE, then

    a.  Perform MakeMethod(closure, UNDEFINED).

10. Let prototype be ObjectCreate(%GeneratorPrototype%).

11. Perform MakeConstructor (closure, TRUE, prototype).

1.  Perform SetFunctionName(closure, name).

1.  2.  Call the InitializeBinding concrete method of envRec passing
    name and closure as the arguments.

3.  Return closure.

NOTE 1 The BindingIdentifier in a GeneratorExpression can be
referenced from inside the GeneratorExpression's FunctionBody to
allow the generator code to call itself recursively. However, unlike in
a GeneratorDeclaration, the BindingIdentifier in a
GeneratorExpression cannot be referenced from and does not affect the
scope enclosing the GeneratorExpression.

YieldExpression : YIELD

1.  Return GeneratorYield(CreateIterResultObject(UNDEFINED, FALSE)).

YieldExpression : YIELD AssignmentExpression

1.  Let exprRef be the result of evaluating AssignmentExpression.

2.  Let value be GetValue(exprRef).

3.  ReturnIfAbrupt(value).

4.  Return GeneratorYield(CreateIterResultObject(value, FALSE)).

YieldExpression : YIELD * AssignmentExpression

1.  Let exprRef be the result of evaluating AssignmentExpression.

2.  Let value be GetValue(exprRef).

3.  4.  Let iterator be GetIterator(value).

5.  ReturnIfAbrupt(iterator_)_.

6.  Let received be NormalCompletion(UNDEFINED).

7.  Repeat

8.  a.  b.  If received.[[type]] is normal, then

        i.  Let innerResult be IteratorNext(iterator,
            received.[[value]]).

        ii. ReturnIfAbrupt(innerResult).

        iii. Let done be IteratorComplete(innerResult).

        iv. ReturnIfAbrupt(done).

        v.  If done is TRUE, then

            1.  Return IteratorValue (innerResult).

        vi. Let received be GeneratorYield(innerResult).

    c.  Else if received.[[type]] is throw, then

    d.  i.  Let throw be GetMethod(iterator, "THROW").

        ii. ReturnIfAbrupt(throw).

        iii. If throw is not UNDEFINED, then

            1.  Let innerResult be Call(throw, iterator,
                «‍received.[[value]]»).

            2.  ReturnIfAbrupt(innerResult).

            3.  NOTE: Exceptions from the inner iterator THROW method
                are propagated. Normal completions from an inner THROW
                method are processed similarly to an inner NEXT.

            4.  If Type(innerResult) is not Object, throw a TYPEERROR
                exception.

            5.  Let done be IteratorComplete(innerResult).

            6.  ReturnIfAbrupt(done).

            7.  If done is TRUE, then

                a.  Return Completion{[[type]]: return , [[value]]:
                    IteratorValue(innerResult), [[target]]:empty}.

            8.  Let received be GeneratorYield(innerResult).

        iv. Else,

            1.  NOTE: If iterator does not have a THROW method, this
                throw is going to terminate the YIELD* loop. But first
                we need to give iterator a chance to clean up.

            2.  Let closeResult = IteratorClose(iterator,
                received).

            3.  ReturnIfAbrupt(closeResult).

            4.  Throw a TYPEERROR exception.

            5.  

    e.  Else,

        i.  Assert: received.[[type]] is return.

        ii. iii. Let return be GetMethod(iterator, "RETURN").

        iv. ReturnIfAbrupt(return).

        v.  If return is UNDEFINED, return received.

        vi. vii. Let innerReturnResult be Call(return, iterator,
            «‍received.[[value]]»).

        viii. ReturnIfAbrupt(innerReturnResult).

        ix. If Type(innerReturnResult) is not Object, throw a
            TYPEERROR exception.

        x.  Let done be IteratorComplete(innerReturnResult).

        xi. ReturnIfAbrupt(done).

        xii. If done is TRUE, then

            1.  Return Completion{[[type]]: return , [[value]]:
                IteratorValue(innerReturnResult), [[target]]:empty}.

        xiii. Let received be GeneratorYield(innerReturnResult).

    f.  g.  i.  

    h.  i.  j.  i.  

    k.  


Class Definitions

Syntax

ClassDeclaration~[Yield,\ Default]~ :

CLASS BindingIdentifier~[?Yield]~ ClassTail~[?Yield]~
[+Default] CLASS ClassTail~[?Yield]~

ClassExpression~[Yield,GeneratorParameter]~ :

CLASS BindingIdentifier~[?Yield]opt~
ClassTail~[?Yield,?GeneratorParameter]~

ClassTail~[Yield,GeneratorParameter]~ :

[~GeneratorParameter] ClassHeritage~[?Yield]opt~ {
ClassBody~[?Yield]opt~ }
[+GeneratorParameter] ClassHeritage~opt~ { ClassBody~opt~ }

ClassHeritage~[Yield]~ :

EXTENDS LeftHandSideExpression~[?Yield]~

ClassBody~[Yield]~ :

ClassElementList~[?Yield]~

ClassElementList~[Yield]~ :

ClassElement~[?Yield]~
ClassElementList~[?Yield]~ ClassElement~[?Yield]~

ClassElement~[Yield]~ :

MethodDefinition~[?Yield]~
STATIC MethodDefinition~[?Yield]~
;

NOTE A ClassBody is always strict code.

Static Semantics: Early Errors

-   

ClassBody : ClassElementList

-   It is a Syntax Error if PrototypePropertyNameList of
    ClassElementList contains more than one occurrence of
    "CONSTRUCTOR".

-   

ClassElement : MethodDefinition

-   It is a Syntax Error if PropName of MethodDefinition is not
    "CONSTRUCTOR" and HasDirectSuper(MethodDefinition) is TRUE.

-   It is a Syntax Error if PropName of MethodDefinition is
    "CONSTRUCTOR" and SpecialMethod of MethodDefinition is TRUE.

-   

ClassElement : STATIC MethodDefinition

-   It is a Syntax Error if HasDirectSuper(MethodDefinition) is TRUE.

-   It is a Syntax Error if PropName of MethodDefinition is
    "PROTOTYPE".

-   

Static Semantics: BoundNames

See also: 13.2.1.2, 13.2.2.1, 12.1.2, 13.6.4.2, 14.1.3, 14.2.2, 14.4.2,
15.2.2.2, 15.2.3.1.

ClassDeclaration : CLASS BindingIdentifier ClassTail

1.  Return the BoundNames of BindingIdentifier.

ClassDeclaration : CLASS ClassTail

1.  Return «"*DEFAULT*"».

Static Semantics: ConstructorMethod

ClassElementList : ClassElement

1.  If ClassElement is the production ClassElement : ; , return
    empty.

2.  If IsStatic of ClassElement is TRUE, return empty.

3.  If PropName of ClassElement is not "CONSTRUCTOR", return empty.

4.  Return ClassElement.

ClassElementList : ClassElementList ClassElement

1.  Let head be ConstructorMethod of ClassElementList.

2.  If head is not empty, return head.

3.  If ClassElement is the production ClassElement : ; , return
    empty.

4.  If IsStatic of ClassElement is TRUE, return empty.

5.  If PropName of ClassElement is not "CONSTRUCTOR", return empty.

6.  Return ClassElement.

NOTE Early Error rules ensure that there is only one method definition
named "CONSTRUCTOR" and that it is not an accessor property or generator
definition.

Static Semantics: Contains

  With parameter symbol.

See also: 5.3, 12.2.5.2, 12.3.1.1, 14.1.4, 14.2.3, 14.4.40

ClassTail : ClassHeritage~opt~ { ClassBody }

1.  If symbol is ClassBody, return TRUE.

2.  If symbol is ClassHeritage, then

3.  a.  If ClassHeritage is present, return TRUE otherwise return
        FALSE.

    b.  

4.  Let inHeritage be ClassHeritage Contains symbol.

5.  If inHeritage is TRUE, return TRUE.

6.  Return the result of ComputedPropertyContains for ClassBody with
    argument symbol.

NOTE Static semantic rules that depend upon substructure generally do
not look into class bodies except for PropertyName productions.

Static Semantics: ComputedPropertyContains

  With parameter symbol.

See also: 12.2.5.2, 14.3.2, 14.4.3.

ClassElementList : ClassElementList ClassElement

1.  Let inList be the result of ComputedPropertyContains for
    ClassElementList with argument symbol.

2.  If inList is TRUE, return TRUE.

3.  Return the result of ComputedPropertyContains for ClassElement
    with argument symbol.

ClassElement : MethodDefinition

1.  Return the result of ComputedPropertyContains for MethodDefinition
    with argument symbol.

ClassElement : STATIC MethodDefinition

1.  Return the result of ComputedPropertyContains for MethodDefinition
    with argument symbol.

ClassElement : ;

1.  Return FALSE.

Static Semantics: HasName

See also: 14.1.9, 14.2.8, 14.4.6.

ClassExpression : CLASS ClassTail

1.  Return FALSE.

ClassExpression : CLASS BindingIdentifier ClassTail

1.  Return TRUE.

Static Semantics: IsConstantDeclaration

See also: 13.2.1.3, 14.1.11, 14.4.8, 15.2.3.7.

ClassDeclaration : CLASS BindingIdentifier ClassTail

ClassDeclaration : CLASS ClassTail

1.  Return FALSE.

Static Semantics: IsFunctionDefinition

See also: 12.2.0.2, 12.2.9.212.2.9.2, 12.3.1.2, 12.4.2, 12.5.2, 12.6.1,
12.7.1, 12.8.1, 12.9.1, 12.10.1, 12.11.1, 12.12.1, 12.13.1, 12.14.2,
12.15.1, 14.1.12, 14.4.8.

ClassExpression : CLASS ClassTail

1.  Return TRUE.

ClassExpression : CLASS BindingIdentifier ClassTail

1.  Return TRUE.

Static Semantics: IsStatic

ClassElement : MethodDefinition

1.  Return FALSE.

ClassElement : STATIC MethodDefinition

1.  Return TRUE.

ClassElement : ;

1.  Return FALSE.

1.  

Static Semantics: NonConstructorMethodDefinitions

ClassElementList : ClassElement

1.  If ClassElement is the production ClassElement : ; , return a
    new empty List.

2.  3.  4.  If IsStatic of ClassElement is FALSE and PropName of
    ClassElement is "CONSTRUCTOR", return a new empty List.

5.  Return a List containing ClassElement.

ClassElementList : ClassElementList ClassElement

1.  Let list be NonConstructorMethodDefinitions of ClassElementList.

2.  If ClassElement is the production ClassElement : ; , return
    list.

3.  If IsStatic of ClassElement is FALSE

4.  and PropName of ClassElement is "CONSTRUCTOR", return list.

5.  Append ClassElement to the end of list.

6.  Return list.

Static Semantics: PrototypePropertyNameList

ClassElementList : ClassElement

1.  If PropName of ClassElement is empty, return a new empty List.

2.  If IsStatic of ClassElement is TRUE, return a new empty List.

3.  Return a List containing PropName of ClassElement.

ClassElementList : ClassElementList ClassElement

1.  Let list be PrototypePropertyNameList of ClassElementList.

2.  If PropName of ClassElement is empty, return list.

3.  If IsStatic of ClassElement is TRUE, return list.

4.  Append PropName of ClassElement to the end of list.

5.  Return list.

Static Semantics: PropName

SEE ALSO: 12.2.5.6, 14.3.5, 14.4.10

ClassElement : ;

1.  Return empty.

Static Semantics: StaticPropertyNameList

ClassElementList : ClassElement

1.  If PropName of ClassElement is empty, return a new empty List.

2.  If IsStatic of ClassElement is FALSE, return a new empty List.

3.  Return a List containing PropName of ClassElement.

ClassElementList : ClassElementList ClassElement

1.  Let list be StaticPropertyNameList of ClassElementList.

2.  If PropName of ClassElement is empty, return list.

3.  If IsStatic of ClassElement is FALSE, return list.

4.  Append PropName of ClassElement to the end of list.

5.  Return list.

1.  2.  3.  

1.  2.  3.  4.  5.  

1.  

Runtime Semantics: ClassDefinitionEvaluation

  With parameter className.

ClassTail : ClassHeritage~opt~ { ClassBody~opt~ }

1.  Let lex be the LexicalEnvironment of the running execution
    context.

2.  3.  Let classScope be NewDeclarativeEnvironment(lex).

4.  Let classScopeEnvRec be classScope’s environment record.

5.  If className is not UNDEFINED, then

    a.  Call the CreateImmutableBinding concrete method of
        classScopeEnvRec passing className and TRUE as the
        arguments.

6.  If ClassHeritage~opt~ is not present, then

    a.  Let protoParent be the intrinsic object %ObjectPrototype%.

    b.  Let constructorParent be the intrinsic object
        %FunctionPrototype%.

7.  Else

8.  a.  Set the running execution context’s LexicalEnvironment to
        classScope.

    b.  Let superclass be the result of evaluating ClassHeritage.

    c.  Set the running execution context’s LexicalEnvironment to lex.

    d.  ReturnIfAbrupt(superclass).

    e.  If superclass is NULL, then

        i.  Let protoParent be NULL.

        ii. Let constructorParent be the intrinsic object
            %FunctionPrototype%.

    f.  Else if IsConstructor(superclass) is FALSE, throw a TYPEERROR
        exception.

    g.  Else

        i.  If superclass has a [[FunctionKind]] internal slot whose
            value is "GENERATOR", throw a TYPEERROR exception.

        ii. iii. Let protoParent be Get(superclass, "PROTOTYPE").

        iv. ReturnIfAbrupt(protoParent).

        v.  If Type(protoParent) is neither Object nor Null, throw a
            TYPEERROR exception.

        vi. Let constructorParent be superclass.

9.  Let proto be ObjectCreate(protoParent).

10. 11. a.  b.  c.  d.  

12. If ClassBody~opt~ is present, let

13. constructor be ConstructorMethod of ClassBody.

14. Else,

    a.  If ClassHeritage~opt~ is present, then

        i.  Let constructor be the result of parsing the String
            "CONSTRUCTOR(... ARGS){ SUPER (...ARGS);}" using the
            syntactic grammar with the goal symbol MethodDefinition.

    b.  Else,

    c.  i.  Let constructor be the result of parsing the String
            "CONSTRUCTOR( ){ }" using the syntactic grammar with the
            goal symbol MethodDefinition.

15. 16. Set the running execution context’s LexicalEnvironment to
    classScope.

17. Let constructorInfo be the result of performing DefineMethod for
    constructor with arguments proto and constructorParent as the
    optional functionPrototype argument.

18. Let F be constructorInfo.[[closure]]

19. If ClassHeritage~opt~ is present, set F’s [[ConstructorKind]]
    internal slot to "DERIVED".

20. Perform MakeConstructor(F, FALSE, proto).

21. Perform MakeClassConstructor(F).

22. Let desc be the PropertyDescriptor{[[Value]]: F, [[Writable]]:
    TRUE, [[Enumerable]]: FALSE, [[Configurable]]: TRUE}.

23. Call the [[DefineOwnProperty]] internal method of proto with
    arguments "CONSTRUCTOR" and desc.

24. If ClassBody~opt~ is not present, let methods be a new empty
    List.

25. Else, let methods be NonConstructorMethodDefinitions of
    ClassBody.

26. For each ClassElement m in order from methods

    a.  If IsStatic of m is FALSE, then

        i.  Let status be the result of performing
            PropertyDefinitionEvaluation for m with arguments proto
            and FALSE.

    b.  Else,

        i.  ii. iii. Let status be the result of performing
            PropertyDefinitionEvaluation for m with arguments F and
            FALSE.

    c.  If status is an abrupt completion, then

        i.  Set the running execution context’s LexicalEnvironment to
            lex.

        ii. Return status.

27. Set the running execution context’s LexicalEnvironment to lex.

28. If className is not UNDEFINED, then

29. a.  Call the InitializeBinding concrete method of classScopeEnvRec
        passing className and F as the arguments.

    b.  

30. Return F.

Runtime Semantics: BindingClassDeclarationEvaluation

ClassDeclaration : CLASS BindingIdentifier ClassTail

1.  Let className be StringValue of BindingIdentifier.

2.  3.  Let value be the result of ClassDefinitionEvaluation of
    classTail with argument className.

4.  5.  ReturnIfAbrupt(value).

6.  Let hasNameProperty be HasOwnProperty(value, "NAME").

7.  ReturnIfAbrupt(hasNameProperty).

8.  If hasNameProperty is FALSE, then

9.  perform SetFunctionName(value, className).

    a.  

10. Let env be the running execution context’s LexicalEnvironment.

11. Let status be the result of InitializeBoundName(className,
    value, env).

12. ReturnIfAbrupt(status).

13. Return value.

ClassDeclaration : CLASS ClassTail

1.  Return the result of ClassDefinitionEvaluation of ClassTail with
    argument UNDEFINED.

2.  

NOTE ClassDeclaration : CLASS ClassTail only occurs as part of an
ExportDeclaration and the setting of a name property and establishing
its binding are handled as part of the evaluation action for that
production. See 15.2.3.10.

Runtime Semantics: Evaluation

ClassDeclaration : CLASS BindingIdentifier ClassTail

1.  Let status be the result of BindingClassDeclarationEvaluation of
    this ClassDeclaration.

2.  ReturnIfAbrupt(status).

3.  Return NormalCompletion(empty).

NOTE ClassDeclaration : CLASS ClassTail only occurs as part of an
ExportDeclaration and is never directly evaluated.

ClassExpression : CLASS BindingIdentifier~opt~ ClassTail

1.  If BindingIdentifier~opt~ is not present, let className be
    UNDEFINED.

2.  Else, let className be StringValue of BindingIdentifier.

3.  Let value be the result of ClassDefinitionEvaluation of
    ClassTail with argument className.

4.  ReturnIfAbrupt(value).

5.  If className is not UNDEFINED, then

    a.  Let hasNameProperty be HasOwnProperty(value, "NAME").

    b.  ReturnIfAbrupt(hasNameProperty).

    c.  If hasNameProperty is FALSE, then

        i.  Perform SetFunctionName(value, className).

        ii. 

6.  Return NormalCompletion(value).

NOTE If the class definition included a "NAME" static method then that
method is not over-written with a "NAME" data property for the class
name.


Tail Position Calls

Static Semantics: IsInTailPosition(nonterminal) Abstract Operation

The abstract operation IsInTailPosition with argument nonterminal
performs the following steps:

1.  Assert: nonterminal is a parsed grammar production.

2.  If the source code matching nonterminal is not strict code, return
    FALSE.

3.  If nonterminal is not contained within a FunctionBody or
    ConciseBody, return FALSE.

4.  Let body be the FunctionBody or ConciseBody that most closely
    contains nonterminal.

5.  6.  If body is the FunctionBody of a GeneratorMethod,
    GeneratorDeclaration, or a GeneratorExpression, return FALSE.

7.  Return the result of HasProductionInTailPosition of body with
    argument nonterminal.

8.  

NOTE Tail Position calls are only defined in strict mode code because of
a common non-standard language extension (see 9.2.8) that enables
observation of the chain of caller contexts.

Static Semantics: HasProductionInTailPosition

  With parameter nonterminal.

NOTE nonterminal is a parsed grammar production that represent a
specific range of source code. When the following algorithms compare
nonterminal to other grammar symbols they are testing whether the same
source code was matched by both symbols.

Statement Rules

ConciseBody : AssignmentExpression

1.  Return HasProductionInTailPosition of AssignmentExpression with
    argument nonterminal.

StatementList : _StatementList StatementListItem_

1.  Let has be HasProductionInTailPosition of StatementList with
    argument nonterminal.

2.  If has is TRUE, RETURN TRUE.

3.  Return HasProductionInTailPosition of StatementListItem with
    argument nonterminal.

FunctionStatementList : [empty]

StatementListItem : Declaration

Statement :

VariableStatement
EmptyStatement
ExpressionStatement
ContinueStatement
BreakStatement
ThrowStatement
DebuggerStatement

Block : { }

ReturnStatement : RETURN ;

LabelledItem : FunctionDeclaration

IterationStatement :

FOR ( LeftHandSideExpression IN Expression ) Statement
FOR ( VAR ForBinding IN Expression ) Statement
FOR ( ForDeclaration IN Expression ) Statement
FOR ( LeftHandSideExpression OF AssignmentExpression ) Statement
FOR ( VAR ForBinding OF AssignmentExpression ) Statement
FOR ( ForDeclaration OF AssignmentExpression ) Statement

CaseBlock : { }

1.  Return FALSE.

IfStatement : IF ( Expression ) Statement ELSE Statement

1.  Let has be HasProductionInTailPosition of the first Statement
    with argument nonterminal.

2.  If has is TRUE, RETURN TRUE.

3.  Return HasProductionInTailPosition of the second Statement with
    argument nonterminal.

IfStatement : IF ( Expression ) Statement

IterationStatement :

DO Statement WHILE ( Expression ) ;~opt~
WHILE ( Expression ) Statement
FOR (Expression~opt~ ; Expression~opt~ ; Expression~opt~ ) Statement
FOR ( VAR VariableDeclarationList ; Expression~opt~ ; Expression~opt~ )
Statement
FOR ( LexicalDeclaration Expression~opt~ ; Expression~opt~ ) Statement

WithStatement : WITH ( Expression ) Statement

1.  Return HasProductionInTailPosition of Statement with argument
    nonterminal.

LabelledStatement :

LabelIdentifier : LabelledItem

1.  Return HasProductionInTailPosition of LabelledItem with argument
    nonterminal.

ReturnStatement : RETURN Expression;

1.  Return HasProductionInTailPosition of Expression with argument
    nonterminal.

SwitchStatement : SWITCH ( Expression ) CaseBlock

1.  Return HasProductionInTailPosition of CaseBlock with argument
    nonterminal.

CaseBlock : { CaseClauses~opt~ _DefaultClause CaseClauses_~opt~ }

1.  Let has be FALSE.

2.  If the first CaseClauses is present, let has be
    HasProductionInTailPosition of the first CaseClauses with argument
    nonterminal.

3.  If has is TRUE, RETURN TRUE.

4.  Let has be HasProductionInTailPosition of the DefaultClause with
    argument nonterminal.

5.  If has is TRUE, RETURN TRUE.

6.  If the second CaseClauses is present, let has be
    HasProductionInTailPosition of the second CaseClauses with
    argument nonterminal.

7.  Return has.

CaseClauses : _CaseClauses CaseClause_

1.  Let has be HasProductionInTailPosition of CaseClauses with
    argument nonterminal.

2.  If has is TRUE, RETURN TRUE.

3.  Return HasProductionInTailPosition of CaseClause with argument
    nonterminal.

CaseClause : CASE Expression : StatementList~opt~

DefaultClause : DEFAULT : StatementList~opt~

1.  If StatementList is present, return HasProductionInTailPosition of
    StatementList with argument nonterminal.

2.  Return FALSE.

TryStatement : TRY Block Catch

1.  Return HasProductionInTailPosition of Catch with argument
    nonterminal.

TryStatement : TRY Block Finally

TryStatement : TRY Block Catch Finally

1.  Return HasProductionInTailPosition of Finally with argument
    nonterminal.

Catch : CATCH ( CatchParameter ) Block

1.  Return HasProductionInTailPosition of Block with argument
    nonterminal.

Expression Rules

NOTE A potential tail position call that is immediately followed by
return GetValue of the call result is also a possible tail position
call. Function calls cannot return reference values, so such a GetValue
operation will always returns the same value as the actual function call
result.

AssignmentExpression :

YieldExpression
ArrowFunction
LeftHandSideExpression = AssignmentExpression
LeftHandSideExpression AssignmentOperator AssignmentExpression

BitwiseANDExpression : BitwiseANDExpression & EqualityExpression

BitwiseXORExpression : BitwiseXORExpression ^ BitwiseANDExpression

BitwiseORExpression : BitwiseORExpression | BitwiseXORExpression

EqualityExpression :

EqualityExpression == RelationalExpression
EqualityExpression != RelationalExpression
EqualityExpression === RelationalExpression
EqualityExpression !== RelationalExpression

RelationalExpression :

RelationalExpression < ShiftExpression
RelationalExpression > ShiftExpression
RelationalExpression <= ShiftExpression
RelationalExpression >= ShiftExpression
RelationalExpression INSTANCEOF ShiftExpression
RelationalExpression IN ShiftExpression

ShiftExpression :

ShiftExpression << AdditiveExpression
ShiftExpression >> AdditiveExpression
ShiftExpression >>> AdditiveExpression

AdditiveExpression :

AdditiveExpression + MultiplicativeExpression
AdditiveExpression - MultiplicativeExpression

MultiplicativeExpression :

MultiplicativeExpression MultiplicativeOperator UnaryExpression

UnaryExpression :

DELETE UnaryExpression
VOID UnaryExpression
TYPEOF UnaryExpression
++ UnaryExpression
-- UnaryExpression
+ UnaryExpression
- UnaryExpression
~ UnaryExpression
! UnaryExpression

PostfixExpression :

LeftHandSideExpression ++
LeftHandSideExpression --

CallExpression :

CallExpression [ Expression ]
CallExpression . IdentifierName

MemberExpression :

MemberExpression [ Expression ]
MemberExpression . IdentifierName
SuperProperty

PrimaryExpression :

THIS
IdentifierReference
Literal
ArrayLiteral
ObjectLiteral
FunctionExpression
ClassExpression
GeneratorExpression
RegularExpressionLiteral
TemplateLiteral

1.  Return FALSE.

Expression :

AssignmentExpression
Expression , AssignmentExpression

1.  Return HasProductionInTailPosition of AssignmentExpression with
    argument nonterminal.

ConditionalExpression : LogicalORExpression ? AssignmentExpression
: AssignmentExpression

1.  Let has be HasProductionInTailPosition of the first
    AssignmentExpression with argument nonterminal.

2.  If has is TRUE, RETURN TRUE.

3.  Return HasProductionInTailPosition of the second
    AssignmentExpression with argument nonterminal.

LogicalANDExpression : LogicalANDExpression && BitwiseORExpression

1.  Return HasProductionInTailPosition of BitwiseORExpression with
    argument nonterminal.

LogicalORExpression : LogicalORExpression || LogicalANDExpression

1.  Return HasProductionInTailPosition of LogicalANDExpression with
    argument nonterminal.

CallExpression :

MemberExpression Arguments
SuperCall
CallExpression Arguments
CallExpression TemplateLiteral

1.  If this CallExpression is nonterminal, RETURN TRUE.

2.  Return FALSE.

MemberExpression :

MemberExpression TemplateLiteral
NEW MemberExpression Arguments

1.  If this MemberExpression is nonterminal, RETURN TRUE.

2.  Return FALSE.

NewExpression :

NEW NewExpression

1.  If this NewExpression is nonterminal, RETURN TRUE.

2.  Return FALSE.

PrimaryExpression :
CoverParenthesizedExpressionAndArrowParameterList

1.  Let expr be CoveredParenthesizedExpression of
    CoverParenthesizedExpressionAndArrowParameterList.

2.  Return HasProductionInTailPosition of expr with argument
    nonterminal.

ParenthesizedExpression :

( Expression )

1.  Return HasProductionInTailPosition of Expression with argument
    nonterminal.

Runtime Semantics: PrepareForTailCall ( )

The abstract operation PrepareForTailCall performs the following steps:

1.  Let leafContext be the running execution context.

2.  Suspend leafContext.

3.  Pop leafContext from the execution context context stack. The
    execution context now on the top of the stack becomes the running
    execution context.

4.  Assert: leafContext has no further use. It will never be activated
    as the running execution context.

A tail position call must either release any transient internal
resources associated with the currently executing function execution
context before invoking the target function or reuse those resources in
support of the target function.

NOTE For example, a tail position call should only grow an
implementation’s activation record stack by the amount that the size of
the target function’s activation record exceeds the size of the calling
function’s activation record. If the target function’s activation record
is smaller, then the total size of the stack should decrease.



ECMASCRIPT LANGUAGE: SCRIPTS AND MODULES


Scripts

Syntax

Script :

ScriptBody~opt~

ScriptBody :

StatementList

Static Semantics: Early Errors

ScriptBody : StatementList

-   It is a Syntax Error if the LexicallyDeclaredNames of
    StatementList contains any duplicate entries.

-   It is a Syntax Error if any element of the LexicallyDeclaredNames of
    StatementList also occurs in the VarDeclaredNames of
    StatementList.

-   It is a Syntax Error if StatementList Contains SUPER unless the
    source code containing SUPER is eval code that is being processed by
    a direct EVAL that is contained in function code.

-   -   It is a Syntax Error if StatementList Contains NewTarget
    unless the source code containing NewTarget is eval code that is
    being processed by a direct EVAL that is contained in function code.

-   It is a Syntax Error if ContainsDuplicateLabels of StatementList
    with argument « » is TRUE.

-   It is a Syntax Error if ContainsUndefinedBreakTarget of
    StatementList with argument « » is TRUE.

-   It is a Syntax Error if ContainsUndefinedContineTarget of
    StatementList with arguments « » and « » is TRUE.

-   

Static Semantics: IsStrict

See also: 14.1.14, 15.2.1.9.

ScriptBody : StatementList

1.  If this ScriptBody is contained in strict code or if
    StatementList is strict code, return TRUE. Otherwise, return
    FALSE.

Static Semantics: LexicallyDeclaredNames

See also: 13.1.2, 13.11.2, 13.12.6, 14.1.15, 14.2.10, 15.2.1.11.

ScriptBody : StatementList

1.  Return TopLevelLexicallyDeclaredNames of StatementList.

NOTE At the top level of a Script, function declarations are treated
like var declarations rather than like lexical declarations.

Static Semantics: LexicallyScopedDeclarations

See also: 13.1.6, 13.11.6, 13.12.7, 14.1.16, 14.2.11, 15.2.1.12,
15.2.3.8.

ScriptBody : StatementList

1.  Return TopLevelLexicallyScopedDeclarations of StatementList.

Static Semantics: VarDeclaredNames

See also: 13.0.5, 13.1.11, 13.2.2.2, 13.5.5, 13.6.1.4, 13.6.2.4,
13.6.3.5, 13.6.4.7, 13.10.5, 13.11.7, 13.12.12, 13.14.5, 14.1.18,
14.2.13, 15.2.1.13.

ScriptBody : StatementList

1.  Return TopLevelVarDeclaredNames of StatementList.

Static Semantics: VarScopedDeclarations

See also: 13.0.6, 13.1.12, 13.2.2.3, 13.5.6, 13.6.1.5, 13.6.2.5,
13.6.3.6, 13.6.4.8, 13.10.6, 13.11.8, 13.12.13, 13.14.6, 14.1.19,
14.2.14, 15.2.1.1413.1.12.

ScriptBody : StatementList

1.  Return TopLevelVarScopedDeclarations of StatementList.

Runtime Semantics: ScriptEvaluation

  With argument realm.

Script : ScriptBody~opt~

1.  The code of this Script is strict mode code if the Directive
    Prologue (14.1.1) of its ScriptBody contains a Use Strict
    Directive or if any of the conditions of 10.2.1 apply. If the code
    of this Script is strict mode code, ScriptBody is evaluated in
    the following steps as strict mode code. Otherwise ScriptBody is
    evaluated in the following steps as non-strict mode code.

2.  If ScriptBody is not present, return NormalCompletion(empty).

3.  Let globalEnv be realm.[[globalEnv]].

4.  5.  6.  Let scriptCxt be a new ECMAScript code execution context.

7.  8.  Set the Function of scriptCxt to NULL.

9.  Set the Realm of scriptCxt to realm.

10. Set the VariableEnvironment of scriptCxt to globalEnv.

11. Set the LexicalEnvironment of scriptCxt to globalEnv.

12. Suspend the currently running execution context.

13. Push scriptCxt on to the execution context stack; scriptCxt is
    now the running execution context.

14. Let result be GlobalDeclarationInstantiation(ScriptBody,
    globalEnv).

15. If result.[[type]] is normal, then

    a.  Let result be the result of evaluating ScriptBody.

16. If result.[[type]] is normal and result.[[value]] is empty, then

    a.  Let result be NormalCompletion(UNDEFINED).

17. Suspend scriptCxt and remove it from the execution context stack.

18. Assert: the execution context stack is not empty.

19. Resume the context that is now on the top of the execution context
    stack as the running execution context.

20. 21. Return result.

Runtime Semantics: GlobalDeclarationInstantiation (script, env)

NOTE When an execution context is established for evaluating scripts,
declarations are instantiated in the current global environment. Each
global binding declared in the code is instantiated.

GlobalDeclarationInstantiation is performed as follows using arguments
script and env. script is the ScriptBody for which the execution
context is being established. env is the global lexical environment in
which bindings are to be created.

1.  2.  Let envRec be env’s environment record.

3.  Assert: envRec is a Global Environment Record.

4.  Let lexNames be the LexicallyDeclaredNames of script.

5.  Let varNames be the VarDeclaredNames of script.

6.  For each name in lexNames, do

    a.  If the result of calling envRec’s HasVarDeclaration concrete
        method passing name as the argument is TRUE, throw a
        SYNTAXERROR exception.

    b.  If the result of calling envRec’s HasLexicalDeclaration
        concrete method passing name as the argument is TRUE, throw a
        SYNTAXERROR exception.

    c.  If the result of calling envRec’s HasRestrictedGlobalProperty
        concrete method passing name as the argument is TRUE, throw a
        SYNTAXERROR exception.

7.  For each name in varNames, do

    a.  If the result of calling envRec’s HasLexicalDeclaration
        concrete method passing name as the argument is TRUE, throw a
        SYNTAXERROR exception.

8.  Let varDeclarations be the VarScopedDeclarations of script.

9.  Let functionsToInitialize be an empty List.

10. Let declaredFunctionNames be an empty List.

11. For each d in varDeclarations, in reverse list order do

    a.  If d is neither a VariableDeclaration or a ForBinding,
        then

        i.  Assert: d is either a FunctionDeclaration or a
            GeneratorDeclaration.

        ii. NOTE If there are multiple FunctionDeclarations for the
            same name, the last declaration is used.

        iii. iv. Let fn be the sole element of the BoundNames of d.

        v.  If fn is not an element of declaredFunctionNames, then

        vi. 1.  Let fnDefinable be the result of calling envRec’s
                CanDeclareGlobalFunction concrete method passing fn as
                the argument.

            2.  If fnDefinable is FALSE, throw TYPEERROR exception.

            3.  Append fn to declaredFunctionNames.

            4.  Insert d as the first element of
                functionsToInitialize.

12. Let declaredVarNames be an empty List.

13. For each d in varDeclarations, do

    a.  If d is a VariableDeclaration or a ForBinding, then

        i.  For each String vn in the BoundNames of d, do

            1.  If vn is not an element of declaredFunctionNames,
                then

            2.  a.  Let vnDefinable be the result of calling
                    envRec’s CanDeclareGlobalVar concrete method
                    passing vn as the argument.

                b.  If vnDefinable is FALSE, throw TYPEERROR
                    exception.

                c.  If vn is not an element of declaredVarNames,
                    then

                d.  i.  Append vn to declaredVarNames.

14. NOTE: No abnormal terminations occur after this algorithm step if
    the global object is an ordinary object. However, if the global
    object is a Proxy exotic object it may exhibit behaviours that cause
    abnormal terminations in some of the following steps.

15. 16. Let lexDeclarations be the LexicallyScopedDeclarations of
    script.

17. For each element d in lexDeclarations do

    a.  NOTE Lexically declared names are only instantiated here but not
        initialized.

    b.  c.  For each element dn of the BoundNames of d do

        i.  If IsConstantDeclaration of d is TRUE, then

            1.  Let status be the result of calling envRec’s
                CreateImmutableBinding concrete method passing dn and
                TRUE as the arguments.

        ii. Else,

            1.  Let status be the result of calling envRec’s
                CreateMutableBinding concrete method passing dn and
                FALSE as the arguments.

        iii. ReturnIfAbrupt(status).

18. For each production f in functionsToInitialize, do

    a.  Let fn be the sole element of the BoundNames of f.

    b.  Let fo be the result of performing InstantiateFunctionObject
        for f with argument env.

    c.  Let status be the result of calling envRec’s
        CreateGlobalFunctionBinding concrete method passing fn, fo,
        and FALSE as the arguments.

    d.  ReturnIfAbrupt(status).

19. For each String vn in declaredVarNames, in list order do

    a.  Let status be the result of calling envRec’s
        CreateGlobalVarBinding concrete method passing vn and FALSE as
        the argument.

    b.  ReturnIfAbrupt(status).

20. 21. a.  b.  i.  1.  

        ii. 1.  

        iii. 

    c.  i.  ii. iii. iv. 

22. Return NormalCompletion(empty)

NOTE Early errors specified in 15.1.1 prevent name conflicts between
function/var declarations and let/const/class declarations as well as
redeclaration of let/const/class bindings for declaration contained
within a single Script. However, such conflicts and redeclarations
that span more than one Script are detected as runtime errors during
GlobalDeclarationInstantiation. If any such errors are detected, no
bindings are instantiated for the script. However, if the global object
is defined using Proxy exotic objects then the runtime tests for
conflicting declarations may be unreliable resulting in an abrupt
completion and some global declarations not being instantiated. If this
occurs, the code for the Script is not evaluated.

Unlike explicit var or function declarations, properties that are
directly created on the global object result in global bindings that may
be shadowed by let/const/class declarations.

Runtime Semantics: ScriptEvaluationJob (sourceCodeId)

The job ScriptEvaluationJob with parameter sourceCodeId parses,
validates, and evaluates the Script whose source code is host
accessible using sourceCodeId.

1.  Assert: sourceCodeId is a host provided script source code
    identifier.

2.  Let source be HostGetSource(sourceCodeId).

3.  If source is an abrupt completion, let script be source.

4.  Else,

    a.  Assert: source is a SourceCharacter sequence (see 10).

    b.  c.  Parse source using Script as the goal symbol and analyze
        the parse result for any Early Error conditions. If the parse
        was successful and no early errors were found, let script the
        resulting parse tree. Otherwise, let script be an indication
        of one or more parsing errors and/or early errors. Parsing and
        early error detection may be interweaved in an implementation
        dependent manner. If more than one parse or early error is
        present, the number and ordering of reported errors is
        implementation dependent but at least one error must be
        reported.

5.  If script is an error indication, then

    a.  Report or log the error(s) in an implementation dependent
        manner.

    b.  Let status be NormalCompletion(UNDEFINED).

6.  Else,

    a.  b.  c.  d.  Let realm be the running execution context’s
        Realm.

    e.  Let status be the result of ScriptEvaluation of script with
        argument realm.

7.  NextJob status.

NOTE An implementation may parse a Script and analyze it for Early
Error conditions prior to the execution of the ScriptEvaluationJob for
that Script. However, the reporting of any errors must be deferred
until the ScriptEvaluationJob is actually executed.


Modules

Syntax

Module :

ModuleBody~opt~

ModuleBody :

ModuleItemList

ModuleItemList :

ModuleItem
ModuleItemList ModuleItem

ModuleItem :

ImportDeclaration
ExportDeclaration
StatementListItem

Module Semantics

Static Semantics: Early Errors

ModuleBody : ModuleItemList

-   -   It is a Syntax Error if the LexicallyDeclaredNames of
    ModuleItemList contains any duplicate entries.

-   -   -   It is a Syntax Error if any element of the
    LexicallyDeclaredNames of ModuleItemList also occurs in the
    VarDeclaredNames of ModuleItemList.

-   -   It is a Syntax Error if the ExportedNames of ModuleItemList
    contains any duplicate entries.

-   It is a Syntax Error if any element of the ExportedBindings of
    ModuleItemList do not also occurs in either the VarDeclaredNames
    of ModuleItemList, or the LexicallyDeclaredNames of
    ModuleItemList.

-   It is a Syntax Error if ModuleItemList Contains SUPER.

-   It is a Syntax Error if ModuleItemList Contains NewTarget

-   It is a Syntax Error if ContainsDuplicateLabels of ModuleItemList
    with argument « » is TRUE.

-   It is a Syntax Error if ContainsUndefinedBreakTarget of
    ModuleItemList with argument « » is TRUE.

-   It is a Syntax Error if ContainsUndefinedContineTarget of
    ModuleItemList with arguments « » and « » is TRUE.

NOTE The duplicate ExportedNames rule implies that multiple EXPORT
DEFAULT ExportDeclaration items within a ModuleBody is a Syntax
Error. Additional error conditions relating to conflicting or duplicate
declarations are checked during module linking prior to evaluation of a
Module. If any such errors are detected the Module is not evaluated.

Static Semantics: ContainsDuplicateLabels

  With argument labelSet.

See also: 13.0.1, 13.1.2, 13.5.2, 13.6.1.1, 13.6.2.1, 13.6.3.2,
13.6.4.3, 13.10.2, 13.11.2, 13.12.2, 13.14.2.

ModuleItemList : ModuleItemList ModuleItem

1.  Let hasDuplicates be ContainsDuplicateLabels of ModuleItemList
    with argument labelSet.

2.  If hasDuplicates is TRUE return TRUE.

3.  Return ContainsDuplicateLabels of ModuleItem with argument
    labelSet.

ModuleItem :

ImportDeclaration
ExportDeclaration

1.  Return FALSE.

Static Semantics: ContainsUndefinedBreakTarget

  With argument labelSet.

See also: 13.0.2, 13.1.3, 13.5.3, 13.6.1.2, 13.6.2.2, 13.6.3.3,
13.6.4.4, 13.8.2, 13.10.3, 13.11.3, 13.12.3, 13.14.3.

ModuleItemList : ModuleItemList ModuleItem

1.  Let hasUndefinedLabels be ContainsUndefinedBreakTarget of
    ModuleItemList with argument labelSet.

2.  If hasUndefinedLabels is TRUE, return TRUE.

3.  Return ContainsUndefinedBreakTarget of ModuleItem with argument
    labelSet.

ModuleItem :

ImportDeclaration
ExportDeclaration

1.  Return FALSE.

Static Semantics: ContainsUndefinedContinueTarget

  With arguments iterationSet and labelSet.

See also: 13.0.3, 13.1.4, 13.5.4, 13.6.1.3, 13.6.2.3, 13.6.3.4,
13.6.4.5, 13.7.2, 13.10.4, 13.11.4, 13.12.4,13.14.4.

ModuleItemList : ModuleItemList ModuleItem

1.  Let hasUndefinedLabels be ContainsUndefinedContinueTarget of
    ModuleItemList with arguments iterationSet and « ».

2.  If hasUndefinedLabels is TRUE, return TRUE.

3.  Return ContainsUndefinedContinueTarget of ModuleItem with
    arguments iterationSet and « ».

ModuleItem :

ImportDeclaration
ExportDeclaration

1.  Return FALSE.

1.  

1.  2.  3.  

Static Semantics: ExportedBindings

See also:15.2.3.3.

NOTE ExportedBindings are the locally bound names that are explicitly
associated with a Module’s ExportedNames.

1.  

ModuleItemList : ModuleItemList ModuleItem

1.  Let names be ExportedBindings of ModuleItemList.

2.  Append to names the elements of the ExportedBindings of
    ModuleItem.

3.  Return names.

ModuleItem :

ImportDeclaration
StatementListItem

1.  Return a new empty List.

1.  

1.  2.  3.  

1.  

Static Semantics: ExportedNames

See also: 15.2.3.4.

NOTE ExportedNames are the externally visible names that a Module
explicitly maps to one of its local name bindings.

1.  

ModuleItemList : ModuleItemList ModuleItem

1.  Let names be ExportedNames of ModuleItemList.

2.  Append to names the elements of the ExportedNames of ModuleItem.

3.  Return names.

ModuleItem : ExportDeclaration

1.  Return the ExportedNames of ExportDeclaration.

ModuleItem :

ImportDeclaration
StatementListItem

1.  Return a new empty List.

Static Semantics: ExportEntries

See also: 15.2.3.5.

Module : [empty]

1.  Return a new empty List.

ModuleItemList : ModuleItemList ModuleItem

1.  Let entries be ExportEntries of ModuleItemList.

2.  Append to entries the elements of the ExportEntries of
    ModuleItem.

3.  Return entries.

ModuleItem :

ImportDeclaration
StatementListItem

1.  Return a new empty List.

Static Semantics: ImportEntries

See also:15.2.2.3.

Module : [empty]

1.  Return a new empty List.

ModuleItemList : ModuleItemList ModuleItem

1.  Let entries be ImportEntries of ModuleItemList.

2.  Append to entries the elements of the ImportEntries of
    ModuleItem.

3.  Return entries.

ModuleItem :

ExportDeclaration
StatementListItem

1.  Return a new empty List.

Static Semantics: IsStrict

See also: 14.1.14, 15.1.2.

Module : [empty]

ModuleBody : ModuleItemList

1.  Return TRUE.

1.  2.  

Static Semantics: ModuleRequests

See also: 15.2.2.5, 15.2.3.7.

Module : [empty]

1.  Return a new empty List.

ModuleItemList : ModuleItem

1.  Return ModuleRequests of ModuleItem.

ModuleItemList : ModuleItemList ModuleItem

1.  Let moduleNames be ModuleRequests of ModuleItemList.

2.  Let additionalNames be ModuleRequests of ModuleItem.

3.  Append to moduleNames each element of additionalNames that is
    not already an element of moduleNames.

4.  Return moduleNames.

ModuleItem : StatementListItem

1.  Return a new empty List.

Static Semantics: LexicallyDeclaredNames

See also: 13.1.2, 13.11.2, 13.12.6, 14.1.15, 14.2.10, 15.1.3.

NOTE The LexicallyDeclaredNames of a Module includes the names of all
of its imported bindings.

1.  

ModuleItemList : ModuleItemList ModuleItem

1.  Let names be LexicallyDeclaredNames of ModuleItemList.

2.  Append to names the elements of the LexicallyDeclaredNames of
    ModuleItem.

3.  Return names.

ModuleItem : ImportDeclaration

1.  Return the BoundNames of ImportDeclaration.

ModuleItem : ExportDeclaration

1.  If ExportDeclaration is EXPORT VariableStatement, return a new
    empty List.

2.  Return the BoundNames of ExportDeclaration.

ModuleItem : StatementListItem

1.  Return LexicallyDeclaredNames of StatementListItem.

NOTE At the top level of a Module, function declarations are treated
like lexical declarations rather than like var declarations.

Static Semantics: LexicallyScopedDeclarations

See also: 13.1.6, 13.11.6, 13.12.7, 14.1.16, 14.2.11, 15.1.4, 15.2.3.8.

Module : [empty]

1.  Return a new empty List.

ModuleItemList : ModuleItemList ModuleItem

1.  Let declarations be LexicallyScopedDeclarations of
    ModuleItemList.

2.  Append to declarations the elements of the
    LexicallyScopedDeclarations of ModuleItem.

3.  Return declarations.

ModuleItem : ImportDeclaration

1.  2.  Return a new empty List.

1.  2.  

1.  2.  

Static Semantics: VarDeclaredNames

See also: 13.0.5, 13.1.11, 13.2.2.2, 13.5.5, 13.6.1.4, 13.6.2.4,
13.6.3.5, 13.6.4.7, 13.10.5, 13.11.7, 13.12.12, 13.14.5, 14.1.18,
14.2.13, 15.1.5.

Module : ModuleItemList ModuleItem

1.  Let names be VarDeclaredNames of ModuleItemList.

2.  Append to names the elements of the VarDeclaredNames of
    ModuleItem.

3.  Return names.

ModuleItem : ImportDeclaration

1.  Return an empty List.

ModuleItem : ExportDeclaration

1.  If ExportDeclaration is EXPORT VariableStatement, return
    BoundNames of ExportDeclaration.

2.  Return a new empty List.

Static Semantics: VarScopedDeclarations

See also: 13.0.6, 13.1.12, 13.2.2.3, 13.5.6, 13.6.1.5, 13.6.2.5,
13.6.3.6, 13.6.4.8, 13.10.6, 13.11.8, 13.12.13, 13.14.6, 14.1.19,
14.2.14, 15.1.613.1.12.

Module : [empty]

1.  Return a new empty List.

ModuleItemList : ModuleItemList ModuleItem

1.  Let declarations be VarScopedDeclarations of ModuleItemList.

2.  Append to declarations the elements of the VarScopedDeclarations
    of ModuleItem.

3.  Return declarations.

ModuleItem : ImportDeclaration

1.  Return a new empty List.

ModuleItem : ExportDeclaration

1.  If ExportDeclaration is EXPORT VariableStatement, return
    VarScopedDeclarations of VariableStatement.

2.  Return a new empty List.

Static and Runtime Semantics: Module Records

A Module Record encapsulates static declarative information about the
imports and exports of a single module. Additionally it includes three
fields that are only used at runtime: [[Environment]], [[Namespace]],
and [[Evaluated]].

Each Module Record has the fields defined in Table 37:

Table 37 — Module Record Fields

  --------------------------- ----------------------------- ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  _FIELD NAME_                _VALUE TYPE_                  MEANING
  [[SourceCodeId]]            String                        A host supplied sourceCodeId that uniquely identifies the source code of this module.
  [[ImportedModules]]         List of Module Records        A List of all the modules that are directly imported by the module represented by this record. The List is source code ordered based upon the first explicit import of each module in the list.
  [[ECMAScriptCode]]          a parse result                The result of parsing the source code of this module using Module as the goal symbol.
  [[ImportEntries]]           List of ImportEntry Records   A List of ImportEntry records derived from the code of this module. Module names within the ImportEntry records have been host normalized.
  [[LocalExportEntries]]      List of ExportEntry Records   A List of ExportEntry records derived from the code of this module that correspond to declarations that occur within the module. Module names within the ImportEntry records have been host normalized.
  [[IndirectExportEntries]]   List of ExportEntry Records   A List of ExportEntry records derived from the code of this module that correspond to reexported imports that occur within the module. Module names within the ImportEntry records have been host normalized.
  [[StarExportEntries]]       List of ExportEntry Records   A List of ExportEntry records derived from the code of this module that correspond to export * declarations that occur within the module. Module names within the ImportEntry records have been host normalized.
  [[Environment]]             Lexical Enironment            The Lexical Environment containing the top level bindings for this module. This field is set when the modules is linked.
  [[Namespace]]               Object | UNDEFINED            The Module Namespace Object (26.3) if one has been created for this module. Otherwise UNDEFINED.
  [[Evaluated]]               Boolean                       Initially FALSE, TRUE if evaluation of this module has started. Remains TRUE when evaluation completes, even if it is an abrupt completion.
  --------------------------- ----------------------------- ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

An ImportEntry Record is a Record that digests information about a
single declarative import. Each ImportEntry Record has the fields
defined in Table 38:

 Table 38 — ImportEntry Record Fields

  ------------------- --------------- ------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  _FIELD NAME_        _VALUE TYPE_    MEANING
  [[ModuleRequest]]   String          The module name that was stated in the FromClause of the ImportDeclaration.
                                      
  [[ImportModule]]    Module Record   The Module Record that the FromClause resolved to.
  [[ImportName]]      String          The name under which the desired binding is exported by [[ImportModule]]. The value "*" indicates that the import request is for the target module’s namespace object.
  [[LocalName]]       String          The name that is used to locally access the imported value from within the importing module.
  ------------------- --------------- ------------------------------------------------------------------------------------------------------------------------------------------------------------------------

NOTE The following table gives examples of ImportEntry records fields
used to represent the syntactic import forms:

  ----------------------------- ---------------------------------------- ---------------- ---------------
  _IMPORT STATEMENT_ FORM     [[MODULEREQUEST]]                        [[IMPORTNAME]]   [[LOCALNAME]]
  IMPORT V FROM "MOD";          "MOD"                                    "DEFAULT"        "V"
  IMPORT * AS NS FROM "MOD";    "MOD"                                    "*"              "NS"
  IMPORT {X} FROM "MOD";        "MOD"                                    "X"              "X"
  IMPORT {X AS V} FROM "MOD";   "MOD"                                    "X"              "V"
  IMPORT FROM "MOD";            An ImportEntry Records is not created.
  ----------------------------- ---------------------------------------- ---------------- ---------------

An ExportEntry Record is a Record that digests information about a
single declarative export. Each ExportEntry Record has the fields
defined in Table 39:

Table 39 — ExportEntry Record Fields

  ------------------- --------------- ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  _FIELD NAME_        _VALUE TYPE_    MEANING
  [[ExportName]]      String          The name under which the desired binding is exported by this module.
  [[ModuleRequest]]   String | null   The module name that was stated in the FromClause of the ExportDeclaration. NULL if the ExportDeclaration does not have a FromClause.
                                      
  [[ImportModule]]    Module Record   The Module Record that the FromClause resolved to.
  [[ImportName]]      String | null   The name under which the desired binding is exported by the target module named by [[ModuleRequest]]. NULL if the ExportDeclaration does not have a FromClause. The value "*" indicates that the export request is for all exported bindings.
  [[LocalName]]       String | null   The name that is used to locally access the exported value from within the importing module. NULL if the exported value is not locally accessible from within the module.
  ------------------- --------------- ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

NOTE The following table gives examples of the ExportEntry record fields
used to represent the syntactic export forms:

  -------------------------------- ---------------- ------------------- ---------------- ---------------
  _EXPORT STATEMENT FORM_          [[EXPORTNAME]]   [[MODULEREQUEST]]   [[IMPORTNAME]]   [[LOCALNAME]]
  EXPORT VAR V;                    "V"              NULL                NULL             "V"
  EXPORT DEFAULT FUNCTION F(){};   "DEFAULT"        NULL                NULL             "F"
  EXPORT DEFAULT FUNCTION(){};     "DEFAULT"        NULL                NULL             "*DEFAULT*"
  EXPORT DEFAULT 42;               "DEFAULT"        NULL                NULL             "*DEFAULT*"
  EXPORT {X};                      "X"              NULL                NULL             "X"
  EXPORT {V AS X};                 "X"              NULL                NULL             "V"
  EXPORT {X} FROM "MOD";           "X"              "MOD"               "X"              NULL
  EXPORT {V AS X} FROM "MOD";      "X"              "MOD"               "V"              NULL
  EXPORT * FROM "MOD";             NULL             "MOD"               "*"              NULL
  -------------------------------- ---------------- ------------------- ---------------- ---------------

CreateModule(sourceCodeId) Abstract Operation

The abstract operation CreateModule creates and returns a new Module
Record. The argument sourceCodeId is a host supplied module
identifier.

The following steps are taken:

1.  Let mod be a new Module Record.

2.  Set mod.[[Evaluated]] to FALSE.

3.  Set mod.[[SourceCodeId]] to sourceCodeId .

4.  Set all other fields of mod to UNDEFINED.

5.  Return mod.

ModuleAt( list, sourceCodeId )

The abstract operation ModuleAt retrieves a Module Record from a List of
Module Records. The following steps are taken:

1.  Assert: list is a List whose elements are Module Records.

2.  Assert: sourceCodeId is a String that is a host supplied
    sourceCodeId identifier.

3.  For each element m of list, do

    a.  If SameValue(m.[[SourceCodeId]], sourceCodeId) is TRUE,
        return m.

4.  Return UNDEFINED.

Static Semantics: ParseModuleAndImports ( realm, moduleSrcId, visited )

The abstract operation ParseModuleAndImports with arguments realm,
moduleSrcId, and visited creates the Module Record for the module
source code identified by its moduleSrcId argument. It also creates
module records (if they do not already exist) for modules that are
directly or indirectly imported by the named module.
ParseModuleAndImports performs the following steps:

1.  Assert: Type(moduleSrcId) is String.

2.  Assert: moduleSrcId is a host supplied sourceCodeId .

3.  Let vm be ModuleAt(visited, moduleSrcId).

4.  If vm is not UNDEFINED, return vm.

5.  Let mods be realm.[[modules]].

6.  Let rm be ModuleAt(mods, moduleSrcId).

7.  If rm is not UNDEFINED, return rm.

8.  Let m be CreateModule(moduleSrcId).

9.  Append m to visited.

10. Let src be HostGetSource(moduleSrcId).

11. If src is an abrupt completion or any other implemention defined
    error indication, then

    a.  Let errors be src.

12. Else,

13. a.  Let source be src.[[value]].

    b.  Assert: source is a SourceCharacter sequence (see clause
        10).

    c.  Parse source using Module as the goal symbol and analyze the
        parse result for any Early Error conditions. If the parse was
        successful and no early errors were found, let body be the
        resulting parse tree. Otherwise, let errors be an indication
        of one or more parsing errors and/or early errors. Parsing and
        early error detection may be interweaved in an implementation
        dependent manner. If more than one parse or early error is
        present, the number and ordering of reported errors is
        implementation dependent but at least one error must be
        reported.

14. If errors is an abrupt completion or error indication, then

    a.  Throw a SYNTAXERROR exception. Additional implementation
        dependent errors information may be attached to the exception
        object.

15. Set m.[[ECMAScriptCode]] to body.

16. Let requestedModules be the ModuleRequests of body.

17. Let importedModules be a new empty List.

18. For each String requestedName in requestedModules, do

    a.  Let requestedSrcID be NormalizeModuleName(requestedName,
        moduleSrcId).

    b.  ReturnIfAbrupt(requestedSrcID).

    c.  d.  Let importedModule be ParseModuleAndImports(realm,
        requestedSrcID, visited).

    e.  ReturnIfAbrupt(importedModule).

    f.  g.  If importedModule is not an element of importedModules,
        append importedModule to importedModules.

19. Set m.[[ImportedModules]] to importedModules.

20. Let importEntries be ImportEntries of body.

21. For each record ie in importEntries, do

    a.  Let requestedSrcID be
        NormalizeModuleName(ie.[[ModuleRequest]], moduleSrcId).

    b.  ReturnIfAbrupt(normalizedRequest).

    c.  Assert: importedModules includes a Module Record whose
        [[SourceCodeId]] is requestedSrcID.

    d.  Set ie.[[ImportModule]] to ModuleAt(importedModules,
        requestedSrcID).

22. Set m.[[ImportEntries]] to importEntries.

23. Let indirectExportEntries be a new empty List.

24. Let localExportEntries be a new empty List.

25. Let starExportEntries be a new empty List.

26. Let exportEntries be ExportEntries of body.

27. For each record ee in exportEntries, do

    a.  If ee.[[ModuleRequest]] is NULL, then

        i.  Append ee to localExportEntries.

    b.  Else,

        i.  Let requestedSrcID be
            NormalizeModuleName(ee.[[ModuleRequest]], moduleSrcId).

        ii. ReturnIfAbrupt(requestedSrcID).

        iii. Assert: importedModules includes a Module Record whose
            [[SourceCodeId]] is requestedSrcID.

        iv. Set ee.[[ImportModule]] to ModuleAt(importedModules,
            requestedSrcID).

        v.  If ee.[[ImportName]] is "*", then

            1.  Append ee to starExportEntries.

        vi. Else,

            1.  Append ee to indirectExportEntries.

28. Set m.[[LocalExportEntries]] to localExportEntries.

29. Set m.[[IndirectExportEntries]] to indirectExportEntries.

30. Set m.[[StarExportEntries]] to starExportEntries.

31. Return m.

NOTE An implementation may parse the source code identified by a host
supplied module identifier as a Module and analyze it for Early Error
conditions prior to the evaluation of a ParseModuleAndImports for that
module identifier. However, the reporting of any errors must be deferred
until such a ParseModuleAndImports is actually evaluated.

NormalizeModuleName(unnormalizedName, referrerSrcId )

1.  2.  a.  i.  ii. 

3.  Let moduleSrcId be HostNormalizeModuleName(unnormalizedName,
    referrerSrcId).

4.  5.  If moduleSrcId is UNDEFINED, throw a SYNTAXERROR exception.

6.  Return moduleSrcId.

Static Semantics: GetExportedNames(module, circularitySet)

The abstract operation GetExportedNames with arguments module and
circularitySet returns a list of all names that are either directly or
indirectly exported from a module. It performs the following steps:

1.  Assert: module is a Module Record.

2.  If circularitySet contains module, then

    a.  Assert: We’ve reached the starting point of an import *
        circularity.

    b.  Return a new empty List.

3.  4.  Append module to circularitySet.

5.  Let exportedNames be a new empty List.

6.  For each ExportEntry Record e in module.[[LocalExportEntries]],
    do

    a.  Assert: module provides the leaf binding for this export.

    b.  Append e.[[ExportName]] to exportedNames.

7.  For each ExportEntry Record e in
    module.[[IndirectExportEntries]], do

    a.  Assert: module imports a specific binding for this export.

    b.  Append e.[[ExportName]] to exportedNames.

8.  For each ExportEntry Record e in module.[[StarExportEntries]],
    do

    a.  Let circularitySetCopy be a copy of the circularitySet List.

    b.  Let starNames be GetExportedNames(e_.[[ImportModule]],
        circularitySetCopy_).

    c.  For each element n of starNames, do

        i.  If n is not an element of exportedNames, then

            1.  If SameValue(n, "DEFAULT") is FALSE, then

                a.  Append n to exportedNames.

9.  Return exportedNames.

NOTE GetExportedNames does not filter out or throw an exception for
names that have ambiguous bindings.

Static Semantics: ResolveExport( module, exportName, circularitySet)

The abstract operation ResolveExport with arguments module,
exportName, and circularitySet performs the following steps:

1.  Assert: module is a Module Record.

2.  3.  For each Record r {[[module]], [[exportName]]} in
    circularitySet, do:

    a.  If module and r are the same Module Record and
        SameValue(exportName, r.[[exportName]]) is TRUE, then

        i.  Assert: this is a circular import request.

        ii. Throw a SYNTAXERROR exception.

4.  Append the Record {[[module]]: module,
    [[exportName]]:exportName} to circularitySet.

5.  For each ExportEntry Record e in module.[[LocalExportEntries]],
    do

    a.  If SameValue(exportName, e.[[ExportName]]) is TRUE, then

        i.  Assert: module provides the leaf binding for this export.

        ii. Return Record{[[module]]: module, [[bindingName]]:
            module.[[LocalName]]}.

6.  For each ExportEntry Record e in
    module.[[IndirectExportEntries]], do

    a.  If SameValue(exportName, e.[[ExportName]]) is TRUE, then

        i.  Assert: module imports a specific binding for this export.

        ii. Return ResolveExport(e_.[[ImportModule]],
            e_.[[ImportName]], circularitySet).

7.  If SameValue(exportName, "DEFAULT") is TRUE, then

    a.  Assert: A DEFAULT export was not explicitly defined by this
        module.

    b.  c.  Throw a SYNTAXERROR exception.

    d.  NOTE A DEFAULT export cannot be provided by an EXPORT *.

8.  Let starResolution be NULL.

9.  For each ExportEntry Record e in module.[[StarExportEntries]],
    do

    a.  Let circularitySetCopy be a copy of the circularitySet List.

    b.  Let resolution be ResolveExport(e_.[[ImportModule]],
        exportName_, circularitySetCopy).

    c.  ReturnIfAbrupt(resolution).

    d.  If resolution is not NULL, then

        i.  If starResolution is not NULL, then

            1.  Assert: there is more than one * import that includes
                the requested name.

            2.  Throw a SYNTAXERROR exception.

        ii. Let starResolution be resolution.

10. Return starResolution.

NOTE ResolveExport attempts to resolve an imported binding to the actual
defining module and local binding name. The defining module may be the
module passed as the module parameter or some other module that is
imported by that module. The parameter circularitySet is use to detect
unresolved circular import/export paths. If a pair consisting of
specific module record and exportName is reached that is already in
circularitySet, an import circularity has been encountered. Before
recursively calling ResolveExport, a pair consisting of module and
exportName is added to circularitySet.

If a defining module is found a Record {[[module]], [[bindingName]]}
is returned. This record identifies the resolved binding of the
originally requested export. If no definition was found, NULL is
returned. If the request is found to be circular or ambiguous a
SYNTAXERROR exception is thrown.

Runtime Semantics: ModuleEvaluationJob ( sourceCodeId )

A ModuleEvaluationJob with parameter sourceCodeId is a job that
fetches, parses, validates, and evaluates the Module whose source code
is host accessible using sourceCodeId.

1.  Assert: Type(sourceCodeId) is String.

2.  Assert: sourceCodeId is a host provided module source code
    identifier.

3.  Let realm be the running execution context’s Realm.

4.  Let mods be realm.[[modules]].

5.  Let m be ModuleAt(mods, sourceCodeId).

6.  If m is UNDEFINED, then

    a.  Let newModules be an empty List.

    b.  Let m be ParseModuleAndImports(realm, sourceCodeId,
        newModules).

    c.  If m is an abrupt completion or any other implemention defined
        error indication, then

        i.  Report or log the error(s) in an implementation dependent
            manner.

        ii. NextJob NormalCompletion(UNDEFINED).

    d.  Let linkStatus be LinkModules(_realm, newModules_).

    e.  If linkStatus is an abrupt completion, then

        i.  Report or log a module linking error in an implementation
            dependent manner.

        ii. NextJob NormalCompletion(UNDEFINED).

7.  Let status be the result of ModuleEvaluation(m, realm).

8.  NextJob status.

Runtime Semantics: LinkModules( realm, newModuleSet)

The abstract operation LinkModules with arguments realm and
newModuleSet performs the following steps:

1.  2.  3.  Let modules be a copy of the List realm.[[modules]].

4.  Append to modules the elements of newModuleSet.

5.  For each Module Record m that is an element of newModuleSet, do

    a.  Let status be ModuleDeclarationInstantiation (m, realm,
        modules).

    b.  ReturnIfAbrupt(status).

6.  Assert: all elements of newModuleSet have been instantiated and
    are ready to be evaluated.

7.  Append to realm.[[modules]] the elements of newModuleSet.

8.  Return NormalCompletion(empty).

Runtime Semantics: ModuleDeclarationInstantiation( module, realm, moduleSet )

ModuleDeclarationInstantiation is performed as follows using arguments
module, realm, and moduleSet. module is the Module Record for
which a ModuleEnvironment is being established. realm is the Realm
Record with which the module is associated, and moduleSet is a List of
Module Records from which this module may import bindings.

1.  a.  i.  1.  

        ii. 1.  2.  

    b.  i.  

        i.  ii. iii. iv. 

1.  2.  Let code be module.[[ECMAScriptCode]].

3.  For each ExportEntry Record e in
    module.[[IndirectExportEntries]], do

    a.  Let resolution be ResolveExport(_module, e_.[[ExportName]], «‍
        »).

    b.  ReturnIfAbrupt(resolution).

    c.  If resolution is NULL, throw a SYNTAXERROR exception.

4.  Assert: all named exports from module are resolvable.

5.  6.  Let env be NewModuleEnvironment(realm.[[globalEnv]]).

7.  Let envRec be env’s environment record.

8.  Set module.[[Environment]] to env.

9.  For each ImportEntry Record in in module.[[ImportEntries]], do

    a.  If in.[[ImportName]] is "*", then

        i.  Let importedModule be in.[[ImportModule]].

        ii. iii. Assert: importedModule is not UNDEFINED.

        iv. Let namespace be importedModule.[[Namespace]].

        v.  If namespace is UNDEFINED, then

            1.  Let exportedNames be
                GetExportedNames(importedModule, « »).

            2.  Let namespace be
                ModuleNamespaceCreate(importedModule,
                exportedNames).

        vi. Let status be the result of calling envRec’s
            CreateImmutableBinding concrete method passing
            in.[[LocalName]] and TRUE as the arguments.

        vii. Assert: status is not an abrupt completion.

        viii. Call envRec’s InitializeBinding concrete method passing
            in.[[LocalName]], and namespace as the arguments.

    b.  else,

        i.  Let resolution be ResolveExport(in.[[ImportModule]] _,
            in_.[[ImportName]], « »).

        ii. ReturnIfAbrupt(resolution).

        iii. If resolution is NULL, throw a SYNTAXERROR exception.

        iv. Call envRec’s CreateImportBinding concrete method passing
            in.[[LocalName]], resolution.[[module]],
            resolution.[[bindingName]] as the argument.

10. Let varDeclarations be the VarScopedDeclarations of code.

11. For each element d in varDeclarations do

    a.  For each element dn of the BoundNames of d do

        i.  Let status be the result of calling envRec’s
            CreateMutableBinding concrete method passing dn and FALSE
            as the arguments.

        ii. Assert: status is not an abrupt completion.

        iii. Call envRec’s InitializeBinding concrete method passing
            dn, and UNDEFINED as the arguments.

12. Let lexDeclarations be the LexicallyScopedDeclarations of code.

13. For each element d in lexDeclarations do

    a.  For each element dn of the BoundNames of d do

        i.  If IsConstantDeclaration of d is TRUE, then

            1.  Let status be the result of calling envRec’s
                CreateImmutableBinding concrete method passing dn and
                TRUE as the arguments.

        ii. Else,

            1.  Let status be the result of calling envRec’s
                CreateMutableBinding concrete method passing dn and
                FALSE as the arguments.

        iii. Assert: status is not an abrupt completion.

        iv. If d is a GeneratorDeclaration production or a
            FunctionDeclaration production, then

            1.  Let fo be the result of performing
                InstantiateFunctionObject for d with argument env.

            2.  Call envRec’s InitializeBinding concrete method
                passing dn, and fo as the arguments.

14. Return NormalCompletion(empty).

Runtime Semantics: ModuleEvaluation(module, realm)

1.  If module.[[Evaluated]] is TRUE, return UNDEFINED.

2.  Set module.[[Evaluated]] to TRUE.

3.  For each Module Record required that is an element of
    module.[[ImportedModules]], do

    a.  Assert: realm.[[modules]] includes required.

    b.  c.  Let status be ModuleEvaluation(required, realm).

    d.  ReturnIfAbrupt(status).

4.  Let moduleCxt be a new ECMAScript code execution context.

5.  6.  Set the Function of moduleCxt to NULL.

7.  Set the Realm of moduleCxt to realm.

8.  Assert: module has been linked and declarations in its module
    environment have been instantiated.

9.  Set the VariableEnvironment of moduleCxt to
    module.[[Environment]].

10. Set the LexicalEnvironment of moduleCxt to
    module.[[Environment]].

11. Suspend the currently running execution context.

12. Push moduleCxt on to the execution context stack; moduleCxt is
    now the running execution context.

13. Let result be the result of evaluating
    module.[[ECMAScriptCode]].

14. Suspend moduleCxt and remove it from the execution context stack.

15. Resume the context that is now on the top of the execution context
    stack as the running execution context.

16. Return result.

Runtime Semantics: Evaluation

Module : [empty]

1.  Return NormalCompletion(UNDEFINED).

ModuleItemList : ModuleItemList ModuleItem

1.  Let sl be the result of evaluating ModuleItemList.

2.  ReturnIfAbrupt(sl).

3.  Let s be the result of evaluating ModuleItem.

4.  If s.[[type]] is throw, return s.

5.  6.  If s.[[value]] is empty, let V = sl.[[value]], otherwise
    let V = s.[[value]].

7.  Return Completion{[[type]]: s.[[type]], [[value]]: V,
    [[target]]: s.[[target]]}.

NOTE Steps 5 and 6 of the above algorithm ensure that the value of a
ModuleItemList is the value of the last value producing item in the
ModuleItemList.

ModuleItem : ImportDeclaration

1.  Return NormalCompletion(empty).

Imports

Syntax

ImportDeclaration :

IMPORT ImportClause FromClause ;
IMPORT ModuleSpecifier ;

ImportClause :

ImportedDefaultBinding
NameSpaceImport
NamedImports
ImportedDefaultBinding , NameSpaceImport
ImportedDefaultBinding , NamedImports

ImportedDefaultBinding :

ImportedBinding

NameSpaceImport :

* AS ImportedBinding

NamedImports :

{ }
{ ImportsList }
{ ImportsList , }

FromClause :

FROM ModuleSpecifier

ImportsList :

ImportSpecifier
ImportsList , ImportSpecifier

ImportSpecifier :

ImportedBinding
IdentifierName AS ImportedBinding

ModuleSpecifier :

StringLiteral

ImportedBinding :

BindingIdentifier

Static Semantics: Early Errors

ModuleItem : ImportDeclaration

-   It is a Syntax Error if the BoundNames of ImportDeclaration
    contains any duplicate entries.

Static Semantics: BoundNames

See also: 13.2.1.2, 13.2.2.1, 12.1.2, 13.6.4.2, 14.1.3, 14.2.2, 14.4.2,
14.5.2, 15.2.3.1.

ImportDeclaration : IMPORT ImportClause FromClause ;

1.  Return the BoundNames of ImportClause.

ImportDeclaration : IMPORT ModuleSpecifier ;

1.  Return a new empty List.

ImportClause : ImportedDefaultBinding, NameSpaceImport

1.  Let names be the BoundNames of ImportedDefaultBinding.

2.  Append to names the elements of the BoundNames of
    NameSpaceImport.

3.  Return names.

1.  

ImportClause : ImportedDefaultBinding, NamedImports

1.  Let names be the BoundNames of ImportedDefaultBinding.

2.  Append to names the elements of the BoundNames of NamedImports.

3.  Return names.

NamedImports : { }

1.  Return a new empty List.

ImportsList : ImportsList , ImportSpecifier

1.  Let names be the BoundNames of ImportsList.

2.  Append to names the elements of the BoundNames of
    ImportSpecifier.

3.  Return names.

ImportSpecifier : IdentifierName AS ImportedBinding

1.  Return the BoundNames of ImportedBinding.

Static Semantics: ImportEntries

See also:15.2.1.7.

ImportDeclaration : IMPORT ImportClause FromClause ;

1.  Let module be the sole element of ModuleRequests of FromClause.

2.  Return ImportEntriesForModule of ImportClause with argument
    module.

ImportDeclaration : IMPORT ModuleSpecifier ;

1.  Return a new empty List.

1.  2.  3.  4.  

Static Semantics: ImportEntriesForModule

  With parameter module.

1.  2.  3.  

ImportClause : ImportedDefaultBinding, NameSpaceImport

1.  Let entries be ImportEntriesForModule of ImportedDefaultBinding
    with argument module.

2.  Append to entries the elements of the ImportEntriesForModule of
    NameSpaceImport with argument module.

3.  Return entries.

ImportClause : ImportedDefaultBinding , NamedImports

1.  2.  3.  Let entries be ImportEntriesForModule of
    ImportedDefaultBinding with argument module.

4.  Append to entries the elements of the ImportEntriesForModule of
    NamedImports with argument module.

5.  Return entries.

ImportedDefaultBinding: ImportedBinding

1.  Let localName be the sole element of BoundNames of
    ImportedBinding.

2.  Let defaultEntry be the Record {[[ModuleRequest]]: module,
    [[ImportName]]: "DEFAULT", [[LocalName]]: localName }.

3.  Return a new List containing defaultEntry.

NameSpaceImport : * AS ImportedBinding

1.  Let localName be the StringValue of ImportedBinding.

2.  Let entry be the Record {[[ModuleRequest]]: module,
    [[ImportName]]: "*", [[LocalName]]: localName }.

3.  Return a new List containing entry.

NamedImports : { }

1.  Return a new empty List.

ImportsList : ImportsList , ImportSpecifier

1.  Let specs be the ImportEntriesForModule of ImportsList with
    argument module.

2.  Append to specs the elements of the ImportEntriesForModule of
    ImportSpecifier with argument module.

3.  Return specs.

ImportSpecifier : ImportedBinding

1.  Let localName be the sole element of BoundNames of
    ImportedBinding.

2.  Let entry be the Record {[[ModuleRequest]]: module,
    [[ImportName]]: localName , [[LocalName]]: localName }.

3.  Return a new List containing entry.

ImportSpecifier : IdentifierName AS ImportedBinding

1.  Let importName be the StringValue of IdentifierName.

2.  Let localName be the StringValue of ImportedBinding.

3.  Let entry be the Record {[[ModuleRequest]]: module,
    [[ImportName]]: importName, [[LocalName]]: localName }.

4.  Return a new List containing entry.

Static Semantics: ModuleRequests

See also: 15.2.1.10, 15.2.3.7.

ImportDeclaration : IMPORT ImportClause FromClause ;

1.  Return ModuleRequests of FromClause.

1.  

ModuleSpecifier : StringLiteral

1.  Return a List containing the StringValue of StringLiteral.

Runtime Semantics: Evaluation

See 15.2.1.23.

Exports

Syntax

ExportDeclaration :

EXPORT * FromClause ;
EXPORT ExportClause FromClause ;
EXPORT ExportClause ;
EXPORT VariableStatement
EXPORT Declaration
EXPORT DEFAULT HoistableDeclaration~[Default]~
EXPORT DEFAULT ClassDeclaration~[Default]~
EXPORT DEFAULT [lookahead ∉ { FUNCTION, CLASS }]
AssignmentExpression~[In]~ ;

ExportClause :

{ }
{ ExportsList }
{ ExportsList , }

ExportsList :

ExportSpecifier
ExportsList , ExportSpecifier

ExportSpecifier :

IdentifierName
IdentifierName AS IdentifierName

Static Semantics: Early Errors

ExportDeclaration : EXPORT ExportClause ;

-   For each IdentifierName n in ReferencedBindings of
    ExportClause: It is a Syntax Error if StringValue of n is a
    ReservedWord or if the StringValue of n is one of: "IMPLEMENTS",
    "INTERFACE", "LET", "PACKAGE", "PRIVATE", "PROTECTED", "PUBLIC",
    "STATIC", or "YIELD".

NOTE The above rule means that each ReferencedBindings of ExportClause
is treated as an IdentifierReference.

Static Semantics: BoundNames

See also: 13.2.1.2, 13.2.2.1, 12.1.2, 13.6.4.2,14.1.3, 14.2.2, 14.4.2,
14.5.2, 15.2.2.2.

ExportDeclaration :

EXPORT * FromClause ;
EXPORT ExportClause FromClause ;
EXPORT ExportClause ;

1.  Return a new empty List.

ExportDeclaration : EXPORT VariableStatement

1.  Return the BoundNames of VariableStatement.

ExportDeclaration : EXPORT Declaration

1.  Return the BoundNames of Declaration.

ExportDeclaration : EXPORT DEFAULT HoistableDeclaration

1.  Let declarationNames be the BoundNames of HoistableDeclaration.

2.  If declarationNames does not include the element "*DEFAULT*",
    append "*DEFAULT*"to declarationNames.

3.  Return declarationNames.

ExportDeclaration : EXPORT DEFAULT ClassDeclaration

1.  Let declarationNames be the BoundNames of ClassDeclaration.

2.  If declarationNames does not include the element "*DEFAULT*",
    append "*DEFAULT*"to declarationNames.

3.  Return declarationNames.

4.  

ExportDeclaration : EXPORT DEFAULT AssignmentExpression ;

1.  Return «"*DEFAULT*"».

Static Semantics: ExportedBindings

See also:15.2.1.2.

ExportDeclaration :

EXPORT ExportClause FromClause ;
EXPORT * FromClause ;

1.  Return a new empty List.

ExportDeclaration : EXPORT ExportClause ;

1.  Return the ExportedBindings of ExportClause.

ExportDeclaration : EXPORT VariableStatement

1.  Return the BoundNames of VariableStatement.

ExportDeclaration : EXPORT Declaration

1.  Return the BoundNames of Declaration.

ExportDeclaration : EXPORT DEFAULT HoistableDeclaration

ExportDeclaration : EXPORT DEFAULT ClassDeclaration

ExportDeclaration : EXPORT DEFAULT AssignmentExpression ;

1.  Return the BoundNames of this ExportDeclaration.

ExportClause : { }

1.  Return a new empty List.

ExportsList : ExportsList , ExportSpecifier

1.  Let names be the ExportedBindings of ExportsList.

2.  Append to names the elements of the ExportedBindings of
    ExportSpecifier.

3.  Return names.

ExportSpecifier : IdentifierName

1.  Return a List containing the StringValue of IdentifierName.

ExportSpecifier : IdentifierName AS IdentifierName

1.  Return a List containing the StringValue of the first
    IdentifierName.

Static Semantics: ExportedNames

See also: 15.2.1.6.

ExportDeclaration : EXPORT * FromClause ;

1.  Return a new empty List.

ExportDeclaration :

EXPORT ExportClause FromClause ;
EXPORT ExportClause ;

1.  Return the ExportedNames of ExportClause.

ExportDeclaration : EXPORT VariableStatement

1.  Return the BoundNames of VariableStatement.

ExportDeclaration : EXPORT Declaration

1.  Return the BoundNames of Declaration.

ExportDeclaration : EXPORT DEFAULT HoistableDeclaration

ExportDeclaration : EXPORT DEFAULT ClassDeclaration

ExportDeclaration : EXPORT DEFAULT AssignmentExpression ;

1.  Return «"DEFAULT"».

ExportClause : { }

1.  Return a new empty List.

ExportsList : ExportsList, ExportSpecifier

1.  Let names be the ExportedNames of ExportsList.

2.  Append to names the elements of the ExportedNames of
    ExportSpecifier.

3.  Return names.

ExportSpecifier : IdentifierName

1.  Return a List containing the StringValue of IdentifierName.

ExportSpecifier : IdentifierName AS IdentifierName

1.  Return a List containing the StringValue of the second
    IdentifierName.

Static Semantics: ExportEntries

See also: 15.2.1.7.

ExportDeclaration : EXPORT * FromClause ;

1.  Let module be the sole element of ModuleRequests of FromClause.

2.  Let entry be the Record {[[ModuleRequest]]: module,
    [[ImportName]]: "*", [[LocalName]]: NULL, [[ExportName]]: NULL }.

3.  Return a new List containing entry.

ExportDeclaration : EXPORT ExportClause FromClause ;

1.  Let module be the sole element of ModuleRequests of FromClause.

2.  Return ExportEntriesForModule of ExportClause with argument
    module.

ExportDeclaration : EXPORT ExportClause ;

1.  2.  Return ExportEntriesForModule of ExportClause with argument
    NULL.

ExportDeclaration : EXPORT VariableStatement

1.  Let entries be a new empty List.

2.  Let names be the BoundNames of VariableStatement.

3.  Repeat for each name in names,

4.  a.  Append to entries the Record {[[ModuleRequest]]: NULL,
        [[ImportName]]: NULL, [[LocalName]]: name, [[ExportName]]:
        name }.

5.  Return entries.

ExportDeclaration : EXPORT Declaration

1.  Let entries be a new empty List.

2.  Let names be the BoundNames of Declaration.

3.  Repeat for each name in names,

4.  a.  Append to entries the Record {[[ModuleRequest]]: NULL,
        [[ImportName]]: NULL, [[LocalName]]: name, [[ExportName]]:
        name }.

5.  Return entries.

ExportDeclaration : EXPORT DEFAULT HoistableDeclaration

1.  Let names be BoundNames of HoistableDeclaration.

2.  Let localName be the sole element of names.

3.  Return a new List containing the Record {[[ModuleRequest]]: NULL,
    [[ImportName]]: NULL, [[LocalName]]: localName, [[ExportName]]:
    "DEFAULT"}.

ExportDeclaration : EXPORT DEFAULT ClassDeclaration

1.  Let names be BoundNames of ClassDeclaration.

2.  Let localName be the sole element of names.

3.  Return a new List containing the Record {[[ModuleRequest]]: NULL,
    [[ImportName]]: NULL, [[LocalName]]: localName, [[ExportName]]:
    "DEFAULT"}.

ExportDeclaration : EXPORT DEFAULT AssignmentExpression;

1.  Let entry be the Record {[[ModuleRequest]]: NULL, [[ImportName]]:
    NULL, [[LocalName]]: "*DEFAULT*", [[ExportName]]: "DEFAULT"}.

2.  Return a new List containing entry.

NOTE "*DEFAULT*" is used within this specification as a synthetic name
for anonymous default export values.

Static Semantics: ExportEntriesForModule

  With parameter module.

ExportClause : { }

1.  Return a new empty List.

ExportsList : ExportsList , ExportSpecifier

1.  Let specs be the ExportEntriesForModule of ExportsList with
    argument module.

2.  Append to specs the elements of the ExportEntriesForModule of
    ExportSpecifier with argument module.

3.  Return specs.

1.  2.  

1.  2.  3.  

ExportSpecifier : IdentifierName

1.  Let sourceName be the StringValue of IdentifierName.

2.  If module is NULL, then

    a.  Let localName be sourceName.

    b.  Let importName be NULL.

3.  Else

    a.  Let localName be NULL.

    b.  Let importName be sourceName.

4.  Return a new List containing the Record {[[ModuleRequest]]:
    module, [[ImportName]]: importName, [[LocalName]]: localName,
    [[ExportName]]: sourceName }.

ExportSpecifier : IdentifierName AS IdentifierName

1.  Let sourceName be the StringValue of the first IdentifierName.

2.  Let exportName be the StringValue of the second IdentifierName.

3.  If module is NULL, then

    a.  Let localName be sourceName.

    b.  Let importName be NULL.

4.  Else

    a.  Let localName be NULL.

    b.  Let importName be sourceName.

5.  Return a new List containing the Record {[[ModuleRequest]]:
    module, [[ImportName]]: importName, [[LocalName]]: localName,
    [[ExportName]]: exportName }.

Static Semantics: IsConstantDeclaration

See also: 13.2.1.3, 14.1.9, 14.4.5, 14.5.5.

ExportDeclaration :

EXPORT * FromClause ;
EXPORT ExportClause FromClause ;
EXPORT ExportClause ;
EXPORT DEFAULT AssignmentExpression ;

1.  Return FALSE.

NOTE It is not necessary to treat EXPORT DEFAULT AssignmentExpression
as a constant declaration because there is no syntax that permits
assignment to the internal bound name used to reference a module’s
default object.

1.  

Static Semantics: LexicallyScopedDeclarations

See also: 13.1.6, 13.11.6, 13.12.7, 14.1.16, 14.2.11, 15.1.4, 15.2.1.12.

ExportDeclaration :

EXPORT * FromClause ;

EXPORT ExportClause FromClause ;

EXPORT ExportClause ;

EXPORT VariableStatement

1.  Return a new empty List.

ExportDeclaration : EXPORT Declaration

1.  Return a new List containing DeclarationPart of Declaration.

ExportDeclaration : EXPORT DEFAULT HoistableDeclaration

1.  Return a new List containing DeclarationPart of
    HoistableDeclaration.

ExportDeclaration : EXPORT DEFAULT ClassDeclaration

1.  Return a new List containing ClassDeclaration.

ExportDeclaration : EXPORT DEFAULT AssignmentExpression ;

1.  Return a new List containing this ExportDeclaration.

Static Semantics: ModuleRequests

See also: 15.2.1.10, 15.2.2.5.

ExportDeclaration : EXPORT * FromClause ;

ExportDeclaration : EXPORT ExportClause FromClause ;

1.  Return the ModuleRequests of FromClause.

ExportDeclaration :

EXPORT ExportClause ;
EXPORT VariableStatement
EXPORT Declaration
EXPORT DEFAULT HoistableDeclaration~
~EXPORT DEFAULT ClassDeclaration
EXPORT DEFAULT AssignmentExpression ;

1.  Return a new empty List.

Static Semantics: ReferencedBindings

ExportClause : { }

1.  Return a new empty List.

ExportsList : ExportsList, ExportSpecifier

1.  Let names be the ReferencedBindings of ExportsList.

2.  Append to names the elements of the ReferencedBindings of
    ExportSpecifier.

3.  Return names.

ExportSpecifier : IdentifierName

1.  Return a List containing the IdentifierName.

ExportSpecifier : IdentifierName AS IdentifierName

1.  Return a List containing the first IdentifierName.

  -- -- --
        
        
        
        
        
  -- -- --

1.  2.  3.  4.  5.  6.  

  -- -- --
        
        
        
        
        
        
        
        
        
        
        
        
        
        
  -- -- --

1.  2.  3.  4.  5.  6.  7.  

Runtime Semantics: Evaluation

ExportDeclaration :

EXPORT * FromClause ;
EXPORT ExportClause FromClause ;
EXPORT ExportClause ;

1.  Return NormalCompletion(empty).

ExportDeclaration : EXPORT _VariableStatement _

1.  Return the result of evaluating VariableStatement.

ExportDeclaration : EXPORT Declaration

1.  Return the result of evaluating Declaration.

ExportDeclaration : EXPORT DEFAULT HoistableDeclaration

1.  Return the result of evaluating HoistableDeclaration.

2.  

ExportDeclaration : EXPORT DEFAULT ClassDeclaration

1.  Let value the result of BindingClassDeclarationEvaluation of
    ClassDeclaration.

2.  ReturnIfAbrupt(value).

3.  Let className be the sole element of BoundNames of
    ClassDeclaration.

4.  If className is "*DEFAULT*", then

    a.  Let hasNameProperty be HasOwnProperty(value, "NAME").

    b.  ReturnIfAbrupt(hasNameProperty).

    c.  If hasNameProperty is FALSE, perform hen

    d.  SetFunctionName(value, "DEFAULT").

        i.  

    e.  Let env be the running execution context’s LexicalEnvironment.

    f.  Let status be InitializeBoundName("*DEFAULT*", value,
        env).

    g.  ReturnIfAbrupt(status).

5.  Return NormalCompletion(empty).

ExportDeclaration : EXPORT DEFAULT AssignmentExpression ;

1.  Let rhs be the result of evaluating AssignmentExpression.

2.  Let value be GetValue(rhs).

3.  ReturnIfAbrupt(value).

4.  If IsAnonymousFunctionDefinition(AssignmentExpression) is TRUE,
    then

    a.  Let hasNameProperty be HasOwnProperty(value, "NAME").

    b.  ReturnIfAbrupt(hasNameProperty).

    c.  If hasNameProperty is FALSE, perform

    d.  SetFunctionName(value, "DEFAULT").

        i.  

5.  Let env be the running execution context’s LexicalEnvironment.

6.  Let status be InitializeBoundName("*DEFAULT*", value, env).

7.  Return NormalCompletion(empty).

1.  2.  a.  i.  ii. iii. 

3.  a.  b.  c.  i.  ii. iii. 1.  a.  b.  

            2.  a.  b.  c.  

        iv. 1.  2.  a.  b.  

            3.  

    d.  e.  

4.  a.  b.  

5.  a.  b.  

6.  7.  a.  b.  c.  d.  

1.  2.  3.  a.  i.  ii. 

    b.  i.  ii. 1.  2.  

        iii. 

1.  a.  b.  c.  d.  e.  f.  g.  h.  

1.  2.  3.  4.  a.  b.  c.  i.  ii. 

    d.  

5.  a.  b.  i.  ii. 

    c.  i.  ii. iii. 1.  

6.  7.  

1.  a.  

1.  2.  3.  4.  a.  b.  c.  

5.  6.  7.  a.  b.  c.  

8.  a.  b.  c.  

9.  10. a.  b.  c.  d.  

11. 12. 13. 

1.  2.  3.  a.  b.  c.  

4.  

1.  2.  3.  4.  5.  6.  

1.  2.  3.  4.  5.  a.  b.  i.  

6.  7.  8.  9.  10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 



ERROR HANDLING AND LANGUAGE EXTENSIONS


An implementation must report most errors at the time the relevant
ECMAScript language construct is evaluated. An _early error_ is an error
that can be detected and reported prior to the evaluation of any
construct in the Script containing the error. The presence of an early
error prevents the evaluation of the construct. An implementation must
report early errors in a Script as part of the ScriptEvaluationJob for
that Script. Early errors in a Module are reported at the point when
the Module would be evaluated and the Module is never initialized.
Early errors in EVAL code are reported at the time EVAL is called and
prevent evaluation of the EVAL code. All errors that are not early
errors are runtime errors.

An implementation must report as an early error any occurrence of a
condition that is listed in a “Static Semantics: Early Errors” subclause
of this specification.

An implementation shall not treat other kinds of errors as early errors
even if the compiler can prove that a construct cannot execute without
error under any circumstances. An implementation may issue an early
warning in such a case, but it should not report the error until the
relevant construct is actually executed.

An implementation shall report all errors as specified, except for the
following:

-   Except as restricted in 16.1, an implementation may extend Script
    syntax, Module syntax, and regular expression pattern or flag
    syntax. To permit this, all operations (such as calling EVAL, using
    a regular expression literal, or using the FUNCTION or REGEXP
    constructor) that are allowed to throw SYNTAXERROR are permitted to
    exhibit implementation-defined behaviour instead of throwing
    SYNTAXERROR when they encounter an implementation-defined extension
    to the script syntax or regular expression pattern or flag syntax.

-   Except as restricted in 16.1, an implementation may provide
    additional types, values, objects, properties, and functions beyond
    those described in this specification. This may cause constructs
    (such as looking up a variable in the global scope) to have
    implementation-defined behaviour instead of throwing an error (such
    as REFERENCEERROR).

An implementation may define behaviour other than throwing RANGEERROR
for TOFIXED, TOEXPONENTIAL, and TOPRECISION when the fractionDigits or
precision argument is outside the specified range.


Forbidden Extensions

An implementation must not extend this specification in the following
ways:

-   Other than as defined in this specification, ECMAScript Function
    objects defined using syntactic constructors in strict code must not
    be created with own properties named "CALLER" or "ARGUMENTS" other
    than those that are created by applying the
    AddRestrictedFunctionProperties abstract operation (9.2.8) to the
    function. Such own properties also must not be created for function
    objects defined in non-strict code using an ArrowFunction,
    MethodDefinition, GeneratorDeclaration, GeneratorExpression,
    ClassDeclaration, or ClassExpression. Built-in functions, strict
    mode functions created using the FUNCTION constructor, generator
    functions created using the GENERATOR constructor, and functions
    created using the BIND method also must not be created with such own
    properties.

-   If an implementation extends non-strict functions with an own
    property named "CALLER" the value of that property, as observed
    using [[Get]] or [[GetOwnProperty]], must not be a strict mode
    function object.

-   The behaviour of the following methods must not be extended except
    as specified in ECMA-402: OBJECT.PROTOTYPE.TOLOCALESTRING,
    ARRAY.PROTOTYPE.TOLOCALESTRING, NUMBER.PROTOTYPE.TOLOCALESTRING,
    DATE.PROTOTYPE.TOLOCALEDATESTRING, DATE.PROTOTYPE.TOLOCALESTRING,
    DATE.PROTOTYPE.TOLOCALETIMESTRING, STRING.PROTOTYPE.LOCALECOMPARE.

-   The RegExp pattern grammars in 21.2.1 and B.1.4 must not be extended
    to recognize any of the source characters A-Z or a-z as
    IdentityEscape~[U]~ when the U grammar parameter is present.

-   The Syntactic Grammar must not be extended in any manner that allows
    the token : to immediate follow source code that matches the
    BindingIdentifier nonterminal symbol.

-   When processing strict mode code, the syntax of NumericLiteral
    must not be extended to include LegacyOctalIntegerLiteral as
    defined in B.1.1.

-   TemplateCharacter (11.8.6) must not be extended to include
    LegacyOctalEscapeSequence as defined in B.1.2.

-   When processing strict mode code, the extensions defined in B.3.1,
    B.3.2, B.3.3, and B.3.4 must not be supported.

-   When parsing for the Module goal symbol, the lexical grammar
    extensions defined in B.1.3 must not be supported.



ECMASCRIPT STANDARD BUILT-IN OBJECTS 


There are certain built-in objects available whenever an ECMAScript
Script or Module begins execution. One, the global object, is part
of the lexical environment of the executing program. Others are
accessible as initial properties of the global object or indirectly as
properties of accessible built-in objects.

Unless specified otherwise, a built-in object that is callable as a
function is a Built-in Function object with the characteristics
described in 9.3. Unless specified otherwise, the [[Extensible]]
internal slot of a built-in object initially has the value TRUE. Every
built-in Function object has a [[Realm]] internal slot whose value is
the code Realm for which the object was initially created.

Many built-in objects are functions: they can be invoked with arguments.
Some of them furthermore are constructors: they are functions intended
for use with the NEW operator. For each built-in function, this
specification describes the arguments required by that function and
properties of the Function object. For each built-in constructor, this
specification furthermore describes properties of the prototype object
of that constructor and properties of specific object instances returned
by a NEW expression that invokes that constructor.

Unless otherwise specified in the description of a particular function,
if a built-in function or constructor is given fewer arguments than the
function is specified to require, the function or constructor shall
behave exactly as if it had been given sufficient additional arguments,
each such argument being the UNDEFINED value. Such missing arguments are
considered to be “not present” and may be identified in that manner by
specification algorithms. In the description of a particular function,
the terms “THIS value” and “NewTarget” have the meanings given in 9.3.

Unless otherwise specified in the description of a particular function,
if a built-in function or constructor described is given more arguments
than the function is specified to allow, the extra arguments are
evaluated by the call and then ignored by the function. However, an
implementation may define implementation specific behaviour relating to
such arguments as long as the behaviour is not the throwing of a
TYPEERROR exception that is predicated simply on the presence of an
extra argument.

NOTE Implementations that add additional capabilities to the set of
built-in functions are encouraged to do so by adding new functions
rather than adding new parameters to existing functions.

Unless otherwise specified every built-in function and every built-in
constructor has the Function prototype object, which is the initial
value of the expression FUNCTION.PROTOTYPE (19.2.3), as the value of its
[[Prototype]] internal slot.

Unless otherwise specified every built-in prototype object has the
Object prototype object, which is the initial value of the expression
OBJECT.PROTOTYPE (19.1.3), as the value of its [[Prototype]] internal
slot, except the Object prototype object itself.

Built-in function objects that are not identified as constructors do not
implement the [[Construct]] internal method unless otherwise specified
in the description of a particular function.

Unless otherwise specified, each built-in function defined in clauses 18
through 26 is created as if by calling the CreateBuiltinFunction
abstract operation (9.3.3).

Every built-in Function object, including constructors, has a LENGTH
property whose value is an integer. Unless otherwise specified, this
value is equal to the largest number of named arguments shown in the
subclause headings for the function description, including optional
parameters. However, rest parameters shown using the form “...name” are
not included in the default argument count.

NOTE For example, the Function object that is the initial value of the
slice property of the String prototype object is described under the
subclause heading “String.prototype.slice (start, end)” which shows the
two named arguments start and end; therefore the value of the length
property of that Function object is 2.

Unless otherwise specified, the LENGTH property of a built-in Function
object has the attributes { [[Writable]]: FALSE, [[Enumerable]]: FALSE,
[[Configurable]]: TRUE }.

Every built-in Function object, including constructors, that is not
identified as an anonymous function has a NAME property whose value is a
String. Unless otherwise specified, this value is the name that is given
to the function in this specification. For functions that are specified
as properties of objects, the name value is the property name string
used to access the function. Functions that are specified as get or set
accessor functions of built-in properties have "GET " or "SET "
prepended to the property name string. The value of the NAME property is
explicitly specified for each built-in functions whose property key is a
symbol value.

Unless otherwise specified, the NAME property of a built-in Function
object, if it exists, has the attributes { [[Writable]]: FALSE,
[[Enumerable]]: FALSE, [[Configurable]]: TRUE }.

Every other data property described in clauses 18 through 26 and in
Annex B.2 has the attributes { [[Writable]]: TRUE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE } unless otherwise specified.

Every accessor property described in clauses 18 through 26 and in Annex
B.2 has the attributes {[[Enumerable]]: FALSE, [[Configurable]]: TRUE }
unless otherwise specified. If only a get accessor function is
described, the set accessor function is the default value, UNDEFINED. If
only a set accessor is described the get accessor is the default value,
UNDEFINED.



THE GLOBAL OBJECT 


The unique _global object_ is created before control enters any
execution context.

The global object does not have a [[Construct]] internal method; it is
not possible to use the global object as a constructor with the NEW
operator.

The global object does not have a [[Call]] internal method; it is not
possible to invoke the global object as a function.

The value of the [[Prototype]] internal slot of the global object is
implementation-dependent.

In addition to the properties defined in this specification the global
object may have additional host defined properties. This may include a
property whose value is the global object itself; for example, in the
HTML document object model the WINDOW property of the global object is
the global object itself.


Value Properties of the Global Object

Infinity

The value of INFINITY is +∞ (see 6.1.6). This property has the
attributes { [[Writable]]: FALSE, [[Enumerable]]: FALSE,
[[Configurable]]: FALSE }.

NaN

The value of NAN is NAN (see 6.1.6). This property has the attributes {
[[Writable]]: FALSE, [[Enumerable]]: FALSE, [[Configurable]]: FALSE }.

undefined

The value of UNDEFINED is UNDEFINED (see 6.1.1). This property has the
attributes { [[Writable]]: FALSE, [[Enumerable]]: FALSE,
[[Configurable]]: FALSE }.


Function Properties of the Global Object

eval (x)

The EVAL function is the %eval% intrinsic object. When the EVAL function
is called with one argument x, the following steps are taken:

1.  Let evalRealm be the value of the active function object’s
    [[Realm]] internal slot.

2.  Let strictCaller be FALSE.

3.  Let directEval be FALSE.

4.  Return PerformEval(x, evalRealm, strictCaller, directEval).

Runtime Semantics: PerformEval( x, evalRealm, strictCaller, direct)

The abstract operation PerformEval takes with arguments x,
evalRealm, strictCaller, and direct performs the following steps:

1.  Assert: If direct is FALSE then strictCaller is also FALSE.

2.  If Type(x) is not String, return x.

3.  Let script be the ECMAScript code that is the result of parsing
    x, interpreted as UTF-16 encoded Unicode text as described in
    6.1.4, for the goal symbol Script. If the parse fails or any
    early errors are detected, throw a SYNTAXERROR exception (but see
    also clause 16).

4.  If script Contains ScriptBody is FALSE, return UNDEFINED.

5.  Let body be the ScriptBody of script.

6.  If strictCaller is TRUE, let strictEval be TRUE.

7.  Else, let strictEval be IsStrict of script.

8.  9.  10. Let ctx be the running execution context. If direct is
    TRUE ctx will be the execution context that performed the direct
    EVAL. If direct is FALSE ctx will be the execution context for
    the invocation of the eval function.

11. 12. a.  

13. a.  

14. a.  b.  

15. If direct is TRUE, then

    a.  Let lexEnv be NewDeclarativeEnvironment(ctx’s
        LexicalEnvironment).

    b.  Let varEnv be ctx’s VariableEnvironment.

16. Else,

    a.  Let lexEnv be
        NewDeclarativeEnvironment(evalRealm.[[globalEnv]]).

    b.  Let varEnv be evalRealm.[[globalEnv]].

17. If strictEval is TRUE, then

    a.  b.  c.  Let varEnv be lexEnv.

18. 19. 20. If ctx is not already suspended, Suspend ctx.

21. Let evalCxt be a new ECMAScript code execution context.

22. 23. Set the evalCxt’s Realm to evalRealm.

24. Set the evalCxt’s VariableEnvironment to varEnv.

25. Set the evalCxt’s LexicalEnvironment to lexEnv.

26. 27. Push evalCxt on to the execution context stack; evalCxt is
    now the running execution context.

28. Let result be EvalDeclarationInstantiation(body, varEnv,
    lexEnv, strictEval).

29. If result.[[type]] is normal, then

    a.  Let result be the result of evaluating body.

30. If result.[[type]] is normal and result.[[value]] is empty, then

    a.  Let result be NormalCompletion(UNDEFINED).

31. Suspend evalCxt and remove it from the execution context stack.

32. Resume the context that is now on the top of the execution context
    stack as the running execution context.

33. Return result.

NOTE The eval code cannot instantiate variable or function bindings in
the variable environment of the calling context that invoked the eval if
either the code of the calling context or the eval code is strict code.
Instead such bindings are instantiated in a new VariableEnvironment that
is only accessible to the eval code. Bindings introduced by LET, CONST,
or CLASS declarations are always instantiated in the LexicalEnvironment.

Runtime Semantics: 

-   -   -   

EvalDeclarationInstantiation( body, varEnv, lexEnv, strict)

1.  Let lexNames be the LexicallyDeclaredNames of body.

2.  Let varNames be the VarDeclaredNames of body.

3.  Let varDeclarations be the VarScopedDeclarations of body.

4.  Let lexEnvRec be lexEnv’s environment record.

5.  Let varEnvRec be varEnv’s environment record.

6.  If strict is FALSE, then

    a.  If varEnvRec is a GlobalEnvironmentRecord, then

        i.  For each name in varNames, do

            1.  If the result of calling varEnvRec’s
                HasLexicalDeclaration concrete method passing name as
                the argument is TRUE, throw a SYNTAXERROR exception.

            2.  NOTE: EVAL will not create a global var delaration that
                would be shadowed by a global lexical declaration.

    b.  Else If varEnvRec is a Function Environment Record, then

        i.  Let topLexEnvRec be varEnvRec.[[topLex]].

        ii. For each name in varNames, do

            1.  Assert: lexEnvRec contains the top-level lexical
                declarations for the function.

            2.  If the result of calling topLexEnvRec’s HasBinding
                concrete method passing name as the argument is TRUE,
                throw a SYNTAXERROR exception.

            3.  NOTE: Within a function, a direct EVAL will not create a
                top-level var delaration that would be shadowed by a
                top-level lexical declaration.

7.  Let functionsToInitialize be an empty List.

8.  Let declaredFunctionNames be an empty List.

9.  For each d in varDeclarations, in reverse list order do

    a.  If d is neither a VariableDeclaration or a ForBinding,
        then

        i.  Assert: d is either a FunctionDeclaration or a
            GeneratorDeclaration.

        ii. NOTE If there are multiple FunctionDeclarations for the
            same name, the last declaration is used.

        iii. iv. Let fn be the sole element of the BoundNames of d.

        v.  If fn is not an element of declaredFunctionNames, then

        vi. 1.  If varEnvRec is a GlobalEnvironmentRecord, then

                a.  Let fnDefinable be the result of calling
                    varEnvRec’s CanDeclareGlobalFunction concrete
                    method passing fn as the argument.

                b.  If fnDefinable is FALSE, throw SYNTAXERROR
                    exception.

            2.  Append fn to declaredFunctionNames.

            3.  Insert d as the first element of
                functionsToInitialize.

10. Let declaredVarNames be an empty List.

11. For each d in varDeclarations, do

    a.  If d is a VariableDeclaration or a ForBinding, then

        i.  For each String vn in the BoundNames of d, do

            1.  If vn is not an element of declaredFunctionNames,
                then

            2.  a.  If varEnvRec is a GlobalEnvironmentRecord, then

                    i.  Let vnDefinable be the result of calling
                        varEnvRec’s CanDeclareGlobalVar concrete
                        method passing vn as the argument.

                    ii. If vnDefinable is FALSE, throw SYNTAXERROR
                        exception.

                b.  If vn is not an element of declaredVarNames,
                    then

                c.  i.  Append vn to declaredVarNames.

12. NOTE: No abnormal terminations occur after this algorithm step
    unless varEnvRec is a GlobalEnvironmentRecord and the global
    object is a Proxy exotic object.

13. 14. Let lexDeclarations be the LexicallyScopedDeclarations of
    body.

15. For each element d in lexDeclarations do

    a.  NOTE Lexically declared names are only instantiated here but not
        initialized.

    b.  c.  For each element dn of the BoundNames of d do

        i.  If IsConstantDeclaration of d is TRUE, then

            1.  Let status be the result of calling lexEnvRec’s
                CreateImmutableBinding concrete method passing dn and
                TRUE as the arguments.

        ii. Else,

            1.  Let status be the result of calling lexEnvRec’s
                CreateMutableBinding concrete method passing dn and
                FALSE as the arguments.

        iii. ReturnIfAbrupt(status).

16. For each production f in functionsToInitialize, do

    a.  Let fn be the sole element of the BoundNames of f.

    b.  Let fo be the result of performing InstantiateFunctionObject
        for f with argument lexEnv.

    c.  If varEnvRec is a GlobalEnvironmentRecord, then

        i.  Let status be the result of calling varEnvRec’s
            CreateGlobalFunctionBinding concrete method passing fn,
            fo, and TRUE as the arguments.

        ii. ReturnIfAbrupt(status).

    d.  Else,

        i.  Let status be the result of calling varEnvRec’s
            CreateMutableBinding concrete method passing fn and TRUE
            as the arguments.

        ii. ReturnIfAbrupt(status).

        iii. Call varEnvRec’s InitializeBinding concrete method
            passing fn and fo as arguments.

17. For each String vn in declaredVarNames, in list order do

    a.  If varEnvRec is a GlobalEnvironmentRecord, then

        i.  Let status be the result of calling varEnvRec’s
            CreateGlobalVarBinding concrete method passing vn and TRUE
            as the argument.

    b.  Else,

        i.  Let status be the result of calling varEnvRec’s
            CreateMutableBinding concrete method passing vn and TRUE
            as the arguments.

    c.  ReturnIfAbrupt(status).

    d.  Call varEnvRec’s InitializeBinding concrete method passing
        vn and UNDEFINED as arguments.

18. Return NormalCompletion(empty)

isFinite (number)

Returns FALSE if the argument coerces to NAN, +∞, or −∞, and otherwise
returns TRUE.

1.  Let num be ToNumber(number).

2.  ReturnIfAbrupt(num).

3.  If num is NAN, +∞, or −∞, return FALSE.

4.  Otherwise, return TRUE.

isNaN (number)

Returns TRUE if the argument coerces to NAN, and otherwise returns
FALSE.

1.  Let num be ToNumber(number).

2.  ReturnIfAbrupt(num).

3.  If num is NAN, return TRUE.

4.  Otherwise, return FALSE.

NOTE A reliable way for ECMAScript code to test if a value X is a NAN is
an expression of the form X !== X. The result will be TRUE if and only
if X is a NAN.

parseFloat (string)

The PARSEFLOAT function produces a Number value dictated by
interpretation of the contents of the string argument as a decimal
literal.

When the PARSEFLOAT function is called, the following steps are taken:

1.  Let inputString be ToString(string).

2.  ReturnIfAbrupt(inputString).

3.  Let trimmedString be a substring of inputString consisting of
    the leftmost code unit that is not a StrWhiteSpaceChar and all
    code units to the right of that code unit. (In other words, remove
    leading white space.) If inputString does not contain any such
    code units, let trimmedString be the empty string.

4.  If neither trimmedString nor any prefix of trimmedString
    satisfies the syntax of a StrDecimalLiteral (see 7.1.3.1), return
    NAN.

5.  Let numberString be the longest prefix of trimmedString, which
    might be trimmedString itself, that satisfies the syntax of a
    StrDecimalLiteral.

6.  Let mathFloat be MV of numberString.

7.  If mathFloat=0, then

    a.  If the first code unit of trimmedString is "-", return −0.

    b.  Return +0.

8.  Return the Number value for mathFloat.

NOTE PARSEFLOAT may interpret only a leading portion of string as a
Number value; it ignores any code units that cannot be interpreted as
part of the notation of an decimal literal, and no indication is given
that any such code units were ignored.

parseInt (string , radix)

The PARSEINT function produces an integer value dictated by
interpretation of the contents of the string argument according to the
specified radix. Leading white space in string is ignored. If
radix is UNDEFINED or 0, it is assumed to be 10 except when the number
begins with the code unit pairs 0X or 0X, in which case a radix of 16 is
assumed. If radix is 16, the number may also optionally begin with the
code unit pairs 0X or 0X.

When the PARSEINT function is called, the following steps are taken:

1.  Let inputString be ToString(string).

2.  ReturnIfAbrupt(string).

3.  Let S be a newly created substring of inputString consisting of
    the first code unit that is not a StrWhiteSpaceChar and all code
    unit following that code unit. (In other words, remove leading white
    space.) If inputString does not contain any such code unit, let
    S be the empty string.

4.  Let sign be 1.

5.  If S is not empty and the first code unit of S is U+002D
    (HYPHEN-MINUS), let sign be −1.

6.  If S is not empty and the first code unit of S is U+002B (PLUS
    SIGN) or U+002D (HYPHEN-MINUS), remove the first code unit from S.

7.  Let R = ToInt32(radix).

8.  ReturnIfAbrupt(R).

9.  Let stripPrefix be TRUE.

10. If R ≠ 0, then

    a.  If R < 2 or R > 36, return NAN.

    b.  If R ≠ 16, let stripPrefix be FALSE.

11. Else R = 0,

    a.  Let R = 10.

12. If stripPrefix is TRUE, then

    a.  If the length of S is at least 2 and the first two code units
        of S are either “0X” or “0X”, remove the first two code units
        from S and let R = 16.

13. If S contains any code units that is not a radix-R digit, let
    Z be the substring of S consisting of all code units before the
    first such code unit; otherwise, let Z be S.

14. If Z is empty, return NAN.

15. Let mathInt be the mathematical integer value that is represented
    by Z in radix-R notation, using the letters A-Z and A-Z for
    digits with values 10 through 35. (However, if R is 10 and Z
    contains more than 20 significant digits, every significant digit
    after the 20th may be replaced by a 0 digit, at the option of the
    implementation; and if R is not 2, 4, 8, 10, 16, or 32, then
    mathInt may be an implementation-dependent approximation to the
    mathematical integer value that is represented by Z in radix-R
    notation.)

1.  If mathFloat = 0, then

    a.  If sign = −1, return −0.

    b.  Return +0.

1.  Let number be the Number value for mathInt.

2.  Return sign × number.

NOTE PARSEINT may interpret only a leading portion of string as an
integer value; it ignores any code units that cannot be interpreted as
part of the notation of an integer, and no indication is given that any
such code units were ignored.

URI Handling Functions 

Uniform Resource Identifiers, or URIs, are Strings that identify
resources (e.g. web pages or files) and transport protocols by which to
access them (e.g. HTTP or FTP) on the Internet. The ECMAScript language
itself does not provide any support for using URIs except for functions
that encode and decode URIs as described in 18.2.6.2, 18.2.6.3, 18.2.6.4
and 18.2.6.5

NOTE Many implementations of ECMAScript provide additional functions and
methods that manipulate web pages; these functions are beyond the scope
of this standard.

URI Syntax and Semantics

A URI is composed of a sequence of components separated by component
separators. The general form is:

Scheme : First / Second ; Third ? Fourth

where the italicized names represent components and “:”, “/”, “;” and
“?” are reserved for use as separators. The ENCODEURI and DECODEURI
functions are intended to work with complete URIs; they assume that any
reserved code units in the URI are intended to have special meaning and
so are not encoded. The ENCODEURICOMPONENT and DECODEURICOMPONENT
functions are intended to work with the individual component parts of a
URI; they assume that any reserved code units represent text and so must
be encoded so that they are not interpreted as reserved code units when
the component is part of a complete URI.

The following lexical grammar specifies the form of encoded URIs.

Syntax

uri :::

uriCharacters~opt~

uriCharacters :::

uriCharacter uriCharacters~opt~

uriCharacter :::

uriReserved
uriUnescaped
uriEscaped

uriReserved ::: ONE OF

; / ? : @ & = + $ ,

uriUnescaped :::

uriAlpha
DecimalDigit
uriMark

uriEscaped :::

% HexDigit HexDigit

uriAlpha ::: ONE OF

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

uriMark ::: ONE OF

- _ . ! ~ * ' ( )

NOTE The above syntax is based upon RFC 2396 and does not reflect
changes introduced by the more recent RFC 3986.

RUNTIME SEMANTICS

When a code unit to be included in a URI is not listed above or is not
intended to have the special meaning sometimes given to the reserved
code units, that code unit must be encoded. The code unit is transformed
into its UTF-8 encoding, with surrogate pairs first converted from
UTF-16 to the corresponding code point value. (Note that for code units
in the range [0,127] this results in a single octet with the same
value.) The resulting sequence of octets is then transformed into a
String with each octet represented by an escape sequence of the form
“%xx”.

Runtime Semantics: Encode Abstract Operation

The encoding and escaping process is described by the abstract operation
Encode taking two String arguments string and unescapedSet.

1.  Let strLen be the number of code units in string.

2.  Let R be the empty String.

3.  Let k be 0.

4.  Repeat

    a.  If k equals strLen, return R.

    b.  Let C be the code unit at index k within string.

    c.  If C is in unescapedSet, then

        i.  Let S be a String containing only the code unit C.

        ii. Let R be a new String value computed by concatenating the
            previous value of R and S.

    d.  Else C is not in unescapedSet,

        i.  If the code unit value of C is not less than 0xDC00 and
            not greater than 0xDFFF, throw a URIERROR exception.

        ii. If the code unit value of C is less than 0xD800 or greater
            than 0xDBFF, then

            1.  Let V be the code unit value of C.

        iii. Else,

        iv. 1.  Increase k by 1.

            2.  If k equals strLen, throw a URIERROR exception.

            3.  Let kChar be the code unit value of the code unit at
                index k within string.

            4.  If kChar is less than 0xDC00 or greater than 0xDFFF,
                throw a URIERROR exception.

            5.  Let V be (((the code unit value of C) – 0xD800) ×
                0x400 + (kChar – 0xDC00) + 0x10000).

        v.  Let Octets be the array of octets resulting by applying
            the UTF-8 transformation to V, and let L be the array
            size.

        vi. Let j be 0.

        vii. Repeat, while j < L

            1.  Let jOctet be the value at index j within Octets.

            2.  Let S be a String containing three code units “%XY”
                where XY are two uppercase hexadecimal digits encoding
                the value of jOctet.

            3.  Let R be a new String value computed by concatenating
                the previous value of R and S.

            4.  Increase j by 1.

    e.  Increase k by 1.

Runtime Semantics: Decode Abstract Operation

The unescaping and decoding process is described by the abstract
operation Decode taking two String arguments string and reservedSet.

1.  Let strLen be the number of code units in string.

2.  Let R be the empty String.

3.  Let k be 0.

4.  Repeat

    a.  If k equals strLen, return R.

    b.  Let C be the code unit at index k within string.

    c.  If C is not ‘%’, then

        i.  Let S be the String containing only the code unit C.

    d.  Else C is ‘%’,

        i.  Let start be k.

        ii. If k + 2 is greater than or equal to strLen, throw a
            URIERROR exception.

        iii. If the code units at index (k+1) and (k + 2) within
            string do not represent hexadecimal digits, throw a
            URIERROR exception.

        iv. Let B be the 8-bit value represented by the two
            hexadecimal digits at index (k + 1) and (k + 2).

        v.  Increment k by 2.

        vi. If the most significant bit in B is 0, then

            1.  Let C be the code unit with code unit value B.

            2.  If C is not in reservedSet, then

                a.  Let S be the String containing only the code unit
                    C.

            3.  Else C is in reservedSet,

                a.  Let S be the substring of string from index
                    start to index k inclusive.

        vii. Else the most significant bit in B is 1,

            1.  Let n be the smallest nonnegative integer such that
                (B << n) & 0x80 is equal to 0.

            2.  If n equals 1 or n is greater than 4, throw a
                URIERROR exception.

            3.  Let Octets be an array of 8-bit integers of size n.

            4.  Put B into Octets at index 0.

            5.  If k + (3 × (n – 1)) is greater than or equal to
                strLen, throw a URIERROR exception.

            6.  Let j be 1.

            7.  Repeat, while j < n

                a.  Increment k by 1.

                b.  If the code unit at index k within string is not
                    "%", throw a URIERROR exception.

                c.  If the code units at index (k +1) and (k + 2)
                    within string do not represent hexadecimal digits,
                    throw a URIERROR exception.

                d.  Let B be the 8-bit value represented by the two
                    hexadecimal digits at index (k + 1) and (k + 2).

                e.  If the two most significant bits in B are not 10,
                    throw a URIERROR exception.

                f.  Increment k by 2.

                g.  Put B into Octets at index j.

                h.  Increment j by 1.

            8.  Let V be the value obtained by applying the UTF-8
                transformation to Octets, that is, from an array of
                octets into a 21-bit value. If Octets does not contain
                a valid UTF-8 encoding of a Unicode code point throw a
                URIERROR exception.

            9.  If V < 0x10000, then

                a.  Let C be the code unit V.

                b.  If C is not in reservedSet, then

                    i.  Let S be the String containing only the code
                        unit C.

                c.  Else C is in reservedSet,

                    i.  Let S be the substring of string from index
                        start to index k inclusive.

            10. Else V ≥ 0x10000,

                a.  Let L be (((V – 0x10000) & 0x3FF) + 0xDC00).

                b.  Let H be ((((V – 0x10000) >> 10) & 0x3FF) +
                    0xD800).

                c.  Let S be the String containing the two code units
                    H and L.

    e.  Let R be a new String value computed by concatenating the
        previous value of R and S.

    f.  Increase k by 1.

NOTE This syntax of Uniform Resource Identifiers is based upon RFC 2396
and does not reflect the more recent RFC 3986 which replaces RFC 2396. A
formal description and implementation of UTF-8 is given in RFC 3629.

In UTF-8, characters are encoded using sequences of 1 to 6 octets. The
only octet of a "sequence" of one has the higher-order bit set to 0, the
remaining 7 bits being used to encode the character value. In a sequence
of n octets, n>1, the initial octet has the n higher-order bits set to
1, followed by a bit set to 0. The remaining bits of that octet contain
bits from the value of the character to be encoded. The following octets
all have the higher-order bit set to 1 and the following bit set to 0,
leaving 6 bits in each to contain bits from the character to be encoded.
The possible UTF-8 encodings of ECMAScript characters are specified in
Table 40.

Table 40 — UTF-8 Encodings

  ------------------- --------------------- --------------- --------------- --------------- ---------------
  _CODE UNIT VALUE_   REPRESENTATION      _1^ST^ OCTET_   _2^ND^ OCTET_   _3^RD^ OCTET_   _4^TH^ OCTET_

  0X0000 - 0X007F     00000000 0zzzzzzz   0zzzzzzz                                      

  0X0080 - 0X07FF     00000_yyy yyzzzzzz_   110yyyyy      10zzzzzz                      

  0X0800 - 0XD7FF     _xxxxyyyy yyzzzzzz_   1110xxxx      10yyyyyy      10zzzzzz      

  0XD800 - 0XDBFF     110110_vv vvwwwwxx_   11110uuu      10uuwwww      10xxyyyy      10zzzzzz
                                                                                            
  _followed by_       _followed by_                                                         
                                                                                            
  0XDC00 – 0XDFFF     110111_yy yyzzzzzz_                                                   

  0XD800 - 0XDBFF     causes URIERROR                                                     
                                                                                            
  _not followed by_                                                                         
                                                                                            
  0XDC00 – 0XDFFF                                                                           

  0XDC00 – 0XDFFF     causes URIERROR                                                     

  0XE000 - 0XFFFF     _xxxxyyyy yyzzzzzz_   1110xxxx      10yyyyyy      10zzzzzz      
  ------------------- --------------------- --------------- --------------- --------------- ---------------

Where

uuuuu = vvvv + 1

to account for the addition of 0x10000 as in Surrogates, section 3.7, of
the Unicode Standard.

The range of code unit values 0xD800-0xDFFF is used to encode surrogate
pairs; the above transformation combines a UTF-16 surrogate pair into a
UTF-32 representation and encodes the resulting 21-bit value in UTF-8.
Decoding reconstructs the surrogate pair.

RFC 3629 prohibits the decoding of invalid UTF-8 octet sequences. For
example, the invalid sequence C0 80 must not decode into the code unit
U+0000. Implementations of the Decode algorithm are required to throw a
URIERROR when encountering such invalid sequences.

decodeURI (encodedURI)

The DECODEURI function computes a new version of a URI in which each
escape sequence and UTF-8 encoding of the sort that might be introduced
by the ENCODEURI function is replaced with the UTF-16 encoding of the
code points that it represents. Escape sequences that could not have
been introduced by ENCODEURI are not replaced.

When the DECODEURI function is called with one argument encodedURI,
the following steps are taken:

1.  Let uriString be ToString(encodedURI).

2.  ReturnIfAbrupt(uriString).

3.  Let reservedURISet be a String containing one instance of each
    code unit valid in uriReserved plus “#”.

4.  Return Decode(uriString, reservedURISet).

NOTE The code point “#” is not decoded from escape sequences even though
it is not a reserved URI code point.

 decodeURIComponent (encodedURIComponent)

The DECODEURICOMPONENT function computes a new version of a URI in which
each escape sequence and UTF-8 encoding of the sort that might be
introduced by the ENCODEURICOMPONENT function is replaced with the
UTF-16 encoding of the code points that it represents.

When the DECODEURICOMPONENT function is called with one argument
encodedURIComponent, the following steps are taken:

1.  Let componentString be ToString(encodedURIComponent).

2.  ReturnIfAbrupt(componentString).

3.  Let reservedURIComponentSet be the empty String.

4.  Return Decode(componentString, reservedURIComponentSet)

encodeURI (uri)

The ENCODEURI function computes a new version of an UTF-16 encoded
(6.1.4) URI in which each instance of certain code points is replaced by
one, two, three, or four escape sequences representing the UTF-8
encoding of the code points.

When the ENCODEURI function is called with one argument uri, the
following steps are taken:

1.  Let uriString be ToString(uri).

2.  ReturnIfAbrupt(uriString).

3.  Let unescapedURISet be a String containing one instance of each
    code unit valid in uriReserved and uriUnescaped plus "#".

4.  Return Encode(uriString, unescapedURISet)

NOTE The code point "#" is not encoded to an escape sequence even though
it is not a reserved or unescaped URI code point.

encodeURIComponent (uriComponent)

The ENCODEURICOMPONENT function computes a new version of an UTF-16
encoded (6.1.4) URI in which each instance of certain code points is
replaced by one, two, three, or four escape sequences representing the
UTF-8 encoding of the code point.

When the ENCODEURICOMPONENT function is called with one argument
uriComponent, the following steps are taken:

1.  Let componentString be ToString(uriComponent).

2.  ReturnIfAbrupt(componentString).

3.  Let unescapedURIComponentSet be a String containing one instance
    of each code unit valid in uriUnescaped.

4.  Return Encode(componentString, unescapedURIComponentSet)


Constructor Properties of the Global Object

Array ( . . . )

See 22.1.1.

ArrayBuffer ( . . . )

See 24.1.2.

Boolean ( . . . )

See 19.3.1.

DataView ( . . . )

See 24.2.2.

Date ( . . . )

See 20.3.2.

Error ( . . . )

See 19.5.1.

EvalError ( . . . )

See 19.5.5.1.

Float32Array ( . . . )

See 22.2.4.

Float64Array ( . . . )

See 22.2.4.

Function ( . . . )

See 19.2.1.

Int8Array ( . . . )

See 22.2.4.

Int16Array ( . . . )

See 22.2.4.

Int32Array ( . . . )

See 22.2.4.

Map ( . . . )

See 23.1.1.

Number ( . . . )

See 20.1.1.

Object ( . . . )

See 19.1.1.

Proxy ( . . . )

See 26.2.1.

Promise ( . . . )

See 25.4.3.

RangeError ( . . . )

See 19.5.5.2.

ReferenceError ( . . . )

See 19.5.5.3.

RegExp ( . . . )

See 21.2.3.

Set ( . . . )

See 23.2.1.

String ( . . . )

See 21.1.1.

Symbol ( . . . )

See 19.4.1.

SyntaxError ( . . . )

See 19.5.5.4.

TypeError ( . . . )

See 19.5.5.5.

Uint8Array ( . . . )

See 22.2.4.

Uint8ClampedArray ( . . . )

See 22.2.4.

Uint16Array ( . . . )

See 22.2.4.

Uint32Array ( . . . )

See 22.2.4.

URIError ( . . . )

See 19.5.5.6.

WeakMap ( . . . )

See 23.3.1.

WeakSet ( . . . )

See 23.4.


Other Properties of the Global Object

JSON

See 24.3.

Math

See 20.2.

Reflect

See 26.1.



FUNDAMENTAL OBJECTS 


Object Objects

The Object Constructor

The Object constructor is the %Object% intrinsic object and the initial
value of the OBJECT property of the global object. When called as a
constructor it creates new ordinary object. When OBJECT is called as a
function rather than as a constructor, it performs a type conversion.

The OBJECT constructor is designed to be subclassable. It may be used as
the value of an EXTENDS clause of a class definition.

Object ( [ value ] )

When OBJECT function is called with optional argument value, the
following steps are taken:

1.  If NewTarget is neither UNDEFINED nor the active function, then

    a.  Return OrdinaryCreateFromConstructor(NewTarget,
        "%OBJECTPROTOTYPE%").

2.  If value is NULL, UNDEFINED or not supplied, return
    ObjectCreate(%ObjectPrototype%).

3.  Return ToObject(value).

1.  2.  3.  

Properties of the Object Constructor

The value of the [[Prototype]] internal slot of the Object constructor
is the intrinsic object %FunctionPrototype%.

Besides the LENGTH property (whose value is 1), the Object constructor
has the following properties:

Object.assign ( target, ...sources )

The ASSIGN function is used to copy the values of all of the enumerable
own properties from one or more source objects to a target object.
When the ASSIGN function is called, the following steps are taken:

1.  Let to be ToObject(target).

2.  ReturnIfAbrupt(to).

3.  If only one argument was passed, return to.

4.  Let sources be the List of argument values starting with the
    second argument.

5.  6.  For each element nextSource of sources, in ascending index
    order,

    a.  If nextSource is UNDEFINED or NULL, let keys be an empty
        List.

    b.  Else,

        i.  Let from be ToObject(nextSource).

        ii. ReturnIfAbrupt(from).

        iii. Let keys be the result of calling the [[OwnPropertyKeys]]
            internal method of from.

        iv. ReturnIfAbrupt(keys).

    c.  d.  e.  f.  g.  h.  i.  Repeat for each element nextKey of
        keys in List order,

        i.  ii. iii. iv. v.  vi. vii. Let desc be the result of
            calling the [[GetOwnProperty]] internal method of from
            with argument nextKey.

        viii. ReturnIfAbrupt(desc).

            1.  

        ix. if desc is not UNDEFINED and desc.[[Enumerable]] is
            TRUE, then

            1.  Let propValue be Get(from, nextKey).

            2.  ReturnIfAbrupt(propValue).

            3.  4.  5.  Let status be Put(to, nextKey,
                propValue, TRUE);

            6.  ReturnIfAbrupt(status).

                a.  

        x.  

    j.  

7.  Return to.

The LENGTH property of the ASSIGN method is 2.

Object.create ( O [ , Properties ] )

The CREATE function creates a new object with a specified prototype.
When the CREATE function is called, the following steps are taken:

1.  If Type(O) is not Object or Null throw a TYPEERROR exception.

2.  Let obj be ObjectCreate(O).

3.  If the argument Properties is present and not UNDEFINED, then

    a.  Return the result of the abstract operation
        ObjectDefineProperties(obj, Properties).

4.  Return obj.

Object.defineProperties ( O, Properties )

The DEFINEPROPERTIES function is used to add own properties and/or
update the attributes of existing own properties of an object. When the
DEFINEPROPERTIES function is called, the following steps are taken:

1.  Return the result of the abstract operation ObjectDefineProperties
    with arguments O and Properties.

Runtime Semantics: ObjectDefineProperties Abstract Operation

The abstract operation ObjectDefineProperties with arguments O and
Properties performs the following steps:

1.  If Type(O) is not Object throw a TYPEERROR exception.

2.  Let props be ToObject(Properties).

3.  4.  Let keys be the result of calling the [[OwnPropertyKeys]]
    internal method of props.

5.  ReturnIfAbrupt(keys).

6.  7.  8.  9.  10. Let descriptors be an empty List.

11. Repeat for each element nextKey of keys in List order,

    a.  b.  c.  d.  Let propDesc be the result of calling the
        [[GetOwnProperty]] internal method of props with argument
        nextKey.

    e.  ReturnIfAbrupt(propDesc).

    f.  If propDesc is not UNDEFINED and propDesc.[[Enumerable]] is
        TRUE, then

        i.  Let descObj be the result of Get( props, nextKey).

        ii. ReturnIfAbrupt(descObj).

        iii. Let desc be ToPropertyDescriptor(descObj)t.

        iv. ReturnIfAbrupt(desc).

        v.  Append the pair (a two element List) consisting of nextKey
            and desc to the end of descriptors.

12. 13. For each pair from descriptors in list order,

    a.  Let P be the first element of pair.

    b.  Let desc be the second element of pair.

    c.  Let status be the result of DefinePropertyOrThrow(O_,_P,
        desc).

    d.  ReturnIfAbrupt(status).

        i.  

14. 15. Return O.

Object.defineProperty ( O, P, Attributes )

The DEFINEPROPERTY function is used to add an own property and/or update
the attributes of an existing own property of an object. When the
DEFINEPROPERTY function is called, the following steps are taken:

1.  If Type(O) is not Object throw a TYPEERROR exception.

2.  Let key be ToPropertyKey(P).

3.  ReturnIfAbrupt(key).

4.  Let desc be ToPropertyDescriptor(Attributes).

5.  ReturnIfAbrupt(desc).

6.  Let success be DefinePropertyOrThrow(O,key, desc).

7.  ReturnIfAbrupt(success).

8.  Return O.

Object.freeze ( O )

When the FREEZE function is called, the following steps are taken:

1.  If Type(O) is not Object, return O.

2.  Let status be the result of SetIntegrityLevel( O, "FROZEN").

3.  ReturnIfAbrupt(status).

4.  If status is FALSE, throw a TYPEERROR exception.

5.  Return O.

Object.getOwnPropertyDescriptor ( O, P )

When the GETOWNPROPERTYDESCRIPTOR function is called, the following
steps are taken:

1.  Let obj be ToObject(O).

2.  ReturnIfAbrupt(obj).

3.  Let key be ToPropertyKey(P).

4.  ReturnIfAbrupt(key).

5.  Let desc be the result of calling the [[GetOwnProperty]] internal
    method of obj with argument key.

6.  ReturnIfAbrupt(desc).

7.  Return FromPropertyDescriptor(desc).

8.  

Object.getOwnPropertyNames ( O )

When the GETOWNPROPERTYNAMES function is called, the following steps are
taken:

1.  Return GetOwnPropertyKeys(O, String).

Object.getOwnPropertySymbols ( O )

When the GETOWNPROPERTYSYMBOLS function is called with argument O, the
following steps are taken:

1.  Return GetOwnPropertyKeys(O, Symbol).

GetOwnPropertyKeys ( O, Type ) Abstract Operation

The abstract operation GetOwnPropertyKeys is called with arguments O
and Type where O is an Object and Type is one of the ECMAScript
specification types String or Symbol. The following steps are taken:

1.  Let obj be ToObject(O).

2.  ReturnIfAbrupt(obj).

3.  Let keys be the result of calling the [[OwnPropertyKeys]] internal
    method of obj.

4.  ReturnIfAbrupt(keys).

5.  6.  7.  8.  9.  Let nameList be a new empty List.

10. 11. Repeat for each element nextKey of keys in List order ,

    a.  b.  c.  d.  e.  f.  g.  If Type(nextKey) is Type, then

        i.  Append nextKey as the last element of nameList.

    h.  

12. Return CreateArrayFromList(nameList).

Object.getPrototypeOf ( O )

When the GETPROTOTYPEOF function is called with argument O, the
following steps are taken:

1.  Let obj be ToObject(O).

2.  ReturnIfAbrupt(obj).

3.  Return the result of calling the [[GetPrototypeOf]] internal method
    of obj.

Object.is ( value1, value2 )

When the IS function is called with arguments value1 and value2 the
following steps are taken:

1.  Return SameValue(value1, value2).

Object.isExtensible ( O )

When the ISEXTENSIBLE function is called with argument O, the
following steps are taken:

1.  If Type(O) is not Object, return FALSE.

2.  Return the result of IsExtensible(O).

Object.isFrozen ( O )

When the ISFROZEN function is called with argument O, the following
steps are taken:

1.  If Type(O) is not Object, return TRUE.

2.  Return TestIntegrityLevel(O, "FROZEN").

Object.isSealed ( O )

When the ISSEALED function is called with argument O, the following
steps are taken:

1.  If Type(O) is not Object, return TRUE.

2.  Return TestIntegrityLevel(O, "SEALED").

Object.keys ( O )

When the KEYS function is called with argument O, the following steps
are taken:

1.  Let obj be ToObject(O).

2.  ReturnIfAbrupt(obj).

3.  Let nameList be EnumerableOwnNames(obj).

4.  ReturnIfAbrupt(nameList).

5.  6.  7.  8.  9.  10. 11. 12. 13. a.  b.  c.  d.  e.  f.  g.  i.  ii. iii. 1.  

    h.  

14. Return CreateArrayFromList(nameList).

If an implementation defines a specific order of enumeration for the
for-in statement, the same order must be used for the elements of the
array returned in step 4.

Object.preventExtensions ( O )

When the PREVENTEXTENSIONS function is called, the following steps are
taken:

1.  If Type(O) is not Object, return O.

2.  Let status be the result of calling the [[PreventExtensions]]
    internal method of O.

3.  ReturnIfAbrupt(status).

4.  If status is FALSE, throw a TYPEERROR exception.

5.  Return O.

Object.prototype

The initial value of OBJECT.PROTOTYPE is the intrinsic object
%ObjectPrototype% (19.1.3).

This property has the attributes {[[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Object.seal ( O )

When the SEAL function is called, the following steps are taken:

1.  If Type(O) is not Object, return O.

2.  Let status be the result of SetIntegrityLevel( O, "SEALED").

3.  ReturnIfAbrupt(status).

4.  If status is FALSE, throw a TYPEERROR exception.

5.  Return O.

Object.setPrototypeOf ( O, proto )

When the SETPROTOTYPEOF function is called with arguments O and proto,
the following steps are taken:

1.  Let O be RequireObjectCoercible(O_)_.

2.  ReturnIfAbrupt(O).

3.  If Type(proto) is neither Object nor Null, throw a TYPEERROR
    exception.

4.  If Type(O) is not Object, return O.

5.  Let status be the result of calling the [[SetPrototypeOf]]
    internal method of O with argument proto.

6.  ReturnIfAbrupt(status).

7.  If status is FALSE, throw a TYPEERROR exception.

8.  Return O.

Properties of the Object Prototype Object

The Object prototype object is an ordinary object.

The value of the [[Prototype]] internal slot of the Object prototype
object is NULL and the initial value of the [[Extensible]] internal slot
is TRUE.

Object.prototype.constructor

The initial value of OBJECT.PROTOTYPE.CONSTRUCTOR is the intrinsic
object %Object%.

Object.prototype.hasOwnProperty ( V )

When the HASOWNPROPERTY method is called with argument V, the
following steps are taken:

1.  Let P be ToPropertyKey(V).

2.  ReturnIfAbrupt(P).

3.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

4.  ReturnIfAbrupt(O).

5.  Return the result of HasOwnProperty(O, P).

NOTE The ordering of steps 1 and 3 is chosen to ensure that any
exception that would have been thrown by step 1 in previous editions of
this specification will continue to be thrown even if the THIS value is
UNDEFINED or NULL.

Object.prototype.isPrototypeOf ( V )

When the ISPROTOTYPEOF method is called with argument V, the following
steps are taken:

1.  If Type(V) is not Object, return FALSE.

2.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

3.  ReturnIfAbrupt(O).

4.  Repeat

    a.  Let V be the result of calling the [[GetPrototypeOf]] internal
        method of V with no arguments.

    b.  If V is NULL, return FALSE

    c.  If SameValue(O, V) is TRUE, return TRUE.

NOTE The ordering of steps 1 and 2 preserves the behaviour specified by
previous editions of this specification for the case where V is not an
object and the THIS value is UNDEFINED or null.

Object.prototype.propertyIsEnumerable ( V )

When the PROPERTYISENUMERABLE method is called with argument V, the
following steps are taken:

1.  Let P be ToPropertyKey(V).

2.  ReturnIfAbrupt(P).

3.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

4.  ReturnIfAbrupt(O).

5.  Let desc be the result of calling the [[GetOwnProperty]] internal
    method of O passing P as the argument.

6.  ReturnIfAbrupt(desc).

7.  If desc is UNDEFINED, return FALSE.

8.  Return the value of desc.[[Enumerable]].

NOTE 1 This method does not consider objects in the prototype chain.

NOTE 2 The ordering of steps 1 and 3 is chosen to ensure that any
exception that would have been thrown by step 1 in previous editions of
this specification will continue to be thrown even if the THIS value is
UNDEFINED or NULL.

Object.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] )

When the TOLOCALESTRING method is called, the following steps are taken:

1.  Let O be the THIS value.

2.  Return the result of Invoke(O, "TOSTRING").

The optional parameters to this function are not used but are intended
to correspond to the parameter pattern used by ECMA-402 TOLOCALSTRING
functions. Implementations that do not include ECMA-402 support must not
use those parameter positions for other purposes.

NOTE 1 This function provides a generic TOLOCALESTRING implementation
for objects that have no locale-specific TOSTRING behaviour. ARRAY,
NUMBER, DATE, and TYPED ARRAYS provide their own locale-sensitive
TOLOCALESTRING methods.

NOTE 2 ECMA-402 intentionally does not provide an alternative to this
default implementation.

Object.prototype.toString ( )

When the TOSTRING method is called, the following steps are taken:

1.  If the THIS value is UNDEFINED, return "[OBJECT UNDEFINED]".

2.  If the THIS value is NULL, return "[OBJECT NULL]".

3.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

4.  If IsArray(O) is TRUE, let builtinTag be "ARRAY".

5.  Else, if O is an exotic String object, let builtinTag be
    "STRING".

6.  7.  Else, if O has an [[ParameterMap]] internal slot, let
    builtinTag be "ARGUMENTS".

8.  Else, if O has a [[Call]] internal method, let builtinTag be
    "FUNCTION".

9.  Else, if O has an [[ErrorData]] internal slot, let builtinTag be
    "ERROR".

10. Else, if O has a [[BooleanData]] internal slot, let builtinTag
    be "BOOLEAN".

11. Else, if O has a [[NumberData]] internal slot, let builtinTag be
    "NUMBER".

12. Else, if O has a [[DateValue]] internal slot, let builtinTag be
    "DATE".

13. Else, if O has a [[RegExpMatcher]] internal slot, let builtinTag
    be "REGEXP".

14. Else, let builtinTag be "OBJECT".

15. Let tag be the result of Get (O, @@toStringTag).

16. ReturnIfAbrupt(tag).

17. If Type(tag) is not String, let tag be builtinTag.

18. 19. a.  b.  c.  d.  e.  

20. Return the String that is the result of concatenating "[OBJECT ",
    tag, and "]".

NOTE Historically, this function was occasionally used to access the
string value of the [[Class]] internal slot that was used in previous
editions of this specification as a nominal type tag for various
built-in objects. The above definition of TOSTRING preserves
compatibility for legacy code that uses TOSTRING as a test for those
specific kinds of built-in objects. It does not provide a reliable type
testing mechanism for other kinds of built-in or program defined
objects. In addition, programs can use @@toStringTag in ways that will
invalidate the reliability of such legacy type tests.

Object.prototype.valueOf ( )

When the VALUEOF method is called, the following steps are taken:

1.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

2.  Return O.

Properties of Object Instances

Object instances have no special properties beyond those inherited from
the Object prototype object.


Function Objects

The Function Constructor

The Function constructor is the %Function% intrinsic object and the
initial value of the FUNCTION property of the global object. When
FUNCTION is called as a function rather than as a constructor, it
creates and initializes a new Function object. Thus the function call
FUNCTION(…) is equivalent to the object creation expression NEW
FUNCTION(…) with the same arguments.

The FUNCTION constructor is designed to be subclassable. It may be used
as the value of an EXTENDS clause of a class definition. Subclass
constructors that intend to inherit the specified FUNCTION behaviour
must include a SUPER call to the FUNCTION constructor to create and
initialize a subclass instances with the internal slots necessary for
built-in function behaviour. All ECMAScript syntactic forms for defining
function objects create instances of FUNCTION. There is no syntactic
means to create instances of FUNCTION subclasses except for the built-in
Generator Function subclass.

Function ( p1, p2, … , pn, body )

The last argument specifies the body (executable code) of a function;
any preceding arguments specify formal parameters.

When the FUNCTION function is called with some arguments p1, p2, … ,
pn, body (where n might be 0, that is, there are no “p”
arguments, and where body might also not be provided), the following
steps are taken:

1.  Let C be the active function object.

2.  Let args be the argumentsList that was passed to this function
    by [[Call]] or [[Construct]].

3.  Return CreateDynamicFunction(C, NewTarget, "NORMAL", args).

NOTE It is permissible but not necessary to have one argument for each
formal parameter to be specified. For example, all three of the
following expressions produce the same result:

  new Function("a", "b", "c", "return a+b+c")

  new Function("a, b, c", "return a+b+c")

  new Function("a,b", "c", "return a+b+c")

RuntimeSemantics: CreateDynamicFunction(constructor, newTarget, kind, args)

The abstract operation CreateDynamicFunction is called with arguments
constructor, newTarget, kind, and args. constructor is the
constructor function that is performing this action, newTarget is the
constructor that NEW was initially applied to, kind is either "NORMAL"
or "GENERATOR", and args is a List containing the actual argument
values that were passed to a constructor. The following steps are
taken:

1.  If newTarget is UNDEFINED, let newTarget be constructor.

2.  If kind is "NORMAL", then

    a.  Let goal be the grammar symbol FunctionBody.

    b.  Let parameterGoal be the grammar symbol FormalParameters.

    c.  Let fallbackProto be "%FUNCTIONPROTOTYPE%".

3.  Else,

    a.  Let goal be the grammar symbol GeneratorBody~[Yield]~.

    b.  Let parameterGoal be the grammar symbol
        FormalParameters~[Yield,~ ~GeneratorParameter]~.

    c.  Let fallbackProto be "%GENERATOR%".

4.  Let argCount be the number of elements in args.

5.  Let P be the empty String.

6.  If argCount = 0, let bodyText be the empty String.

7.  Else if argCount = 1, let bodyText be args[0].

8.  Else argCount > 1,

    a.  Let firstArg be args[0].

    b.  Let P be ToString(firstArg).

    c.  ReturnIfAbrupt(P).

    d.  Let k be 1.

    e.  Repeat, while k < argCount-1

        i.  Let nextArg be args_[_k].

        ii. Let nextArgString be ToString(nextArg).

        iii. ReturnIfAbrupt(nextArgString).

        iv. Let P be the result of concatenating the previous value of
            P, the String "," (a comma), and nextArgString.

        v.  Increase k by 1.

    f.  Let bodyText be args_[_k].

9.  Let bodyText be ToString(bodyText).

10. ReturnIfAbrupt(bodyText).

11. Let body be the result of parsing bodyText, interpreted as
    UTF-16 encoded Unicode text as described in 6.1.4, using goal as
    the goal symbol. Throw a SYNTAXERROR exception if the parse fails or
    if any static semantics errors are detected.

12. If bodyText is strict mode code (see 10.2.1) then let strict be
    TRUE, else let strict be FALSE.

13. Let parameters be the result of parsing P, interpreted as UTF-16
    encoded Unicode text as described in 6.1.4, using parameterGoal
    as the goal symbol. Throw a SYNTAXERROR exception if the parse fails
    or if any static semantics errors are detected. If strict is TRUE,
    the Early Error rules for StrictFormalParameters :
    FormalParameters are applied.

14. 15. 16. If any element of the BoundNames of parameters also occurs
    in the LexicallyDeclaredNames of body, throw a SYNTAXERROR
    exception.

17. If body Contains SuperCall is TRUE, throw a SYNTAXERROR
    exception.

18. If parameters Contains SuperCall is TRUE, throw a SYNTAXERROR
    exception.

    a.  

19. 20. If strict is TRUE, then

    a.  If BoundNames of FormalParameters contains any duplicate
        elements

21. Let proto be the result of
    GetPrototypeFromConstructor(newTarget, fallbackProto).

22. ReturnIfAbrupt(proto).

23. 24. Let F be FunctionAllocate(proto, strict, kind).

    i.  

    a.  b.  c.  d.  

25. ReturnIfAbrupt(F).

26. 27. 28. Let realmF be the value of F’s [[Realm]] internal slot.

29. Let scope be realmF.[[globalEnv]].

30. 31. 32. 33. 34. Perfrom FunctionInitialize(F, Normal, strict,
    parameters, body, scope).

35. 36. If NeedsSuperBinding of body is TRUE or NeedsSuperBinding of
    parameters is TRUE, then

    a.  Perform MakeMethod(F, UNDEFINED).

37. If kind is "GENERATOR" , then

    a.  Let prototype be ObjectCreate(%GeneratorPrototype%).

    b.  ReturnIfAbrupt(prototype).

    c.  Perform MakeConstructor(F, TRUE, prototype).

38. Else, perform MakeConstructor(F).

39. 40. 41. 42. Perform

43. SetFunctionName(F, "ANONYMOUS").

    a.  

44. Return F.

NOTE A PROTOTYPE property is automatically created for every function
created using CreateDynamicFunction , to provide for the possibility
that the function will be used as a constructor.

1.  2.  3.  

Properties of the Function Constructor

The FUNCTION constructor is itself a built-in function object. The value
of the [[Prototype]] internal slot of the FUNCTION constructor is
%FunctionPrototype%, the intrinsic Function prototype object (19.2.3).

The value of the [[Extensible]] internal slot of the Function
constructor is TRUE.

1.  2.  3.  

The Function constructor has the following properties:

Function.length

This is a data property with a value of 1. This property has the
attributes { [[Writable]]: FALSE, [[Enumerable]]: FALSE,
[[Configurable]]: TRUE }.

Function.prototype

The value of FUNCTION.PROTOTYPE is %FunctionPrototype%, the intrinsic
Function prototype object (19.2.3).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

1.  2.  3.  4.  5.  

Properties of the Function Prototype Object

The Function prototype object is itself a Built-in Function object. When
invoked, it accepts any arguments and returns UNDEFINED. It does not
have a [[Construct]] internal method so it is not a constructor.

NOTE The Function prototype object is specified to be a function object
to ensure compatibility with ECMAScript code that was created prior to
the 6^th^ Edition of this specification.

The value of the [[Prototype]] internal slot of the Function prototype
object is the intrinsic object %ObjectPrototype% (19.1.3). The initial
value of the [[Extensible]] internal slot of the Function prototype
object is TRUE.

The Function prototype object does not have a PROTOTYPE property.

The value of the LENGTH property of the Function prototype object is 0.

The value of the NAME property of the Function prototype object is the
empty String.

Function.prototype.apply ( thisArg, argArray )

When the APPLY method is called on an object func with arguments
thisArg and argArray, the following steps are taken:

1.  If IsCallable(func) is FALSE, throw a TYPEERROR exception.

2.  If argArray is NULL or UNDEFINED, then

    a.  Return Call(func, thisArg).

3.  Let argList be the result of CreateListFromArrayLike(argArray).

4.  ReturnIfAbrupt(argList ).

5.  Perform PrepareForTailCall().

6.  Return Call(func, thisArg, argList).

The LENGTH property of the APPLY method is 2.

NOTE 1 The thisArg value is passed without modification as the THIS
value. This is a change from Edition 3, where an UNDEFINED or NULL
thisArg is replaced with the global object and ToObject is applied to
all other values and that result is passed as the THIS value. Even
though the thisArg is passed without modification, non-strict mode
functions still perform these transformations upon entry to the
function.

NOTE 2 If func is an arrow function or a bound function then the
thisArg will be ignored by the function [[Call]] in step 6.

Function.prototype.bind ( thisArg , ...args)

When the BIND method is called with argument thisArg and zero or more
args, it performs the following steps:

1.  Let Target be the THIS value.

2.  If IsCallable(Target) is FALSE, throw a TYPEERROR exception.

3.  Let args be a new (possibly empty) List consisting of all of the
    argument values provided after thisArg in order.

4.  Let F be BoundFunctionCreate(Target, thisArg, args).

5.  6.  7.  Let targetHasLength be HasOwnProperty(Target, "LENGTH").

8.  ReturnIfAbrupt(targetHasLength).

9.  If targetHasLength is TRUE, then

    a.  Let targetLen be Get(Target, "LENGTH").

    b.  ReturnIfAbrupt(targetLen).

    c.  If Type(targetLen) is not Number, let L be 0.

    d.  Else,

        i.  Let targetLen be ToInteger(targetLen).

        ii. Let L be the larger of 0 and the result of targetLen
            minus the number of elements of args.

10. Else let L be 0.

11. Let status be DefinePropertyOrThrow(F, "LENGTH",
    PropertyDescriptor {[[Value]]: L, [[Writable]]: FALSE,
    [[Enumerable]]: FALSE, [[Configurable]]: TRUE}).

12. Assert: status is not an abrupt completion.

13. Let targetName be Get(Target, "NAME").

14. ReturnIfAbrupt(targetName).

15. If Type(targetName) is not String, let targetName be the empty
    string.

16. 17. Perform SetFunctionName(F, targetName, "BOUND").

18. 19. 20. Return F.

The LENGTH property of the BIND method is 1.

NOTE 1 Function objects created using FUNCTION.PROTOTYPE.BIND are exotic
objects. They also do not have a PROTOTYPE property.

NOTE 2 If Target is an arrow function or a bound function then the
thisArg passed to this method will not be used by subsequent calls to
F.

Function.prototype.call (thisArg , ...args)

When the CALL method is called on an object func with argument,
thisArg and zero or more args, the following steps are taken:

1.  If IsCallable(func) is FALSE, throw a TYPEERROR exception.

2.  Let argList be an empty List.

3.  If this method was called with more than one argument then in left
    to right order starting with _the second argument_ append each
    argument as the last element of argList

4.  Perform PrepareForTailCall().

5.  Return Call(func, thisArg, argList).

The LENGTH property of the CALL method is 1.

NOTE 1 The thisArg value is passed without modification as the THIS
value. This is a change from Edition 3, where an UNDEFINED or NULL
thisArg is replaced with the global object and ToObject is applied to
all other values and that result is passed as the THIS value. Even
though the thisArg is passed without modification, non-strict mode
functions still perform these transformations upon entry to the
function.

NOTE 2 If func is an arrow function or a bound function then the
thisArg will be ignored by the function [[Call]] in step 5.

Function.prototype.constructor

The initial value of FUNCTION.PROTOTYPE.CONSTRUCTOR is the intrinsic
object %Function%.

1.  2.  3.  a.  b.  c.  i.  ii. 

    d.  

4.  a.  

5.  6.  7.  

Function.prototype.toString ( )

When the TOSTRING method is called on an object func the following
steps are taken:

1.  If func is a Bound Function exotic object, then

    a.  Return an implementation-dependent String source code
        representation of func. The representation must conform to the
        rules below. It is implementation dependent whether the
        representation includes bound function information or
        information about the target function.

2.  If Type(func) is Object and is either a Built-in function object
    or has an [[ECMAScriptCode]] internal slot, then

    a.  Return an implementation-dependent String source code
        representation of func. The representation must conform to the
        rules below.

3.  Throw a TYPEERROR exception.

TOSTRING Representation Requirements:

-   The string representation must have the syntax of a
    FunctionDeclaration FunctionExpression, _GeneratorDeclaration,
    GeneratorExpession, ClassDeclaration_, ClassExpression,
    ArrowFunction, MethodDefinition, or GeneratorMethod depending
    upon the actual characteristics of the object.

-   The use and placement of white space, line terminators, and
    semicolons within the representation String is
    implementation-dependent.

-   -   If the object was defined using ECMAScript code and the returned
    string representation is not in the form of a MethodDefinition or
    GeneratorMethod then the representation must be such that if the
    string is evaluated, using EVAL in a lexical context that is
    equivalent to the lexical context used to create the original
    object, it will result in a new functionally equivalent object. In
    that case the returned source code must not mention freely any
    variables that were not mentioned freely by the original function’s
    source code, even if these “extra” names were originally in scope.

-   If the implementation cannot produce a source code string that meets
    these criteria then it must return a string for which EVAL will
    throw a SYNTAXERROR exception.

1.  

Function.prototype[@@hasInstance] ( V )

When the @@hasInstance method of an object F is called with value V,
the following steps are taken:

1.  Let F be the THIS value.

2.  Return the result of OrdinaryHasInstance(F, V).

The value of the NAME property of this function is
"[SYMBOL.HASINSTANCE]".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

NOTE This is the default implementation of @@HASINSTANCE that most
functions inherit. @@HASINSTANCE is called by the INSTANCEOF operator to
determine whether a value is an instance of a specific constructor. An
expression such as

V INSTANCEOF F

evaluates as

F[@@HASINSTANCE](V)

A constructor function can control which objects are recognized as its
instances by INSTANCEOF by exposing a different @@HASINSTANCE method on
the function.

This property is non-writable and non-configurable to prevent tampering
that could be used to globally expose the target function of a bound
function.

Function Instances

Every function instance is an ECMAScript function object and has the
internal slots listed in Table 28. Function instances created using the
FUNCTION.PROTOTYPE.BIND method (19.2.3.2) have the internal slots listed
in Table 29

The Function instances have the following properties:

length

The value of the LENGTH property is an integer that indicates the
typical number of arguments expected by the function. However, the
language permits the function to be invoked with some other number of
arguments. The behaviour of a function when invoked on a number of
arguments other than the number specified by its LENGTH property depends
on the function. This property has the attributes { [[Writable]]: FALSE,
[[Enumerable]]: FALSE, [[Configurable]]: TRUE }.

name

The value of the NAME property is an String that is descriptive of the
function. The name has no semantic significance but is typically a
variable or property name that is used to refer to the function at its
point of definition in ECMAScript code. This property has the attributes
{ [[Writable]]: FALSE, [[Enumerable]]: FALSE, [[Configurable]]: TRUE }.

Anonymous functions objects that do not have a contextual name
associated with them by this specification do not have a NAME own
property but inherit the NAME property of %FunctionPrototype%.

prototype

Function instances that can be used as a constructor have a PROTOTYPE
property. Whenever such a function instance is created another ordinary
object is also created and is the initial value of the function’s
PROTOTYPE property. Unless otherwise specified, the value of the
prototype property is used to initialize the [[Prototype]] internal slot
of a newly created ordinary object before the Function object is invoked
as a constructor for that newly created object.

This property has the attributes { [[Writable]]: TRUE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

NOTE Function objects created using FUNCTION.PROTOTYPE.BIND, or by
evaluating a MethodDefinition (that are not a GeneratorMethod) or an
ArrowFunction grammar production do not have a PROTOTYPE property.


Boolean Objects

The Boolean Constructor 

The Boolean constructor is the %Boolean% intrinsic object and the
initial value of the BOOLEAN property of the global object. When called
as a constructor it creates and initializes a new Boolean object. When
BOOLEAN is called as a function rather than as a constructor, it
performs a type conversion.

The BOOLEAN constructor is designed to be subclassable. It may be used
as the value of an EXTENDS clause of a class definition. Subclass
constructors that intend to inherit the specified BOOLEAN behaviour must
include a SUPER call to the BOOLEAN constructor to create and initialize
the subclass instance with a [[BooleanData]] internal slot.

 Boolean ( value )

When BOOLEAN is called with argument value, the following steps are
taken:

1.  2.  Let b be ToBoolean(value).

3.  If NewTarget is UNDEFINED, return b.

4.  Let O be OrdinaryCreateFromConstructor(NewTarget,
    "%BOOLEANPROTOTYPE%", «[[BooleanData]]» ).

5.  ReturnIfAbrupt(O).

6.  Set the value of O’s [[BooleanData]] internal slot to b.

7.  Return O.

8.  

1.  2.  3.  

Properties of the Boolean Constructor

The value of the [[Prototype]] internal slot of the Boolean constructor
is the intrinsic object %FunctionPrototype% (19.2.3).

1.  2.  3.  

Besides the LENGTH property (whose value is 1), the Boolean constructor
has the following properties:

Boolean.prototype

The initial value of BOOLEAN.PROTOTYPE is the Boolean prototype object
(19.3.3).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Properties of the Boolean Prototype Object

The Boolean prototype object is an ordinary object. It is not a Boolean
instance and does not have a [[BooleanData]] internal slot.

The value of the [[Prototype]] internal slot of the Boolean prototype
object is the intrinsic object %ObjectPrototype% (19.1.3).

The abstract operation thisBooleanValue(value) performs the following
steps:

1.  If Type(value) is Boolean, return value.

2.  If Type(value) is Object and value has a [[BooleanData]]
    internal slot, then

    a.  Assert: value’s [[BooleanData]] internal slot is a Boolean
        value.

    b.  Return the value of value’s [[BooleanData]] internal slot.

    c.  

3.  Throw a TYPEERROR exception.

Boolean.prototype.constructor

The initial value of BOOLEAN.PROTOTYPE.CONSTRUCTOR is the intrinsic
object %Boolean%.

Boolean.prototype.toString ( )

The following steps are taken:

1.  Let b be thisBooleanValue(THIS value).

2.  ReturnIfAbrupt(b).

3.  If b is TRUE, return "TRUE"; else return "FALSE".

Boolean.prototype.valueOf ( )

The following steps are taken:

1.  Return thisBooleanValue(THIS value).

Properties of Boolean Instances

Boolean instances are ordinary objects that inherit properties from the
Boolean prototype object. Boolean instances have a [[BooleanData]]
internal slot. The [[BooleanData]] internal slot is the Boolean value
represented by this Boolean object.


Symbol Objects

The Symbol Constructor 

The Symbol constructor is the %Symbol% intrinsic object and the initial
value of the SYMBOL property of the global object. When SYMBOL is called
as a function, it returns a new Symbol value.

The SYMBOL constructor is not intended to be used with the NEW operator
or to be subclassed. It may be used as the value of an EXTENDS clause of
a class definition but a SUPER call to the SYMBOL constructor will cause
an exception.

 Symbol ( [ description ] )

When SYMBOL is called with optional argument description, the
following steps are taken:

1.  If NewTarget is not UNDEFINED, throw a TYPEERROR exception.

2.  If description is UNDEFINED, let descString be UNDEFINED.

3.  Else, let descString be ToString(description).

4.  ReturnIfAbrupt(descString).

5.  Return a new unique Symbol value whose [[Description]] value is
    descString.

1.  2.  3.  

Properties of the Symbol Constructor

The value of the [[Prototype]] internal slot of the Symbol constructor
is the intrinsic object %FunctionPrototype% (19.2.3).

1.  

Besides the LENGTH property (whose value is 1), the Symbol constructor
has the following properties:

Symbol.for ( key )

When SYMBOL.FOR is called with argument key it performs the following
steps:

1.  Let stringKey be ToString(key).

2.  ReturnIfAbrupt(stringKey).

3.  For each element e of the GlobalSymbolRegistry List,

    a.  If SameValue(e.[[key]], stringKey) is TRUE, return
        e.[[symbol]].

4.  Assert: GlobalSymbolRegistry does not currently contain an entry for
    stringKey.

5.  Let newSymbol be a new unique Symbol value whose [[Description]]
    is stringKey.

6.  Append the record { [[key]]: stringKey, [[symbol]]: newSymbol }
    to the GlobalSymbolRegistry List.

7.  Return newSymbol.

The GlobalSymbolRegistry is a List that is globally available. It is
shared by all Code Realms. Prior to the evaluation of any ECMAScript
code it is initialized as an empty List. Elements of the
GlobalSymbolRegistry are Records with the structure defined in Table 41.

Table 41 — GlobalSymbolRegistry Record Fields

  -------------- ---------- --------------------------------------------------
  _FIELD NAME_   VALUE    USAGE
  [[key]]        A String   A string key used to globally identify a Symbol.
  [[symbol]]     A Symbol   A symbol that can be retrieved from any Realm.
  -------------- ---------- --------------------------------------------------

Symbol.hasInstance

The initial value of SYMBOL.HASINSTANCE is the well known symbol
@@hasInstance (Table 1).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Symbol.isConcatSpreadable

The initial value of SYMBOL.ISCONCATSPREADABLE is the well known symbol
@@isConcatSpreadable (Table 1).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Symbol.iterator

The initial value of SYMBOL.ITERATOR is the well known symbol @@iterator
(Table 1).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Symbol.keyFor ( sym )

When SYMBOL.KEYFOR is called with argument sym it performs the
following steps:

1.  If Type(sym) is not Symbol, throw a TYPEERROR exception.

2.  For each element e of the GlobalSymbolRegistry List (see
    19.4.2.1),

    a.  If SameValue(e.[[symbol]], sym) is TRUE, return e.[[key]].

3.  Assert: GlobalSymbolRegistry does not currently contain an entry for
    sym.

4.  Return UNDEFINED.

Symbol.match

The initial value of SYMBOL.MATCH is the well known symbol @@match
(Table 1).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Symbol.prototype

The initial value of SYMBOL.PROTOTYPE is the Symbol prototype object
(19.4.3).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Symbol.replace

The initial value of SYMBOL.REPLACEis the well known symbol @@replace
(Table 1).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Symbol.search

The initial value of SYMBOL.SEARCH is the well known symbol @@search
(Table 1).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Symbol.species

The initial value of SYMBOL.SPECIES is the well known symbol @@species
(Table 1).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Symbol.split

The initial value of SYMBOL.SPLIT is the well known symbol @@split
(Table 1).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Symbol.toPrimitive

The initial value of SYMBOL.TOPRIMITIVE is the well known symbol
@@toPrimitive (Table 1).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Symbol.toStringTag

The initial value of SYMBOL.TOSTRINGTAG is the well known symbol
@@toStringTag (Table 1).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Symbol.unscopables

The initial value of SYMBOL.unscopables is the well known symbol
@@unscopables (Table 1).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Properties of the Symbol Prototype Object

The Symbol prototype object is an ordinary object. It is not a Symbol
instance and does not have a [[SymbolData]] internal slot.

The value of the [[Prototype]] internal slot of the Symbol prototype
object is the intrinsic object %ObjectPrototype% (19.1.3).

Symbol.prototype.constructor

The initial value of SYMBOL.PROTOTYPE.CONSTRUCTOR is the intrinsic
object %Symbol%.

Symbol.prototype.toString ( )

The following steps are taken:

1.  Let s be the THIS value.

2.  If Type(s) is Symbol, let sym be s.

3.  Else,

    a.  If Type(s) is not Object, throw a TYPEERROR exception.

    b.  If s does not have a [[SymbolData]] internal slot, throw a
        TYPEERROR exception.

    c.  Let sym be the value of s’s [[SymbolData]] internal slot.

4.  Return SymbolDescriptiveString(sym).

SymbolDescriptiveString ( sym ) Abstract Operation

When the abstract operation SymbolDescriptiveString is called with
argument sym, the following steps are taken:

1.  Assert: Type(sym) is Symbol.

2.  Let desc be the value of sym’s [[Description]] attribute.

3.  If desc is UNDEFINED, let desc be the empty string.

4.  Assert: Type(desc) is String.

5.  Let result be the result of concatenating the strings "SYMBOL(",
    desc, and ")".

6.  Return result.

7.  

Symbol.prototype.valueOf ( )

The following steps are taken:

1.  Let s be the THIS value.

2.  If Type(s) is Symbol, return s.

3.  If Type(s) is not Object, throw a TYPEERROR exception.

4.  If s does not have a [[SymbolData]] internal slot, throw a
    TYPEERROR exception.

5.  Return the value of s’s [[SymbolData]] internal slot.

Symbol.prototype [ @@toPrimitive ] ( hint )

This function is called by ECMAScript language operators to convert an
object to a primitive value. The allowed values for hint are
"DEFAULT", "NUMBER", and "STRING".

When the @@TOPRIMITIVE method is called with argument hint, the
following steps are taken:

1.  Let s be the THIS value.

2.  If Type(s) is Symbol, return s.

3.  If Type(s) is not Object, throw a TYPEERROR exception.

4.  If s does not have a [[SymbolData]] internal slot, throw a
    TYPEERROR exception.

5.  Return the value of s’s [[SymbolData]] internal slot.

1.  

The value of the NAME property of this function is
"[SYMBOL.TOPRIMITIVE]".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Symbol.prototype [ @@toStringTag ]

The initial value of the @@toStringTag property is the string value
"SYMBOL".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Properties of Symbol Instances

Symbol instances are ordinary objects that inherit properties from the
Symbol prototype object. Symbol instances have a [[SymbolData]] internal
slot. The [[SymbolData]] internal slot is the Symbol value represented
by this Symbol object.


Error Objects

Instances of Error objects are thrown as exceptions when runtime errors
occur. The Error objects may also serve as base objects for user-defined
exception classes.

The Error Constructor 

The Error constructor is the %Error% intrinsic object and the initial
value of the ERROR property of the global object. When ERROR is called
as a function rather than as a constructor, it creates and initializes a
new Error object. Thus the function call ERROR(…) is equivalent to the
object creation expression NEW ERROR(…) with the same arguments.

The ERROR constructor is designed to be subclassable. It may be used as
the value of an EXTENDS clause of a class definition. Subclass
constructors that intend to inherit the specified ERROR behaviour must
include a SUPER call to the ERROR constructor to create and initialize
subclass instances with a [[ErrorData]] internal slot.

Error ( message )

When the ERROR function is called with argument message the following
steps are taken:

1.  If NewTarget is UNDEFINED, let newTarget be the active function
    object, else let newTarget be NewTarget.

2.  3.  4.  Let O be OrdinaryCreateFromConstructor(newTarget,
    "%ERRORPROTOTYPE%", «[[ErrorData]]»).

5.  ReturnIfAbrupt(O).

6.  7.  8.  If message is not UNDEFINED, then

    a.  Let msg be ToString(message).

    b.  ReturnIfAbrupt(msg).

    c.  Let msgDesc be the PropertyDescriptor{[[Value]]: msg,
        [[Writable]]: TRUE, [[Enumerable]]: FALSE, [[Configurable]]:
        TRUE}.

    d.  Let status be the result of DefinePropertyOrThrow(O,
        "MESSAGE", msgDesc).

    e.  Assert: status is not an abrupt completion.

9.  Return O.

1.  2.  3.  

Properties of the Error Constructor

The value of the [[Prototype]] internal slot of the Error constructor is
the intrinsic object %FunctionPrototype% (19.2.3).

1.  2.  3.  

Besides the LENGTH property (whose value is 1), the Error constructor
has the following properties:

Error.prototype

The initial value of ERROR.PROTOTYPE is the Error prototype object
(19.5.3).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Properties of the Error Prototype Object

The Error prototype object is an ordinary object. It is not an Error
instance and does not have an [[ErrorData]] internal slot.

The value of the [[Prototype]] internal slot of the Error prototype
object is the intrinsic object %ObjectPrototype% (19.1.3).

Error.prototype.constructor

The initial value of ERROR.PROTOTYPE.CONSTRUCTOR is the intrinsic object
%Error%.

Error.prototype.message

The initial value of ERROR.PROTOTYPE.MESSAGE is the empty String.

Error.prototype.name

The initial value of ERROR.PROTOTYPE.NAME is "ERROR".

Error.prototype.toString ( )

The following steps are taken:

1.  Let O be the THIS value.

2.  If Type(O) is not Object, throw a TYPEERROR exception.

3.  Let name be the result of Get(O, "NAME").

4.  ReturnIfAbrupt(name).

5.  If name is UNDEFINED, let name be "ERROR"; otherwise let name
    be ToString(name).

6.  ReturnIfAbrupt(name).

7.  Let msg be the result of Get(O, "MESSAGE").

8.  ReturnIfAbrupt(msg).

9.  If msg is UNDEFINED, let msg be the empty String; otherwise let
    msg be ToString(msg).

10. ReturnIfAbrupt(msg).

11. If name is the empty String, return msg.

12. If msg is the empty String, return name.

13. Return the result of concatenating name, the code unit U+003A
    (COLON), the code unit U+0020 (SPACE), and msg.

Properties of Error Instances

Error instances are ordinary objects that inherit properties from the
Error prototype object and have an [[ErrorData]] internal slot whose
initial value is UNDEFINED. The only specified uses of [[ErrorData]] is
to flag whether or not an Error instance has been initialized by the
Error constructor and to identify them as Error objects within
OBJECT.PROTOTYPE.TOSTRING.

Native Error Types Used in This Standard

A new instance of one of the NativeError objects below is thrown when
a runtime error is detected. All of these objects share the same
structure, as described in 19.5.6.

EvalError

This exception is not currently used within this specification. This
object remains for compatibility with previous editions of this
specification.

RangeError

Indicates a value that is not in the set or range of allowable values.

ReferenceError

Indicate that an invalid reference value has been detected.

SyntaxError

Indicates that a parsing error has occurred.

TypeError

Indicates the actual type of an operand is different than the expected
type.

URIError

Indicates that one of the global URI handling functions was used in a
way that is incompatible with its definition.

NativeError Object Structure

When an ECMAScript implementation detects a runtime error, it throws a
new instance of one of the NativeError objects defined in 19.5.5. Each
of these objects has the structure described below, differing only in
the name used as the constructor name instead of NativeError, in the
NAME property of the prototype object, and in the implementation-defined
MESSAGE property of the prototype object.

For each error object, references to NativeError in the definition
should be replaced with the appropriate error object name from 19.5.5.

NativeError Constructors

When a NativeError constructor is called as a function rather than as
a constructor, it creates and initializes a new NativeError object. A
call of the object as a function is equivalent to calling it as a
constructor with the same arguments. Thus the function call
NativeError(…) is equivalent to the object creation expression NEW
NativeError(…) with the same arguments.

Each NativeError constructor is designed to be subclassable. It may be
used as the value of an EXTENDS clause of a class definition. Subclass
constructors that intend to inherit the specified NativeError
behaviour must include a SUPER call to the NativeError constructor to
create and initialize subclass instances with a [[ErrorData]] internal
slot.

NativeError ( message )

When a NativeError function is called with argument message the
following steps are taken:

1.  If NewTarget is UNDEFINED, let newTarget be the active function
    object, else let newTarget be NewTarget.

2.  Let O be

3.  4.  OrdinaryCreateFromConstructor(newTarget,
    "%NATIVEERRORPROTOTYPE%", «[[ErrorData]]» ).

5.  ReturnIfAbrupt(O).

6.  7.  8.  If message is not UNDEFINED, then

    a.  Let msg be ToString(message).

    b.  Let msgDesc be the PropertyDescriptor{[[Value]]: msg,
        [[Writable]]: TRUE, [[Enumerable]]: FALSE, [[Configurable]]:
        TRUE}.

    c.  Let status be the result of DefinePropertyOrThrow(O,
        "MESSAGE", msgDesc).

    d.  Assert: status is not an abrupt completion.

9.  Return O.

The actual value of the string passed in step 2 is either
"%EVALERRORPROTOTYPE%", "%RANGEERRORPROTOTYPE%",
"%REFERENCEERRORPROTOTYPE%", "%SYNTAXERRORPROTOTYPE%",
"%TYPEERRORPROTOTYPE%", or "%URIERRORPROTOTYPE%" corresponding to which
NativeError constructor is being defined.

1.  2.  3.  

Properties of the NativeError Constructors

The value of the [[Prototype]] internal slot of a NativeError
constructor is the intrinsic object %Error% (19.5.1).

1.  2.  3.  

Besides the LENGTH property (whose value is 1), each NativeError
constructor has the following properties:

NativeError.prototype

The initial value of NATIVEERROR.PROTOTYPE is a NativeError
prototype object (19.5.6.3). Each NativeError constructor has a
separate prototype object.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Properties of the NativeError Prototype Objects

Each NativeError prototype object is an ordinary object. It is not an
Error instance and does not have an [[ErrorData]] internal slot.

The value of the [[Prototype]] internal slot of each NativeError
prototype object is the intrinsic object %ErrorPrototype% (19.5.3).

NativeError.prototype.constructor

The initial value of the CONSTRUCTOR property of the prototype for a
given NativeError constructor is the corresponding intrinsic object
%NativeError% (19.5.6.1).

 NativeError.prototype.message

The initial value of the MESSAGE property of the prototype for a given
NativeError constructor is the empty String.

 NativeError.prototype.name

The initial value of the NAME property of the prototype for a given
NativeError constructor is a string consisting of the name of the
constructor (the name used instead of NativeError).

Properties of NativeError Instances

NativeError instances are ordinary objects that inherit properties
from their NativeError prototype object and have an [[ErrorData]]
internal slot whose initial value is UNDEFINED. The only specified use
of [[ErrorData]] is to flag whether or not an Error or NativeError
instance has been initialized by its constructor.



NUMBERS AND DATES 


Number Objects

The Number Constructor 

The Number constructor is the %Number% intrinsic object and the initial
value of the NUMBER property of the global object. When called as a
constructor, it creates and initializes a new Number object. When NUMBER
is called as a function rather than as a constructor, it performs a type
conversion.

The NUMBER constructor is designed to be subclassable. It may be used as
the value of an EXTENDS clause of a class definition. Subclass
constructors that intend to inherit the specified NUMBER behaviour must
include a SUPER call to the NUMBER constructor to create and initialize
the subclass instance with a [[NumberData]] internal slot.

Number ( [ value ] )

When NUMBER is called with argument number, the following steps are
taken:

1.  2.  If no arguments were passed to this function invocation, let n
    be +0.

3.  Else, let n be ToNumber(value).

4.  ReturnIfAbrupt(n).

5.  If NewTarget is UNDEFINED, return n.

6.  Let O be OrdinaryCreateFromConstructor(NewTarget,
    "%NUMBERPROTOTYPE%", «[[NumberData]]» ).

7.  ReturnIfAbrupt(O).

8.  Set the value of O’s [[NumberData]] internal slot to n.

9.  Return O.

10. 

1.  2.  3.  

Properties of the Number Constructor

The value of the [[Prototype]] internal slot of the Number constructor
is the intrinsic object %FunctionPrototype% (19.2.3).

1.  2.  3.  

Besides the LENGTH property (whose value is 1), the Number constructor
has the following properties:

Number.EPSILON

The value of Number.EPSILON is the difference between 1 and the smallest
value greater than 1 that is representable as a Number value, which is
approximately 2.2204460492503130808472633361816 x 10‍^−‍16^.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Number.isFinite ( number )

When the NUMBER.ISFINITE is called with one argument number, the
following steps are taken:

1.  If Type(number) is not Number, return FALSE.

2.  If number is NAN, +∞, or −∞, return FALSE.

3.  Otherwise, return TRUE.

Number.isInteger ( number )

When the NUMBER.ISINTEGER is called with one argument number, the
following steps are taken:

1.  If Type(number) is not Number, return FALSE.

2.  If number is NAN, +∞, or −∞, return FALSE.

3.  Let integer be ToInteger(number).

4.  If integer is not equal to number, return FALSE.

5.  Otherwise, return TRUE.

Number.isNaN ( number )

When the NUMBER.ISNAN is called with one argument number, the
following steps are taken:

1.  If Type(number) is not Number, return FALSE.

2.  If number is NAN, return TRUE.

3.  Otherwise, return FALSE.

NOTE This function differs from the global isNaN function (18.2.3) is
that it does not convert its argument to a Number before determining
whether it is NaN.

Number.isSafeInteger ( number )

When the NUMBER.ISSAFEINTEGER is called with one argument number, the
following steps are taken:

1.  If Type(number) is not Number, return FALSE.

2.  If number is NAN, +∞, or −∞, return FALSE.

3.  Let integer be ToInteger(number).

4.  If integer is not equal to number, return FALSE.

5.  If abs(integer) ≤ 2^53^−1, return TRUE.

6.  Otherwise, return FALSE.

Number.MAXSAFEINTEGER

NOTE The value of NUMBER.MAXSAFEINTEGER is the largest integer n such
that n and n + 1 are both exactly representable as a Number value.

The value of Number.MAXSAFEINTEGER is 9007199254740991 (2^53^−1).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

 Number.MAX_VALUE

The value of NUMBER.MAX_VALUE is the largest positive finite value of
the Number type, which is approximately 1.7976931348623157 × 10^308^.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Number.MINSAFEINTEGER

NOTE The value of NUMBER.MINSAFEINTEGER is the smallest integer n such
that n and n − 1 are both exactly representable as a Number value.

The value of Number.MINSAFEINTEGER is −9007199254740991 (−(2^53^−1)).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Number.MIN_VALUE

The value of NUMBER.MIN_VALUE is the smallest positive value of the
Number type, which is approximately 5 × 10^−324^.

In the IEEE-764 double precision binary representation, the smallest
possible value is a denormalized number. If an implementation does not
support denormalized values, the value of NUMBER.MIN_VALUE must be the
smallest non-zero positive value that can actually be represented by the
implementation.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Number.NaN

The value of NUMBER.NAN is NAN.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Number.NEGATIVE_INFINITY

The value of Number.NEGATIVE_INFINITY is −∞.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Number.parseFloat ( string )

The value of the NUMBER.PARSEFLOAT data property is the same built-in
function object that is the value of the PARSEFLOAT property of the
global object defined in 18.2.4.

Number.parseInt ( string, radix )

The value of the NUMBER.PARSEINT data property is the same built-in
function object that is the value of the PARSEINT property of the global
object defined in 18.2.5.

Number.POSITIVE_INFINITY

The value of Number.POSITIVE_INFINITY is +∞.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Number.prototype

The initial value of NUMBER.PROTOTYPE is the intrinsic object
%NumberPrototype% (20.1.3).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Properties of the Number Prototype Object

The Number prototype object is an ordinary object. It is not a Number
instance and does not have a [[NumberData]] internal slot.

The value of the [[Prototype]] internal slot of the Number prototype
object is the intrinsic object %ObjectPrototype% (19.1.3).

Unless explicitly stated otherwise, the methods of the Number prototype
object defined below are not generic and the THIS value passed to them
must be either a Number value or an object that has a [[NumberData]]
internal slot that has been initialized to a Number value.

The abstract operation thisNumberValue(value) performs the following
steps:

1.  If Type(value) is Number, return value.

2.  If Type(value) is Object and value has a [[NumberData]] internal
    slot, then

    a.  Assert: value’s [[NumberData]] internal slot is a Number
        value.

    b.  Return the value of value’s [[NumberData]] internal slot.

    c.  

3.  Throw a TYPEERROR exception.

The phrase “this Number value” within the specification of a method
refers to the result returned by calling the abstract operation
thisNumberValue with the THIS value of the method invocation passed as
the argument.

Number.prototype.constructor

The initial value of NUMBER.PROTOTYPE.CONSTRUCTOR is the intrinsic
object %Number%.

Number.prototype.toExponential ( fractionDigits )

Return a String containing this Number value represented in decimal
exponential notation with one digit before the significand's decimal
point and fractionDigits digits after the significand's decimal point.
If fractionDigits is UNDEFINED, include as many significand digits as
necessary to uniquely specify the Number (just like in ToString except
that in this case the Number is always output in exponential notation).
Specifically, perform the following steps:

1.  Let x be thisNumberValue(THIS value).

2.  ReturnIfAbrupt(x).

3.  Let f be ToInteger(fractionDigits).

4.  Assert: f is 0, when fractionDigits is UNDEFINED.

5.  ReturnIfAbrupt(f).

6.  If x is NAN, return the String "NAN".

7.  Let s be the empty String.

8.  If x < 0, then

    a.  Let s be "-".

    b.  Let x = –x.

9.  If x = +∞, then

    a.  Return the concatenation of the Strings s and "INFINITY".

    b.  

10. If f < 0 or f > 20, throw a RANGEERROR exception. However, an
    implementation is permitted to extend the behaviour of TOEXPONENTIAL
    for values of f less than 0 or greater than 20. In this case
    TOEXPONENTIAL would not necessarily throw RANGEERROR for such
    values.

11. If x = 0, then

    a.  Let m be the String consisting of f+1 occurrences of the
        code unit 0x0030.

    b.  Let e = 0.

12. Else x ≠ 0,

    a.  If fractionDigits is not UNDEFINED, then

        i.  Let e and n be integers such that 10^f^ ≤ n <
            10^f+1^ and for which the exact mathematical value of n
            × 10^e_–_f^ – x is as close to zero as possible. If
            there are two such sets of e and n, pick the e and n
            for which n × 10^e_–_f^ is larger.

    b.  Else fractionDigits is UNDEFINED,

    c.  i.  Let e, n, and f be integers such that f ≥ 0, 10^f^
            ≤ n < 10^f+1^, the Number value for n × 10^e_–_f^ is
            x, and f is as small as possible. Note that the decimal
            representation of n has f+1 digits, n is not divisible
            by 10, and the least significant digit of n is not
            necessarily uniquely determined by these criteria.

    d.  Let m be the String consisting of the digits of the decimal
        representation of n (in order, with no leading zeroes).

13. If f ≠ 0, then

    a.  Let a be the first element of m, and let b be the
        remaining f elements of m.

    b.  Let m be the concatenation of the three Strings a, ".", and
        b.

14. If e = 0, then

15. a.  Let c = "+".

    b.  Let d = "0".

16. Else

    a.  If e > 0, let c = "+".

    b.  Else e ≤ 0,

        i.  Let c = "-".

        ii. Let e = –e.

    c.  Let d be the String consisting of the digits of the decimal
        representation of e (in order, with no leading zeroes).

17. Let m be the concatenation of the four Strings m, "E", c, and
    d.

18. Return the concatenation of the Strings s and m.

The LENGTH property of the TOEXPONENTIAL method is 1.

If the TOEXPONENTIAL method is called with more than one argument, then
the behaviour is undefined (see clause 17).

NOTE For implementations that provide more accurate conversions than
required by the rules above, it is recommended that the following
alternative version of step 12.b.i be used as a guideline:

i.  Let e, n, and f be integers such that f ≥ 0, 10^f^ ≤ n <
    10^f+1^, the Number value for n × 10^e_–_f^ is x, and f is as
    small as possible. If there are multiple possibilities for n,
    choose the value of n for which n × 10^e_–_f^ is closest in
    value to x. If there are two such possible values of n, choose
    the one that is even.

Number.prototype.toFixed ( fractionDigits )

Note TOFIXED returns a String containing this Number value represented
in decimal fixed-point notation with fractionDigits digits after the
decimal point. If fractionDigits is UNDEFINED, 0 is assumed.

The following steps are performed:

1.  Let x be thisNumberValue(THIS value).

2.  ReturnIfAbrupt(x).

3.  Let f be ToInteger(fractionDigits). (If fractionDigits is
    UNDEFINED, this step produces the value 0).

4.  ReturnIfAbrupt(f).

5.  If f < 0 or f > 20, throw a RANGEERROR exception. However, an
    implementation is permitted to extend the behaviour of TOFIXED for
    values of f less than 0 or greater than 20. In this case TOFIXED
    would not necessarily throw RANGEERROR for such values.

6.  If x is NAN, return the String "NAN".

7.  Let s be the empty String.

8.  If x < 0, then

    a.  Let s be "-".

    b.  Let x = –x.

9.  If x ≥ 10^21^, then

    a.  Let m = ToString(x).

10. Else x < 10^21^,

    a.  Let n be an integer for which the exact mathematical value of
        n ÷ 10^f^ – x is as close to zero as possible. If there are
        two such n, pick the larger n.

    b.  If n = 0, let m be the String "0". Otherwise, let m be the
        String consisting of the digits of the decimal representation of
        n (in order, with no leading zeroes).

    c.  If f ≠ 0, then

        i.  Let k be the number of elements in m.

        ii. If k ≤ f, then

            1.  Let z be the String consisting of f_+1–_k
                occurrences of the code unit 0x0030.

            2.  Let m be the concatenation of Strings z and m.

            3.  Let k = f + 1.

        iii. Let a be the first k_–_f elements of m, and let b
            be the remaining f elements of m.

        iv. Let m be the concatenation of the three Strings a, ".",
            and b.

11. Return the concatenation of the Strings s and m.

The LENGTH property of the TOFIXED method is 1.

If the TOFIXED method is called with more than one argument, then the
behaviour is undefined (see clause 17).

NOTE The output of TOFIXED may be more precise than TOSTRING for some
values because toString only prints enough significant digits to
distinguish the number from adjacent number values. For example,

(1000000000000000128).TOSTRING() returns "1000000000000000100",
while (1000000000000000128).TOFIXED(0) returns "1000000000000000128".

Number.prototype.toLocaleString( [ reserved1 [ , reserved2 ] ])

An ECMAScript implementation that includes the ECMA-402
Internationalization API must implement the
NUMBER.PROTOTYPE.TOLOCALESTRING method as specified in the ECMA-402
specification. If an ECMAScript implementation does not include the
ECMA-402 API the following specification of the TOLOCALESTRING method is
used.

Produces a String value that represents this Number value formatted
according to the conventions of the host environment’s current locale.
This function is implementation-dependent, and it is permissible, but
not encouraged, for it to return the same thing as TOSTRING.

The meanings of the optional parameters to this method are defined in
the ECMA-402 specification; implementations that do not include ECMA-402
support must not use those parameter positions for anything else.

The LENGTH property of the TOLOCALESTRING method is 0.

Number.prototype.toPrecision ( precision )

Return a String containing this Number value represented either in
decimal exponential notation with one digit before the significand's
decimal point and precision–1 digits after the significand's decimal
point or in decimal fixed notation with precision significant digits.
If precision is UNDEFINED, call ToString (7.1.12) instead.
Specifically, perform the following steps:

1.  Let x be thisNumberValue(THIS value).

2.  ReturnIfAbrupt(x).

3.  If precision is UNDEFINED, return ToString(x).

4.  Let p be ToInteger(precision).

5.  ReturnIfAbrupt(p).

6.  If x is NAN, return the String "NAN".

7.  Let s be the empty String.

8.  If x < 0, then

    a.  Let s be code unit U+002D (HYPHEN-MINUS).

    b.  Let x = –x.

9.  If x = +∞, then

    a.  Return the String that is the concatenation of s and
        "INFINITY".

10. If p < 1 or p > 21, throw a RANGEERROR exception. However, an
    implementation is permitted to extend the behaviour of TOPRECISION
    for values of p less than 1 or greater than 21. In this case
    TOPRECISION would not necessarily throw RANGEERROR for such values.

11. If x = 0, then

    a.  Let m be the String consisting of p occurrences of the code
        unit U+0030 (DIGIT ZERO).

    b.  Let e = 0.

12. Else x ≠ 0,

    a.  Let e and n be integers such that 10^p–1^ ≤ n < 10^p^
        and for which the exact mathematical value of n ×
        10^e_–_p+1^ – x is as close to zero as possible. If there
        are two such sets of e and n, pick the e and n for which
        n × 10^e_–_p+1^ is larger.

    b.  Let m be the String consisting of the digits of the decimal
        representation of n (in order, with no leading zeroes).

    c.  If e < –6 or e ≥ p, then

        i.  Assert: e ≠ 0

        ii. Let a be the first element of m, and let b be the
            remaining p–1 elements of m.

        iii. Let m be the concatenation of a, code unit U+002E (FULL
            STOP), and b.

        iv. If e > 0, then

        v.  1.  Let c be code unit U+002B (PLUS SIGN).

        vi. Else e < 0,

            1.  Let c be code unit U+002D (HYPHEN-MINUS).

            2.  Let e = –e.

        vii. Let d be the String consisting of the digits of the
            decimal representation of e (in order, with no leading
            zeroes).

        viii. Return the concatenation of s, m, code unit U+0065
            (LATIN SMALL LETTER E), c, and d.

13. If e = p–1, return the concatenation of the Strings s and m.

14. If e ≥ 0, then

    a.  Let m be the concatenation of the first e+1 elements of m,
        the code unit U+002E (FULL STOP), and the remaining p– (e+1)
        elements of m.

15. Else e < 0,

    a.  Let m be the String formed by the concatenation of code unit
        U+0030 (DIGIT ZERO), code unit U+002E (FULL STOP), –(e+1)
        occurrences of code unit U+0030 (DIGIT ZERO), and the String
        m.

16. Return the String that is the concatenation of s and m.

The LENGTH property of the TOPRECISION method is 1.

If the TOPRECISION method is called with more than one argument, then
the behaviour is undefined (see clause 17).

 Number.prototype.toString ( [ radix ] )

NOTE The optional radix should be an integer value in the inclusive
range 2 to 36. If radix not present or is UNDEFINED the Number 10 is
used as the value of radix.

The following steps are performed:

1.  Let x be thisNumberValue(THIS value).

2.  ReturnIfAbrupt(x).

3.  If radix is not present, let radixNumber be 10.

4.  Else if radix is UNDEFINED, let radixNumber be 10.

5.  Else let radixNumber be ToInteger(radix).

6.  ReturnIfAbrupt(radixNumber).

7.  If radixNumber < 2 or radixNumber > 36, throw a RANGEERROR
    exception.

8.  If radixNumber = 10, return ToString(x).

9.  Return the String representation of this Number value using the
    radix specified by radixNumber. Letters A-Z are used for digits
    with values 10 through 35. The precise algorithm is
    implementation-dependent, however the algorithm should be a
    generalization of that specified in 7.1.12.1.

The TOSTRING function is not generic; it throws a TYPEERROR exception if
its THIS value is not a Number or a Number object. Therefore, it cannot
be transferred to other kinds of objects for use as a method.

Number.prototype.valueOf ( )

1.  Let x be thisNumberValue(THIS value).

2.  Return x.

Properties of Number Instances

Number instances are ordinary objects that inherit properties from the
Number prototype object. Number instances also have a [[NumberData]]
internal slot. The [[NumberData]] internal slot is the Number value
represented by this Number object.


The Math Object

The Math object is a single ordinary object.

The value of the [[Prototype]] internal slot of the Math object is the
intrinsic object %ObjectPrototype% (19.1.3).

The Math is not a function object. It does not have a [[Construct]]
internal method; it is not possible to use the Math object as a
constructor with the NEW operator. The Math object also does not have a
[[Call]] internal method; it is not possible to invoke the Math object
as a function.

NOTE In this specification, the phrase “the Number value for x” has a
technical meaning defined in 6.1.6.

Value Properties of the Math Object

Math.E

The Number value for e, the base of the natural logarithms, which is
approximately 2.7182818284590452354.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

 Math.LN10

The Number value for the natural logarithm of 10, which is approximately
2.302585092994046.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Math.LN2

The Number value for the natural logarithm of 2, which is approximately
0.6931471805599453.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Math.LOG10E

The Number value for the base-10 logarithm of e, the base of the
natural logarithms; this value is approximately 0.4342944819032518.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

NOTE The value of MATH.LOG10E is approximately the reciprocal of the
value of MATH.LN10.

Math.LOG2E

The Number value for the base-2 logarithm of e, the base of the
natural logarithms; this value is approximately 1.4426950408889634.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

NOTE The value of MATH.LOG2E is approximately the reciprocal of the
value of MATH.LN2.

Math.PI

The Number value for π, the ratio of the circumference of a circle to
its diameter, which is approximately 3.1415926535897932.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Math.SQRT1_2

The Number value for the square root of ½, which is approximately
0.7071067811865476.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

NOTE The value of MATH.SQRT1_2 is approximately the reciprocal of the
value of MATH.SQRT2.

Math.SQRT2

The Number value for the square root of 2, which is approximately
1.4142135623730951.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Math [ @@toStringTag ]

The initial value of the @@toStringTag property is the string value
"MATH".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Function Properties of the Math Object

Each of the following MATH object functions applies the ToNumber
abstract operation to each of its arguments (in left-to-right order if
there is more than one). If ToNumber returns an abrupt completion, that
Completion Record is immediately returned. Otherwise, the function
performs a computation on the resulting Number value(s). The value
returned by each function is a Number.

In the function descriptions below, the symbols NaN, −0, +0, −∞ and +∞
refer to the Number values described in 6.1.6.

NOTE The behaviour of the functions ACOS, ACOSH, ASIN, ASINH, ATAN,
ATANH, ATAN2, CBRT, COS, COSH, EXP, EXPM1, HYPOT, LOG,LOG1P, LOG2,
LOG10, POW, RANDOM, SIN, SINH, SQRT, TAN, and TANH is not precisely
specified here except to require specific results for certain argument
values that represent boundary cases of interest. For other argument
values, these functions are intended to compute approximations to the
results of familiar mathematical functions, but some latitude is allowed
in the choice of approximation algorithms. The general intent is that an
implementer should be able to use the same mathematical library for
ECMAScript on a given hardware platform that is available to C
programmers on that platform.

Although the choice of algorithms is left to the implementation, it is
recommended (but not specified by this standard) that implementations
use the approximation algorithms for IEEE 754 arithmetic contained in
FDLIBM, the freely distributable mathematical library from Sun
Microsystems (http://www.netlib.org/fdlibm).

Math.abs ( x )

Returns the absolute value of x; the result has the same magnitude as
x but has positive sign.

-   If x is NaN, the result is NaN.

-   If x is −0, the result is +0.

-   If x is −∞, the result is +∞.

Math.acos ( x )

Returns an implementation-dependent approximation to the arc cosine of
x. The result is expressed in radians and ranges from +0 to +π.

-   If x is NaN, the result is NaN.

-   If x is greater than 1, the result is NaN.

-   If x is less than −1, the result is NaN.

-   If x is exactly 1, the result is +0.

Math.acosh( x )

Returns an implementation-dependent approximation to the inverse
hyperbolic cosine of x.

-   If x is NaN, the result is NaN.

-   If x is less than 1, the result is NaN.

-   If x is 1, the result is +0.

-   If x is +∞, the result is +∞.

Math.asin ( x )

Returns an implementation-dependent approximation to the arc sine of
x. The result is expressed in radians and ranges from −π/2 to +π/2.

-   If x is NaN, the result is NaN.

-   If x is greater than 1, the result is NaN.

-   If x is less than –1, the result is NaN.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

Math.asinh( x )

Returns an implementation-dependent approximation to the inverse
hyperbolic sine of x.

-   If x is NaN, the result is NaN.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

-   If x is +∞, the result is +∞.

-   If x is −∞, the result is −∞.

Math.atan ( x )

Returns an implementation-dependent approximation to the arc tangent of
x. The result is expressed in radians and ranges from −π/2 to +π/2.

-   If x is NaN, the result is NaN.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

-   If x is +∞, the result is an implementation-dependent
      approximation to +π/2.

-   If x is −∞, the result is an implementation-dependent
      approximation to −π/2.

Math.atanh( x )

Returns an implementation-dependent approximation to the inverse
hyperbolic tangent of x.

-   If x is NaN, the result is NaN.

-   If x is less than −1, the result is NaN.

-   If x is greater than 1, the result is NaN.

-   If x is −1, the result is −∞.

-   If x is +1, the result is +∞.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

Math.atan2 ( y, x )

Returns an implementation-dependent approximation to the arc tangent of
the quotient y_/_x of the arguments y and x, where the signs of
y and x are used to determine the quadrant of the result. Note that
it is intentional and traditional for the two-argument arc tangent
function that the argument named y be first and the argument named x
be second. The result is expressed in radians and ranges from −π to +π.

-   If either x or y is NaN, the result is NaN.

-   If y>0 and x is +0, the result is an implementation-dependent
      approximation to +π/2.

-   If y>0 and x is −0, the result is an implementation-dependent
      approximation to +π/2.

-   If y is +0 and x>0, the result is +0.

-   If y is +0 and x is +0, the result is +0.

-   If y is +0 and x is −0, the result is an
      implementation-dependent approximation to +π.

-   If y is +0 and x<0, the result is an implementation-dependent
      approximation to +π.

-   If y is −0 and x>0, the result is −0.

-   If y is −0 and x is +0, the result is −0.

-   If y is −0 and x is −0, the result is an
      implementation-dependent approximation to −π.

-   If y is −0 and x<0, the result is an implementation-dependent
      approximation to −π.

-   If y<0 and x is +0, the result is an implementation-dependent
      approximation to −π/2.

-   If y<0 and x is −0, the result is an implementation-dependent
      approximation to −π/2.

-   If y>0 and y is finite and x is +∞, the result is +0.

-   If y>0 and y is finite and x is −∞, the result if an
      implementation-dependent approximation to +π.

-   If y<0 and y is finite and x is +∞, the result is −0.

-   If y<0 and y is finite and x is −∞, the result is an
      implementation-dependent approximation to −π.

-   If y is +∞ and x is finite, the result is an
      implementation-dependent approximation to +π/2.

-   If y is −∞ and x is finite, the result is an
      implementation-dependent approximation to −π/2.

-   If y is +∞ and x is +∞, the result is an
      implementation-dependent approximation to +π/4.

-   If y is +∞ and x is −∞, the result is an
      implementation-dependent approximation to +3π/4.

-   If y is −∞ and x is +∞, the result is an
      implementation-dependent approximation to −π/4.

-   If y is −∞ and x is −∞, the result is an
      implementation-dependent approximation to −3π/4.

Math.cbrt ( x )

Returns an implementation-dependent approximation to the cube root of
x.

-   If x is NaN, the result is NaN.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

-   If x is +∞, the result is +∞.

-   If x is −∞, the result is −∞.

Math.ceil ( x )

Returns the smallest (closest to −∞) Number value that is not less than
x and is equal to a mathematical integer. If x is already an
integer, the result is x.

-   If x is NaN, the result is NaN.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

-   If x is +∞, the result is +∞.

-   If x is −∞, the result is −∞.

-   If x is less than 0 but greater than -1, the result is −0.

The value of MATH.CEIL(X) is the same as the value of -MATH.FLOOR(-X).

Math.clz32 ( x )

When MATH.CLZ32 is called with one argument x, the following steps are
taken:

1.  Let n be ToUint32(x).

2.  3.  Let p be the number of leading zero bits in the 32-bit binary
    representation of n.

4.  Return p.

NOTE If n is 0, p will be 32. If the most significant bit of the
32-bit binary encoding of n is 1, p will be 0.

Math.cos ( x )

Returns an implementation-dependent approximation to the cosine of x.
The argument is expressed in radians.

-   If x is NaN, the result is NaN.

-   If x is +0, the result is 1.

-   If x is −0, the result is 1.

-   If x is +∞, the result is NaN.

-   If x is −∞, the result is NaN.

Math.cosh ( x )

Returns an implementation-dependent approximation to the hyperbolic
cosine of x.

-   If x is NaN, the result is NaN.

-   If x is +0, the result is 1.

-   If x is −0, the result is 1.

-   If x is +∞, the result is +∞.

-   If x is −∞, the result is +∞.

NOTE The value of cosh(x) is the same as _(exp(x) + exp(-x))/2_.

Math.exp ( x )

Returns an implementation-dependent approximation to the exponential
function of x (e raised to the power of x, where e is the base
of the natural logarithms).

-   If x is NaN, the result is NaN.

-   If x is +0, the result is 1.

-   If x is −0, the result is 1.

-   If x is +∞, the result is +∞.

-   If x is −∞, the result is +0.

Math.expm1 ( x )

Returns an implementation-dependent approximation to subtracting 1 from
the exponential function of x (e raised to the power of x, where
e is the base of the natural logarithms). The result is computed in a
way that is accurate even when the value of x is close 0.

-   If x is NaN, the result is NaN.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

-   If x is +∞, the result is +∞.

-   If x is −∞, the result is −1.

Math.floor ( x )

Returns the greatest (closest to +∞) Number value that is not greater
than x and is equal to a mathematical integer. If x is already an
integer, the result is x.

-   If x is NaN, the result is NaN.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

-   If x is +∞, the result is +∞.

-   If x is −∞, the result is −∞.

-   If x is greater than 0 but less than 1, the result is +0.

NOTE The value of MATH.FLOOR(X) is the same as the value of
-MATH.CEIL(-X).

Math.fround ( x )

When MATH.FROUND is called with argument x the following steps are
taken:

1.  If x is NaN, return NaN.

2.  If x is one of +0, −0, +∞, −∞, return x.

3.  Let x32 be the result of converting x to a value in
    IEEE-754-2008 binary32 format using roundTiesToEven.

4.  Let x64 be the result of converting x32 to a value in
    IEEE-754-2008 binary64 format.

5.  Return the ECMAScript Number value corresponding to x64.

Math.hypot ( value1 , value2 , …values )

MATH.HYPOT returns an implementation-dependent approximation of the
square root of the sum of squares of its arguments.

-   If no arguments are passed, the result is +0.

-   If any argument is +∞, the result is +∞.

-   If any argument is −∞, the result is +∞.

-   If no argument is +∞ or −∞, and any argument is NaN, the result is
      NaN.

-   If all arguments are either +0 or −0, the result is +0.

-   

The length property of the HYPOT function is 2.

NOTE Implementations should take care to avoid the loss of precision
from overflows and underflows that are prone to occur in naive
implementations when this function is called with two or more arguments.

Math.imul ( x, y )

When the MATH.IMUL is called with arguments x and y the following
steps are taken:

1.  Let a be ToUint32(x).

2.  3.  Let b be ToUint32(y).

4.  5.  Let product be (a × b) modulo 2^32^.

6.  If product ≥ 2^31^, return product − 2^32^, otherwise return
    product.

Math.log ( x )

Returns an implementation-dependent approximation to the natural
logarithm of x.

-   If x is NaN, the result is NaN.

-   If x is less than 0, the result is NaN.

-   If x is +0 or −0, the result is −∞.

-   If x is 1, the result is +0.

-   If x is +∞, the result is +∞.

Math.log1p ( x )

Returns an implementation-dependent approximation to the natural
logarithm of 1 + x. The result is computed in a way that is accurate
even when the value of x is close to zero.

-   If x is NaN, the result is NaN.

-   If x is less than -1, the result is NaN.

-   If x is -1, the result is -∞.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

-   If x is +∞, the result is +∞.

Math.log10 ( x )

Returns an implementation-dependent approximation to the base 10
logarithm of x.

-   If x is NaN, the result is NaN.

-   If x is less than 0, the result is NaN.

-   If x is +0, the result is −∞.

-   If x is −0, the result is −∞.

-   If x is 1, the result is +0.

-   If x is +∞, the result is +∞.

Math.log2 ( x )

Returns an implementation-dependent approximation to the base 2
logarithm of x.

-   If x is NaN, the result is NaN.

-   If x is less than 0, the result is NaN.

-   If x is +0, the result is −∞.

-   If x is −0, the result is −∞.

-   If x is 1, the result is +0.

-   If x is +∞, the result is +∞.

Math.max ( value1, value2 , …values )

Given zero or more arguments, calls ToNumber on each of the arguments
and returns the largest of the resulting values.

-   If no arguments are given, the result is −∞.

-   If any value is NaN, the result is NaN.

-   The comparison of values to determine the largest value is done
      using the Abstract Relational Comparison algorithm (7.2.9) except
      that +0 is considered to be larger than −0.

The LENGTH property of the MAX method is 2.

Math.min ( value1, value2 , …values )

Given zero or more arguments, calls ToNumber on each of the arguments
and returns the smallest of the resulting values.

-   If no arguments are given, the result is +∞.

-   If any value is NaN, the result is NaN.

-   The comparison of values to determine the smallest value is done
      using the Abstract Relational Comparison algorithm (7.2.9) except
      that +0 is considered to be larger than −0.

The LENGTH property of the MIN method is 2.

Math.pow ( x, y )

Returns an implementation-dependent approximation to the result of
raising x to the power y.

-   If y is NaN, the result is NaN.

-   If y is +0, the result is 1, even if x is NaN.

-   If y is −0, the result is 1, even if x is NaN.

-   If x is NaN and y is nonzero, the result is NaN.

-   If abs(x)>1 and y is +∞, the result is +∞.

-   If abs(x)>1 and y is −∞, the result is +0.

-   If abs(x) is 1 and y is +∞, the result is NaN.

-   If abs(x) is 1 and y is −∞, the result is NaN.

-   If abs(x)<1 and y is +∞, the result is +0.

-   If abs(x)<1 and y is −∞, the result is +∞.

-   If x is +∞ and y>0, the result is +∞.

-   If x is +∞ and y<0, the result is +0.

-   If x is −∞ and y>0 and y is an odd integer, the result is −∞.

-   If x is −∞ and y>0 and y is not an odd integer, the result
      is +∞.

-   If x is −∞ and y<0 and y is an odd integer, the result is −0.

-   If x is −∞ and y<0 and y is not an odd integer, the result
      is +0.

-   If x is +0 and y>0, the result is +0.

-   If x is +0 and y<0, the result is +∞.

-   If x is −0 and y>0 and y is an odd integer, the result is −0.

-   If x is −0 and y>0 and y is not an odd integer, the result
      is +0.

-   If x is −0 and y<0 and y is an odd integer, the result is −∞.

-   If x is −0 and y<0 and y is not an odd integer, the result
      is +∞.

-   If x<0 and x is finite and y is finite and y is not an
      integer, the result is NaN.

Math.random ( )

Returns a Number value with positive sign, greater than or equal to 0
but less than 1, chosen randomly or pseudo randomly with approximately
uniform distribution over that range, using an implementation-dependent
algorithm or strategy. This function takes no arguments.

Each MATH.RANDOM function created for distinct code Realms must produce
a distinct sequence of values from successive calls.

Math.round ( x )

Returns the Number value that is closest to x and is equal to a
mathematical integer. If two integer Number values are equally close to
x, then the result is the Number value that is closer to +∞. If x is
already an integer, the result is x.

-   If x is NaN, the result is NaN.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

-   If x is +∞, the result is +∞.

-   If x is −∞, the result is −∞.

-   If x is greater than 0 but less than 0.5, the result is +0.

-   If x is less than 0 but greater than or equal to -0.5, the result
      is −0.

NOTE 1 MATH.ROUND(3.5) returns 4, but MATH.ROUND(–3.5) returns –3.

NOTE 2 The value of MATH.ROUND(X) is not always the same as the value of
MATH.FLOOR(X+0.5). When X is −0 or is less than 0 but greater than or
equal to -0.5, MATH.ROUND(X) returns −0, but MATH.FLOOR(X+0.5)
returns +0. MATH.ROUND(X) may also differ from the value of
MATH.FLOOR(X+0.5)because of internal rounding when computing X+0.5.

Math.sign(x)

Returns the sign of the x, indicating whether x is positive, negative or
zero.

-   If x is NaN, the result is NaN.

-   If x is −0, the result is −0.

-   If x is +0, the result is +0.

-   If x is negative and not −0, the result is −1.

-   If x is positive and not +0, the result is +1.

Math.sin ( x )

Returns an implementation-dependent approximation to the sine of x.
The argument is expressed in radians.

-   If x is NaN, the result is NaN.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

-   If x is +∞ or −∞, the result is NaN.

Math.sinh( x )

Returns an implementation-dependent approximation to the hyperbolic sine
of x.

-   If x is NaN, the result is NaN.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

-   If x is +∞, the result is +∞.

-   If x is −∞, the result is −∞.

NOTE The value of sinh(x) is the same as _(exp(x) - exp(-x))/2_.

Math.sqrt ( x )

Returns an implementation-dependent approximation to the square root of
x.

-   If x is NaN, the result is NaN.

-   If x is less than 0, the result is NaN.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

-   If x is +∞, the result is +∞.

Math.tan ( x )

Returns an implementation-dependent approximation to the tangent of x.
The argument is expressed in radians.

-   If x is NaN, the result is NaN.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

-   If x is +∞ or −∞, the result is NaN.

Math.tanh ( x )

Returns an implementation-dependent approximation to the hyperbolic
tangent of x.

-   If x is NaN, the result is NaN.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

-   If x is +∞, the result is +1.

-   If x is −∞, the result is -1.

NOTE The value of tanh(x) is the same as _(exp(x) - exp(-x))/(exp(x) +
exp(-x))_.

Math.trunc ( x )

Returns the integral part of the number x, removing any fractional
digits. If x is already an integer, the result is x.

-   If x is NaN, the result is NaN.

-   If x is −0, the result is −0.

-   If x is +0, the result is +0.

-   If x is +∞, the result is +∞.

-   If x is −∞, the result is −∞.

-   If x is greater than 0 but less than 1, the result is +0.

-   If x is less than 0 but greater than −1, the result is −0.


Date Objects

Overview of Date Objects and Definitions of Abstract Operations

The following functions are abstract operations that operate on time
values (defined in 20.3.1.1). Note that, in every case, if any argument
to one of these functions is NAN, the result will be NAN.

Time Values and Time Range

A Date object contains a Number indicating a particular instant in time
to within a millisecond. Such a Number is called a _time value_. A time
value may also be NAN, indicating that the Date object does not
represent a specific instant of time.

Time is measured in ECMAScript in milliseconds since 01 January, 1970
UTC. In time values leap seconds are ignored. It is assumed that there
are exactly 86,400,000 milliseconds per day. ECMAScript Number values
can represent all integers from –9,007,199,254,740,992 to
9,007,199,254,740,992; this range suffices to measure times to
millisecond precision for any instant that is within approximately
285,616 years, either forward or backward, from 01 January, 1970 UTC.

The actual range of times supported by ECMAScript Date objects is
slightly smaller: exactly –100,000,000 days to 100,000,000 days measured
relative to midnight at the beginning of 01 January, 1970 UTC. This
gives a range of 8,640,000,000,000,000 milliseconds to either side of 01
January, 1970 UTC.

The exact moment of midnight at the beginning of 01 January, 1970 UTC is
represented by the value +0.

Day Number and Time within Day

A given time value t belongs to day number

Day(t) = floor(t / msPerDay)

where the number of milliseconds per day is

msPerDay = 86400000

The remainder is called the time within the day:

TimeWithinDay(t) = t modulo msPerDay

Year Number

ECMAScript uses an extrapolated Gregorian system to map a day number to
a year number and to determine the month and date within that year. In
this system, leap years are precisely those which are (divisible by 4)
and ((not divisible by 100) or (divisible by 400)). The number of days
in year number y is therefore defined by

  DaysInYear(y) = 365 if (y modulo 4) ≠ 0
  = 366 if (y modulo 4) = 0 and (y modulo 100) ≠ 0
  = 365 if (y modulo 100) = 0 and (y modulo 400) ≠ 0
  = 366 if (y modulo 400) = 0

All non-leap years have 365 days with the usual number of days per month
and leap years have an extra day in February. The day number of the
first day of year y is given by:

DayFromYear(y) = 365 × (y−1970) + floor((y−1969)/4) −
floor((y−1901)/100) + floor((y−1601)/400)

The time value of the start of a year is:

TimeFromYear(y) = msPerDay × DayFromYear(y)

A time value determines a year by:

YearFromTime(t) = the largest integer y (closest to positive
infinity) such that TimeFromYear(y) ≤ t

The leap-year function is 1 for a time within a leap year and otherwise
is zero:

  InLeapYear(t) = 0 if DaysInYear(YearFromTime(t)) = 365
  = 1 if DaysInYear(YearFromTime(t)) = 366

Month Number

Months are identified by an integer in the range 0 to 11, inclusive. The
mapping MonthFromTime(t) from a time value t to a month number is
defined by:

MonthFromTime(t) = 0 if 0 ≤ DayWithinYear(t) < 31
 = 1 if 31 ≤ DayWithinYear (t) < 59+InLeapYear(t)
 = 2 if 59+InLeapYear(t) ≤ DayWithinYear (t) < 90+InLeapYear(t)
 = 3 if 90+InLeapYear(t) ≤ DayWithinYear (t) < 120+InLeapYear(t)
 = 4 if 120+InLeapYear(t) ≤ DayWithinYear (t) < 151+InLeapYear(t)
 = 5 if 151+InLeapYear(t) ≤ DayWithinYear (t) < 181+InLeapYear(t)
 = 6 if 181+InLeapYear(t) ≤ DayWithinYear (t) < 212+InLeapYear(t)
 = 7 if 212+InLeapYear(t) ≤ DayWithinYear (t) < 243+InLeapYear(t)
 = 8 if 243+InLeapYear(t) ≤ DayWithinYear (t) < 273+InLeapYear(t)
 = 9 if 273+InLeapYear(t) ≤ DayWithinYear (t) < 304+InLeapYear(t)
 = 10 if 304+InLeapYear(t) ≤ DayWithinYear (t) < 334+InLeapYear(t)
 = 11 if 334+InLeapYear(t) ≤ DayWithinYear (t) < 365+InLeapYear(t)

where

DayWithinYear(t) = Day(t_)−DayFromYear(YearFromTime(_t))

A month value of 0 specifies January; 1 specifies February; 2 specifies
March; 3 specifies April; 4 specifies May; 5 specifies June; 6 specifies
July; 7 specifies August; 8 specifies September; 9 specifies October; 10
specifies November; and 11 specifies December. Note that
MonthFromTime(0) = 0, corresponding to Thursday, 01 January, 1970.

Date Number

A date number is identified by an integer in the range 1 through 31,
inclusive. The mapping DateFromTime(t) from a time value t to a date
number is defined by:

  DateFromTime(t) = DayWithinYear(t)+1 if MonthFromTime(t)=0
   = DayWithinYear(t)−30 if MonthFromTime(t)=1
   = DayWithinYear(t_)−58−InLeapYear(_t) if MonthFromTime(t)=2
   = DayWithinYear(t_)−89−InLeapYear(_t) if MonthFromTime(t)=3
   = DayWithinYear(t_)−119−InLeapYear(_t) if MonthFromTime(t)=4
   = DayWithinYear(t_)−150−InLeapYear(_t) if MonthFromTime(t)=5
   = DayWithinYear(t_)−180−InLeapYear(_t) if MonthFromTime(t)=6
   = DayWithinYear(t_)−211−InLeapYear(_t) if MonthFromTime(t)=7
   = DayWithinYear(t_)−242−InLeapYear(_t) if MonthFromTime(t)=8
   = DayWithinYear(t_)−272−InLeapYear(_t) if MonthFromTime(t)=9
   = DayWithinYear(t_)−303−InLeapYear(_t) if MonthFromTime(t)=10
   = DayWithinYear(t_)−333−InLeapYear(_t) if MonthFromTime(t)=11

Week Day

The weekday for a particular time value t is defined as

WeekDay(t) = (Day(t) + 4) modulo 7

A weekday value of 0 specifies Sunday; 1 specifies Monday; 2 specifies
Tuesday; 3 specifies Wednesday; 4 specifies Thursday; 5 specifies
Friday; and 6 specifies Saturday. Note that WeekDay(0) = 4,
corresponding to Thursday, 01 January, 1970.

Local Time Zone Adjustment

An implementation of ECMAScript is expected to determine the local time
zone adjustment. The local time zone adjustment is a value LocalTZA
measured in milliseconds which when added to UTC represents the local
standard time. Daylight saving time is not reflected by LocalTZA.

NOTE It is recommended that implementations use the time zone
information of the IANA Time Zone Database
http://www.iana.org/time-zones/.

Daylight Saving Time Adjustment

An implementation dependent algorithm using best available information
on time zones to determine the local daylight saving time adjustment
DaylightSavingTA(t), measured in milliseconds. An implementation of
ECMAScript is expected to make its best effort to determine the local
daylight saving time adjustment.

NOTE It is recommended that implementations use the time zone
information of the IANA Time Zone Database
http://www.iana.org/time-zones/.

Local Time

Conversion from UTC to local time is defined by

LocalTime(t) = t + LocalTZA + DaylightSavingTA(t)

Conversion from local time to UTC is defined by

UTC(t) = t – LocalTZA – DaylightSavingTA(t – LocalTZA)

NOTE UTC(LocalTime(t)) is not necessarily always equal to t.

Hours, Minutes, Second, and Milliseconds

The following functions are useful in decomposing time values:

HourFromTime(t) = floor(t / msPerHour) modulo HoursPerDay

MinFromTime(t) = floor(t / msPerMinute) modulo MinutesPerHour

SecFromTime(t) = floor(t / msPerSecond) modulo SecondsPerMinute

msFromTime(t) = t modulo msPerSecond

where

HoursPerDay = 24

MinutesPerHour = 60

SecondsPerMinute = 60

msPerSecond = 1000

msPerMinute = 60000 = msPerSecond × SecondsPerMinute

msPerHour = 3600000 = msPerMinute × MinutesPerHour

MakeTime (hour, min, sec, ms)

The operator MakeTime calculates a number of milliseconds from its four
arguments, which must be ECMAScript Number values. This operator
functions as follows:

1.  If hour is not finite or min is not finite or sec is not
    finite or ms is not finite, return NAN.

2.  Let h be ToInteger(hour).

3.  Let m be ToInteger(min).

4.  Let s be ToInteger(sec).

5.  Let milli be ToInteger(ms).

6.  Let t be h * msPerHour + m * msPerMinute + s * msPerSecond +
    milli, performing the arithmetic according to IEEE 754 rules (that
    is, as if using the ECMAScript operators * and +).

7.  Return t.

MakeDay (year, month, date)

The operator MakeDay calculates a number of days from its three
arguments, which must be ECMAScript Number values. This operator
functions as follows:

1.  If year is not finite or month is not finite or date is not
    finite, return NAN.

2.  Let y be ToInteger(year).

3.  Let m be ToInteger(month).

4.  Let dt be ToInteger(date).

5.  Let ym be y + floor(m /12).

6.  Let mn be m modulo 12.

7.  Find a value t such that YearFromTime(t) is ym and
    MonthFromTime(t) is mn and DateFromTime(t) is 1; but if this
    is not possible (because some argument is out of range), return NAN.

8.  Return Day(t) + dt − 1.

MakeDate (day, time)

The operator MakeDate calculates a number of milliseconds from its two
arguments, which must be ECMAScript Number values. This operator
functions as follows:

1.  If day is not finite or time is not finite, return NAN.

2.  Return day × msPerDay + time.

TimeClip (time)

The operator TimeClip calculates a number of milliseconds from its
argument, which must be an ECMAScript Number value. This operator
functions as follows:

1.  If time is not finite, return NAN.

2.  If abs(time) > 8.64 × 10^15^, return NAN.

3.  Return ToInteger(time) + (+0). (Adding a positive zero converts −0
    to +0.)

NOTE The point of step 3 is that an implementation is permitted a choice
of internal representations of time values, for example as a 64-bit
signed integer or as a 64-bit floating-point value. Depending on the
implementation, this internal representation may or may not distinguish
−0 and +0.

Date Time String Format

ECMAScript defines a string interchange format for date-times based upon
a simplification of the ISO 8601 Extended Format. The format is as
follows: YYYY-MM-DDTHH:MM:SS.SSSZ

Where the fields are as follows:

This format includes date-only forms:

  YYYY
  YYYY-MM
  YYYY-MM-DD

It also includes “date-time” forms that consist of one of the above
date-only forms immediately followed by one of the following time forms
with an optional time zone offset appended:

  THH:MM
  THH:MM:SS
  THH:MM:SS.SSS

All numbers must be base 10. If the MM or DD fields are absent “01” is
used as the value. If the HH, MM, or SS fields are absent “00” is used
as the value and the value of an absent SSS field is “000”. If the time
zone offset is absent, the date-time is interpreted as a local time.

Illegal values (out-of-bounds as well as syntax errors) in a format
string means that the format string is not a valid instance of this
format.

NOTE 1 As every day both starts and ends with midnight, the two
notations 00:00 and 24:00 are available to distinguish the two midnights
that can be associated with one date. This means that the following two
notations refer to exactly the same point in time: 1995-02-04T24:00 and
1995-02-05T00:00

NOTE 2 There exists no international standard that specifies
abbreviations for civil time zones like CET, EST, etc. and sometimes the
same abbreviation is even used for two very different time zones. For
this reason, ISO 8601 and this format specifies numeric representations
of date and time.

Extended years

ECMAScript requires the ability to specify 6 digit years (extended
years); approximately 285,426 years, either forward or backward, from 01
January, 1970 UTC. To represent years before 0 or after 9999, ISO 8601
permits the expansion of the year representation, but only by prior
agreement between the sender and the receiver. In the simplified
ECMAScript format such an expanded year representation shall have 2
extra year digits and is always prefixed with a + or – sign. The year 0
is considered positive and hence prefixed with a + sign.

NOTE Examples of extended years:

  -283457-03-21T15:00:59.008Z 283458 B.C.
  -000001-01-01T00:00:00Z 2 B.C.
  +000000-01-01T00:00:00Z 1 B.C.
  +000001-01-01T00:00:00Z 1 A.D.
  +001970-01-01T00:00:00Z 1970 A.D.
  +002009-12-15T00:00:00Z 2009 A.D.
  +287396-10-12T08:59:00.992Z 287396 A.D.

The Date Constructor 

The Date constructor is the %Date% intrinsic object and the initial
value of the DATE property of the global object. When called as a
constructor it creates and initializes a new Date object. When DATE is
called as a function rather than as a constructor, it returns a String
representing the current time (UTC).

The DATE constructor is a single function whose behaviour is overloaded
based upon the number and types of its arguments.

The DATE constructor is designed to be subclassable. It may be used as
the value of an EXTENDS clause of a class definition. Subclass
constructors that intend to inherit the specified DATE behaviour must
include a SUPER call to the DATE constructor to create and initialize
the subclass instance with a [[DateValue]] internal slot.

Date ( year, month [, date [ , hours [ , minutes [ , seconds [ , ms ] ] ] ] ] )

This description applies only if the Date constructor is called with at
least two arguments.

When the DATE function is called the following steps are taken:

1.  Let numberOfArgs be the number of arguments passed to this
    function call.

2.  Assert: numberOfArgs ≥ 2.

3.  4.  If NewTarget is not UNDEFINED, then

    a.  Let y be ToNumber(year).

    b.  ReturnIfAbrupt(y).

    c.  Let m be ToNumber(month).

    d.  ReturnIfAbrupt(m).

    e.  If date is supplied, let dt be ToNumber(date); else let
        dt be 1.

    f.  ReturnIfAbrupt(dt).

    g.  If hours is supplied, let h be ToNumber(hours); else let
        h be 0.

    h.  ReturnIfAbrupt(h).

    i.  If minutes is supplied, let min be ToNumber(minutes); else
        let min be 0.

    j.  ReturnIfAbrupt(min).

    k.  If seconds is supplied, let s be ToNumber(seconds); else
        let s be 0.

    l.  ReturnIfAbrupt(s).

    m.  If ms is supplied, let milli be ToNumber(ms); else let
        milli be 0.

    n.  ReturnIfAbrupt(milli).

    o.  If y_ is not NAN and 0 ≤ ToInteger(_y) ≤ 99, let yr
        be 1900+ToInteger(y); otherwise, let yr be y.

    p.  Let finalDate be MakeDate(MakeDay(yr, m, dt),
        MakeTime(h, min, s, milli)).

    q.  Let O be OrdinaryCreateFromConstructor(NewTarget,
        "%DATEPROTOTYPE%", «‍ [[DateValue]]»).

    r.  ReturnIfAbrupt(O).

    s.  Set the [[DateValue]] internal slot of O to
        TimeClip(UTC(finalDate)).

    t.  Return O.

5.  Else,

    a.  Let now be the Number that is the time value (UTC) identifying
        the current time.

    b.  Return ToDateString (now).

 Date ( value )

This description applies only if the Date constructor is called with
exactly one argument.

When the DATE function is called the following steps are taken:

1.  Let numberOfArgs be the number of arguments passed to this
    function call.

2.  Assert: numberOfArgs = 1.

3.  4.  If NewTarget is not UNDEFINED, then

    a.  If Type(value) is Object and value has a [[DateValue]]
        internal slot, then

        i.  Let tv be thisTimeValue(value).

    b.  Else,

        i.  Let v be ToPrimitive(value).

        ii. If Type(v) is String, then

        iii. 1.  Let tv be the result of parsing v as a date, in
                exactly the same manner as for the PARSE method
                (20.3.3.2). If the parse resulted in an abrupt
                completion, tv is the Completion Record.

        iv. Else,

            1.  Let tv be ToNumber(v).

    c.  ReturnIfAbrupt(tv).

    d.  Let O be OrdinaryCreateFromConstructor(NewTarget,
        "%DATEPROTOTYPE%", «‍ [[DateValue]]»).

    e.  ReturnIfAbrupt(O).

    f.  Set the [[DateValue]] internal slot of O to TimeClip(tv).

    g.  Return O.

5.  Else,

    a.  Let now be the Number that is the time value (UTC) identifying
        the current time.

    b.  Return ToDateString (now).

Date ( )

This description applies only if the Date constructor is called with no
arguments.

When the DATE function is called the following steps are taken:

1.  Let numberOfArgs be the number of arguments passed to this
    function call.

2.  Assert: numberOfArgs = 0.

3.  4.  If NewTarget is not UNDEFINED, then

    a.  Let O be OrdinaryCreateFromConstructor(NewTarget,
        "%DATEPROTOTYPE%", «‍ [[DateValue]]»).

    b.  ReturnIfAbrupt(O).

    c.  Set the [[DateValue]] internal slot of O to the time value
        (UTC) identifying the current time.

    d.  Return O.

5.  Else,

    a.  Let now be the Number that is the time value (UTC) identifying
        the current time.

    b.  Return ToDateString (now).

1.  2.  3.  

Properties of the Date Constructor

The value of the [[Prototype]] internal slot of the Date constructor is
the intrinsic object %FunctionPrototype% (19.2.3).

1.  

Besides the LENGTH property (whose value is 7), the Date constructor has
the following properties:

Date.now ( )

The NOW function return a Number value that is the time value
designating the UTC date and time of the occurrence of the call to NOW.

Date.parse ( string )

The PARSE function applies the ToString operator to its argument. If
ToString results in an abrupt completion the Completion Record is
immediately returned. Otherwise, PARSE interprets the resulting String
as a date and time; it returns a Number, the UTC time value
corresponding to the date and time. The String may be interpreted as a
local time, a UTC time, or a time in some other time zone, depending on
the contents of the String. The function first attempts to parse the
format of the String according to the rules (including extended years)
called out in Date Time String Format (20.3.1.15). If the String does
not conform to that format the function may fall back to any
implementation-specific heuristics or implementation-specific date
formats. Unrecognizable Strings or dates containing illegal element
values in the format String shall cause DATE.PARSE to return NAN.

If x is any Date object whose milliseconds amount is zero within a
particular implementation of ECMAScript, then all of the following
expressions should produce the same numeric value in that
implementation, if all the properties referenced have their initial
values:

  X.VALUEOF()

  DATE.PARSE(X.TOSTRING())

  DATE.PARSE(X.TOUTCSTRING())

  DATE.PARSE(X.TOISOSTRING())

However, the expression

  DATE.PARSE(X.TOLOCALESTRING())

is not required to produce the same Number value as the preceding three
expressions and, in general, the value produced by DATE.PARSE is
implementation-dependent when given any String value that does not
conform to the Date Time String Format (20.3.1.15) and that could not be
produced in that implementation by the TOSTRING or TOUTCSTRING method.

Date.prototype

The initial value of DATE.PROTOTYPE is the intrinsic object
%DatePrototype% (20.3.4).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Date.UTC ( year, month [ , date [ , hours [ , minutes [ , seconds [ , ms ] ] ] ] ] )

When the UTC function is called with fewer than two arguments, the
behaviour is implementation-dependent. When the UTC function is called
with two to seven arguments, it computes the date from year, month
and (optionally) date, hours, minutes, seconds and ms. The
following steps are taken:

1.  Let y be ToNumber(year).

2.  ReturnIfAbrupt(y).

3.  Let m be ToNumber(month).

4.  ReturnIfAbrupt(m).

5.  If date is supplied, let dt be ToNumber(date); else let dt
    be 1.

6.  ReturnIfAbrupt(dt).

7.  If hours is supplied, let h be ToNumber(hours); else let h
    be 0.

8.  ReturnIfAbrupt(h).

9.  If minutes is supplied, let min be ToNumber(minutes); else let
    min be 0.

10. ReturnIfAbrupt(min).

11. If seconds is supplied, let s be ToNumber(seconds); else let
    s be 0.

12. ReturnIfAbrupt(s).

13. If ms is supplied, let milli be ToNumber(ms); else let milli
    be 0.

14. ReturnIfAbrupt(milli).

15. If y_ is not NAN and 0 ≤ ToInteger(_y) ≤ 99, let yr
    be 1900+ToInteger(y); otherwise, let yr be y.

16. Return TimeClip(MakeDate(MakeDay(yr, m, dt), MakeTime(h,
    min, s, milli))).

The LENGTH property of the UTC function is 7.

NOTE The UTC function differs from the Date constructor in two ways: it
returns a time value as a Number, rather than creating a Date object,
and it interprets the arguments in UTC rather than as local time.

1.  2.  

Properties of the Date Prototype Object

The Date prototype object is itself an ordinary object. It is not a Date
instance and does not have a [[DateValue]] internal slot.

The value of the [[Prototype]] internal slot of the Date prototype
object is the intrinsic object %ObjectPrototype% (20.3.4).

Unless explicitly defined otherwise, the methods of the Date prototype
object defined below are not generic and the THIS value passed to them
must be an object that has a [[DateValue]] internal slot that has been
initialized to a time value.

The abstract operation thisTimeValue(value) performs the following
steps:

1.  If Type(value) is Object and value has a [[DateValue]] internal
    slot, then

    a.  Return the value of value’s [[DateValue]] internal slot.

    b.  

2.  Throw a TYPEERROR exception.

In following descriptions of functions that are properties of the Date
prototype object, the phrase “this Date object” refers to the object
that is the THIS value for the invocation of the function. If the Type
of the THIS value is not Object, a TYPEERROR exception is thrown. The
phrase “this time value” within the specification of a method refers to
the result returned by calling the abstract operation thisTimeValue with
the THIS value of the method invocation passed as the argument.

Date.prototype.constructor

The initial value of DATE.PROTOTYPE.CONSTRUCTOR is the intrinsic object
%Date%.

Date.prototype.getDate ( )

1.  Let t be this time value.

2.  ReturnIfAbrupt(t).

3.  If t is NAN, return NAN.

4.  Return DateFromTime(LocalTime(t)).

Date.prototype.getDay ( )

1.  Let t be this time value.

2.  ReturnIfAbrupt(t).

3.  If t is NAN, return NAN.

4.  Return WeekDay(LocalTime(t)).

Date.prototype.getFullYear ( )

1.  Let t be this time value.

2.  ReturnIfAbrupt(t).

3.  If t is NAN, return NAN.

4.  Return YearFromTime(LocalTime(t)).

Date.prototype.getHours ( )

1.  Let t be this time value.

2.  ReturnIfAbrupt(t).

3.  If t is NAN, return NAN.

4.  Return HourFromTime(LocalTime(t)).

Date.prototype.getMilliseconds ( )

1.  Let t be this time value.

2.  ReturnIfAbrupt(t).

3.  If t is NAN, return NAN.

4.  Return msFromTime(LocalTime(t)).

Date.prototype.getMinutes ( )

1.  Let t be this time value.

2.  ReturnIfAbrupt(t).

3.  If t is NAN, return NAN.

4.  Return MinFromTime(LocalTime(t)).

Date.prototype.getMonth ( )

1.  Let t be this time value.

2.  ReturnIfAbrupt(t).

3.  If t is NAN, return NAN.

4.  Return MonthFromTime(LocalTime(t)).

Date.prototype.getSeconds ( )

1.  Let t be this time value.

2.  ReturnIfAbrupt(t).

3.  If t is NAN, return NAN.

4.  Return SecFromTime(LocalTime(t)).

Date.prototype.getTime ( )

1.  Return this time value.

Date.prototype.getTimezoneOffset ( )

Returns the difference between local time and UTC time in minutes.

1.  Let t be this time value.

2.  ReturnIfAbrupt(t).

3.  If t is NAN, return NAN.

4.  Return (t − LocalTime(t)) / msPerMinute.

Date.prototype.getUTCDate ( )

1.  Let t be this time value.

2.  ReturnIfAbrupt(t).

3.  If t is NAN, return NAN.

4.  Return DateFromTime(t).

Date.prototype.getUTCDay ( )

1.  Let t be this time value.

2.  ReturnIfAbrupt(t).

3.  If t is NAN, return NAN.

4.  Return WeekDay(t).

Date.prototype.getUTCFullYear ( )

1.  Let t be this time value.

2.  ReturnIfAbrupt(t).

3.  If t is NAN, return NAN.

4.  Return YearFromTime(t).

Date.prototype.getUTCHours ( )

1.  Let t be this time value.

2.  ReturnIfAbrupt(t).

3.  If t is NAN, return NAN.

4.  Return HourFromTime(t).

Date.prototype.getUTCMilliseconds ( )

1.  Let t be this time value.

2.  ReturnIfAbrupt(t).

3.  If t is NAN, return NAN.

4.  Return msFromTime(t).

Date.prototype.getUTCMinutes ( )

1.  Let t be this time value.

2.  ReturnIfAbrupt(t).

3.  If t is NAN, return NAN.

4.  Return MinFromTime(t).

Date.prototype.getUTCMonth ( )

1.  Let t be this time value.

2.  ReturnIfAbrupt(t).

3.  If t is NAN, return NAN.

4.  Return MonthFromTime(t).

Date.prototype.getUTCSeconds ( )

1.  Let t be this time value.

2.  ReturnIfAbrupt(t).

3.  If t is NAN, return NAN.

4.  Return SecFromTime(t).

Date.prototype.setDate ( date )

1.  Let t be the result of LocalTime(this time value).

2.  Let dt be ToNumber(date).

3.  ReturnIfAbrupt(dt).

4.  Let newDate be MakeDate(MakeDay(YearFromTime(t),
    MonthFromTime(t), dt), TimeWithinDay(t)).

5.  Let u be TimeClip(UTC(newDate)).

6.  Set the [[DateValue]] internal slot of this Date object to u.

7.  Return u.

Date.prototype.setFullYear ( year [ , month [ , date ] ] )

1.  Let t be the result of LocalTime(this time value); but if this
    time value is NAN, let t be +0.

2.  Let y be ToNumber(year).

3.  ReturnIfAbrupt(y).

4.  If month is not specified, let m be MonthFromTime(t);
    otherwise, let m be ToNumber(month).

5.  ReturnIfAbrupt(m).

6.  If date is not specified, let dt be DateFromTime(t);
    otherwise, let dt be ToNumber(date).

7.  ReturnIfAbrupt(dt).

8.  Let newDate be MakeDate(MakeDay(y, m, dt),
    TimeWithinDay(t)).

9.  Let u be TimeClip(UTC(newDate)).

10. Set the [[DateValue]] internal slot of this Date object to u.

11. Return u.

The LENGTH property of the SETFULLYEAR method is 3.

NOTE If month is not specified, this method behaves as if month were
specified with the value GETMONTH(). If date is not specified, it
behaves as if date were specified with the value GETDATE().

Date.prototype.setHours ( hour [ , min [ , sec [ , ms ] ] ] )

1.  Let t be the result of LocalTime(this time value).

2.  Let h be ToNumber(hour).

3.  ReturnIfAbrupt(h).

4.  If min is not specified, let m be MinFromTime(t); otherwise,
    let m be ToNumber(min).

5.  ReturnIfAbrupt(m).

6.  If sec is not specified, let s be SecFromTime(t); otherwise,
    let s be ToNumber(sec).

7.  ReturnIfAbrupt(s).

8.  If ms is not specified, let milli be msFromTime(t); otherwise,
    let milli be ToNumber(ms).

9.  ReturnIfAbrupt(milli).

10. Let date be MakeDate(Day(t), MakeTime(h, m, s, milli)).

11. Let u be TimeClip(UTC(date)).

12. Set the [[DateValue]] internal slot of this Date object to u.

13. Return u.

The LENGTH property of the SETHOURS method is 4.

NOTE If min is not specified, this method behaves as if min were
specified with the value GETMINUTES(). If sec is not specified, it
behaves as if sec were specified with the value GETSECONDS(). If ms
is not specified, it behaves as if ms were specified with the value
GETMILLISECONDS().

Date.prototype.setMilliseconds ( ms )

1.  Let t be the result of LocalTime(this time value).

2.  Let ms be ToNumber(ms).

3.  ReturnIfAbrupt(ms).

4.  Let time be MakeTime(HourFromTime(t), MinFromTime(t),
    SecFromTime(t), ms).

5.  Let u be TimeClip(UTC(MakeDate(Day(t), time))).

6.  Set the [[DateValue]] internal slot of this Date object to u.

7.  Return u.

Date.prototype.setMinutes ( min [ , sec [ , ms ] ] )

1.  Let t be the result of LocalTime(this time value).

2.  Let m be ToNumber(min).

3.  ReturnIfAbrupt(m).

4.  If sec is not specified, let s be SecFromTime(t); otherwise,
    let s be ToNumber(sec).

5.  ReturnIfAbrupt(s).

6.  If ms is not specified, let milli be msFromTime(t); otherwise,
    let milli be ToNumber(ms).

7.  ReturnIfAbrupt(milli).

8.  Let date be MakeDate(Day(t), MakeTime(HourFromTime(t), m,
    s, milli)).

9.  Let u be TimeClip(UTC(date)).

10. Set the [[DateValue]] internal slot of this Date object to u.

11. Return u.

The LENGTH property of the SETMINUTES method is 3.

NOTE If sec is not specified, this method behaves as if sec were
specified with the value GETSECONDS(). If ms is not specified, this
behaves as if ms were specified with the value GETMILLISECONDS().

Date.prototype.setMonth ( month [ , date ] )

1.  Let t be the result of LocalTime(this time value).

2.  Let m be ToNumber(month).

3.  ReturnIfAbrupt(m).

4.  If date is not specified, let dt be DateFromTime(t);
    otherwise, let dt be ToNumber(date).

5.  ReturnIfAbrupt(dt).

6.  Let newDate be MakeDate(MakeDay(YearFromTime(t), m, dt),
    TimeWithinDay(t)).

7.  Let u be TimeClip(UTC(newDate)).

8.  Set the [[DateValue]] internal slot of this Date object to u.

9.  Return u.

The LENGTH property of the SETMONTH method is 2.

NOTE If date is not specified, this method behaves as if date were
specified with the value GETDATE().

Date.prototype.setSeconds ( sec [ , ms ] )

1.  Let t be the result of LocalTime(this time value).

2.  Let s be ToNumber(sec).

3.  ReturnIfAbrupt(s).

4.  If ms is not specified, let milli be msFromTime(t); otherwise,
    let milli be ToNumber(ms).

5.  ReturnIfAbrupt(milli).

6.  Let date be MakeDate(Day(t), MakeTime(HourFromTime(t),
    MinFromTime(t), s, milli)).

7.  Let u be TimeClip(UTC(date)).

8.  Set the [[DateValue]] internal slot of this Date object to u.

9.  Return u.

The LENGTH property of the SETSECONDS method is 2.

NOTE If ms is not specified, this method behaves as if ms were
specified with the value GETMILLISECONDS().

Date.prototype.setTime ( time )

1.  Let t be ToNumber(time).

2.  ReturnIfAbrupt(t).

3.  Let v be TimeClip(t).

4.  5.  Set the [[DateValue]] internal slot of this Date object to v.

6.  Return v.

Date.prototype.setUTCDate ( date )

1.  Let t be this time value.

2.  ReturnIfAbrupt(t).

3.  Let dt be ToNumber(date).

4.  ReturnIfAbrupt(dt).

5.  Let newDate be MakeDate(MakeDay(YearFromTime(t),
    MonthFromTime(t), dt), TimeWithinDay(t)).

6.  Let v be TimeClip(newDate).

7.  Set the [[DateValue]] internal slot of this Date object to v.

8.  Return v.

Date.prototype.setUTCFullYear ( year [ , month [ , date ] ] )

1.  Let t be this time value; but if this time value is NAN, let t
    be +0.

2.  ReturnIfAbrupt(t).

3.  Let y be ToNumber(year).

4.  ReturnIfAbrupt(y).

5.  If month is not specified, let m be MonthFromTime(t);
    otherwise, let m be ToNumber(month).

6.  ReturnIfAbrupt(m).

7.  If date is not specified, let dt be DateFromTime(t);
    otherwise, let dt be ToNumber(date).

8.  ReturnIfAbrupt(dt).

9.  Let newDate be MakeDate(MakeDay(y, m, dt),
    TimeWithinDay(t)).

10. Let v be TimeClip(newDate).

11. Set the [[DateValue]] internal slot of this Date object to v.

12. Return v.

The LENGTH property of the SETUTCFULLYEAR method is 3.

NOTE If month is not specified, this method behaves as if month were
specified with the value GETUTCMONTH(). If date is not specified, it
behaves as if date were specified with the value GETUTCDATE().

Date.prototype.setUTCHours ( hour [ , min [ , sec [ , ms ] ] ] )

1.  Let t be this time value.

2.  ReturnIfAbrupt(t).

3.  Let h be ToNumber(hour).

4.  ReturnIfAbrupt(h).

5.  If min is not specified, let m be MinFromTime(t); otherwise,
    let m be ToNumber(min).

6.  ReturnIfAbrupt(m).

7.  If sec is not specified, let s be SecFromTime(t); otherwise,
    let s be ToNumber(sec).

8.  ReturnIfAbrupt(s).

9.  If ms is not specified, let milli be msFromTime(t); otherwise,
    let milli be ToNumber(ms).

10. ReturnIfAbrupt(milli).

11. Let newDate be MakeDate(Day(t), MakeTime(h, m, s,
    milli)).

12. Let v be TimeClip(newDate).

13. Set the [[DateValue]] internal slot of this Date object to v.

14. Return v.

The LENGTH property of the SETUTCHOURS method is 4.

NOTE If min is not specified, this method behaves as if min were
specified with the value GETUTCMINUTES(). If sec is not specified, it
behaves as if sec were specified with the value GETUTCSECONDS(). If
ms is not specified, it behaves as if ms were specified with the
value GETUTCMILLISECONDS().

Date.prototype.setUTCMilliseconds ( ms )

1.  Let t be this time value.

2.  ReturnIfAbrupt(t).

3.  Let milli be ToNumber(ms).

4.  ReturnIfAbrupt(milli).

5.  Let time be MakeTime(HourFromTime(t), MinFromTime(t),
    SecFromTime(t), milli).

6.  Let v be TimeClip(MakeDate(Day(t), time)).

7.  Set the [[DateValue]] internal slot of this Date object to v.

8.  Return v.

Date.prototype.setUTCMinutes ( min [ , sec [, ms ] ] )

1.  Let t be this time value.

2.  ReturnIfAbrupt(t).

3.  Let m be ToNumber(min).

4.  If sec is not specified, let s be SecFromTime(t); otherwise,
    let s be ToNumber(sec).

5.  If ms is not specified, let milli be msFromTime(t); otherwise,
    let milli be ToNumber(ms).

6.  Let date be MakeDate(Day(t), MakeTime(HourFromTime(t), m,
    s, milli)).

7.  Let v be TimeClip(date).

8.  Set the [[DateValue]] internal slot of this Date object to v.

9.  Return v.

The LENGTH property of the SETUTCMINUTES method is 3.

NOTE If sec is not specified, this method behaves as if sec were
specified with the value GETUTCSECONDS(). If ms is not specified, it
function behaves as if ms were specified with the value return by
GETUTCMILLISECONDS().

Date.prototype.setUTCMonth ( month [ , date ] )

1.  Let t be this time value.

2.  ReturnIfAbrupt(t).

3.  Let m be ToNumber(month).

4.  If date is not specified, let dt be DateFromTime(t);
    otherwise, let dt be ToNumber(date).

5.  Let newDate be MakeDate(MakeDay(YearFromTime(t), m, dt),
    TimeWithinDay(t)).

6.  Let v be TimeClip(newDate).

7.  Set the [[DateValue]] internal slot of this Date object to v.

8.  Return v.

The LENGTH property of the SETUTCMONTH method is 2.

NOTE If date is not specified, this method behaves as if date were
specified with the value GETUTCDATE().

Date.prototype.setUTCSeconds ( sec [ , ms ] )

1.  Let t be this time value.

2.  ReturnIfAbrupt(t).

3.  Let s be ToNumber(sec).

4.  If ms is not specified, let milli be msFromTime(t); otherwise,
    let milli be ToNumber(ms).

5.  Let date be MakeDate(Day(t), MakeTime(HourFromTime(t),
    MinFromTime(t), s, milli)).

6.  Let v be TimeClip(date).

7.  Set the [[DateValue]] internal slot of this Date object to v.

8.  Return v.

The LENGTH property of the SETUTCSECONDS method is 2.

NOTE If ms is not specified, this method behaves as if ms were
specified with the value GETUTCMILLISECONDS().

Date.prototype.toDateString ( )

This function returns a String value. The contents of the String are
implementation-dependent, but are intended to represent the “date”
portion of the Date in the current time zone in a convenient,
human-readable form.

Date.prototype.toISOString ( )

This function returns a String value representing the instance in time
corresponding to this time value. The format of the String is the Date
Time string format defined in 20.3.1.15. All fields are present in the
String. The time zone is always UTC, denoted by the suffix Z. If this
time value is not a finite Number or if the year is not a value that can
be represented in that format (if necessary using extended year format),
a RANGEERROR exception is thrown.

Date.prototype.toJSON ( key )

This function provides a String representation of a Date object for use
by JSON.STRINGIFY (24.3.2).

When the TOJSON method is called with argument key, the following
steps are taken:

1.  Let O be the result of calling ToObject, giving it the THIS value
    as its argument.

2.  Let tv be ToPrimitive(O, hint Number).

3.  ReturnIfAbrupt(tv).

4.  If Type(tv) is Number and tv is not finite, return NULL.

5.  Return Invoke(O, "TOISOSTRING").

6.  7.  8.  

NOTE 1 The argument is ignored.

NOTE 2 The TOJSON function is intentionally generic; it does not require
that its THIS value be a Date object. Therefore, it can be transferred
to other kinds of objects for use as a method. However, it does require
that any such object have a TOISOSTRING method.

Date.prototype.toLocaleDateString ( [ reserved1 [ , reserved2 ] ] )

An ECMAScript implementation that includes the ECMA-402
Internationalization API must implement the
DATE.PROTOTYPE.TOLOCALEDATESTRING method as specified in the ECMA-402
specification. If an ECMAScript implementation does not include the
ECMA-402 API the following specification of the TOLOCALEDATESTRING
method is used.

This function returns a String value. The contents of the String are
implementation-dependent, but are intended to represent the “date”
portion of the Date in the current time zone in a convenient,
human-readable form that corresponds to the conventions of the host
environment’s current locale.

The meaning of the optional parameters to this method are defined in the
ECMA-402 specification; implementations that do not include ECMA-402
support must not use those parameter positions for anything else.

The LENGTH property of the TOLOCALEDATESTRING method is 0.

Date.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] )

An ECMAScript implementation that includes the ECMA-402
Internationalization API must implement the
DATE.PROTOTYPE.TOLOCALESTRING method as specified in the ECMA-402
specification. If an ECMAScript implementation does not include the
ECMA-402 API the following specification of the TOLOCALESTRING method is
used.

This function returns a String value. The contents of the String are
implementation-dependent, but are intended to represent the Date in the
current time zone in a convenient, human-readable form that corresponds
to the conventions of the host environment’s current locale.

The meaning of the optional parameters to this method are defined in the
ECMA-402 specification; implementations that do not include ECMA-402
support must not use those parameter positions for anything else.

The LENGTH property of the TOLOCALESTRING method is 0.

Date.prototype.toLocaleTimeString ( [ reserved1 [ , reserved2 ] ] )

An ECMAScript implementation that includes the ECMA-402
Internationalization API must implement the
DATE.PROTOTYPE.TOLOCALETIMESTRING method as specified in the ECMA-402
specification. If an ECMAScript implementation does not include the
ECMA-402 API the following specification of the TOLOCALESTRING method is
used.

This function returns a String value. The contents of the String are
implementation-dependent, but are intended to represent the “time”
portion of the Date in the current time zone in a convenient,
human-readable form that corresponds to the conventions of the host
environment’s current locale.

The meaning of the optional parameters to this method are defined in the
ECMA-402 specification; implementations that do not include ECMA-402
support must not use those parameter positions for anything else.

The LENGTH property of the TOLOCALETIMESTRING method is 0.

Date.prototype.toString ( )

The following steps are performed:

1.  Let O be this Date object.

2.  If O does not have a [[DateValue]] internal slot, then

    a.  Let tv be NaN.

3.  Else,

    a.  Let tv be this time value.

4.  Return ToDateString(tv).

NOTE For any Date object d whose milliseconds amount is zero, the
result of Date.parse(d.toString()) is equal to d.valueOf(). See
20.3.3.2.

Runtime Semantics: ToDateString(tv) Abstract Operation

1.  Assert: Type(tv) is Number.

2.  If tv is NaN, return "INVALID DATE".

3.  Return an implementation-dependent String value that represents tv
    as a date and time in the current time zone using a convenient,
    human-readable form.

Date.prototype.toTimeString ( )

This function returns a String value. The contents of the String are
implementation-dependent, but are intended to represent the “time”
portion of the Date in the current time zone in a convenient,
human-readable form.

 Date.prototype.toUTCString ( )

This function returns a String value. The contents of the String are
implementation-dependent, but are intended to represent this time value
in a convenient, human-readable form in UTC.

NOTE The intent is to produce a String representation of a date that is
more readable than the format specified in 20.3.1.15. It is not
essential that the chosen format be unambiguous or easily machine
parsable. If an implementation does not have a preferred human-readable
format it is recommended to use the format defined in 20.3.1.15 but with
a space rather than a “T” used to separate the date and time elements.

Date.prototype.valueOf ( )

The VALUEOF function returns a Number, which is this time value.

Date.prototype [ @@toPrimitive ] ( hint )

This function is called by ECMAScript language operators to convert an
object to a primitive value. The allowed values for hint are
"DEFAULT", "NUMBER", and "STRING". Date objects, are unique among
built-in ECMAScript object in that they treat "DEFAULT" as being
equivalent to "STRING", All other built-in ECMAScript objects treat
"DEFAULT" as being equivalent to "NUMBER".

When the @@TOPRIMITIVE method is called with argument hint, the
following steps are taken:

1.  Let O be the THIS value.

2.  If Type(O) is not Object, throw a TYPEERROR exception.

3.  If hint is the string value "STRING" or the string value "DEFAULT"
    , then

    a.  Let tryFirst be "STRING".

4.  Else if hint is the string value "NUMBER", then

5.  a.  Let tryFirst be "NUMBER".

6.  Else, throw a TYPEERROR exception.

7.  Return the result of OrdinaryToPrimitive(O, tryFirst).

The value of the NAME property of this function is
"[SYMBOL.TOPRIMITIVE]".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Properties of Date Instances

Date instances are ordinary objects that inherit properties from the
Date prototype object. Date instances also have a [[DateValue]] internal
slot. The [[DateValue]] internal slot is the time value represented by
this Date object.



 TEXT PROCESSING 


String Objects

The String Constructor 

The String constructor is the %String% intrinsic object and the initial
value of the STRING property of the global object. When called as a
constructor it creates and initializes a new String object. When STRING
is called as a function rather than as a constructor, it performs a type
conversion.

The STRING constructor is designed to be subclassable. It may be used as
the value of an EXTENDS clause of a class definition. Subclass
constructors that intend to inherit the specified STRING behaviour must
include a SUPER call to the STRING constructor to create and initialize
the subclass instance with a [[StringData]] internal slot.

String ( value )

When STRING is called with argument value, the following steps are
taken:

1.  2.  a.  

3.  4.  If no arguments were passed to this function invocation, let s
    be "".

5.  Else,

    a.  If NewTarget is UNDEFINED and Type(value) is Symbol, return
        SymbolDescriptiveString(value).

    b.  Let s be ToString(value).

6.  ReturnIfAbrupt(s).

7.  If NewTarget is UNDEFINED, return s.

8.  Return StringCreate(s, GetPrototypeFromConstructor(NewTarget,
    "%STRINGPROTOTYPE%")).

9.  10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 

The LENGTH property of the STRING function is 1.

1.  2.  3.  

Properties of the String Constructor

The value of the [[Prototype]] internal slot of the String constructor
is the intrinsic object %FunctionPrototype% (19.2.3).

1.  2.  3.  

Besides the LENGTH property (whose value is 1), the String constructor
has the following properties:

String.fromCharCode ( ...codeUnits )

The STRING.FROMCHARCODE function may be called with any number of
arguments which form the rest parameter codeUnits. The following steps
are taken:

1.  Let codeUnits is be a List containing the arguments passed to this
    function.

2.  Let length be the number of elements in codeUnits.

3.  Let elements be a new List.

4.  Let nextIndex be 0.

5.  Repeat while nextIndex < length

    a.  Let next be codeUnits_[_nextIndex].

    b.  Let nextCU be ToUint16(next).

    c.  ReturnIfAbrupt(nextCU).

    d.  Append nextCU to the end of elements.

    e.  Let nextIndex be nextIndex + 1.

6.  Return the String value whose elements are, in order, the elements
    in the List elements. If length is 0, the empty string is
    returned.

The LENGTH property of the FROMCHARCODE function is 1.

String.fromCodePoint ( ...codePoints )

The STRING.FROMCODEPOINT function may be called with any number of
arguments which form the rest parameter codePoints. The following
steps are taken:

1.  Let codePoints be a List containing the arguments passed to this
    function.

2.  Let length be number of elements in codePoints.

3.  Let elements be a new List.

4.  Let nextIndex be 0.

5.  Repeat while nextIndex < length

    a.  Let next be codePoints_[_nextIndex].

    b.  Let nextCP be ToNumber(next).

    c.  ReturnIfAbrupt(nextCP).

    d.  If SameValue(nextCP, ToInteger(nextCP)) is FALSE, throw a
        RANGEERROR exception.

    e.  If nextCP < 0 or nextCP > 0x10FFFF, throw a RANGEERROR
        exception.

    f.  Append the elements of the UTF-16Encoding (10.1.1) of nextCP
        to the end of elements.

    g.  Let nextIndex be nextIndex + 1.

6.  Return the String value whose elements are, in order, the elements
    in the List elements. If length is 0, the empty string is
    returned.

The LENGTH property of the FROMCODEPOINT function is 1.

String.prototype

The initial value of STRING.PROTOTYPE is the intrinsic object
%StringPrototype% (21.1.3).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

String.raw ( template , ...substitutions )

The STRING.RAW function may be called with a variable number of
arguments. The first argument is template and the remainder of the
arguments form the List substitutions. The following steps are taken:

1.  Let substitutions be a List consisting of all of the arguments
    passed to this function, starting with the second argument. If fewer
    than two arguments were passed, the List is empty.

2.  Let numberOfSubstitutions be the number of elements in
    substitutions.

3.  Let cooked be ToObject(template).

4.  ReturnIfAbrupt(cooked).

5.  Let rawValue be the result of Get(cooked, "RAW").

6.  Let raw be ToObject(rawValue).

7.  ReturnIfAbrupt(raw).

8.  Let literalSegments be the result of ToLength(Get(raw,
    "LENGTH")).

9.  10. ReturnIfAbrupt(literalSegments).

11. If literalSegments ≤ 0, return the empty string.

12. Let stringElements be a new List.

13. Let nextIndex be 0.

14. Repeat

15. a.  Let nextKey be ToString(nextIndex).

    b.  Let next be the result of Get(raw, nextKey).

    c.  Let nextSeg be ToString(next).

    d.  ReturnIfAbrupt(nextSeg).

    e.  Append in order the code unit elements of nextSeg to the end
        of stringElements.

    f.  If nextIndex + 1 = literalSegments, then

        i.  Return the string value whose code units are, in order, the
            elements in the List stringElements. If stringElements
            has no elements, the empty string is returned.

    g.  If nextIndex< numberOfSubstitutions, let next be
        substitutions_[_nextIndex].

    h.  Else, let next is the empty String.

    i.  Let nextSub be ToString(next).

    j.  ReturnIfAbrupt(nextSub).

    k.  Append in order the code unit elements of nextSub to the end
        of stringElements.

    l.  Let nextIndex be nextIndex + 1.

The LENGTH property of the RAW function is 1.

NOTE String.raw is intended for use as a tag function of a Tagged
Template (12.3.7). When called as such, the first argument will be a
well formed template object and the rest parameter will contain the
substitution values.

1.  2.  3.  4.  5.  

Properties of the String Prototype Object

The String prototype object is itself an ordinary object. It is not a
String instance and does not have a [[StringData]] internal slot.

The value of the [[Prototype]] internal slot of the String prototype
object is the intrinsic object %ObjectPrototype% (19.1.3).

Unless explicitly stated otherwise, the methods of the String prototype
object defined below are not generic and the THIS value passed to them
must be either a String value or an object that has a [[StringData]]
internal slot that has been initialized to a String value.

The abstract operation thisStringValue(value) performs the following
steps:

1.  If Type(value) is String, return value.

2.  If Type(value) is Object and value has a [[StringData]] internal
    slot, then

    a.  Assert: value’s [[StringData]] internal slot is a String
        value.

    b.  Return the value of value’s [[StringData]] internal slot.

    c.  

3.  Throw a TYPEERROR exception.

The phrase “this String value” within the specification of a method
refers to the result returned by calling the abstract operation
thisStringValue with the THIS value of the method invocation passed as
the argument.

String.prototype.charAt ( pos )

NOTE Returns a single element String containing the code unit at index
pos in the String value resulting from converting this object to a
String. If there is no element at that index, the result is the empty
String. The result is a String value, not a String object.

If pos is a value of Number type that is an integer, then the result
of X.CHARAT(pos) is equal to the result of X.SUBSTRING(pos,
pos+1).

When the CHARAT method is called with one argument pos, the following
steps are taken:

1.  Let O be RequireObjectCoercible(THIS value).

2.  Let S be ToString(O).

3.  ReturnIfAbrupt(S).

4.  Let position be ToInteger(pos).

5.  ReturnIfAbrupt(position).

6.  Let size be the number of elements in S.

7.  If position < 0 or position ≥ size, return the empty String.

8.  Return a String of length 1, containing one code unit from S,
    namely the code unit at index position.

NOTE The CHARAT function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

String.prototype.charCodeAt ( pos )

NOTE Returns a Number (a nonnegative integer less than 2^16^) that is
the code unit value of the string element at index pos in the String
resulting from converting this object to a String. If there is no
element at that index, the result is NAN.

When the CHARCODEAT method is called with one argument pos, the
following steps are taken:

1.  Let O be RequireObjectCoercible(THIS value).

2.  Let S be ToString(O).

3.  ReturnIfAbrupt(S).

4.  Let position be ToInteger(pos).

5.  ReturnIfAbrupt(position).

6.  Let size be the number of elements in S.

7.  If position < 0 or position ≥ size, return NAN.

8.  Return a value of Number type, whose value is the code unit value of
    the element at index position in the String S.

NOTE The CHARCODEAT function is intentionally generic; it does not
require that its THIS value be a String object. Therefore it can be
transferred to other kinds of objects for use as a method.

String.prototype.codePointAt ( pos )

NOTE Returns a nonnegative integer Number less than 1114112 (0x110000)
that is the code point value of the UTF-16 encoded code point (6.1.4)
starting at the string element at index pos in the String resulting
from converting this object to a String. If there is no element at that
index, the result is UNDEFINED. If a valid UTF-16 surrogate pair does
not begin at pos, the result is the code unit at pos.

When the CODEPOINTAT method is called with one argument pos, the
following steps are taken:

1.  Let O be RequireObjectCoercible(THIS value).

2.  Let S be ToString(O).

3.  ReturnIfAbrupt(S).

4.  Let position be ToInteger(pos).

5.  ReturnIfAbrupt(position).

6.  Let size be the number of elements in S.

7.  If position < 0 or position ≥ size, return UNDEFINED.

8.  Let first be the code unit value of the element at index
    position in the String S.

9.  If first < 0xD800 or first > 0xDBFF or position+1 = size,
    return first.

10. Let second be the code unit value of the element at index
    position+1 in the String S.

11. If second < 0xDC00 or second > 0xDFFF, return first.

12. Return ((first – 0xD800) × 1024) + (second – 0xDC00) + 0x10000.

NOTE The CODEPOINTAT function is intentionally generic; it does not
require that its THIS value be a String object. Therefore it can be
transferred to other kinds of objects for use as a method.

String.prototype.concat ( ...args )

NOTE When the CONCAT method is called it returns a String consisting of
the code units of the THIS object (converted to a String) followed by
the code units of each of the arguments converted to a String. The
result is a String value, not a String object.

When the CONCAT method is called with zero or more arguments the
following steps are taken:

1.  2.  Let O be RequireObjectCoercible(THIS value).

3.  Let S be ToString(O).

4.  ReturnIfAbrupt(S).

5.  Let args be a List whose elements are the arguments passed to this
    function.

6.  Let R be S.

7.  Repeat, while args is not empty

    a.  Remove the first element from args and let next be the value
        of that element.

    b.  Let nextString be ToString(next)

    c.  ReturnIfAbrupt(nextString).

    d.  Let R be the String value consisting of the code units of the
        previous value of R followed by the code units of
        nextString.

8.  Return R.

The LENGTH property of the CONCAT method is 1.

NOTE The CONCAT function is intentionally generic; it does not require
that its THIS value be a String object. Therefore it can be transferred
to other kinds of objects for use as a method.

String.prototype.constructor

The initial value of STRING.PROTOTYPE.CONSTRUCTOR is the intrinsic
object %String%.

String.prototype.endsWith ( searchString [ , endPosition] )

The following steps are taken:

1.  Let O be RequireObjectCoercible(THIS value).

2.  Let S be ToString(O).

3.  ReturnIfAbrupt(S).

4.  5.  Let isRegExp be IsRegExp(searchString).

6.  ReturnIfAbrupt(isRegExp).

7.  If isRegExp is TRUE, throw a TYPEERROR exception.

8.  Let searchStr be ToString(searchString).

9.  ReturnIfAbrupt(searchStr).

10. Let len be the number of elements in S.

11. If endPosition is UNDEFINED, let pos be len, else let pos be
    ToInteger(endPosition).

12. 13. ReturnIfAbrupt(pos).

14. Let end be min(max(pos, 0), len).

15. Let searchLength be the number of elements in searchStr.

16. Let start be end - searchLength.

17. If start is less than 0, return FALSE.

18. 19. If the searchLength sequence of elements of S starting at
    start is the same as the full element sequence of searchStr,
    return TRUE.

20. Otherwise, return FALSE.

The LENGTH property of the ENDSWITH method is 1.

NOTE 1 Returns TRUE if the sequence of elements of searchString
converted to a String is the same as the corresponding elements of this
object (converted to a String) starting at endPosition – length(this).
Otherwise returns FALSE.

NOTE 2 Throwing an exception if the first argument is a RegExp is
specified in order to allow future editions to define extends that allow
such argument values.

NOTE 3 The ENDSWITH function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

String.prototype.includes ( searchString [ , position ] )

The INCLUDES method takes two arguments, searchString and position,
and performs the following steps:

1.  Let O be RequireObjectCoercible(THIS value).

2.  Let S be ToString(O).

3.  ReturnIfAbrupt(S).

4.  5.  Let isRegExp be IsRegExp(searchString).

6.  ReturnIfAbrupt(isRegExp).

7.  If isRegExp is TRUE, throw a TYPEERROR exception.

8.  Let searchStr be ToString(searchString).

9.  ReturnIfAbrupt(searchStr).

10. Let pos be ToInteger(position). (If position is UNDEFINED,
    this step produces the value 0).

11. ReturnIfAbrupt(pos).

12. Let len be the number of elements in S.

13. Let start be min(max(pos, 0), len).

14. Let searchLen be the number of elements in searchStr.

15. If there exists any integer k not smaller than start such that
    k + searchLen is not greater than len, and for all nonnegative
    integers j less than searchLen, the code unit at index k_+_j
    of S is the same as the code unit at index j of searchStr,
    return TRUE; but if there is no such integer k, return FALSE.

The LENGTH property of the INCLUDES method is 1.

NOTE 1 If searchString appears as a substring of the result of
converting this object to a String, at one or more indices that are
greater than or equal to position, return TRUE; otherwise, returns
FALSE. If position is UNDEFINED, 0 is assumed, so as to search all of
the String.

NOTE 2 Throwing an exception if the first argument is a RegExp is
specified in order to allow future editions to define extensions that
allow such argument values.

NOTE 3 The INCLUDES function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

String.prototype.indexOf ( searchString [ , position ] )

NOTE If searchString appears as a substring of the result of
converting this object to a String, at one or more indices that are
greater than or equal to position, then the smallest such index is
returned; otherwise, 1 is returned. If position is UNDEFINED, 0 is
assumed, so as to search all of the String.

The INDEXOF method takes two arguments, searchString and position,
and performs the following steps:

1.  Let O be RequireObjectCoercible(THIS value).

2.  Let S be ToString(O).

3.  ReturnIfAbrupt(S).

4.  Let searchStr be ToString(searchString).

5.  ReturnIfAbrupt(searchStr).

6.  Let pos be ToInteger(position). (If position is UNDEFINED,
    this step produces the value 0).

7.  ReturnIfAbrupt(pos).

8.  Let len be the number of elements in S.

9.  Let start be min(max(pos, 0), len).

10. Let searchLen be the number of elements in searchStr.

11. Return the smallest possible integer k not smaller than start
    such that k+ searchLen is not greater than len, and for all
    nonnegative integers j less than searchLen, the code unit at
    index k_+_j of S is the same as the code unit at index j of
    searchStr; but if there is no such integer k, return the value
    -1.

The LENGTH property of the INDEXOF method is 1.

NOTE The INDEXOF function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

String.prototype.lastIndexOf ( searchString [ , position ] )

NOTE If searchString appears as a substring of the result of
converting this object to a String at one or more indices that are
smaller than or equal to position, then the greatest such index is
returned; otherwise, 1 is returned. If position is UNDEFINED, the
length of the String value is assumed, so as to search all of the
String.

The LASTINDEXOF method takes two arguments, searchString and
position, and performs the following steps:

1.  Let O be RequireObjectCoercible(THIS value).

2.  Let S be ToString(O).

3.  ReturnIfAbrupt(S).

4.  Let searchStr be ToString(searchString).

5.  ReturnIfAbrupt(searchString).

6.  Let numPos be ToNumber(position). (If position is UNDEFINED,
    this step produces the value NAN).

7.  ReturnIfAbrupt(numPos).

8.  If numPos is NAN, let pos be +∞; otherwise, let pos be
    ToInteger(numPos).

9.  Let len be the number of elements in S.

10. Let start be min(max(pos, 0), len).

11. Let searchLen be the number of elements in searchStr.

12. Return the largest possible nonnegative integer k not larger than
    start such that k+ searchLen is not greater than len, and
    for all nonnegative integers j less than searchLen, the code
    unit at index k_+_j of S is the same as the code unit at index
    j of searchStr; but if there is no such integer k, return the
    value -1.

The LENGTH property of the LASTINDEXOF method is 1.

NOTE The LASTINDEXOF function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

String.prototype.localeCompare ( that [, reserved1 [ , reserved2 ] ] )

An ECMAScript implementation that includes the ECMA-402
Internationalization API must implement the LOCALECOMPARE method as
specified in the ECMA-402 specification. If an ECMAScript implementation
does not include the ECMA-402 API the following specification of the
LOCALECOMPARE method is used.

When the LOCALECOMPARE method is called with argument that, it returns
a Number other than NAN that represents the result of a locale-sensitive
String comparison of the THIS value (converted to a String) with that
(converted to a String). The two Strings are S and That. The two
Strings are compared in an implementation-defined fashion. The result is
intended to order String values in the sort order specified by a host
default locale, and will be negative, zero, or positive, depending on
whether S comes before That in the sort order, the Strings are
equal, or S comes after That in the sort order, respectively.

Before perform the comparisons the following steps are performed to
prepare the Strings:

1.  Let O be RequireObjectCoercible(THIS value).

2.  Let S be ToString(O).

3.  ReturnIfAbrupt(S).

4.  Let That be ToString(that).

5.  ReturnIfAbrupt(That).

The meaning of the optional second and third parameters to this method
are defined in the ECMA-402 specification; implementations that do not
include ECMA-402 support must not assign any other interpretation to
those parameter positions.

The LOCALECOMPARE method, if considered as a function of two arguments
THIS and that, is a consistent comparison function (as defined in
22.1.3.24) on the set of all Strings.

The actual return values are implementation-defined to permit
implementers to encode additional information in the value, but the
function is required to define a total ordering on all Strings. This
function must treat Strings that are canonically equivalent according to
the Unicode standard as identical and must return 0 when comparing
Strings that are considered canonically equivalent.

The LENGTH property of the LOCALECOMPARE method is 1.

NOTE 1 The LOCALECOMPARE method itself is not directly suitable as an
argument to ARRAY.PROTOTYPE.SORT because the latter requires a function
of two arguments.

NOTE 2 This function is intended to rely on whatever language-sensitive
comparison functionality is available to the ECMAScript environment from
the host environment, and to compare according to the rules of the host
environment’s current locale. However, regardless of the host provided
comparison capabilities, this function must treat Strings that are
canonically equivalent according to the Unicode standard as identical.
It is recommended that this function not honour Unicode compatibility
equivalences or decompositions. For a definition and discussion of
canonical equivalence see the Unicode Standard, chapters 2 and 3, as
well as Unicode Annex #15, Unicode Normalization Forms and Unicode
Technical Note #5 Canonical Equivalence in Applications. Also see
Unicode Technical Standard #10, Unicode Collation Algorithm.

NOTE 3 The LOCALECOMPARE function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

String.prototype.match ( regexp )

When the MATCH method is called with argument regexp, the following
steps are taken:

1.  Let O be RequireObjectCoercible(THIS value).

2.  Let S be ToString(O).

3.  ReturnIfAbrupt(S).

4.  If regexp is not UNDEFINED, then

    a.  Let matcher be GetMethod(regexp, @@match).

    b.  ReturnIfAbrupt(matcher).

    c.  If matcher is not UNDEFINED, then

        i.  Return Call(matcher, regexp, «‍S»).

5.  Let rx be RegExpCreate(regexp, UNDEFINED) (see 21.2.3.3.3).

6.  ReturnIfAbrupt(rx).

7.  8.  Return Invoke(rx, @@match, «‍S»).

NOTE The MATCH function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

String.prototype.normalize ( [ form ] )

When the NORMALIZE method is called with one argument form, the
following steps are taken:

1.  Let O be RequireObjectCoercible(THIS value).

2.  Let S be ToString(O).

3.  ReturnIfAbrupt(S).

4.  If form is not provided or form is UNDEFINED let form be
    "NFC".

5.  Let f be ToString(form).

6.  ReturnIfAbrupt(f).

7.  If f is not one of "NFC", "NFD", "NFKC", or "NFKD", throw a
    RANGEERROR Exception.

8.  Let ns be the String value is the result of normalizing S into
    the normalization form named by f as specified in Unicode
    Standard Annex #15, Unicode Normalization Forms.

9.  Return ns.

The LENGTH property of the NORMALIZE method is 0.

NOTE The NORMALIZE function is intentionally generic; it does not
require that its THIS value be a String object. Therefore it can be
transferred to other kinds of objects for use as a method.

String.prototype.repeat ( count )

The following steps are taken:

1.  Let O be RequireObjectCoercible(THIS value).

2.  Let S be ToString(O).

3.  ReturnIfAbrupt(S).

4.  Let n be ToInteger(count).

5.  ReturnIfAbrupt(n).

6.  If n < 0, throw a RANGEERROR exception.

7.  If n is +∞, throw a RANGEERROR exception.

8.  Let T be a String value that is made from n copies of S
    appended together. If n is 0, T is the empty String.

9.  Return T.

NOTE 1 This method creates a String consisting of the code units of the
THIS object (converted to String) repeated count times.

NOTE 2 The REPEAT function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

String.prototype.replace (searchValue, replaceValue )

When the REPLACE method is called with arguments searchValue and
replaceValue the following steps are taken:

1.  Let O be RequireObjectCoercible(THIS value).

2.  Let string be ToString(O).

3.  ReturnIfAbrupt(string).

4.  If searchValue is not UNDEFINED, then

    a.  Let replacer be GetMethod(searchValue, @@replace).

    b.  ReturnIfAbrupt(replacer).

    c.  If replacer is not UNDEFINED, then

    d.  i.  Return Call(replacer, searchValue, «‍string,
            replaceValue»).

5.  Let searchString be ToString(searchValue).

6.  7.  ReturnIfAbrupt(searchString).

8.  Let functionalReplace be IsCallable(replaceValue).

9.  If functionReplace is FALSE, then

    a.  Let replaceValue be ToString(replaceValue).

    b.  ReturnIfAbrupt(replaceValue).

10. Search string for the first occurrence of searchString and let
    pos be the index within string of the first code unit of the
    matched substring and let matched be searchString. If no
    occurrences of searchString were found, return string.

11. If functionalReplace is TRUE, then

    a.  Let replValue be Call(replaceValue, UNDEFINED,«matched,
        pos, and string»).

    b.  Let replStr be ToString(replValue).

    c.  ReturnIfAbrupt(replStr).

12. Else,

    a.  Let captures be an empty List.

    b.  c.  d.  Let replStr be GetReplaceSubstitution(matched,
        string, pos, captures, replaceValue).

13. Let tailPos be pos + the number of code units in matched.

14. 15. Let newString be the String formed by concatenating the first
    pos code units of string, replStr, and the trailing substring
    of string starting at index tailPos. If pos is 0, the first
    element of the concatenation will be the empty String.

16. 17. Return newString.

NOTE The REPLACE function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

Runtime Semantics: GetReplaceSubstitution Abstract Operation

The abstract operation GetReplaceSubstitution(matched, string,
position, captures, replacement) performs the following steps:

1.  Assert: Type(matched) is String.

2.  Let matchLength be the number of code units in matched.

3.  Assert: Type(string) is String.

4.  Let stringLength be the number of code units in string.

5.  Assert: position is a nonnegative integer.

6.  Assert: position ≤ stringLength.

7.  Assert: captures is a possibly empty List of Strings.

8.  Assert:Type( replacement) is String

9.  Let tailPos be position + matchLength.

10. Let m be the number of elements in captures.

11. Let result be a String value derived from replacement by copying
    code unit elements from replacement to result while performing
    replacements as specified in Table 42. These $ replacements are done
    left-to-right, and, once such a replacement is performed, the new
    replacement text is not subject to further replacements.

12. Return result.

Table 42 — Replacement Text Symbol Substitutions

  --------------------- ------------------------------------------------------------------------- ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  Code units            Unicode Characters                                                        Replacement text

  0x0024, 0x0024        $$                                                                        $

  0x0024, 0x0026        $&                                                                        matched

  0x0024, 0x0060        $`                                                                        If position is 0, the replacement is the empty String. Otherwise the replacement is the substring of string that starts at index 0 and whose last code point is at index position -1.

  0x0024, 0x0027        $'                                                                        If tailPos ≥ stringLength, the replacement is the empty String. Otherwise the replacement is the substring of string that starts at index tailPos and continues to the end of string.

  0x0024, N where       $N where                                                                  The n^th^ element of captures, where n is a single digit in the range 1 to 9. If n_≤_m and the nth element of captures is UNDEFINED, use the empty String instead. If n_>_m, the result is implementation-defined.
  0x0031 ≤ N ≤ 0x0039   N is one of 1 2 3 4 5 6 7 8 9 and $N is not followed by a decimal digit   

  0x0024, N, N where    $NN where                                                                 The nn^th^ element of captures, where nn is a two-digit decimal number in the range 01 to 99. If nn_≤_m and the nn^th^ element of captures is UNDEFINED, use the empty String instead. If nn is 00 or nn_>_m, the result is implementation-defined.
  0x0030 ≤ N ≤ 0x0039   N is one of 0 1 2 3 4 5 6 7 8 9                                           

  0x0024                $ in any context that does not match any of the above.                    $
  --------------------- ------------------------------------------------------------------------- ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

String.prototype.search ( regexp )

When the search method is called with argument regexp, the following
steps are taken:

1.  Let O be RequireObjectCoercible(THIS value).

2.  Let string be ToString(O).

3.  ReturnIfAbrupt(string).

4.  If regexp is not UNDEFINED, then

    a.  Let searcher be GetMethod(regexp, @@search).

    b.  ReturnIfAbrupt(searcher).

    c.  If searcher is not UNDEFINED , then

        i.  Return Call(searcher, regexp, «‍string»)

5.  6.  Let rx be RegExpCreate(regexp, UNDEFINED) (see 21.2.3.3).

7.  ReturnIfAbrupt(rx).

8.  Return Invoke(rx, @@search, «‍string»).

NOTE The SEARCH function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

String.prototype.slice ( start, end )

The SLICE method takes two arguments, start and end, and returns a
substring of the result of converting this object to a String, starting
from index start and running to, but not including, index end (or
through the end of the String if end is UNDEFINED). If start is
negative, it is treated as sourceLength_+_start where sourceLength
is the length of the String. If end is negative, it is treated as
sourceLength_+_end where sourceLength is the length of the String.
The result is a String value, not a String object. The following steps
are taken:

1.  Let O be RequireObjectCoercible(THIS value).

2.  Let S be ToString(O).

3.  ReturnIfAbrupt(S).

4.  Let len be the number of elements in S.

5.  Let intStart be ToInteger(start).

6.  ReturnIfAbrupt(intStart).

7.  If end is UNDEFINED, let intEnd be len; else let intEnd be
    ToInteger(end).

8.  ReturnIfAbrupt(intEnd).

9.  If intStart < 0, let from be max(len + intStart,0);
    otherwise let from be min(intStart, len).

10. If intEnd < 0, let to be max(len + intEnd,0); otherwise let
    to be min(intEnd, len).

11. Let span be max(to – from,0).

12. Return a String value containing span consecutive elements from
    S beginning with the element at index from.

The LENGTH property of the SLICE method is 2.

NOTE The SLICE function is intentionally generic; it does not require
that its THIS value be a String object. Therefore it can be transferred
to other kinds of objects for use as a method.

String.prototype.split ( separator, limit )

Returns an Array object into which substrings of the result of
converting this object to a String have been stored. The substrings are
determined by searching from left to right for occurrences of
separator; these occurrences are not part of any substring in the
returned array, but serve to divide up the String value. The value of
separator may be a String of any length or it may be a RegExp object.

When the SPLIT method is called, the following steps are taken:

1.  Let O be RequireObjectCoercible(THIS value).

2.  ReturnIfAbrupt(O).

3.  If separator is not UNDEFINED, then

    a.  Let splitter be GetMethod(separator, @@split).

    b.  ReturnIfAbrupt(splitter).

    c.  If splitter is not UNDEFINED , then

        i.  Return Call(splitter, separator, «‍O, limit»).

4.  Let S be ToString(O).

5.  ReturnIfAbrupt(S).

6.  Let A be ArrayCreate(0).

7.  Let lengthA be 0.

8.  If limit is UNDEFINED, let lim = 2^53^–1; else let lim =
    ToLength(limit).

9.  ReturnIfAbrupt(lim).

10. Let s be the number of elements in S.

11. Let p = 0.

12. Let R be ToString(separator).

13. ReturnIfAbrupt(R).

14. If lim = 0, return A.

15. If separator is UNDEFINED, then

    a.  Call CreateDataProperty(A, "0", S).

    b.  Assert: The above call will never result in an abrupt
        completion.

    c.  Return A.

16. If s = 0, then

    a.  Let z be the result of SplitMatch(S, 0, R).

    b.  If z is not FALSE, return A.

    c.  Call CreateDataProperty(A, "0", S).

    d.  Assert: The above call will never result in an abrupt
        completion.

    e.  Return A.

17. Let q = p.

18. Repeat, while q ≠ s

    a.  Let e be the result of SplitMatch(_S, q, R_).

    b.  If e is FALSE, let q = q+1.

    c.  Else e is an integer index into S,

        i.  If e = p, let q = q+1.

        ii. Else e ≠ p,

            1.  Let T be a String value equal to the substring of S
                consisting of the code units at indices p (inclusive)
                through q (exclusive).

            2.  Call CreateDataProperty(A, ToString(lengthA), T).

            3.  Assert: The above call will never result in an abrupt
                completion.

            4.  Increment lengthA by 1.

            5.  If lengthA = lim, return A.

            6.  Let p = e.

            7.  Let q = p.

19. Let T be a String value equal to the substring of S consisting
    of the code units at indices p (inclusive) through s
    (exclusive).

20. Call CreateDataProperty(A, ToString(lengthA), T).

21. Assert: The above call will never result in an abrupt completion.

22. Return A.

The LENGTH property of the SPLIT method is 2.

NOTE 1 The value of separator may be an empty String, an empty regular
expression, or a regular expression that can match an empty String. In
this case, separator does not match the empty substring at the
beginning or end of the input String, nor does it match the empty
substring at the end of the previous separator match. (For example, if
separator is the empty String, the String is split up into individual
code unit elements; the length of the result array equals the length of
the String, and each substring contains one code unit.) If separator
is a regular expression, only the first match at a given index of the
THIS String is considered, even if backtracking could yield a
non-empty-substring match at that index. (For example, "AB".SPLIT(/A*?/)
evaluates to the array ["A","B"], while "AB".SPLIT(/A*/) evaluates to
the array["","B"].)

If the THIS object is (or converts to) the empty String, the result
depends on whether separator can match the empty String. If it can,
the result array contains no elements. Otherwise, the result array
contains one element, which is the empty String.

If separator is a regular expression that contains capturing
parentheses, then each time separator is matched the results
(including any UNDEFINED results) of the capturing parentheses are
spliced into the output array. For example,

"A<B>BOLD</B>AND<CODE>CODED</CODE>".SPLIT(/<(\/)?([^<>]+)>/)

evaluates to the array

["A", UNDEFINED, "B", "BOLD", "/", "B", "AND", UNDEFINED,
 "CODE", "CODED", "/", "CODE", ""]

If separator is UNDEFINED, then the result array contains just one
String, which is the THIS value (converted to a String). If limit is
not UNDEFINED, then the output array is truncated so that it contains no
more than limit elements.

NOTE 2 The SPLIT function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

Runtime Semantics: SplitMatch Abstract Operation

The abstract operation SplitMatch takes three parameters, a String S,
an integer q, and a String R, and performs the following in order to
return either FALSE or the end index of a match:

1.  Assert: Type(R) is String.

2.  3.  Let r be the number of code units in R.

4.  Let s be the number of code units in S.

5.  If q_+_r > s, return FALSE.

6.  If there exists an integer i between 0 (inclusive) and r
    (exclusive) such that the code unit at index q_+_i of S is
    different from the code unit at index i of R, return FALSE.

7.  Return q_+_r.

8.  

String.prototype.startsWith ( searchString [, position ] )

The following steps are taken:

1.  Let O be RequireObjectCoercible(THIS value).

2.  Let S be ToString(O).

3.  ReturnIfAbrupt(S).

4.  5.  6.  7.  8.  Let isRegExp be IsRegExp(searchString).

9.  ReturnIfAbrupt(isRegExp).

10. If isRegExp is TRUE, throw a TYPEERROR exception.

11. Let searchStr be ToString(searchString).

12. ReturnIfAbrupt(searchString).

13. 14. 15. Let pos be ToInteger(position). (If position is
    UNDEFINED, this step produces the value 0).

16. ReturnIfAbrupt(pos).

17. Let len be the number of elements in S.

18. Let start be min(max(pos, 0), len).

19. Let searchLength be the number of elements in searchStr.

20. If searchLength+start is greater than len, return FALSE.

21. 22. If the searchLength sequence of elements of S starting at
    start is the same as the full element sequence of searchStr,
    return TRUE.

23. Otherwise, return FALSE.

The LENGTH property of the STARTSWITH method is 1.

NOTE 1 This method returns TRUE if the sequence of elements of
searchString converted to a String is the same as the corresponding
elements of this object (converted to a String) starting at index
position. Otherwise returns FALSE.

NOTE 2 Throwing an exception if the first argument is a RegExp is
specified in order to allow future editions to define extends that allow
such argument values.

NOTE 3 The STARTSWITH function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

String.prototype.substring ( start, end )

The SUBSTRING method takes two arguments, start and end, and returns
a substring of the result of converting this object to a String,
starting from index start and running to, but not including, index
end of the String (or through the end of the String is end is
UNDEFINED). The result is a String value, not a String object.

If either argument is NAN or negative, it is replaced with zero; if
either argument is larger than the length of the String, it is replaced
with the length of the String.

If start is larger than end, they are swapped.

The following steps are taken:

1.  Let O be RequireObjectCoercible(THIS value).

2.  Let S be ToString(O).

3.  ReturnIfAbrupt(S).

4.  Let len be the number of elements in S.

5.  Let intStart be ToInteger(start).

6.  ReturnIfAbrupt(intStart).

7.  If end is UNDEFINED, let intEnd be len; else let intEnd be
    ToInteger(end).

8.  ReturnIfAbrupt(intEnd).

9.  Let finalStart be min(max(intStart, 0), len).

10. Let finalEnd be min(max(intEnd, 0), len).

11. Let from be min(finalStart, finalEnd).

12. Let to be max(finalStart, finalEnd).

13. Return a String whose length is to - from, containing code units
    from S, namely the code units with indices from through to −1,
    in ascending order.

The LENGTH property of the SUBSTRING method is 2.

NOTE The SUBSTRING function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

String.prototype.toLocaleLowerCase ( [ reserved1 [ , reserved2 ] ] )

This function interprets a string value as a sequence of code points, as
described in 6.1.4.

This function works exactly the same as TOLOWERCASE except that its
result is intended to yield the correct result for the host
environment’s current locale, rather than a locale-independent result.
There will only be a difference in the few cases (such as Turkish) where
the rules for that language conflict with the regular Unicode case
mappings.

The LENGTH property of the TOLOCALELOWERCASE method is 0.

NOTE 1 The meaning of the optional first and second parameters to this
method is reserved for use by the ECMA-402 specification; it is
recommended that implementations do not use those parameter positions
for anything else.

NOTE 2 The TOLOCALELOWERCASE function is intentionally generic; it does
not require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

String.prototype.toLocaleUpperCase ([ reserved1 [ , reserved2 ] ] )

This function interprets a string value as a sequence of code points, as
described in 6.1.4.

This function works exactly the same as TOUPPERCASE except that its
result is intended to yield the correct result for the host
environment’s current locale, rather than a locale-independent result.
There will only be a difference in the few cases (such as Turkish) where
the rules for that language conflict with the regular Unicode case
mappings.

The LENGTH property of the TOLOCALEUPPERCASE method is 0.

NOTE 1 The meaning of the optional first and second parameters to this
method is reserved for use by the ECMA-402 specification; it is
recommended that implementations do not use those parameter positions
for anything else.

NOTE 2 The TOLOCALEUPPERCASE function is intentionally generic; it does
not require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

String.prototype.toLowerCase ( )

This function interprets a string value as a sequence of code points, as
described in 6.1.4. The following steps are taken:

1.  Let O be RequireObjectCoercible(THIS value).

2.  Let S be ToString(O).

3.  ReturnIfAbrupt(S).

4.  Let cpList be a List containing in order the code points as
    defined in 6.1.4 of S, starting at the first element of S.

5.  For each code point c in cpList, if the Unicode Character
    Database provides a language insensitive lower case equivalent of
    c then replace c in cpList with that equivalent code point(s).

6.  Let cuList be a new List.

7.  For each code point c in cpList, in order, append to cuList
    the elements of the UTF-16Encoding (10.1.1) of c.

8.  Let L be a String whose elements are, in order, the elements of
    cuList .

9.  Return L.

The result must be derived according to the locale-insensitive case
mappings in the Unicode Character Database (this explicitly includes not
only the UnicodeData.txt file, but also all locale-insensitive mappings
in the SpecialCasings.txt file that accompanies it).

NOTE 1 The case mapping of some code points may produce multiple code
points . In this case the result String may not be the same length as
the source String. Because both TOUPPERCASE and TOLOWERCASE have
context-sensitive behaviour, the functions are not symmetrical. In other
words, S.TOUPPERCASE().TOLOWERCASE() is not necessarily equal to
S.TOLOWERCASE().

NOTE 2 The TOLOWERCASE function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

String.prototype.toString ( )

When the TOSTRING method is called, the following steps are taken:

1.  Let s be thisStringValue(THIS value).

2.  Return s.

NOTE For a String object, the TOSTRING method happens to return the same
thing as the VALUEOF method.

String.prototype.toUpperCase ( )

This function interprets a string value as a sequence of code points, as
described in 6.1.4.

This function behaves in exactly the same way as
STRING.PROTOTYPE.TOLOWERCASE, except that code points are mapped to
their uppercase equivalents as specified in the Unicode Character
Database.

NOTE The TOUPPERCASE function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

String.prototype.trim ( )

This function interprets a string value as a sequence of code points, as
described in 6.1.4.

The following steps are taken:

1.  Let O be RequireObjectCoercible(THIS value).

2.  Let S be ToString(O).

3.  ReturnIfAbrupt(S).

4.  Let T be a String value that is a copy of S with both leading
    and trailing white space removed. The definition of white space is
    the union of WhiteSpace and LineTerminator. When determining
    whether a Unicode code point is in Unicode general category “Zs”,
    code unit sequences are interpreted as UTF-16 encoded code point
    sequences as specified in 6.1.4.

5.  Return T.

NOTE The TRIM function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

String.prototype.valueOf ( )

When the VALUEOF method is called, the following steps are taken:

1.  Let s be thisStringValue(THIS value).

2.  Return s.

String.prototype [ @@iterator ]( )

When the @@iterator method is called it returns an Iterator object
(25.1.1.2) that iterates over the code points of a String value,
returning each code point as a String value. The following steps are
taken:

The following steps are taken:

1.  Let O be RequireObjectCoercible(THIS value).

2.  Let S be ToString(O).

3.  ReturnIfAbrupt(S).

4.  Return CreateStringIterator(S).

The value of the NAME property of this function is "[SYMBOL.ITERATOR]".

Properties of String Instances

String instances are String exotic objects and have the internal methods
specified for such objects. String instances inherit properties from the
String prototype object. String instances also have a [[StringData]]
internal slot.

String instances have a LENGTH property, and a set of enumerable
properties with integer indexed names.

length

The number of elements in the String value represented by this String
object.

Once a String object is initialized, this property is unchanging. It has
the attributes { [[Writable]]: FALSE, [[Enumerable]]: FALSE,
[[Configurable]]: FALSE }.

String Iterator Objects 

An String Iterator is an object, that represents a specific iteration
over some specific String instance object. There is not a named
constructor for String Iterator objects. Instead, String iterator
objects are created by calling certain methods of String instance
objects.

CreateStringIterator Abstract Operation

Several methods of String objects return Iterator objects. The abstract
operation CreateStringIterator with argument string is used to create
such iterator objects. It performs the following steps:

1.  Assert: Type(string) is String.

2.  3.  Let iterator be the result of
    ObjectCreate(%StringIteratorPrototype%, «[[IteratedString]],
    [[StringIteratorNextIndex]] »).

4.  Set iterator’s [[IteratedString]] internal slot to string.

5.  Set iterator’s [[StringIteratorNextIndex]] internal slot to 0.

6.  Return iterator.

The %StringIteratorPrototype% Object

All String Iterator Objects inherit properties from the
%StringIteratorPrototype% intrinsic object. The
%StringIteratorPrototype% object is an ordinary object and its
[[Prototype]] internal slot is the %IteratorPrototype% intrinsic object
(25.1.2). In addition, %StringIteratorPrototype% has the following
properties:

%StringIteratorPrototype%.next ( )

1.  Let O be the THIS value.

2.  If Type(O) is not Object, throw a TYPEERROR exception.

3.  If O does not have all of the internal slots of an String Iterator
    Instance (21.1.5.3), throw a TYPEERROR exception.

4.  Let s be the value of the [[IteratedString]] internal slot of O.

5.  If s is UNDEFINED, return CreateIterResultObject(UNDEFINED, TRUE).

6.  Let position be the value of the [[StringIteratorNextIndex]]
    internal slot of O.

7.  Let len be the number of elements in s.

8.  If position ≥ len, then

    a.  Set the value of the [[IteratedString]] internal slot of O to
        UNDEFINED.

    b.  Return CreateIterResultObject(UNDEFINED, TRUE).

9.  Let first be the code unit value at index position in s.

10. If first < 0xD800 or first > 0xDBFF or position+1 = len, let
    resultString be the string consisting of the single code unit
    first.

11. Else,

12. a.  Let second be the code unit value at index position+1 in the
        String S.

    b.  If second < 0xDC00 or second > 0xDFFF, let resultString be
        the string consisting of the single code unit first.

    c.  Else, let resultString be the string consisting of the code
        unit first followed by the code unit second.

13. Let resultSize be the number of code units in resultString.

14. Set the value of the [[StringIteratorNextIndex]] internal slot of
    O to position+ resultSize.

15. Return CreateIterResultObject(resultString, FALSE).

1.  

%StringIteratorPrototype% [ @@toStringTag ]

The initial value of the @@toStringTag property is the string value
"STRING ITERATOR".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Properties of String Iterator Instances

String Iterator instances are ordinary objects that inherit properties
from the %StringIteratorPrototype% intrinsic object. String Iterator
instances are initially created with the internal slots listed in Table
45.

Table 43 — Internal Slots of String Iterator Instances

  ----------------------------- ------------------------------------------------------------------------------
  INTERNAL SLOT                 DESCRIPTION
  [[IteratedString]]            The String value whose elements are being iterated.
  [[StringIteratorNextIndex]]   The integer index of the next string index to be examined by this iteration.
  ----------------------------- ------------------------------------------------------------------------------


RegExp (Regular Expression) Objects

A RegExp object contains a regular expression and the associated flags.

NOTE The form and functionality of regular expressions is modelled after
the regular expression facility in the Perl 5 programming language.

Patterns

The REGEXP constructor applies the following grammar to the input
pattern String. An error occurs if the grammar cannot interpret the
String as an expansion of Pattern.

Syntax

Pattern~[U]~ ::

Disjunction~[?U]~

Disjunction~[U]~ ::

Alternative~[?U]~
 Alternative~[?U]~ | Disjunction~[?U]~

Alternative~[U]~ ::

[empty]
Alternative~[?U]~ Term~[?U]~

Term~[U]~ ::

Assertion~[?U]~
Atom~[?U]~
Atom~[?U]~ Quantifier

Assertion~[U]~ ::

^
$
\ B
\ B
( ? = Disjunction~[?U]~ )
( ? ! Disjunction~[?U]~ )

Quantifier ::

QuantifierPrefix
QuantifierPrefix ?

QuantifierPrefix ::

*
+
?
{ DecimalDigits }
{ DecimalDigits , }
{ DecimalDigits , DecimalDigits }

Atom~[U]~ ::

PatternCharacter
.
\ AtomEscape~[?U]~
CharacterClass~[?U]~
( Disjunction~[?U]~ )
( ? : Disjunction~[?U]~ )

SyntaxCharacter :: ONE OF

^ $ \ . * + ? ( ) [ ] { } |

PatternCharacter ::

SourceCharacter BUT NOT SyntaxCharacter

AtomEscape~[U]~ ::

DecimalEscape
CharacterEscape~[?U]~
CharacterClassEscape

CharacterEscape~[U]~ ::

ControlEscape
C ControlLetter
HexEscapeSequence
RegExpUnicodeEscapeSequence~[?U]~
IdentityEscape~[?U]~

ControlEscape :: ONE OF

F N R T V

ControlLetter :: ONE OF

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

RegExpUnicodeEscapeSequence~[U]~ ::

[+U] U LeadSurrogate \U TrailSurrogate
U Hex4Digits
[+U] U{ HexDigits }

-   It is a Syntax Error if the MV of HexDigits > 1114111.

-   

LeadSurrogate ::

Hex4Digits [match only if the SV of Hex4Digits is in the inclusive range
0xD800 to 0xDBFF]

TrailSurrogate ::

Hex4Digits [match only if the SV of Hex4Digits is in the inclusive range
0xDC00 to 0xDFFF]

IdentityEscape~[U]~ ::

[+U] SyntaxCharacter
[~U] SourceCharacter BUT NOT UnicodeIDContinue

DecimalEscape ::

DecimalIntegerLiteral [lookahead ∉ DecimalDigit]

CharacterClassEscape :: ONE OF

D D S S W W

CharacterClass~[U]~ ::

[ [lookahead ∉ {^}] ClassRanges~[?U]~ ]
[ ^ ClassRanges~[?U]~ ]

ClassRanges~[U]~ ::

[empty]
NonemptyClassRanges~[?U]~

NonemptyClassRanges~[U]~ ::

ClassAtom~[?U]~
ClassAtom~[?U]~ NonemptyClassRangesNoDash~[?U]~
ClassAtom~[?U]~ - ClassAtom~[?U]~ ClassRanges~[?U]~

NonemptyClassRangesNoDash~[U]~ ::

ClassAtom~[?U]~
ClassAtomNoDash~[?U]~ NonemptyClassRangesNoDash~[?U]~
ClassAtomNoDash~[?U]~ - ClassAtom~[?U]~ ClassRanges~[?U]~

ClassAtom~[U]~ ::

-
ClassAtomNoDash~[?U]~

ClassAtomNoDash~[U]~ ::

SourceCharacter BUT NOT ONE OF \ OR ] OR -
\ ClassEscape~[?U]~

ClassEscape~[U]~ ::

DecimalEscape
B
[+U] -
CharacterEscape~[?U]~
CharacterClassEscape

Pattern Semantics

A regular expression pattern is converted into an internal procedure
using the process described below. An implementation is encouraged to
use more efficient algorithms than the ones listed below, as long as the
results are the same. The internal procedure is used as the value of a
RegExp object’s [[RegExpMatcher]] internal slot.

A Pattern is either a BMP pattern or a Unicode pattern depending upon
whether or not its associated flags contain an "U". A BMP pattern
matches against a String interpreted as consisting of a sequence of
16-bit values that are Unicode code points in the range of the Basic
Multilingual Plane. A Unicode pattern matches against a String
interpreted as consisting of Unicode code points encoded using UTF-16.
In the context of describing the behaviour of a BMP pattern “character”
means a single 16-bit Unicode BMP code point. In the context of
describing the behaviour of a Unicode pattern “character” means a UTF-16
encoded code point (6.1.4). In either context, “character value” means
the numeric value of the code unit or code point.

The semantics of Pattern is defined as if a Pattern was a List of
SourceCharacter values where each SourceCharacter corresponds to a
Unicode code point. If a BMP pattern contains a non-BMP
SourceCharacter the entire pattern is encoded using UTF-16 and the
individual code units of that encoding are used as the elements of the
List.

NOTE For example, consider a pattern expressed in source code as the
single non-BMP character U+1D11E (MUSICAL SYMBOL G CLEF). Interpreted as
a Unicode pattern, it would be a single element (character) List
consisting of the single code point 0x1D11E. However, interpreted as a
BMP pattern, it is first UTF-16 encoded to produce a two element List
consisting of the code units 0xD834 and 0xDD1E.

Patterns are passed to the RegExp constructor as ECMAScript string
values in which non-BMP characters are UTF-16 encoded. For example, the
single character MUSICAL SYMBOL G CLEF pattern, expressed as a string
value, is a String of length 2 whose elements were the code units 0xD834
and 0xDD1E. So no further translation of the string would be necessary
to process it as a BMP pattern consisting of two pattern characters.
However, to process it as a Unicode pattern the string value must
treated as if it was UTF-16 decoded into a List consisting of a single
pattern character, the code point U+1D11E.

An implementation may not actually perform such translations to or from
UTF-16, but the semantics of this specification requires that the result
of pattern matching be as if such translations were performed.

Notation

The descriptions below use the following variables:

-   Input is a List consisting of all of the characters, in order, of
      the String being matched by the regular expression pattern. Each
      character is either a code unit or a code point, depending upon
      the kind of pattern involved. The notation input_[_n] means the
      n^th^ character of input, where n can range between 0
      (inclusive) and InputLength (exclusive).

-   InputLength is the number of characters in Input.

-   NcapturingParens is the total number of left capturing parentheses
      (i.e. the total number of times the Atom :: ( Disjunction )
      production is expanded) in the pattern. A left capturing
      parenthesis is any ( pattern character that is matched by the (
      terminal of the Atom :: ( Disjunction ) production.

-   IgnoreCase is TRUE if the RegExp object's [[OriginalFlags]]
      internal slot contains "I" and otherwise is FALSE.

-   Multiline is TRUE if the RegExp object’s [[OriginalFlags]]
      internal slot contains "M" and otherwise is FALSE.

-   Unicode is TRUE if the RegExp object’s [[OriginalFlags]] internal
      slot contains "U" and otherwise is FALSE.

Furthermore, the descriptions below use the following internal data
structures:

-   A CharSet is a mathematical set of characters, either code units
      or code points depending up the state of the Unicode flag. “All
      characters” means either all code unit values or all code point
      values also depending upon the state if Unicode.

-   A State is an ordered pair (endIndex, captures) where
      endIndex is an integer and captures is a List of
      NcapturingParens values. States are used to represent partial
      match states in the regular expression matching algorithms. The
      endIndex is one plus the index of the last input character
      matched so far by the pattern, while captures holds the results
      of capturing parentheses. The n^th^ element of captures is
      either a List that represents the value obtained by the n^th^
      set of capturing parentheses or UNDEFINED if the n^th^ set of
      capturing parentheses hasn’t been reached yet. Due to
      backtracking, many States may be in use at any time during the
      matching process.

-   A MatchResult is either a State or the special token FAILURE
      that indicates that the match failed.

-   A Continuation procedure is an internal closure (i.e. an internal
      procedure with some arguments already bound to values) that takes
      one State argument and returns a MatchResult result. If an
      internal closure references variables which are bound in the
      function that creates the closure, the closure uses the values
      that these variables had at the time the closure was created. The
      Continuation attempts to match the remaining portion (specified
      by the closure's already-bound arguments) of the pattern against
      Input, starting at the intermediate state given by its State
      argument. If the match succeeds, the Continuation returns the
      final State that it reached; if the match fails, the
      Continuation returns FAILURE.

-   A Matcher procedure is an internal closure that takes two
      arguments — a State and a Continuation — and returns a
      MatchResult result. A Matcher attempts to match a middle
      subpattern (specified by the closure's already-bound arguments) of
      the pattern against Input, starting at the intermediate state
      given by its State argument. The Continuation argument should
      be a closure that matches the rest of the pattern. After matching
      the subpattern of a pattern to obtain a new State, the Matcher
      then calls Continuation on that new State to test if the rest
      of the pattern can match as well. If it can, the Matcher returns
      the State returned by Continuation; if not, the Matcher may
      try different choices at its choice points, repeatedly calling
      Continuation until it either succeeds or all possibilities have
      been exhausted.

-   An AssertionTester procedure is an internal closure that takes a
      State argument and returns a Boolean result. The assertion
      tester tests a specific condition (specified by the closure's
      already-bound arguments) against the current place in Input and
      returns TRUE if the condition matched or FALSE if not.

-   An EscapeValue is either a character or an integer. An
      EscapeValue is used to denote the interpretation of a
      DecimalEscape escape sequence: a character ch means that the
      escape sequence is interpreted as the character ch, while an
      integer n means that the escape sequence is interpreted as a
      backreference to the n^th^ set of capturing parentheses.

Pattern

The production Pattern :: Disjunction evaluates as follows:

1.  Evaluate Disjunction to obtain a Matcher m.

2.  Return an internal closure that takes two arguments, a String str
    and an integer index, and performs the following:

    1.  If Unicode is TRUE, let Input be a List consisting of the
        sequence of code points of str interpreted as a UTF-16 encoded
        (6.1.4) Unicode string. Otherwise, let Input be a List
        consisting of the sequence of code units that are the elements
        of str. Input will be used throughout the algorithms in
        21.2.2. Each element of Input is considered to be a character.

    2.  Let listIndex be the index into Input of the character that
        was obtained from element index of str.

    3.  Let InputLength be the number of characters contained in
        Input. This variable will be used throughout the algorithms in
        21.2.2.

    4.  Let c be a Continuation that always returns its State argument
        as a successful MatchResult.

    5.  Let cap be a List of NcapturingParens UNDEFINED values,
        indexed 1 through NcapturingParens.

    6.  Let x be the State (listIndex, cap).

    7.  Call m_(_x, c) and return its result.

NOTE A Pattern evaluates ("compiles") to an internal procedure value.
REGEXP.PROTOTYPE.EXEC and other methods can then apply this procedure to
a String and an offset within the String to determine whether the
pattern would match starting at exactly that offset within the String,
and, if it does match, what the values of the capturing parentheses
would be. The algorithms in 21.2.2 are designed so that compiling a
pattern may throw a SYNTAXERROR exception; on the other hand, once the
pattern is successfully compiled, applying its result internal procedure
to find a match in a String cannot throw an exception (except for any
host-defined exceptions that can occur anywhere such as out-of-memory).

Disjunction

The production Disjunction :: Alternative evaluates by evaluating
Alternative to obtain a Matcher and returning that Matcher.

The production Disjunction :: Alternative | Disjunction evaluates
as follows:

1.  Evaluate Alternative to obtain a Matcher m1.

2.  Evaluate Disjunction to obtain a Matcher m2.

3.  Return an internal Matcher closure that takes two arguments, a State
    x and a Continuation c, and performs the following steps when
    evaluated:

    1.  Call m1_(_x, c) and let r be its result.

    2.  If r isn't FAILURE, return r.

    3.  Call m2_(_x, c) and return its result.

NOTE The | regular expression operator separates two alternatives. The
pattern first tries to match the left Alternative (followed by the
sequel of the regular expression); if it fails, it tries to match the
right Disjunction (followed by the sequel of the regular expression).
If the left Alternative, the right Disjunction, and the sequel all
have choice points, all choices in the sequel are tried before moving on
to the next choice in the left Alternative. If choices in the left
Alternative are exhausted, the right Disjunction is tried instead of
the left Alternative. Any capturing parentheses inside a portion of
the pattern skipped by | produce UNDEFINED values instead of Strings.
Thus, for example,

  /a|ab/.exec("abc")

returns the result "A" and not "AB". Moreover,

  /((a)|(ab))((c)|(bc))/.exec("abc")

returns the array

  ["abc", "a", "a", undefined, "bc", undefined, "bc"]

and not

  ["abc", "ab", undefined, "ab", "c", "c", undefined]

Alternative

The production Alternative :: [empty] evaluates by returning a Matcher
that takes two arguments, a State x and a Continuation c, and
returns the result of calling c_(_x).

The production Alternative :: Alternative Term evaluates as
follows:

1.  Evaluate Alternative to obtain a Matcher m1.

2.  Evaluate Term to obtain a Matcher m2.

3.  Return an internal Matcher closure that takes two arguments, a State
    x and a Continuation c, and performs the following steps when
    evaluated:

    1.  Create a Continuation d that takes a State argument y and
        returns the result of calling m2_(_y, c).

    2.  Call m1_(_x, d) and return its result.

NOTE Consecutive Terms try to simultaneously match consecutive
portions of Input. If the left Alternative, the right Term, and
the sequel of the regular expression all have choice points, all choices
in the sequel are tried before moving on to the next choice in the right
Term, and all choices in the right Term are tried before moving on
to the next choice in the left Alternative.

Term

The production Term :: Assertion evaluates by returning an internal
Matcher closure that takes two arguments, a State x and a Continuation
c, and performs the following steps when evaluated:

1.  Evaluate Assertion to obtain an AssertionTester t.

2.  Call t_(_x) and let r be the resulting Boolean value.

3.  If r is FALSE, return FAILURE.

4.  Call c_(_x) and return its result.

The production Term :: Atom evaluates as follows:

1.  Return the Matcher that is the result of evaluating Atom.

The production Term :: Atom Quantifier evaluates as follows:

1.  Evaluate Atom to obtain a Matcher m.

2.  Evaluate Quantifier to obtain the three results: an integer min,
    an integer (or ∞) max, and Boolean greedy.

3.  If max is finite and less than min, throw a SYNTAXERROR
    exception.

4.  Let parenIndex be the number of left capturing parentheses in the
    entire regular expression that occur to the left of this production
    expansion's Term. This is the total number of times the Atom ::
    ( Disjunction ) production is expanded prior to this production's
    Term plus the total number of Atom :: ( Disjunction )
    productions enclosing this Term.

5.  Let parenCount be the number of left capturing parentheses in the
    expansion of this production's Atom. This is the total number of
    Atom :: ( Disjunction ) productions enclosed by this
    production's Atom.

6.  Return an internal Matcher closure that takes two arguments, a State
    x and a Continuation c, and performs the following steps when
    evaluated:

    1.  Call RepeatMatcher(m, min, max, greedy, x, c,
        parenIndex, parenCount) and return its result.

Runtime Semantics: RepeatMatcher Abstract Operation

The abstract operation RepeatMatcher takes eight parameters, a Matcher
m, an integer min, an integer (or ∞) max, a Boolean greedy, a
State x, a Continuation c, an integer parenIndex, and an integer
parenCount, and performs the following steps:

1.  If max is zero, return c_(_x).

2.  Create an internal Continuation closure d that takes one State
    argument y and performs the following steps when evaluated:

    1.  If min is zero and y's endIndex is equal to x's
        endIndex, return FAILURE.

    2.  If min is zero, let min2 be zero; otherwise let min2 be
        min–1.

    3.  If max is ∞, let max2 be ∞; otherwise let max2 be max–1.

    4.  Call RepeatMatcher(m, min2, max2, greedy, y, c,
        parenIndex, parenCount) and return its result.

3.  Let cap be a fresh copy of x's captures List.

4.  For every integer k that satisfies parenIndex < k and k ≤
    parenIndex_+_parenCount, set cap_[_k] to UNDEFINED.

5.  Let e be x's endIndex.

6.  Let xr be the State (e, cap).

7.  If min is not zero, return m_(_xr, d).

8.  If greedy is FALSE, then

    a.  Call c_(_x) and let z be its result.

    b.  If z is not FAILURE, return z.

    c.  Call m_(_xr, d) and return its result.

9.  Call m_(_xr, d) and let z be its result.

10. If z is not FAILURE, return z.

11. Call c_(_x) and return its result.

NOTE 1 An Atom followed by a Quantifier is repeated the number of
times specified by the Quantifier. A Quantifier can be non-greedy,
in which case the Atom pattern is repeated as few times as possible
while still matching the sequel, or it can be greedy, in which case the
Atom pattern is repeated as many times as possible while still
matching the sequel. The Atom pattern is repeated rather than the
input character sequence that it matches, so different repetitions of
the Atom can match different input substrings.

NOTE 2 If the Atom and the sequel of the regular expression all have
choice points, the Atom is first matched as many (or as few, if
non-greedy) times as possible. All choices in the sequel are tried
before moving on to the next choice in the last repetition of Atom.
All choices in the last (n^th^) repetition of Atom are tried before
moving on to the next choice in the next-to-last (n–1)^st^ repetition of
Atom; at which point it may turn out that more or fewer repetitions of
Atom are now possible; these are exhausted (again, starting with
either as few or as many as possible) before moving on to the next
choice in the (n-1)^st^ repetition of Atom and so on.

Compare

  /a[a-z]{2,4}/.exec("abcdefghi")

which returns "ABCDE" with

  /a[a-z]{2,4}?/.exec("abcdefghi")

which returns "ABC".

Consider also

  /(aa|aabaac|ba|b|c)*/.exec("aabaac")

which, by the choice point ordering above, returns the array

  ["aaba", "ba"]

and not any of:

  ["aabaac", "aabaac"]

  ["aabaac", "c"]

The above ordering of choice points can be used to write a regular
expression that calculates the greatest common divisor of two numbers
(represented in unary notation). The following example calculates the
gcd of 10 and 15:

  "aaaaaaaaaa,aaaaaaaaaaaaaaa".replace(/^(a+)\1*,\1+$/,"$1")

which returns the gcd in unary notation "AAAAA".

NOTE 3 Step 5 of the RepeatMatcher clears Atom's captures each time
Atom is repeated. We can see its behaviour in the regular expression

  /(z)((a+)?(b+)?(c))*/.exec("zaacbbbcac")

which returns the array

  ["zaacbbbcac", "z", "ac", "a", undefined, "c"]

and not

  ["zaacbbbcac", "z", "ac", "a", "bbb", "c"]

because each iteration of the outermost * clears all captured Strings
contained in the quantified Atom, which in this case includes capture
Strings numbered 2, 3, 4, and 5.

NOTE 4 Step 1 of the RepeatMatcher's d closure states that, once the
minimum number of repetitions has been satisfied, any more expansions of
Atom that match the empty character sequence are not considered for
further repetitions. This prevents the regular expression engine from
falling into an infinite loop on patterns such as:

  /(a*)*/.exec("b")

or the slightly more complicated:

  /(a*)b\1+/.exec("baaaac")

which returns the array

  ["b", ""]

Assertion

The production Assertion :: ^ evaluates by returning an internal
AssertionTester closure that takes a State argument x and performs the
following steps when evaluated:

1.  Let e be x's endIndex.

2.  If e is zero, return TRUE.

3.  If Multiline is FALSE, return FALSE.

4.  If the character Input_[_e–1] is one of LineTerminator, return
    TRUE.

5.  Return FALSE.

NOTE Even when the Y flag is used with a pattern, ^ always matches only
at the beginning of Input, or (if Multiline is TRUE) at the
beginning of a line.

The production Assertion :: $ evaluates by returning an internal
AssertionTester closure that takes a State argument x and performs the
following steps when evaluated:

1.  Let e be x's endIndex.

2.  If e is equal to InputLength, return TRUE.

3.  If Multiline is FALSE, return FALSE.

4.  If the character Input_[_e] is one of LineTerminator, return
    TRUE.

5.  Return FALSE.

The production Assertion :: \ B evaluates by returning an internal
AssertionTester closure that takes a State argument x and performs the
following steps when evaluated:

1.  Let e be x's endIndex.

2.  Call IsWordChar(e–1) and let a be the Boolean result.

3.  Call IsWordChar(e) and let b be the Boolean result.

4.  If a is TRUE and b is FALSE, return TRUE.

5.  If a is FALSE and b is TRUE, return TRUE.

6.  Return FALSE.

The production Assertion :: \ B evaluates by returning an internal
AssertionTester closure that takes a State argument x and performs the
following steps when evaluated:

1.  Let e be x's endIndex.

2.  Call IsWordChar(e–1) and let a be the Boolean result.

3.  Call IsWordChar(e) and let b be the Boolean result.

4.  If a is TRUE and b is FALSE, return FALSE.

5.  If a is FALSE and b is TRUE, return FALSE.

6.  Return TRUE.

The production Assertion :: ( ? = Disjunction ) evaluates as
follows:

1.  Evaluate Disjunction to obtain a Matcher m.

2.  Return an internal Matcher closure that takes two arguments, a State
    x and a Continuation c, and performs the following steps:

    1.  Let d be a Continuation that always returns its State argument
        as a successful MatchResult.

    2.  Call m_(_x, d) and let r be its result.

    3.  If r is FAILURE, return FAILURE.

    4.  Let y be r's State.

    5.  Let cap be y's captures List.

    6.  Let xe be x's endIndex.

    7.  Let z be the State (xe, cap).

    8.  Call c_(_z) and return its result.

The production Assertion :: ( ? ! Disjunction ) evaluates as
follows:

1.  Evaluate Disjunction to obtain a Matcher m.

2.  Return an internal Matcher closure that takes two arguments, a State
    x and a Continuation c, and performs the following steps:

    1.  Let d be a Continuation that always returns its State argument
        as a successful MatchResult.

    2.  Call m_(_x, d) and let r be its result.

    3.  If r isn't FAILURE, return FAILURE.

    4.  Call c_(_x) and return its result.

Runtime Semantics: IsWordChar Abstract Operation

The abstract operation IsWordChar takes an integer parameter e and
performs the following steps:

1.  If e is –1 or e is InputLength, return FALSE.

2.  Let c be the character Input_[_e].

3.  If c is one of the sixty-three characters below, return TRUE.

  --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
  a   b   c   d   e   f   g   h   i   j   k   l   m   n   o   p   q   r   s   t   u   v   w   x   y   z
  A   B   C   D   E   F   G   H   I   J   K   L   M   N   O   P   Q   R   S   T   U   V   W   X   Y   Z
  0   1   2   3   4   5   6   7   8   9   _                                                           
  --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---

1.  Return FALSE.

Quantifier

The production Quantifier :: QuantifierPrefix evaluates as follows:

1.  Evaluate QuantifierPrefix to obtain the two results: an integer
    min and an integer (or ∞) max.

2.  Return the three results min, max, and TRUE.

The production Quantifier :: QuantifierPrefix ? evaluates as
follows:

1.  Evaluate QuantifierPrefix to obtain the two results: an integer
    min and an integer (or ∞) max.

2.  Return the three results min, max, and FALSE.

The production QuantifierPrefix :: * evaluates as follows:

1.  Return the two results 0 and ∞.

The production QuantifierPrefix :: + evaluates as follows:

1.  Return the two results 1 and ∞.

The production QuantifierPrefix :: ? evaluates as follows:

1.  Return the two results 0 and 1.

The production QuantifierPrefix :: { DecimalDigits } evaluates as
follows:

1.  Let i be the MV of DecimalDigits (see 11.8.3).

2.  Return the two results i and i.

The production QuantifierPrefix :: { DecimalDigits , } evaluates as
follows:

1.  Let i be the MV of DecimalDigits.

2.  Return the two results i and ∞.

The production QuantifierPrefix :: { DecimalDigits , DecimalDigits
} evaluates as follows:

1.  Let i be the MV of the first DecimalDigits.

2.  Let j be the MV of the second DecimalDigits.

3.  Return the two results i and j.

Atom

The production Atom :: PatternCharacter evaluates as follows:

1.  Let ch be the character matched by PatternCharacter.

2.  Let A be a one-element CharSet containing the character ch.

3.  Call CharacterSetMatcher(A, FALSE) and return its Matcher result.

The production Atom :: . evaluates as follows:

1.  Let A be the set of all characters except LineTerminator.

2.  Call CharacterSetMatcher(A, FALSE) and return its Matcher result.

The production Atom :: \ AtomEscape evaluates as follows:

1.  Return the Matcher that is the result of evaluating AtomEscape.

The production Atom :: CharacterClass evaluates as follows:

1.  Evaluate CharacterClass to obtain a CharSet A and a Boolean
    invert.

2.  Call CharacterSetMatcher(A, invert) and return its Matcher
    result.

The production Atom :: ( Disjunction ) evaluates as follows:

1.  Evaluate Disjunction to obtain a Matcher m.

2.  Let parenIndex be the number of left capturing parentheses in the
    entire regular expression that occur to the left of this production
    expansion's initial left parenthesis. This is the total number of
    times the Atom_ :: ( _Disjunction ) production is expanded prior
    to this production's Atom plus the total number of
    Atom_ :: ( _Disjunction ) productions enclosing this Atom.

3.  Return an internal Matcher closure that takes two arguments, a State
    x and a Continuation c, and performs the following steps:

    1.  Create an internal Continuation closure d that takes one State
        argument y and performs the following steps:

1.  Let cap be a fresh copy of y's captures List.

2.  Let xe be x's endIndex.

3.  Let ye be y's endIndex.

4.  Let s be a fresh List whose characters are the characters of
    Input at indices xe (inclusive) through ye (exclusive).

5.  Set cap_[_parenIndex+1] to s.

6.  Let z be the State (ye, cap).

7.  Call c_(_z) and return its result.

    1.  Call m_(_x, d) and return its result.

The production Atom :: ( ? : Disjunction ) evaluates as follows:

1.  Return the Matcher that is the result of evaluating Disjunction.

Runtime Semantics: CharacterSetMatcher Abstract Operation

The abstract operation CharacterSetMatcher takes two arguments, a
CharSet A and a Boolean flag invert, and performs the following
steps:

1.  Return an internal Matcher closure that takes two arguments, a State
    x and a Continuation c, and performs the following steps steps
    when evaluated:

    1.  Let e be x's endIndex.

    2.  If e is InputLength, return FAILURE.

    3.  Let ch be the character Input_[_e].

    4.  Let cc be the result of Canonicalize(ch).

    5.  If invert is FALSE, then

        a.  If there does not exist a member a of set A such that
            Canonicalize(a) is cc, return FAILURE.

    6.  Else invert is TRUE,

        a.  If there exists a member a of set A such that
            Canonicalize(a) is cc, return FAILURE.

    7.  Let cap be x's captures List.

    8.  Let y be the State (e+1, cap).

    9.  Call c_(_y) and return its result.

Runtime Semantics: Canonicalize Abstract Operation

The abstract operation Canonicalize takes a character parameter ch and
performs the following steps:

1.  If IgnoreCase is FALSE, return ch.

2.  If Unicode is TRUE,

    a.  If the file CaseFolding.txt of the Unicode Character Database
        provides a simple or common case folding mapping for ch,
        return

    b.  the result of applying that mapping to ch.

    c.  Else, return ch.

3.  Else,

    a.  Assert: ch is a UTF-16 code unit.

    b.  c.  Let s be the ECMAScript String value consisting of the
        single code unit ch.

    d.  Let u be the same result produced as if by performing the
        algorithm for STRING.PROTOTYPE.TOUPPERCASE using s as the THIS
        value.

    e.  ReturnIfAbrupt(u).

    f.  Assert: u is a String value.

    g.  If u does not consist of a single code unit, return ch.

    h.  Let cu be u’s single code unit element.

    i.  If ch's code unit value ≥ 128 and cu's code unit value <
        128, return ch.

    j.  Return cu.

NOTE 1 Parentheses of the form ( Disjunction ) serve both to group the
components of the Disjunction pattern together and to save the result
of the match. The result can be used either in a backreference (\
followed by a nonzero decimal number), referenced in a replace String,
or returned as part of an array from the regular expression matching
internal procedure. To inhibit the capturing behaviour of parentheses,
use the form (?: Disjunction ) instead.

NOTE 2 The form (?= Disjunction ) specifies a zero-width positive
lookahead. In order for it to succeed, the pattern inside Disjunction
must match at the current position, but the current position is not
advanced before matching the sequel. If Disjunction can match at the
current position in several ways, only the first one is tried. Unlike
other regular expression operators, there is no backtracking into a (?=
form (this unusual behaviour is inherited from Perl). This only matters
when the Disjunction contains capturing parentheses and the sequel of
the pattern contains backreferences to those captures.

For example,

  /(?=(a+))/.exec("baaabac")

matches the empty String immediately after the first B and therefore
returns the array:

  ["", "aaa"]

To illustrate the lack of backtracking into the lookahead, consider:

  /(?=(a+))a*b\1/.exec("baaabac")

This expression returns

  ["aba", "a"]

and not:

  ["aaaba", "a"]

NOTE 3 The form (?! Disjunction ) specifies a zero-width negative
lookahead. In order for it to succeed, the pattern inside Disjunction
must fail to match at the current position. The current position is not
advanced before matching the sequel. Disjunction can contain capturing
parentheses, but backreferences to them only make sense from within
Disjunction itself. Backreferences to these capturing parentheses from
elsewhere in the pattern always return UNDEFINED because the negative
lookahead must fail for the pattern to succeed. For example,

  /(.*?)a(?!(a+)b\2c)\2(.*)/.exec("baaabaac")

looks for an A not immediately followed by some positive number n of
A's, a B, another n A's (specified by the first \2) and a C. The second
\2 is outside the negative lookahead, so it matches against UNDEFINED
and therefore always succeeds. The whole expression returns the array:

  ["baaabaac", "ba", undefined, "abaac"]

NOTE 4 In case-insignificant matches when Unicode is TRUE, all
characters are implicitly case-folded using the simple mapping provided
by the Unicode standard immediately before they are compared. The simple
mapping always maps to a single code point, so it does not map, for
example, "SS" (U+00DF) to "SS". It may however map a code point outside
the Basic Latin range to a character within, for example, “ſ” (U+017F)
to “s”. Such characters are not mapped if Unicode is FALSE. This
prevents Unicode code points such as U+017F and U+212A from matching
regular expressions such as /[AZ]/I, but they will match /[AZ]/UI.

AtomEscape

The production AtomEscape :: DecimalEscape evaluates as follows:

1.  Evaluate DecimalEscape to obtain an EscapeValue E.

2.  If E is a character, then

    a.  Let ch be E's character.

    b.  Let A be a one-element CharSet containing the character ch.

    c.  Call CharacterSetMatcher(A, FALSE) and return its Matcher
        result.

3.  Assert: E must be an integer.

4.  Let n be that integer.

5.  If n=0 or n_>_NcapturingParens, throw a SYNTAXERROR exception.

6.  Return an internal Matcher closure that takes two arguments, a State
    x and a Continuation c, and performs the following steps:

    1.  Let cap be x's captures List.

    2.  Let s be cap_[_n].

    3.  If s is UNDEFINED, return c_(_x).

    4.  Let e be x's endIndex.

    5.  Let len be s's length.

    6.  Let f be e_+_len.

    7.  If f_>_InputLength, return FAILURE.

    8.  If there exists an integer i between 0 (inclusive) and len
        (exclusive) such that Canonicalize(s_[_i]) is not the same
        character value as Canonicalize(Input [e_+_i]), return
        FAILURE.

    9.  Let y be the State (f, cap).

    10. Call c_(_y) and return its result.

The production AtomEscape :: CharacterEscape evaluates as follows:

1.  Evaluate CharacterEscape to obtain a character ch.

2.  Let A be a one-element CharSet containing the character ch.

3.  Call CharacterSetMatcher(A, FALSE) and return its Matcher result.

The production AtomEscape :: CharacterClassEscape evaluates as
follows:

1.  Evaluate CharacterClassEscape to obtain a CharSet A.

2.  Call CharacterSetMatcher(A, FALSE) and return its Matcher result.

NOTE An escape sequence of the form \ followed by a nonzero decimal
number n matches the result of the nth set of capturing parentheses
(see 21.2.2.11). It is an error if the regular expression has fewer than
n capturing parentheses. If the regular expression has n or more
capturing parentheses but the nth one is UNDEFINED because it has not
captured anything, then the backreference always succeeds.

CharacterEscape

The production CharacterEscape :: ControlEscape evaluates by
returning the character according to Table 44.

Table 44 — ControlEscape Character Values

  ----------------- ------------------- -------------- ---------------------- ----------
  CONTROLESCAPE   _CHARACTER VALUE_   _CODE POINT_   _UNICODE NAME_         SYMBOL
  T                 9                   U+0009         CHARACTER TABULATION   <HT>
  N                 10                  U+000A         LINE FEED (LF)         <LF>
  V                 11                  U+000B         LINE TABULATION        <VT>
  F                 12                  U+000C         FORM FEED (FF)         <FF>
  R                 13                  U+000D         CARRIAGE RETURN (CR)   <CR>
  ----------------- ------------------- -------------- ---------------------- ----------

The production CharacterEscape :: C ControlLetter evaluates as
follows:

1.  Let ch be the character matched by ControlLetter.

2.  Let i be ch's character value.

3.  Let j be the remainder of dividing i by 32.

4.  Return the character whose character value is j.

The production CharacterEscape :: HexEscapeSequence evaluates as
follows:

1.  Return the character whose code is the SV of HexEscapeSequence.

The production CharacterEscape :: RegExpUnicodeEscapeSequence
evaluates as follows:

1.  Return the result of evaluating RegExpUnicodeEscapeSequence.

The production CharacterEscape :: IdentityEscape evaluates as
follows:

1.  Return the character matched by IdentityEscape.

The production RegExpUnicodeEscapeSequence :: U LeadSurrogate \U
TrailSurrogate evaluates as follows:

1.  Let lead be the result of evaluating LeadSurrogate.

2.  Let trail be the result of evaluating TrailSurrogate.

3.  Let cp be UTF16Decode(lead, trail).

4.  Return the character whose character value is cp.

The production RegExpUnicodeEscapeSequence :: U Hex4Digits evaluates
as follows:

1.  Return the character whose code is the SV of Hex4Digits.

The production RegExpUnicodeEscapeSequence :: U{ HexDigits}
evaluates as follows:

1.  Return the character whose code is the MV of HexDigits.

The production LeadSurrogate :: Hex4Digits evaluates as follows:

1.  Return the character whose code is the SV of Hex4Digits.

The production TrailSurrogate :: Hex4Digits evaluates as follows:

1.  Return the character whose code is the SV of Hex4Digits.

DecimalEscape

The production DecimalEscape :: DecimalIntegerLiteral evaluates as
follows:

1.  Let i be the MV of DecimalIntegerLiteral.

2.  If i is zero, return the EscapeValue consisting of the character
    U+0000 (NULL).

3.  Return the EscapeValue consisting of the integer i.

The definition of “the MV of DecimalIntegerLiteral” is in 11.8.3.

NOTE If \ is followed by a decimal number n whose first digit is not
0, then the escape sequence is considered to be a backreference. It is
an error if n is greater than the total number of left capturing
parentheses in the entire regular expression. \0 represents the <NUL>
character and cannot be followed by a decimal digit.

CharacterClassEscape

The production CharacterClassEscape :: D evaluates by returning the
ten-element set of characters containing the characters 0 through 9
inclusive.

The production CharacterClassEscape :: D evaluates by returning the
set of all characters not included in the set returned by
CharacterClassEscape :: D.

The production CharacterClassEscape :: S evaluates by returning the
set of characters containing the characters that are on the right-hand
side of the WhiteSpace (11.2) or LineTerminator (11.3) productions.

The production CharacterClassEscape :: S evaluates by returning the
set of all characters not included in the set returned by
CharacterClassEscape :: S.

The production CharacterClassEscape :: W evaluates by returning the
set of characters containing the sixty-three characters:

  --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
  a   b   c   d   e   f   g   h   i   j   k   l   m   n   o   p   q   r   s   t   u   v   w   x   y   z
  A   B   C   D   E   F   G   H   I   J   K   L   M   N   O   P   Q   R   S   T   U   V   W   X   Y   Z
  0   1   2   3   4   5   6   7   8   9   _                                                           
  --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---

The production CharacterClassEscape :: W evaluates by returning the
set of all characters not included in the set returned by
CharacterClassEscape :: W.

CharacterClass

The production CharacterClass :: [ ClassRanges ] evaluates by
evaluating ClassRanges to obtain a CharSet and returning that CharSet
and the Boolean FALSE.

The production CharacterClass :: [ ^ ClassRanges ] evaluates by
evaluating ClassRanges to obtain a CharSet and returning that CharSet
and the Boolean TRUE.

ClassRanges

The production ClassRanges :: [empty] evaluates by returning the empty
CharSet.

The production ClassRanges :: NonemptyClassRanges evaluates by
evaluating NonemptyClassRanges to obtain a CharSet and returning that
CharSet.

NonemptyClassRanges

The production NonemptyClassRanges :: ClassAtom evaluates as
follows:

1.  Return the CharSet that is the result of evaluating ClassAtom.

The production NonemptyClassRanges :: ClassAtom
NonemptyClassRangesNoDash evaluates as follows:

1.  Evaluate ClassAtom to obtain a CharSet A.

2.  Evaluate NonemptyClassRangesNoDash to obtain a CharSet B.

3.  Return the union of CharSets A and B.

The production NonemptyClassRanges :: ClassAtom - ClassAtom
ClassRanges evaluates as follows:

1.  Evaluate the first ClassAtom to obtain a CharSet A.

2.  Evaluate the second ClassAtom to obtain a CharSet B.

3.  Evaluate ClassRanges to obtain a CharSet C.

4.  Call CharacterRange(A, B) and let D be the resulting CharSet.

5.  Return the union of CharSets D and C.

Runtime Semantics: CharacterRange Abstract Operation

The abstract operation CharacterRange takes two CharSet parameters A
and B and performs the following steps:

1.  If A does not contain exactly one character or B does not
    contain exactly one character, throw a SYNTAXERROR exception.

2.  Let a be the one character in CharSet A.

3.  Let b be the one character in CharSet B.

4.  Let i be the character value of character a.

5.  Let j be the character value of character b.

6.  If i > j, throw a SYNTAXERROR exception.

7.  Return the set containing all characters numbered i through j,
    inclusive.

NonemptyClassRangesNoDash

The production NonemptyClassRangesNoDash :: ClassAtom evaluates as
follows:

1.  Return the CharSet that is the result of evaluating ClassAtom.

The production NonemptyClassRangesNoDash :: ClassAtomNoDash
NonemptyClassRangesNoDash evaluates as follows:

1.  Evaluate ClassAtomNoDash to obtain a CharSet A.

2.  Evaluate NonemptyClassRangesNoDash to obtain a CharSet B.

3.  Return the union of CharSets A and B.

The production NonemptyClassRangesNoDash :: ClassAtomNoDash -
ClassAtom ClassRanges evaluates as follows:

1.  Evaluate ClassAtomNoDash to obtain a CharSet A.

2.  Evaluate ClassAtom to obtain a CharSet B.

3.  Evaluate ClassRanges to obtain a CharSet C.

4.  Call CharacterRange(A, B) and let D be the resulting CharSet.

5.  Return the union of CharSets D and C.

NOTE 1 ClassRanges can expand into single ClassAtoms and/or ranges
of two ClassAtoms separated by dashes. In the latter case the
ClassRanges includes all characters between the first ClassAtom and
the second ClassAtom, inclusive; an error occurs if either ClassAtom
does not represent a single character (for example, if one is \W) or if
the first ClassAtom's character value is greater than the second
ClassAtom's character value.

NOTE 2 Even if the pattern ignores case, the case of the two ends of a
range is significant in determining which characters belong to the
range. Thus, for example, the pattern /[E-F]/I matches only the letters
E, F, E, and F, while the pattern /[E-F]/I matches all upper and
lower-case letters in the Unicode Basic Latin block as well as the
symbols [, \, ], ^, _, and `.

NOTE 3 A - character can be treated literally or it can denote a range.
It is treated literally if it is the first or last character of
ClassRanges, the beginning or end limit of a range specification, or
immediately follows a range specification.

ClassAtom

The production ClassAtom :: - evaluates by returning the CharSet
containing the one character -.

The production ClassAtom :: ClassAtomNoDash evaluates by evaluating
ClassAtomNoDash to obtain a CharSet and returning that CharSet.

ClassAtomNoDash

The production ClassAtomNoDash :: SourceCharacter BUT NOT ONE OF \
OR ] OR - evaluates as follows:

1.  Return the CharSet containing the character matched by
    SourceCharacter.

The production ClassAtomNoDash :: \ ClassEscape evaluates as
follows:

1.  Return the CharSet that is the result of evaluating ClassEscape.

ClassEscape

The production ClassEscape :: DecimalEscape evaluates as follows:

1.  Evaluate DecimalEscape to obtain an EscapeValue E.

2.  If E is not a character, throw a SYNTAXERROR exception.

3.  Let ch be E's character.

4.  Return the one-element CharSet containing the character ch.

The production ClassEscape :: B evaluates as follows:

1.  Return the CharSet containing the single character <BS> U+0008
    (BACKSPACE).

The production ClassEscape :: - evaluates as follows:

1.  Return the CharSet containing the single character - U+002D
    (HYPEN-MINUS).

The production ClassEscape :: CharacterEscape evaluates as follows:

1.  Return the CharSet containing the single character that is the
    result of evaluating CharacterEscape.

The production ClassEscape :: CharacterClassEscape evaluates as
follows:

1.  Return the CharSet that is the result of evaluating
    CharacterClassEscape.

NOTE A ClassAtom can use any of the escape sequences that are allowed
in the rest of the regular expression except for \B, \B, and
backreferences. Inside a CharacterClass, \B means the backspace
character, while \B and backreferences raise errors. Using a
backreference inside a ClassAtom causes an error.

The RegExp Constructor 

The RegExp constructor is the %RegExp% intrinsic object and the initial
value of the REGEXP property of the global object. When REGEXP is called
as a function rather than as a constructor, it creates and initializes a
new RegExp object. Thus the function call REGEXP(…) is equivalent to the
object creation expression NEW REGEXP(…) with the same arguments.

The REGEXP constructor is designed to be subclassable. It may be used as
the value of an EXTENDS clause of a class definition. Subclass
constructors that intend to inherit the specified REGEXP behaviour must
include a SUPER call to the REGEXP constructor to create and initialize
subclass instances with the necessary internal slots.

RegExp ( pattern, flags )

The following steps are taken:

1.  2.  3.  4.  5.  Let patternIsRegExp be IsRegExp(pattern).

6.  ReturnIfAbrupt(patternIsRegExp).

7.  If NewTarget is not UNDEFINED, let newTarget be NewTarget.

8.  Else,

    a.  Let newTarget be the active function object.

    b.  If patternIsRegExp is TRUE and flags is UNDEFINED, then

    c.  i.  Let patternConstructor be Get(pattern, "CONSTRUCTOR").

        ii. ReturnIfAbrupt(patternConstructor).

        iii. If SameValue(newTarget, patternConstructor) is TRUE,
            return pattern.

        iv. 

9.  10. 11. If Type(pattern) is Object and pattern has a
    [[RegExpMatcher]] internal slot, then

    a.  b.  c.  Let P be the value of pattern’s [[OriginalSource]]
        internal slot.

    d.  If flags is UNDEFINED, let F be the value of pattern’s
        [[OriginalFlags]] internal slot.

    e.  Else, let F be flags.

12. Else if patternIsRegExp is TRUE, then

    a.  Let P be be Get(pattern, "SOURCE").

    b.  ReturnIfAbrupt(P).

    c.  If flags is UNDEFINED, then

        i.  Let F be Get(pattern, "FLAGS").

        ii. ReturnIfAbrupt(F).

    d.  Else, let F be flags.

13. Else,

    a.  Let P be pattern.

    b.  Let F be flags.

14. Let O be RegExpAlloc(newTarget).

15. ReturnIfAbrupt(O).

16. Return RegExpInitialize(O, P, F).

NOTE If pattern is supplied using a StringLiteral, the usual escape
sequence substitutions are performed before the String is processed by
RegExp. If pattern must contain an escape sequence to be recognized by
RegExp, any REVERSE SOLIDUS (\) code points must be escaped within the
StringLiteral to prevent them being removed when the contents of the
StringLiteral are formed.

1.  2.  3.  

Abstract Operations for the RegExp Constructor

Runtime Semantics: RegExpAlloc Abstract Operation

When the abstract operation RegExpAlloc with argument newTarget is
called, the following steps are taken:

1.  Let obj be OrdinaryCreateFromConstructor(newTarget,
    "%REGEXPPROTOTYPE%", «‍[[RegExpMatcher]], [[OriginalSource]],
    [[OriginalFlags]]»).

2.  ReturnIfAbrupt(obj).

3.  Let status be the result of DefinePropertyOrThrow(obj,
    "LASTINDEX", PropertyDescriptor {[[Writable]]: TRUE, [[Enumerable]]:
    FALSE, [[Configurable]]: FALSE}).

4.  Assert: status is not an abrupt completion.

5.  Return obj.

Runtime Semantics: RegExpInitialize Abstract Operation

When the abstract operation RegExpInitialize with arguments obj,
pattern, and flags is called, the following steps are taken:

1.  If pattern is UNDEFINED, let P be the empty String.

2.  Else, let P be ToString(pattern).

3.  ReturnIfAbrupt(P).

4.  If flags is UNDEFINED, let F be the empty String.

5.  Else, let F be ToString(flags).

6.  ReturnIfAbrupt(F).

7.  If F contains any code unit other than "G", "I", "M", "U", or "Y"
    or if it contains the same code unit more than once, throw a
    SYNTAXERROR exception.

8.  If F contains "U", let BMP be FALSE; else let BMP be TRUE.

9.  10. If BMP is TRUE, then

    a.  Parse P using the grammars in 21.2.1 and interpreting each of
        its 16-bit elements as a Unicode BMP code point. UTF-16 decoding
        is not applied to the elements. The goal symbol for the parse is
        Pattern.Throw a SYNTAXERROR exception if P did not conform
        to the grammar or if any elements of P were not matched by the
        parse.

    b.  c.  Let patternCharacters be a List whose elements are the
        code unit elements of P.

11. Else

    a.  Parse P using the grammars in 21.2.1 and interpreting P as
        UTF-16 encoded Unicode code points (6.1.4). The goal symbol for
        the parse is Pattern~[U]~. Throw a SYNTAXERROR exception if
        P did not conform to the grammar or if any elements of P
        were not matched by the parse.

    b.  c.  Let patternCharacters be a List whose elements are the
        code points resulting from applying UTF-16 decoding to P’s
        sequence of elements.

12. Set the value of obj’s [[OriginalSource]] internal slot to P.

13. Set the value of obj’s [[OriginalFlags]] internal slot to F.

14. 15. Set obj’s [[RegExpMatcher]] internal slot to the internal
    procedure that evaluates the above parse of P by applying the
    semantics provided in 21.2.2 using patternCharacters as the
    pattern’s List of SourceCharacter values and F as the flag
    parameters.

16. Let putStatus be the result of Put(obj, "LASTINDEX", 0, TRUE).

17. ReturnIfAbrupt(putStatus).

18. Return obj.

Runtime Semantics: RegExpCreate Abstract Operation

When the abstract operation RegExpCreate with arguments P and F is
called, the following steps are taken:

1.  Let obj be RegExpAlloc(%RegExp%).

2.  ReturnIfAbrupt(obj).

3.  Return RegExpInitialize(obj, P, F).

Runtime Semantics: EscapeRegExpPattern Abstract Operation

When the abstract operation EscapeRegExpPattern with arguments P and
F is called, the following occurs:

1.  Let S be a String in the form of a Pattern (Pattern~[U]~ if
    F contains "U") equivalent to P interpreted as UTF-16 encoded
    Unicode code points (6.1.4), in which certain code points are
    escaped as described below. S may or may not be identical to P;
    however, the internal procedure that would result from evaluating
    S as a Pattern (Pattern~[U]~ if F contains "U") must behave
    identically to the internal procedure given by the constructed
    object's [[RegExpMatcher]] internal slot. Multiple calls to this
    abstract operation using the same values for P and F must
    produce identical results.

2.  The code points / or any LineTerminator occurring in the pattern
    shall be escaped in S as necessary to ensure that the String value
    formed by concatenating the Strings "/", S, "/", and F can be
    parsed (in an appropriate lexical context) as a
    RegularExpressionLiteral that behaves identically to the
    constructed regular expression. For example, if P is "/", then S
    could be "\/" or "\U002F", among other possibilities, but not "/",
    because /// followed by F would be parsed as a SingleLineComment
    rather than a RegularExpressionLiteral. If P is the empty
    String, this specification can be met by letting S be "(?:)".

3.  4.  Return S.

Properties of the RegExp Constructor

The value of the [[Prototype]] internal slot of the RegExp constructor
is the intrinsic object %FunctionPrototype% (19.2.3).

1.  

Besides the LENGTH property (whose value is 2), the RegExp constructor
has the following properties:

RegExp.prototype

The initial value of REGEXP.PROTOTYPE is the RegExp prototype object
(21.2.5).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

get RegExp [ @@species ] 

REGEXP[@@SPECIES] is an accessor property whose set accessor function is
UNDEFINED. Its get accessor function performs the following steps:

1.  Return THIS.

The value of the NAME property of this function is
"GET[SYMBOL.SPECIES]".

NOTE RegExp prototype methods normally use their THIS object’s
constructor to create a derived object. However, a subclass constructor
may over-ride that default behaviour by redefining its @@species
property.

1.  

Properties of the RegExp Prototype Object

The RegExp prototype object is an ordinary object. It is not a RegExp
instance and does not have a [[RegExpMatcher]] internal slot or any of
the other internal slots of RegExp instance objects.

The value of the [[Prototype]] internal slot of the RegExp prototype
object is the intrinsic object %ObjectPrototype% (19.1.3).

NOTE The RegExp prototype object does not have a VALUEOF property of its
own; however, it inherits the VALUEOF property from the Object prototype
object.

RegExp.prototype.constructor

The initial value of REGEXP.PROTOTYPE.CONSTRUCTOR is the intrinsic
object %RegExp%.

RegExp.prototype.exec ( string )

Performs a regular expression match of string against the regular
expression and returns an Array object containing the results of the
match, or NULL if string did not match.

The String ToString(string) is searched for an occurrence of the
regular expression pattern as follows:

1.  Let R be the THIS value.

2.  If Type(R) is not Object, throw a TYPEERROR exception.

3.  If R does not have a [[RegExpMatcher]] internal slot, throw a
    TYPEERROR exception.

4.  5.  6.  7.  Let S be ToString(string)

8.  ReturnIfAbrupt(S).

9.  Return RegExpBuiltinExec(R, S).

Runtime Semantics: RegExpExec ( R, S ) Abstract Operation

The abstract operation RegExpExec with arguments R and S performs
the following steps:

1.  Assert: Type(R) is Object.

2.  Assert: Type(S) is String.

3.  Let exec be Get(R, "EXEC").

4.  ReturnIfAbrupt(exec).

5.  If IsCallable(exec) is TRUE, then

    a.  Let result be Call(exec, R, «S»).

    b.  ReturnIfAbrupt(result).

    c.  If Type(result) is neither Object or Null, throw a TYPEERROR
        exception.

    d.  Return(result).

6.  If R does not have a [[RegExpMatcher]] internal slot, throw a
    TYPEERROR exception.

7.  8.  Return RegExpBuiltinExec(R, S).

NOTE If a callable EXEC property is not found this algorithm falls back
to attempting to use the built-in RegExp matching algorithm. This
provides compatible behaviour for code written for prior editions where
most built-in algorithms that use regular expressions did not perform a
dynamic property lookup of EXEC.

Runtime Semantics: RegExpBuiltinExec ( R, S ) Abstract Operation

The abstract operation RegExpBuiltinExec with arguments R and S
performs the following steps:

1.  Assert: R is an initialized RegExp instance.

2.  Assert: Type(S) is String.

3.  4.  5.  Let length be the number of code units in S.

6.  7.  8.  Let lastIndex be ToLength(Get(R,"LASTINDEX")).

9.  10. ReturnIfAbrupt(lastIndex).

11. Let global be ToBoolean(Get(R, "GLOBAL")).

12. ReturnIfAbrupt(global).

13. Let sticky be ToBoolean(Get(R, "STICKY")).

14. ReturnIfAbrupt(sticky).

15. If global is FALSE and sticky is FALSE, let i = 0.

16. Let matcher be the value of R’s [[RegExpMatcher]] internal slot.

17. Let flags be the value of R’s [[OriginalFlags]] internal slot.

18. If flags contains "U", let fullUnicode be TRUE, else let
    fullUnicode be FALSE.

19. 20. Let matchSucceeded be FALSE.

21. Repeat, while matchSucceeded is FALSE

    a.  If lastIndex > length, then

        i.  ii. Let putStatus be Put(R, "LASTINDEX", 0, TRUE).

        iii. ReturnIfAbrupt(putStatus).

        iv. Return NULL.

    b.  Let r be the result of calling matcher with arguments S
        and lastIndex.

    c.  If r is FAILURE, then

    d.  i.  If sticky is TRUE, then

            1.  2.  Let putStatus be Put(R, "LASTINDEX", 0, TRUE).

            3.  ReturnIfAbrupt(putStatus).

            4.  Return NULL.

        ii. Let lastIndex = lastIndex+1.

    e.  else

    f.  i.  Assert: r is a State.

        ii. Set matchSucceeded to TRUE.

22. Let e be r's endIndex value.

23. If fullUnicode is TRUE, then

    a.  e is an index into the Input character list, derived from
        S, matched by matcher. Let eUTF be the smallest index into
        S that corresponds to the character at element e of Input.
        If e is greater than the length of Input, then eUTF is 1 +
        the number of code units in S.

    b.  c.  Let e be eUTF.

24. If global is TRUE or sticky is TRUE,

    a.  Let putStatus be the result of Put(R, "LASTINDEX", e,
        TRUE).

    b.  ReturnIfAbrupt(putStatus).

25. Let n be the length of r's captures List. (This is the same
    value as 21.2.2.1's NcapturingParens.)

26. Let A be the result of the abstract operation ArrayCreate(n +
    1).

27. Assert: The value of A’s "LENGTH" property is n + 1.

28. Let matchIndex be lastIndex.

29. Assert: The following CreateDataProperty calls will not result in an
    abrupt completion.

30. Perform CreateDataProperty(A, "INDEX", matchIndex).

31. Perform CreateDataProperty(A, "INPUT", S).

32. 33. Let matchedSubstr be the matched substring (i.e. the portion
    of S between offset lastIndex inclusive and offset e
    exclusive).

34. Perform CreateDataProperty(A, "0", matchedSubstr).

35. For each integer i such that i > 0 and i ≤ n

    a.  Let captureI be i^th^ element of r's captures List.

    b.  If captureI is UNDEFINED, let capturedValue be UNDEFINED.

    c.  Else if fullUnicode is TRUE,

    d.  i.  Assert: captureI is a List of code points.

        ii. Let capturedValue be a string whose code units are the
            UTF-16Encoding (10.1.1) of the code points of capture.

    e.  Else, fullUnicode is FALSE,

    f.  i.  Assert: captureI is a List of code units.

        ii. Let capturedValue be a string consisting of the code units
            of captureI.

    g.  Perform CreateDataProperty(A, ToString(i) ,
        capturedValue).

36. Return A.

get RegExp.prototype.flags 

REGEXP.PROTOTYPE.FLAGS is an accessor property whose set accessor
function is UNDEFINED. Its get accessor function performs the following
steps:

1.  Let R be the THIS value.

2.  If Type(R) is not Object, throw a TYPEERROR exception.

3.  Let result be the empty String.

4.  Let global be ToBoolean(Get(R, "GLOBAL")).

5.  ReturnIfAbrupt(global).

6.  If global is TRUE, append "G" as the last code unit of result.

7.  Let ignoreCase be ToBoolean(Get(R, "IGNORECASE")).

8.  ReturnIfAbrupt(ignoreCase).

9.  If ignoreCase is TRUE, append "I" as the last code unit of
    result.

10. Let multiline be ToBoolean(Get(R, "MULTILINE")).

11. ReturnIfAbrupt(multiline).

12. If multiline is TRUE, append "M" as the last code unit of
    result.

13. 14. 15. 16. Let unicode be ToBoolean(Get(R, "UNICODE")).

17. ReturnIfAbrupt(unicode).

18. If unicode is TRUE, append "U" as the last code unit of result.

19. Let sticky be ToBoolean(Get(R, "STICKY")).

20. ReturnIfAbrupt(sticky).

21. If sticky is TRUE, append "Y" as the last code unit of result.

22. Return result.

get RegExp.prototype.global

REGEXP.PROTOTYPE.GLOBAL is an accessor property whose set accessor
function is UNDEFINED. Its get accessor function performs the following
steps:

1.  Let R be the THIS value.

2.  If Type(R) is not Object, throw a TYPEERROR exception.

3.  If R does not have an [[OriginalFlags]] internal slot throw a
    TYPEERROR exception.

4.  Let flags be the value of R’s [[OriginalFlags]] internal slot.

5.  6.  If flags contains the code unit "G", return TRUE.

7.  Return FALSE.

get RegExp.prototype.ignoreCase

REGEXP.PROTOTYPE.IGNORECASE is an accessor property whose set accessor
function is UNDEFINED. Its get accessor function performs the following
steps:

1.  Let R be the THIS value.

2.  If Type(R) is not Object, throw a TYPEERROR exception.

3.  If R does not have an [[OriginalFlags]] internal slot throw a
    TYPEERROR exception.

4.  Let flags be the value of R’s [[OriginalFlags]] internal slot.

5.  6.  If flags contains the code unit "I", return TRUE.

7.  Return FALSE.

RegExp.prototype [ @@match ] ( string )

When the @@MATCH method is called with argument string, the following
steps are taken:

1.  Let rx be the THIS value.

2.  If Type(rx) is not Object, throw a TYPEERROR exception.

3.  4.  5.  Let S be ToString(string)

6.  ReturnIfAbrupt(S).

7.  Let global be ToBoolean(Get(rx, "GLOBAL")).

8.  ReturnIfAbrupt(global).

9.  If global is false, then

    a.  Return the result of RegExpExec(rx, S).

10. Else global is TRUE,

    a.  Let putStatus be Put(rx, "LASTINDEX", 0, TRUE).

    b.  ReturnIfAbrupt(putStatus).

    c.  Let A be ArrayCreate(0).

    d.  e.  Let n be 0.

    f.  g.  Repeat,

        i.  Let result be RegExpExec(rx, S).

        ii. ReturnIfAbrupt(result).

        iii. If result is NULL, then

            1.  If n=0, return NULL.

            2.  Else, return A.

        iv. Else result is not NULL,

            1.  Let matchValue be Get(result, "0").

            2.  ReturnIfAbrupt(matchValue).

            3.  Let matchStr be ToString(matchValue).

            4.  ReturnIfAbrupt(matchStr).

            5.  Let status be CreateDataProperty(A, ToString(n),
                matchStr).

            6.  Assert: status is TRUE.

            7.  8.  9.  If matchStr is the empty String, then

                a.  Let thisIndex be ToLength(Get(rx, "LASTINDEX")).

                b.  ReturnIfAbrupt(thisIndex).

            10. a.  Let putStatus be Put(rx, "LASTINDEX",
                    thisIndex+1, TRUE).

                b.  ReturnIfAbrupt(putStatus).

                c.  

            11. a.  

            12. 13. 14. 15. Increment n.

The value of the NAME property of this function is "[SYMBOL.MATCH]".

NOTE The @@match property is used by the IsRegExp abstract operation to
identify objects that have the basic behaviour of regular expressions.
The absence of a @@match property or the existence of such a property
whose value does not Boolean coerce to TRUE indicates that the object is
not intended to be used as a regular expression object.

a.  b.  

get RegExp.prototype.multiline

REGEXP.PROTOTYPE.MULTILINE is an accessor property whose set accessor
function is UNDEFINED. Its get accessor function performs the following
steps:

1.  Let R be the THIS value.

2.  If Type(R) is not Object, throw a TYPEERROR exception.

3.  If R does not have an [[OriginalFlags]] internal slot throw a
    TYPEERROR exception.

4.  Let flags be the value of R’s [[OriginalFlags]] internal slot.

5.  6.  If flags contains the code unit "M", return TRUE.

7.  Return FALSE.

RegExp.prototype [ @@replace ] ( string, replaceValue )

When the @@REPLACE method is called with arguments string and
replaceValue the following steps are taken:

1.  Let rx be the THIS value.

2.  If Type(rx) is not Object, throw a TYPEERROR exception.

3.  4.  5.  6.  Let S be ToString(string).

7.  ReturnIfAbrupt(S).

8.  Let lengthS be the number of code unit elements in S.

9.  Let functionalReplace be IsCallable(replaceValue).

10. If functionalReplace is FALSE, then

    a.  Let replaceValue be ToString(replaceValue).

    b.  ReturnIfAbrupt(replaceValue).

11. Let global be ToBoolean(Get(rx, "GLOBAL")).

12. ReturnIfAbrupt(global).

13. 14. 15. If global is TRUE, then

    a.  Let putStatus be Put(rx, "LASTINDEX", 0, TRUE).

    b.  ReturnIfAbrupt(putStatus).

16. 17. Let results be a new empty List.

18. Let done be FALSE.

19. Repeat, while done is FALSE

    a.  Let result be RegExpExec(rx, S).

    b.  ReturnIfAbrupt(result).

    c.  If result is NULL, set done to TRUE.

    d.  Else result is not NULL,

        i.  Append result to the end of results.

        ii. If global is FALSE, set done to TRUE.

        iii. Else,

            1.  Let matchStr be ToString(Get(result, "0")).

            2.  ReturnIfAbrupt(matchStr).

            3.  If matchStr is the empty String, then

                a.  Let thisIndex be ToLength(Get(rx, "LASTINDEX")).

                b.  ReturnIfAbrupt(thisIndex).

            4.  a.  Let putStatus be Put(rx, "LASTINDEX",
                    thisIndex+1, TRUE).

                b.  ReturnIfAbrupt(putStatus).

                c.  

            5.  a.  

    e.  

20. Let accumulatedResult be the empty String value.

21. Let nextSourcePosition be 0.

22. 23. 24. Repeat, for each result in results,

    a.  Let nCaptures be ToLength(Get(result, "LENGTH")).

    b.  ReturnIfAbrupt(nCaptures).

    c.  Let nCaptures be max(nCaptures − 1, 0).

25. a.  Let matched be ToString(Get(result, "0")).

    b.  ReturnIfAbrupt(matched).

    c.  Let matchLength be the number of code units in matched.

    d.  Let position be ToInteger(Get(result, "INDEX")).

    e.  ReturnIfAbrupt(position).

    f.  Let position be max(min(position, lengthS), 0).

    g.  Let n be 1.

    h.  Let captures be an empty List.

    i.  Repeat while n ≤ nCaptures

        i.  Let capN be Get(result, ToString(n)).

        ii. If Type(capN) is not Undefined, let capN be
            ToString(capN).

        iii. ReturnIfAbrupt(capN).

        iv. Append capN as the last element of captures.

        v.  Let n be n+1

    j.  If functionalReplace is TRUE, then

        i.  Let replacerArgs be the List (matched).

        ii. Append in list order the elements of captures to the end
            of the List replacerArgs.

        iii. Append position and S as the last two elements of
            replacerArgs.

        iv. Let replValue be Call(replaceValue, UNDEFINED,
            replacerArgs).

        v.  Let replacement be ToString(replValue).

    k.  Else,

        i.  Let replacement be GetReplaceSubstitution(matched, S,
            position, captures, replaceValue).

    l.  ReturnIfAbrupt(replacement).

    m.  If position ≥ nextSourcePosition, then

    n.  i.  NOTE position should not normally move backwards. If it
            does, it is in indication of a ill-behaving RegExp subclass
            or use of an access triggered side-effect to change the
            global flag or other characteristics of rx. In such cases,
            the corresponding substitution is ignored.

        ii. iii. iv. Let accumulatedResult be the String formed by
            concatenating the code units of the current value of
            accumulatedResult with the substring of S consisting of
            the code units from nextSourcePosition (inclusive) up to
            position (exclusive) and with the code units of
            replacement.

        v.  vi. Let nextSourcePosition be position + matchLength.

26. If nextSourcePosition ≥ lengthS, return accumulatedResult.

27. Return the String formed by concatenating the code units of
    accumulatedResult with the substring of S consisting of the code
    units from nextSourcePosition (inclusive) up through the final
    code unit of S (inclusive).

The value of the NAME property of this function is "[SYMBOL.REPLACE]".

RegExp.prototype [ @@search ] ( string )

When the @@search method is called with argument string, the following
steps are taken:

1.  Let rx be the THIS value.

2.  If Type(rx) is not Object, throw a TYPEERROR exception.

3.  4.  5.  Let S be ToString(string).

6.  ReturnIfAbrupt(S).

7.  Let previousLastIndex be Get(rx, "LASTINDEX").

8.  ReturnIfAbrupt(previousLastIndex).

9.  Let status be Put(rx, "LASTINDEX", 0, TRUE)

10. ReturnIfAbrupt(status)

11. Let result be RegExpExec(rx, S).

12. ReturnIfAbrupt(result).

13. Let status be Put(rx, "LASTINDEX", previousLastIndex, TRUE)

14. ReturnIfAbrupt(status)

15. If result is NULL, return –1.

16. Return Get(result, "INDEX").

The value of the NAME property of this function is "[SYMBOL.SEARCH]".

NOTE The LASTINDEX and GLOBAL properties of this RegExp object are
ignored when performing the search. The LASTINDEX property is left
unchanged.

get RegExp.prototype.source

REGEXP.PROTOTYPE.SOURCE is an accessor property whose set accessor
function is UNDEFINED. Its get accessor function performs the following
steps:

1.  Let R be the THIS value.

2.  If Type(R) is not Object, throw a TYPEERROR exception.

3.  If R does not have an [[OriginalSource]] internal slot throw a
    TYPEERROR exception.

4.  If R does not have an [[OriginalFlags]] internal slot throw a
    TYPEERROR exception.

5.  Let src be the value of R’s [[OriginalSource]] internal slot.

6.  Let flags be the value of R’s [[OriginalFlags]] internal slot.

7.  8.  Return EscapeRegExpPattern(src, flags).

RegExp.prototype [ @@split ] ( string, limit )

NOTE Returns an Array object into which substrings of the result of
converting string to a String have been stored. The substrings are
determined by searching from left to right for matches of the THIS value
regular expression; these occurrences are not part of any substring in
the returned array, but serve to divide up the String value.

The THIS value may be an empty regular expression or a regular
expression that can match an empty String. In this case, regular
expression does not match the empty substring at the beginning or end of
the input String, nor does it match the empty substring at the end of
the previous separator match. (For example, if the regular expression
matches the empty String, the String is split up into individual code
unit elements; the length of the result array equals the length of the
String, and each substring contains one code unit.) Only the first match
at a given index of the THIS String is considered, even if backtracking
could yield a non-empty-substring match at that index. (For example,
/A*?/[SYMBOL.SPLIT]("AB") evaluates to the array ["A","B"], while
/A*/[SYMBOL.SPLIT]("AB") evaluates to the array["","B"].)

If the string is (or converts to) the empty String, the result depends
on whether the regular expression can match the empty String. If it can,
the result array contains no elements. Otherwise, the result array
contains one element, which is the empty String.

If the regular expression that contains capturing parentheses, then each
time separator is matched the results (including any UNDEFINED
results) of the capturing parentheses are spliced into the output array.
For example,

/<(\/)?([^<>]+)>/[Symbol.split]("A<B>bold</B>and<CODE>coded</CODE>")

evaluates to the array

["A", undefined, "B", "bold", "/", "B", "and", undefined,"CODE",
"coded", "/", "CODE", ""]

If limit is not UNDEFINED, then the output array is truncated so that
it contains no more than limit elements.

When the @@SPLIT method is called, the following steps are taken:

1.  Let rx be the THIS value.

2.  If Type(rx) is not Object, throw a TYPEERROR exception.

3.  4.  5.  6.  7.  Let S be ToString(string).

8.  ReturnIfAbrupt(S).

9.  Let C be SpeciesConstructor(rx, %RegExp%).

10. ReturnIfAbrupt(C).

11. Let flags be ToString(Get(rx, "FLAGS"))

12. 13. ReturnIfAbrupt(flags).

14. If flags contains "U", let unicodeMatching be TRUE.

15. Ese, let unicodeMatching be FALSE.

16. If flags contains "Y", let newFlags be flags.

17. Else,et newFlags be the string that is the concatenation of
    flags and "Y".

18. 19. Let splitter be Construct(C, «rx, newFlags»).

20. ReturnIfAbrupt(splitter).

21. 22. Let A be ArrayCreate(0).

23. 24. Let lengthA be 0.

25. If limit is UNDEFINED, let lim = 2^53^–1; else let lim =
    ToLength(limit).

26. ReturnIfAbrupt(lim).

27. Let size be the number of elements in S.

28. Let p = 0.

29. If lim = 0, return A.

30. If size = 0, then

    a.  Let z be RegExpExec(splitter, S).

    b.  ReturnIfAbrupt(z).

    c.  If z is not NULL, return A.

    d.  Assert: The following call will never result in an abrupt
        completion.

    e.  Call CreateDataProperty(A, "0", S).

    f.  Return A.

31. Let q = p.

32. Repeat, while q < size

    a.  Let putStatus be Put(splitter, "LASTINDEX", q, TRUE).

    b.  ReturnIfAbrupt(putStatus).

    c.  Let z be RegExpExec(splitter, S).

    d.  ReturnIfAbrupt(z).

    e.  If z is NULL, then

        i.  If unicodeMatching is TRUE, then

            1.  Let first be the code unit value of the element at
                index q in the String S.

            2.  If first ≥ 0xD800 and first ≤ 0xDBFF and q+1 ≠
                size, then

            3.  a.  Let second be the code unit value of the element
                    at index q+1 in the String S.

                b.  If second ≥ 0xDC00 and second ≤ 0xDFFF, then

                    i.  Let q = q+1.

        ii. Let q = q+1.

    f.  Else z is not NULL,

        i.  Let e be ToLength(Get(splitter, "LASTINDEX")).

        ii. ReturnIfAbrupt(e).

        iii. iv. If e = p, then

            1.  If unicodeMatching is TRUE, then

                a.  Let first be the code unit value of the element at
                    index q in the String S.

                b.  If first ≥ 0xD800 and first ≤ 0xDBFF and q+1 ≠
                    size, then

                c.  i.  Let second be the code unit value of the
                        element at index q+1 in the String S.

                    ii. If second ≥ 0xDC00 and second ≤ 0xDFFF, then

                        1.  Let q = q+1.

            2.  Let q = q+1.

        v.  Else e ≠ p,

            1.  Let T be a String value equal to the substring of S
                consisting of the elements at indices p (inclusive)
                through q (exclusive).

            2.  Assert: The following call will never result in an
                abrupt completion.

            3.  Call CreateDataProperty(A, ToString(lengthA), T).

            4.  Let lengthA be lengthA +1.

            5.  If lengthA = lim, return A.

            6.  Let p = e.

            7.  Let i = 0.

            8.  Let numberOfCaptures be ToLength(Get(z, "LENGTH")).

            9.  ReturnIfAbrupt(numberOfCaptures).

            10. Let numberOfCaptures be max(numberOfCaptures-1, 0).

            11. Let i be 1.

            12. Repeat, while i ≤ numberOfCaptures.

                a.  b.  Let nextCapture be Get(z, ToString(i)).

                c.  ReturnIfAbrupt(nextCapture).

                d.  Call CreateDataProperty(A, ToString(lengthA),
                    nextCapture).

                e.  Let i be i +1.

                f.  Let lengthA be lengthA +1.

                g.  If lengthA = lim, return A.

            13. Let q = p.

33. Let T be a String value equal to the substring of S consisting
    of the elements at indices p (inclusive) through size
    (exclusive).

34. Assert: The following call will never result in an abrupt
    completion.

35. Call CreateDataProperty(A, ToString(lengthA), T ).

36. Return A.

The LENGTH property of the @@SPLIT method is 2.

The value of the NAME property of this function is "[SYMBOL.SPLIT]".

NOTE The @@SPLIT method ignores the value of the GLOBAL and STICKY
properties of this RegExp object.

get RegExp.prototype.sticky

REGEXP.PROTOTYPE.STICKY is an accessor property whose set accessor
function is UNDEFINED. Its get accessor function performs the following
steps:

1.  Let R be the THIS value.

2.  If Type(R) is not Object, throw a TYPEERROR exception.

3.  If R does not have an [[OriginalFlags]] internal slot throw a
    TYPEERROR exception.

4.  Let flags be the value of R’s [[OriginalFlags]] internal slot.

5.  6.  If flags contains the code unit "Y", return TRUE.

7.  Return FALSE.

RegExp.prototype.test( S )

The following steps are taken:

1.  Let R be the THIS value.

2.  If Type(R) is not Object, throw a TYPEERROR exception.

3.  Let string be ToString(S).

4.  ReturnIfAbrupt(string).

5.  Let match be RegExpExec(R, string).

6.  ReturnIfAbrupt(match).

7.  If match is not NULL, return TRUE; else return FALSE.

RegExp.prototype.toString ( )

1.  Let R be the THIS value.

2.  If Type(R) is not Object, throw a TYPEERROR exception.

3.  4.  5.  Let pattern be ToString(Get(R, "SOURCE")).

6.  ReturnIfAbrupt(pattern).

7.  Let flags be ToString(Get(R, "FLAGS")).

8.  ReturnIfAbrupt(flags).

9.  Let result be the String value formed by concatenating "/",
    pattern, and "/", and flags.

10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 24. 25. 

NOTE The returned String has the form of a RegularExpressionLiteral
that evaluates to another RegExp object with the same behaviour as this
object.

get RegExp.prototype.unicode

REGEXP.PROTOTYPE.UNICODE is an accessor property whose set accessor
function is UNDEFINED. Its get accessor function performs the following
steps:

1.  Let R be the THIS value.

2.  If Type(R) is not Object, throw a TYPEERROR exception.

3.  If R does not have an [[OriginalFlags]] internal slot throw a
    TYPEERROR exception.

4.  Let flags be the value of R’s [[OriginalFlags]] internal slot.

5.  6.  If flags contains the code unit "U", return TRUE.

7.  Return FALSE.

Properties of RegExp Instances

RegExp instances are ordinary objects that inherit properties from the
RegExp prototype object. RegExp instances have internal slots
[[RegExpMatcher]], [[OriginalSource]], and [[OriginalFlags]]. The value
of the [[RegExpMatcher]] internal slot is an implementation dependent
representation of the Pattern of the RegExp object.

NOTE Prior to the 6^th^ Edition, REGEXP instances were specified as
having the own data properties SOURCE, GLOBAL, IGNORECASE, and
MULTILINE. Those properties are now specified as accessor properties of
RegExp.prototype.

RegExp instances also have the following property:

lastIndex

The value of the LASTINDEX property specifies the String index at which
to start the next match. It is coerced to an integer when used (see
21.2.5.2.2). This property shall have the attributes { [[Writable]]:
TRUE, [[Enumerable]]: FALSE, [[Configurable]]: FALSE }.



INDEXED COLLECTIONS 


Array Objects

Array objects are exotic objects that give special treatment to a
certain class of property names. See 9.4.1.4 for a definition of this
special treatment.

1.  

2.  a.  b.  

3.  

The Array Constructor

The Array constructor is the %Array% intrinsic object and the initial
value of the ARRAY property of the global object. When called as a
constructor it creates and initializes a new exotic Array object. When
ARRAY is called as a function rather than as a constructor, it also
creates and initializes a new Array object. Thus the function call
ARRAY(…) is equivalent to the object creation expression NEW ARRAY(…)
with the same arguments.

The ARRAY constructor is a single function whose behaviour is overloaded
based upon the number and types of its arguments.

The ARRAY constructor is designed to be subclassable. It may be used as
the value of an EXTENDS clause of a class definition. Subclass
constructors that intend to inherit the exotic ARRAY behaviour must
include a SUPER call to the ARRAY constructor to initialize subclass
instances that are exotic Array objects. However, most of the
ARRAY.PROTOTYPE methods are generic methods that are not dependent upon
their THIS value being an exotic Array object.

The LENGTH property of the ARRAY constructor function is 1.

Array ( )

This description applies if and only if the Array constructor is called
with no arguments.

1.  Let numberOfArgs be the number of arguments passed to this
    function call.

2.  Assert: numberOfArgs = 0.

3.  If NewTarget is UNDEFINED, let newTarget be the active function
    object, else let newTarget be NewTarget.

4.  5.  a.  b.  

6.  a.  

7.  Let proto be GetPrototypeFromConstructor(newTarget,
    "%ARRAYPROTOTYPE%").

8.  ReturnIfAbrupt(proto).

9.  Return ArrayCreate(0, proto).

10. 11. 12. 13. 

Array (len)

This description applies if and only if the Array constructor is called
with exactly one argument.

1.  Let numberOfArgs be the number of arguments passed to this
    function call.

2.  Assert: numberOfArgs = 1.

3.  If NewTarget is UNDEFINED, let newTarget be the active function
    object, else let newTarget be NewTarget.

4.  a.  b.  

5.  a.  

6.  Let proto be GetPrototypeFromConstructor(newTarget,
    "%ARRAYPROTOTYPE%").

7.  ReturnIfAbrupt(proto).

8.  Let array be ArrayCreate(0, proto).

9.  10. If Type(len) is not Number, then

    a.  Let defineStatus be CreateDataPropertyOrThrow(array, "0",
        len).

    b.  Assert: defineStatus is not an abrupt completion.

    c.  Let intLen be 1.

11. Else,

    a.  Let intLen be ToUint32(len).

    b.  If intLen ≠ len, throw a RANGEERROR exception.

12. Let putStatus be Put(array, "LENGTH", intLen, TRUE).

13. Assert: putStatus is not an abrupt completion.

14. Return array.

Array (...items )

This description applies if and only if the Array constructor is called
with at least two arguments.

When the ARRAY function is called the following steps are taken:

1.  Let numberOfArgs be the number of arguments passed to this
    function call.

2.  Assert: numberOfArgs ≥ 2.

3.  If NewTarget is UNDEFINED, let newTarget be the active function
    object, else let newTarget be NewTarget.

4.  5.  6.  7.  8.  9.  Let proto be
    GetPrototypeFromConstructor(newTarget, "%ARRAYPROTOTYPE%").

10. ReturnIfAbrupt(proto).

11. Let array be ArrayCreate(numberOfArgs, proto).

12. ReturnIfAbrupt(array).

13. Let k be 0.

14. Let items be a zero-origined List containing the argument items in
    order.

15. Repeat, while k < numberOfArgs

    a.  Let Pk be ToString(k).

    b.  Let itemK be k^th^ element of items.

    c.  Let defineStatus be CreateDataPropertyOrThrow(array, Pk,
        itemK).

    d.  Assert: defineStatus is not an abrupt completion.

    e.  Increase k by 1.

16. Assert: the value of array’s LENGTH property is numberOfArgs.

17. 18. Return array.

1.  2.  3.  

Properties of the Array Constructor

The value of the [[Prototype]] internal slot of the Array constructor is
the intrinsic object %FunctionPrototype% (19.2.3).

1.  2.  3.  

Besides the LENGTH property (whose value is 1), the Array constructor
has the following properties:

Array.from ( items [ , mapfn [ , thisArg ] ] )

When the FROM method is called with argument items and optional
arguments mapfn and thisArg the following steps are taken:

1.  Let C be the THIS value.

2.  3.  4.  If mapfn is UNDEFINED, let mapping be FALSE.

5.  else

    a.  If IsCallable(mapfn) is FALSE, throw a TYPEERROR exception.

    b.  If thisArg was supplied, let T be thisArg; else let T be
        UNDEFINED.

    c.  Let mapping be TRUE

6.  Let usingIterator be GetMethod(items, @@iterator).

7.  ReturnIfAbrupt(usingIterator).

8.  If usingIterator is not UNDEFINED, then

    a.  If IsConstructor(C) is TRUE, then

        i.  Let A be Construct(C).

    b.  Else,

        i.  Let A be ArrayCreate(0).

    c.  ReturnIfAbrupt(A).

    d.  Let iterator be GetIterator(items, usingIterator).

    e.  ReturnIfAbrupt(iterator).

    f.  Let k be 0.

    g.  Repeat

        i.  Let Pk be ToString(k).

        ii. Let next be IteratorStep(iterator).

        iii. If next is an abrupt completion, return
            IteratorClose(iterator, next).

        iv. If next.[[value]] is FALSE, then

        v.  1.  Let putStatus be Put(A, "LENGTH", k, TRUE).

            2.  ReturnIfAbrupt(putStatus).

            3.  Return A.

        vi. Let nextValue be IteratorValue(next.[[value]]).

        vii. If nextValue is an abrupt completion, return
            IteratorClose(iterator, nextValue).

        viii. If mapping is TRUE, then

            1.  Let mappedValue be Call(mapfn, T,
                «nextValue.[[value]], k»).

            2.  If mappedValue is an abrupt completion, return
                IteratorClose(iterator, mappedValue).

        ix. Else, let mappedValue be nextValue.

        x.  Let defineStatus be CreateDataPropertyOrThrow(A, Pk,
            mappedValue.[[value]]).

        xi. If defineStatus is an abrupt completion, return
            IteratorClose(iterator, defineStatus).

        xii. Increase k by 1.

9.  Assert: items is not an Iterable so assume it is an array-like
    object.

10. Let arrayLike be ToObject(items).

11. ReturnIfAbrupt(arrayLike).

12. Let len be ToLength(Get(arrayLike, "LENGTH")).

13. 14. ReturnIfAbrupt(len).

15. If IsConstructor(C) is TRUE, then

    a.  Let A be Construct(C, «len»).

16. Else,

    a.  Let A be ArrayCreate(len).

17. ReturnIfAbrupt(A).

18. Let k be 0.

19. Repeat, while k < len

    a.  Let Pk be ToString(k).

    b.  Let kValue be Get(arrayLike, Pk).

    c.  ReturnIfAbrupt(kValue).

    d.  If mapping is TRUE, then

        i.  Let mappedValue be Call(mapfn, T, «kValue, k»).

        ii. ReturnIfAbrupt(mappedValue).

    e.  Else, let mappedValue be kValue.

    f.  Let defineStatus be CreateDataPropertyOrThrow(A, Pk,
        mappedValue).

    g.  ReturnIfAbrupt(defineStatus).

    h.  Increase k by 1.

20. Let putStatus be Put(A, "LENGTH", len, TRUE).

21. ReturnIfAbrupt(putStatus).

22. Return A.

The LENGTH property of the FROM method is 1.

NOTE The FROM function is an intentionally generic factory method; it
does not require that its THIS value be the Array constructor. Therefore
it can be transferred to or inherited by any other constructors that may
be called with a single numeric argument.

Array.isArray ( arg )

The ISARRAY function takes one argument arg, and performs the
following steps:

1.  2.  3.  Return IsArray(arg).

Array.of ( ...items )

When the OF method is called with any number of arguments, the following
steps are taken:

1.  Let len be the actual number of arguments passed to this function.

2.  Let items be the List of arguments passed to this function.

3.  4.  Let C be the THIS value.

5.  If IsConstructor(C) is TRUE, then

    a.  Let A be Construct(C, «len»).

6.  Else,

    a.  Let A be ArrayCreate(len).

7.  ReturnIfAbrupt(A).

8.  Let k be 0.

9.  Repeat, while k < len

    a.  b.  Let kValue be element k of items.

    c.  Let Pk be ToString(k).

    d.  Let defineStatus be CreateDataPropertyOrThrow(A_,_Pk,
        kValue.[[value]]).

    e.  ReturnIfAbrupt(defineStatus).

    f.  Increase k by 1.

10. Let putStatus be Put(A, "LENGTH", len, TRUE).

11. ReturnIfAbrupt(putStatus).

12. Return A.

The LENGTH property of the OF method is 0.

NOTE 1 The items argument is assumed to be a well-formed rest argument
value.

NOTE 2 The OF function is an intentionally generic factory method; it
does not require that its THIS value be the Array constructor. Therefore
it can be transferred to or inherited by other constructors that may be
called with a single numeric argument.

Array.prototype

The value of ARRAY.PROTOTYPE is %ArrayPrototype%, the intrinsic Array
prototype object (22.1.3).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

1.  2.  3.  4.  5.  

get Array [ @@species ] 

ARRAY[@@SPECIES] is an accessor property whose set accessor function is
UNDEFINED. Its get accessor function performs the following steps:

1.  Return THIS.

The value of the NAME property of this function is "GET
[SYMBOL.SPECIES]".

NOTE Array prototype methods normally use their THIS object’s
constructor to create a derived object. However, a subclass constructor
may over-ride that default behaviour by redefining its @@species
property.

Properties of the Array Prototype Object

The value of the [[Prototype]] internal slot of the Array prototype
object is the intrinsic object %ObjectPrototype%.

The Array prototype object is itself an ordinary object. It is not an
Array instance and does not have a LENGTH property .

NOTE The Array prototype object does not have a VALUEOF property of its
own; however, it inherits the VALUEOF property from the standard
built-in Object prototype Object.

Array.prototype.concat ( ...arguments )

When the CONCAT method is called with zero or more arguments, it returns
an array containing the array elements of the object followed by the
array elements of each argument in order.

The following steps are taken:

1.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(O).

3.  Let A be ArraySpeciesCreate(O, 0).

4.  5.  a.  b.  c.  i.  ii. 1.  

6.  a.  

7.  ReturnIfAbrupt(A).

8.  Let n be 0.

9.  Let items be a List whose first element is O and whose
    subsequent elements are, in left to right order, the arguments that
    were passed to this function invocation.

10. Repeat, while items is not empty

    a.  Remove the first element from items and let E be the value
        of the element.

    b.  Let spreadable be IsConcatSpreadable(E).

    c.  ReturnIfAbrupt(spreadable).

    d.  If spreadable is TRUE, then

        i.  Let k be 0.

        ii. Let len be ToLength(Get(E, "LENGTH")).

        iii. iv. ReturnIfAbrupt(len).

        v.  If n + len+ > 2^53^-1, throw a TYPEERROR exception.

        vi. Repeat, while k < len

            1.  Let P be ToString(k).

            2.  Let exists be HasProperty(E, P).

            3.  ReturnIfAbrupt(exists).

            4.  If exists is TRUE, then

                a.  Let subElement be Get(E, P).

                b.  ReturnIfAbrupt(subElement).

                c.  d.  Let status be CreateDataPropertyOrThrow (A,
                    ToString(n), subElement).

                e.  ReturnIfAbrupt(status).

            5.  Increase n by 1.

            6.  Increase k by 1.

    e.  Else E is added as a single item rather than spread,

        i.  If n≥2^53^-1, throw a TYPEERROR exception.

        ii. Let status be CreateDataPropertyOrThrow (A,
            ToString(n), E).

        iii. ReturnIfAbrupt(status).

        iv. Increase n by 1.

11. Let putStatus be Put(A, "LENGTH", n, TRUE).

12. ReturnIfAbrupt(putStatus).

13. Return A.

The LENGTH property of the CONCAT method is 1.

NOTE 1 The explicit setting of the LENGTH property in step 10 is
necessary to ensure that its value is correct in situations where the
trailing elements of the result Array are not present.

NOTE 2 The CONCAT function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method.

IsConcatSpreadable ( O ) Abstract Operation

The abstract operation IsConcatSpreadable with argument O performs the
following steps:

1.  If Type(O) is not Object, return FALSE.

2.  Let spreadable be Get(O, @@isConcatSpreadable).

3.  ReturnIfAbrupt(spreadable).

4.  If spreadable is not UNDEFINED, return ToBoolean(spreadable).

5.  6.  Return IsArray(O).

Array.prototype.constructor

The initial value of ARRAY.PROTOTYPE.CONSTRUCTOR is the intrinsic object
%Array%.

Array.prototype.copyWithin (target, start [ , end ] )

The COPYWITHIN method takes up to three arguments target, start and
end.

NOTE The end argument is optional with the length of the THIS object
as its default value. If target is negative, it is treated as
length_+_target where length is the length of the array. If start
is negative, it is treated as length_+_start. If end is negative, it
is treated as length_+_end.

The following steps are taken:

1.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(O).

3.  Let len be ToLength(Get(O, "LENGTH")).

4.  5.  ReturnIfAbrupt(len).

6.  Let relativeTarget be ToInteger(target).

7.  ReturnIfAbrupt(relativeTarget).

8.  If relativeTarget < 0, let to be max((len +
    relativeTarget),0); else let to be min(relativeTarget, len).

9.  Let relativeStart be ToInteger(start).

10. ReturnIfAbrupt(relativeStart).

11. If relativeStart < 0, let from be max((len +
    relativeStart),0); else let from be min(relativeStart, len).

12. If end is UNDEFINED, let relativeEnd be len; else let
    relativeEnd be ToInteger(end).

13. ReturnIfAbrupt(relativeEnd).

14. If relativeEnd < 0, let final be max((len + relativeEnd),0);
    else let final be min(relativeEnd, len).

15. Let count be min(final_-_from, len_-_to).

16. If from_<_to and to_<_from_+_count

    a.  Let direction = -1.

    b.  Let from = from + count -1.

    c.  Let to = to + count -1.

17. Else,

    a.  Let direction = 1.

18. Repeat, while count > 0

    a.  Let fromKey be ToString(from).

    b.  Let toKey be ToString(to).

    c.  Let fromPresent be HasProperty(O, fromKey).

    d.  ReturnIfAbrupt(fromPresent).

    e.  If fromPresent is TRUE, then

        i.  Let fromVal be Get(O, fromKey).

        ii. ReturnIfAbrupt(fromVal).

        iii. Let putStatus be Put(O, toKey, fromVal, TRUE).

        iv. ReturnIfAbrupt(putStatus).

    f.  Else fromPresent is FALSE,

        i.  Let deleteStatus be DeletePropertyOrThrow(O, toKey).

        ii. ReturnIfAbrupt(deleteStatus).

    g.  Let from be from + direction.

    h.  Let to be to + direction.

    i.  Let count be count − 1.

19. Return O.

The LENGTH property of the COPYWITHIN method is 2.

NOTE 1 The COPYWITHIN function is intentionally generic; it does not
require that its THIS value be an Array object. Therefore it can be
transferred to other kinds of objects for use as a method.

Array.prototype.entries ( )

The following steps are taken:

1.  Let O be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(O).

3.  Return CreateArrayIterator(O, "KEY+VALUE").

Array.prototype.every ( callbackfn [ , thisArg] )

NOTE callbackfn should be a function that accepts three arguments and
returns a value that is coercible to the Boolean value TRUE or FALSE.
EVERY calls callbackfn once for each element present in the array, in
ascending order, until it finds one where callbackfn returns FALSE. If
such an element is found, EVERY immediately returns FALSE. Otherwise, if
callbackfn returned TRUE for all elements, EVERY will return TRUE.
callbackfn is called only for elements of the array which actually
exist; it is not called for missing elements of the array.

If a thisArg parameter is provided, it will be used as the THIS value
for each invocation of callbackfn. If it is not provided, UNDEFINED is
used instead.

callbackfn is called with three arguments: the value of the element,
the index of the element, and the object being traversed.

EVERY does not directly mutate the object on which it is called but the
object may be mutated by the calls to callbackfn.

The range of elements processed by EVERY is set before the first call to
callbackfn. Elements which are appended to the array after the call to
EVERY begins will not be visited by callbackfn. If existing elements
of the array are changed, their value as passed to callbackfn will be
the value at the time EVERY visits them; elements that are deleted after
the call to EVERY begins and before being visited are not visited. EVERY
acts like the "for all" quantifier in mathematics. In particular, for an
empty array, it returns TRUE.

When the EVERY method is called with one or two arguments, the following
steps are taken:

1.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(O).

3.  Let len be ToLength(Get(O, "LENGTH")).

4.  5.  ReturnIfAbrupt(len).

6.  If IsCallable(callbackfn) is FALSE, throw a TYPEERROR exception.

7.  If thisArg was supplied, let T be thisArg; else let T be
    UNDEFINED.

8.  Let k be 0.

9.  Repeat, while k < len

    a.  Let Pk be ToString(k).

    b.  Let kPresent be HasProperty(O, Pk).

    c.  ReturnIfAbrupt(kPresent).

    d.  If kPresent is TRUE, then

        i.  Let kValue be Get(O, Pk).

        ii. ReturnIfAbrupt(kValue).

        iii. Let testResult be ToBoolean(Call(callbackfn, T,
            «kValue, k, O»)).

        iv. ReturnIfAbrupt(testResult).

        v.  If testResult is FALSE, return FALSE.

    e.  Increase k by 1.

10. Return TRUE.

The LENGTH property of the EVERY method is 1.

NOTE The EVERY function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method.

Array.prototype.fill (value [ , start [ , end ] ] )

The FILL method takes up to three arguments value, start and end.

NOTE The start and end arguments are optional with default values of
0 and the length of the THIS object. If start is negative, it is
treated as length_+_start where length is the length of the array.
If end is negative, it is treated as length_+_end.

The following steps are taken:

1.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(O).

3.  Let len be ToLength(Get(O, "LENGTH")).

4.  5.  ReturnIfAbrupt(len).

6.  Let relativeStart be ToInteger(start).

7.  ReturnIfAbrupt(relativeStart).

8.  If relativeStart < 0, let k be max((len + relativeStart),0);
    else let k be min(relativeStart, len).

9.  If end is UNDEFINED, let relativeEnd be len; else let
    relativeEnd be ToInteger(end).

10. ReturnIfAbrupt(relativeEnd).

11. If relativeEnd < 0, let final be max((len + relativeEnd),0);
    else let final be min(relativeEnd, len).

12. Repeat, while k < final

    a.  Let Pk be ToString(k).

    b.  Let putStatus be Put(O, Pk, value, TRUE).

    c.  ReturnIfAbrupt(putStatus).

    d.  Increase k by 1.

13. Return O.

The LENGTH property of the FILL method is 1.

NOTE 1 The FILL function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method.

Array.prototype.filter ( callbackfn [ , thisArg ] )

NOTE callbackfn should be a function that accepts three arguments and
returns a value that is coercible to the Boolean value TRUE or FALSE.
FILTER calls callbackfn once for each element in the array, in
ascending order, and constructs a new array of all the values for which
callbackfn returns TRUE. callbackfn is called only for elements of
the array which actually exist; it is not called for missing elements of
the array.

If a thisArg parameter is provided, it will be used as the THIS value
for each invocation of callbackfn. If it is not provided, UNDEFINED is
used instead.

callbackfn is called with three arguments: the value of the element,
the index of the element, and the object being traversed.

FILTER does not directly mutate the object on which it is called but the
object may be mutated by the calls to callbackfn.

The range of elements processed by FILTER is set before the first call
to callbackfn. Elements which are appended to the array after the call
to FILTER begins will not be visited by callbackfn. If existing
elements of the array are changed their value as passed to callbackfn
will be the value at the time FILTER visits them; elements that are
deleted after the call to FILTER begins and before being visited are not
visited.

When the FILTER method is called with one or two arguments, the
following steps are taken:

1.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(O).

3.  Let len be ToLength(Get(O, "LENGTH")).

4.  5.  ReturnIfAbrupt(len).

6.  If IsCallable(callbackfn) is FALSE, throw a TYPEERROR exception.

7.  If thisArg was supplied, let T be thisArg; else let T be
    UNDEFINED.

8.  Let A be ArraySpeciesCreate(O, 0).

9.  10. a.  b.  c.  i.  ii. 1.  

11. a.  

12. ReturnIfAbrupt(A).

13. Let k be 0.

14. Let to be 0.

15. Repeat, while k < len

    a.  Let Pk be ToString(k).

    b.  Let kPresent be HasProperty(O, Pk).

    c.  ReturnIfAbrupt(kPresent).

    d.  If kPresent is TRUE, then

        i.  Let kValue be Get(O, Pk).

        ii. ReturnIfAbrupt(kValue).

        iii. Let selected be ToBoolean(Call(callbackfn, T,
            «kValue, k, O»)).

        iv. ReturnIfAbrupt(selected).

        v.  If selected is TRUE, then

            1.  Let status be CreateDataPropertyOrThrow (A,
                ToString(to), kValue).

            2.  ReturnIfAbrupt(status).

            3.  Increase to by 1.

    e.  Increase k by 1.

16. Return A.

The LENGTH property of the FILTER method is 1.

NOTE The FILTER function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method.

Array.prototype.find ( predicate [ , thisArg ] )

  The FIND method is called with one or two arguments, predicate and
  thisArg.

NOTE predicate should be a function that accepts three arguments and
returns a value that is coercible to a Boolean value. FIND calls
predicate once for each element of the array, in ascending order,
until it finds one where predicate returns TRUE. If such an element is
found, FIND immediately returns that element value. Otherwise, FIND
returns UNDEFINED.

If a thisArg parameter is provided, it will be used as the THIS value
for each invocation of predicate. If it is not provided, UNDEFINED is
used instead.

predicate is called with three arguments: the value of the element,
the index of the element, and the object being traversed.

FIND does not directly mutate the object on which it is called but the
object may be mutated by the calls to predicate.

The range of elements processed by FIND is set before the first call to
callbackfn. Elements that are appended to the array after the call to
FIND begins will not be visited by callbackfn. If existing elements of
the array are changed, their value as passed to predicate will be the
value at the time that FIND visits them; elements that correspond to
non-existent properties are treated as if they the existed and have the
value UNDEFINED.

When the FIND method is called, the following steps are taken:

1.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(O).

3.  Let len be ToLength(Get(O, "LENGTH")).

4.  5.  ReturnIfAbrupt(len).

6.  If IsCallable(predicate) is FALSE, throw a TYPEERROR exception.

7.  If thisArg was supplied, let T be thisArg; else let T be
    UNDEFINED.

8.  Let k be 0.

9.  Repeat, while k < len

    a.  Let Pk be ToString(k).

    b.  c.  d.  e.  Let kValue be Get(O, Pk).

    f.  ReturnIfAbrupt(kValue).

    g.  Let testResult be ToBoolean(Call(predicate, T, «kValue,
        k, O»)).

    h.  ReturnIfAbrupt(testResult).

    i.  If testResult is TRUE, return kValue.

    j.  Increase k by 1.

10. Return UNDEFINED.

The LENGTH property of the FIND method is 1.

NOTE The FIND function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method.

Array.prototype.findIndex ( predicate [ , thisArg ] )

NOTE predicate should be a function that accepts three arguments and
returns a value that is coercible to the Boolean value TRUE or FALSE.
FINDINDEX calls predicate once for each element of the array, in
ascending order, until it finds one where predicate returns TRUE. If
such an element is found, FINDINDEX immediately returns the index of
that element value. Otherwise, FINDINDEX returns -1.

If a thisArg parameter is provided, it will be used as the THIS value
for each invocation of predicate. If it is not provided, UNDEFINED is
used instead.

predicate is called with three arguments: the value of the element,
the index of the element, and the object being traversed.

FINDINDEX does not directly mutate the object on which it is called but
the object may be mutated by the calls to predicate.

The range of elements processed by FINDINDEX is set before the first
call to callbackfn. Elements that are appended to the array after the
call to FINDINDEX begins will not be visited by callbackfn. If
existing elements of the array are changed, their value as passed to
predicate will be the value at the time that FINDINDEX visits them;
elements that are deleted after the call to FINDINDEX begins and before
being visited are not visited.

When the FINDINDEX method is called with one or two arguments, the
following steps are taken:

1.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(O).

3.  Let len be ToLength(Get(O, "LENGTH")).

4.  5.  ReturnIfAbrupt(len).

6.  If IsCallable(predicate) is FALSE, throw a TYPEERROR exception.

7.  If thisArg was supplied, let T be thisArg; else let T be
    UNDEFINED.

8.  Let k be 0.

9.  Repeat, while k < len

    a.  Let Pk be ToString(k).

    b.  c.  d.  e.  Let kValue be Get(O, Pk).

    f.  ReturnIfAbrupt(kValue).

    g.  Let testResult be ToBoolean(Call(predicate, T, «kValue,
        k, O»)).

    h.  ReturnIfAbrupt(testResult).

    i.  If testResult is TRUE, return k.

    j.  Increase k by 1.

10. Return -1.

The LENGTH property of the FINDINDEX method is 1.

NOTE The FINDINDEX function is intentionally generic; it does not
require that its THIS value be an Array object. Therefore it can be
transferred to other kinds of objects for use as a method.

Array.prototype.forEach ( callbackfn [ , thisArg ] )

NOTE callbackfn should be a function that accepts three arguments.
FOREACH calls callbackfn once for each element present in the array,
in ascending order. callbackfn is called only for elements of the
array which actually exist; it is not called for missing elements of the
array.

If a thisArg parameter is provided, it will be used as the THIS value
for each invocation of callbackfn. If it is not provided, UNDEFINED is
used instead.

callbackfn is called with three arguments: the value of the element,
the index of the element, and the object being traversed.

FOREACH does not directly mutate the object on which it is called but
the object may be mutated by the calls to callbackfn.

The range of elements processed by FOREACH is set before the first call
to callbackfn. Elements which are appended to the array after the call
to FOREACH begins will not be visited by callbackfn. If existing
elements of the array are changed, their value as passed to callback
will be the value at the time FOREACH visits them; elements that are
deleted after the call to FOREACH begins and before being visited are
not visited.

When the FOREACH method is called with one or two arguments, the
following steps are taken:

1.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(O).

3.  Let len be ToLength(Get(O, "LENGTH")).

4.  5.  ReturnIfAbrupt(len).

6.  If IsCallable(callbackfn) is FALSE, throw a TYPEERROR exception.

7.  If thisArg was supplied, let T be thisArg; else let T be
    UNDEFINED.

8.  Let k be 0.

9.  Repeat, while k < len

    a.  Let Pk be ToString(k).

    b.  Let kPresent be HasProperty(O, Pk).

    c.  ReturnIfAbrupt(kPresent).

    d.  If kPresent is TRUE, then

        i.  Let kValue be Get(O, Pk).

        ii. ReturnIfAbrupt(kValue).

        iii. Let funcResult be Call(callbackfn, T, «kValue, k,
            O»).

        iv. ReturnIfAbrupt(funcResult).

    e.  Increase k by 1.

10. Return UNDEFINED.

The LENGTH property of the FOREACH method is 1.

NOTE The FOREACH function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method.

Array.prototype.indexOf ( searchElement [ , fromIndex ] )

NOTE INDEXOF compares searchElement to the elements of the array, in
ascending order, using the Strict Equality Comparison algorithm
(7.2.11), and if found at one or more indices, returns the smallest such
index; otherwise, −1 is returned.

The optional second argument fromIndex defaults to 0 (i.e. the whole
array is searched). If it is greater than or equal to the length of the
array, −1is returned, i.e. the array will not be searched. If it is
negative, it is used as the offset from the end of the array to compute
fromIndex. If the computed index is less than 0, the whole array will
be searched.

When the INDEXOF method is called with one or two arguments, the
following steps are taken:

1.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(O).

3.  Let len be ToLength(Get(O, "LENGTH")).

4.  5.  ReturnIfAbrupt(len).

6.  If len is 0, return −1.

7.  If argument fromIndex was passed let n be
    ToInteger(fromIndex); else let n be 0.

8.  ReturnIfAbrupt(n).

9.  If n ≥ len, return −1.

10. If n ≥ 0, then

11. a.  Let k be n.

12. Else n<0,

    a.  Let k be len - abs(n).

    b.  If k < 0, let k be 0.

13. Repeat, while k_<_len

    a.  Let kPresent be HasProperty(O, ToString(k)).

    b.  ReturnIfAbrupt(kPresent).

    c.  If kPresent is TRUE, then

        i.  Let elementK be the result of Get(O, ToString(k)).

        ii. ReturnIfAbrupt(elementK).

        iii. Let same be the result of performing Strict Equality
            Comparison searchElement === elementK.

        iv. If same is TRUE, return k.

    d.  Increase k by 1.

14. Return -1.

The LENGTH property of the INDEXOF method is 1.

NOTE The INDEXOF function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method.

Array.prototype.join (separator)

NOTE The elements of the array are converted to Strings, and these
Strings are then concatenated, separated by occurrences of the
separator. If no separator is provided, a single comma is used as the
separator.

The JOIN method takes one argument, separator, and performs the
following steps:

1.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(O).

3.  Let len be the result of ToLength(Get(O, "LENGTH")).

4.  5.  ReturnIfAbrupt(len).

6.  If separator is UNDEFINED, let separator be the single-element
    String ",".

7.  Let sep be ToString(separator).

8.  ReturnIfAbrupt(sep).

9.  If len is zero, return the empty String.

10. Let element0 be the result of Get(O, "0").

11. If element0 is UNDEFINED or NULL, let R be the empty String;
    otherwise, let R be ToString(element0).

12. ReturnIfAbrupt(R).

13. Let k be 1.

14. Repeat, while k < len

    a.  Let S be the String value produced by concatenating R and
        sep.

    b.  Let element be Get(O, ToString(k)).

    c.  If element is UNDEFINED or NULL, let next be the empty
        String; otherwise, let next be ToString(element).

    d.  ReturnIfAbrupt(next).

    e.  Let R be a String value produced by concatenating S and
        next.

    f.  Increase k by 1.

15. Return R.

The LENGTH property of the JOIN method is 1.

NOTE The JOIN function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore, it can be transferred
to other kinds of objects for use as a method.

Array.prototype.keys ( )

The following steps are taken:

1.  Let O be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(O).

3.  Return CreateArrayIterator(O, "KEY").

Array.prototype.lastIndexOf ( searchElement [ , fromIndex ] )

NOTE LASTINDEXOF compares searchElement to the elements of the array
in descending order using the Strict Equality Comparison algorithm
(7.2.11), and if found at one or more indices, returns the largest such
index; otherwise, −1 is returned.

The optional second argument fromIndex defaults to the array's length
minus one (i.e. the whole array is searched). If it is greater than or
equal to the length of the array, the whole array will be searched. If
it is negative, it is used as the offset from the end of the array to
compute fromIndex. If the computed index is less than 0, −1is
returned.

When the LASTINDEXOF method is called with one or two arguments, the
following steps are taken:

1.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(O).

3.  Let len be ToLength(Get(O, "LENGTH")).

4.  5.  ReturnIfAbrupt(len).

6.  If len is 0, return -1.

7.  If argument fromIndex was passed let n be
    ToInteger(fromIndex); else let n be len-1.

8.  ReturnIfAbrupt(n).

9.  If n ≥ 0, let k be min(n, len – 1).

10. Else n < 0,

    a.  Let k be len - abs(n).

11. Repeat, while k≥ 0

    a.  Let kPresent be HasProperty(O, ToString(k)).

    b.  ReturnIfAbrupt(kPresent).

    c.  If kPresent is TRUE, then

        i.  Let elementK be Get(O, ToString(k)).

        ii. ReturnIfAbrupt(elementK).

        iii. Let same be the result of performing Strict Equality
            Comparison
            searchElement === elementK.

        iv. If same is TRUE, return k.

    d.  Decrease k by 1.

12. Return -1.

The LENGTH property of the LASTINDEXOF method is 1.

NOTE The LASTINDEXOF function is intentionally generic; it does not
require that its THIS value be an Array object. Therefore it can be
transferred to other kinds of objects for use as a method.

Array.prototype.map ( callbackfn [ , thisArg ] )

NOTE callbackfn should be a function that accepts three arguments. MAP
calls callbackfn once for each element in the array, in ascending
order, and constructs a new Array from the results. callbackfn is
called only for elements of the array which actually exist; it is not
called for missing elements of the array.

If a thisArg parameter is provided, it will be used as the THIS value
for each invocation of callbackfn. If it is not provided, UNDEFINED is
used instead.

callbackfn is called with three arguments: the value of the element,
the index of the element, and the object being traversed.

MAP does not directly mutate the object on which it is called but the
object may be mutated by the calls to callbackfn.

The range of elements processed by MAP is set before the first call to
callbackfn. Elements which are appended to the array after the call to
MAP begins will not be visited by callbackfn. If existing elements of
the array are changed, their value as passed to callbackfn will be the
value at the time MAP visits them; elements that are deleted after the
call to MAP begins and before being visited are not visited.

When the MAP method is called with one or two arguments, the following
steps are taken:

1.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(O).

3.  Let len be ToLength(Get(O, "LENGTH")).

4.  5.  ReturnIfAbrupt(len).

6.  If IsCallable(callbackfn) is FALSE, throw a TYPEERROR exception.

7.  If thisArg was supplied, let T be thisArg; else let T be
    UNDEFINED.

8.  Let A be ArraySpeciesCreate(O, len).

9.  10. a.  b.  c.  i.  ii. 1.  

11. a.  

12. ReturnIfAbrupt(A).

13. Let k be 0.

14. Repeat, while k < len

    a.  Let Pk be ToString(k).

    b.  Let kPresent be HasProperty(O, Pk).

    c.  ReturnIfAbrupt(kPresent).

    d.  If kPresent is TRUE, then

        i.  Let kValue be Get(O, Pk).

        ii. ReturnIfAbrupt(kValue).

        iii. Let mappedValue be Call(callbackfn, T, «kValue,
            k, O»).

        iv. ReturnIfAbrupt(mappedValue).

        v.  Let status be CreateDataPropertyOrThrow (A, Pk,
            mappedValue).

        vi. ReturnIfAbrupt(status).

    e.  Increase k by 1.

15. Return A.

The LENGTH property of the MAP method is 1.

NOTE The MAP function is intentionally generic; it does not require that
its THIS value be an Array object. Therefore it can be transferred to
other kinds of objects for use as a method.

Array.prototype.pop ( )

NOTE The last element of the array is removed from the array and
returned.

When the POP method is called the following steps are taken:

1.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(O).

3.  Let len be ToLength(Get(O, "LENGTH")).

4.  5.  ReturnIfAbrupt(len).

6.  If len is zero,

7.  a.  Let putStatus be Put(O, "LENGTH", 0, TRUE).

    b.  ReturnIfAbrupt(putStatus).

    c.  Return UNDEFINED.

8.  Else len > 0,

    a.  Let newLen be len–1.

    b.  Let indx be ToString(newLen).

    c.  Let element be Get(O, indx).

    d.  ReturnIfAbrupt(element).

    e.  Let deleteStatus be DeletePropertyOrThrow(O, indx).

    f.  ReturnIfAbrupt(deleteStatus).

    g.  Let putStatus be Put(O, "LENGTH", newLen, TRUE).

    h.  ReturnIfAbrupt(putStatus).

    i.  Return element.

NOTE The POP function is intentionally generic; it does not require that
its THIS value be an Array object. Therefore it can be transferred to
other kinds of objects for use as a method.

Array.prototype.push ( ...items )

NOTE The arguments are appended to the end of the array, in the order in
which they appear. The new length of the array is returned as the result
of the call.

When the PUSH method is called with zero or more arguments the following
steps are taken:

1.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(O).

3.  Let len be ToLength(Get(O, "LENGTH")).

4.  5.  ReturnIfAbrupt(len).

6.  Let items be a List whose elements are, in left to right order,
    the arguments that were passed to this function invocation.

7.  Let argCount be the number of elements in items.

8.  If len + argCount > 2^53^-1, throw a TYPEERROR exception.

9.  Repeat, while items is not empty

    a.  b.  Remove the first element from items and let E be the
        value of the element.

    c.  Let putStatus be Put(O, ToString(len), E, TRUE).

    d.  ReturnIfAbrupt(putStatus).

    e.  Let len be len+1.

10. Let putStatus be Put(O, "LENGTH", len, TRUE).

11. ReturnIfAbrupt(putStatus).

12. Return len.

The LENGTH property of the PUSH method is 1.

NOTE The PUSH function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method.

Array.prototype.reduce ( callbackfn [ , initialValue ] )

NOTE callbackfn should be a function that takes four arguments. REDUCE
calls the callback, as a function, once for each element present in the
array, in ascending order.

callbackfn is called with four arguments: the previousValue (or
value from the previous call to callbackfn), the currentValue (value
of the current element), the currentIndex, and the object being
traversed. The first time that callback is called, the previousValue
and currentValue can be one of two values. If an initialValue was
provided in the call to REDUCE, then previousValue will be equal to
initialValue and currentValue will be equal to the first value in
the array. If no initialValue was provided, then previousValue will
be equal to the first value in the array and currentValue will be
equal to the second. It is a TYPEERROR if the array contains no elements
and initialValue is not provided.

REDUCE does not directly mutate the object on which it is called but the
object may be mutated by the calls to callbackfn.

The range of elements processed by REDUCE is set before the first call
to callbackfn. Elements that are appended to the array after the call
to REDUCE begins will not be visited by callbackfn. If existing
elements of the array are changed, their value as passed to callbackfn
will be the value at the time REDUCE visits them; elements that are
deleted after the call to REDUCE begins and before being visited are not
visited.

When the REDUCE method is called with one or two arguments, the
following steps are taken:

1.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(O).

3.  Let len be ToLength(Get(O, "LENGTH")).

4.  5.  ReturnIfAbrupt(len).

6.  If IsCallable(callbackfn) is FALSE, throw a TYPEERROR exception.

7.  If len is 0 and initialValue is not present, throw a TYPEERROR
    exception.

8.  Let k be 0.

9.  If initialValue is present, then

    a.  Set accumulator to initialValue.

10. Else initialValue is not present,

    a.  Let kPresent be FALSE.

    b.  Repeat, while kPresent is FALSE and k < len

        i.  Let Pk be ToString(k).

        ii. Let kPresent be HasProperty(O, Pk).

        iii. ReturnIfAbrupt(kPresent).

        iv. If kPresent is TRUE, then

            1.  Let accumulator be Get(O, Pk).

            2.  ReturnIfAbrupt(accumulator).

        v.  Increase k by 1.

    c.  If kPresent is FALSE, throw a TYPEERROR exception.

11. Repeat, while k < len

    a.  Let Pk be ToString(k).

    b.  Let kPresent be HasProperty(O, Pk).

    c.  ReturnIfAbrupt(kPresent).

    d.  If kPresent is TRUE, then

        i.  Let kValue be Get(O, Pk).

        ii. ReturnIfAbrupt(kValue).

        iii. Let accumulator be Call(callbackfn, UNDEFINED,
            «accumulator, kValue, k, O»).

        iv. ReturnIfAbrupt(accumulator).

    e.  Increase k by 1.

12. Return accumulator.

The LENGTH property of the REDUCE method is 1.

NOTE The REDUCE function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method.

Array.prototype.reduceRight ( callbackfn [ , initialValue ] )

NOTE callbackfn should be a function that takes four arguments.
REDUCERIGHT calls the callback, as a function, once for each element
present in the array, in descending order.

callbackfn is called with four arguments: the previousValue (or
value from the previous call to callbackfn), the currentValue (value
of the current element), the currentIndex, and the object being
traversed. The first time the function is called, the previousValue
and currentValue can be one of two values. If an initialValue was
provided in the call to REDUCERIGHT, then previousValue will be equal
to initialValue and currentValue will be equal to the last value in
the array. If no initialValue was provided, then previousValue will
be equal to the last value in the array and currentValue will be equal
to the second-to-last value. It is a TYPEERROR if the array contains no
elements and initialValue is not provided.

REDUCERIGHT does not directly mutate the object on which it is called
but the object may be mutated by the calls to callbackfn.

The range of elements processed by REDUCERIGHT is set before the first
call to callbackfn. Elements that are appended to the array after the
call to REDUCERIGHT begins will not be visited by callbackfn. If
existing elements of the array are changed by callbackfn, their value
as passed to callbackfn will be the value at the time REDUCERIGHT
visits them; elements that are deleted after the call to REDUCERIGHT
begins and before being visited are not visited.

When the REDUCERIGHT method is called with one or two arguments, the
following steps are taken:

1.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(O).

3.  Let len be ToLength(Get(O, "LENGTH")).

4.  5.  ReturnIfAbrupt(len).

6.  If IsCallable(callbackfn) is FALSE, throw a TYPEERROR exception.

7.  If len is 0 and initialValue is not present, throw a TYPEERROR
    exception.

8.  Let k be len-1.

9.  If initialValue is present, then

    a.  Set accumulator to initialValue.

10. Else initialValue is not present,

    a.  Let kPresent be FALSE.

    b.  Repeat, while kPresent is FALSE and k ≥ 0

        i.  Let Pk be ToString(k).

        ii. Let kPresent be HasProperty(O, Pk).

        iii. ReturnIfAbrupt(kPresent).

        iv. If kPresent is TRUE, then

            1.  Let accumulator be Get(O, Pk).

            2.  ReturnIfAbrupt(accumulator).

        v.  Decrease k by 1.

    c.  If kPresent is FALSE, throw a TYPEERROR exception.

11. Repeat, while k ≥ 0

    a.  Let Pk be ToString(k).

    b.  Let kPresent be HasProperty(O, Pk).

    c.  ReturnIfAbrupt(kPresent).

    d.  If kPresent is TRUE, then

        i.  Let kValue be Get(O, Pk).

        ii. ReturnIfAbrupt(kValue).

        iii. Let accumulator be Call(callbackfn, UNDEFINED,
            «accumulator, kValue, k, »).

        iv. ReturnIfAbrupt(accumulator).

    e.  Decrease k by 1.

12. Return accumulator.

The LENGTH property of the REDUCERIGHT method is 1.

NOTE The REDUCERIGHT function is intentionally generic; it does not
require that its this value be an Array object. Therefore it can be
transferred to other kinds of objects for use as a method.

Array.prototype.reverse ( )

NOTE The elements of the array are rearranged so as to reverse their
order. The object is returned as the result of the call.

When the REVERSE method is called the following steps are taken:

1.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(O).

3.  Let len be ToLength(Get(O, "LENGTH")).

4.  5.  ReturnIfAbrupt(len).

6.  Let middle be floor(len/2).

7.  Let lower be 0.

8.  Repeat, while lower ≠ middle

    a.  Let upper be len− lower −1.

    b.  Let upperP be ToString(upper).

    c.  Let lowerP be ToString(lower).

    d.  Let lowerExists be HasProperty(O, lowerP).

    e.  ReturnIfAbrupt(lowerExists).

    f.  If lowerExists is TRUE, then

        i.  Let lowerValue be Get(O, lowerP).

        ii. ReturnIfAbrupt(lowerValue).

    g.  Let upperExists be HasProperty(O, upperP).

    h.  ReturnIfAbrupt(upperExists).

    i.  If upperExists is TRUE, then

        i.  Let upperValue be Get(O, upper).

        ii. ReturnIfAbrupt(upperValue).

    j.  k.  l.  m.  n.  If lowerExists is TRUE and upperExists is
        TRUE, then

        i.  Let putStatus be Put(O, lowerP, upperValue, TRUE).

        ii. ReturnIfAbrupt(putStatus).

        iii. Let putStatus be Put(O, upperP, lowerValue, TRUE).

        iv. ReturnIfAbrupt(putStatus).

    o.  Else if lowerExists is FALSE and upperExists is TRUE, then

        i.  Let putStatus be Put(O, lowerP, upperValue, TRUE).

        ii. ReturnIfAbrupt(putStatus).

        iii. Let deleteStatus be DeletePropertyOrThrow (O,
            upperP).

        iv. ReturnIfAbrupt(deleteStatus).

    p.  Else if lowerExists is TRUE and upperExists is FALSE, then

        i.  Let deleteStatus be DeletePropertyOrThrow (O, lowerP).

        ii. ReturnIfAbrupt(deleteStatus).

        iii. Let putStatus be Put(O, upperP, lowerValue, TRUE).

        iv. ReturnIfAbrupt(putStatus).

    q.  Else both lowerExists and upperExists are FALSE,

        i.  No action is required.

    r.  Increase lower by 1.

9.  Return O .

NOTE The REVERSE function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore, it can be transferred
to other kinds of objects for use as a method.

Array.prototype.shift ( )

NOTE The first element of the array is removed from the array and
returned.

When the SHIFT method is called the following steps are taken:

1.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(O).

3.  Let len be ToLength(Get(O, "LENGTH")).

4.  5.  ReturnIfAbrupt(len).

6.  If len is zero, then

    a.  Let putStatus be Put(O, "LENGTH", 0, TRUE).

    b.  ReturnIfAbrupt(putStatus).

    c.  Return UNDEFINED.

7.  Let first be Get(O, "0").

8.  ReturnIfAbrupt(first).

9.  Let k be 1.

10. Repeat, while k < len

    a.  Let from be ToString(k).

    b.  Let to be ToString(k–1).

    c.  Let fromPresent be HasProperty(O, from).

    d.  ReturnIfAbrupt(fromPresent).

    e.  If fromPresent is TRUE, then

        i.  Let fromVal be Get(O, from).

        ii. ReturnIfAbrupt(fromVal).

        iii. Let putStatus be Put(O, to, fromVal, TRUE).

        iv. ReturnIfAbrupt(putStatus).

    f.  Else fromPresent is FALSE,

        i.  Let deleteStatus be DeletePropertyOrThrow(O, to).

        ii. ReturnIfAbrupt(deleteStatus).

    g.  Increase k by 1.

11. Let deleteStatus be DeletePropertyOrThrow(O, ToString(len–1)).

12. ReturnIfAbrupt(deleteStatus).

13. Let putStatus be Put(O, "LENGTH", len–1, TRUE).

14. ReturnIfAbrupt(putStatus).

15. Return first.

NOTE The SHIFT function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method.

Array.prototype.slice (start, end)

NOTE The SLICE method takes two arguments, start and end, and
returns an array containing the elements of the array from element
start up to, but not including, element end (or through the end of
the array if end is UNDEFINED). If start is negative, it is treated
as length_+_start where length is the length of the array. If end
is negative, it is treated as length_+_end where length is the
length of the array.

The following steps are taken:

1.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(O).

3.  Let len be ToLength(Get(O, "LENGTH")).

4.  5.  ReturnIfAbrupt(len).

6.  Let relativeStart be ToInteger(start).

7.  ReturnIfAbrupt(relativeStart).

8.  If relativeStart < 0, let k be max((len + relativeStart),0);
    else let k be min(relativeStart, len).

9.  If end is UNDEFINED, let relativeEnd be len; else let
    relativeEnd be ToInteger(end).

10. ReturnIfAbrupt(relativeEnd).

11. If relativeEnd < 0, let final be max((len + relativeEnd),0);
    else let final be min(relativeEnd, len).

12. Let count be max(final – k, 0).

13. Let A be ArraySpeciesCreate(O, count).

14. 15. ReturnIfAbrupt(A).

16. Let n be 0.

17. Repeat, while k < final

    a.  Let Pk be ToString(k).

    b.  Let kPresent be HasProperty(O, Pk).

    c.  ReturnIfAbrupt(kPresent).

    d.  If kPresent is TRUE, then

        i.  Let kValue be Get(O, Pk).

        ii. ReturnIfAbrupt(kValue).

        iii. Let status be CreateDataPropertyOrThrow(A,
            ToString(n), kValue ).

        iv. ReturnIfAbrupt(status).

    e.  Increase k by 1.

    f.  Increase n by 1.

18. Let putStatus be Put(A, "LENGTH", n, TRUE).

19. ReturnIfAbrupt(putStatus).

20. Return A.

The LENGTH property of the SLICE method is 2.

NOTE 1 The explicit setting of the LENGTH property of the result Array
in step 19 is necessary to ensure that its value is correct in
situations where the trailing elements of the result Array are not
present.

NOTE 2 The SLICE function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method.

Array.prototype.some ( callbackfn [ , thisArg ] )

NOTE callbackfn should be a function that accepts three arguments and
returns a value that is coercible to the Boolean value TRUE or FALSE.
SOME calls callbackfn once for each element present in the array, in
ascending order, until it finds one where callbackfn returns TRUE. If
such an element is found, SOME immediately returns TRUE. Otherwise, SOME
returns FALSE. callbackfn is called only for elements of the array
which actually exist; it is not called for missing elements of the
array.

If a thisArg parameter is provided, it will be used as the THIS value
for each invocation of callbackfn. If it is not provided, UNDEFINED is
used instead.

callbackfn is called with three arguments: the value of the element,
the index of the element, and the object being traversed.

SOME does not directly mutate the object on which it is called but the
object may be mutated by the calls to callbackfn.

The range of elements processed by SOME is set before the first call to
callbackfn. Elements that are appended to the array after the call to
SOME begins will not be visited by callbackfn. If existing elements of
the array are changed, their value as passed to callbackfn will be the
value at the time that SOME visits them; elements that are deleted after
the call to SOME begins and before being visited are not visited. SOME
acts like the "exists" quantifier in mathematics. In particular, for an
empty array, it returns FALSE.

When the SOME method is called with one or two arguments, the following
steps are taken:

1.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(O).

3.  Let len be ToLength(Get(O, "LENGTH")).

4.  5.  ReturnIfAbrupt(len).

6.  If IsCallable(callbackfn) is FALSE, throw a TYPEERROR exception.

7.  If thisArg was supplied, let T be thisArg; else let T be
    UNDEFINED.

8.  Let k be 0.

9.  Repeat, while k < len

    a.  Let Pk be ToString(k).

    b.  Let kPresent be HasProperty(O, Pk).

    c.  ReturnIfAbrupt(kPresent).

    d.  If kPresent is TRUE, then

        i.  Let kValue be Get(O, Pk).

        ii. ReturnIfAbrupt(kValue).

        iii. Let testResult be ToBoolean(Call(callbackfn, T,
            «kValue, k, and O»)).

        iv. ReturnIfAbrupt(testResult).

        v.  If testResult is TRUE, return TRUE.

    e.  Increase k by 1.

10. Return FALSE.

The LENGTH property of the SOME method is 1.

NOTE The SOME function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method.

Array.prototype.sort (comparefn)

The elements of this array are sorted. The sort is not necessarily
stable (that is, elements that compare equal do not necessarily remain
in their original order). If comparefn is not UNDEFINED, it should be
a function that accepts two arguments x and y and returns a negative
value if x < y, zero if x = y, or a positive value if x > y.

Within this specification of the SORT method, an Array object, obj, is
said to be sparse if the following algorithm returns TRUE:

1.  Let len be Get(obj, "LENGTH").

2.  For each integer i in the range 0≤i_<ToUint32(_len)

    a.  Let elem be the result of calling the [[GetOwnProperty]]
        internal method of obj with argument ToString(i).

    b.  If elem is UNDEFINED, return TRUE.

3.  Return FALSE.

Upon entry, the following steps are performed to initialize evaluation
of the SORT function:

1.  Let obj be the result of calling ToObject passing the THIS value
    as the argument.

2.  Let len be ToLength(Get(obj, "LENGTH")).

3.  4.  ReturnIfAbrupt(len).

The _sort order_ is the ordering of the array index property values of
obj after completion of this function. The result of the SORT function
is then determined as follows:

If comparefn is not UNDEFINED and is not a consistent comparison
function for the elements of this array (see below), the sort order is
implementation-defined. The sort order is also implementation-defined if
comparefn is UNDEFINED and SortCompare (22.1.3.24.1) does not act as a
consistent comparison function.

Let proto be the result of calling the [[GetPrototypeOf]] internal
method of obj. If proto is not NULL and there exists an integer j
such that all of the conditions below are satisfied then the sort order
is implementation-defined:

-   obj is sparse (22.1)

-   0 ≤ j < len

-   The result of HasProperty(proto, ToString(j)) is TRUE.

The sort order is also implementation defined if obj is sparse and any
of the following conditions are true:

-   The result of the predicate IsExtensible(obj) is FALSE.

-   Any array index property of obj whose name is a nonnegative
    integer less than len is a data property whose [[Configurable]]
    attribute is FALSE.

The sort order is also implementation defined if any of the following
condtions are true:

-   If obj is an exotic object (including Proxy exotic objects) whose
    behaviour for [[Get]], [[Set]], [[Delete]], and [[GetOwnProperty]]
    is different from the ordinary object behaviour for these internal
    methods.

-   If any array index property of obj whose name is a nonnegative
    integer less than len is an accessor property or is a data
    property whose [[Writable]] attribute is FALSE.

-   

The following steps are taken:

1.  Perform an implementation-dependent sequence of calls to the [[Get]]
    and [[Set]], internal methods of obj, to the DeletePropertyOrThrow
    and HasOwnProperty abstract operation with obj as the first
    argument, and to SortCompare (described below), such that:

    -   The property key argument for each call to [[Get]], [[Set]],
        HasOwnProperty, or DeletePropertyOrThrow is the string
        representation of a nonnegative integer less than len.

    -   The arguments for calls to SortCompare are values returned by a
        previous call to the [[Get]] internal method, unless the
        properties accessed by those previous calls did not exist
        according to [[HasOwnProperty]]. If both perspective arguments
        to SortCompare correspond to non-existent properties, use +0
        instead of calling SortCompare. If only the first perspective
        argument is non-existent use +1. If only the second perspective
        argument is non-existent use −1.

    -   If obj is not sparse then DeletePropertyOrThrow must not be
        called.

    -   If any [[Set]] call returns FALSE a TYPEERROR exception is
        thrown.

    -   If an abrupt completion is returned from any of these
        operations, it is immediately returned as the value of this
        function.

2.  Return obj.

Unless the sort order is specified above to be implemention-defined, the
returned object must have the following two characteristics:

-   There must be some mathematical permutation π of the nonnegative
    integers less than len, such that for every nonnegative integer
    j less than len, if property old[j] existed, then new[π(j)]
    is exactly the same value as old[j]. But if property old[j] did
    not exist, then new[π(j)] does not exist.

-   Then for all nonnegative integers j and k, each less than len,
    if SortCompare(old[j], old[k]) < 0 (see SortCompare below), then
    new[Π(j)] < new[Π(k)].

Here the notation old[j] is used to refer to the hypothetical result
of calling the [[Get]] internal method of obj with argument j before
this function is executed, and the notation new[j] to refer to the
hypothetical result of calling the [[Get]] internal method of obj with
argument j after this function has been executed.

A function comparefn is a consistent comparison function for a set of
values S if all of the requirements below are met for all values a,
b, and c (possibly the same value) in the set S: The notation
a_ <~CF~ _b means comparefn_(_a_,_b) < 0; a_ =~CF~ _b means
comparefn_(_a_,_b) = 0 (of either sign); and a_ >~CF~ _b means
comparefn_(_a_,_b) > 0.

-   Calling comparefn_(_a_,_b) always returns the same value v when
    given a specific pair of values a and b as its two arguments.
    Furthermore, Type(v) is Number, and v is not NaN. Note that this
    implies that exactly one of a_ <~CF~ _b, a_ =~CF~ _b, and
    a_ >~CF~ _b will be true for a given pair of a and b.

-   Calling comparefn_(_a_,_b) does not modify obj or any object on
    obj’s prototype chain.

-   a_ =~CF~ _a (reflexivity)

-   If a_ =~CF~ _b, then b_ =~CF~ _a (symmetry)

-   If a_ =~CF~ _b and b_ =~CF~ _c, then a_ =~CF~ _c (transitivity
    of =~CF~)

-   If a_ <~CF~ _b and b_ <~CF~ _c, then a_ <~CF~ _c (transitivity
    of <~CF~)

-   If a_ >~CF~ _b and b_ >~CF~ _c, then a_ >~CF~ _c (transitivity
    of >~CF~)

NOTE 1 The above conditions are necessary and sufficient to ensure that
comparefn divides the set S into equivalence classes and that these
equivalence classes are totally ordered.

NOTE 2 The SORT function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore, it can be transferred
to other kinds of objects for use as a method.

Runtime Semantics: SortCompare Abstract Operation

When the SortCompare abstract operation is called with two arguments x
and y, the following steps are taken:

1.  2.  3.  4.  5.  6.  7.  8.  9.  10. 11. 12. 13. 14. If x and y
    are both UNDEFINED, return +0.

15. If x is UNDEFINED, return 1.

16. If y is UNDEFINED, return −1.

17. If the argument comparefn is not UNDEFINED, then

    a.  b.  Let v be Call(comparefn, UNDEFINED, «x, y»)

    c.  ReturnIfAbrupt(v).

    d.  If v is NAN, return +0.

    e.  Return v.

18. Let xString be ToString(x).

19. ReturnIfAbrupt(xString).

20. Let yString be ToString(y).

21. ReturnIfAbrupt(yString).

22. If xString < yString, return −1.

23. If xString > yString, return 1.

24. Return +0.

NOTE 1 Because non-existent property values always compare greater than
UNDEFINED property values, and UNDEFINED always compares greater than
any other value, UNDEFINED property values always sort to the end of the
result, followed by non-existent property values.

NOTE 2 Method calls performed by the ToString abstract operations in
steps 5 and 7 have the potential to cause SortCompare to not behave as a
consistent comparison function.

Array.prototype.splice (start, deleteCount , ...items )

NOTE When the SPLICE method is called with two or more arguments
start, deleteCount and zero or more items, the deleteCount
elements of the array starting at integer index start are replaced by
the arguments items. An Array object containing the deleted elements
(if any) is returned.

The following steps are taken:

1.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(O).

3.  Let len be ToLength(Get(O, "LENGTH")).

4.  5.  ReturnIfAbrupt(len).

6.  Let relativeStart be ToInteger(start).

7.  ReturnIfAbrupt(relativeStart).

8.  If relativeStart < 0, let actualStart be max((len +
    relativeStart),0); else let actualStart be min(relativeStart,
    len).

9.  If the number of actual arguments is 0, then

    a.  Let insertCount be 0.

    b.  Let actualDeleteCount be 0.

10. Else if the number of actual arguments is 1, then

    a.  Let insertCount be 0.

    b.  Let actualDeleteCount be len - actualStart

11. Else,

    a.  Let insertCount be the number of actual arguments minus 2.

    b.  Let dc be ToInteger(deleteCount).

    c.  ReturnIfAbrupt(dc).

    d.  Let actualDeleteCount be min(max(dc,0), len –
        actualStart).

12. If len+insertCount_−_actualDeleteCount > 2^53^-1, throw a
    TYPEERROR exception.

13. Let A be ArraySpeciesCreate(O,

14. a.  b.  c.  i.  ii. 1.  

15. 16. actualDeleteCount).

17. ReturnIfAbrupt(A).

18. Let k be 0.

19. Repeat, while k < actualDeleteCount

    a.  Let from be ToString(actualStart_+_k).

    b.  Let fromPresent be HasProperty(O, from).

    c.  ReturnIfAbrupt(fromPresent).

    d.  If fromPresent is TRUE, then

        i.  Let fromValue be Get(O, from).

        ii. ReturnIfAbrupt(fromValue).

        iii. Let status be CreateDataPropertyOrThrow(A,
            ToString(k), fromValue).

        iv. ReturnIfAbrupt(status).

    e.  Increment k by 1.

20. Let putStatus be Put(A, "LENGTH", actualDeleteCount, TRUE).

21. ReturnIfAbrupt(putStatus).

22. Let items be a List whose elements are, in left to right order,
    the portion of the actual argument list starting with the third
    argument. The list is empty if fewer than three arguments were
    passed.

23. Let itemCount be the number of elements in items.

24. If itemCount < actualDeleteCount, then

    a.  Let k be actualStart.

    b.  Repeat, while k < (len – actualDeleteCount)

        i.  Let from be ToString(k_+_actualDeleteCount).

        ii. Let to be ToString(k_+_itemCount).

        iii. Let fromPresent be HasProperty(O, from).

        iv. ReturnIfAbrupt(fromPresent).

        v.  If fromPresent is TRUE, then

            1.  Let fromValue be Get(O, from).

            2.  ReturnIfAbrupt(fromValue).

            3.  Let putStatus be Put(O, to, fromValue, TRUE).

            4.  ReturnIfAbrupt(putStatus).

        vi. Else fromPresent is FALSE,

            1.  Let deleteStatus be DeletePropertyOrThrow(O, to).

            2.  ReturnIfAbrupt(deleteStatus).

        vii. Increase k by 1.

    c.  Let k be len.

    d.  Repeat, while k > (len – actualDeleteCount + itemCount)

    e.  i.  Let deleteStatus be DeletePropertyOrThrow(O,
            ToString(k–1)).

        ii. ReturnIfAbrupt(deleteStatus).

        iii. Decrease k by 1.

25. Else if itemCount > actualDeleteCount, then

    a.  Let k be (len – actualDeleteCount).

    b.  Repeat, while k > actualStart

        i.  Let from be ToString(k + actualDeleteCount – 1).

        ii. Let to be ToString(k + itemCount – 1)

        iii. Let fromPresent be HasProperty(O, from).

        iv. ReturnIfAbrupt(fromPresent).

        v.  If fromPresent is TRUE, then

            1.  Let fromValue be Get(O, from).

            2.  ReturnIfAbrupt(fromValue).

            3.  Let putStatus be Put(O, to, fromValue, TRUE).

            4.  ReturnIfAbrupt(putStatus).

        vi. Else fromPresent is FALSE,

            1.  Let deleteStatus be DeletePropertyOrThrow(O, to).

            2.  ReturnIfAbrupt(deleteStatus).

        vii. Decrease k by 1.

26. Let k be actualStart.

27. Repeat, while items is not empty

    a.  Remove the first element from items and let E be the value
        of that element.

    b.  Let putStatus be Put(O, ToString(k), E, TRUE).

    c.  ReturnIfAbrupt(putStatus).

    d.  Increase k by 1.

28. Let putStatus be Put(O, "LENGTH", len – actualDeleteCount +
    itemCount, TRUE).

29. ReturnIfAbrupt(putStatus).

30. Return A.

The LENGTH property of the SPLICE method is 2.

NOTE 1 The explicit setting of the LENGTH property of the result Array
in step 18 is necessary to ensure that its value is correct in
situations where its trailing elements are not present.

NOTE 2 The SPLICE function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method.

Array.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] )

An ECMAScript implementation that includes the ECMA-402
Internationalization API must implement the
ARRAY.PROTOTYPE.TOLOCALESTRING method as specified in the ECMA-402
specification. If an ECMAScript implementation does not include the
ECMA-402 API the following specification of the TOLOCALESTRING method is
used.

NOTE The first edition of ECMA-402 did not include a replacement
specification for the ARRAY.PROTOTYPE.TOLOCALESTRING method.

The meanings of the optional parameters to this method are defined in
the ECMA-402 specification; implementations that do not include ECMA-402
support must not use those parameter positions for anything else.

The following steps are taken:

1.  Let array be the result of calling ToObject passing the THIS value
    as the argument.

2.  ReturnIfAbrupt(array).

3.  Let len be ToLength(Get(array, "LENGTH")).

4.  5.  ReturnIfAbrupt(len).

6.  Let separator be the String value for the list-separator String
    appropriate for the host environment’s current locale (this is
    derived in an implementation-defined way).

7.  If len is zero, return the empty String.

8.  Let firstElement be Get(array, "0").

9.  ReturnIfAbrupt(firstElement).

10. If firstElement is UNDEFINED or NULL, then

    a.  Let R be the empty String.

11. Else

12. a.  Let R be ToString(Invoke(firstElement, "TOLOCALESTRING")).

    b.  c.  ReturnIfAbrupt(R).

13. Let k be 1.

14. Repeat, while k < len

    a.  Let S be a String value produced by concatenating R and
        separator.

    b.  Let nextElement be Get(array, ToString(k)).

    c.  ReturnIfAbrupt(nextElement).

    d.  If nextElement is UNDEFINED or NULL, then

        i.  Let R be the empty String.

    e.  Else

    f.  i.  Let R be ToString(Invoke(nextElement,
            "TOLOCALESTRING")).

        ii. iii. ReturnIfAbrupt(R).

    g.  Let R be a String value produced by concatenating S and R.

    h.  Increase k by 1.

15. Return R.

NOTE 1 The elements of the array are converted to Strings using their
TOLOCALESTRING methods, and these Strings are then concatenated,
separated by occurrences of a separator String that has been derived in
an implementation-defined locale-specific way. The result of calling
this function is intended to be analogous to the result of TOSTRING,
except that the result of this function is intended to be
locale-specific.

NOTE 2 The TOLOCALESTRING function is intentionally generic; it does not
require that its THIS value be an Array object. Therefore it can be
transferred to other kinds of objects for use as a method.

Array.prototype.toString ( )

When the TOSTRING method is called, the following steps are taken:

1.  Let array be the result of calling ToObject on the THIS value.

2.  ReturnIfAbrupt(array).

3.  Let func be Get(array, "JOIN").

4.  ReturnIfAbrupt(func).

5.  If IsCallable(func) is FALSE, let func be the intrinsic function
    %ObjProto_toString% (19.1.3.6).

6.  Return Call(func, array).

NOTE The TOSTRING function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method.

Array.prototype.unshift ( ...items )

NOTE The arguments are prepended to the start of the array, such that
their order within the array is the same as the order in which they
appear in the argument list.

When the UNSHIFT method is called with zero or more arguments item1,
item2, etc., the following steps are taken:

1.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(O).

3.  Let len be ToLength(Get(O, "LENGTH")).

4.  5.  ReturnIfAbrupt(len).

6.  Let argCount be the number of actual arguments.

7.  If argCount > 0, then

    a.  If len+ argCount > 2^53^-1, throw a TYPEERROR exception.

    b.  Let k be len.

    c.  Repeat, while k > 0,

    d.  i.  Let from be ToString(k–1).

        ii. Let to be ToString(k_+_argCount –1).

        iii. Let fromPresent be HasProperty(O, from).

        iv. ReturnIfAbrupt(fromPresent).

        v.  If fromPresent is TRUE, then

            1.  Let fromValue be the result of Get(O, from).

            2.  ReturnIfAbrupt(fromValue).

            3.  Let putStatus be Put(O, to, fromValue, TRUE).

            4.  ReturnIfAbrupt(putStatus).

        vi. Else fromPresent is FALSE,

            1.  Let deleteStatus be DeletePropertyOrThrow(O, to).

            2.  ReturnIfAbrupt(deleteStatus).

        vii. Decrease k by 1.

    e.  Let j be 0.

    f.  Let items be a List whose elements are, in left to right
        order, the arguments that were passed to this function
        invocation.

    g.  Repeat, while items is not empty

        i.  Remove the first element from items and let E be the
            value of that element.

        ii. Let putStatus be Put(O, ToString(j), E, TRUE).

        iii. ReturnIfAbrupt(putStatus).

        iv. Increase j by 1.

8.  Let putStatus be Put(O, "LENGTH", len_+_argCount, TRUE).

9.  ReturnIfAbrupt(putStatus).

10. Return len_+_argCount.

The LENGTH property of the UNSHIFT method is 1.

NOTE The UNSHIFT function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method.

Array.prototype.values ( )

The following steps are taken:

1.  Let O be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(O).

3.  Return CreateArrayIterator(O, "VALUE").

This function is the %ArrayProto_values% intrinsic object.

Array.prototype [ @@iterator ] ( )

The initial value of the @@iterator property is the same function object
as the initial value of the ARRAY.PROTOTYPE.VALUES property.

Array.prototype [ @@unscopables ]

The initial value of the @@unscopables data property is an object
created by the following steps:

1.  Let blackList be ObjectCreate(NULL).

2.  Perform CreateDataProperty(blackList, "COPYWITHIN", TRUE).

3.  Perform CreateDataProperty(blackList, "ENTRIES", TRUE).

4.  Perform CreateDataProperty(blackList, "FILL", TRUE).

5.  Perform CreateDataProperty(blackList, "FIND", TRUE).

6.  Perform CreateDataProperty(blackList, "FINDINDEX", TRUE).

7.  8.  9.  10. Perform CreateDataProperty(blackList, "KEYS", TRUE).

11. Perform CreateDataProperty(blackList, "VALUES", TRUE).

12. Assert: Each of the above calls will return TRUE.

13. Return blackList.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

NOTE The own property names of this object are property names that were
not included as standard properties of ARRAY.PROTOTYPE prior to the
sixth edition of this specification. These names are ignored for WITH
statement binding purposes in order to preserve the behaviour of
existing code that might use one of these names as a binding in an outer
scope that is shadowed by a WITH statement whose binding object is an
Array object.

Properties of Array Instances

Array instances are Array exotic objects and have the internal methods
specified for such objects. Array instances inherit properties from the
Array prototype object.

Array instances have a LENGTH property, and a set of enumerable
properties with array index names.

length

The LENGTH property of an Array instance is a data property whose value
is always numerically greater than the name of every configurable own
property whose name is an array index.

The LENGTH property initially has the attributes { [[Writable]]: TRUE,
[[Enumerable]]: FALSE, [[Configurable]]: FALSE }.

NOTE Attempting to set the length property of an Array object to a value
that is numerically less than or equal to the largest numeric own
property name of an existing array indexed configurable property of the
array will result in the length being set to a numeric value that is one
greater than that largest numeric own property name. See 9.4.2.1.

Array Iterator Objects 

An Array Iterator is an object, that represents a specific iteration
over some specific Array instance object. There is not a named
constructor for Array Iterator objects. Instead, Array iterator objects
are created by calling certain methods of Array instance objects.

CreateArrayIterator Abstract Operation

Several methods of Array objects return Iterator objects. The abstract
operation CreateArrayIterator with arguments array and kind is used
to create such iterator objects. It performs the following steps:

1.  Assert: Type(array) is Object.

2.  3.  Let iterator be ObjectCreate(%ArrayIteratorPrototype%,
    «‍[[IteratedObject]], [[ArrayIteratorNextIndex]],
    [[ArrayIterationKind]]»).

4.  Set iterator’s [[IteratedObject]] internal slot to array.

5.  Set iterator’s [[ArrayIteratorNextIndex]] internal slot to 0.

6.  Set iterator’s [[ArrayIterationKind]] internal slot to kind.

7.  Return iterator.

The %ArrayIteratorPrototype% Object

All Array Iterator Objects inherit properties from the
%ArrayIteratorPrototype% intrinsic object. The %ArrayIteratorPrototype%
object is an ordinary object and its [[Prototype]] internal slot is the
%IteratorPrototype% intrinsic object (25.1.2). In addition,
%ArrayIteratorPrototype% has the following properties:

%ArrayIteratorPrototype%.next( )

1.  Let O be the THIS value.

2.  If Type(O) is not Object, throw a TYPEERROR exception.

3.  If O does not have all of the internal slots of an Array Iterator
    Instance (22.1.5.3), throw a TYPEERROR exception.

4.  Let a be the value of the [[IteratedObject]] internal slot of O.

5.  If a is UNDEFINED, return CreateIterResultObject(UNDEFINED, TRUE).

6.  Let index be the value of the [[ArrayIteratorNextIndex]] internal
    slot of O.

7.  Let itemKind be the value of the [[ArrayIterationKind]] internal
    slot of O.

8.  If a has a [[TypedArrayName]] internal slot, then

    a.  Let len be the value of O’s [[ArrayLength]] internal slot.

9.  Else,

    a.  Let len be ToLength(Get(a, "LENGTH")).

    b.  c.  ReturnIfAbrupt(len).

10. If index ≥ len, then

    a.  Set the value of the [[IteratedObject]] internal slot of O to
        UNDEFINED.

    b.  Return CreateIterResultObject(UNDEFINED, TRUE).

11. Set the value of the [[ArrayIteratorNextIndex]] internal slot of O
    to index+1.

12. If itemKind is "KEY", CreateIterResultObject(index, FALSE).

13. 14. Let elementKey be ToString(index).

15. Let elementValue be Get(a, elementKey).

16. ReturnIfAbrupt(elementValue).

17. If itemKind is "VALUE", let result be elementValue.

18. Else,

    a.  Assert itemKind is "KEY+VALUE".

    b.  Let result be ArrayCreate(2).

    c.  Assert: result is a new, well-formed Array object so the
        following operations will never fail.

    d.  Call CreateDataProperty(result, "0", index).

    e.  Call CreateDataProperty(result, "1", elementValue).

    f.  

19. 20. 21. Return CreateIterResultObject(result, FALSE).

1.  

%ArrayIteratorPrototype% [ @@toStringTag ]

The initial value of the @@toStringTag property is the string value
"ARRAY ITERATOR".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Properties of Array Iterator Instances

Array Iterator instances are ordinary objects that inherit properties
from the %ArrayIteratorPrototype% intrinsic object. Array Iterator
instances are initially created with the internal slots listed in Table
45.

Table 45 — Internal Slots of Array Iterator Instances

  ---------------------------- ------------------------------------------------------------------------------------------------------------------------------------------------
  INTERNAL SLOT                DESCRIPTION
  [[IteratedObject]]           The object whose array elements are being iterated.
  [[ArrayIteratorNextIndex]]   The integer index of the next array index to be examined by this iteration.
  [[ArrayIterationKind]]       A string value that identifies what is to be returned for each element of the iteration. The possible values are: "KEY", "VALUE", "KEY+VALUE".
  ---------------------------- ------------------------------------------------------------------------------------------------------------------------------------------------


TypedArray Objects 

TypedArray objects present an array-like view of an underlying binary
data buffer (24.1). Each element of a TypedArray instance has the same
underlying binary scalar data type. There is a distinct TypedArray
constructor, listed in Table 46, for each of the nine supported element
types. Each constructor in Table 46 has a corresponding distinct
prototype object.

Table 46 – The TypedArray Constructors

  -------------------------------------------------------------------------------------------------------------------------------------------------------
  Constructor Name and Intrinsic   Element Type   Element Size   Conversion Operation   Description                                   Equivalent C Type
  -------------------------------- -------------- -------------- ---------------------- --------------------------------------------- -------------------
  Int8Array                        Int8           1              ToInt8                 8-bit 2’s complement signed integer           signed char
  %Int8Array%                                                                                                                         

  Uint8Array                       Uint8          1              ToUint8                8-bit unsigned integer                        unsigned char
  %Uint8Array%                                                                                                                        

  Uint8ClampedArray                Uint8C         1              ToUint8Clamp           8-bit unsigned integer (clamped conversion)   unsigned char
  %Uint8ClampedArray%                                                                                                                 

  Int16Array                       Int16          2              ToInt16                16-bit 2’s complement signed integer          short
  %Int16Array%                                                                                                                        

  Uint16Array                      Uint16         2              ToUint16               16-bit unsigned integer                       unsigned short
  %Uint16Array%                                                                                                                       

  Int32Array                       Int32          4              ToInt32                32-bit 2’s complement signed integer          int
  %Int32Array%                                                                                                                        

  Uint32Array                      Uint32         4              ToUint32               32-bit unsigned integer                       unsigned int
  %Uint32Array%                                                                                                                       

  Float32Array                     Float32        4                                     32-bit IEEE floating point                    float
  %Float32Array%                                                                                                                      

  Float64Array                     Float64        8                                     64-bit IEEE floating point                    double
  %Float64Array%                                                                                                                      
  -------------------------------------------------------------------------------------------------------------------------------------------------------

In the definitions below, references to TypedArray should be replaced
with the appropriate constructor name from the above table. The phrase
“the element size in bytes” refers to the value in the Element Size
column of the table in the row corresponding to the constructor. The
phrase “element Type” refers to the value in the Element Type column for
that row.

The %TypedArray% Intrinsic Object

The %TypedArray% intrinsic object is a constructor function object that
all of the TypedArray constructor object inherit from. %TypedArray%
and its corresponding prototype object provide common properties that
are inherited by all TypedArray constructors and their instances. The
%TypedArray% intrinsic does not have a global name or appear as a
property of the global object.

The %TypedArray% intrinsic function object is designed to act as the
superclass of the various TypedArray constructors. Those constructors
use %TypedArray% to initialize their instances by invoking %TypedArray%
as if by making a SUPER call. The %TypedArray% intrinsic function is not
designed to be directly called in any other way. If %TypedArray% is
directly called or called as part of a NEW expression an exception is
thrown.

The %TypedArray% intrinsic function constructor is a single function
whose behaviour is overloaded based upon the number and types of its
arguments. The actual behaviour of a SUPER call of %TypedArray% depends
upon the number and kind of arguments that are passed to it.

%TypedArray% ( length )

This description applies only if the %TypedArray% function is called and
the Type of the first argument is not Object.

%TypedArray% called with argument length performs the following steps:

1.  Assert: Type(length) is not Object.

2.  If NewTarget is UNDEFINED, throw a TYPEERROR exception.

3.  Let numberLength be ToNumber(length).

4.  Let elementLength be ToLength(numberLength).

5.  ReturnIfAbrupt(elementLength).

6.  If SameValueZero(numberLength, elementLength) is FALSE, throw a
    RANGEERROR exception.

7.  8.  9.  10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 24. Return
    AllocateTypedArray(NewTarget, elementLength).

25. 26. 27. 28. 29. 30. 31. 

Runtime Semantics: AllocateTypedArray (newTarget, length )

The abstract operation AllocateTypedArray with argument newTarget and
optional argument length is used to validate and create an instance of
a TypedArray constructor. If the length argument is passed an
ArrayBuffer of that length is also allocated and associated with the new
Typed Array instance. AllocateTypedArray provides common semantics that
is used by all of the %TypeArray% overloads and other methods.
AllocateTypedArray performs the following steps:

1.  2.  If SameValue(%TypedArray%, newTarget) is TRUE, throw a
    TYPEERROR exception.

3.  Let constructorName be UNDEFINED.

4.  Let subclass be newTarget.

5.  Repeat while constructorName is UNDEFINED

    a.  If subclass is NULL, throw a TYPEERROR exception.

    b.  If SameValue(%TypedArray%, subclass) is TRUE, throw a
        TYPEERROR exception.

    c.  If subclass has a [[TypedArrayConstructorName]] internal slot,
        let constructorName be the value of subclass’s
        [[TypedArrayConstructorName]] internal slot.

    d.  Let subclass be the result of calling the [[GetPrototypeOf]]
        internal method of subclass with no arguments.

    e.  ReturnIfAbrupt(subclass).

6.  Let proto be GetPrototypeFromConstructor(newTarget,
    "%TYPEDARRAYPROTOTYPE%").

7.  ReturnIfAbrupt(proto).

8.  Let obj be IntegerIndexedObjectCreate (proto,
    «‍[[ViewedArrayBuffer]], [[TypedArrayName]], [[ByteLength]],
    [[ByteOffset]], [[ArrayLength]]» ).

9.  Assert: The [[ViewedArrayBuffer]] internal slot of obj is
    UNDEFINED.

10. Set obj’s [[TypedArrayName]] internal slot to constructorName.

11. If length was not passed, then

    a.  Set obj’s [[ByteLength]] internal slot to 0.

    b.  Set obj’s [[ByteOffset]] internal slot to 0.

    c.  Set obj’s [[ArrayLength]] internal slot to 0.

12. Else,

    a.  Let elementSize be the Element Size value in Table 46 for
        constructorName.

    b.  Let byteLength be elementSize × length.

    c.  Let data be AllocateArrayBuffer(%ArrayBuffer%, byteLength).

    d.  ReturnIfAbrupt(data).

    e.  Set obj’s [[ViewedArrayBuffer]] internal slot to data.

    f.  Set obj’s [[ByteLength]] internal slot to byteLength.

    g.  Set obj’s [[ByteOffset]] internal slot to 0.

    h.  Set obj’s [[ArrayLength]] internal slot to length.

13. Return obj.

%TypedArray% ( typedArray )

This description applies only if the %TypedArray% function is called
with at least one argument and the Type of the first argument is Object
and that object has a [[TypedArrayName]] internal slot.

%TypedArray%called with argument typedArray performs the following
steps:

1.  Assert: Type(typedArray) is Object and typedArray has a
    [[TypedArrayName]] internal slot.

2.  If NewTarget is UNDEFINED, throw a TYPEERROR exception.

3.  Let O be AllocateTypedArray(NewTarget).

4.  ReturnIfAbrupt(O).

5.  Let srcArray be typedArray.

6.  7.  8.  9.  10. 11. Let srcData be the value of srcArray’s
    [[ViewedArrayBuffer]] internal slot.

12. 13. If IsDetachedBuffer(srcData) is TRUE, throw a TYPEERROR
    exception.

14. Let constructorName be the string value of O’s
    [[TypedArrayName]] internal slot.

15. Let elementType be the string value of the Element Type value in
    Table 46 for constructorName.

16. Let elementLength be the value of srcArray’s [[ArrayLength]]
    internal slot.

17. Let srcName be the string value of srcArray’s [[TypedArrayName]]
    internal slot.

18. Let srcType be the string value of the Element Type value in Table
    46 for srcName.

19. Let srcElementSize be the Element Size value in Table 46 for
    srcName.

20. 21. Let srcByteOffset be the value of srcArray’s [[ByteOffset]]
    internal slot.

22. Let elementSize be the Element Size value in Table 46 for
    constructorName.

23. Let byteLength be elementSize × elementLength.

24. If SameValue(elementType_,_srcType) is TRUE, then

    a.  Let data be CloneArrayBuffer(srcData, srcByteOffset).

    b.  ReturnIfAbrupt(data).

25. Else,

    a.  Let bufferConstructor be SpeciesConstructor(srcData,
        %ArrayBuffer%).

    b.  ReturnIfAbrupt(bufferConstructor).

    c.  d.  e.  Let data be AllocateArrayBuffer(bufferConstructor,
        byteLength).

    f.  If IsDetachedBuffer(srcData) is TRUE, throw a TYPEERROR
        exception.

    g.  h.  i.  j.  Let srcByteIndex be srcByteOffset.

    k.  Let targetByteIndex be 0.

    l.  Let count be elementLength.

    m.  Repeat, while count >0

        i.  Let value be GetValueFromBuffer(srcData, srcByteIndex,
            srcType).

        ii. Let status be SetValueInBuffer(data, targetByteIndex,
            elementType, value).

        iii. Set srcByteIndex to srcByteIndex + srcElementSize.

        iv. v.  Set targetByteIndex to targetByteIndex +
            elementSize.

        vi. Decrement count by 1.

26. 27. 28. Set O’s [[ViewedArrayBuffer]] internal slot to data.

29. Set O’s [[ByteLength]] internal slot to byteLength.

30. Set O’s [[ByteOffset]] internal slot to 0.

31. Set O’s [[ArrayLength]] internal slot to elementLength.

32. Return O.

%TypedArray% ( object )

This description applies only if the %TypedArray% function is called
with at least one argument and the Type of first argument is Object and
that object does not have either a [[TypedArrayName]] or an
[[ArrayBufferData]] internal slot.

%TypedArray% called with argument object performs the following steps:

1.  Assert: Type(object) is Object and object does not have either a
    [[TypedArrayName]] or an [[ArrayBufferData]] internal slot.

2.  If NewTarget is UNDEFINED, throw a TYPEERROR exception.

3.  4.  5.  6.  7.  8.  9.  10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. a.  b.  c.  d.  e.  f.  

24. 25. 26. 27. 28. 29. 30. Return TypedArrayFrom(NewTarget, object,
    UNDEFINED, UNDEFINED).

%TypedArray% ( buffer [ , byteOffset [ , length ] ] )

This description applies only if the %TypedArray% function is called
with at least one argument and the Type of the first argument is Object
and that object has an [[ArrayBufferData]] internal slot.

%TypedArray% called with arguments buffer, byteOffset, and length
performs the following steps:

1.  Assert: Type(buffer) is Object and buffer has an
    [[ArrayBufferData]] internal slot.

2.  If NewTarget is UNDEFINED, throw a TYPEERROR exception.

3.  4.  5.  6.  Let O be AllocateTypedArray(NewTarget).

7.  ReturnIfAbrupt(O).

8.  9.  10. 11. 12. Let constructorName be the string value of O’s
    [[TypedArrayName]] internal slot.

13. 14. Let elementSize be the Number value of the Element Size value
    in Table 46 for constructorName.

15. Let offset be ToInteger(byteOffset).

16. ReturnIfAbrupt(offset).

17. If offset < 0, throw a RANGEERROR exception.

18. If offset modulo elementSize ≠ 0, throw a RANGEERROR exception.

19. If IsDetachedBuffer(buffer) is TRUE, throw a TYPEERROR exception.

20. Let bufferByteLength be the value of buffer’s
    [[ArrayBufferByteLength]] internal slot.

21. If length is UNDEFINED, then

    a.  If bufferByteLength modulo elementSize ≠ 0, throw a
        RANGEERROR exception.

    b.  Let newByteLength be bufferByteLength – offset.

    c.  If newByteLength < 0, throw a RANGEERROR exception.

22. Else,

    a.  Let newLength be ToLength(length).

    b.  ReturnIfAbrupt(newLength).

    c.  Let newByteLength be newLength × elementSize.

    d.  If offset_+_newByteLength > bufferByteLength, throw a
        RANGEERROR exception.

23. 24. Set O’s [[ViewedArrayBuffer]] internal slot to buffer.

25. Set O’s [[ByteLength]] internal slot to newByteLength.

26. Set O’s [[ByteOffset]] internal slot to offset.

27. Set O’s [[ArrayLength]] internal slot to _newByteLength /
    elementSize_ .

28. Return O.

%TypedArray% ( all other argument combinations )

If the %TypedArray% function is called with arguments that do not match
any of the preceding argument descriptions a TYPEERROR exception is
thrown.

Properties of the %TypedArray% Intrinsic Object

The %TypedArray% intrinsic object is a built-in function object. The
value of the [[Prototype]] internal slot of %TypedArray% is the
intrinsic object %FunctionPrototype% (19.2.3).

1.  2.  3.  4.  5.  6.  7.  8.  9.  

Besides a LENGTH property whose value is 3 and a NAME property whose
value is "TYPEDARRAY", %TypedArray% has the following properties:

%TypedArray%.from ( source [ , mapfn [ , thisArg ] ] )

When the FROM method is called with argument source, and optional
arguments mapfn and thisArg, the following steps are taken:

1.  Let C be the THIS value.

2.  If IsConstructor(C) is FALSE, throw a TYPEERROR exception.

3.  4.  5.  If mapfn was supplied, let f be mapfn; otherwise let
    f be UNDEFINED.

6.  If f is not UNDEFINED, then

    a.  If IsCallable(f) is FALSE, throw a TYPEERROR exception.

7.  If thisArg was supplied, let t be thisArg; else let t be
    UNDEFINED.

8.  Return TypedArrayFrom(C, source, f, t).

The LENGTH property of the FROM method is 1.

NOTE The FROM function is an intentionally generic factory method; it
does not require that its THIS value be a Typed Array constructor.
Therefore it can be transferred to or inherited by any other
constructors that may be called with a single numeric argument. This
function uses [[Set]] to store elements into a newly created object and
assume that the constructor sets the LENGTH property of the new object
to the argument value passed to it.

Runtime Semantics: TypedArrayFrom( constructor, items, mapfn, thisArg )

When the TypedArrayFrom abstract operation is called with arguments
constructor, items, mapfn, and thisArg, the following steps are
taken:

1.  Let C be constructor.

2.  3.  Assert: IsConstructor(C) is TRUE.

4.  5.  6.  Assert: Type(mapfn) is either a callable Object or
    Undefined.

7.  8.  If mapfn is UNDEFINED, let mapping be FALSE.

9.  else

    a.  b.  Let T be thisArg.

    c.  Let mapping be TRUE

10. Let usingIterator be GetMethod(items, @@iterator).

11. ReturnIfAbrupt(usingIterator).

12. If usingIterator is not UNDEFINED, then

    a.  Let iterator be GetIterator(items, usingIterator).

    b.  ReturnIfAbrupt(iterator).

    c.  Let values be a new empty List.

    d.  Let next be TRUE.

    e.  Repeat, while next is not FALSE

        i.  Let next be IteratorStep(iterator).

        ii. If next is an abrupt completion, return
            IteratorClose(iterator, next).

    f.  Let next be next.[[value]].

    g.  If next is not FALSE, then

    h.  i.  Let nextValue be IteratorValue(next).

        ii. If nextValue is an abrupt completion, return
              IteratorClose(iterator, nextValue).

        iii. Append nextValue.[[value]] to the end of the List
              values.

    i.  Let len be the number of elements in values.

    j.  Let targetObj be AllocateTypedArray(C, len).

    k.  ReturnIfAbrupt(targetObj).

    l.  i.  ii. 

    m.  i.  ii. iii. iv. v.  vi. vii. viii. ix. x.  xi. xii. xiii. xiv. xv. xvi. 

    n.  Let k be 0.

    o.  Repeat, while k < len

        i.  Let Pk be ToString(k).

        ii. Let kValue be the first element of values and remove
            that element from list.

        iii. If mapping is TRUE, then

            1.  Let mappedValue be Call(mapfn, T, «kValue,
                k»).

            2.  ReturnIfAbrupt(mappedValue).

        iv. Else, let mappedValue be kValue.

        v.  Let putStatus be Put(targetObj, Pk, mappedValue,
            TRUE).

        vi. ReturnIfAbrupt(putStatus).

        vii. Increase k by 1.

    p.  Assert: values is now an empty List.

    q.  Return targetObj.

13. Assert: items is not an Iterable so assume it is an array-like
    object.

14. Let arrayLike be ToObject(items).

15. ReturnIfAbrupt(arrayLike).

16. Let len be ToLength(Get(arrayLike, "LENGTH")).

17. 18. ReturnIfAbrupt(len).

19. Let targetObj be AllocateTypedArray(C, len).

20. ReturnIfAbrupt(targetObj).

21. Let k be 0.

22. Repeat, while k < len

    a.  Let Pk be ToString(k).

    b.  Let kValue be Get(arrayLike, Pk).

    c.  ReturnIfAbrupt(kValue).

    d.  If mapping is TRUE, then

        i.  Let mappedValue be Call(mapfn, T, «kValue, k»).

        ii. ReturnIfAbrupt(mappedValue).

    e.  Else, let mappedValue be kValue.

    f.  Let putStatus be Put(targetObj, Pk, mappedValue, TRUE).

    g.  ReturnIfAbrupt(putStatus).

    h.  Increase k by 1.

23. Return targetObj.

1.  2.  3.  4.  5.  a.  b.  

6.  a.  b.  c.  d.  e.  f.  g.  h.  i.  j.  k.  l.  m.  n.  o.  p.  

7.  

%TypedArray%.of ( ...items )

When the OF method is called with any number of arguments, the following
steps are taken:

1.  2.  Let len be the actual number of arguments passed to this
    function.

3.  Let items be the List of arguments passed to this function.

4.  Let C be the THIS value.

5.  If IsConstructor(C) is FALSE, throw a TYPEERROR exception.

6.  Let newObj be AllocateTypedArray(C, len).

7.  ReturnIfAbrupt(newObj).

8.  a.  

9.  Let k be 0.

10. Repeat, while k < len

    a.  b.  Let kValue be items_[_k].

    c.  Let Pk be ToString(k).

    d.  Let status be Put(newObj_,_Pk, kValue. TRUE).

    e.  ReturnIfAbrupt(status).

    f.  Increase k by 1.

11. Return newObj.

The LENGTH property of the OF method is 0.

NOTE 1 The items argument is assumed to be a well-formed rest argument
value.

%TypedArray%.prototype

The initial value of %TypedArray%.prototype is the %TypedArrayPrototype%
intrinsic object (22.2.3).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

get %TypedArray% [ @@species ] 

%TYPEDARRAY%[@@SPECIES] is an accessor property whose set accessor
function is UNDEFINED. Its get accessor function performs the following
steps:

1.  Return THIS.

The value of the NAME property of this function is "GET
[SYMBOL.SPECIES]".

NOTE Typed Array prototype methods normally their THIS object’s
constructor to create a derived object. However, a subclass constructor
may over-ride that default behaviour by redefining its @@species
property.

1.  2.  3.  4.  5.  6.  7.  8.  9.  10. 11. 

Properties of the %TypedArrayPrototype% Object

The value of the [[Prototype]] internal slot of the
%TypedArrayPrototype% object is the intrinsic object %ObjectPrototype%
(19.1.3). The %TypedArrayPrototype% object is an ordinary object. It
does not have a [[ViewedArrayBuffer]] or or any other of the internal
slots that are specific to TypedArray instance objects.

get %TypedArray%.prototype.buffer

%TypedArray%.PROTOTYPE.BUFFER is an accessor property whose set accessor
function is UNDEFINED. Its get accessor function performs the following
steps:

1.  Let O be the THIS value.

2.  If Type(O) is not Object, throw a TYPEERROR exception.

3.  If O does not have a [[ViewedArrayBuffer]] internal slot throw a
    TYPEERROR exception.

4.  Let buffer be the value of O’s [[ViewedArrayBuffer]] internal
    slot.

5.  6.  Return buffer.

get %TypedArray%.prototype.byteLength

%TypedArray%.PROTOTYPE.BYTELENGTH is an accessor property whose set
accessor function is UNDEFINED. Its get accessor function performs the
following steps:

1.  Let O be the THIS value.

2.  If Type(O) is not Object, throw a TYPEERROR exception.

3.  If O does not have a [[ViewedArrayBuffer]] internal slot throw a
    TYPEERROR exception.

4.  Let buffer be the value of O’s [[ViewedArrayBuffer]] internal
    slot.

5.  6.  If IsDetachedBuffer(buffer) is TRUE, return 0.

7.  Let size be the value of O’s [[ByteLength]] internal slot.

8.  Return size.

get %TypedArray%.prototype.byteOffset

%TypedArray%.PROTOTYPE.BYTEOFFSET is an accessor property whose set
accessor function is UNDEFINED. Its get accessor function performs the
following steps:

1.  Let O be the THIS value.

2.  If Type(O) is not Object, throw a TYPEERROR exception.

3.  If O does not have a [[ViewedArrayBuffer]] internal slot throw a
    TYPEERROR exception.

4.  Let buffer be the value of O’s [[ViewedArrayBuffer]] internal
    slot.

5.  6.  If IsDetachedBuffer(buffer) is TRUE, return 0.

7.  Let offset be the value of O’s [[ByteOffset]] internal slot.

8.  Return offset.

%TypedArray%.prototype.constructor

The initial value of %TypedArray%.prototype.constructor is the
%TypedArray% intrinsic object.

%TypedArray%.prototype.copyWithin (target, start [, end ] )

%TypedArray%.PROTOTYPE.COPYWITHIN is a distinct function that implements
the same algorithm as ARRAY.PROTOTYPE.COPYWITHIN as defined in 22.1.3.3
except that the THIS object’s [[ArrayLength]] internal slot is accessed
in place of performing a [[Get]] of "LENGTH". The implementation of the
algorithm may be optimized with the knowledge that the THIS value is an
object that has a fixed length and whose integer indexed properties are
not sparse. However, such optimization must not introduce any observable
changes in the specified behaviour of the algorithm.

This function is not generic. ValidateTypedArray is applied to the THIS
value prior to evaluating the algorithm. If its result is an abrupt
completion that exception is thrown instead of evaluating the algorithm.

The LENGTH property of the COPYWITHIN method is 2.

Runtime Semantics: ValidateTypedArray ( O )

When called with argument O the following steps are taken:

1.  If Type(O) is not Object, throw a TYPEERROR exception.

2.  If O does not have a [[TypedArrayName]] internal slot, throw a
    TYPEERROR exception.

3.  If O does not have a [[ViewedArrayBuffer]] internal slot throw a
    TYPEERROR exception.

4.  Let buffer be the value of O’s [[ViewedArrayBuffer]] internal
    slot.

5.  If IsDetachedBuffer(buffer) is TRUE, throw a TYPEERROR exception.

6.  Return buffer.

%TypedArray%.prototype.entries ( )

When ENTRIES is called with THIS value O, the following steps are
taken:

1.  Let O be the THIS value.

2.  Let valid be ValidateTypedArray(O).

3.  ReturnIfAbrupt(valid).

4.  5.  6.  7.  8.  9.  10. 11. Return CreateArrayIterator(O,
    "KEY+VALUE").

%TypedArray%.prototype.every ( callbackfn [ , thisArg ] )

%TypedArray%.PROTOTYPE.EVERY is a distinct function that implements the
same algorithm as ARRAY.PROTOTYPE.EVERY as defined in 22.1.3.5 except
that the THIS object’s [[ArrayLength]] internal slot is accessed in
place of performing a [[Get]] of "LENGTH". The implementation of the
algorithm may be optimized with the knowledge that the THIS value is an
object that has a fixed length and whose integer indexed properties are
not sparse. However, such optimization must not introduce any observable
changes in the specified behaviour of the algorithm and must take into
account the possibility that calls to callbackfn may cause the THIS
value to become detached.

This function is not generic. ValidateTypedArray is applied to the THIS
value prior to evaluating the algorithm. If its result is an abrupt
completion that exception is thrown instead of evaluating the algorithm.

The LENGTH property of the EVERY method is 1.

%TypedArray%.prototype.fill (value [ , start [ , end ] ] )

%TypedArray%.PROTOTYPE.FILL is a distinct function that implements the
same algorithm as ARRAY.PROTOTYPE.FILL as defined in 22.1.3.6 except
that the THIS object’s [[ArrayLength]] internal slot is accessed in
place of performing a [[Get]] of "LENGTH". The implementation of the
algorithm may be optimized with the knowledge that the THIS value is an
object that has a fixed length and whose integer indexed properties are
not sparse. However, such optimization must not introduce any observable
changes in the specified behaviour of the algorithm.

This function is not generic. ValidateTypedArray is applied to the THIS
value prior to evaluating the algorithm. If its result is an abrupt
completion that exception is thrown instead of evaluating the algorithm.

The LENGTH property of the FILL method is 1.

%TypedArray%.prototype.filter ( callbackfn [ , thisArg ] )

The interpretation and use of the arguments of
%TypedArray%.PROTOTYPE.FILTER are the same as for ARRAY.PROTOTYPE.FILTER
as defined in 22.1.3.7.

When the FILTER method is called with one or two arguments, the
following steps are taken:

1.  Let O be the THIS value.

2.  3.  4.  5.  6.  7.  Let valid be ValidateTypedArray(O).

8.  ReturnIfAbrupt(valid).

9.  Let len be the value of O’s [[ArrayLength]] internal slot.

10. If IsCallable(callbackfn) is FALSE, throw a TYPEERROR exception.

11. If thisArg was supplied, let T be thisArg; else let T be
    UNDEFINED.

12. Let defaultConstructor be the intrinsic object listed in column
    one of Table 46 for the value of O’s [[TypedArrayName]] internal
    slot.

13. Let C be SpeciesConstructor(O, defaultConstructor).

14. ReturnIfAbrupt(C).

15. a.  

16. Let kept be a new empty List.

17. Let k be 0.

18. Let captured be 0.

19. Repeat, while k < len

    a.  Let Pk be ToString(k).

    b.  Let kValue be Get(O, Pk).

    c.  ReturnIfAbrupt(kValue).

    d.  Let selected be ToBoolean(Call(callbackfn, T, «kValue,
        k, O»)).

    e.  ReturnIfAbrupt(selected).

    f.  If selected is TRUE, then

        i.  Append kValue to the end of kept.

        ii. Increase captured by 1.

    g.  Increase k by 1.

20. Let A be AllocateTypedArray(C, captured).

21. ReturnIfAbrupt(A).

22. Let n be 0.

23. For each element e of kept

    a.  Let status be Put(A, ToString(n), e, TRUE ).

    b.  ReturnIfAbrupt(status).

    c.  Increment n by 1.

24. Return A.

This function is not generic. The THIS value must be an object with a
[[TypedArrayName]] internal slot.

The LENGTH property of the FILTER method is 1.

%TypedArray%.prototype.find (predicate [ , thisArg ] )

%TypedArray%.PROTOTYPE.FIND is a distinct function that implements the
same algorithm as ARRAY.PROTOTYPE.FIND as defined in 22.1.3.8 except
that the THIS object’s [[ArrayLength]] internal slot is accessed in
place of performing a [[Get]] of "LENGTH". The implementation of the
algorithm may be optimized with the knowledge that the THIS value is an
object that has a fixed length and whose integer indexed properties are
not sparse. However, such optimization must not introduce any observable
changes in the specified behaviour of the algorithm and must take into
account the possibility that calls to predicate may cause the THIS
value to become detached.

This function is not generic. ValidateTypedArray is applied to the THIS
value prior to evaluating the algorithm. If its result is an abrupt
completion that exception is thrown instead of evaluating the algorithm.

The LENGTH property of the FIND method is 1.

%TypedArray%.prototype.findIndex ( predicate [ , thisArg ] )

%TypedArray%.PROTOTYPE.FINDINDEX is a distinct function that implements
the same algorithm as ARRAY.PROTOTYPE.FINDINDEX as defined in 22.1.3.9
except that the THIS object’s [[ArrayLength]] internal slot is accessed
in place of performing a [[Get]] of "LENGTH". The implementation of the
algorithm may be optimized with the knowledge that the THIS value is an
object that has a fixed length and whose integer indexed properties are
not sparse. However, such optimization must not introduce any observable
changes in the specified behaviour of the algorithm and must take into
account the possibility that calls to predicate may cause the THIS
value to become detached.

This function is not generic. ValidateTypedArray is applied to the THIS
value prior to evaluating the algorithm. If its result is an abrupt
completion that exception is thrown instead of evaluating the algorithm.

The LENGTH property of the FINDINDEX method is 1.

%TypedArray%.prototype.forEach ( callbackfn [ , thisArg ] )

%TypedArray%.PROTOTYPE.FOREACH is a distinct function that implements
the same algorithm as ARRAY.PROTOTYPE.FOREACH as defined in 22.1.3.10
except that the THIS object’s [[ArrayLength]] internal slot is accessed
in place of performing a [[Get]] of "LENGTH". The implementation of the
algorithm may be optimized with the knowledge that the THIS value is an
object that has a fixed length and whose integer indexed properties are
not sparse. However, such optimization must not introduce any observable
changes in the specified behaviour of the algorithm and must take into
account the possibility that calls to callbackfn may cause the THIS
value to become detached.

This function is not generic. ValidateTypedArray is applied to the THIS
value prior to evaluating the algorithm. If its result is an abrupt
completion that exception is thrown instead of evaluating the algorithm.

The LENGTH property of the FOREACH method is 1.

%TypedArray%.prototype.indexOf (searchElement [ , fromIndex ] )

%TypedArray%.PROTOTYPE.INDEXOF is a distinct function that implements
the same algorithm as ARRAY.PROTOTYPE.INDEXOF as defined in 22.1.3.11
except that the THIS object’s [[ArrayLength]] internal slot is accessed
in place of performing a [[Get]] of "LENGTH". The implementation of the
algorithm may be optimized with the knowledge that the THIS value is an
object that has a fixed length and whose integer indexed properties are
not sparse. However, such optimization must not introduce any observable
changes in the specified behaviour of the algorithm.

This function is not generic. ValidateTypedArray is applied to the THIS
value prior to evaluating the algorithm. If its result is an abrupt
completion that exception is thrown instead of evaluating the algorithm.

The LENGTH property of the INDEXOF method is 1.

%TypedArray%.prototype.join ( separator )

%TypedArray%.PROTOTYPE.JOIN is a distinct function that implements the
same algorithm as ARRAY.PROTOTYPE.JOIN as defined in 22.1.3.12 except
that the THIS object’s [[ArrayLength]] internal slot is accessed in
place of performing a [[Get]] of "LENGTH". The implementation of the
algorithm may be optimized with the knowledge that the THIS value is an
object that has a fixed length and whose integer indexed properties are
not sparse. However, such optimization must not introduce any observable
changes in the specified behaviour of the algorithm.

This function is not generic. ValidateTypedArray is applied to the THIS
value prior to evaluating the algorithm. If its result is an abrupt
completion that exception is thrown instead of evaluating the algorithm.

%TypedArray%.prototype.keys ( )

The following steps are taken:

1.  Let O be the THIS value.

2.  3.  4.  Let valid be ValidateTypedArray(O).

5.  ReturnIfAbrupt(valid).

6.  7.  8.  9.  Return CreateArrayIterator(O, "KEY").

%TypedArray%.prototype.lastIndexOf ( searchElement [ , fromIndex ] )

%TypedArray%.PROTOTYPE.LASTINDEXOF is a distinct function that
implements the same algorithm as ARRAY.PROTOTYPE.LASTINDEXOF as defined
in 22.1.3.14 except that the THIS object’s [[ArrayLength]] internal slot
is accessed in place of performing a [[Get]] of "LENGTH". The
implementation of the algorithm may be optimized with the knowledge that
the THIS value is an object that has a fixed length and whose integer
indexed properties are not sparse. However, such optimization must not
introduce any observable changes in the specified behaviour of the
algorithm.

This function is not generic. ValidateTypedArray is applied to the THIS
value prior to evaluating the algorithm. If its result is an abrupt
completion that exception is thrown instead of evaluating the algorithm.

The LENGTH property of the LASTINDEXOF method is 1.

get %TypedArray%.prototype.length

%TypedArray%.PROTOTYPE.LENGTH is an accessor property whose set accessor
function is UNDEFINED. Its get accessor function performs the following
steps:

1.  Let O be the THIS value.

2.  If Type(O) is not Object, throw a TYPEERROR exception.

3.  If O does not have a [[TypedArrayName]] internal slot, throw a
    TYPEERROR exception.

4.  Assert: O has [[ViewedArrayBuffer]] and [[ArrayLength]] internal
    slots.

5.  Let buffer be the value of O’s [[ViewedArrayBuffer]] internal
    slot.

6.  7.  If IsDetachedBuffer(buffer) is TRUE, return 0.

8.  Let length be the value of O’s [[ArrayLength]] internal slot.

9.  Return length.

This function is not generic. The THIS value must be an object with a
[[TypedArrayName]] internal slot.

%TypedArray%.prototype.map ( callbackfn [ , thisArg ] )

The interpretation and use of the arguments of
%TypedArray%.PROTOTYPE.MAP are the same as for ARRAY.PROTOTYPE.MAP as
defined in 22.1.3.15.

When the MAP method is called with one or two arguments, the following
steps are taken:

1.  Let O be the THIS value.

2.  Let valid be ValidateTypedArray(O).

3.  ReturnIfAbrupt(valid).

4.  5.  6.  7.  8.  9.  Let len be the value of O’s [[ArrayLength]]
    internal slot.

10. If IsCallable(callbackfn) is FALSE, throw a TYPEERROR exception.

11. If thisArg was supplied, let T be thisArg; else let T be
    UNDEFINED.

12. Let defaultConstructor be the intrinsic object listed in column
    one of Table 46 for the value of O’s [[TypedArrayName]] internal
    slot.

13. Let C be SpeciesConstructor(O, defaultConstructor).

14. ReturnIfAbrupt(C).

15. 16. Let A be AllocateTypedArray(C, len).

17. ReturnIfAbrupt(A).

18. a.  

19. Let k be 0.

20. Repeat, while k < len

    a.  Let Pk be ToString(k).

    b.  Let kValue be Get(O, Pk).

    c.  ReturnIfAbrupt(kValue).

    d.  Let mappedValue be Call(callbackfn, T, «kValue, k,
        O»).

    e.  ReturnIfAbrupt(mappedValue).

    f.  Let status be Put(A, Pk, mappedValue, TRUE ).

    g.  ReturnIfAbrupt(status).

    h.  Increase k by 1.

21. Return A.

This function is not generic. The THIS value must be an object with a
[[TypedArrayName]] internal slot.

The LENGTH property of the MAP method is 1.

%TypedArray%.prototype.reduce ( callbackfn [ , initialValue ] )

%TypedArray%.PROTOTYPE.REDUCE is a distinct function that implements the
same algorithm as ARRAY.PROTOTYPE.REDUCE as defined in 22.1.3.18 except
that the THIS object’s [[ArrayLength]] internal slot is accessed in
place of performing a [[Get]] of "LENGTH". The implementation of the
algorithm may be optimized with the knowledge that the THIS value is an
object that has a fixed length and whose integer indexed properties are
not sparse. However, such optimization must not introduce any observable
changes in the specified behaviour of the algorithm and must take into
account the possibility that calls to callbackfn may cause the THIS
value to become detached.

This function is not generic. ValidateTypedArray is applied to the THIS
value prior to evaluating the algorithm. If its result is an abrupt
completion that exception is thrown instead of evaluating the algorithm.

The LENGTH property of the REDUCE method is 1.

%TypedArray%.prototype.reduceRight ( callbackfn [ , initialValue ] )

%TypedArray%.PROTOTYPE.REDUCERIGHT is a distinct function that
implements the same algorithm as ARRAY.PROTOTYPE.REDUCERIGHT as defined
in 22.1.3.19 except that the THIS object’s [[ArrayLength]] internal slot
is accessed in place of performing a [[Get]] of "LENGTH". The
implementation of the algorithm may be optimized with the knowledge that
the THIS value is an object that has a fixed length and whose integer
indexed properties are not sparse. However, such optimization must not
introduce any observable changes in the specified behaviour of the
algorithm and must take into account the possibility that calls to
callbackfn may cause the THIS value to become detached.

This function is not generic. ValidateTypedArray is applied to the THIS
value prior to evaluating the algorithm. If its result is an abrupt
completion that exception is thrown instead of evaluating the algorithm.

The LENGTH property of the REDUCERIGHT method is 1.

%TypedArray%.prototype.reverse ( )

%TypedArray%.PROTOTYPE.REVERSE is a distinct function that implements
the same algorithm as ARRAY.PROTOTYPE.REVERSE as defined in 22.1.3.20
except that the THIS object’s [[ArrayLength]] internal slot is accessed
in place of performing a [[Get]] of "LENGTH". The implementation of the
algorithm may be optimized with the knowledge that the THIS value is an
object that has a fixed length and whose integer indexed properties are
not sparse. However, such optimization must not introduce any observable
changes in the specified behaviour of the algorithm.

This function is not generic. ValidateTypedArray is applied to the THIS
value prior to evaluating the algorithm. If its result is an abrupt
completion that exception is thrown instead of evaluating the algorithm.

%TypedArray%.prototype.set ( overloaded [ , offset ])

%TypedArray%.PROTOTYPE.SET is a single function whose behaviour is
overloaded based upon the type of its first argument.

This function is not generic. The THIS value must be an object with a
[[TypedArrayName]] internal slot.

  The LENGTH property of the SET method is 1.

%TypedArray%.prototype.set (array [ , offset ] )

Set multiple values in this TypedArray, reading the values from the
object array. The optional offset value indicates the first element
index in this TypedArray where values are written. If omitted, it is
assumed to be 0.

1.  Assert: array does not have a [[TypedArrayName]] internal slot. If
    it does, the definition in 22.2.3.22.2 applies.

2.  Let target be the THIS value.

3.  If Type(target) is not Object, throw a TYPEERROR exception.

4.  If target does not have a [[TypedArrayName]] internal slot, throw
    a TYPEERROR exception.

5.  Assert: target has a [[ViewedArrayBuffer]] internal slot.

6.  7.  8.  9.  10. Let targetOffset be ToInteger (offset)

11. ReturnIfAbrupt(targetOffset).

12. If targetOffset < 0, throw a RANGEERROR exception.

13. Let targetBuffer be the value of target’s [[ViewedArrayBuffer]]
    internal slot.

14. 15. If IsDetachedBuffer(targetBuffer) is TRUE, throw a TYPEERROR
    exception.

16. Let targetLength be the value of target’s [[ArrayLength]]
    internal slot.

17. Let targetName be the string value of target’s
    [[TypedArrayName]] internal slot.

18. Let targetElementSize be the Number value of the Element Size
    value specified in Table 46 for targetName.

19. Let targetType be the string value of the Element Type value in
    Table 46 for targetName.

20. Let targetByteOffset be the value of target’s [[ByteOffset]]
    internal slot.

21. Let src be ToObject(array).

22. 23. ReturnIfAbrupt(src).

24. Let srcLen be Get(src, "LENGTH").

25. Let numberLength be ToNumber(srcLen).

26. Let srcLength be ToInteger(numberLength).

27. ReturnIfAbrupt(srcLength).

28. If numberLength ≠ srcLength or srcLength < 0, throw a
    TYPEERROR exception.

29. If srcLength + targetOffset > targetLength, throw a RANGEERROR
    exception.

30. Let targetByteIndex be targetOffset × targetElementSize +
    targetByteOffset.

31. Let k be 0.

32. Let limit be targetByteIndex + targetElementSize ×
    min(srcLength, targetLength – targetOffset).

33. Repeat, while targetByteIndex < limit

    a.  Let Pk be ToString(k).

    b.  Let kValue be Get(src, Pk).

    c.  Let kNumber be ToNumber(kValue).

    d.  ReturnIfAbrupt(kNumber).

    e.  If IsDetachedBuffer(targetBuffer) is TRUE, throw a TYPEERROR
        exception.

    f.  Perform SetValueInBuffer(targetBuffer, targetByteIndex,
        targetType, kNumber).

    g.  Set k to k + 1.

    h.  Set targetByteIndex to targetByteIndex +
        targetElementSize.

34. Return UNDEFINED.

%TypedArray%.prototype.set(typedArray [, offset ] )

Set multiple values in this TypedArray, reading the values from the
typedArray argument object. The optional offset value indicates the
first element index in this TypedArray where values are written. If
omitted, it is assumed to be 0.

1.  Assert: typedArray has a [[TypedArrayName]] internal slot. If it
    does not, the definition in 22.2.3.22.1 applies.

2.  Let target be the THIS value.

3.  If Type(target) is not Object, throw a TYPEERROR exception.

4.  If target does not have a [[TypedArrayName]] internal slot, throw
    a TYPEERROR exception.

5.  Assert: target has a [[ViewedArrayBuffer]] internal slot.

6.  7.  8.  9.  10. 11. Let targetOffset be ToInteger (offset)

12. ReturnIfAbrupt(targetOffset).

13. If targetOffset < 0, throw a RANGEERROR exception.

14. Let targetBuffer be the value of target’s [[ViewedArrayBuffer]]
    internal slot.

15. 16. If IsDetachedBuffer(targetBuffer) is TRUE, throw a TYPEERROR
    exception.

17. Let targetLength be the value of target’s [[ArrayLength]]
    internal slot.

18. Let srcBuffer be the value of typedArray’s [[ViewedArrayBuffer]]
    internal slot.

19. 20. If IsDetachedBuffer(srcBuffer) is TRUE, throw a TYPEERROR
    exception.

21. Let targetName be the string value of target’s
    [[TypedArrayName]] internal slot.

22. Let targetType be the string value of the Element Type value in
    Table 46 for targetName.

23. Let targetElementSize be the Number value of the Element Size
    value specified in Table 46 for targetName.

24. Let targetByteOffset be the value of target’s [[ByteOffset]]
    internal slot.

25. Let srcName be the string value of typedArray’s
    [[TypedArrayName]] internal slot.

26. Let srcType be the string value of the Element Type value in Table
    46 for srcName .

27. Let srcElementSize be the Number value of the Element Size value
    specified in Table 46 for srcName.

28. Let srcLength be the value of typedArray’s [[ArrayLength]]
    internal slot.

29. Let srcByteOffset be the value of typedArray’s [[ByteOffset]]
    internal slot.

30. If srcLength + targetOffset > targetLength, throw a RANGEERROR
    exception.

31. If SameValue(srcBuffer, targetBuffer) is TRUE, then

32. a.  Let srcBuffer be CloneArrayBuffer(targetBuffer,
        srcByteOffset, %ArrayPrototype%).

    b.  NOTE: %ArrayPrototype% is used to clone targetBuffer because
        is it known to not have any observable side-effects.

    c.  ReturnIfAbrupt(srcBuffer).

    d.  e.  Let srcByteIndex be 0.

33. Else, let srcByteIndex be srcByteOffset.

34. Let targetByteIndex be targetOffset × targetElementSize +
    targetByteOffset.

35. Let limit be targetByteIndex + targetElementSize ×
    min(srcLength, targetLength – targetOffset).

36. Repeat, while targetByteIndex < limit

    a.  Let value be GetValueFromBuffer(srcBuffer, srcByteIndex,
        srcType).

    b.  Let status be SetValueInBuffer (targetBuffer,
        targetByteIndex, targetType, value).

    c.  Set srcByteIndex to srcByteIndex + srcElementSize.

    d.  e.  Set targetByteIndex to targetByteIndex +
        targetElementSize.

37. Return UNDEFINED.

%TypedArray%.prototype.slice ( start, end )

The interpretation and use of the arguments of
%TypedArray%.PROTOTYPE.SLICE are the same as for ARRAY.PROTOTYPE.SLICE
as defined in 22.1.3.22. The following steps are taken:

1.  Let O be the THIS value.

2.  Let valid be ValidateTypedArray(O).

3.  ReturnIfAbrupt(valid).

4.  5.  6.  7.  8.  9.  10. Let len be the value of O’s
    [[ArrayLength]] internal slot.

11. Let relativeStart be ToInteger(start).

12. ReturnIfAbrupt(relativeStart).

13. If relativeStart < 0, let k be max((len + relativeStart),0);
    else let k be min(relativeStart, len).

14. If end is UNDEFINED, let relativeEnd be len; else let
    relativeEnd be ToInteger(end).

15. ReturnIfAbrupt(relativeEnd).

16. If relativeEnd < 0, let final be max((len + relativeEnd),0);
    else let final be min(relativeEnd, len).

17. Let count be max(final – k, 0).

18. Let defaultConstructor be the intrinsic object listed in column
    one of Table 46 for the value of O’s [[TypedArrayName]] internal
    slot.

19. Let C be SpeciesConstructor(O, defaultConstructor).

20. ReturnIfAbrupt(C).

21. 22. Let A AllocateTypedArray(C, count).

23. ReturnIfAbrupt(A).

24. a.  

25. Let n be 0.

26. Repeat, while k < final

    a.  Let Pk be ToString(k).

    b.  Let kValue be Get(O, Pk).

    c.  ReturnIfAbrupt(kValue).

    d.  Let status be Put(A, ToString(n), kValue, TRUE ).

    e.  ReturnIfAbrupt(status).

    f.  Increase k by 1.

    g.  Increase n by 1.

27. Return A.

This function is not generic. The THIS value must be an object with a
[[TypedArrayName]] internal slot.

The LENGTH property of the SLICE method is 2.

%TypedArray%.prototype.some ( callbackfn [ , thisArg ] )

%TypedArray%.PROTOTYPE.SOME is a distinct function that implements the
same algorithm as ARRAY.PROTOTYPE.SOME as defined in 22.1.3.23 except
that the THIS object’s [[ArrayLength]] internal slot is accessed in
place of performing a [[Get]] of "LENGTH". The implementation of the
algorithm may be optimized with the knowledge that the THIS value is an
object that has a fixed length and whose integer indexed properties are
not sparse. However, such optimization must not introduce any observable
changes in the specified behaviour of the algorithm and must take into
account the possibility that calls to callbackfn may cause the THIS
value to become detached.

This function is not generic. ValidateTypedArray is applied to the THIS
value prior to evaluating the algorithm. If its result is an abrupt
completion that exception is thrown instead of evaluating the algorithm.

The LENGTH property of the SOME method is 1.

%TypedArray%.prototype.sort ( comparefn )

%TypedArray%.PROTOTYPE.SORT is a distinct function that, except as
described below, implements the same requirements as those of
ARRAY.PROTOTYPE.SORT as defined in 22.1.3.24. The implementation of the
%TypedArray%.PROTOTYPE.SORT specification may be optimized with the
knowledge that the THIS value is an object that has a fixed length and
whose integer indexed properties are not sparse. The only internal
methods of the THIS object that the algorithm may call are [[Get]] and
[[Set]].

This function is not generic. The THIS value must be an object with a
[[TypedArrayName]] internal slot.

Upon entry, the following steps are performed to initialize evaluation
of the SORT function. These steps are used instead of the entry steps in
22.1.3.24:

1.  Let obj be the THIS value as the argument.

2.  Let buffer be ValidateTypedArray(obj).

3.  ReturnIfAbrupt(buffer).

4.  5.  6.  7.  8.  Let len be the value of obj’s [[ArrayLength]]
    internal slot.

The following version of SortCompare is used by
%TypedArray%.PROTOTYPE.SORT. It performs a numeric comparison rather
than the string comparison used in 22.1.3.24.

The Typed Array SortCompare abstract operation is called with two
arguments x and y, the following steps are taken:

1.  2.  3.  4.  5.  6.  7.  Assert: Both Type(x) and Type(y) is
    Number.

8.  9.  10. 11. If the argument comparefn is not UNDEFINED, then

    a.  b.  Let v be Call(comparefn, UNDEFINED, «x, y»).

    c.  ReturnIfAbrupt(v).

    d.  If IsDetachedBuffer(buffer) is TRUE, throw a TYPEERROR
        exception.

    e.  If v is NAN, return +0.

    f.  Return v.

12. If x and y are both NAN, return +0.

13. If x is NAN, return 1.

14. If y is NAN, return −1.

15. If x < y, return −1.

16. If x > y, return 1.

17. Return +0.

NOTE 1 Because NAN always compares greater than any other value, NAN
property values always sort to the end of the result when a comparefn
is not provided.

%TypedArray%.prototype.subarray( [ begin [ , end ] ] )

Returns a new TypedArray object whose element types is the same as
this TypedArray and whose ArrayBuffer is the same as the ArrayBuffer
of this TypedArray, referencing the elements at begin, inclusive, up
to end, exclusive. If either begin or end is negative, it refers
to an index from the end of the array, as opposed to from the beginning.

1.  Let O be the THIS value.

2.  If Type(O) is not Object, throw a TYPEERROR exception.

3.  If O does not have a [[TypedArrayName]] internal slot, throw a
    TYPEERROR exception.

4.  Assert: O has a [[ViewedArrayBuffer]] internal slot.

5.  Let buffer be the value of O’s [[ViewedArrayBuffer]] internal
    slot.

6.  7.  Let srcLength be the value of O’s [[ArrayLength]] internal
    slot.

8.  Let beginInt be ToInteger(begin)

9.  ReturnIfAbrupt(beginInt).

10. If beginInt < 0, let beginInt be srcLength + beginInt.

11. Let beginIndex be min(srcLength, max(0, beginInt)).

12. If end is UNDEFINED, let end be srcLength.

13. Let endInt be ToInteger(end).

14. ReturnIfAbrupt(endInt).

15. If endInt < 0, let endInt be srcLength + endInt.

16. Let endIndex be max(0,min(srcLength, endInt)).

17. If endIndex < beginIndex, let endIndex be beginIndex.

18. Let newLength be endIndex - beginIndex.

19. Let constructorName be the string value of O’s
    [[TypedArrayName]] internal slot.

20. 21. Let elementSize be the Number value of the Element Size value
    specified in Table 46 for constructorName.

22. Let srcByteOffset be the value of O’s [[ByteOffset]] internal
    slot.

23. Let beginByteOffset be srcByteOffset + beginIndex ×
    elementSize.

24. Let defaultConstructor be the intrinsic object listed in column
    one of Table 46 for constructorName.

25. Let constructor be SpeciesConstructor(O, defaultConstructor).

26. ReturnIfAbrupt(constructor).

27. 28. Let argumentsList be «buffer, beginByteOffset,
    newLength».

29. Return Construct(constructor, argumentsList).

This function is not generic. The THIS value must be an object with a
[[TypedArrayName]] internal slot.

The LENGTH property of the SUBARRAY method is 2.

%TypedArray%.prototype.toLocaleString ([ reserved1 [ , reserved2 ] ])

%TypedArray%.PROTOTYPE.TOLOCALESTRING is a distinct function that
implements the same algorithm as ARRAY.PROTOTYPE. TOLOCALESTRING as
defined in 22.1.3.26 except that the THIS object’s [[ArrayLength]]
internal slot is accessed in place of performing a [[Get]] of "LENGTH".
The implementation of the algorithm may be optimized with the knowledge
that the THIS value is an object that has a fixed length and whose
integer indexed properties are not sparse. However, such optimization
must not introduce any observable changes in the specified behaviour of
the algorithm.

This function is not generic. ValidateTypedArray is applied to the THIS
value prior to evaluating the algorithm. If its result is an abrupt
completion that exception is thrown instead of evaluating the algorithm.

%TypedArray%.prototype.toString ( )

The initial value of the %TypedArray%.prototype.toString data property
is the same built-in function object as the Array.prototype.toString
method defined in 22.1.3.27.

%TypedArray%.prototype.values ( )

The following steps are taken:

1.  Let O be the THIS value.

2.  3.  4.  5.  6.  7.  8.  9.  Let valid be ValidateTypedArray(O).

10. ReturnIfAbrupt(valid).

11. Return CreateArrayIterator(O, "VALUE").

%TypedArray%.prototype [ @@iterator ] ( )

The initial value of the @@iterator property is the same function object
as the initial value of the %TypedArray%.PROTOTYPE.VALUES property.

get %TypedArray%.prototype [ @@toStringTag ]

%TypedArray%.PROTOTYPE[@@TOSTRINGTAG] is an accessor property whose set
accessor function is UNDEFINED. Its get accessor function performs the
following steps:

1.  Let O be the THIS value.

2.  If Type(O) is not Object, return UNDEFINED.

3.  If O does not have a [[TypedArrayName]] internal slot, return
    UNDEFINED.

4.  Let name be the value of O’s [[TypedArrayName]] internal slot.

5.  6.  Assert: name is a String value.

7.  Return name.

This property has the attributes { [[Enumerable]]: FALSE,
[[Configurable]]: TRUE }.

The initial value of the NAME property of this function is "GET
[SYMBOL.TOSTRINGTAG]".

The TypedArray Constructors

Each of these TypedArray constructor objects is an intrinsic object
that has the structure described below, differing only in the name used
as the constructor name instead of TypedArray, in Table 46.

The TypedArray constructors are not intended to be called as a
function and will throw an exception when called in that manner.

The TypedArray constructors are designed to be subclassable. They may
be used as the value of an EXTENDS clause of a class definition.
Subclass constructors that intend to inherit the specified TypedArray
behaviour must include a SUPER call to the TypedArray constructor to
create and initialize the subclass instance with the internal state
necessary to support the %TypedArray%.PROTOTYPE built-in methods.

TypedArray( ... argumentsList)

A TypedArray constructor with a list of arguments argumentsList
performs the following steps:

1.  If NewTarget is UNDEFINED, throw a TYPEERROR exception.

2.  3.  4.  5.  6.  7.  8.  Let here be the active function. .

9.  Let super be the result of calling the [[GetPrototypeOf]] internal
    method of here with no arguments.

10. ReturnIfAbrupt(super).

11. If IsConstructor (constructor) is FALSE, throw a TYPEERROR
    exception.

12. Let argumentsList be the argumentsList argument of the
    [[Construct]] internal method that invoked the active function.

13. 14. Return Construct(super, argumentsList, NewTarget).

1.  2.  3.  

Properties of the TypedArray Constructors

The value of the [[Prototype]] internal slot of each TypedArray
constructor is the %TypedArray% intrinsic object (22.2.1).

Each TypedArray constructor has a [[TypedArrayConstructorName]]
internal slot property whose value is the String value of the
constructor name specified for it in Table 46.

Each TypedArray constructor has a NAME property whose value is the
String value of the constructor name specified for it in Table 46.

Besides a LENGTH property (whose value is 3), each TypedArray
constructor has the following properties:

TypedArray_.BYTES_PERELEMENT

The value of TypedArray_.BYTES_PERELEMENT is the Number value of the
Element Size value specified in Table 46 for TypedArray.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

TypedArray.prototype

The initial value of TypedArray.prototype is the corresponding
TypedArray prototype object (22.2.6).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Properties of TypedArray Prototype Objects

The value of the [[Prototype]] internal slot of a TypedArray prototype
object is the intrinsic object %TypedArrayPrototype% (22.2.3). A
TypedArray prototype object is an ordinary object. It does not have a
[[ViewedArrayBuffer]] or or any other of the internal slots that are
specific to TypedArray instance objects.

TypedArray_.prototype.BYTES_PERELEMENT

The value of TypedArray_.prototype.BYTES_PERELEMENT is the Number
value of the Element Size value specified in Table 46 for TypedArray.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

TypedArray.prototype.constructor

The initial value of a TypedArray.prototype.constructor is the
corresponding %TypedArray% intrinsic object.

Properties of TypedArray Instances

TypedArray instances are Integer Indexed exotic objects. Each
TypedArray instances inherits properties from the corresponding
TypedArray prototype object. Each TypedArray instances have the
following internal slots: [[TypedArrayName]], [[ViewedArrayBuffer]],
[[ByteLength]], [[ByteOffset]], and [[ArrayLength]].



KEYED COLLECTION 


Map Objects

Map objects are collections of key/value pairs where both the keys and
values may be arbitrary ECMAScript language values. A distinct key value
may only occur in one key/value pair within the Map’s collection.
Distinct key values are discriminated using the SameValueZero comparison
algorithm.

Map object must be implemented using either hash tables or other
mechanisms that, on average, provide access times that are sublinear on
the number of elements in the collection. The data structures used in
this Map objects specification is only intended to describe the required
observable semantics of Map objects. It is not intended to be a viable
implementation model.

The Map Constructor 

The Map constructor is the %Map% intrinsic object and the initial value
of the MAP property of the global object. When called as a constructor
it creates and initializes a new Map object. MAP is not intended to be
called as a function and will throw an exception when called in that
manner.

The MAP constructor is designed to be subclassable. It may be used as
the value in an EXTENDS clause of a class definition. Subclass
constructors that intend to inherit the specified MAP behaviour must
include a SUPER call to the MAP constructor to create and initialize the
subclass instance with the internal state necessary to support the
MAP.PROTOTYPE built-in methods.

Map ( [ iterable ] ) 

When the MAP function is called with optional argument the following
steps are taken:

1.  2.  3.  4.  If NewTarget is UNDEFINED, throw a TYPEERROR exception.

5.  Let map be OrdinaryCreateFromConstructor(NewTarget,
    "%MAPPROTOTYPE%", «‍[[MapData]]» ).

6.  ReturnIfAbrupt(map).

7.  Set map’s [[MapData]] internal slot to a new empty List.

8.  If iterable is not present, let iterable be UNDEFINED.

9.  If iterable is either UNDEFINED or NULL, let iter be UNDEFINED.

10. Else,

    a.  b.  c.  Let adder be the result of Get(map, "SET").

    d.  ReturnIfAbrupt(adder).

    e.  If IsCallable(adder) is FALSE, throw a TYPEERROR Exception.

    f.  Let iter be the result of GetIterator(iterable).

    g.  ReturnIfAbrupt(iter).

11. 12. 13. 14. If iter is UNDEFINED, return map.

15. Repeat

    a.  Let next be the result of IteratorStep(iter).

    b.  If next is an abrupt completion, return IteratorClose(iter,
        next).

    c.  If next.[[value]] is FALSE, return map.

    d.  Let nextItem be IteratorValue(next.[[value]]).

    e.  If nextItem is an abrupt completion, return
        IteratorClose(iter, nextItem).

    f.  If Type(nextItem.[[value]]) is not Object,

        i.  Let error be Completion{[[type]]: throw, [[value]]: a
            newly created TYPEERROR object, [[target]]:empty}.

        ii. Return IteratorClose(iter, error).

    g.  Let k be the result of Get(nextItem.[[value]], "0").

    h.  If k is an abrupt completion, return IteratorClose(iter,
        k).

    i.  Let v be the result of Get(nextItem.[[value]], "1").

    j.  If v is an abrupt completion, return IteratorClose(iter,
        v).

    k.  Let status be Call(adder, map, «k.[[value]],
        v.[[value]]»).

    l.  If status is an abrupt completion, return
        IteratorClose(iter, status).

NOTE If the parameter iterable is present, it is expected to be an
object that implements an @@iterator method that returns an iterator
object that produces a two element array-like object whose first element
is a value that will be used as a Map key and whose second element is
the value to associate with that key.

1.  2.  3.  

Properties of the Map Constructor

The value of the [[Prototype]] internal slot of the Map constructor is
the intrinsic object %FunctionPrototype% (19.2.3).

1.  

Besides the LENGTH property (whose value is 1), the Map constructor has
the following properties:

Map.prototype

The initial value of MAP.PROTOTYPE is the Map prototype object (23.1.3).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

get Map [ @@species ] 

MAP[@@SPECIES] is an accessor property whose set accessor function is
UNDEFINED. Its get accessor function performs the following steps:

1.  Return THIS.

The value of the NAME property of this function is "GET
[SYMBOL.SPECIES]".

NOTE Map prototype methods normally use their THIS object’s constructor
to create a derived object. However, a subclass constructor may
over-ride that default behaviour by redefining its @@species property.

1.  2.  3.  

Properties of the Map Prototype Object

The value of the [[Prototype]] internal slot of the Map prototype object
is the intrinsic object %ObjectPrototype% (19.1.3). The Map prototype
object is an ordinary object. It does not have a [[MapData]] internal
slot.

Map.prototype.clear ( )

The following steps are taken:

1.  Let M be the THIS value.

2.  If Type(M) is not Object, throw a TYPEERROR exception.

3.  If M does not have a [[MapData]] internal slot throw a TYPEERROR
    exception.

4.  5.  Let entries be the List that is the value of M’s [[MapData]]
    internal slot.

6.  Repeat for each Record {[[key]], [[value]]} p that is an element
    of entries,

    a.  Set p.[[key]] to empty.

    b.  Set p.[[value]] to empty.

7.  Return UNDEFINED.

NOTE The existing [[MapData]] List is preserved because there may be
existing MapIterator objects that are suspended midway through iterating
over that List.

Map.prototype.constructor

The initial value of MAP.PROTOTYPE.CONSTRUCTOR is the intrinsic object
%Map%.

Map.prototype.delete ( key )

The following steps are taken:

1.  Let M be the THIS value.

2.  If Type(M) is not Object, throw a TYPEERROR exception.

3.  If M does not have a [[MapData]] internal slot throw a TYPEERROR
    exception.

4.  5.  Let entries be the List that is the value of M’s [[MapData]]
    internal slot.

6.  Repeat for each Record {[[key]], [[value]]} p that is an element
    of entries,

    a.  If p.[[key]] is not empty and SameValueZero(p.[[key]],
        key) is TRUE, then

        i.  Set p.[[key]] to empty.

        ii. Set p.[[value]] to empty.

        iii. Return TRUE.

7.  Return FALSE.

NOTE The value EMPTY is used as a specification device to indicate that
an entry has been deleted. Actual implementations may take other actions
such as physically removing the entry from internal data structures.

Map.prototype.entries ( )

The following steps are taken:

1.  Let M be the THIS value.

2.  Return CreateMapIterator(M, "KEY+VALUE").

Map.prototype.forEach ( callbackfn [ , thisArg ] )

NOTE callbackfn should be a function that accepts three arguments.
FOREACH calls callbackfn once for each key/value pair present in the
map object, in key insertion order. callbackfn is called only for keys
of the map which actually exist; it is not called for keys that have
been deleted from the map.

If a thisArg parameter is provided, it will be used as the THIS value
for each invocation of callbackfn. If it is not provided, UNDEFINED is
used instead.

callbackfn is called with three arguments: the value of the item, the
key of the item, and the Map object being traversed.

FOREACH does not directly mutate the object on which it is called but
the object may be mutated by the calls to callbackfn.

When the FOREACH method is called with one or two arguments, the
following steps are taken:

1.  Let M be the THIS value.

2.  If Type(M) is not Object, throw a TYPEERROR exception.

3.  If M does not have a [[MapData]] internal slot throw a TYPEERROR
    exception.

4.  5.  If IsCallable(callbackfn) is FALSE, throw a TYPEERROR
    exception.

6.  If thisArg was supplied, let T be thisArg; else let T be
    UNDEFINED.

7.  Let entries be the List that is the value of M’s [[MapData]]
    internal slot.

8.  Repeat for each Record {[[key]], [[value]]} e that is an element
    of entries, in original key insertion order

    a.  If e.[[key]] is not empty, then

        i.  Let funcResult be Call(callbackfn, T, «e.[[value]],
            e.[[key]], M»).

        ii. ReturnIfAbrupt(funcResult).

9.  Return UNDEFINED.

The LENGTH property of the FOREACH method is 1.

Map.prototype.get ( key )

The following steps are taken:

1.  Let M be the THIS value.

2.  If Type(M) is not Object, throw a TYPEERROR exception.

3.  If M does not have a [[MapData]] internal slot throw a TYPEERROR
    exception.

4.  5.  Let entries be the List that is the value of M’s [[MapData]]
    internal slot.

6.  Repeat for each Record {[[key]], [[value]]} p that is an element
    of entries,

    a.  If p.[[key]] is not empty and SameValueZero(p.[[key]],
        key) is TRUE, return p.[[value]].

7.  Return UNDEFINED.

Map.prototype.has ( key )

The following steps are taken:

1.  Let M be the THIS value.

2.  If Type(M) is not Object, throw a TYPEERROR exception.

3.  If M does not have a [[MapData]] internal slot throw a TYPEERROR
    exception.

4.  5.  Let entries be the List that is the value of M’s [[MapData]]
    internal slot.

6.  Repeat for each Record {[[key]], [[value]]} p that is an element
    of entries,

    a.  If p.[[key]] is not empty and SameValueZero(p.[[key]],
        key) is TRUE, return TRUE.

7.  Return FALSE.

Map.prototype.keys ( )

The following steps are taken:

1.  Let M be the THIS value.

2.  Return CreateMapIterator(M, "KEY").

Map.prototype.set ( key , value )

The following steps are taken:

1.  Let M be the THIS value.

2.  If Type(M) is not Object, throw a TYPEERROR exception.

3.  If M does not have a [[MapData]] internal slot throw a TYPEERROR
    exception.

4.  5.  Let entries be the List that is the value of M’s [[MapData]]
    internal slot.

6.  Repeat for each Record {[[key]], [[value]]} p that is an element
    of entries,

    a.  If p.[[key]] is not empty and SameValueZero(p.[[key]],
        key) is TRUE, then

        i.  Set p.[[value]] to value.

        ii. Return M.

7.  If key is −0, let key be +0.

8.  Let p be the Record {[[key]]: key, [[value]]: value}.

9.  Append p as the last element of entries.

10. Return M.

get Map.prototype.size

Map.prototype.size is an accessor property whose set accessor function
is UNDEFINED. Its get accessor function performs the following steps:

1.  Let M be the THIS value.

2.  If Type(M) is not Object, throw a TYPEERROR exception.

3.  If M does not have a [[MapData]] internal slot throw a TYPEERROR
    exception.

4.  5.  Let entries be the List that is the value of M’s [[MapData]]
    internal slot.

6.  Let count be 0.

7.  For each Record {[[key]], [[value]]} p that is an element of
    entries

    a.  If p.[[key]] is not empty,

    b.  set count to count+1.

8.  Return count.

Map.prototype.values ( )

The following steps are taken:

1.  Let M be the THIS value.

2.  Return CreateMapIterator abstract(M, "VALUE").

Map.prototype [ @@iterator ]( )

The initial value of the @@iterator property is the same function object
as the initial value of the ENTRIES property.

Map.prototype [ @@toStringTag ]

The initial value of the @@toStringTag property is the string value
"MAP".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Properties of Map Instances

Map instances are ordinary objects that inherit properties from the Map
prototype. Map instances also have a [[MapData]] internal slot.

Map Iterator Objects 

A Map Iterator is an object, that represents a specific iteration over
some specific Map instance object. There is not a named constructor for
Map Iterator objects. Instead, map iterator objects are created by
calling certain methods of Map instance objects.

CreateMapIterator Abstract Operation

Several methods of Map objects return Iterator objects. The abstract
operation CreateMapIterator with arguments map and kind is used to
create such iterator objects. It performs the following steps:

1.  If Type(map) is not Object, throw a TYPEERROR exception.

2.  If map does not have a [[MapData]] internal slot throw a TYPEERROR
    exception.

3.  4.  Let iterator be the result of
    ObjectCreate(%MapIteratorPrototype%, «‍[[Map]], [[MapNextIndex]],
    [[MapIterationKind]]»).

5.  Set iterator’s [[Map]] internal slot to map.

6.  Set iterator’s [[MapNextIndex]] internal slot to 0.

7.  Set iterator’s [[MapIterationKind]] internal slot to kind.

8.  Return iterator.

The %MapIteratorPrototype% Object

All Map Iterator Objects inherit properties from the
%MapIteratorPrototype% intrinsic object. The %MapIteratorPrototype%
intrinsic object is an ordinary object and its [[Prototype]] internal
slot is the %IteratorPrototype% intrinsic object (25.1.2). In addition,
%MapIteratorPrototype% has the following properties:

%MapIteratorPrototype%.next ( )

1.  Let O be the THIS value.

2.  If Type(O) is not Object, throw a TYPEERROR exception.

3.  If O does not have all of the internal slots of a Map Iterator
    Instance (23.1.5.3), throw a TYPEERROR exception.

4.  Let m be the value of the [[Map]] internal slot of O.

5.  Let index be the value of the [[MapNextIndex]] internal slot of
    O.

6.  Let itemKind be the value of the [[MapIterationKind]] internal
    slot of O.

7.  If m is UNDEFINED, return CreateIterResultObject(UNDEFINED, TRUE)

8.  Assert: m has a [[MapData]] internal slot.

9.  Let entries be the List that is the value of the [[MapData]]
    internal slot of m.

10. Repeat while index is less than the total number of elements of
    entries. The number of elements must be redetermined each time
    this method is evaluated.

    a.  Let e be the Record {[[key]], [[value]]} that is the value of
        entries_[_index].

    b.  Set index to index+1;

    c.  Set the [[MapNextIndex]] internal slot of O to index.

    d.  If e.[[key]] is not empty, then

        i.  If itemKind is "KEY", let result be e.[[key]].

        ii. Else if itemKind is "VALUE", let result be
            e.[[value]].

        iii. Else,

        iv. 1.  Assert: itemKind is "KEY+VALUE".

            2.  Let result be the result of performing ArrayCreate(2).

            3.  Assert: result is a new, well-formed Array object so
                the following operations will never fail.

            4.  Call CreateDataProperty(result, "0", e.[[key]]) .

            5.  Call CreateDataProperty(result, "1", e.[[value]]).

        v.  Return CreateIterResultObject(result, FALSE).

11. Set the [[Map]] internal slot of O to UNDEFINED.

12. 13. Return CreateIterResultObject(UNDEFINED, TRUE).

1.  

%MapIteratorPrototype% [ @@toStringTag ]

The initial value of the @@toStringTag property is the string value "MAP
ITERATOR".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Properties of Map Iterator Instances

Map Iterator instances are ordinary objects that inherit properties from
the %MapIteratorPrototype% intrinsic object. Map Iterator instances are
initially created with the internal slots described in Table 47.

Table 47 — Internal Slots of Map Iterator Instances

  ---------------------- ------------------------------------------------------------------------------------------------------------------------------------------------
  INTERNAL SLOT          DESCRIPTION
  [[Map]]                The Map object that is being iterated.
  [[MapNextIndex]]       The integer index of the next Map data element to be examined by this iterator.
  [[MapIterationKind]]   A string value that identifies what is to be returned for each element of the iteration. The possible values are: "KEY", "VALUE", "KEY+VALUE".
  ---------------------- ------------------------------------------------------------------------------------------------------------------------------------------------


Set Objects

Set objects are collections of ECMAScript language values. A distinct
value may only occur once as an element of a Set’s collection. Distinct
values are discriminated using the SameValueZero comparison algorithm.

Set objects must be implemented using either hash tables or other
mechanisms that, on average, provide access times that are sublinear on
the number of elements in the collection. The data structures used in
this Set objects specification is only intended to describe the required
observable semantics of Set objects. It is not intended to be a viable
implementation model.

The Set Constructor 

The Set constructor is the %Set% intrinsic object and the initial value
of the SET property of the global object. When called as a constructor
it creates and initializes a new Set object. SET is not intended to be
called as a function and will throw an exception when called in that
manner.

The SET constructor is designed to be subclassable. It may be used as
the value in an EXTENDS clause of a class definition. Subclass
constructors that intend to inherit the specified SET behaviour must
include a SUPER call to the SET constructor to create and initialize the
subclass instance with the internal state necessary to support the
SET.PROTOTYPE built-in methods.

Set ( [ iterable ] )

When the SET function is called with optional argument iterable the
following steps are taken:

1.  2.  3.  4.  If NewTarget is UNDEFINED, throw a TYPEERROR exception.

5.  Let set be OrdinaryCreateFromConstructor(NewTarget,
    "%SETPROTOTYPE%", «‍[[SetData]]» ).

6.  ReturnIfAbrupt(set).

7.  Set set’s [[SetData]] internal slot to a new empty List.

8.  If iterable is not present, let iterable be UNDEFINED.

9.  If iterable is either UNDEFINED or NULL, let iter be UNDEFINED.

10. Else,

    a.  b.  c.  Let adder be the result of Get(set, "ADD").

    d.  ReturnIfAbrupt(adder).

    e.  If IsCallable(adder) is FALSE, throw a TYPEERROR Exception.

    f.  Let iter be the result of GetIterator(iterable).

    g.  ReturnIfAbrupt(iter).

11. 12. 13. 14. If iter is UNDEFINED, return set.

15. Repeat

    a.  Let next be the result of IteratorStep(iter).

    b.  If next is an abrupt completion, return IteratorClose(iter,
        next).

    c.  If next.[[value]] is FALSE, return set.

    d.  Let nextValue be IteratorValue(next.[[value]]).

    e.  If nextValue is an abrupt completion, return
        IteratorClose(iter, nextValue).

    f.  Let status be Call(adder, set, «nextValue.[[value]]»).

    g.  If status is an abrupt completion, return
        IteratorClose(iter, status).

NOTE Using a method call for inserting values during initialization
enables subclasses to that redefine ADD to still make a super call to
the inherited constructor.

1.  2.  3.  

Properties of the Set Constructor

The value of the [[Prototype]] internal slot of the Set constructor is
the intrinsic object %FunctionPrototype% (19.2.3).

1.  2.  3.  

Besides the LENGTH property (whose value is 1), the Set constructor has
the following properties:

Set.prototype

The initial value of SET.PROTOTYPE is the intrinsic %SetPrototype%
object (23.2.3).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

get Set [ @@species ] 

SET[@@SPECIES] is an accessor property whose set accessor function is
UNDEFINED. Its get accessor function performs the following steps:

1.  Return THIS.

The value of the NAME property of this function is "GET
[SYMBOL.SPECIES]".

NOTE Set prototype methods normally use their THIS object’s constructor
to create a derived object. However, a subclass constructor may
over-ride that default behaviour by redefining its @@species property.

Properties of the Set Prototype Object

The value of the [[Prototype]] internal slot of the Set prototype object
is the intrinsic object %ObjectPrototype% (19.1.3). The Set prototype
object is an ordinary object. It does not have a [[SetData]] internal
slot.

Set.prototype.add ( value )

The following steps are taken:

1.  Let S be the THIS value.

2.  If Type(S) is not Object, throw a TYPEERROR exception.

3.  If S does not have a [[SetData]] internal slot throw a TYPEERROR
    exception.

4.  5.  Let entries be the List that is the value of S’s [[SetData]]
    internal slot.

6.  Repeat for each e that is an element of entries,

    a.  If e is not empty and SameValueZero(e, value) is TRUE,
        then

        i.  Return S.

7.  If value is −0, let value be +0.

8.  Append value as the last element of entries.

9.  Return S.

Set.prototype.clear ( )

The following steps are taken:

1.  Let S be THIS value.

2.  If Type(S) is not Object, throw a TYPEERROR exception.

3.  If S does not have a [[SetData]] internal slot throw a TYPEERROR
    exception.

4.  5.  Let entries be the List that is the value of S’s [[SetData]]
    internal slot.

6.  Repeat for each e that is an element of entries,

    a.  Replace the element of entries whose value is e with an
        element whose value is empty.

    b.  

7.  Return UNDEFINED.

Set.prototype.constructor

The initial value of SET.PROTOTYPE.CONSTRUCTOR is the intrinsic object
%Set%.

Set.prototype.delete ( value )

The following steps are taken:

1.  Let S be the THIS value.

2.  If Type(S) is not Object, throw a TYPEERROR exception.

3.  If S does not have a [[SetData]] internal slot throw a TYPEERROR
    exception.

4.  5.  Let entries be the List that is the value of S’s [[SetData]]
    internal slot.

6.  Repeat for each e that is an element of entries,

    a.  If e is not empty and SameValueZero(e, value) is TRUE,
        then

        i.  Replace the element of entries whose value is e with an
            element whose value is empty.

        ii. Return TRUE.

7.  Return FALSE.

NOTE The value EMPTY is used as a specification device to indicate that
an entry has been deleted. Actual implementations may take other actions
such as physically removing the entry from internal data structures.

Set.prototype.entries ( )

The following steps are taken:

1.  Let S be the THIS value.

2.  Return CreateSetIterator(S, "KEY+VALUE").

NOTE For iteration purposes, a Set appears similar to a Map where each
entry has the same value for its key and value.

Set.prototype.forEach ( callbackfn [ , thisArg ] )

NOTE callbackfn should be a function that accepts three arguments.
FOREACH calls callbackfn once for each value present in the set
object, in value insertion order. callbackfn is called only for values
of the Set which actually exist; it is not called for keys that have
been deleted from the set.

If a thisArg parameter is provided, it will be used as the THIS value
for each invocation of callbackfn. If it is not provided, UNDEFINED is
used instead.

callbackfn is called with three arguments: the first two arguments are
a value contained in the Set. The same value of passed for both
arguments. The Set object being traversed is passed as the third
argument.

The callbackfn is called with three arguments to be consistent with
the call back functions used by FOREACH methods for Map and Array. For
Sets, each item value is considered to be both the key and the value.

FOREACH does not directly mutate the object on which it is called but
the object may be mutated by the calls to callbackfn.

Each value is normally visited only once. However, a value will be
revisited if it is deleted after it has been visited and then re-added
before the to FOREACH call completes. Values that are deleted after the
call to FOREACH begins and before being visited are not visited unless
the value is added again before the to FOREACH call completes. New
values added, after the call to FOREACH begins are visited.

When the FOREACH method is called with one or two arguments, the
following steps are taken:

1.  Let S be the THIS value.

2.  If Type(S) is not Object, throw a TYPEERROR exception.

3.  If S does not have a [[SetData]] internal slot throw a TYPEERROR
    exception.

4.  5.  If IsCallable(callbackfn) is FALSE, throw a TYPEERROR
    exception.

6.  If thisArg was supplied, let T be thisArg; else let T be
    UNDEFINED.

7.  Let entries be the List that is the value of S’s [[SetData]]
    internal slot.

8.  Repeat for each e that is an element of entries, in original
    insertion order

    a.  If e is not empty, then

        i.  Let funcResult be Call(callbackfn, T, «e, e,
            S»).

        ii. ReturnIfAbrupt(funcResult).

9.  Return UNDEFINED.

The LENGTH property of the FOREACH method is 1.

Set.prototype.has ( value )

The following steps are taken:

1.  Let S be the THIS value.

2.  If Type(S) is not Object, throw a TYPEERROR exception.

3.  If S does not have a [[SetData]] internal slot throw a TYPEERROR
    exception.

4.  5.  Let entries be the List that is the value of S’s [[SetData]]
    internal slot.

6.  Repeat for each e that is an element of entries,

    a.  If e is not empty and SameValueZero(e, value) is TRUE,
        return TRUE.

7.  Return FALSE.

Set.prototype.keys ( )

The initial value of the KEYS property is the same function object as
the initial value of the VALUES property.

NOTE For iteration purposes, a Set appears similar to a Map where each
entry has the same value for its key and value.

get Set.prototype.size

SET.PROTOTYPE.SIZE is an accessor property whose set accessor function
is UNDEFINED. Its get accessor function performs the following steps:

1.  Let S be the THIS value.

2.  If Type(S) is not Object, throw a TYPEERROR exception.

3.  If S does not have a [[SetData]] internal slot throw a TYPEERROR
    exception.

4.  5.  Let entries be the List that is the value of S’s [[SetData]]
    internal slot.

6.  Let count be 0.

7.  For each e that is an element of entries

    a.  If e is not empty,

    b.  set count to count+1.

8.  Return count.

Set.prototype.values ( )

The following steps are taken:

1.  Let S be the THIS value.

2.  Return CreateSetIterator(S, "VALUE").

Set.prototype [ @@iterator ] ( )

The initial value of the @@iterator property is the same function object
as the initial value of the VALUES property.

Set.prototype [ @@toStringTag ]

The initial value of the @@toStringTag property is the string value
"SET".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Properties of Set Instances

Set instances are ordinary objects that inherit properties from the Set
prototype. After initialization by the Set constructor, Set instances
also have a [[SetData]] internal slot.

Set Iterator Objects

A Set Iterator is an ordinary object, with the structure defined below,
that represents a specific iteration over some specific Set instance
object. There is not a named constructor for Set Iterator objects.
Instead, set iterator objects are created by calling certain methods of
Set instance objects.

CreateSetIterator Abstract Operation

Several methods of Set objects return Iterator objects. The abstract
operation CreateSetIterator with arguments set and kind is used to
create such iterator objects. It performs the following steps:

1.  If Type(set) is not Object, throw a TYPEERROR exception.

2.  If set does not have a [[SetData]] internal slot throw a TYPEERROR
    exception.

3.  4.  Let iterator be the result of
    ObjectCreate(%SetIteratorPrototype%, «‍[[IteratedSet]],
    [[SetNextIndex]], [[SetIterationKind]]»).

5.  Set iterator’s [[IteratedSet]] internal slot to set.

6.  Set iterator’s [[SetNextIndex]] internal slot to 0.

7.  Set iterator’s [[SetIterationKind]] internal slot to kind.

8.  Return iterator.

The %SetIteratorPrototype% Object

All Set Iterator Objects inherit properties from the
%SetIteratorPrototype% intrinsic object. The %SetIteratorPrototype%
intrinsic object is an ordinary object and its [[Prototype]] internal
slot is the %IteratorPrototype% intrinsic object (25.1.2). In addition,
%SetIteratorPrototype% has the following properties:

%SetIteratorPrototype%.next ( )

1.  Let O be the THIS value.

2.  If Type(O) is not Object, throw a TYPEERROR exception.

3.  If O does not have all of the internal slots of a Set Iterator
    Instance (23.2.5.3), throw a TYPEERROR exception.

4.  Let s be the value of the [[IteratedSet]] internal slot of O.

5.  Let index be the value of the [[SetNextIndex]] internal slot of
    O.

6.  Let itemKind be the value of the [[SetIterationKind]] internal
    slot of O.

7.  If s is UNDEFINED, return CreateIterResultObject(UNDEFINED, TRUE).

8.  Assert: s has a [[SetData]] internal slot.

9.  Let entries be the List that is the value of the [[SetData]]
    internal slot of s.

10. Repeat while index is less than the total number of elements of
    entries. The number of elements must be redetermined each time
    this method is evaluated.

    a.  Let e be entries_[_index].

    b.  Set index to index+1;

    c.  Set the [[SetNextIndex]] internal slot of O to index.

    d.  If e is not empty, then

        i.  If itemKind is "KEY+VALUE", then

            1.  Let result be the result of performing ArrayCreate(2).

            2.  Assert: result is a new, well-formed Array object so
                the following operations will never fail.

            3.  Call CreateDataProperty(result, "0", e) .

            4.  Call CreateDataProperty(result, "1", e).

            5.  Return CreateIterResultObject(result, FALSE).

        ii. Return CreateIterResultObject(e, FALSE).

11. Set the [[IteratedSet]] internal slot of O to UNDEFINED.

12. 13. Return CreateIterResultObject(UNDEFINED, TRUE).

1.  

%SetIteratorPrototype% [ @@toStringTag ]

The initial value of the @@toStringTag property is the string value "SET
ITERATOR".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Properties of Set Iterator Instances

Set Iterator instances are ordinary objects that inherit properties from
the %SetIteratorPrototype% intrinsic object. Set Iterator instances are
initially created with the internal slots specified in Table 48.

Table 48 — Internal Slots of Set Iterator Instances

  ---------------------- -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  INTERNAL SLOT          DESCRIPTION
  [[IteratedSet]]        The Set object that is being iterated.
  [[SetNextIndex]]       The integer index of the next Set data element to be examined by this iterator
  [[SetIterationKind]]   A string value that identifies what is to be returned for each element of the iteration. The possible values are: "KEY", "VALUE", "KEY+VALUE". "KEY" and "VALUE" have the same meaning.
  ---------------------- -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


WeakMap Objects

WeakMap objects are collections of key/value pairs where the keys are
objects and values may be arbitrary ECMAScript language values. A
WeakMap may be queried to see if it contains an key/value pair with a
specific key, but no mechanisms is provided for enumerating the objects
it holds as keys. If an object that is being used as the key of a
WeakMap key/value pair is only reachable by following a chain of
references that start within that WeakMap, then that key/value pair is
inaccessible and is automatically removed from the WeakMap. WeakMap
implementations must detect and remove such key/value pairs and any
associated resources.

An implementation may impose an arbitrarily determined latency between
the time a key/value pair of a WeakMap becomes inaccessible and the time
when the key/value pair is removed from the WeakMap. If this latency was
observable to ECMAScript program, it would be a source of indeterminacy
that could impact program execution. For that reason, an ECMAScript
implementation must not provide any means to observe a key of a WeakMap
that does not require the observer to present the observed key.

WeakMap objects must be implemented using either hash tables or other
mechanisms that, on average, provide access times that are sublinear on
the number of key/value pairs in the collection. The data structure used
in this WeakMap objects specification are only intended to describe the
required observable semantics of WeakMap objects. It is not intended to
be a viable implementation model.

NOTE WeakMap and WeakSets are intended to provide mechanisms for
dynamically associating state with an object in a manner that does not
“leak” memory resources if, in the absence of the WeakMap or WeakSet,
the object otherwise became inaccessible and subject to resource
reclamation by the implementation’s garbage collection mechanisms.
Achieving this characteristic can be achieved by using an inverted
per-object mapping of weak map instances to keys. Alternatively each
weak map may internally store its key to value mappings but this
approach requires coordination between the WeakMap or WeakSet
implementation and the garbage collector. The following references
describe mechanism that may be useful to implementations of WeakMap and
WeakSets:

  Barry Hayes. 1997. Ephemerons: a new finalization mechanism. In
  _Proceedings of the 12th ACM SIGPLAN conference on Object-oriented
  programming, systems, languages, and applications (OOPSLA '97)_, A.
  Michael Berman (Ed.). ACM, New York, NY, USA, 176-183.
  http://doi.acm.org/10.1145/263698.263733.

  Alexandra Barros, Roberto Ierusalimschy, Eliminating Cycles in Weak
  Tables. Journal of Universal Computer Science - J.UCS , vol. 14, no.
  21, pp. 3481-3497, 2008.
  http://www.jucs.org/jucs_14_21/eliminating_cycles_in_weak

The WeakMap Constructor

The WeakMap constructor is the %WeakMap% intrinsic object and the
initial value of the WEAKMAP property of the global object. When called
as a constructor it creates and initializes a new WeakMap object.
WEAKMAP is not intended to be called as a function and will throw an
exception when called in that manner.

The WEAKMAP constructor is designed to be subclassable. It may be used
as the value in an EXTENDS clause of a class definition. Subclass
constructors that intend to inherit the specified WEAKMAP behaviour must
include a SUPER call to the WEAKMAP constructor to create and initialize
the subclass instance with the internal state necessary to support the
WEAKMAP.PROTOTYPE built-in methods.

WeakMap ( [ iterable ] )

When the WEAKMAP function is called with optional argument iterable
the following steps are taken:

1.  2.  3.  4.  If NewTarget is UNDEFINED, throw a TYPEERROR exception.

5.  Let map be OrdinaryCreateFromConstructor(NewTarget,
    "%WEAKMAPPROTOTYPE%", «‍[[WeakMapData]]» ).

6.  ReturnIfAbrupt(map).

7.  Set map’s [[WeakMapData]] internal slot to a new empty List.

8.  If iterable is not present, let iterable be UNDEFINED.

9.  If iterable is either UNDEFINED or NULL, let iter be UNDEFINED.

10. Else,

    a.  b.  c.  Let adder be the result of Get(map, "SET").

    d.  ReturnIfAbrupt(adder).

    e.  If IsCallable(adder) is FALSE, throw a TYPEERROR Exception.

    f.  Let iter be the result of GetIterator(iterable).

    g.  ReturnIfAbrupt(iter).

11. 12. 13. 14. If iter is UNDEFINED, return map.

15. Repeat

    a.  Let next be the result of IteratorStep(iter).

    b.  If next is an abrupt completion, return IteratorClose(iter,
        next).

    c.  If next.[[value]] is FALSE, return map.

    d.  Let nextItem be IteratorValue(nex_.[[value]]_t).

    e.  If nextItem is an abrupt completion, return
        IteratorClose(iter, nextItem).

    f.  If Type(nextItem.[[value]]) is not Object,

        i.  Let error be Completion{[[type]]: throw, [[value]]: a
            newly created TYPEERROR object, [[target]]:empty}.

        ii. Return IteratorClose(iter, error).

    g.  Let k be the result of Get(nextItem.[[value]], "0").

    h.  If k is an abrupt completion, return IteratorClose(iter,
        k).

    i.  Let v be the result of Get(nextItem.[[value]], "1").

    j.  If v is an abrupt completion, return IteratorClose(iter,
        v).

    k.  Let status be Call(adder, map, «k.[[value]],
        v.[[value]]»).

    l.  If status is an abrupt completion, return
        IteratorClose(iter, status).

NOTE If the parameter iterable is present, it is expected to be an
object that implements an @@iterator method that returns an iterator
object that produces a two element array-like object whose first element
is a value that will be used as a WeakMap key and whose second element
is the value to associate with that key.

1.  2.  3.  

Properties of the WeakMap Constructor

The value of the [[Prototype]] internal slot of the WeakMap constructor
is the intrinsic object %FunctionPrototype% (19.2.3).

1.  2.  3.  

Besides the LENGTH property (whose value is 1), the WeakMap constructor
has the following properties:

WeakMap.prototype

The initial value of WEAKMAP.PROTOTYPE is the WeakMap prototype object
(23.3.3).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Properties of the WeakMap Prototype Object

The value of the [[Prototype]] internal slot of the WeakMap prototype
object is the intrinsic object %ObjectPrototype% (19.1.3). The WeakMap
prototype object is an ordinary object. It does not have a
[[WeakMapData]] internal slot.

1.  2.  3.  4.  5.  6.  

WeakMap.prototype.constructor

The initial value of WEAKMAP.PROTOTYPE.CONSTRUCTOR is the intrinsic
object %WeakMap%.

WeakMap.prototype.delete ( key )

The following steps are taken:

1.  Let M be the THIS value.

2.  If Type(M) is not Object, throw a TYPEERROR exception.

3.  If M does not have a [[WeakMapData]] internal slot throw a
    TYPEERROR exception.

4.  Let entries be the List that is the value of M’s [[WeakMapData]]
    internal slot.

5.  6.  If Type(key) is not Object, return FALSE.

7.  Repeat for each Record {[[key]], [[value]]} p that is an element
    of entries,

    a.  If p.[[key]] is not empty and SameValue(p.[[key]], key) is
        TRUE, then

        i.  Set p.[[key]] to empty.

        ii. Set p.[[value]] to empty.

        iii. Return TRUE.

8.  Return FALSE.

NOTE The value EMPTY is used as a specification device to indicate that
an entry has been deleted. Actual implementations may take other actions
such as physically removing the entry from internal data structures.

WeakMap.prototype.get ( key )

The following steps are taken:

1.  Let M be the THIS value.

2.  If Type(M) is not Object, throw a TYPEERROR exception.

3.  If M does not have a [[WeakMapData]] internal slot throw a
    TYPEERROR exception.

4.  Let entries be the List that is the value of M’s [[WeakMapData]]
    internal slot.

5.  6.  If Type(key) is not Object, return UNDEFINED.

7.  Repeat for each Record {[[key]], [[value]]} p that is an element
    of entries,

    a.  If p.[[key]] is not empty and SameValue(p.[[key]], key) is
        TRUE, return p.[[value]].

8.  Return UNDEFINED.

WeakMap.prototype.has ( key )

The following steps are taken:

1.  Let M be the THIS value.

2.  If Type(M) is not Object, throw a TYPEERROR exception.

3.  If M does not have a [[WeakMapData]] internal slot throw a
    TYPEERROR exception.

4.  Let entries be the List that is the value of M’s [[WeakMapData]]
    internal slot.

5.  6.  If Type(key) is not Object, return FALSE.

7.  Repeat for each Record {[[key]], [[value]]} p that is an element
    of entries,

    a.  If p.[[key]] is not empty and SameValue(p.[[key]], key) is
        TRUE, return TRUE.

8.  Return FALSE.

WeakMap.prototype.set ( key , value )

The following steps are taken:

1.  Let M be the THIS value.

2.  If Type(M) is not Object, throw a TYPEERROR exception.

3.  If M does not have a [[WeakMapData]] internal slot throw a
    TYPEERROR exception.

4.  Let entries be the List that is the value of M’s [[WeakMapData]]
    internal slot.

5.  6.  If Type(key) is not Object, throw a TYPEERROR exception.

7.  Repeat for each Record {[[key]], [[value]]} p that is an element
    of entries,

    a.  If p.[[key]] is not empty and SameValue(p.[[key]], key) is
        TRUE, then

        i.  Set p.[[value]] to value.

        ii. Return M.

8.  Let p be the Record {[[key]]: key, [[value]]: value}.

9.  Append p as the last element of entries.

10. Return M.

WeakMap.prototype [ @@toStringTag ]

The initial value of the @@toStringTag property is the string value
"WEAKMAP".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Properties of WeakMap Instances

WeakMap instances are ordinary objects that inherit properties from the
WeakMap prototype. WeakMap instances also have a [[WeakMapData]]
internal slot.


WeakSet Objects

WeakSet objects are collections of objects. A distinct object may only
occur once as an element of a WeakSet’s collection. A WeakSet may be
queried to see if it contains a specific object, but no mechanisms is
provided for enumerating the objects it holds. If an object that is
contain by a WeakSet is only reachable by following a chain of
references that start within that WeakSet, then that object is
inaccessible and is automatically removed from the WeakSet. WeakSet
implementations must detect and remove such objects and any associated
resources.

An implementation may impose an arbitrarily determined latency between
the time an object contained in a WeakSet becomes inaccessible and the
time when the object is removed from the WeakSet. If this latency was
observable to ECMAScript program, it would be a source of indeterminacy
that could impact program execution. For that reason, an ECMAScript
implementation must not provide any means to determine if a WeakSet
contains a particular object that does not require the observer to
present the observed object.

WeakSet objects must be implemented using either hash tables or other
mechanisms that, on average, provide access times that are sublinear on
the number of elements in the collection. The data structure used in
this WeakSet objects specification is only intended to describe the
required observable semantics of WeakSet objects. It is not intended to
be a viable implementation model.

NOTE See the NOTE in 23.3.

The WeakSet Constructor

The WeakSet constructor is the %WeakSet% intrinsic object and the
initial value of the WEAKSET property of the global object. When called
as a constructor it creates and initializes a new WeakSet object.
WEAKSET is not intended to be called as a function and will throw an
exception when called in that manner.

The WEAKSET constructor is designed to be subclassable. It may be used
as the value in an EXTENDS clause of a class definition. Subclass
constructors that intend to inherit the specified WEAKSET behaviour must
include a SUPER call to the WEAKSET constructor to create and initialize
the subclass instance with the internal state necessary to support the
WEAKSET.PROTOTYPE built-in methods.

WeakSet ( [ iterable ] )

When the WEAKSET function is called with optional argument iterable
the following steps are taken:

1.  2.  3.  4.  If NewTarget is UNDEFINED, throw a TYPEERROR exception.

5.  Let set be OrdinaryCreateFromConstructor(NewTarget,
    "%WEAKSETPROTOTYPE%", «‍[[WeakSetData]]» ).

6.  ReturnIfAbrupt(set).

7.  Set set’s [[WeakSetData]] internal slot to a new empty List.

8.  If iterable is not present, let iterable be UNDEFINED.

9.  If iterable is either UNDEFINED or NULL, let iter be UNDEFINED.

10. Else,

    a.  b.  c.  Let adder be the result of Get(set, "ADD").

    d.  ReturnIfAbrupt(adder).

    e.  If IsCallable(adder) is FALSE, throw a TYPEERROR Exception.

    f.  Let iter be the result of GetIterator(iterable).

    g.  ReturnIfAbrupt(iter).

11. 12. 13. 14. If iter is UNDEFINED, return set.

15. Repeat

    a.  Let next be the result of IteratorStep(iter).

    b.  If next.[[value]] is an abrupt completion, return
        IteratorClose(iter, next).

    c.  If next is FALSE, return set.

    d.  Let nextValue be IteratorValue(next.[[value]]).

    e.  If nextValue is an abrupt completion, return
        IteratorClose(iter, nextValue).

    f.  Let status be Call(adder, set, «nextValue.[[value]]»).

    g.  If status is an abrupt completion, return
        IteratorClose(iter, status).

1.  2.  3.  

Properties of the WeakSet Constructor

The value of the [[Prototype]] internal slot of the WeakSet constructor
is the intrinsic object %FunctionPrototype% (19.2.3).

1.  2.  3.  

Besides the LENGTH property (whose value is 1), the WeakSet constructor
has the following properties:

WeakSet.prototype

The initial value of WEAKSET.PROTOTYPE is the intrinsic
%WeakSetPrototype% object (23.4.3).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Properties of the WeakSet Prototype Object

The value of the [[Prototype]] internal slot of the WeakSet prototype
object is the intrinsic object %ObjectPrototype% (19.1.3). The WeakSet
prototype object is an ordinary object. It does not have a
[[WeakSetData]] internal slot.

WeakSet.prototype.add ( value )

The following steps are taken:

1.  Let S be the THIS value.

2.  If Type(S) is not Object, throw a TYPEERROR exception.

3.  If S does not have a [[WeakSetData]] internal slot throw a
    TYPEERROR exception.

4.  5.  If Type(value) is not Object, throw a TYPEERROR exception.

6.  Let entries be the List that is the value of S’s [[WeakSetData]]
    internal slot.

7.  Repeat for each e that is an element of entries,

    a.  If e is not empty and SameValue(e, value) is TRUE, then

        i.  Return S.

8.  Append value as the last element of entries.

9.  Return S.

1.  2.  3.  4.  5.  6.  

WeakSet.prototype.constructor

The initial value of WEAKSET.PROTOTYPE.CONSTRUCTOR is the %WeakSet%
intrinsic object.

WeakSet.prototype.delete ( value )

The following steps are taken:

1.  Let S be the THIS value.

2.  If Type(S) is not Object, throw a TYPEERROR exception.

3.  If S does not have a [[WeakSetData]] internal slot throw a
    TYPEERROR exception.

4.  5.  If Type(value) is not Object, return FALSE.

6.  Let entries be the List that is the value of S’s [[WeakSetData]]
    internal slot.

7.  Repeat for each e that is an element of entries,

    a.  If e is not empty and SameValue(e, value) is TRUE, then

        i.  Replace the element of entries whose value is e with an
            element whose value is empty.

        ii. Return TRUE.

8.  Return FALSE.

NOTE The value EMPTY is used as a specification device to indicate that
an entry has been deleted. Actual implementations may take other actions
such as physically removing the entry from internal data structures.

WeakSet.prototype.has ( value )

The following steps are taken:

1.  Let S be the THIS value.

2.  If Type(S) is not Object, throw a TYPEERROR exception.

3.  If S does not have a [[WeakSetData]] internal slot throw a
    TYPEERROR exception.

4.  5.  Let entries be the List that is the value of S’s
    [[WeakSetData]] internal slot.

6.  If Type(value) is not Object, return FALSE.

7.  Repeat for each e that is an element of entries,

    a.  If e is not empty and SameValue(e, value), return TRUE.

8.  Return FALSE.

WeakSet.prototype [ @@toStringTag ]

The initial value of the @@toStringTag property is the string value
"WEAKSET".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Properties of WeakSet Instances

WeakSet instances are ordinary objects that inherit properties from the
WeakSet prototype. After initialization by the WeakSet constructor,
WeakSet instances also have a [[WeakSetData]] internal slot.



STRUCTURED DATA


ArrayBuffer Objects

Abstract Operations For ArrayBuffer Objects

AllocateArrayBuffer( constructor, byteLength )

The abstract operation AllocateArrayBuffer with arguments constructor
and byteLength is used to create an ArrayBuffer object. It performs
the following steps:

1.  Let obj be OrdinaryCreateFromConstructor(constructor,
    "%ARRAYBUFFERPROTOTYPE%", «‍[[ArrayBufferData]],
    [[ArrayBufferByteLength]]» ).

2.  ReturnIfAbrupt(obj).

3.  Assert: byteLength is a positive integer.

4.  Let block be CreateByteDataBlock(byteLength).

5.  ReturnIfAbrupt(block).

6.  Set obj’s [[ArrayBufferData]] internal slot to block.

7.  Set obj’s [[ArrayBufferByteLength]] internal slot to byteLength.

8.  9.  Return obj.

IsDetachedBuffer( arrayBuffer )

The abstract operation IsDetachedBuffer with argument arrayBuffer
performs the following steps:

1.  Assert: Type(arrayBuffer) is Object and it has [[ArrayBufferData]]
    internal slot.

2.  If arrayBuffer’s [[ArrayBufferData]] internal slot is NULL, return
    TRUE.

3.  Return FALSE.

DetachArrayBuffer( arrayBuffer )

The abstract operation DetachArrayBuffer with argument arrayBuffer
performs the following steps:

1.  Assert: Type(arrayBuffer) is Object and it has [[ArrayBufferData]]
    and [[ArrayBufferByteLength]] internal slots.

2.  Set arrayBuffer’s [[ArrayBufferData]] internal slot to NULL.

3.  Set arrayBuffer’s [[ArrayBufferByteLength]] internal slot to 0.

4.  Return NormalCompletion(NULL).

NOTE Detaching an ArrayBuffer instance disassociates the Data Block used
as its backing store from the instance and sets the byte length of the
buffer to 0. No operations defined by this specification uses the
DetachArrayBuffer abstract operation. However, an ECMAScript
implementation or host environment may define such operations.

1.  2.  3.  4.  5.  6.  7.  8.  

CloneArrayBuffer( srcBuffer, srcByteOffset [, cloneConstructor] )

The abstract operation CloneArrayBuffer takes two parameters, an
ArrayBuffer srcBuffer an integer srcByteOffset and optional
parameter cloneConstructor. It creates a new ArrayBuffer whose data is
a copy of srcBuffer’s data starting at srcByteOffset. This operation
performs the following steps:

1.  Assert: Type(srcBuffer) is Object and it has an
    [[ArrayBufferData]] internal slot.

2.  If cloneConstructor is not present, then

    a.  Let cloneConstructor be SpeciesConstructor(srcBuffer,
        %ArrayBuffer%).

    b.  ReturnIfAbrupt(cloneConstructor).

    c.  If IsDetachedBuffer(srcBuffer) is TRUE, throw a TYPEERROR
        exception.

3.  Else, assert IsConstructor(cloneConstructor) is TRUE.

4.  5.  6.  7.  8.  9.  10. 11. 12. 13. 14. 15. Let srcLength be the
    value of srcBuffer’s [[ArrayBufferByteLength]] internal slot.

16. Assert: srcByteOffset ≤ srcLength.

17. Let cloneLength be be srcLength – srcByteOffset.

18. Let srcBlock be the value of srcBuffer’s [[ArrayBufferData]]
    internal slot.

19. 20. Let targetBuffer be AllocateArrayBuffer(cloneConstructor,
    cloneLength).

21. ReturnIfAbrupt(targetBuffer).

22. If IsDetachedBuffer(srcBuffer) is TRUE, throw a TYPEERROR
    exception.

23. Let targetBlock be the value of targetBuffer’s
    [[ArrayBufferData]] internal slot.

24. Perform CopyDataBlockBytes(targetBlock, 0, srcBlock,
    srcByteOffset, cloneLength).

25. Return targetBuffer.

GetValueFromBuffer ( arrayBuffer, byteIndex, type, isLittleEndian )

The abstract operation GetValueFromBuffer takes four parameters, an
ArrayBuffer arrayBuffer, an integer byteIndex, a String type, and
optionally a Boolean isLittleEndian. This operation performs the
following steps:

1.  2.  Assert: IsDetachedBuffer(arrayBuffer) is FALSE.

3.  Assert: There are sufficient bytes in arrayBuffer starting at
    byteIndex to represent a value of type.

4.  Assert: byteIndex is a positive integer.

5.  Let block be arrayBuffer’s [[ArrayBufferData]] internal slot.

6.  7.  Let elementSize be the Number value of the Element Size value
    specified in Table 46 for Element Type type.

8.  Let rawValue be a List of elementSize containing, in order,
    the elementSize sequence of bytes starting with
    block_[_byteIndex].

9.  If isLittleEndian is not present, set isLittleEndian to either
    TRUE or FALSE. The choice is implementation dependent and should be
    the alternative that is most efficient for the implementation. An
    implementation must use the same value each time this step is
    executed and the same value must be used for the corresponding step
    in the SetValueInBuffer abstract operation.

10. If isLittleEndian is FALSE, reverse the order of the elements of
    rawValue.

11. If type is “Float32” , then

    a.  Let value be the byte elements of rawValue concatenated and
        interpreted as a little-endian bit string encoding of an IEEE
        754-2008 binary32 value.

    b.  If value is an IEEE 754-2008 binary32 NaN value, return the
        NAN Number value.

    c.  Return the Number value that corresponds to value.

12. If type is “Float64” , then

    a.  Let value be the byte elements of rawValue concatenated and
        interpreted as a little-endian bit string encoding of an IEEE
        754-2008 binary64 value.

    b.  If value is an IEEE 754-2008 binary64 NaN value, return the
        NAN Number value.

    c.  Return the Number value that corresponds to value.

13. If the first code unit of type is "U", then

    a.  Let intValue be the byte elements of rawValue concatenated
        and interpreted as a bit string encoding of an unsigned
        little-endian binary number.

14. Else

    a.  Let intValue be the byte elements of rawValue concatenated
        and interpreted as a bit string encoding of a binary
        little-endian 2’s complement number of bit length elementSize
        × 8.

15. Return the Number value that corresponds to intValue.

SetValueInBuffer ( arrayBuffer, byteIndex, type, value, isLittleEndian )

The abstract operation SetValueInBuffer takes five parameters, an
ArrayBuffer arrayBuffer, an integer byteIndex, a String type, a
Number value, and optionally a Boolean isLittleEndian. This
operation performs the following steps:

1.  2.  Assert: IsDetachedBuffer(arrayBuffer) is FALSE.

3.  Assert: There are sufficient bytes in arrayBuffer starting at
    byteIndex to represent a value of type.

4.  Assert: byteIndex is a positive integer.

5.  Assert: Type(value) is Number.

6.  Let block be arrayBuffer’s [[ArrayBufferData]] internal slot.

7.  Assert: block is not UNDEFINED.

8.  Let elementSize be the Number value of the Element Size specified
    in Table 46 for Element Type type.

9.  If isLittleEndian is not present, set isLittleEndian to either
    TRUE or FALSE. The choice is implementation dependent and should be
    the alternative that is most efficient for the implementation. An
    implementation must use the same value each time this step is
    executed and the same value must be used for the corresponding step
    in the GetValueFromBuffer abstract operation.

10. If type is “Float32” , then

    a.  Set rawValue to a List containing the 4 bytes that are the
        result of converting value to IEEE-754-2008 binary32 format
        using “Round to nearest, ties to even” rounding mode. If
        isLittleEndian is FALSE, the bytes are arranged in big endian
        order. Otherwise, the bytes are arranged in little endian order.
        If value is NAN, rawValue may be set to any implementation
        chosen non-signaling NaN encoding. An implementation must always
        choose the same non-signaling NaN encoding for a distinct
        Not-a-Number value.

11. Else, if type is “Float64” , then

    a.  Set rawValue to a List containing the 8 bytes that are the
        IEEE-754-2008 binary64 format encoding of value. If
        isLittleEndian is FALSE, the bytes are arranged in big endian
        order. Otherwise, the bytes are arranged in little endian order.
        If value is NAN, rawValue may be set to any implementation
        chosen non-signaling NaN encoding. An implementation must always
        choose the same non-signaling NaN encoding for a distinct
        Not-a-Number value.

12. Else,

    a.  Let n be the Number value of the Element Size specified in
        Table 46 for Element Type type.

    b.  Let convOp be the abstract operation named in the Conversion
        Operation column in Table 46 for Element Type type.

    c.  Let intValue be the result of calling convOp with value as
        its argument .

    d.  If intValue ≥ 0, then

        i.  Let rawBytes be a List containing the n-byte binary
            encoding of intValue. If isLittleEndian is FALSE, the
            bytes are ordered in big endian order. Otherwise, the bytes
            are ordered in little endian order.

        ii. 

    e.  Else,

        i.  Let rawBytes be a List containing the n-byte binary 2’s
            complement encoding of intValue. If isLittleEndian is
            FALSE, the bytes are ordered in big endian order. Otherwise,
            the bytes are ordered in little endian order.

        ii. 

13. Store the individual bytes of rawBytes into block, in order,
    starting at block_[_byteIndex].

14. Return NormalCompletion (UNDEFINED).

The ArrayBuffer Constructor

The ArrayBuffer constructor is the %ArrayBuffer% intrinsic object and
the initial value of the ARRAYBUFFER property of the global object. When
called as a constructor it creates and initializes a new ArrayBuffer
object. ARRAYBUFFER is not intended to be called as a function and will
throw an exception when called in that manner.

The ARRAYBUFFER constructor is designed to be subclassable. It may be
used as the value of an EXTENDS clause of a class definition. Subclass
constructors that intend to inherit the specified ARRAYBUFFER behaviour
must include a SUPER call to the ARRAYBUFFER constructor to create and
initialize subclass instances with the internal state necessary to
support the ARRAYBUFFER.PROTOTYPE built-in methods.

ArrayBuffer( length )

ArrayBuffer called with argument length performs the following steps:

1.  2.  If NewTarget is UNDEFINED,

3.  throw a TYPEERROR exception.

4.  Let numberLength be ToNumber(length).

5.  Let byteLength be ToLength(numberLength).

6.  ReturnIfAbrupt(byteLength).

7.  If SameValueZero(numberLength, byteLength) is FALSE, throw a
    RANGEERROR exception.

8.  a.  

9.  Return AllocateArrayBuffer(NewTarget, byteLength).

10. 

1.  2.  3.  

Properties of the ArrayBuffer Constructor

The value of the [[Prototype]] internal slot of the ArrayBuffer
constructor is the intrinsic object %FunctionPrototype% (19.2.3).

1.  

Besides its LENGTH property (whose value is 1), the ArrayBuffer
constructor has the following properties:

ArrayBuffer.isView ( arg )

The isView function takes one argument arg, and performs the following
steps are taken:

1.  If Type(arg) is not Object, return FALSE.

2.  If arg has a [[ViewedArrayBuffer]] internal slot, return TRUE.

3.  Return FALSE.

ArrayBuffer.prototype

The initial value of ArrayBuffer.prototype is the ArrayBuffer prototype
object (24.1.4).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

get ArrayBuffer [ @@species ] 

ARRAYBUFFER[@@SPECIES] is an accessor property whose set accessor
function is UNDEFINED. Its get accessor function performs the following
steps:

1.  Return THIS.

The value of the NAME property of this function is "GET
[SYMBOL.SPECIES]".

NOTE ArrayBuffer prototype methods normally use their THIS object’s
constructor to create a derived object. However, a subclass constructor
may over-ride that default behaviour by redefining its @@species
property.

1.  2.  

Properties of the ArrayBuffer Prototype Object

The value of the [[Prototype]] internal slot of the ArrayBuffer
prototype object is the intrinsic object %ObjectPrototype% (19.1.3). The
ArrayBuffer prototype object is an ordinary object. It does not have an
[[ArrayBufferData]] or [[ArrayBufferByteLength]] internal slot.

 get ArrayBuffer.prototype.byteLength

ARRAYBUFFER.PROTOTYPE.BYTELENGTH is an accessor property whose set
accessor function is UNDEFINED. Its get accessor function performs the
following steps:

1.  Let O be the THIS value.

2.  If Type(O) is not Object, throw a TYPEERROR exception.

3.  If O does not have an [[ArrayBufferData]] internal slot throw a
    TYPEERROR exception.

4.  5.  If IsDetachedBuffer(O) is TRUE, throw a TYPEERROR exception.

6.  Let length be the value of O’s [[ArrayBufferByteLength]]
    internal slot.

7.  Return length.

ArrayBuffer.prototype.constructor

The initial value of ArrayBuffer.prototype.constructor is the intrinsic
object %ArrayBuffer%.

ArrayBuffer.prototype.slice ( start , end )

The following steps are taken:

1.  Let O be the THIS value.

2.  If Type(O) is not Object, throw a TYPEERROR exception.

3.  If O does not have an [[ArrayBufferData]] internal slot throw a
    TYPEERROR exception.

4.  5.  If IsDetachedBuffer(O) is TRUE, throw a TYPEERROR exception.

6.  Let len be the value of O’s [[ArrayBufferByteLength]] internal
    slot.

7.  Let relativeStart be ToInteger(start).

8.  ReturnIfAbrupt(relativeStart).

9.  If relativeStart < 0, let first be max((len +
    relativeStart),0); else let first be min(relativeStart,
    len).

10. If end is UNDEFINED, let relativeEnd be len; else let
    relativeEnd be ToInteger(end).

11. ReturnIfAbrupt(relativeEnd).

12. If relativeEnd < 0, let final be max((len + relativeEnd),0);
    else let final be min(relativeEnd, len).

13. Let newLen be max(final_-_first,0).

14. Let ctor be SpeciesConstructor(O, %ArrayBuffer%).

15. ReturnIfAbrupt(ctor).

16. 17. Let new be Construct(ctor, «newLen»).

18. ReturnIfAbrupt(new).

19. If new does not have an [[ArrayBufferData]] internal slot throw a
    TYPEERROR exception.

20. 21. If IsDetachedBuffer(new) is TRUE, throw a TYPEERROR exception.

22. If SameValue(new, O) is TRUE, throw a TYPEERROR exception.

23. If the value of new’s [[ArrayBufferByteLength]] internal slot <
    newLen, throw a TYPEERROR exception.

24. NOTE: Side-effects of the above steps may have detached O.

25. If IsDetachedBuffer(O) is TRUE, throw a TYPEERROR exception.

26. Let fromBuf be the value of O’s [[ArrayBufferData]] internal
    slot.

27. Let toBuf be the value of new’s [[ArrayBufferData]] internal
    slot.

28. Perform CopyDataBlockBytes(toBuf, 0, fromBuf, first,
    newLen).

29. Return new.

ArrayBuffer.prototype [ @@toStringTag ]

The initial value of the @@toStringTag property is the string value
"ARRAYBUFFER".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Properties of the ArrayBuffer Instances

ArrayBuffer instances inherit properties from the ArrayBuffer prototype
object. ArrayBuffer instances each have an [[ArrayBufferData]] internal
slot and an [[ArrayBufferByteLength]] internal slot.

ArrayBuffer instances whose [[ArrayBufferData]] is NULL are considered
to be detached and all operators to access or modify data contained in
the ArrayBuffer instance will fail.


DataView Objects

Abstract Operations For DataView Objects

GetViewValue ( view, requestIndex, isLittleEndian, type )

The abstract operation GetViewValue with arguments view,
requestIndex, isLittleEndian, and type is used by functions on
DataView instances is to retrieve values from the view’s buffer. It
performs the following steps:

1.  If Type(view) is not Object, throw a TYPEERROR exception.

2.  If view does not have a [[DataView]] internal slot, throw a
    TYPEERROR exception.

3.  4.  5.  Let numberIndex be ToNumber(requestIndex)

6.  Let getIndex be ToInteger(numberIndex).

7.  ReturnIfAbrupt(getIndex).

8.  If numberIndex ≠ getIndex or getIndex < 0, throw a RANGEERROR
    exception.

9.  Let isLittleEndian be ToBoolean(isLittleEndian).

10. 11. Let buffer be the value of view’s [[ViewedArrayBuffer]]
    internal slot.

12. 13. If IsDetachedBuffer(buffer) is TRUE, throw a TYPEERROR
    exception.

14. Let viewOffset be the value of view’s [[ByteOffset]] internal
    slot.

15. Let viewSize be the value of view’s [[ByteLength]] internal
    slot.

16. Let elementSize be the Number value of the Element Size value
    specified in Table 46 for Element Type type.

17. If getIndex +elementSize > viewSize, throw a RANGEERROR
    exception.

18. Let bufferIndex be getIndex + viewOffset.

19. Return GetValueFromBuffer(buffer, bufferIndex, type,
    isLittleEndian).

SetViewValue ( view, requestIndex, isLittleEndian, type, value )

The abstract operation SetViewValue with arguments view,
requestIndex, isLittleEndian, type, and value is used by
functions on DataView instances to store values into the view’s buffer.
It performs the following steps:

1.  If Type(view) is not Object, throw a TYPEERROR exception.

2.  If view does not have a [[DataView]] internal slot, throw a
    TYPEERROR exception.

3.  4.  5.  Let numberIndex be ToNumber(requestIndex)

6.  Let getIndex be ToInteger(numberIndex).

7.  ReturnIfAbrupt(getIndex).

8.  If numberIndex ≠ getIndex or getIndex < 0, throw a RANGEERROR
    exception.

9.  Let isLittleEndian be ToBoolean(isLittleEndian).

10. 11. Let buffer be the value of view’s [[ViewedArrayBuffer]]
    internal slot.

12. 13. If IsDetachedBuffer(buffer) is TRUE, throw a TYPEERROR
    exception.

14. Let viewOffset be the value of view’s [[ByteOffset]] internal
    slot.

15. Let viewSize be the value of view’s [[ByteLength]] internal
    slot.

16. Let elementSize be the Number value of the Element Size value
    specified in Table 46 for Element Type type.

17. If getIndex +elementSize > viewSize, throw a RANGEERROR
    exception.

18. Let bufferIndex be getIndex + viewOffset.

19. Return SetValueInBuffer(buffer, bufferIndex, type, value,
    isLittleEndian).

NOTE The algorithms for GetViewValue and SetViewValue are identical
except for their final steps.

The DataView Constructor

The DataView constructor is the %DataView% intrinsic object and the
initial value of the DATAVIEW property of the global object. When called
as a constructor it creates and initializes a new DataView object.
DATAVIEW is not intended to be called as a function and will throw an
exception when called in that manner.

The DATAVIEW constructor is designed to be subclassable. It may be used
as the value of an EXTENDS clause of a class definition. Subclass
constructors that intend to inherit the specified DATAVIEW behaviour
must include a SUPER call to the DATAVIEW constructor to create and
initialize subclass instances with the internal state necessary to
support the DATAVIEW.PROTOTYPE built-in methods.

DataView (buffer [ , byteOffset [ , byteLength ] ] )

DATAVIEW called with arguments buffer, byteOffset, and length
performs the following steps:

1.  2.  If NewTarget is UNDEFINED, throw a TYPEERROR exception.

3.  4.  5.  a.  

6.  If Type(buffer) is not Object, throw a TYPEERROR exception.

7.  If buffer does not have an [[ArrayBufferData]] internal slot,
    throw a TYPEERROR exception.

8.  9.  Let numberOffset be ToNumber(byteOffset).

10. Let offset be ToInteger(numberOffset).

11. ReturnIfAbrupt(offset).

12. If numberOffset ≠ offset or offset < 0, throw a RANGEERROR
    exception.

13. If IsDetachedBuffer(buffer) is TRUE, throw a TYPEERROR exception.

14. Let bufferByteLength be the value of buffer’s
    [[ArrayBufferByteLength]] internal slot.

15. If offset > bufferByteLength, throw a RANGEERROR exception.

16. If byteLength is UNDEFINED, then

    a.  Let viewByteLength be bufferByteLength – offset.

17. Else,

    a.  Let numberLength be ToNumber(byteLength).

    b.  Let viewLength be ToInteger (numberLength).

    c.  ReturnIfAbrupt(viewLength).

    d.  If numberLength ≠ viewLength or viewLength < 0, throw a
        RANGEERROR exception.

    e.  Let viewByteLength be viewLength.

    f.  If offset_+_viewByteLength > bufferByteLength, throw a
        RANGEERROR exception.

18. 19. Let O be OrdinaryCreateFromConstructor(NewTarget,
    "%DATAVIEWPROTOTYPE%", «‍[[DataView]], [[ViewedArrayBuffer]],
    [[ByteLength]], [[ByteOffset]]» ).

20. ReturnIfAbrupt(O).

21. Set O’s [[DataView]] internal slot to TRUE.

22. Set O’s [[ViewedArrayBuffer]] internal slot to buffer.

23. Set O’s [[ByteLength]] internal slot to viewByteLength.

24. Set O’s [[ByteOffset]] internal slot to offset.

25. Return O.

1.  2.  3.  

Properties of the DataView Constructor

The value of the [[Prototype]] internal slot of the DATAVIEW constructor
is the intrinsic object %FunctionPrototype% (19.2.3).

1.  2.  3.  

Besides the LENGTH property (whose value is 3), the DataView constructor
has the following properties:

DataView.prototype

The initial value of DATAVIEW.PROTOTYPE is the DataView prototype object
(24.2.4).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

1.  2.  3.  4.  

Properties of the DataView Prototype Object

The value of the [[Prototype]] internal slot of the DataView prototype
object is the intrinsic object %ObjectPrototype% (19.1.3). The DataView
prototype object is an ordinary object. It does not have a [[DataView]],
[[ViewedArrayBuffer]], [[ByteLength]], or [[ByteOffset]] internal slot.

get DataView.prototype.buffer

DATAVIEW.PROTOTYPE.BUFFER is an accessor property whose set accessor
function is UNDEFINED. Its get accessor function performs the following
steps:

1.  Let O be the THIS value.

2.  If Type(O) is not Object, throw a TYPEERROR exception.

3.  If O does not have a [[ViewedArrayBuffer]] internal slot throw a
    TYPEERROR exception.

4.  Let buffer be the value of O’s [[ViewedArrayBuffer]] internal
    slot.

5.  6.  Return buffer.

get DataView.prototype.byteLength

DATAVIEW.PROTOTYPE.BYTELENGTH is an accessor property whose set accessor
function is UNDEFINED. Its get accessor function performs the following
steps:

1.  Let O be the THIS value.

2.  If Type(O) is not Object, throw a TYPEERROR exception.

3.  If O does not have a [[ViewedArrayBuffer]] internal slot throw a
    TYPEERROR exception.

4.  Let buffer be the value of O’s [[ViewedArrayBuffer]] internal
    slot.

5.  6.  If IsDetachedBuffer(buffer) is TRUE, throw a TYPEERROR
    exception.

7.  Let size be the value of O’s [[ByteLength]] internal slot.

8.  Return size.

get DataView.prototype.byteOffset

DATAVIEW.PROTOTYPE.BYTEOFFSET is an accessor property whose set accessor
function is UNDEFINED. Its get accessor function performs the following
steps:

1.  Let O be the THIS value.

2.  If Type(O) is not Object, throw a TYPEERROR exception.

3.  If O does not have a [[ViewedArrayBuffer]] internal slot throw a
    TYPEERROR exception.

4.  Let buffer be the value of O’s [[ViewedArrayBuffer]] internal
    slot.

5.  6.  If IsDetachedBuffer(buffer) is TRUE, throw a TYPEERROR
    exception.

7.  Let offset be the value of O’s [[ByteOffset]] internal slot.

8.  Return offset.

DataView.prototype.constructor

The initial value of DATAVIEW.PROTOTYPE.CONSTRUCTOR is the intrinsic
object %DataView%.

DataView.prototype.getFloat32 ( byteOffset [ , littleEndian ] )

When the GETFLOAT32 method is called with argument byteOffset and
optional argument littleEndian the following steps are taken:

1.  Let v be the THIS value.

2.  3.  If littleEndian is not present, let littleEndian be FALSE.

4.  Return the result of GetViewValue(v, byteOffset, littleEndian,
    "FLOAT32").

DataView.prototype.getFloat64 ( byteOffset [ , littleEndian ] )

When the GETFLOAT64 method is called with argument byteOffset and
optional argument littleEndian the following steps are taken:

1.  Let v be the THIS value.

2.  If littleEndian is not present, let littleEndian be FALSE.

3.  Return the result of GetViewValue(v, byteOffset, littleEndian,
    "FLOAT64").

DataView.prototype.getInt8 ( byteOffset )

When the GETINT8 method is called with argument byteOffset the
following steps are taken:

1.  Let v be the THIS value.

2.  Return the result of GetViewValue(v, byteOffset, TRUE, "INT8").

DataView.prototype.getInt16 ( byteOffset [ , littleEndian ] )

When the GETINT16 method is called with argument byteOffset and
optional argument littleEndian the following steps are taken:

1.  Let v be the THIS value.

2.  If littleEndian is not present, let littleEndian be FALSE.

3.  Return the result of GetViewValue(v, byteOffset, littleEndian,
    "INT16").

DataView.prototype.getInt32 ( byteOffset [ , littleEndian ] )

When the GETINT32 method is called with argument byteOffset and
optional argument littleEndian the following steps are taken:

1.  Let v be the THIS value.

2.  If littleEndian is not present, let littleEndian be UNDEFINED.

3.  Return the result of GetViewValue(v, byteOffset, littleEndian,
    "INT32").

DataView.prototype.getUint8 ( byteOffset )

When the GETUINT8 method is called with argument byteOffset the
following steps are taken:

1.  Let v be the THIS value.

2.  3.  Return the result of GetViewValue(v, byteOffset, TRUE,
    "UINT8").

DataView.prototype.getUint16 ( byteOffset [ , littleEndian ] )

When the GETUINT16 method is called with argument byteOffset and
optional argument littleEndian the following steps are taken:

1.  Let v be the THIS value.

2.  If littleEndian is not present, let littleEndian be FALSE.

3.  Return the result of GetViewValue(v, byteOffset, littleEndian,
    "UINT16").

DataView.prototype.getUint32 ( byteOffset [ , littleEndian ] )

When the GETUINT32 method is called with argument byteOffset and
optional argument littleEndian the following steps are taken:

1.  Let v be the THIS value.

2.  If littleEndian is not present, let littleEndian be FALSE.

3.  Return the result of GetViewValue(v, byteOffset, littleEndian,
    "UINT32").

DataView.prototype.setFloat32 ( byteOffset, value [ , littleEndian ] )

When the SETFLOAT32 method is called with arguments byteOffset and
value and optional argument littleEndian the following steps are
taken:

1.  Let v be the THIS value.

2.  If littleEndian is not present, let littleEndian be FALSE.

3.  Return the result of SetViewValue(v, byteOffset, littleEndian,
    "FLOAT32", value).

DataView.prototype.setFloat64 ( byteOffset, value [ , littleEndian ] )

When the SETFLOAT64 method is called with arguments byteOffset and
value and optional argument littleEndian the following steps are
taken:

1.  Let v be the THIS value.

2.  If littleEndian is not present, let littleEndian be FALSE.

3.  Return the result of SetViewValue(v, byteOffset, littleEndian,
    "FLOAT64", value).

DataView.prototype.setInt8 ( byteOffset, value )

When the SETINT8 method is called with arguments byteOffset and
value the following steps are taken:

1.  Let v be the THIS value.

2.  Return the result of SetViewValue(v, byteOffset, TRUE, "INT8",
    value).

DataView.prototype.setInt16 ( byteOffset, value [ , littleEndian ] )

When the SETINT16 method is called with arguments byteOffset and
value and optional argument littleEndian the following steps are
taken:

1.  Let v be the THIS value.

2.  If littleEndian is not present, let littleEndian be FALSE.

3.  Return the result of SetViewValue(v, byteOffset, littleEndian,
    "INT16", value).

DataView.prototype.setInt32 ( byteOffset, value [ , littleEndian ] )

When the SETINT32 method is called with arguments byteOffset and
value and optional argument littleEndian the following steps are
taken:

1.  Let v be the THIS value.

2.  If littleEndian is not present, let littleEndian be FALSE.

3.  Return the result of SetViewValue(v, byteOffset, littleEndian,
    "INT32", value).

DataView.prototype.setUint8 ( byteOffset, value )

When the SETUINT8 method is called with arguments byteOffset and
value the following steps are taken:

1.  Let v be the THIS value.

2.  Return the result of SetViewValue(v, byteOffset, TRUE, "UINT8",
    value).

DataView.prototype.setUint16 ( byteOffset, value [ , littleEndian ] )

When the SETUINT16 method is called with arguments byteOffset and
value and optional argument littleEndian the following steps are
taken:

1.  Let v be the THIS value.

2.  If littleEndian is not present, let littleEndian be FALSE.

3.  Return the result of SetViewValue(v, byteOffset, littleEndian,
    "UINT16", value).

DataView.prototype.setUint32 ( byteOffset, value [ , littleEndian ] )

When the SETUINT32 method is called with arguments byteOffset and
value and optional argument littleEndian the following steps are
taken:

1.  Let v be the THIS value.

2.  If littleEndian is not present, let littleEndian be FALSE.

3.  Return the result of SetViewValue(v, byteOffset, littleEndian,
    "UINT32", value).

DataView.prototype[ @@toStringTag ]

The initial value of the @@toStringTag property is the string value
"DATAVIEW".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Properties of DataView Instances

DataView instances are ordinary objects that inherit properties from the
DataView prototype object. DataView instances each have a [[DataView]],
[[ViewedArrayBuffer]], [[ByteLength]], and [[ByteOffset]] internal
slots.

NOTE The value of the [[DataView]] internal slot is not used within this
specification. The simple presence of that internal slot is used within
the specification to identify objects created using the DATAVIEW
constructor.


The JSON Object

The JSON object is a single ordinary object that contains two functions,
PARSE and STRINGIFY, that are used to parse and construct JSON texts.
The JSON Data Interchange Format is defined in ECMA-404. The JSON
interchange format used in this specification is exactly that described
by ECMA-404.

Conforming implementations of JSON.PARSE and JSON.STRINGIFY must support
the exact interchange format described in this specification without any
deletions or extensions to the format.

The value of the [[Prototype]] internal slot of the JSON object is the
intrinsic object %ObjectPrototype% (19.1.3). The value of the
[[Extensible]] internal slot of the JSON object is set to TRUE.

The JSON object does not have a [[Construct]] internal method; it is not
possible to use the JSON object as a constructor with the NEW operator.

The JSON object does not have a [[Call]] internal method; it is not
possible to invoke the JSON object as a function.

JSON.parse ( text [ , reviver ] )

The PARSE function parses a JSON text (a JSON-formatted String) and
produces an ECMAScript value. The JSON format is a subset of the syntax
for ECMAScript literals, Array Initializers and Object Initializers.
After parsing, JSON objects are realized as ECMAScript objects. JSON
arrays are realized as ECMAScript Array instances. JSON strings,
numbers, booleans, and null are realized as ECMAScript Strings, Numbers,
Booleans, and NULL.

The optional reviver parameter is a function that takes two
parameters, key and value. It can filter and transform the results.
It is called with each of the key_/_value pairs produced by the parse,
and its return value is used instead of the original value. If it
returns what it received, the structure is not modified. If it returns
UNDEFINED then the property is deleted from the result.

1.  Let JText be ToString(text).

2.  ReturnIfAbrupt(JText).

3.  Parse JText interpreted as UTF-16 encoded Unicode points (6.1.4)
    as a JSON text as specified in
    ECMA-404. Throw a SYNTAXERROR exception if JText is not a valid
    JSON text as defined in that specification.

4.  5.  Let scriptText be the result of concatenating "(", JText,
    and ");".

6.  Let completion be the result of parsing and evaluating
    scriptText as if it was the source text of an ECMAScript Script.
    but using the alternative definition of DoubleStringCharacter
    provided below. The extended PropertyDefinitionEvaluation semantics
    defined in B.3.1 must not be used during the evaluation.

7.  8.  Let unfiltered be completion.[[value]].

9.  Assert: unfiltered will be either a primitive value or an object
    that is defined by either an ArrayLiteral or an ObjectLiteral.

10. If IsCallable(reviver) is TRUE, then

    a.  Let root be ObjectCreate(%ObjectPrototype%).

    b.  Let rootName be the empty String.

    c.  Let status be CreateDataProperty(root, rootName,
        unfiltered).

    d.  Assert: status is TRUE.

    e.  Return Walk(root, rootName).

11. Else

    a.  Return unfiltered.

JSON allows Unicode code points U+2028 and U+2029 to directly appear in
String literals without using an escape sequence. This is enabled by
using the following alternative definition of DoubleStringCharacter
when parsing scriptText in step 5:

DoubleStringCharacter ::

SourceCharacter BUT NOT ONE OF " OR \ OR U+0000 THROUGH U+001F

\ EscapeSequence

-   The SV of DoubleStringCharacter :: SourceCharacter BUT NOT ONE
    OF " OR \ OR U+0000 THROUGH U+001F is the UTF-16Encoding (10.1.1) of
    the code point value of SourceCharacter.

NOTE The syntax of a valid JSON text is a subset of the ECMAScript
PrimaryExpression syntax. Hence a valid JSON text is also a valid
PrimaryExpression. Step 3 above verifies that JText conforms to that
subset. When scriptText is parsed and evaluated as a Script the
result will be either a String, Number, Boolean, or Null primitive value
or an Object defined as if by an ArrayLiteral or ObjectLiteral.

Runtime Semantics: Walk Abstract Operation

The abstract operation Walk is a recursive abstract operation that takes
two parameters: a holder object and the String name of a property in
that object. Walk uses the value of reviver that was originally passed
to the above parse function.

1.  Let val be Get(holder, name).

2.  ReturnIfAbrupt(val).

3.  If Type(val) is Object, then

    a.  b.  c.  If IsArray(val) is TRUE, then

        i.  Set I to 0.

        ii. Let len be the result of ToLength(Get(val, "LENGTH")).

        iii. ReturnIfAbrupt(len).

        iv. Repeat while I < len,

        v.  1.  Let newElement be Walk(val, ToString(I)).

            2.  ReturnIfAbrupt(newElement).

            3.  If newElement is UNDEFINED, then

                a.  Let status be the result of calling the [[Delete]]
                    internal method of val with ToString(I) as the
                    argument.

                b.  

            4.  Else

                a.  Let status be CreateDataProperty(val,
                    ToString(I), newElement).

                b.  NOTE This algorithm intentionally does not throw an
                    exception if status is FALSE.

            5.  ReturnIfAbrupt(status).

            6.  Add 1 to I.

    d.  Else

        i.  Let keys be EnumerableOwnNames(val).

        ii. ReturnIfAbrupt(keys).

        iii. For each String P in keys do,

        iv. 1.  Let newElement be Walk(val, P).

            2.  3.  ReturnIfAbrupt(newElement).

            4.  If newElement is UNDEFINED, then

                a.  Let status be the result of calling the [[Delete]]
                    internal method of val with P as the argument.

                b.  

            5.  Else

                a.  Let status be CreateDataProperty(val, P,
                    newElement).

                b.  NOTE This algorithm intentionally does not throw an
                    exception if status is FALSE.

            6.  ReturnIfAbrupt(status).

4.  Return Call(reviver, holder, «name, val»).

It is not permitted for a conforming implementation of JSON.PARSE to
extend the JSON grammars. If an implementation wishes to support a
modified or extended JSON interchange format it must do so by defining a
different parse function.

NOTE In the case where there are duplicate name Strings within an
object, lexically preceding values for the same key shall be
overwritten.

JSON.stringify ( value [ , replacer [ , space ] ] )

The STRINGIFY function returns a String in UTF-16 encoded JSON format
representing an ECMAScript value. It can take three parameters. The
value parameter is an ECMAScript value, which is usually an object or
array, although it can also be a String, Boolean, Number or NULL. The
optional replacer parameter is either a function that alters the way
objects and arrays are stringified, or an array of Strings and Numbers
that acts as a white list for selecting the object properties that will
be stringified. The optional space parameter is a String or Number
that allows the result to have white space injected into it to improve
human readability.

These are the steps in stringifying an object:

1.  Let stack be an empty List.

2.  Let indent be the empty String.

3.  Let PropertyList and ReplacerFunction be UNDEFINED.

4.  5.  6.  If Type(replacer) is Object, then

    a.  If IsCallable(replacer) is TRUE, then

        i.  Let ReplacerFunction be replacer.

    b.  Else if IsArray(replacer) is TRUE, then

        i.  Let PropertyList be an empty List

        ii. Let len be ToLength(Get(replacer, "LENGTH")).

        iii. iv. ReturnIfAbrupt(len).

        v.  Let k be 0.

        vi. Repeat while k_<_len.

        vii. 1.  Let v be Get(replacer, ToString(k)).

            2.  ReturnIfAbrupt(v).

            3.  Let item be UNDEFINED.

            4.  If Type(v) is String, let item be v.

            5.  Else if Type(v) is Number, let item be
                ToString(v).

            6.  Else if Type(v) is Object, then

                a.  If v has a [[StringData]] or [[NumberData]]
                    internal slot, let item be ToString(v).

                b.  ReturnIfAbrupt(item).

            7.  If item is not UNDEFINED and item is not currently
                an element of PropertyList, then

                a.  Append item to the end of PropertyList.

            8.  Let k be k+1.

7.  If Type(space) is Object, then

    a.  If space has a [[NumberData]] internal slot, then

        i.  Let space be ToNumber(space).

        ii. ReturnIfAbrupt(space).

    b.  Else if space has a [[StringData]] internal slot, then

        i.  Let space be ToString(space).

        ii. ReturnIfAbrupt(space).

8.  If Type(space) is Number, then

    a.  Let space be min(10, ToInteger(space)).

    b.  Set gap to a String containing space occurrences of code
        unit 0x0020 (SPACE). This will be the empty String if space is
        less than 1.

9.  Else if Type(space) is String, then

    a.  If the number of elements in space is 10 or less, set gap to
        space otherwise set gap to a String consisting of the first
        10 elements of space.

10. Else

    a.  Set gap to the empty String.

11. Let wrapper be ObjectCreate(%ObjectPrototype%).

12. Let status be CreateDataProperty(wrapper, the empty String,
    value).

13. Assert: status is TRUE.

14. Return Str(the empty String, wrapper).

NOTE 1 JSON structures are allowed to be nested to any depth, but they
must be acyclic. If value is or contains a cyclic structure, then the
stringify function must throw a TYPEERROR exception. This is an example
of a value that cannot be stringified:

  a = [];

  a[0] = a;

  my_text = JSON.stringify(a); // This must throw a TypeError.

NOTE 2 Symbolic primitive values are rendered as follows:

-   The NULL value is rendered in JSON text as the String NULL.

-   The UNDEFINED value is not rendered.

-   The TRUE value is rendered in JSON text as the String TRUE.

-   The FALSE value is rendered in JSON text as the String FALSE.

NOTE 3 String values are wrapped in QUOTATION MARK (") code units. The
code units " and \ are escaped with \ prefixes. Control characters code
units are replaced with escape sequences \UHHHH, or with the shorter
forms, \B (backspace), \F (form feed), \N (LINE FEED), \R (carriage
return), \T (CHARACTER TABULATION).

NOTE 4 Finite numbers are stringified as if by calling
ToString(number). NAN and Infinity regardless of sign are represented
as the String NULL.

NOTE 5 Values that do not have a JSON representation (such as UNDEFINED
and functions) do not produce a String. Instead they produce the
UNDEFINED value. In arrays these values are represented as the String
NULL. In objects an unrepresentable value causes the property to be
excluded from stringification.

NOTE 6 An object is rendered as an left CURLY BRACKET followed by zero
or more properties, separated with a COMMA, closed with a right CURLY
BRACKET. A property is a quoted String representing the key or property
name, a colon, and then the stringified property value. An array is
rendered as an opening left square bracket followed by zero or more
values, separated with a COMMA, closed with a right square bracket.

Runtime Semantics: Str Abstract Operation

The abstract operation Str(key, holder) has access to
ReplacerFunction from the invocation of the STRINGIFY method. Its
algorithm is as follows:

1.  Let value be Get(holder, key).

2.  ReturnIfAbrupt(value).

3.  If Type(value) is Object, then

    a.  Let toJSON be Get(value, "TOJSON").

    b.  ReturnIfAbrupt(toJSON).

    c.  If IsCallable(toJSON) is TRUE

        i.  Let value be Call(toJSON, value, «key»).

        ii. ReturnIfAbrupt(value).

4.  If ReplacerFunction is not UNDEFINED, then

    a.  Let value be Call(ReplacerFunction, holder, «key,
        value»).

    b.  ReturnIfAbrupt(value).

5.  If Type(value) is Object, then

    a.  If value has a [[NumberData]] internal slot, then

        i.  Let value be ToNumber(value).

        ii. ReturnIfAbrupt(value).

    b.  Else if value has a [[StringData]] internal slot, then

        i.  Let value be ToString(value).

        ii. ReturnIfAbrupt(value).

    c.  Else if value has a [[BooleanData]] internal slot, then

        i.  Let value be the value of the [[BooleanData]] internal
            slot of value.

        ii. 

6.  If value is NULL, return "NULL".

7.  If value is TRUE, return "TRUE".

8.  If value is FALSE, return "FALSE".

9.  If Type(value) is String, return Quote(value).

10. If Type(value) is Number, then

    a.  If value is finite, return ToString(value).

    b.  Else, return "NULL".

11. If Type(value) is Object, and IsCallable(value) is FALSE, then

    a.  b.  c.  If IsArray(value) is TRUE, then

        i.  Return JA(value).

    d.  Else, return JO(value).

12. Return UNDEFINED.

Runtime Semantics: Quote Abstract Operation

The abstract operation Quote(value) wraps a String value in QUOTATION
MARK code units and escapes certain other code units within it.

1.  Let product be code unit U+0022 (QUOTATION MARK).

2.  For each code unit C in value

    a.  If C is U+0022 (quOTATion mark) or U+005C (reverse solidus)

        i.  Let product be the concatenation of product and code
            unit U+005C (reverse solidus).

        ii. Let product be the concatenation of product and C.

    b.  Else if C is u+0008 (backspace), U+000C (form feed), u+000A
        (LINE FEED), U+000D (carriage return), or U+000B (LINE
        TABULATION)

        i.  Let product be the concatenation of product and code
            unit U+005C (reverse solidus).

        ii. Let abbrev be the string value corresponding to the value
            of C as follows:

  backspace "B"

  form feed (FF) "F"

  LINE FEED (LF) "N"

  carriage return (CR) "R"

  LINE TABULATION "T"

i.  Let product be the concatenation of product and abbrev.

a.  Else if C has a code unit value less than U+0020 (SPACE)

    i.  Let product be the concatenation of product and code unit
        U+005C (reverse solidus).

    ii. Let product be the concatenation of product and "U".

    iii. Let hex be the string result of converting the numeric code
        unit value of C to a String of four hexadecimal digits.
        Alphabetic hexadecimal digits are presented as lowercase Latin
        letters.

    iv. v.  Let product be the concatenation of product and hex.

b.  Else

    i.  Let product be the concatenation of product and C.

1.  Let product be the concatenation of product and code unit U+0022
    (QUOTATION MARK).

2.  Return product.

Runtime Semantics: JO Abstract Operation

The abstract operation JO(value) serializes an object. It has access
to the stack, indent, gap, and PropertyList of the invocation of
the STRINGIFY method.

1.  If stack contains value, throw a TYPEERROR exception because the
    structure is cyclical.

2.  Append value to stack.

3.  Let stepback be indent.

4.  Let indent be the concatenation of indent and gap.

5.  If PropertyList is not UNDEFINED, then

    a.  Let K be PropertyList.

6.  Else,

    a.  Let K be EnumerableOwnNames(value).

7.  Let partial be an empty List.

8.  For each element P of K,

    a.  Let strP be Str(P, value).

    b.  ReturnIfAbrupt(strP).

    c.  If strP is not UNDEFINED, then

        i.  Let member be Quote(P).

        ii. Let member be the concatenation of member and the string
            ":".

        iii. If gap is not the empty String, then

            1.  Let member be the concatenation of member and code
                unit U+020 (SPACE).

        iv. Let member be the concatenation of member and strP.

        v.  Append member to partial.

9.  If partial is empty, then

    a.  Let final be "{}".

10. Else,

    a.  If gap is the empty String

        i.  Let properties be a String formed by concatenating all the
            element Strings of partial with each adjacent pair of
            Strings separated with code unit U+002C (comma). A comma is
            not inserted either before the first String or after the
            last String.

        ii. iii. Let final be the result of concatenating "{",
            properties, and "}".

    b.  Else gap is not the empty String

        i.  Let separator be the result of concatenating code unit
            U+002C (comma), code unit U+000A (line feed), and indent.

        ii. Let properties be a String formed by concatenating all the
            element Strings of partial with each adjacent pair of
            Strings separated with separator. The separator String
            is not inserted either before the first String or after the
            last String.

        iii. Let final be the result of concatenating "{", code unit
            U+000A (line feed), indent, properties, code unit
            U+000A, stepback, and "}".

11. Remove the last element of stack.

12. Let indent be stepback.

13. Return final.

Runtime Semantics: JA Abstract Operation

The abstract operation JA(value) serializes an array. It has access to
the stack, indent, and gap of the invocation of the stringify
method. The representation of arrays includes only the elements between
zero and ARRAY.LENGTH – 1 inclusive. Properties whose keys are not array
indexes are excluded from the stringification. An array is stringified
as an opening left square bracket code point, elements separated by
comma, and a closing right square bracket.

1.  If stack contains value, throw a TYPEERROR exception because the
    structure is cyclical.

2.  Append value to stack.

3.  Let stepback be indent.

4.  Let indent be the concatenation of indent and gap.

5.  Let partial be an empty List.

6.  7.  Let len be ToLength(Get(value, "LENGTH")).

8.  9.  ReturnIfAbrupt(len).

10. Let index be 0.

11. Repeat while index < len

    a.  Let strP be Str(ToString(index), value).

    b.  c.  ReturnIfAbrupt(strP).

    d.  If strP is UNDEFINED, then

        i.  Append "NULL" to partial.

    e.  Else,

        i.  Append strP to partial.

    f.  Increment index by 1.

12. If partial is empty, then

    a.  Let final be "[]".

13. Else,

    a.  If gap is the empty String, then

        i.  Let properties be a String formed by concatenating all the
            element Strings of partial with each adjacent pair of
            Strings separated with code unit U+002C (comma). A comma is
            not inserted either before the first String or after the
            last String.

        ii. iii. Let final be the result of concatenating "[",
            properties, and "]".

    b.  Else,

        i.  Let separator be the result of concatenating code unit
            U+002C (comma), code unit U+000A (line feed), and indent.

        ii. Let properties be a String formed by concatenating all the
            element Strings of partial with each adjacent pair of
            Strings separated with separator. The separator String
            is not inserted either before the first String or after the
            last String.

        iii. Let final be the result of concatenating "[", code unit
            U+000A (line feed), indent, properties, code unit
            U+000A, stepback, and "]".

14. Remove the last element of stack.

15. Let indent be stepback.

16. Return final.

JSON [ @@toStringTag ]

The initial value of the @@toStringTag property is the string value
"JSON".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.



CONTROL ABSTRACTION OBJECTS


Iteration

Common Iteration Interfaces

An interface is a set of property keys whose associated values match a
specific specification. Any object that provides all the properties as
described by an interface’s specification conforms to that interface.
An interface is not represented by an distinct object. There may be many
separately implemented objects that conform to any interface. An
individual object may conform to multiple interfaces.

The Iterable Interface

The Iterable interface includes the following property:

  PROPERTY     VALUE                                               REQUIREMENTS
  ------------ --------------------------------------------------- ---------------------------------------------------------------------------
  @@ITERATOR   A zero arguments function that returns an object.   The function returns an object that conforms to the iterator interface.

The Iterator Interface

The Iterator interface includes the following properties:

  PROPERTY   VALUE                                REQUIREMENTS
  ---------- ------------------------------------ --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  NEXT       A function that returns an object.   The function returns an object that conforms to the IteratorResult interface. If a previous call to the NEXT method of an Iterator has returned an IteratorResult object whose DONE property is TRUE, then all subsequent calls to the NEXT method of that object must also return an IteratorResult object whose DONE property is TRUE,

NOTE Arguments may be passed to the next function but their
interpretation and validity is dependent upon the target Iterator. The
for-of statement and other common users of Iterators do not pass any
arguments, so Iterators that expect to be used in such a manner must be
prepared to deal with being called with no arguments.

The IteratorResult Interface

The IteratorResult interface includes the following properties:

  PROPERTY   VALUE                            REQUIREMENTS
  ---------- -------------------------------- ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  DONE       Either TRUE or FALSE.            This is the result status of an iterator NEXT method call. If the end of the iterator was reached DONE is TRUE. If the end was not reached DONE is FALSE and a value is available. If a DONE property (either own or inherited does not exist), it is consider to have the value FALSE.
  VALUE      Any ECMAScript language value.   If done is FALSE, this is the current iteration element value. If done is TRUE, this is the return value of the iterator, if it supplied one. If the iterator does not have a return value, VALUE is UNDEFINED. In that case, the VALUE property may be absent from the conforming object if it does not inherit an explicit VALUE property.

The %IteratorPrototype% Object

The value of the [[Prototype]] internal slot of the %IteratorPrototype%
object is the intrinsic object %ObjectPrototype% (19.1.3). The
%IteratorPrototype% object is an ordinary object. The initial value of
the [[Extensible]] internal slot of the %IteratorPrototype% object is
TRUE.

NOTE All objects defined in this specification that implement the
Iterator interface also inherit from %IteratorPrototype%. ECMAScript
code may also define objects that inherit from %IteratorPrototype%. The
%IteratorPrototype% object provides a place where additional methods
that are applicable to all iterator objects may be added.

The following expression is one way that ECMAScript code can access the
%IteratorPrototype% object:

Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()))

%IteratorPrototype% [ @@iterator ] ( )

The following steps are taken:

1.  Return the THIS value.

The value of the NAME property of this function is "[SYMBOL.ITERATOR]".


GeneratorFunction Objects

Generator Function objects are constructor functions that are usually
created by evaluating GeneratorDeclaration, GeneratorExpression, and
GeneratorMethod syntactic productions. They may also be created by
calling the %GeneratorFunction% intrinsic.

  --
  --

Figure 2 (Informative) — Generator Objects Relationships

The GeneratorFunction Constructor

The GENERATORFUNCTION constructor is the %GeneratorFunction% intrinsic.
When GENERATORFUNCTION is called as a function rather than as a
constructor, it creates and initializes a new GeneratorFunction object.
Thus the function call GENERATORFUNCTION (…) is equivalent to the object
creation expression NEW GENERATORFUNCTION (…) with the same arguments.

GENERATORFUNCTION is designed to be subclassable. It may be used as the
value of an EXTENDS clause of a class definition. Subclass constructors
that intend to inherit the specified GENERATORFUNCTION behaviour must
include a SUPER call to the GENERATORFUNCTION constructor to create and
initialize subclass instances with the internal slots necessary for
built-in GeneratorFunction behaviour. All ECMAScript syntactic forms for
defining generator function objects create direct instances of
GENERATORFUNCTION. There is no syntactic means to create instances of
GENERATORFUNCTION subclasses.

GeneratorFunction (p1, p2, … , pn, body)

The last argument specifies the body (executable code) of a generator
function; any preceding arguments specify formal parameters.

When the GENERATORFUNCTION function is called with some arguments p1,
p2, … , pn, body (where n might be 0, that is, there are no
“p” arguments, and where body might also not be provided), the
following steps are taken:

1.  Let C be the active function object.

2.  Let args be the argumentsList that was passed to this function
    by [[Call]] or [[Construct]].

3.  Return CreateDynamicFunction(C, NewTarget, "GENERATOR", args).

1.  2.  3.  4.  5.  a.  b.  c.  d.  e.  i.  ii. iii. iv. v.  

    f.  

6.  7.  8.  9.  10. 11. 12. 13. 14. 15. a.  b.  c.  d.  e.  

16. 17. 18. 19. 20. 21. 22. 23. 24. 25. 26. 27. 28. a.  

29. 30. 31. 32. 33. a.  b.  

34. 

NOTE See NOTE for 19.2.1.1.

1.  2.  3.  

Properties of the GeneratorFunction Constructor

The GENERATORFUNCTION constructor is a standard built-in function object
that inherits from the FUNCTION constructor. The value of the
[[Prototype]] internal slot of the GENERATORFUNCTION constructor is the
intrinsic object %Function%.

The value of the [[Extensible]] internal slot of the GeneratorFunction
constructor is TRUE.

1.  2.  3.  

The value of the NAME property of the GeneratorFunction is
"GENERATORFUNCTION".

The GENERATORFUNCTION constructor has the following properties:

 GeneratorFunction.length

This is a data property with a value of 1. This property has the
attributes { [[Writable]]: FALSE, [[Enumerable]]: FALSE,
[[Configurable]]: TRUE }.

GeneratorFunction.prototype

The initial value of GENERATORFUNCTION.PROTOTYPE is the intrinsic object
%Generator%.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

1.  2.  3.  4.  5.  

Properties of the GeneratorFunction Prototype Object

The GeneratorFunction prototype object is an ordinary object. It is not
a function object and does not have an [[ECMAScriptCode]] internal slot
or any other of the internal slots listed in Table 28 or Table 49. In
addition to being the value of the prototype property of the
%GeneratorFunction% intrinsic and is itself the %Generator% intrinsic.

The value of the [[Prototype]] internal slot of the GeneratorFunction
prototype object is the %FunctionPrototype% intrinsic object. The
initial value of the [[Extensible]] internal slot of the
GeneratorFunction prototype object is TRUE.

GeneratorFunction.prototype.constructor

The initial value of GENERATORFUNCTION.PROTOTYPE.CONSTRUCTOR is the
intrinsic object %GeneratorFunction%.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

GeneratorFunction.prototype.prototype

The value of GENERATORFUNCTION.PROTOTYPE.PROTOTYPE is the
%GeneratorPrototype% intrinsic object.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

 GeneratorFunction.prototype [ @@toStringTag ]

The initial value of the @@toStringTag property is the string value
"GENERATORFUNCTION".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

1.  2.  3.  

GeneratorFunction Instances

Every GeneratorFunction instance is an ECMAScript function object and
has the internal slots listed in Table 28. The value of the
[[FunctionKind]] internal slot for all such instances is "GENERATOR".

1.  

Each GeneratorFunction instance has the following own properties:

length

The value of the LENGTH property is an integer that indicates the
typical number of arguments expected by the GeneratorFunction. However,
the language permits the function to be invoked with some other number
of arguments. The behaviour of a GeneratorFunction when invoked on a
number of arguments other than the number specified by its LENGTH
property depends on the function.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

prototype

Whenever a GeneratorFunction instance is created another ordinary object
is also created and is the initial value of the generator function’s
PROTOTYPE property. The value of the prototype property is used to
initialize the [[Prototype]] internal slot of a newly created Generator
object before the generator function object is invoked as a constructor
for that newly created object.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

NOTE Unlike function instances, the object that is the value of the a
GeneratorFunction’s PROTOTYPE property does not have a CONSTRUCTOR
property whose value is the GeneratorFunction instance.


Generator Objects

A Generator object is an instance of a generator function and conforms
to both the Iterator and Iterable interfaces.

Generator instances directly inherit properties from the object that is
the value of the PROTOTYPE property of the Generator function that
created the instance. Generator instances indirectly inherit properties
from the Generator Prototype intrinsic, %GeneratorPrototype%.

Properties of Generator Prototype

The Generator prototype object is the %GeneratorPrototype% intrinsic. It
is also the initial value of the PROTOTYPE property of the %Generator%
intrinsic (the GeneratorFunction.prototype).

The Generator prototype is an ordinary object. It is not a Generator
instance and does not have a [[GeneratorState]] internal slot.

The value of the [[Prototype]] internal slot of the Generator prototype
object is the intrinsic object %IteratorPrototype% (25.1.2). The initial
value of the [[Extensible]] internal slot of the Function prototype
object is TRUE.

All Generator instances indirectly inherit properties of the Generator
prototype object.

Generator.prototype.constructor

The initial value of GENERATOR.PROTOTYPE.CONSTRUCTOR is the intrinsic
object %Generator%.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

 Generator.prototype.next ( value )

The NEXT method performs the following steps:

1.  Let g be the THIS value.

2.  Return the result of GeneratorResume(g, value).

Generator.prototype.return ( value )

The RETURN method performs the following steps:

1.  Let g be the THIS value.

2.  Let C be Completion{[[type]]: return, [[value]]: value,
    [[target]]: empty}.

3.  Return GeneratorResumeAbrupt(g, C).

Generator.prototype.throw ( exception )

The THROW method performs the following steps:

1.  Let g be the THIS value.

2.  3.  4.  5.  6.  Let C be Completion{[[type]]: throw, [[value]]:
    exception, [[target]]: empty}.

7.  8.  9.  a.  b.  c.  

10. 11. 12. 13. 14. 15. 16. 17. Return GeneratorResumeAbrupt(g, C).

1.  

Generator.prototype [ @@toStringTag ]

The initial value of the @@toStringTag property is the string value
"GENERATOR".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Properties of Generator Instances

Generator instances are initially created with the internal slots
described in Table 49.

Table 49 — Internal Slots of Generator Instances

  ---------------------- -----------------------------------------------------------------------------------------------------------------------------------------------------
  INTERNAL SLOT          DESCRIPTION
  [[GeneratorState]]     The current execution state of the generator. The possible values are: UNDEFINED, "SUSPENDEDSTART", "SUSPENDEDYIELD", "EXECUTING", and "COMPLETED".
  [[GeneratorContext]]   The execution context that is used when executing the code of this generator.
  ---------------------- -----------------------------------------------------------------------------------------------------------------------------------------------------

Generator Abstract Operations

 GeneratorStart (generator, generatorBody)

The abstract operation GeneratorStart with arguments generator and
generatorBody performs the following steps:

1.  Assert: The value of generator’s [[GeneratorState]] internal slot
    is UNDEFINED.

2.  Let genContext be the running execution context.

3.  Set the Generator component of genContext to generator.

4.  Set the code evaluation state of genContext such that when
    evaluation is resumed for that execution context the following steps
    will be performed:

    1.  Let result be the result of evaluating generatorBody.

    2.  Assert: If we return here, the generator either threw an
        exception or performed either an implicit or explicit return.

    3.  Remove genContext from the execution context stack and restore
        the execution context that is at the top of the execution
        context stack as the running execution context.

    4.  Set generator’s [[GeneratorState]] internal slot to
        "COMPLETED".

    5.  Once a generator enters the "COMPLETED" state it never leaves it
        and its associated execution context is never resumed. Any
        execution state associated with generator can be discarded at
        this point.

    6.  If result is a normal completion, let resultValue be
        UNDEFINED.

    7.  Else.

        a.  If result.[[type]] is return, let resultValue be
            result.[[value].

        b.  Else, return result.

    8.  Return CreateIterResultObject(resultValue, TRUE).

5.  Set generator’s [[GeneratorContext]] internal slot to
    genContext.

6.  Set generator’s [[GeneratorState]] internal slot to
    "SUSPENDEDSTART".

7.  Return NormalCompletion(generator).

 GeneratorValidate ( generator )

The abstract operation GeneratorValidate with argument generator
performs the following steps:

1.  If Type(generator) is not Object, throw a TYPEERROR exception.

2.  If generator does not have a [[GeneratorState]] internal slot,
    throw a TYPEERROR exception.

3.  Assert: generator also has a [[GeneratorContext]] internal slot.

4.  Let state be the value of generator’s [[GeneratorState]]
    internal slot.

5.  If state is "EXECUTING", throw a TYPEERROR exception.

6.  Return state.

GeneratorResume ( generator, value )

The abstract operation GeneratorResume with arguments generator and
value performs the following steps:

1.  2.  3.  Let state be GeneratorValidate(generator).

4.  ReturnIfAbrupt(state).

5.  If state is "COMPLETED", return CreateIterResultObject(UNDEFINED,
    TRUE).

6.  Assert: state is either "SUSPENDEDSTART" or "SUSPENDEDYIELD".

7.  Let genContext be the value of generator’s [[GeneratorContext]]
    internal slot.

8.  Let methodContext be the running execution context.

9.  Suspend methodContext.

10. Set generator’s [[GeneratorState]] internal slot to "EXECUTING".

11. Push genContext onto the execution context stack; genContext is
    now the running execution context.

12. Resume the suspended evaluation of genContext using
    NormalCompletion(value) as the result of the operation that
    suspended it. Let result be the value returned by the resumed
    computation.

13. 14. Assert: When we return here, genContext has already been
    removed from the execution context stack and methodContext is the
    currently running execution context.

15. Return result.

GeneratorResumeAbrupt(generator, abruptCompletion)

The abstract operation GeneratorResumeAbrupt with arguments generator
and abruptCompletion performs the following steps:

1.  2.  3.  Let state be GeneratorValidate(generator).

4.  ReturnIfAbrupt(state).

5.  If state is "SUSPENDEDSTART", then

6.  a.  Set generator’s [[GeneratorState]] internal slot to
        "COMPLETED".

    b.  Once a generator enters the "COMPLETED" state it never leaves it
        and its associated execution context is never resumed. Any
        execution state associated with generator can be discarded at
        this point.

    c.  Let state be "COMPLETED".

7.  8.  If state is "COMPLETED", then

    a.  If abruptCompletion.[[type]] is return, then

        i.  Return CreateIterResultObject(abruptCompletion.[[value]],
            TRUE).

    b.  Return abruptCompletion.

9.  Assert: state is "SUSPENDEDYIELD".

10. a.  b.  c.  

11. Let genContext be the value of generator’s [[GeneratorContext]]
    internal slot.

12. Let methodContext be the running execution context.

13. Suspend methodContext.

14. Set generator’s [[GeneratorState]] internal slot to "EXECUTING".

15. Push genContext onto the execution context stack; genContext is
    now the running execution context.

16. Resume the suspended evaluation of genContext using
    abruptCompletion as the result of the operation that suspended it.
    Let result be the value returned by the resumed computation.

17. 18. Assert: When we return here, genContext has already been
    removed from the execution context stack and methodContext is the
    currently running execution context.

19. Return result.

GeneratorYield ( iterNextObj )

The abstract operation GeneratorYield with argument iterNextObj
performs the following steps:

1.  Assert: iterNextObj is an Object that implements the
    IteratorResult interface.

2.  Let genContext be the running execution context.

3.  Assert: genContext is the execution context of a generator.

4.  Let generator be the value of the Generator component of
    genContext.

5.  Set the value of generator’s [[GeneratorState]] internal slot to
    "SUSPENDEDYIELD".

6.  Remove genContext from the execution context stack and restore the
    execution context that is at the top of the execution context stack
    as the running execution context.

7.  Set the code evaluation state of genContext such that when
    evaluation is resumed with a Completion resumptionValue the
    following steps will be performed:

    1.  Return resumptionValue.

    2.  NOTE: This returns to the evaluation of the YieldExpression
        production that originally called this abstract operation.

8.  Return NormalCompletion(iterNextObj).

9.  NOTE: This returns to the evaluation of the operation that had most
    previously resumed evaluation of genContext.


Promise Objects

A Promise is an object that is used as a placeholder for the eventual
results of a deferred (and possibly asynchronous) computation.

Any Promise object is in one of three mutually exclusive states:
fulfilled, rejected, and pending:

-   A promise P is fulfilled if P.THEN(F, R) will immediately enqueue a
    Job to call the function F.

-   A promise P is rejected if P.THEN(F, R) will immediately enqueue a
    Job to call the function R.

-   A promise is pending if it is neither fulfilled nor rejected.

A promise is said to be settled if it is not pending, i.e. if it is
either fulfilled or rejected.

A promise is resolved if it is settled or if it has been "locked in"
to match the state of another promise. Attempting to resolve or reject a
resolved promise has no effect. A promise is unresolved if it is not
resolved. An unresolved promise is always in the pending state. A
resolved promise may be pending, fulfilled or rejected.

Promise Abstract Operations

PromiseCapability Records

A PromiseCapability is a Record value used to encapsulate a promise
object along with the functions that are capable of resolving or
rejecting that promise object. PromiseCapability records are produced by
the NewPromiseCapability abstract operation.

PromiseCapability Records have the fields listed in Table 50.

Table 50 — PromiseCapability Record Fields

  -------------- ------------------- ----------------------------------------------------------------
  _FIELD NAME_   VALUE             MEANING
  [[Promise]]    An object           An object that is usable as a promise.
  [[Resolve]]    A function object   The function that is used to resolve the given promise object.
  [[Reject]]     A function object   The function that is used to reject the given promise object.
  -------------- ------------------- ----------------------------------------------------------------

IfAbruptRejectPromise ( value, capability )

IfAbruptRejectPromise is a short hand for a sequence of algorithm steps
that use a PromiseCapability record. An algorithm step of the form:

1.  IfAbruptRejectPromise(value, capability).

means the same thing as:

1.  If value is an abrupt completion,

2.  a.  Let rejectResult be Call(capability.[[Reject]], UNDEFINED,
        «value.[[value]]»).

    b.  ReturnIfAbrupt(rejectResult).

    c.  Return capability.[[Promise]].

3.  Else if value is a Completion Record, let value be
    value.[[value]].

PromiseReaction Records

The PromiseReaction is a Record value used to store information about
how a promise should react when it becomes resolved or rejected with a
given value. PromiseReaction records are created by the THEN method of
the Promise prototype, and are used by a PromiseReactionJob.

PromiseReaction records have the fields listed in Table 51.

Table 51 — PromiseReaction Record Fields

  ------------------ ------------------------------- ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  _FIELD NAME_       VALUE                         MEANING
  [[Capabilities]]   A PromiseCapability record      The capabilities of the promise for which this record provides a reaction handler.
  [[Handler]]        A function object or a String   The function that should be applied to the incoming value, and whose return value will govern what happens to the derived promise. If [[Handler]] is "IDENTITY" it is equivalent to a function that simply returns its first argument. If [[Handler]] is "THROWER" it is equivalent to a function that throws its first argument as an exception.
  ------------------ ------------------------------- ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1.  2.  3.  

CreateResolvingFunctions ( promise )

When CreateResolvingFunctions is performed with argument promise, the
following steps are taken:

1.  Let alreadyResolved be a new Record { [[value]]: FALSE }.

2.  Let resolve be a new built-in function object as defined in
    Promise Resolve Functions (25.4.1.4.2).

3.  Set the [[Promise]] internal slot of resolve to promise.

4.  Set the [[AlreadyResolved]] internal slot of resolve to
    alreadyResolved.

5.  Let reject be a new built-in function object as defined in Promise
    Reject Functions (25.4.1.4.1).

6.  Set the [[Promise]] internal slot of reject to promise.

7.  Set the [[AlreadyResolved]] internal slot of reject to
    alreadyResolved.

8.  Return a new Record { [[Resolve]]: resolve, [[Reject]]: reject
    }.

Promise Reject Functions

A promise reject function is an anonymous built-in function that has
[[Promise]] and [[AlreadyResolved]] internal slots.

When a promise reject function F is called with argument reason, the
following steps are taken:

1.  Assert: F has a [[Promise]] internal slot whose value is an
    Object.

2.  Let promise be the value of F's [[Promise]] internal slot.

3.  Let alreadyResolved be the value of F's [[AlreadyResolved]]
    internal slot.

4.  If alreadyResolved.[[value]] is TRUE, return UNDEFINED.

5.  Set alreadyResolved.[[value]] to TRUE.

6.  Return RejectPromise(promise, reason).

Promise Resolve Functions

A promise resolve function is an anonymous built-in function that has
[[Promise]] and [[AlreadyResolved]] internal slots.

When a promise resolve function F is called with argument
resolution, the following steps are taken:

1.  Assert: F has a [[Promise]] internal slot whose value is an
    Object.

2.  Let promise be the value of F's [[Promise]] internal slot.

3.  Let alreadyResolved be the value of F's [[AlreadyResolved]]
    internal slot.

4.  If alreadyResolved.[[value]] is TRUE, return UNDEFINED.

5.  Set alreadyResolved.[[value]] to TRUE.

6.  If SameValue(resolution, promise) is TRUE, then

    a.  Let selfResolutionError be a newly-created TYPEERROR object.

    b.  Return RejectPromise(promise, selfResolutionError).

7.  If Type(resolution) is not Object, then

    a.  Return FulfillPromise(promise, resolution).

8.  Let then be Get(resolution, "THEN").

9.  If then is an abrupt completion, then

    a.  Return RejectPromise(promise, then.[[value]]).

10. Let then be then.[[value]].

11. If IsCallable(then) is FALSE, then

    a.  Return FulfillPromise(promise, resolution).

    b.  c.  d.  e.  

12. Perform EnqueueJob ("PromiseJobs", PromiseResolveThenableJob,
    «‍promise, resolution, then»)

13. Return UNDEFINED.

FulfillPromise ( promise, value)

When the FulfillPromise abstract operation is called with arguments
promise and value the following steps are taken:

1.  Assert: the value of promise's [[PromiseState]] internal slot is
    "PENDING".

2.  Let reactions be the value of promise's
    [[PromiseFulfillReactions]] internal slot.

3.  Set the value of promise's [[PromiseResult]] internal slot to
    value.

4.  Set the value of promise's [[PromiseFulfillReactions]] internal
    slot to UNDEFINED.

5.  Set the value of promise's [[PromiseRejectReactions]] internal
    slot to UNDEFINED.

6.  Set the value of promise's [[PromiseState]] internal slot to
    "FULFILLED".

7.  Return TriggerPromiseReactions(reactions, value).

NewPromiseCapability ( C )

The abstract operation NewPromiseCapability takes a constructor
function, and attempts to use that constructor function in the fashion
of the built-in PROMISE constructor to create a Promise object and
extract its resolve and reject functions. The promise plus the resolve
and reject functions are used to initialize a new PromiseCapability
record which is returned as the value of this abstract operation.

1.  2.  

1.  If IsConstructor(C) is FALSE, throw a TYPEERROR exception.

2.  NOTE C is assumed to be a constructor function that supports the
    parameter conventions of the PROMISE constructor (see 25.4.3.1).

3.  Let promiseCapability be a new PromiseCapability { [[Promise]]:
    UNDEFINED, [[Resolve]]: UNDEFINED, [[Reject]]: UNDEFINED }.

4.  Let executor be a new built-in function object as defined in
    GetCapabilitiesExecutor Functions (25.4.1.6.1).

5.  Set the [[Capability]] internal slot of executor to
    promiseCapability.

6.  Let promise be Construct(constructor, «executor»).

7.  ReturnIfAbrupt(promise).

8.  If IsCallable(promiseCapability.[[Resolve]]) is FALSE, throw a
    TYPEERROR exception.

9.  If IsCallable(promiseCapability.[[Reject]]) is FALSE, throw a
    TYPEERROR exception.

10. Set promiseCapability.[[Promise]] to promise.

11. Return promiseCapability.

NOTE This abstract operation supports Promise subclassing, as it is
generic on any constructor that calls a passed executor function
argument in the same way as the Promise constructor. It is used to
generalize static methods of the Promise constructor to any subclass.

GetCapabilitiesExecutor Functions

A GetCapabilitiesExecutor function is an anonymous built-in function
that has a [[Capability]] internal slot.

When a GetCapabilitiesExecutor function F is called with arguments
resolve and reject the following steps are taken:

1.  Assert: F has a [[Capability]] internal slot whose value is a
    PromiseCapability Record.

2.  Let promiseCapability be the value of F's [[Capability]]
    internal slot.

3.  If promiseCapability.[[Resolve]] is not UNDEFINED, throw a
    TYPEERROR exception.

4.  If promiseCapability.[[Reject]] is not UNDEFINED, throw a
    TYPEERROR exception.

5.  Set promiseCapability.[[Resolve]] to resolve.

6.  Set promiseCapability.[[Reject]] to reject.

7.  Return UNDEFINED.

IsPromise ( x )

The abstract operation IsPromise checks for the promise brand on an
object.

1.  If Type(x) is not Object, return FALSE.

2.  If x does not have a [[PromiseState]] internal slot, return FALSE.

3.  4.  Return TRUE.

RejectPromise ( promise, reason)

When the RejectPromise abstract operation is called with arguments
promise and reason the following steps are taken:

1.  Assert: the value of promise's [[PromiseState]] internal slot is
    "PENDING".

2.  Let reactions be the value of promise's
    [[PromiseRejectReactions]] internal slot.

3.  Set the value of promise's [[PromiseResult]] internal slot to
    reason.

4.  Set the value of promise's [[PromiseFulfillReactions]] internal
    slot to UNDEFINED.

5.  Set the value of promise's [[PromiseRejectReactions]] internal
    slot to UNDEFINED.

6.  Set the value of promise's [[PromiseState]] internal slot to
    "REJECTED".

7.  Return TriggerPromiseReactions(reactions, reason).

TriggerPromiseReactions ( reactions, argument )

The abstract operation TriggerPromiseReactions takes a collection of
functions to trigger in the next Job, and calls them, passing each the
given argument. Typically, these reactions will modify a
previously-returned promise, possibly calling in to a user-supplied
handler before doing so.

1.  Repeat for each reaction in reactions, in original insertion
    order

2.  a.  Perform EnqueueJob("PROMISEJOBS", PromiseReactionJob,
        «‍reaction, argument»).

3.  Return UNDEFINED.

Promise Jobs

PromiseReactionJob ( reaction, argument )

The job PromiseReactionJob with parameters reaction and argument
applies the appropriate handler to the incoming value, and uses the
handler's return value to resolve or reject the derived promise
associated with that handler.

1.  Assert: reaction is a PromiseReaction Record.

2.  Let promiseCapability be reaction.[[Capabilities]].

3.  Let handler be reaction.[[Handler]].

4.  If handler is "IDENTITY", let handlerResult be
    NormalCompletion(argument).

5.  Else if handler is "THROWER", let handlerResult be
    Completion{[[type]]: throw, [[value]]: argument, [[target]]:
    empty}.

6.  Else, let handlerResult be Call(handler, UNDEFINED,
    «argument»).

7.  If handlerResult is an abrupt completion, then

    a.  Let status be Call(promiseCapability.[[Reject]], UNDEFINED,
        «handlerResult.[[value]]»).

    b.  NextJob status.

8.  Let handlerResult be handlerResult.[[value]].

9.  Let status be Call(promiseCapability.[[Resolve]], UNDEFINED,
    «handlerResult_»)_.

10. NextJob status.

PromiseResolveThenableJob ( promiseToResolve, thenable, then)

The job PromiseResolveThenableJob with parameters promiseToResolve,
thenable, and then performs the following steps:

1.  Let resolvingFunctions be
    CreateResolvingFunctions(promiseToResolve).

2.  Let thenCallResult be Call(then, thenable,
    «resolvingFunctions.[[Resolve]],
    resolvingFunctions.[[Reject]]»).

3.  If thenCallResult is an abrupt completion,

    a.  Let status be Call(resolvingFunctions.[[Reject]], UNDEFINED,
        «thenCallResult_.[[value]]»)_.

    b.  NextJob status.

4.  NextJob thenCallResult.

NOTE This Job uses the supplied thenable and its THEN method to resolve
the given promise. This process must take place as a Job to ensure that
the evaluation of the THEN method occurs after evaluation of any
surrounding code has completed.

The Promise Constructor

The Promise constructor is the %Promise% intrinsic object and the
initial value of the PROMISE property of the global object. When called
as a constructor it creates and initializes a new Promise object.
PROMISE is not intended to be called as a function and will throw an
exception when called in that manner.

The PROMISE constructor is designed to be subclassable. It may be used
as the value in an EXTENDS clause of a class definition. Subclass
constructors that intend to inherit the specified PROMISE behaviour must
include a SUPER call to the PROMISE constructor to create and initialize
the subclass instance with the internal state necessary to support the
PROMISE and PROMISE.PROTOTYPE built-in methods.

Promise ( executor )

When the PROMISE function is called with argument executor the
following steps are taken:

1.  2.  If NewTarget is UNDEFINED, throw a TYPEERROR exception.

3.  4.  5.  If IsCallable(executor) is FALSE, throw a TYPEERROR
    exception.

6.  Let promise be OrdinaryCreateFromConstructor(NewTarget,
    "%PROMISEPROTOTYPE%", «‍[[PromiseState]], [[PromiseConstructor]],
    [[PromiseResult]], [[PromiseFulfillReactions]],
    [[PromiseRejectReactions]]» ).

7.  ReturnIfAbrupt(promise).

8.  Set the value of promise’s [[PromiseConstructor]] internal slot to
    NewTarget.

9.  10. Set promise's [[PromiseState]] internal slot to "PENDING".

11. Set promise's [[PromiseFulfillReactions]] internal slot to a new
    empty List.

12. Set promise's [[PromiseRejectReactions]] internal slot to a new
    empty List.

13. Let resolvingFunctions be CreateResolvingFunctions(promise).

14. Let completion be Call(executor, UNDEFINED,
    «resolvingFunctions.[[Resolve]],
    resolvingFunctions.[[Reject]]»).

15. If completion is an abrupt completion, then

    a.  Let status be Call(resolvingFunctions.[[Reject]], UNDEFINED,
        «completion.[[value]]»).

    b.  ReturnIfAbrupt(status).

16. Return promise.

NOTE The executor argument must be a function object. It is called for
initiating and reporting completion of the possibly deferred action
represented by this Promise object. The executor is called with two
arguments: resolve and reject. These are functions that may be used
by the executor function to report eventual completion or failure of
the deferred computation. Returning from the executor function does not
mean that the deferred action has been completed but only that the
request to eventually perform the deferred action has been accepted.

The resolve function that is passed to an executor function accepts
a single argument. The executor code may eventually call the resolve
function to indicate that it wishes to resolve the associated Promise
object. The argument passed to the resolve function represents the
eventual value of the deferred action and can be either the actual
fulfillment value or another Promise object which will provide the value
if it is fulfilled.

The reject function that is passed to an executor function accepts a
single argument. The executor code may eventually call the reject
function to indicate that the associated Promise is rejected and will
never be fulfilled. The argument passed to the reject function is used
as the rejection value of the promise. Typically it will be an ERROR
object.

The resolve and reject functions passed to an executor function by the
Promise constructor have the capability to actually resolve and reject
the associated promise. Subclasses may have different constructor
behaviour that passes in customized values for resolve and reject.

1.  2.  3.  4.  5.  6.  7.  8.  a.  b.  

9.  

1.  2.  3.  

Properties of the Promise Constructor

The value of the [[Prototype]] internal slot of the PROMISE constructor
is the intrinsic object %FunctionPrototype% (19.2.3).

1.  

Besides the LENGTH property (whose value is 1), the Promise constructor
has the following properties:

Promise.all ( iterable ) 

The ALL function returns a new promise which is fulfilled with an array
of fulfillment values for the passed promises, or rejects with the
reason of the first passed promise that rejects. It resoves all elements
of the passed iterable to promises as it runs this algorithm.

1.  Let C be the THIS value.

2.  If Type(C) is not Object, throw a TYPEERROR exception.

3.  Let S be Get(C, @@species).

4.  ReturnIfAbrupt(S).

5.  If S is neither UNDEFINED nor NULL, let C be S.

6.  Let promiseCapability be NewPromiseCapability(C).

7.  ReturnIfAbrupt(promiseCapability).

8.  Let iterator be GetIterator(iterable).

9.  IfAbruptRejectPromise(iterator, promiseCapability).

10. Let result be PerformPromiseAll(iterator, C,
    promiseCapability).

11. If result is an abrupt completion,

    a.  Let result be IteratorClose(iterator, result).

    b.  IfAbruptRejectPromise(result, promiseCapability).

12. Return result.[[value]].

Note: The ALL function requires its THIS value to be a constructor
function that supports the parameter conventions of the PROMISE
constructor.

PerformPromiseAll( iterator, constructor, resultCapability) Abstract Operation

When the PerformPromiseAll abstract operation is called with arguments
_iterator, constructor,_ and resultCapability the following steps are
taken:

1.  Assert: iterator is an object that supports the Iterator
    interface.

2.  Assert: constructor is a constructor function.

3.  Assert: resultCapability is a PromiseCapability record.

4.  Let values be a new empty List.

5.  Let remainingElementsCount be a new Record { [[value]]: 1 }.

6.  Let index be 0.

7.  Repeat

8.  a.  Let next be IteratorStep(iterator).

    b.  ReturnIfAbrupt (next).

    c.  If next is FALSE,

    d.  i.  Set remainingElementsCount.[[value]] to
            remainingElementsCount.[[value]] − 1.

        ii. If remainingElementsCount.[[value]] is 0,

        iii. 1.  Let valuesArray be CreateArrayFromList(values).

            2.  3.  Let resolveResult be
                Call(resultCapability.[[Resolve]], UNDEFINED,
                «valuesArray»).

            4.  If resolveResult is an abrupt completion, return
                NormalCompletion(resolveResult).

        iv. Return resultCapability.[[Promise]].

    e.  Let nextValue be IteratorValue(next).

    f.  ReturnIfAbrupt (nextValue ).

    g.  Append UNDEFINED to values.

    h.  Let nextPromise be Invoke(constructor, "RESOLVE",
        «‍nextValue»).

    i.  ReturnIfAbrupt (nextPromise ).

    j.  Let resolveElement be a new built-in function object as
        defined in Promise.all Resolve Element Functions.

    k.  Set the [[AlreadyCalled]] internal slot of resolveElement to a
        new Record { [[value]]: FALSE }.

    l.  Set the [[Index]] internal slot of resolveElement to index.

    m.  Set the [[Values]] internal slot of resolveElement to
        values.

    n.  Set the [[Capabilities]] internal slot of resolveElement to
        resultCapability.

    o.  Set the [[RemainingElements]] internal slot of resolveElement
        to remainingElementsCount.

    p.  Set remainingElementsCount.[[value]] to
        remainingElementsCount.[[value]] + 1.

    q.  Let result be Invoke(nextPromise, "THEN",
        «‍resolveElement, resultCapability.[[Reject]]»).

    r.  ReturnIfAbrupt (result).

    s.  Set index to index + 1.

Promise.all Resolve Element Functions

A Promise.all resolve element function is an anonymous built-in function
that is used to resolve a specific Promise.all element. Each Promise.all
resolve element function has [[Index]], [[Values]], [[Capabilities]],
[[RemainingElements]], and [[AlreadyCalled]] internal slots.

When a Promise.all resolve element function F is called with argument
x, the following steps are taken:

1.  Let alreadyCalled be the value of F's [[AlreadyCalled]] internal
    slot.

2.  If alreadyCalled.[[value]] is TRUE, return UNDEFINED.

3.  Set alreadyCalled.[[value]] to TRUE.

4.  Let index be the value of F's [[Index]] internal slot.

5.  Let values be the value of F's [[Values]] internal slot.

6.  Let promiseCapability be the value of F's [[Capabilities]]
    internal slot.

7.  Let remainingElementsCount be the value of F's
    [[RemainingElements]] internal slot.

8.  Set values_[_index] to x.

9.  10. Set remainingElementsCount.[[value]] to
    remainingElementsCount.[[value]] - 1.

11. If remainingElementsCount.[[value]] is 0,

12. a.  Let valuesArray be CreateArrayFromList(values).

    b.  Return Call(promiseCapability.[[Resolve]], UNDEFINED,
        «valuesArray»).

13. Return UNDEFINED.

Promise.prototype

The initial value of PROMISE.PROTOTYPE is the Promise prototype object
(25.4.5).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Promise.race ( iterable )

The RACE function returns a new promise which is settled in the same way
as the first passed promise to settle. It resolves all elements of the
passed iterable to promises as it runs this algorithm.

1.  Let C be the THIS value.

2.  If Type(C) is not Object, throw a TYPEERROR exception.

3.  Let S be Get(C, @@species).

4.  ReturnIfAbrupt(S).

5.  If S is neither UNDEFINED nor NULL, let C be S.

6.  Let promiseCapability be NewPromiseCapability(C).

7.  ReturnIfAbrupt(promiseCapability).

8.  Let iterator be GetIterator(iterable).

9.  IfAbruptRejectPromise(iterator, promiseCapability).

10. Let result be PerformPromiseRaceLoop(iterator,
    promiseCapability, C).

11. If result is an abrupt completion, then let result be
    IteratorClose(iterator,result).

12. 13. a.  b.  c.  d.  e.  f.  g.  h.  

14. IfAbruptRejectPromise(result, promiseCapability).

15. Return promiseCapability.[[Promise]].

NOTE 1 If the iterable argument is empty or if none of the promises in
iterable ever settle then the pending promise returned by this method
will never be settled

NOTE 2 The RACE function expects its THIS value to be a constructor
function that supports the parameter conventions of the PROMISE
constructor. It also expects that its THIS value provides a RESOLVE
method.

PerformPromiseRaceLoop( iterator, promiseCapability, C )

When the PerformPromiseRaceLoop abstract operation is called with
arguments _iterator, promiseCapability,_ and C the following steps are
taken:

1.  Repeat

    a.  Let next be IteratorStep(iterator).

    b.  ReturnIfAbrupt(next).

    c.  If next is FALSE, return promiseCapability.[[Promise]].

    d.  Let nextValue be IteratorValue(next).

    e.  ReturnIfAbrupt(nextValue).

    f.  Let nextPromise be Invoke(C, "RESOLVE", «‍nextValue»).

    g.  ReturnIfAbrupt(nextPromise).

    h.  Let result be Invoke(nextPromise, "THEN",
        «‍promiseCapability.[[Resolve]],
        promiseCapability.[[Reject]]»).

    i.  ReturnIfAbrupt(result).

Promise.reject ( r )

The REJECT function returns a new promise rejected with the passed
argument.

1.  Let C be the THIS value.

2.  If Type(C) is not Object, throw a TYPEERROR exception.

3.  Let S be Get(C, @@species).

4.  ReturnIfAbrupt(S).

5.  If S is neither UNDEFINED nor NULL, let C be S.

6.  Let promiseCapability be NewPromiseCapability(C).

7.  ReturnIfAbrupt(promiseCapability).

8.  Let rejectResult be Call(promiseCapability.[[Reject]],
    UNDEFINED, «r»).

9.  ReturnIfAbrupt(rejectResult).

10. Return promiseCapability.[[Promise]].

NOTE The REJECT function requires that its THIS value to be a
constructor function that supports the parameter conventions of the
PROMISE constructor.

Promise.resolve ( x )

The RESOLVE function returns either a new promise resolved with the
passed argument, or the argument itself if the argument is a promise
produced by this constructor.

1.  Let C be the THIS value.

2.  If IsPromise(x) is TRUE,

3.  a.  Let constructor be the value of x's [[PromiseConstructor]]
        internal slot.

    b.  If SameValue(constructor, C) is TRUE, return x.

4.  If Type(C) is not Object, throw a TYPEERROR exception.

5.  Let S be Get(C, @@species).

6.  ReturnIfAbrupt(S).

7.  If S is neither UNDEFINED nor NULL, let C be S.

8.  Let promiseCapability be NewPromiseCapability(C).

9.  ReturnIfAbrupt(promiseCapability).

10. Let resolveResult be Call(promiseCapability.[[Resolve]],
    UNDEFINED, «x»).

11. ReturnIfAbrupt(resolveResult).

12. Return promiseCapability.[[Promise]].

NOTE The RESOLVE function requires that its THIS value to be a
constructor function that supports the parameter conventions of the
PROMISE constructor.

get Promise [ @@species ] 

PROMISE[@@SPECIES] is an accessor property whose set accessor function
is UNDEFINED. Its get accessor function performs the following steps:

1.  Return THIS.

The value of the NAME property of this function is "GET
[SYMBOL.SPECIES]".

NOTE Promise prototype methods normally use their THIS object’s
constructor to create a derived object. However, a subclass constructor
may over-ride that default behaviour by redefining its @@species
property.

1.  2.  

1.  2.  3.  

Properties of the Promise Prototype Object

The value of the [[Prototype]] internal slot of the Promise prototype
object is the intrinsic object %ObjectPrototype% (19.1.3). The Promise
prototype object is an ordinary object. It does not have a
[[PromiseState]] internal slot or any of the other internal slots of
Promise instances.

Promise.prototype.catch ( onRejected )

When the CATCH method is called with argument onRejected the following
steps are taken:

1.  Let promise be the THIS value.

2.  Return Invoke(promise, "THEN", «‍UNDEFINED, onRejected»).

Promise.prototype.constructor

The initial value of PROMISE.PROTOTYPE.CONSTRUCTOR is the intrinsic
object %Promise%.

Promise.prototype.then ( onFulfilled , onRejected )

When the THEN method is called with arguments onFulfilled and
onRejected the following steps are taken:

1.  Let promise be the THIS value.

2.  If IsPromise(promise) is FALSE, throw a TYPEERROR exception.

3.  Let C be SpeciesConstructor(promise, %Promise%).

4.  ReturnIfAbrupt(C).

5.  Let resultCapability be NewPromiseCapability(C).

6.  ReturnIfAbrupt(resultCapability).

7.  Return PerformPromiseThen(promise, onFulfilled, onRejected,
    resultCapability).

PerformPromiseThen ( promise, onFulfilled, onRejected, resultCapability )

The abstract operation PerformPromiseThen performs the “then” operation
on promise using onFulfilled and onRejected as its settlement
actions. The result is resultCapability’s promise.

1.  Assert: IsPromise(promise) is TRUE.

2.  Assert: resultCapability is a PromiseCapability record.

3.  If IsCallable(onFulfilled) is FALSE, then

4.  a.  Let onFulfilled be "IDENTITY".

5.  If IsCallable(onRejected) is FALSE, then

6.  a.  Let onRejected be "THROWER".

7.  8.  9.  10. 11. 12. Let fulfillReaction be the PromiseReaction {
    [[Capabilities]]: resultCapability, [[Handler]]: onFulfilled }.

13. Let rejectReaction be the PromiseReaction { [[Capabilities]]:
    resultCapability, [[Handler]]: onRejected}.

14. If the value of promise's [[PromiseState]] internal slot is
    "PENDING",

15. a.  Append fulfillReaction as the last element of the List that is
        the value of promise's [[PromiseFulfillReactions]] internal
        slot.

    b.  Append rejectReaction as the last element of the List that is
        the value of promise's [[PromiseRejectReactions]] internal
        slot.

16. Else if the value of promise's [[PromiseState]] internal slot is
    "FULFILLED",

17. a.  Let value be the value of promise's [[PromiseResult]]
        internal slot.

    b.  Perform EnqueueJob("PROMISEJOBS", PromiseReactionJob,
        «‍fulfillReaction, value»).

18. Else if the value of promise's [[PromiseState]] internal slot is
    "REJECTED",

19. a.  Let reason be the value of promise's [[PromiseResult]]
        internal slot.

    b.  Perform EnqueueJob("PROMISEJOBS", PromiseReactionJob,
        «‍rejectReaction, reason»).

20. Return resultCapability.[[Promise]].

Promise.prototype [ @@toStringTag ]

The initial value of the @@toStringTag property is the string value
"PROMISE".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Properties of Promise Instances

Promise instances are ordinary objects that inherit properties from the
Promise prototype object (the intrinsic, %PromisePrototype%). Promise
instances are initially created with the internal slots described in
Table 52.

Table 52 — Internal Slots of Promise Instances

  ----------------------------- --------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  INTERNAL SLOT                 DESCRIPTION
  [[PromiseState]]                A string value that governs how a promise will react to incoming calls to its THEN method. The possible values are: UNDEFINED, "PENDING", "FULFILLED", and "REJECTED".
  [[PromiseConstructor]]          The function object that was used to construct this promise. Checked by the RESOLVE method of the PROMISE constructor.
  [[PromiseResult]]               The value with which the promise has been fulfilled or rejected, if any. Only meaningful if [[PromiseState]] is not "PENDING".
  [[PromiseFulfillReactions]]     A List of PromiseReaction records to be processed when/if the promise transitions from the "PENDING" state to the"FULFILLED" state.
  [[PromiseRejectReactions]]      A List of PromiseReaction records to be processed when/if the promise transitions from the "PENDING" state to the"REJECTED" state.
  ----------------------------- --------------------------------------------------------------------------------------------------------------------------------------------------------------------------



REFLECTION 


The Reflect Object

The Reflect object is a single ordinary object.

The value of the [[Prototype]] internal slot of the Reflect object is
the intrinsic object %ObjectPrototype% (19.1.3).

The Reflect object is not a function object. It does not have a
[[Construct]] internal method; it is not possible to use the Reflect
object as a constructor with the NEW operator. The Reflect object also
does not have a [[Call]] internal method; it is not possible to invoke
the Reflect object as a function.

Reflect.apply ( target, thisArgument, argumentsList )

When the APPLY function is called with arguments target,
thisArgument, and argumentsList the following steps are taken:

1.  2.  3.  If IsCallable(target) is FALSE, throw a TYPEERROR
    exception.

4.  Let args be CreateListFromArrayLike(argumentsList).

5.  ReturnIfAbrupt(args).

6.  Perform the PrepareForTailCall abstract operation.

7.  Return Call(target, thisArgument, args).

Reflect.construct ( target, argumentsList [, newTarget] )

When the CONSTRUCT function is called with arguments target,
argumentsList, and newTarget the following steps are taken:

1.  2.  3.  If IsConstructor(target) is FALSE, throw a TYPEERROR
    exception.

4.  If newTarget is not present, let newTarget be target.

5.  Else, if IsConstructor(newTarget) is FALSE, throw a TYPEERROR
    exception.

6.  Let args be CreateListFromArrayLike(argumentsList).

7.  ReturnIfAbrupt(args).

8.  Return Construct(target, args, newTarget).

Reflect.defineProperty ( target, propertyKey, attributes )

When the DEFINEPROPERTY function is called with arguments target,
propertyKey, and attributes the following steps are taken:

1.  If Type(target) is not Object, throw a TYPEERROR exception.

2.  3.  Let key be ToPropertyKey(propertyKey).

4.  ReturnIfAbrupt(key).

5.  Let desc be ToPropertyDescriptor(attributes).

6.  ReturnIfAbrupt(desc).

7.  Return the result of calling the [[DefineOwnProperty]] internal
    method of target with arguments key, and desc.

Reflect.deleteProperty ( target, propertyKey )

When the DELETEPROPERTY function is called with arguments target and
propertyKey, the following steps are taken:

1.  If Type(target) is not Object, throw a TYPEERROR exception.

2.  3.  Let key be ToPropertyKey(propertyKey).

4.  ReturnIfAbrupt(key).

5.  Return the result of calling the [[Delete]] internal method of
    target with argument key.

Reflect.enumerate ( target )

When the ENUMERATE function is called with argument target the
following steps are taken:

1.  If Type(target) is not Object, throw a TYPEERROR exception.

2.  3.  Return the result of calling the [[Enumerate]] internal method
    of target.

4.  

Reflect.get ( target, propertyKey [ , receiver ])

When the GET function is called with arguments target, propertyKey,
and receiver the following steps are taken:

1.  If Type(target) is not Object, throw a TYPEERROR exception.

2.  3.  Let key be ToPropertyKey(propertyKey).

4.  ReturnIfAbrupt(key).

5.  If receiver is not present, then

    a.  Let receiver be target.

6.  Return the result of calling the [[Get]] internal method of target
    with arguments key, and receiver.

Reflect.getOwnPropertyDescriptor ( target, propertyKey )

When the GETOWNPROPERTYDESCRIPTOR function is called with arguments
target and propertyKey, the following steps are taken:

1.  If Type(target) is not Object, throw a TYPEERROR exception.

2.  3.  Let key be ToPropertyKey(propertyKey).

4.  ReturnIfAbrupt(key).

5.  Let desc be the result of calling the [[GetOwnProperty]] internal
    method of target with argument key.

6.  ReturnIfAbrupt(desc).

7.  Return FromPropertyDescriptor(desc).

Reflect.getPrototypeOf ( target )

When the GETPROTOTYPEOF function is called with argument target the
following steps are taken:

1.  If Type(target) is not Object, throw a TYPEERROR exception.

2.  3.  Return the result of calling the [[GetPrototypeOf]] internal
    method of target.

Reflect.has ( target, propertyKey )

When the HAS function is called with arguments target and
propertyKey, the following steps are taken:

1.  If Type(target) is not Object, throw a TYPEERROR exception.

2.  3.  Let key be ToPropertyKey(propertyKey).

4.  ReturnIfAbrupt(key).

5.  Return the result of calling the [[HasProperty]] internal method of
    target with argument key.

1.  2.  3.  4.  5.  

Reflect.isExtensible (target)

When the ISEXTENSIBLE function is called with argument target the
following steps are taken:

1.  If Type(target) is not Object, throw a TYPEERROR exception.

2.  3.  Return the result of calling the [[IsExtensible]] internal
    method of target.

Reflect.ownKeys ( target )

When the OWNKEYS function is called with argument target the following
steps are taken:

1.  If Type(target) is not Object, throw a TYPEERROR exception.

2.  3.  Let keys be the result of calling the [[OwnPropertyKeys]]
    internal method of target.

4.  ReturnIfAbrupt(keys).

5.  Return CreateArrayFromList(keys).

Reflect.preventExtensions ( target )

When the PREVENTEXTENSIONS function is called with argument target,
the following steps are taken:

1.  If Type(target) is not Object, throw a TYPEERROR exception.

2.  3.  Return the result of calling the [[PreventExtensions]] internal
    method of target.

Reflect.set ( target, propertyKey, V [ , receiver ] )

When the SET function is called with arguments target, V,
propertyKey, and receiver the following steps are taken:

1.  If Type(target) is not Object, throw a TYPEERROR exception.

2.  3.  Let key be ToPropertyKey(propertyKey).

4.  ReturnIfAbrupt(key).

5.  If receiver is not present, then

    a.  Let receiver be target.

6.  Return the result of calling the [[Set]] internal method of target
    with arguments key, V, and receiver.

Reflect.setPrototypeOf ( target, proto )

When the SETPROTOTYPEOF function is called with arguments target and
propertyKey, the following steps are taken:

1.  If Type(target) is not Object, throw a TYPEERROR exception.

2.  3.  If Type(proto) is not Object and proto is not NULL, throw a
    TYPEERROR exception

4.  Return the result of calling the [[SetPrototypeOf]] internal method
    of target with argument proto.


1.  2.  3.  4.  5.  6.  7.  8.  9.  10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 24. a.  b.  

25. a.  b.  

26. 27. 28. 29. 30. 31. 32. 33. 34. 35. 36. 37. 38. 39. 40. 41. 42. 43. 44. 45. 46. a.  b.  c.  

47. a.  b.  

48. 

1.  2.  3.  

1.  2.  3.  

1.  2.  3.  4.  5.  

1.  2.  3.  4.  5.  

1.  2.  3.  4.  5.  6.  7.  a.  b.  c.  

8.  

1.  2.  3.  4.  5.  6.  a.  b.  c.  d.  

7.  

1.  2.  3.  4.  5.  

1.  2.  3.  4.  5.  

1.  2.  3.  4.  

1.  2.  a.  b.  c.  d.  

1.  

1.  2.  3.  4.  5.  6.  7.  8.  9.  10. 11. 12. 


1.  2.  3.  4.  5.  6.  7.  8.  a.  b.  c.  

9.  a.  b.  c.  i.  ii. iii. 

10. 11. 12. 13. 14. 

1.  2.  3.  

1.  2.  3.  

1.  a.  b.  

2.  

1.  2.  3.  4.  5.  6.  7.  8.  9.  10. 11. 12. 13. 14. 

1.  

1.  2.  3.  4.  5.  6.  7.  a.  i.  ii. iii. 

8.  

1.  2.  3.  

1.  2.  3.  4.  5.  6.  7.  a.  i.  ii. iii. iv. 

8.  

1.  2.  3.  4.  5.  

1.  2.  3.  4.  5.  6.  7.  a.  

8.  

1.  2.  3.  4.  5.  6.  7.  8.  9.  

1.  2.  3.  

1.  2.  3.  4.  5.  6.  7.  

1.  2.  3.  4.  5.  6.  7.  8.  9.  10. 11. 12. 13. 14. 15. 16. 

1.  2.  3.  4.  5.  a.  b.  c.  d.  e.  f.  

6.  7.  

1.  2.  3.  4.  

1.  2.  3.  4.  5.  6.  7.  8.  a.  1.  2.  

9.  10. 11. 

1.  2.  3.  

1.  2.  

1.  

1.  

1.  

1.  

1.  2.  3.  4.  5.  6.  

1.  2.  3.  4.  5.  6.  7.  8.  9.  10. a.  b.  c.  d.  i.  ii. iii. 1.  2.  3.  4.  5.  

        iv. 

11. 12. 

1.  

  -- --
     
     
     
     
  -- --


Proxy Objects

The Proxy Constructor 

The Proxy constructor is the %Proxy% intrinsic object and the initial
value of the PROXY property of the global object. When called as a
constructor it creates and initializes a new exotic proxy object. PROXY
is not intended to be called as a function and will throw an exception
when called in that manner.

The PROXY constructor does not have a PROTOTYPE property because exotic
proxy objects do not have a [[Prototype]] internal slot that requires
initialization.

The PROXY constructor may be used as the value in an EXTENDS clause of a
class definition. Subclass constructors that intend to inherit the
ability to create exotic proxy objects must include a SUPER call to the
PROXY constructor.

Proxy ( target, handler )

1.  

When PROXY is called with arguments target and handler performs the
following steps:

1.  If NewTarget is UNDEFINED, throw a TYPEERROR exception.

2.  Return ProxyCreate(target, handler).

3.  

Properties of the Proxy Constructor 

The value of the [[Prototype]] internal slot of the PROXY constructor is
the intrinsic object %FunctionPrototype% (19.2.3).

Besides the LENGTH property (whose value is 2), the PROXY constructor
has the following properties:

Proxy.revocable ( target, handler )

The PROXY.REVOCABLE function is used to create a revocable Proxy object.
When PROXY.REVOCABLE is called with arguments target and handler the
following steps are taken:

1.  Let p be ProxyCreate(target, handler).

2.  ReturnIfAbrupt(p).

3.  Let revoker be a new built-in function object as defined in
    26.2.2.1.1.

4.  Set the [[RevokableProxy]] internal slot of revoker to p.

5.  Let result be ObjectCreate(%ObjectPrototype%).

6.  CreateDataProperty(result, "PROXY", p).

7.  CreateDataProperty(result, "REVOKE", revoker).

8.  Return result.

Proxy Revocation Functions

A Proxy revocation function is an anonymous function that has the
ability to invalidate a specific Proxy object.

Each Proxy revocation function has a [[RevokableProxy]] internal slot.

When a Proxy revocation function, F, is called the following steps are
taken:

1.  Let p be the value of F’s [[RevokableProxy]] internal slot.

2.  If p is NULL, return UNDEFINED.

3.  Set the value of F’s [[RevokableProxy]] internal slot to NULL.

4.  Assert: p is a Proxy object.

5.  Set the [[ProxyTarget]] internal slot of p to NULL.

6.  Set the [[ProxyHandler]] internal slot of p to NULL.

7.  Return UNDEFINED.


Module Namespace Objects

A Module Namespace Object is a module namespace exotic object that
provides runtime property-based access to a module’s exported bindings.
There is no constructor function for Module Namespace Objects. Instead,
such an object is created for each module that is imported by an
ImportDeclaration that includes a NameSpaceImport (See 15.2.2).

In addition to the properties specified in 15.2.2 each Module Namespace
Object has the own following properties:

@@toStringTag

The initial value of the @@toStringTag property is the string value
"MODULE".

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

 [ @@iterator ] ( )

The following steps are taken:

1.  Let N the THIS value.

2.  If Type(N) is not Object, throw a TYPEERROR exception.

3.  Return the result of calling the [[Enumerate]] internal method of
    N with no arguments.

The value of the NAME property of this function is "[SYMBOL.ITERATOR]".

(informative)
Grammar Summary


Lexical Grammar

SourceCharacter :: See 10.1

any Unicode code point

InputElementDiv :: See clause 11

WhiteSpace
LineTerminator
Comment
Token
DivPunctuator
RightBracePunctuator

InputElementRegExp :: See clause 11

WhiteSpace
LineTerminator
Comment
Token
RightBracePunctuator
RegularExpressionLiteral

InputElementTemplateTail :: See clause 11

WhiteSpace
LineTerminator
Comment
Token
DivPunctuator
TemplateSubstitutionTail

WhiteSpace :: See 11.2

<TAB>
<VT>
<FF>
<SP>
<NBSP>
<ZWNBSP>
<USP>

LineTerminator :: See 11.3

<LF>
<CR>
<LS>
<PS>

LineTerminatorSequence :: See 11.3

<LF>
<CR> [lookahead ≠ <LF> ]
<LS>
<PS>
<CR> <LF>

Comment :: See 11.4

MultiLineComment
SingleLineComment

MultiLineComment :: See 11.4

/* MultiLineCommentChars~opt~ */

MultiLineCommentChars :: See 11.4

MultiLineNotAsteriskChar MultiLineCommentChars~opt~
* PostAsteriskCommentChars~opt~

PostAsteriskCommentChars :: See 11.4

MultiLineNotForwardSlashOrAsteriskChar MultiLineCommentChars~opt~
* PostAsteriskCommentChars~opt~

MultiLineNotAsteriskChar :: See 11.4

SourceCharacter BUT NOT *

MultiLineNotForwardSlashOrAsteriskChar :: See 11.4

SourceCharacter BUT NOT ONE OF / OR *

SingleLineComment :: See 11.4

// SingleLineCommentChars~opt~

SingleLineCommentChars :: See 11.4

SingleLineCommentChar SingleLineCommentChars~opt~

SingleLineCommentChar :: See 11.4

SourceCharacter BUT NOT LineTerminator

Token :: See 11.5

IdentifierName
Punctuator
NumericLiteral
StringLiteral
Template

IdentifierName :: See 11.6

IdentifierStart
IdentifierName IdentifierPart

IdentifierStart :: See 11.6

UnicodeIDStart
$
_
\ UnicodeEscapeSequence

IdentifierPart :: See 11.6

UnicodeIDContinue
$
_
\ UnicodeEscapeSequence
<ZWNJ>
<ZWJ>

UnicodeIDStart :: See 11.6

any Unicode code point with the Unicode property “ID_Start” or
“OtherIDStart”

UnicodeIDContinue :: See 11.6

any Unicode code point with the Unicode property “ID_Continue”,
“OtherIDContinue”, or “OtherIDStart”

ReservedWord :: See 11.6.2

Keyword
FutureReservedWord
NullLiteral
BooleanLiteral

Keyword :: ONE OF See 11.6.2.1

  ---------- ---------- ------------ --------
  break      do         in           typeof
  case       else       instanceof   var
  catch      export     new          void
  class      extends    return       while
  const      finally    super        with
  continue   for        switch       yield
  debugger   function   this         
  default    if         throw        
  delete     import     try          
  ---------- ---------- ------------ --------

FutureReservedWord :: See 11.6.2.2

ENUM
AWAIT

  -- -- -- --
  -- -- -- --

AWAIT is only treated as a FutureReservedWord when Module is the
goal symbol of the syntactic grammar.

  The following tokens are also considered to be FutureReservedWords
  when parsing strict mode code (see 10.2.1).

  ------------ --------- ----------- --
  implements   package   protected   
  interface    private   public      
                                     
                                     
                                     
  ------------ --------- ----------- --

Punctuator :: ONE OF See 11.7

  ----- ------ ----- ----- ----- -----
  {     }      (     )     [     ]
  .     ;      ,     <     >     <=
  >=    ==     !=    ===   !==   
  +     -      *     %     ++    --
  <<    >>     >>>   &     |     ^
  !     ~      &&    ||    ?     :
  =     +=     -=    *=    %=    <<=
  >>=   >>>=   &=    |=    ^=    =>
  ----- ------ ----- ----- ----- -----

DivPunctuator :: ONE OF See 11.7

  --- ---- -- -- -- --
  /   /=            
  --- ---- -- -- -- --

RightBracePunctuator :: ONE OF See 11.7

  --- -- -- -- -- --
  }               
  --- -- -- -- -- --

NullLiteral :: See 11.8.1

NULL

BooleanLiteral :: See 11.8.2

TRUE
FALSE

NumericLiteral :: See 11.8.3

DecimalLiteral
BinaryIntegerLiteral
OctalIntegerLiteral
HexIntegerLiteral

DecimalLiteral :: See 11.8.3

DecimalIntegerLiteral . DecimalDigits~opt~ ExponentPart~opt~
. DecimalDigits ExponentPart~opt~
DecimalIntegerLiteral ExponentPart~opt~

DecimalIntegerLiteral :: See 11.8.3

0
NonZeroDigit DecimalDigits~opt~

DecimalDigits :: See 11.8.3

DecimalDigit
DecimalDigits DecimalDigit

DecimalDigit :: ONE OF See 11.8.3

0 1 2 3 4 5 6 7 8 9

NonZeroDigit :: ONE OF See 11.8.3

1 2 3 4 5 6 7 8 9

ExponentPart :: See 11.8.3

ExponentIndicator SignedInteger

ExponentIndicator :: ONE OF See 11.8.3

E E

SignedInteger :: See 11.8.3

DecimalDigits
+ DecimalDigits
- DecimalDigits

BinaryIntegerLiteral :: See 11.8.3

0B BinaryDigits
0B BinaryDigits

BinaryDigits :: See 11.8.3

BinaryDigit
BinaryDigits BinaryDigit

BinaryDigit :: ONE OF See 11.8.3

0 1

OctalIntegerLiteral :: See 11.8.3

0O OctalDigits
0O OctalDigits

OctalDigits :: See 11.8.3

OctalDigit
OctalDigits OctalDigit

OctalDigit :: ONE OF See 11.8.3

0 1 2 3 4 5 6 7

HexIntegerLiteral :: See 11.8.3

0X HexDigits
0X HexDigit

HexDigits :: See 11.8.3

HexDigit
HexDigits HexDigit

HexDigit :: ONE OF See 11.8.3

0 1 2 3 4 5 6 7 8 9 A B C D E F A B C D E F

StringLiteral :: See 11.8.4

" DoubleStringCharacters~opt~ "
' SingleStringCharacters~opt~ '

DoubleStringCharacters :: See 11.8.4

DoubleStringCharacter DoubleStringCharacters~opt~

SingleStringCharacters :: See 11.8.4

SingleStringCharacter SingleStringCharacters~opt~

DoubleStringCharacter :: See 11.8.4

SourceCharacter BUT NOT ONE OF " OR \ OR LineTerminator
\ EscapeSequence
LineContinuation

SingleStringCharacter :: See 11.8.4

SourceCharacter BUT NOT ONE OF ' OR \ OR LineTerminator
\ EscapeSequence
LineContinuation

LineContinuation :: See 11.8.4

\ LineTerminatorSequence

EscapeSequence :: See 11.8.4

CharacterEscapeSequence
0 [lookahead ∉ DecimalDigit]
HexEscapeSequence
UnicodeEscapeSequence

CharacterEscapeSequence :: See 11.8.4

SingleEscapeCharacter
NonEscapeCharacter

SingleEscapeCharacter :: ONE OF See 11.8.4

' " \ B F N R T V

NonEscapeCharacter :: See 11.8.4

SourceCharacter BUT NOT ONE OF EscapeCharacter OR LineTerminator

EscapeCharacter :: See 11.8.4

SingleEscapeCharacter
DecimalDigit
X
U

HexEscapeSequence :: See 11.8.4

X HexDigit HexDigit

UnicodeEscapeSequence :: See 11.8.4

U Hex4Digits
U{ HexDigits }

Hex4Digits :: See 11.8.4

HexDigit HexDigit HexDigit HexDigit

RegularExpressionLiteral :: See 11.8.5

/ RegularExpressionBody / RegularExpressionFlags

RegularExpressionBody :: See 11.8.5

RegularExpressionFirstChar RegularExpressionChars

RegularExpressionChars :: See 11.8.5

[empty]
RegularExpressionChars RegularExpressionChar

RegularExpressionFirstChar :: See 11.8.5

RegularExpressionNonTerminator BUT NOT ONE OF * OR \ OR / OR [
RegularExpressionBackslashSequence
RegularExpressionClass

RegularExpressionChar :: See 11.8.5

RegularExpressionNonTerminator BUT NOT ONE OF \ OR / OR [
RegularExpressionBackslashSequence
RegularExpressionClass

RegularExpressionBackslashSequence :: See 11.8.5

\ RegularExpressionNonTerminator

RegularExpressionNonTerminator :: See 11.8.5

SourceCharacter BUT NOT LineTerminator

RegularExpressionClass :: See 11.8.5

[ RegularExpressionClassChars ]

RegularExpressionClassChars :: See 11.8.5

[empty]
RegularExpressionClassChars RegularExpressionClassChar

RegularExpressionClassChar :: See 11.8.5

RegularExpressionNonTerminator BUT NOT ONE OF ] OR \
RegularExpressionBackslashSequence

RegularExpressionFlags :: See 11.8.5

[empty]
RegularExpressionFlags IdentifierPart

Template :: See 11.8.6

NoSubstitutionTemplate
TemplateHead

NoSubstitutionTemplate :: See 11.8.6

` TemplateCharacters~opt~ `

TemplateHead :: See 11.8.6

` TemplateCharacters~opt~ ${

TemplateSubstitutionTail :: See 11.8.6

TemplateMiddle
TemplateTail

TemplateMiddle :: See 11.8.6

} TemplateCharacters~opt~ ${

TemplateTail :: See 11.8.6

} TemplateCharacters~opt~ `

TemplateCharacters :: See 11.8.6

TemplateCharacter TemplateCharacters~opt~

TemplateCharacter :: See 11.8.6

$ [lookahead ≠ { ]
\ EscapeSequence
LineContinuation
LineTerminatorSequencei
SourceCharacter BUT NOT ONE OF ` OR \ OR $ OR LineTerminator


Expressions

IdentifierReference~[Yield]~ : See 12.1

Identifier
[~Yield] YIELD

BindingIdentifier~[Yield]~ : See 12.1

  _Identifier
  _[~Yield] YIELD

LabelIdentifier~[Yield]~ : See 12.1

Identifier
[~Yield] YIELD

Identifier : See 12.1

IdentifierName BUT NOT ReservedWord

PrimaryExpression~[Yield]~ : See 12.2

THIS
IdentifierReference~[?Yield]~
Literal
ArrayLiteral~[?Yield]~
ObjectLiteral~[?Yield]~
FunctionExpression
ClassExpression
GeneratorExpression
RegularExpressionLiteral
TemplateLiteral~[?Yield]~
CoverParenthesizedExpressionAndArrowParameterList~[?Yield]~

CoverParenthesizedExpressionAndArrowParameterList~[Yield]~ : See 12.2

( Expression~[In,\ ?Yield]~ )
( )
( ... BindingIdentifier~[?Yield]~ )
( Expression~[In,\ ?Yield]~ , ... BindingIdentifier~[?Yield]~ )

When processing the production

PrimaryExpression~[Yield]~ :
CoverParenthesizedExpressionAndArrowParameterList_~[?Yield]~
_the interpretation of
CoverParenthesizedExpressionAndArrowParameterList is refined using the
following grammar:

ParenthesizedExpression~[Yield]~ : See 12.2

( Expression~[In,\ ?Yield]~ )

Literal : See 12.2.3

NullLiteral
BooleanLiteral
NumericLiteral
StringLiteral

ArrayLiteral~[Yield]~ : See 12.2.4

[ Elision~opt~ ]
[ ElementList~[?Yield]~ ]
[ ElementList~[?Yield]~ , Elision~opt~ ]

ElementList~[Yield]~ : See 12.2.4

Elision~opt~ AssignmentExpression~[In,\ ?Yield]~
Elision~opt~ SpreadElement~[?Yield]~
ElementList~[?Yield]~ , Elision~opt~ AssignmentExpression~[In,\ ?Yield]~
ElementList~[?Yield]~ , Elision~opt~ SpreadElement~[?Yield]~

Elision : See 12.2.4

,
Elision ,

SpreadElement~[Yield]~ : See 12.2.4

... AssignmentExpression~[In,\ ?Yield]~

ObjectLiteral~[Yield]~ : See 12.2.5

{ }
{ PropertyDefinitionList~[?Yield]~ }
{ PropertyDefinitionList~[?Yield]~ , }

PropertyDefinitionList~[Yield]~ : See 12.2.5

PropertyDefinition~[?Yield]~
PropertyDefinitionList~[?Yield]~ , PropertyDefinition~[?Yield]~

PropertyDefinition~[Yield]~ : See 12.2.5

IdentifierReference~[?Yield]~
CoverInitializedName~[?Yield]~
PropertyName~[?Yield]~ : AssignmentExpression~[In,\ ?Yield]~
MethodDefinition~[?Yield]~

PropertyName~[Yield,GeneratorParameter]~ : See 12.2.5

LiteralPropertyName
[+GeneratorParameter] ComputedPropertyName
[~GeneratorParameter] ComputedPropertyName~[?Yield]~

LiteralPropertyName : See 12.2.5

IdentifierName
StringLiteral
NumericLiteral

ComputedPropertyName~[Yield]~ : See 12.2.5

[ AssignmentExpression~[In,\ ?Yield]~ ]

CoverInitializedName~[Yield]~ : See 12.2.5

IdentifierReference~[?Yield]~ Initializer~[In,\ ?Yield]~

Initializer~[In,\ Yield]~ : See 12.2.5

= AssignmentExpression~[?In,\ ?Yield]~

TemplateLiteral~[Yield]~ : See 12.2.8

NoSubstitutionTemplate
TemplateHead Expression~[In,\ ?Yield]~ [Lexical goal
InputElementTemplateTail] TemplateSpans~[?Yield]~

TemplateSpans~[Yield]~ : See 12.2.8

TemplateTail
TemplateMiddleList~[?Yield]~ [Lexical goal InputElementTemplateTail]
TemplateTail

TemplateMiddleList~[Yield]~ : See 12.2.8

TemplateMiddle Expression~[In,\ ?Yield]~
TemplateMiddleList~[?Yield]~ [Lexical goal InputElementTemplateTail]
TemplateMiddle Expression~[In,\ ?Yield]~

MemberExpression~[Yield]~ : See 12.3

[Lexical goal InputElementRegExp] PrimaryExpression~[?Yield]~
MemberExpression~[?Yield]~ [ Expression~[In,\ ?Yield]~ ]
MemberExpression~[?Yield]~ . IdentifierName
MemberExpression~[?Yield]~ TemplateLiteral~[?Yield]~
SuperProperty~[?Yield]~
MetaProperty
NEW MemberExpression~[?Yield]~ Arguments~[?Yield]~

SuperProperty~[Yield]~ : See 12.3

SUPER [ Expression~[In,\ ?Yield]~ ]
SUPER . IdentifierName

MetaProperty : See 12.3

NEW . TARGET

NewExpression~[Yield]~ : See 12.3

MemberExpression~[?Yield]~
NEW NewExpression~[?Yield]\ ~

CallExpression~[Yield]~ : See 12.3

MemberExpression~[?Yield]~ Arguments~[?Yield]~
SuperCall~[?Yield]~
CallExpression~[?Yield]~ Arguments~[?Yield]~
CallExpression~[?Yield]~ [ Expression~[In,\ ?Yield]~ ]
CallExpression~[?Yield]~ . IdentifierName
CallExpression~[?Yield]~ TemplateLiteral~[?Yield]~

SuperCall~[Yield]~ : See 12.3

SUPER Arguments~[?Yield]~

Arguments~[Yield]~ : See 12.3

( )
( ArgumentList~[?Yield]~ )

ArgumentList~[Yield]~ : See 12.3

AssignmentExpression~[In,\ ?Yield]~
... AssignmentExpression~[In,\ ?Yield]~
ArgumentList~[?Yield]~ , AssignmentExpression~[In,\ ?Yield]~
ArgumentList~[?Yield]~ , ... AssignmentExpression~[In,\ ?Yield]~

LeftHandSideExpression~[Yield]~ : See 12.3

NewExpression~[?Yield]~
CallExpression~[?Yield]~

PostfixExpression~[Yield]~ : See 12.4

LeftHandSideExpression~[?Yield]~
LeftHandSideExpression~[?Yield]~ [no LineTerminator here] ++
LeftHandSideExpression~[?Yield]~ [no LineTerminator here] --

UnaryExpression~[Yield]~ : See 12.5

PostfixExpression~[?Yield]~
DELETE UnaryExpression~[?Yield]~
VOID UnaryExpression~[?Yield]~
TYPEOF UnaryExpression~[?Yield]~
++ UnaryExpression~[?Yield]~
-- UnaryExpression~[?Yield]~
+ UnaryExpression~[?Yield]~
- UnaryExpression~[?Yield]~
~ UnaryExpression~[?Yield]~
! UnaryExpression~[?Yield]~

MultiplicativeExpression~[Yield]~ : See 12.6

UnaryExpression~[?Yield]~
MultiplicativeExpression~[?Yield]~ MultiplicativeOperator
UnaryExpression~[?Yield]~

MultiplicativeOperator : ONE OF See 12.6

* / %

AdditiveExpression~[Yield]~ : See 12.7

MultiplicativeExpression~[?Yield]~
AdditiveExpression~[?Yield]~ + MultiplicativeExpression~[?Yield]~
AdditiveExpression~[?Yield]~ - MultiplicativeExpression~[?Yield]~

ShiftExpression~[Yield]~ : See 12.8

AdditiveExpression~[?Yield]~
ShiftExpression~[?Yield]~ << AdditiveExpression~[?Yield]~
ShiftExpression~[?Yield]~ >> AdditiveExpression~[?Yield]~
ShiftExpression~[?Yield]~ >>> AdditiveExpression~[?Yield]~

RelationalExpression~[In,\ Yield]~ : See 12.9

ShiftExpression~[?Yield]~
RelationalExpression~[?In,\ ?Yield]~ < ShiftExpression~[?Yield]~
RelationalExpression~[?In,\ ?Yield]~ > ShiftExpression~[?Yield]~
RelationalExpression~[?In,\ ?Yield]~ <= ShiftExpression~[?\ Yield]~
RelationalExpression~[?In,\ ?Yield]~ >= ShiftExpression~[?Yield]~
RelationalExpression~[?In,\ ?Yield]~ INSTANCEOF
ShiftExpression~[?Yield]~
[+In] RelationalExpression~[In,\ ?Yield]~ IN ShiftExpression~[?Yield]~

EqualityExpression~[In,\ Yield]~ : See 12.10

RelationalExpression~[?In,\ ?Yield]~
EqualityExpression~[?In,\ ?Yield]~ ==
RelationalExpression~[?In,\ ?Yield]~
EqualityExpression~[?In,\ ?Yield]~ !=
RelationalExpression~[?In,\ ?Yield]~
EqualityExpression~[?In,\ ?Yield]~ ===
RelationalExpression~[?In,\ ?Yield]~
EqualityExpression~[?In,\ ?Yield]~ !==
RelationalExpression~[?In,\ ?Yield]~

BitwiseANDExpression~[In,\ Yield]~ : See 12.11

EqualityExpression~[?In,\ ?Yield]~
BitwiseANDExpression~[?In,\ ?Yield]~ &
EqualityExpression~[?In,\ ?Yield]~

BitwiseXORExpression~[In,\ Yield]~ : See 12.11

BitwiseANDExpression~[?In,\ ?Yield]~
BitwiseXORExpression~[?In,\ ?Yield]~ ^
BitwiseANDExpression~[?In,\ ?Yield]~

BitwiseORExpression~[In,\ Yield]~ : See 12.11

BitwiseXORExpression~[?In,\ ?Yield]~
BitwiseORExpression~[?In,\ ?Yield]~ |
BitwiseXORExpression~[?In,\ ?Yield]~

LogicalANDExpression~[In,\ Yield]~ : See 12.12

BitwiseORExpression~[?In,\ ?Yield]~
LogicalANDExpression~[?In,\ ?Yield]~ &&
BitwiseORExpression~[?In,\ ?Yield]~

LogicalORExpression~[In,\ Yield]~ : See 12.12

LogicalANDExpression~[?In,\ ?Yield]~
LogicalORExpression~[?In,\ ?Yield]~ ||
LogicalANDExpression~[?In,\ ?Yield]~

ConditionalExpression~[In,\ Yield]~ : See 12.13

LogicalORExpression~[?In,\ ?Yield]~
LogicalORExpression~[?In,?Yield]~ ? AssignmentExpression~[In,\ ?Yield]~
: AssignmentExpression~[?In,\ ?Yield]~

AssignmentExpression~[In,\ Yield]~ : See 12.14

ConditionalExpression~[?In,\ ?Yield]~
[+Yield] YieldExpression~[?In]~
ArrowFunction~[?In,\ ?Yield]~
LeftHandSideExpression~[?Yield]~ = AssignmentExpression~[?In,\ ?Yield]~
LeftHandSideExpression~[?Yield]~ AssignmentOperator
AssignmentExpression~[?In,\ ?Yield]~

AssignmentOperator : ONE OF See 12.14

  ---- ---- ---- ---- ---- ----- ----- ------ ---- ---- ----
  *=   /=   %=   +=   -=   <<=   >>=   >>>=   &=   ^=   |=
  ---- ---- ---- ---- ---- ----- ----- ------ ---- ---- ----

Expression~[In,\ Yield]~ : See 12.15

AssignmentExpression~[?In,\ ?Yield]~
Expression~[?In,\ ?Yield]~ , AssignmentExpression~[?In,\ ?Yield]~


Statements

Statement~[Yield,\ Return]~ : See clause 13

BlockStatement~[?Yield,\ ?Return]~
VariableStatement~[?Yield]~
EmptyStatement
ExpressionStatement~[?Yield]~
IfStatement~[?Yield,\ ?Return]~
BreakableStatement~[?Yield,\ ?Return]~
ContinueStatement~[?Yield]~
BreakStatement~[?Yield]~
[+Return] ReturnStatement~[?Yield]~
WithStatement~[?Yield,\ ?Return]~
LabelledStatement~[?Yield,\ ?Return]~
ThrowStatement~[?Yield]~
TryStatement~[?Yield,\ ?Return]~
DebuggerStatement

Declaration~[Yield]~ : See clause 13

HoistableDeclaration ~[?Yield]~
ClassDeclaration~[?Yield]~
LexicalDeclaration~[In,\ ?Yield]~

HoistableDeclaration~[Yield,\ Default]~ : See clause 13

FunctionDeclaration~[?Yield,?Default]~
GeneratorDeclaration~[?Yield,\ ?Default]~

BreakableStatement~[Yield,\ Return]~ : See clause 13

IterationStatement~[?Yield,\ ?Return]~
SwitchStatement~[?Yield,\ ?Return]~

BlockStatement~[Yield,\ Return]~ : See 13.1

Block~[?Yield,\ ?Return]~

Block~[Yield,\ Return]~ : See 13.1

{ StatementList~[?Yield,\ ?Return]opt~ }

StatementList~[Yield,\ Return]~ : See 13.1

StatementListItem~[?Yield,\ ?Return]~
StatementList~[?Yield,\ ?Return]~ StatementListItem~[?Yield,\ ?Return]~

StatementListItem~[Yield,\ Return]~ : See 13.1

Statement~[?Yield,\ ?Return]~
Declaration~[?Yield]~

LexicalDeclaration~[In,\ Yield]~ : See 13.2.1

LetOrConst BindingList~[?In,\ ?Yield]~ ;

LetOrConst : See 13.2.1

LET
CONST

BindingList~[In,\ Yield]~ : See 13.2.1

LexicalBinding~[?In,\ ?Yield]~
BindingList~[?In,\ ?Yield]~ , LexicalBinding~[?In,\ ?Yield]~

LexicalBinding~[In,\ Yield]~ : See 13.2.1

BindingIdentifier~[?Yield]~ Initializer~[?In,\ ?Yield]opt
~BindingPattern~[?Yield]~ Initializer~[?In,\ ?Yield]~

VariableStatement~[Yield]~ : See 13.2.2

VAR VariableDeclarationList~[In,\ ?Yield]~ ;

VariableDeclarationList~[In,\ Yield]~ : See 13.2.2

VariableDeclaration~[?In,\ ?Yield]~
VariableDeclarationList~[?In,\ ?Yield]~ ,
VariableDeclaration~[?In,\ ?Yield]~

VariableDeclaration~[In,\ Yield]~ : See 13.2.2

BindingIdentifier~[?Yield]~ Initializer~[?In,\ ?Yield]opt
~BindingPattern~[Yield]~ Initializer~[?In,\ ?Yield]~

BindingPattern~[Yield,GeneratorParameter]~ : See 13.2.3

ObjectBindingPattern~[?Yield,?GeneratorParameter]~
ArrayBindingPattern~[?Yield,?GeneratorParameter]~

ObjectBindingPattern~[Yield,GeneratorParameter]~ : See 13.2.3

{ }
{ BindingPropertyList~[?Yield,?GeneratorParameter]~ }
{ BindingPropertyList~[?Yield,?GeneratorParameter]~ , }

ArrayBindingPattern~[Yield,GeneratorParameter]~ : See 13.2.3

[ Elision~opt~ BindingRestElement~[?Yield,\ ?GeneratorParameter]opt~ ]
[ BindingElementList~[?Yield,\ ?GeneratorParameter]~ ]
[ BindingElementList~[?Yield,\ ?GeneratorParameter]~ , Elision~opt~
BindingRestElement~[?Yield,\ ?GeneratorParameter]opt~ ]

BindingPropertyList~[Yield,GeneratorParameter]~ : See 13.2.3

BindingProperty~[?Yield,\ ?GeneratorParameter]~
BindingPropertyList~[?Yield,\ ?GeneratorParameter]~ ,
BindingProperty~[?Yield,\ ?GeneratorParameter]~

BindingElementList~[Yield,GeneratorParameter]~ : See 13.2.3

BindingElisionElement~[?Yield,\ ?GeneratorParameter]~
BindingElementList~[?Yield,\ ?GeneratorParameter]~ ,
BindingElisionElement~[?Yield,\ ?GeneratorParameter]~

BindingElisionElement~[Yield,GeneratorParameter]~ : See 13.2.3

Elision~opt~ BindingElement~[?Yield,\ ?GeneratorParameter]~

BindingProperty~[Yield,GeneratorParameter]~ : See 13.2.3

SingleNameBinding~[?Yield,\ ?GeneratorParameter]
~ PropertyName~[?Yield,\ ?GeneratorParameter]~ :
BindingElement~[?Yield,\ ?GeneratorParameter]~

BindingElement~[Yield,\ GeneratorParameter\ ]~ : See 13.2.3

SingleNameBinding~[?Yield,\ ?GeneratorParameter]
~[+GeneratorParameter] BindingPattern~[?Yield,GeneratorParameter]~
Initializer~[In]opt~
[~GeneratorParameter] BindingPattern~[?Yield]~
Initializer~[In,\ ?Yield]opt~

SingleNameBinding~[Yield,GeneratorParameter]~ : See 13.2.3

[+GeneratorParameter] BindingIdentifier~[Yield]~ Initializer~[In]opt~
[~GeneratorParameter] BindingIdentifier~[?Yield]~
Initializer~[In,\ ?Yield]opt~

BindingRestElement~[Yield,\ GeneratorParameter]~ : See 13.2.3

[+GeneratorParameter]... BindingIdentifier~[Yield]~
[~GeneratorParameter] ... BindingIdentifier~[?Yield]~

EmptyStatement : See 13.3

;

ExpressionStatement~[Yield]~ : See 13.4

[lookahead ∉ {{, FUNCTION, CLASS, LET [ }] Expression~[In,\ ?Yield]~ ;

IfStatement~[Yield,\ Return]~ : See 13.5

IF ( Expression~[In,\ ?Yield]~ ) Statement~[?Yield,\ ?Return]~ ELSE
Statement~[?Yield,\ ?Return]~
IF ( Expression~[In,\ ?Yield]~ ) Statement~[?Yield,\ ?Return]~

IterationStatement~[Yield,\ Return]~ : See 13.6

  DO Statement~[?Yield,\ ?Return]~ WHILE ( Expression~[In,\ ?Yield]~ )
  ;~opt~

  WHILE ( Expression~[In,\ ?Yield]~ ) Statement~[?Yield,\ ?Return]~

  FOR ( [lookahead ∉ {LET [ }] Expression~[?Yield]opt~ ;
  Expression~[In,\ ?Yield]opt~ ; Expression~[In,\ ?Yield]opt~ )
  Statement~[?Yield,\ ?Return]~

  FOR ( VAR VariableDeclarationList~[?Yield]~;
  Expression~[In,\ ?Yield]opt~ ; Expression~[In,\ ?Yield]opt~ )
  Statement~[?Yield,\ ?Return]~

  FOR ( LexicalDeclaration~[?Yield]~ Expression~[In,\ ?Yield]opt~ ;
  Expression~[In,\ ?Yield]opt~ ) Statement~[?Yield,\ ?Return]~

  FOR ([lookahead ∉ {LET [ }] LeftHandSideExpression~[?Yield]~ IN
  Expression~[In,\ ?Yield]~ ) Statement~[?Yield,\ ?Return]~

  FOR ( VAR ForBinding~[?Yield]~ IN Expression~[In,\ ?Yield]~ )
  Statement~[?Yield,\ ?Return]~

  FOR ( ForDeclaration~[?Yield]~ IN Expression~[In,\ ?Yield]~ )
  Statement~[?Yield,\ ?Return]~

  FOR ([lookahead ≠ LET] LeftHandSideExpression~[?Yield]~ OF
  AssignmentExpression~[In,\ ?Yield]~ ) Statement~[?Yield, ?Return]~

  FOR ( VAR ForBinding~[?Yield]~ OF AssignmentExpression~[In,\ ?Yield]~
  ) Statement~[?Yield,\ ?Return]~

  FOR ( ForDeclaration~[?Yield]~ OF AssignmentExpression~[In,\ ?Yield]~
  ) Statement~[?Yield,\ ?Return]~

ForDeclaration~[Yield]~ : See 13.6

LetOrConst ForBinding~[?Yield]~

ForBinding~[Yield]~ : See 13.6

BindingIdentifier~[?Yield]~
BindingPattern~[?Yield]~

ContinueStatement~[Yield]~ : See 13.7

CONTINUE ;
CONTINUE [no LineTerminator here] LabelIdentifier~[?Yield]~ ;

BreakStatement~[Yield]~ : See 13.8

BREAK ;
BREAK [no LineTerminator here] LabelIdentifier~[?Yield]~ ;

ReturnStatement~[Yield]~ : See 13.9

RETURN ;
RETURN [no LineTerminator here] Expression~[In,\ ?Yield]~ ;

WithStatement~[Yield,\ Return]~ : See 13.10

WITH ( Expression~[In,\ ?Yield]~ ) Statement~[?Yield,\ ?Return]~

SwitchStatement~[Yield,\ Return]~ : See 13.11

SWITCH ( Expression~[In,\ ?Yield]~ ) CaseBlock~[?Yield,\ ?Return]~

CaseBlock~[Yield,\ Return]~ : See 13.11

{ CaseClauses~[?Yield,\ ?Return]opt~ }
{ CaseClauses~[?Yield,\ ?Return]opt~ DefaultClause~[?Yield,\ ?Return]~
CaseClauses~[?Yield,\ ?Return]opt~ }

CaseClauses~[Yield,\ Return]~ : See 13.11

CaseClause~[?Yield,\ ?Return]~
CaseClauses~[?Yield,\ ?Return]~ CaseClause~[?Yield,\ ?Return]~

CaseClause~[Yield,\ Return]~ : See 13.11

CASE Expression~[In,\ ?Yield]~ : StatementList~[?Yield,\ ?Return]opt~

DefaultClause~[Yield,\ Return]~ : See 13.11

DEFAULT : StatementList~[?Yield,\ ?Return]opt~

LabelledStatement~[Yield,\ Return]~ : See 13.12

LabelIdentifier~[?Yield]~ : LabelledItem~[?Yield,\ ?Return]~

LabelledItem~[Yield,\ Return]~ : See 13.12

Statement~[?Yield,\ ?Return]
~FunctionDeclaration~[?Yield]~

ThrowStatement~[Yield]~ : See 13.13

THROW [no LineTerminator here] Expression~[In,\ ?Yield]~ ;

TryStatement~[Yield,\ Return]~ : See 13.14

TRY Block~[?Yield,\ ?Return]~ Catch~[?Yield,\ ?Return]
~TRY Block~[?Yield,\ ?Return]~ Finally~[?Yield,\ ?Return]
~TRY Block~[?Yield,\ ?Return]~ Catch~[?Yield,\ ?Return]~
Finally~[?Yield,\ ?Return]~

Catch~[Yield,\ Return]~ : See 13.14

CATCH ( CatchParameter~[?Yield]~ ) Block~[?Yield,\ ?Return]~

Finally~[Yield,\ Return]~ : See 13.14

FINALLY Block~[?Yield,\ ?Return]~

CatchParameter~[Yield]~ : See 13.14

BindingIdentifier~[?Yield]
~BindingPattern~[?Yield]~

DebuggerStatement : See 13.15

DEBUGGER ;


Functions and Classes

FunctionDeclaration~[Yield,\ Default]~ : See 14.1

FUNCTION BindingIdentifier~[?Yield]~ ( FormalParameters ) { FunctionBody
}
[+Default] FUNCTION ( FormalParameters ) { FunctionBody }

FunctionExpression : See 14.1

FUNCTION BindingIdentifier~opt~ ( FormalParameters ) { FunctionBody }

StrictFormalParameters~[Yield,\ GeneratorParameter]~ : See 14.1

FormalParameters~[?Yield,\ ?GeneratorParameter]~

FormalParameters~[Yield,GeneratorParameter]~ : See 14.1

[empty]
FormalParameterList~[?Yield,\ ?GeneratorParameter]~

FormalParameterList~[Yield,GeneratorParameter]~ : See 14.1

FunctionRestParameter~[?Yield]~
FormalsList~[?Yield,\ ?GeneratorParameter]~
FormalsList~[?Yield,\ ?GeneratorParameter]~,
FunctionRestParameter~[?Yield]~

FormalsList~[Yield,GeneratorParameter]~ : See 14.1

FormalParameter~[?Yield,\ ?GeneratorParameter]~
FormalsList~[?Yield,\ ?GeneratorParameter]~ ,
FormalParameter~[?Yield,?GeneratorParameter]~

FunctionRestParameter~[Yield]~ : See 14.1

BindingRestElement~[?Yield]~

FormalParameter~[Yield,GeneratorParameter]~ : See 14.1

BindingElement~[?Yield,\ ?GeneratorParameter]~

FunctionBody~[Yield]~ : See 14.1

FunctionStatementList~[?Yield]~

FunctionStatementList~[Yield]~ : See 14.1

StatementList~[?Yield,\ Return]opt~

ArrowFunction~[In,\ Yield]~ : See 14.2

ArrowParameters~[?Yield]~ [no LineTerminator here] =>
ConciseBody~[?In]~

ArrowParameters~[Yield]~ : See 14.2

BindingIdentifier~[?Yield]~
CoverParenthesizedExpressionAndArrowParameterList~[?Yield]~

ConciseBody~[In]~ : See 14.2

[lookahead ≠ {] AssignmentExpression~[?In]~
{ FunctionBody }

When the production

ArrowParameters~[Yield]~ :
CoverParenthesizedExpressionAndArrowParameterList~[?Yield]~

is recognized the following grammar is used to refine the interpretation
of CoverParenthesizedExpressionAndArrowParameterList:

ArrowFormalParameters~[Yield,\ GeneratorParameter]~ : See 14.2

( StrictFormalParameters~[?Yield,\ ?GeneratorParameter]~ )

MethodDefinition~[Yield]~ : See 14.3

PropertyName~[?Yield]~ ( StrictFormalParameters ) { FunctionBody }
GeneratorMethod~[?Yield]~
GET PropertyName~[?Yield]~ ( ) { FunctionBody }
SET PropertyName~[?Yield]~ ( PropertySetParameterList ) { FunctionBody }

PropertySetParameterList : See 14.3

FormalParameter

GeneratorMethod~[Yield]~ : See 14.4

* PropertyName~[?Yield]~
(StrictFormalParameters~[Yield,GeneratorParameter]~ ) {
GeneratorBody~[Yield]~ }

GeneratorDeclaration~[Yield,\ Default]~ : See 14.4

FUNCTION * BindingIdentifier~[?Yield]~ (
FormalParameters~[Yield,GeneratorParameter]~ ) { GeneratorBody~[Yield]~
}
[+Default] FUNCTION * ( FormalParameters~[Yield,GeneratorParameter]~ ) {
GeneratorBody~[Yield]~ }

GeneratorExpression : See 14.4

FUNCTION * BindingIdentifier~[Yield]opt~ (
FormalParameters~[Yield,GeneratorParameter]~ ) { GeneratorBody~[Yield]~
}

GeneratorBody~[Yield]~ : See 14.4

FunctionBody~[?Yield]~

YieldExpression~[In]~ : See 14.4

YIELD
YIELD [no LineTerminator here] [Lexical goal InputElementRegExp]
AssignmentExpression~[?In,\ Yield]~
YIELD [no LineTerminator here] * [Lexical goal InputElementRegExp]
AssignmentExpression~[?In,\ Yield]~

ClassDeclaration~[Yield,\ Default]~ : See 14.5

CLASS BindingIdentifier~[?Yield]~ ClassTail~[?Yield]~
[+Default] CLASS ClassTail~[?Yield]~

ClassExpression~[Yield,GeneratorParameter]~ : See 14.5

CLASS BindingIdentifier~[?Yield]opt~
ClassTail~[?Yield,?GeneratorParameter]~

ClassTail~[Yield,GeneratorParameter]~ : See 14.5

[~GeneratorParameter] ClassHeritage~[?Yield]opt~ {
ClassBody~[?Yield]opt~ }
[+GeneratorParameter] ClassHeritage~opt~ { ClassBody~opt~ }

ClassHeritage~[Yield]~ : See 14.5

EXTENDS LeftHandSideExpression~[?Yield]~

ClassBody~[Yield]~ : See 14.5

ClassElementList~[?Yield]~

ClassElementList~[Yield]~ : See 14.5

ClassElement~[?Yield]~
ClassElementList~[?Yield]~ ClassElement~[?Yield]~

ClassElement~[Yield]~ : See 14.5

MethodDefinition~[?Yield]~
STATIC MethodDefinition~[?Yield]~
;


Scripts and Modules

Script : See 15.1

ScriptBody~opt~

ScriptBody : See 15.1

StatementList

Module : See 15.2

ModuleBody~opt~

ModuleBody : See 15.2

ModuleItemList

ModuleItemList : See 15.2

ModuleItem
ModuleItemList ModuleItem

ModuleItem : See 15.2

ImportDeclaration
ExportDeclaration
StatementListItem

ImportDeclaration : See 15.2.2

IMPORT ImportClause FromClause ;
IMPORT ModuleSpecifier ;

ImportClause : See 15.2.2

ImportedDefaultBinding
NameSpaceImport
NamedImports
ImportedDefaultBinding , NameSpaceImport
ImportedDefaultBinding , NamedImports

ImportedDefaultBinding : See 15.2.2

ImportedBinding

NameSpaceImport : See 15.2.2

* AS ImportedBinding

NamedImports : See 15.2.2

{ }
{ ImportsList }
{ ImportsList , }

FromClause : See 15.2.2

FROM ModuleSpecifier

ImportsList : See 15.2.2

ImportSpecifier
ImportsList , ImportSpecifier

ImportSpecifier : See 15.2.2

ImportedBinding
IdentifierName AS ImportedBinding

ModuleSpecifier : See 15.2.2

StringLiteral

ImportedBinding : See 15.2.2

BindingIdentifier

ExportDeclaration : See 15.2.3

EXPORT * FromClause ;
EXPORT ExportClause FromClause ;
EXPORT ExportClause ;
EXPORT VariableStatement
EXPORT Declaration
EXPORT DEFAULT HoistableDeclaration~[Default]
~EXPORT DEFAULT ClassDeclaration~[Default]~
EXPORT DEFAULT [lookahead ∉ { FUNCTION, CLASS }]
AssignmentExpression~[In]~ ;

ExportClause : See 15.2.3

{ }
{ ExportsList }
{ ExportsList , }

ExportsList : See 15.2.3

ExportSpecifier
ExportsList , ExportSpecifier

ExportSpecifier : See 15.2.3

IdentifierName
IdentifierName AS IdentifierName


Number Conversions

StringNumericLiteral ::: See 7.1.3.1

StrWhiteSpace~opt~
StrWhiteSpace~opt~ StrNumericLiteral StrWhiteSpace~opt~

StrWhiteSpace ::: See 7.1.3.1

StrWhiteSpaceChar StrWhiteSpace~opt~

StrWhiteSpaceChar ::: See 7.1.3.1

WhiteSpace
LineTerminator

StrNumericLiteral ::: See 7.1.3.1

StrDecimalLiteral
BinaryIntegerLiteral
OctalIntegerLiteral
HexIntegerLiteral

StrDecimalLiteral ::: See 7.1.3.1

StrUnsignedDecimalLiteral
+ StrUnsignedDecimalLiteral
- StrUnsignedDecimalLiteral

StrUnsignedDecimalLiteral ::: See 7.1.3.1

INFINITY
DecimalDigits . DecimalDigits~opt~ ExponentPart~opt~
. DecimalDigits ExponentPart~opt~
DecimalDigits ExponentPart~opt~

DecimalDigits ::: See 7.1.3.1

DecimalDigit
DecimalDigits DecimalDigit

DecimalDigit ::: ONE OF See 7.1.3.1

0 1 2 3 4 5 6 7 8 9

ExponentPart ::: See 7.1.3.1

ExponentIndicator SignedInteger

ExponentIndicator ::: ONE OF See 7.1.3.1

E E

SignedInteger ::: See 7.1.3.1

DecimalDigits
+ DecimalDigits
- DecimalDigits

HexIntegerLiteral ::: See 7.1.3.1

0X HexDigit
0X HexDigit
HexIntegerLiteral HexDigit

HexDigit ::: ONE OF See 7.1.3.1

0 1 2 3 4 5 6 7 8 9 A B C D E F A B C D E F

All grammar symbols not explicitly defined by the StringNumericLiteral
grammar have the definitions used in the Lexical Grammar for numeric
literals (11.8.3)


Universal Resource Identifier Character Classes

uri ::: See 18.2.6.1

uriCharacters~opt~

uriCharacters ::: See 18.2.6.1

uriCharacter uriCharacters~opt~

uriCharacter ::: See 18.2.6.1

uriReserved
uriUnescaped
uriEscaped

uriReserved ::: ONE OF See 18.2.6.1

; / ? : @ & = + $ ,

uriUnescaped ::: See 18.2.6.1

uriAlpha
DecimalDigit
uriMark

uriEscaped ::: See 18.2.6.1

% HexDigit HexDigit

uriAlpha ::: ONE OF See 18.2.6.1

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

uriMark ::: ONE OF See 18.2.6.1

- _ . ! ~ * ' ( )


Regular Expressions

Pattern~[U]~ :: See 21.2.1

Disjunction~[?U]~

Disjunction~[U]~ :: See 21.2.1

Alternative~[?U]~
 Alternative~[?U]~ | Disjunction~[?U]~

Alternative~[U]~ :: See 21.2.1

[empty]
Alternative~[?U]~ Term~[?U]~

Term~[U]~ :: See 21.2.1

Assertion~[?U]~
Atom~[?U]~
Atom~[?U]~ Quantifier

Assertion~[U]~ :: See 21.2.1

^
$
\ B
\ B
( ? = Disjunction~[?U]~ )
( ? ! Disjunction~[?U]~ )

Quantifier :: See 21.2.1

QuantifierPrefix
QuantifierPrefix ?

QuantifierPrefix :: See 21.2.1

*
+
?
{ DecimalDigits }
{ DecimalDigits , }
{ DecimalDigits , DecimalDigits }

Atom~[U]~ :: See 21.2.1

PatternCharacter
.
\ AtomEscape~[?U]~
CharacterClass~[?U]~
( Disjunction~[?U]~ )
( ? : Disjunction~[?U]~ )

SyntaxCharacter :: ONE OF See 21.2.1

^ $ \ . * + ? ( ) [ ] { } |

PatternCharacter :: See 21.2.1

SourceCharacter BUT NOT SyntaxCharacter

AtomEscape~[U]~ :: See 21.2.1

DecimalEscape
CharacterEscape~[?U]~
CharacterClassEscape

CharacterEscape~[U]~ :: See 21.2.1

ControlEscape
C ControlLetter
HexEscapeSequence
RegExpUnicodeEscapeSequence~[?U]~
IdentityEscape~[?U]~

ControlEscape :: ONE OF See 21.2.1

F N R T V

ControlLetter :: ONE OF See 21.2.1

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

RegExpUnicodeEscapeSequence~[U]~ :: See 21.2.1

[+U] U LeadSurrogate \U TrailSurrogate
U Hex4Digits
[+U] U{ HexDigits }

LeadSurrogate :: See 21.2.1

Hex4Digits [match only if the SV of Hex4Digits is in the inclusive range
0xD800 to 0xDBFF]

TrailSurrogate :: See 21.2.1

Hex4Digits [match only if the SV of Hex4Digits is in the inclusive range
0xDC00 to 0xDFFF]

IdentityEscape~[U]~ :: See 21.2.1

[+U] SyntaxCharacter
[~U] SourceCharacter BUT NOT UnicodeIDContinue

DecimalEscape :: See 21.2.1

DecimalIntegerLiteral [lookahead ∉ DecimalDigit]

CharacterClassEscape :: ONE OF See 21.2.1

D D S S W W

CharacterClass~[U]~ :: See 21.2.1

[ [lookahead ∉ {^}] ClassRanges~[?U]~ ]
[ ^ ClassRanges~[?U]~ ]

ClassRanges~[U]~ :: See 21.2.1

[empty]
NonemptyClassRanges~[?U]~

NonemptyClassRanges~[U]~ :: See 21.2.1

ClassAtom~[?U]~
ClassAtom~[?U]~ NonemptyClassRangesNoDash~[?U]~
ClassAtom~[?U]~ - ClassAtom~[?U]~ ClassRanges~[?U]~

NonemptyClassRangesNoDash~[U]~ :: See 21.2.1

ClassAtom~[?U]~
ClassAtomNoDash~[?U]~ NonemptyClassRangesNoDash~[?U]~
ClassAtomNoDash~[?U]~ - ClassAtom~[?U]~ ClassRanges~[?U]~

ClassAtom~[U]~ :: See 21.2.1

-
ClassAtomNoDash~[?U]~

ClassAtomNoDash~[U]~ :: See 21.2.1

SourceCharacter BUT NOT ONE OF \ OR ] OR -
\ ClassEscape~[?U]~

ClassEscape~[U]~ :: See 21.2.1

DecimalEscape
B
[+U] -
CharacterEscape~[?U]~
CharacterClassEscape

(normative)
Additional ECMAScript Features for Web Browsers

The ECMAScript language syntax and semantics defined in this annex are
required when the ECMAScript host is a web browser. The content of this
annex is normative but optional if the ECMAScript host is not a web
browser.

1.  


    Additional Syntax

    1.  Numeric Literals

The syntax and semantics of 11.8.3 is extended as follows except that
this extension is not allowed for strict mode code:

Syntax

NumericLiteral ::

DecimalLiteral
BinaryIntegerLiteral
OctalIntegerLiteral
HexIntegerLiteral
LegacyOctalIntegerLiteral

LegacyOctalIntegerLiteral ::

0 OctalDigit
LegacyOctalIntegerLiteral OctalDigit

DecimalIntegerLiteral ::

0
NonZeroDigit DecimalDigits~opt
~NonOctalDecimalIntegerLiteral

NonOctalDecimalIntegerLiteral ::

0 NonOctalDigit
LegacyOctalLikeDecimalIntegerLiteral NonOctalDigit
NonOctalDecimalIntegerLiteral DecimalDigit

LegacyOctalLikeDecimalIntegerLiteral ::

0 OctalDigit
LegacyOctalLikeDecimalIntegerLiteral OctalDigit

NonOctalDigit :: ONE OF

8 9

1.  STATIC SEMANTICS

-   The MV of LegacyOctalIntegerLiteral :: 0 OctalDigit is the MV of
    OctalDigit.

-   The MV of LegacyOctalIntegerLiteral :: LegacyOctalIntegerLiteral
    OctalDigit is (the MV of LegacyOctalIntegerLiteral times 8) plus
    the MV of OctalDigit.

-   The MV of DecimalIntegerLiteral :: NonOctalDecimalIntegerLiteral
    is the MV of NonOctalDecimalIntegerLiteral.

-   The MV of NonOctalDecimalIntegerLiteral :: 0 NonOctalDigit is
    the MV of NonOctalDigit.

-   The MV of NonOctalDecimalIntegerLiteral ::
    LegacyOctalLikeDecimalIntegerLiteral NonOctalDigit is (the MV of
    LegacyOctalLikeDecimalIntegerLiteral times 10) plus the MV of
    NonOctalDigit.

-   The MV of NonOctalDecimalIntegerLiteral ::
    NonOctalDecimalIntegerLiteral DecimalDigit is (the MV of
    NonOctalDecimalIntegerLiteral times 10) plus the MV of
    DecimalDigit.

-   The MV of LegacyOctalLikeDecimalIntegerLiteral :: 0 OctalDigit
    is the MV of OctalDigit.

-   The MV of LegacyOctalLikeDecimalIntegerLiteral ::
    LegacyOctalLikeDecimalIntegerLiteral OctalDigit is (the MV of
    LegacyOctalLikeDecimalIntegerLiteral times 10) plus the MV of
    OctalDigit.

-   The MV of NonOctalDigit :: 8 is 8.

-   The MV of NonOctalDigit :: 9 is 9.

    1.  String Literals

The syntax and semantics of 11.8.4 is extended as follows except that
this extension is not allowed for strict mode code:

Syntax

EscapeSequence ::

CharacterEscapeSequence
LegacyOctalEscapeSequence
HexEscapeSequence
UnicodeEscapeSequence

LegacyOctalEscapeSequence ::

OctalDigit [lookahead ∉ OctalDigit]
ZeroToThree OctalDigit [lookahead ∉ OctalDigit]
FourToSeven OctalDigit
ZeroToThree OctalDigit OctalDigit

ZeroToThree :: ONE OF

0 1 2 3

FourToSeven :: ONE OF

4 5 6 7

This definition of EscapeSequence is not used when parsing
TemplateCharacter (11.8.6).

1.  STATIC SEMANTICS

-   The SV of EscapeSequence :: LegacyOctalEscapeSequence is the SV
    of the LegacyOctalEscapeSequence.

-   The SV of LegacyOctalEscapeSequence :: OctalDigit is code unit
    whose value is the MV of the OctalDigit.

-   The SV of LegacyOctalEscapeSequence :: ZeroToThree OctalDigit
    is the code unit whose value is (8 times the MV of the
    ZeroToThree) plus the MV of the OctalDigit.

-   The SV of LegacyOctalEscapeSequence :: FourToSeven OctalDigit
    is the code unit whose value is (8 times the MV of the
    FourToSeven) plus the MV of the OctalDigit.

-   The SV of LegacyOctalEscapeSequence :: ZeroToThree OctalDigit
    OctalDigit is the code unit whose value is (64 (that is, 8^2^)
    times the MV of the ZeroToThree) plus (8 times the MV of the first
    OctalDigit) plus the MV of the second OctalDigit.

-   The MV of ZeroToThree :: 0 is 0.

-   The MV of ZeroToThree :: 1 is 1.

-   The MV of ZeroToThree :: 2 is 2.

-   The MV of ZeroToThree :: 3 is 3.

-   The MV of FourToSeven :: 4 is 4.

-   The MV of FourToSeven :: 5 is 5.

-   The MV of FourToSeven :: 6 is 6.

-   The MV of FourToSeven :: 7 is 7.

    1.  HTML-like Comments

The syntax and semantics of 11.4 is extended as follows except that this
extension is not allowed within module code:

Syntax

Comment ::

MultiLineComment
SingleLineComment
SingleLineHTMLOpenComment
SingleLineHTMLCloseComment
SingleLineDelimitedComment

MultiLineComment ::

/* FirstCommentLine~opt~ LineTerminator MultiLineCommentChars~opt~ */
HTMLCloseComment~opt~

FirstCommentLine ::

SingleLineDelimitedCommentChars

SingleLineHTMLOpenComment ::

<!-- SingleLineCommentChars~opt~

SingleLineHTMLCloseComment ::

LineTerminatorSequence HTMLCloseComment

SingleLineDelimitedComment ::

/* SingleLineDelimitedCommentChars~opt~ */

HTMLCloseComment ::

WhiteSpaceSequence~opt~ SingleLineDelimitedCommentSequence~opt~ -->
SingleLineCommentChars~opt~

SingleLineDelimitedCommentChars ::

SingleLineNotAsteriskChar SingleLineDelimitedCommentChars~opt~
* SingleLinePostAsteriskCommentChars~opt~

SingleLineNotAsteriskChar ::

SourceCharacter BUT NOT ONE OF * OR LineTerminator

SingleLinePostAsteriskCommentChars ::

SingleLineNotForwardSlashOrAsteriskChar
SingleLineDelimitedCommentChars~opt~
* SingleLinePostAsteriskCommentChars~opt~

SingleLineNotForwardSlashOrAsteriskChar ::

SourceCharacter BUT NOT ONE OF / OR * OR LineTerminator

WhiteSpaceSequence ::

WhiteSpace WhiteSpaceSequence~opt~

SingleLineDelimitedCommentSequence ::

SingleLineDelimitedComment WhiteSpaceSequence~opt~
SingleLineDelimitedCommentSequence~opt~

Similar to a MultiLineComment that contains a line terminator code
point, a SingleLineHTMLCloseComment is considered to be a
LineTerminator for purposes of parsing by the syntactic grammar.

Regular Expressions Patterns

The syntax of 21.2.1 is modified and extended as follows. These changes
introduce ambiguities that are broken by the ordering of grammar
productions and by contextual information. When parsing using the
following grammar, each alternative is considered only if previous
production alternatives do not match.

This alternative pattern grammar and semantics only changes the syntax
and semantics of BMP patterns. The following grammar extensions include
productions parameterized with the [U] parameter. However, none of these
extensions change the syntax of Unicode patterns recognized when parsing
with the [U] parameter present on the goal symbol.

SYNTAX

Term~[U]~ ::

[~U] ExtendedTerm
[+U] Assertion~[U]~
[+U] Atom~[U]~
[+U] Atom~[U]~ Quantifier

ExtendedTerm ::

Assertion
AtomNoBrace Quantifier
Atom
QuantifiableAssertion Quantifier

AtomNoBrace ::

PatternCharacterNoBrace
.
\ AtomEscape
CharacterClass
( Disjunction )
( ? : Disjunction )

Atom~[U]~ ::

PatternCharacter
.
\ AtomEscape~[?U]~
CharacterClass~[?U]~
( Disjunction~[?U]~ )
( ? : Disjunction~[?U]~ )

PatternCharacterNoBrace ::

SourceCharacter BUT NOT ONE OF
 ^ $ \ . * + ? ( ) [ ] { } |

PatternCharacter ::

SourceCharacter BUT NOT ONE OF
 ^ $ \ . * + ? ( ) [ ] |

QuantifiableAssertion ::

( ? = Disjunction )
( ? ! Disjunction )

Assertion~[U]~ ::

^
$
\ B
\ B
[+U] ( ? = Disjunction~[U]~ )
[+U] ( ? ! Disjunction~[U]~ )
[~U] QuantifiableAssertion

AtomEscape~[U]~ ::

[+U] DecimalEscape
[+U] CharacterEscape~[U]~
[+U] CharacterClassEscape
[~U] DecimalEscape but only if the integer value of DecimalEscape is <=
NCapturingParens
[~U] CharacterClassEscape
[~U] CharacterEscape

CharacterEscape~[U]~ ::

ControlEscape
C ControlLetter
HexEscapeSequence
RegExpUnicodeEscapeSequence~[?U]~
[~U] LegacyOctalEscapeSequence
IdentityEscape~[?U]~

IdentityEscape~[U]~ ::

[+U] SyntaxCharacter
[~U] SourceCharacter BUT NOT C

NonemptyClassRanges~[U]~ ::

ClassAtom~[?U]~
ClassAtom~[?U]~ NonemptyClassRangesNoDash~[?U]
~[+U] ClassAtom~[U]~ - ClassAtom~[U]~ ClassRanges~[U]~
[~U] ClassAtomInRange - ClassAtomInRange ClassRanges

NonemptyClassRangesNoDash~[U]~ ::

ClassAtom~[?U]~
ClassAtomNoDash~[?U]~ NonemptyClassRangesNoDash~[?U]
~[+U] ClassAtomNoDash~[U]~ - ClassAtom~[U]~ ClassRanges~[U]~
[~U] ClassAtomNoDashInRange - ClassAtomInRange ClassRanges

ClassAtom~[U]~ ::

-
ClassAtomNoDash~[?U]~

ClassAtomNoDash~[U]~ ::

SourceCharacter BUT NOT ONE OF \ OR ] OR -
\ ClassEscape~[?U]~

ClassAtomInRange ::

-
ClassAtomNoDashInRange

ClassAtomNoDashInRange ::

SourceCharacter BUT NOT ONE OF \ OR ] OR -
\ ClassEscape but only if ClassEscape evaluates to a CharSet with
exactly one character
\ IdentityEscape

ClassEscape~[U]~ ::

[+U] DecimalEscape
[+U] CharacterEscape~[U]~
[+U] CharacterClassEscape
[~U] DecimalEscape but only if the integer value of DecimalEscape is <=
NCapturingParens
B
[~U] CharacterClassEscape
[~U] CharacterEscape

1.  PATTERN SEMANTICS

The semantics of 21.2.2 is extended as follows:

Within 21.2.2.5 reference to “Atom :: ( Disjunction )” are to be
interpreted as meaning “Atom :: ( Disjunction )or AtomNoBrace :: (
Disjunction )”.

Term (21.2.2.5) includes the following additional evaluation rule:

  The production Term :: QuantifiableAssertion Quantifier
  evaluates the same as the production Term :: Atom Quantifier but
  with QuantifiableAssertion substituted for Atom.

Atom (21.2.2.8) evaluation rules for the Atom productions except for
Atom :: PatternCharacter are also used for the AtomNoBrace
productions, but with AtomNoBrace substituted for Atom. The
following evaluation rule is also added:

The production AtomNoBrace :: PatternCharacterNoBrace evaluates as
follows:

1.  Let ch be the character represented by PatternCharacterNoBrace.

2.  Let A be a one-element CharSet containing the character ch.

3.  Call CharacterSetMatcher(A, FALSE) and return its Matcher result.

CharacterEscape (21.2.2.10) includes the following additional evaluation
rule:

  The production CharacterEscape :: LegacyOctalEscapeSequence
  evaluates by evaluating the SV of the LegacyOctalEscapeSequence (see
  B.1.2) and returning its character result.

ClassAtom (21.2.2.17) includes the following additional evaluation
rules:

  The production ClassAtomInRange :: - evaluates by returning the
  CharSet containing the one character -.

  The production ClassAtomInRange :: ClassAtomNoDashInRange
  evaluates by evaluating ClassAtomNoDashInRange to obtain a CharSet
  and returning that CharSet.

ClassAtomNoDash (21.2.2.18) includes the following additional evaluation
rules:

  The production ClassAtomNoDashInRange :: SourceCharacter BUT NOT
  ONE OF \ OR ] OR - evaluates by returning a one-element CharSet
  containing the character represented by SourceCharacter.

  The production ClassAtomNoDashInRange :: \ ClassEscape but only
  if…, evaluates by evaluating ClassEscape to obtain a CharSet and
  returning that CharSet.

  The production ClassAtomNoDashInRange :: \ IdentityEscape
  evaluates by returning the character represented by IdentityEscape.


Additional Built-in Properties

When the ECMAScript host is a web browser the following additional
properties of the standard built-in objects are defined.

1.  Additional Properties of the Global Object

    1.  escape (string)

The ESCAPE function is a property of the global object. It computes a
new version of a String value in which certain code units have been
replaced by a hexadecimal escape sequence.

For those code units being replaced whose value is U+00FF or less, a
two-digit escape sequence of the form %xx is used. For those
characters being replaced whose code unit value is greater than U+00FF,
a four-digit escape sequence of the form %Uxxxx is used.

When the ESCAPE function is called with one argument string, the
following steps are taken:

1.  Let string be ToString(string).

2.  ReturnIfAbrupt(string).

3.  Let length be the number of code units in string.

4.  Let R be the empty string.

5.  Let k be 0.

6.  Repeat, while k < length,

7.  a.  Let char be the code unit (represented as a 16-bit unsigned
        integer) at index k within string.

    b.  If char is the code point of one of the 69 nonblank code units
        in
        "ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@*_+-./",
        then

    c.  i.  Let S be a String containing the single code unit char.

    d.  Else if char ≥ 256, then

    e.  i.  Let S be a String containing six code units "%Uwxyz"
            where wxyz are the code units of the four hexadecimal
            digits encoding the value of char.

    f.  Else, char < 256

        i.  Let S be a String containing three code units "%xy"
            where xy are the code units of two hexadecimal digits
            encoding the value of char.

    g.  Let R be a new String value computed by concatenating the
        previous value of R and S.

    h.  Increase k by 1.

8.  Return R.

NOTE The encoding is partly based on the encoding described in RFC 1738,
but the entire encoding specified in this standard is described above
without regard to the contents of RFC 1738. This encoding does not
reflect changes to RFC 1738 made by RFC 3986.

unescape (string)

The UNESCAPE function is a property of the global object. It computes a
new version of a String value in which each escape sequence of the sort
that might be introduced by the ESCAPE function is replaced with the
code unit that it represents.

When the UNESCAPE function is called with one argument string, the
following steps are taken:

1.  Let string be ToString(string).

2.  ReturnIfAbrupt(string).

3.  Let length be the number of code units in string.

4.  Let R be the empty String.

5.  Let k be 0.

6.  Repeat, while k ≠ length

    a.  Let c be the code unit at index k within string.

    b.  If c is %,

    c.  i.  If k ≤ length−6 and the code unit at index k+1 within
            string is U and the four code units at indices k+2,
            k+3, k+4, and k+5 within string are all hexadecimal
            digits, then

            1.  Let c be the code unit whose value is the integer
                represented by the four hexadecimal digits at indices
                k+2, k+3, k+4, and k+5 within string.

            2.  Increase k by 5.

        ii. Else if k ≤ length−3 and the two code units at indices
            k+1 and k+2 within string are both hexadecimal digits,
            then

            1.  Let c be the code unit whose value is the integer
                represented by two zeroes plus the two hexadecimal
                digits at indices k+1 and k+2 within string.

            2.  Increase k by 2.

    d.  Let R be a new String value computed by concatenating the
        previous value of R and c.

    e.  Increase k by 1.

7.  Return R.

    1.  Additional Properties of the Object.prototype Object

        1.  Object.prototype._proto_

        2.  

Object.prototype._proto_ is an accessor property with attributes {
[[Enumerable]]: FALSE, [[Configurable]]: TRUE }. The [[Get]] and [[Set]]
attributes are defined as follows

1.  get Object.prototype._proto_

2.  

The value of the [[Get]] attribute is a built-in function that requires
no arguments. It performs the following steps:

1.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(O).

3.  Return the result of calling the [[GetPrototypeOf]] internal method
    of O.

    1.  set Object.prototype._proto_

    2.  

The value of the [[Set]] attribute is a built-in function that takes an
argument proto. It performs the following steps:

1.  Let O be RequireObjectCoercible(THIS value).

2.  ReturnIfAbrupt(O).

3.  If Type(proto) is neither Object nor Null, return UNDEFINED.

4.  If Type(O) is not Object, return UNDEFINED.

5.  Let status be the result of calling the [[SetPrototypeOf]]
    internal method of O with argument proto.

6.  ReturnIfAbrupt(status).

7.  If status is FALSE, throw a TYPEERROR exception.

8.  Return UNDEFINED.

    1.  Additional Properties of the String.prototype Object

        1.  String.prototype.substr (start, length)

The SUBSTR method takes two arguments, start and length, and returns
a substring of the result of converting the THIS object to a String,
starting from index start and running for length code units (or
through the end of the String if length is UNDEFINED). If start is
negative, it is treated as (sourceLength_+_start) where sourceLength
is the length of the String. The result is a String value, not a String
object. The following steps are taken:

1.  Let O be RequireObjectCoercible(THIS value).

2.  Let S be ToString(O).

3.  ReturnIfAbrupt(S).

4.  Let intStart be ToInteger(start).

5.  ReturnIfAbrupt(intStart).

6.  If length is UNDEFINED, let end be +∞; otherwise let end be
    ToInteger(length).

7.  ReturnIfAbrupt(end).

8.  Let size be the number of code units in S.

9.  If intStart < 0, let intStart be max(size + intStart,0).

10. Let resultLength be min(max(end,0), size – intStart).

11. If resultLength ≤ 0, return the empty String "".

12. Return a String containing resultLength consecutive code units
    from S beginning with the code unit at index intStart.

The LENGTH property of the SUBSTR method is 2.

NOTE The SUBSTR function is intentionally generic; it does not require
that its THIS value be a String object. Therefore it can be transferred
to other kinds of objects for use as a method.

String.prototype.anchor ( name )

When the ANCHOR method is called with argument name, the following
steps are taken:

1.  Let S be the THIS value.

2.  Return CreateHTML(S, "A", "NAME", name).

    1.  CreateHTML ( string, tag, attribute, value ) Abstract Operation

The abstract operation CreateHTML is called with arguments _string,
tag_, attribute, and value. The arguments tag and attribute must
be string values. The following steps are taken:

1.  Let str be RequireObjectCoercible(string).

2.  Let S be ToString(str).

3.  ReturnIfAbrupt(S).

4.  Let p1 be the string value that is the concatenation of "<" and
    tag.

5.  If attribute is not the empty String, then

6.  a.  Let V be ToString(value).

    b.  ReturnIfAbrupt(V).

    c.  Let escapedV be the string value that is the same as V
        except that each occurrence of the code unit U+0022 (QUOTATION
        MARK) in V has been replaced with the six code unit sequence
        "&QUOT;".

    d.  Let p1 be the string value that is the concatenation of the
        following string values:

-   The string value of p1

-   Code unit U+0020 (SPACE)

-   The string value of attribute

-   Code unit U+003D (EQUALS SIGN)

-   Code unit U+0022 (QUOTATION MARK)

-   The string value of escapedV

-   Code unit U+0022 (QUOTATION MARK)

1.  Let p2 be the string value that is the concatenation of p1 and
    ">".

2.  Let p3 be the string value that is the concatenation of p2 and
    S.

3.  Let p4 be the string value that is the concatenation of p3,
    "</", tag, and ">".

4.  Return p4.

    1.  String.prototype.big ()

When the BIG method is called with no arguments, the following steps are
taken:

1.  Let S be the THIS value.

2.  3.  Return CreateHTML(S, "BIG", "", "").

    1.  String.prototype.blink ()

When the BLINK method is called with no arguments, the following steps
are taken:

1.  Let S be the THIS value.

2.  Return CreateHTML(S, "BLINK", "", "").

    1.  String.prototype.bold ()

When the BOLD method is called with no arguments, the following steps
are taken:

1.  Let S be the THIS value.

2.  Return CreateHTML(S, "B", "", "").

    1.  String.prototype.fixed ()

When the FIXED method is called with no arguments, the following steps
are taken:

1.  Let S be the THIS value.

2.  Return CreateHTML(S, "TT", "", "").

    1.  String.prototype.fontcolor ( color )

When the FONTCOLOR method is called with argument color, the following
steps are taken:

1.  Let S be the THIS value.

2.  Return CreateHTML(S, "FONT", "COLOR", color).

    1.  String.prototype.fontsize ( size )

When the FONTSIZE method is called with argument size, the following
steps are taken:

1.  Let S be the THIS value.

2.  Return CreateHTML(S, "FONT", "SIZE", size).

    1.  String.prototype.italics ()

When the ITALICS method is called with no arguments, the following steps
are taken:

1.  Let S be the THIS value.

2.  Return CreateHTML(S, "I", "", "").

    1.  String.prototype.link ( url )

When the LINK method is called with argument url, the following steps
are taken:

1.  Let S be the THIS value.

2.  Return CreateHTML(S, "A", "HREF", url).

    1.  String.prototype.small ()

When the SMALL method is called with no arguments, the following steps
are taken:

1.  Let S be the THIS value.

2.  Return CreateHTML(S, "SMALL", "", "").

    1.  String.prototype.strike ()

When the STRIKE method is called with no arguments, the following steps
are taken:

1.  Let S be the THIS value.

2.  Return CreateHTML(S, "STRIKE", "", "").

    1.  String.prototype.sub ()

When the SUB method is called with no arguments, the following steps are
taken:

1.  Let S be the THIS value.

2.  Return CreateHTML(S, "SUB", "", "").

    1.  String.prototype.sup ()

When the SUP method is called with no arguments, the following steps are
taken:

1.  Let S be the THIS value.

2.  Return CreateHTML(S, "SUP", "", "").

    1.  Additional Properties of the Date.prototype Object

        1.  Date.prototype.getYear ( )

NOTE The GETFULLYEAR method is preferred for nearly all purposes,
because it avoids the “year 2000 problem.”

When the GETYEAR method is called with no arguments, the following steps
are taken:

1.  Let t be this time value.

2.  ReturnIfAbrupt(t).

3.  If t is NAN, return NAN.

4.  Return YearFromTime(LocalTime(t)) − 1900.

    1.  Date.prototype.setYear (year)

NOTE The SETFULLYEAR method is preferred for nearly all purposes,
because it avoids the “year 2000 problem.”

When the SETYEAR method is called with one argument year, the
following steps are taken:

1.  Let t be LocalTime(this time value); but if this time value is
    NAN, let t be +0.

2.  Let y be ToNumber(year).

3.  ReturnIfAbrupt(y).

4.  If y is NAN, set the [[DateValue]] internal slot of this Date
    object to NAN and return NAN.

5.  If y is not NAN and 0 ≤ ToInteger(y) ≤ 99, let yyyy be
    ToInteger(y) + 1900.

6.  Else, let yyyy be y.

7.  Let d be MakeDay(yyyy, MonthFromTime(t), DateFromTime(t)).

8.  Let date be UTC(MakeDate(d, TimeWithinDay(t))).

9.  Set the [[DateValue]] internal slot of this Date object to
    TimeClip(date).

10. Return the value of the [[DateValue]] internal slot of this Date
    object.

    1.  Date.prototype.toGMTString ( )

NOTE The property TOUTCSTRING is preferred. The TOGMTSTRING property is
provided principally for compatibility with old code. It is recommended
that the TOUTCSTRING property be used in new ECMAScript code.

The Function object that is the initial value of
DATE.PROTOTYPE.TOGMTSTRING is the same Function object that is the
initial value of DATE.PROTOTYPE.TOUTCSTRING.

1.  Additional Properties of the RegExp.prototype Object

    1.  RegExp.prototype.compile (pattern, flags )

When the COMPILE method is called with arguments pattern and flags,
the following steps are taken:

1.  Let O be the THIS value.

2.  If Type(O) is not Object or Type(O) is Object and O does not
    have a [[RegExpMatcher]] internal slot, then

    a.  Throw a TYPEERROR exception.

3.  4.  5.  6.  If Type(pattern) is Object and pattern has a
    [[RegExpMatcher]] internal slot, then

    a.  b.  If flags is not UNDEFINED, throw a TYPEERROR exception.

    c.  Let P be the value of pattern’s [[OriginalSource]] internal
        slot.

    d.  Let F be the value of pattern’s [[OriginalFlags]] internal
        slot.

7.  Else,

    a.  Let P be pattern.

    b.  Let F be flags.

8.  Return RegExpInitialize(O, P, F).

NOTE The COMPILE method completely reinitializes the THIS object RegExp
with a new pattern and flags. An implementation may interpret use of
this method as an assertion that the resulting RegExp object will be
used multiple times and hence is a candidate for extra optimization.

1.  


    Other Additional Features

    1.  _proto_ Property Names in Object Initializers

The following Early Error rule is added to those in 12.2.5.1:

ObjectLiteral : { PropertyDefinitionList }

and

ObjectLiteral : { PropertyDefinitionList , }

-   It is a Syntax Error if PropertyNameList of PropertyDefinitionList
    contains any duplicate entries for "_PROTO_" and at least two of
    those entries were obtained from productions of the form
    PropertyDefinition : PropertyName : AssignmentExpression.

NOTE The List returned by PropertyNameList does not include string
literal property names defined as using a ComputedPropertyName.

In 12.2.5.9 the PropertyDefinitionEvaluation algorithm for the
production
PropertyDefinition : PropertyName : AssignmentExpression
s replaced with the following definition:

PropertyDefinition : PropertyName : AssignmentExpression

1.  Let propKey be the result of evaluating PropertyName.

2.  ReturnIfAbrupt(propKey).

3.  Let exprValueRef be the result of evaluating
    AssignmentExpression.

4.  Let propValue be GetValue(exprValueRef).

5.  ReturnIfAbrupt(propValue).

6.  If propKey is the string value "_PROTO_" and if
    IsComputedPropertyKey(propKey) is FALSE, then

    a.  If Type(propValue) is either Object or Null, then

    b.  i.  Return the result of calling the [[SetPrototypeOf]] internal
            method of object with argument propValue.

    c.  Return NormalCompletion(empty).

7.  If IsFunctionDefinition of AssignmentExpression is TRUE, then

    a.  Assert: propValue is an ECMAScript function object.

    b.  Let referencesSuper be the value of propValue’s
        [[NeedsSuper]] internal slot.

    c.  Let thisMode be the value of propValue’s [[ThisMode]]
        internal slot.

    d.  If thisMode is not lexical and referencesSuper is TRUE, then

        i.  If propValue’s [[HomeObject]] internal slot is UNDEFINED,
            then

            1.  Assert: AssignmentExpression is not a class definition
                whose constructor references SUPER.

            2.  Set the propValue’s [[HomeObject]] internal slot to
                object.

            3.  

    e.  If IsAnonymousFunctionDefinition(AssignmentExpression) is
        TRUE, then

        i.  Let hasNameProperty be HasOwnProperty(propValue,
            "NAME").

        ii. ReturnIfAbrupt(hasNameProperty).

        iii. If hasNameProperty is FALSE, perform

        iv. SetFunctionName(propValue, propKey).

8.  Assert: enumerable is TRUE.

9.  10. Return CreateDataPropertyOrThrow(object, propKey,
    propValue).

    1.  Labelled Function Declarations

Prior to the Sixth Edition, the ECMAScript specification
LabelledStatement did not allow for the association of a statement
label with a FunctionDeclaration. However, a labelled
FunctionDeclaration was an allowable extension for non-strict mode
code and most browser-hosted ECMAScript implementations supported that
extension. In the Sixth Edition, the grammar productions for
LabelledStatement permits use of FunctionDeclaration as a
LabelledItem but 13.12.1 includes an Early Error rule that produces a
Syntax Error if that occurs. For web browser compatibility, that rule is
modified with the addition of the underlined text:

LabelledItem : FunctionDeclaration

-   It is a Syntax Error if any strict mode source code matches this
    rule.

    1.  Block-Level Function Declarations Web Legacy Compatibility Semantics 

Prior to the Sixth Edition, the ECMAScript specification did not define
the occurrence of a FunctionDeclaration as an element of a Block
statement’s StatementList. However, support for that form of
FunctionDeclaration was an allowable extension and most browser-hosted
ECMAScript implementations permitted them. Unfortunately, the semantics
of such declarations differ among those implementations. Because of
these semantic differences, existing web ECMAScript code that uses
Block level function declarations is only portable among browser
implementation if the usage only depends upon the semantic intersection
of all of the browser implementations for such declarations. The
following are the use cases that fall within that intersection
semantics:

1.  A function is declared and only referenced within a single block

    -   A function declaration with the name f is declared exactly
        once within the function code of an enclosing function g and
        that declaration is nested within a Block.

    -   No other declaration of f that is not a VAR declaration occurs
        within the function code of g

    -   All references to f occur within the StatementList of the
        Block containing the declaration of f.

    -   

2.  A function is declared and possibly used within a single Block but
    also referenced by an inner function definition that is not
    contained within that same Block.

    -   A function declaration with the name f is declared exactly
        once within the function code of an enclosing function g and
        that declaration is nested within a Block.

    -   No other declaration of f that is not a VAR declaration occurs
        within the function code of g

    -   References to f may occur within the StatementList of the
        Block containing the declaration of f.

    -   -   References to f occur within the function code of g that
        lexically follows the Block containing the declaration of f.

    -   

3.  A function is declared and possibly used within a single block but
    also referenced within subsequent blocks.

    -   A function declaration with the name f is declared exactly
        once within the function code of an enclosing function g and
        that declaration is nested within a Block.

    -   No other declaration of f that is not a VAR declaration occurs
        within the function code of g

    -   References to f may occur within the StatementList of the
        Block containing the declaration of f.

    -   -   References to f occur within another function h that is
        nested within g and no other declaration of f shadows the
        references to f from within h.

    -   All invocations of h occur after the declaration of f has
        been evaluated.

The first use case is interoperable with the semantics of Block level
function declarations provided by ECMA-262 Edition 6. Any pre-existing
ECMAScript code that employees that use case will operate using the
Block level function declarations semantics defined by clauses 9, 13,
and 14 of this specification.

Sixth edition interoperability for the second and third use cases
requires the following extensions to the clause 9 and clause 14
semantics. These extensions are applied to each non-strict mode function
g for each FunctionDeclaration f that is directly contained in the
StatementList of a Block, CaseClause, or DefaultClause that is
part of the function code of g

1.  Let F be StringValue of the BindingIdentifier of
    FunctionDeclaration f.

2.  If replacing the FunctionDeclaration f with a
    VariableStatement that has F as a BindingIdentifier would not
    produce any Early Errors for g and F is not an element of
    BoundNames of FormalParameters of g, then

    a.  During FunctionDeclarationInstantiation (9.2.13) for g perform
        the following steps immediately before performing step 27:

        i.  ii. NOTE A var binding for F is only instantiated here if
            it is neither a VarDeclaredName, the name of a formal
            parameter, or another FunctionDeclarations.

        iii. iv. If instantiatedVarNames does not contain F, then

        v.  1.  Let status be the result of calling varEnvRec’s
                CreateMutableBinding concrete method passing F as the
                argument.

            2.  3.  Assert: status is never an abrupt completion.

            4.  Call the InitializeBinding concrete method of
                varEnvRec with arguments F and UNDEFINED.

            5.  Append F to instantiatedVarNames.

    b.  In place of the FunctionDeclaration Evaluation algorithm
        provided in 14.1.23, perform the following steps to evaluate the
        FunctionDeclaration f:

        1.  Let fenv be the running execution context’s
            VariableEnvironment.

        2.  Let benv be the running execution context’s
            LexicalEnvironment.

        3.  Let fobj be the result of calling the GetBindingValue
            concrete method of benv with arguments F and FALSE.

        4.  ReturnIfAbrupt(fobj).

        i.  1.  Let status be the result of calling fenv’s
                SetMutableBinding concrete method with arguments F,
                fobj, and FALSE.

            2.  Assert: status is never an abrupt completion.

            3.  Return NormalCompletion(empty).

If an ECMAScript implementation has a mechanism for reporting diagnostic
warning messages, a warning should be produced for each function g
whose function code contains a FunctionDeclaration for which steps 2.a
and 2.b above will be performed.

FunctionDeclarations in IfStatement Statement Clauses

The following rules for IfStatement augment those in 13.5:

IfStatement~[Yield,\ Return]~ :

IF ( Expression~[In,\ ?Yield]~ ) FunctionDeclaration~[?Yield]~ ELSE
Statement~[?Yield,\ ?Return]~
IF ( Expression~[In,\ ?Yield]~ ) Statement~[?Yield,\ ?Return]~ ELSE
FunctionDeclaration~[?Yield]~
IF ( Expression~[In,\ ?Yield]~ ) FunctionDeclaration~[?Yield]~ ELSE
FunctionDeclaration~[?Yield]~
IF ( Expression~[In,\ ?Yield]~ ) FunctionDeclaration~[?Yield]~

The above rules are only applied when parsing non-strict mode code. If
any non-strict code is match by one of these rules subsequent processing
of that code takes places as if each matching occurrence of
FunctionDeclaration~[?Yield]~ was the sole StatementListItem of a
BlockStatement occupying that position in the source code. The
semantics of such a synthetic BlockStatement includes the web legacy
compatibility semantics specified in B.3.3.

VariableStatements in Catch blocks

The content of subclause 13.14.1 is replaced with the following:

Catch : CATCH ( CatchParameter ) _Block _

-   It is a Syntax Error if any element of the BoundNames of
    CatchParameter also occurs in the LexicallyDeclaredNames of
    Block.

-   It is a Syntax Error if any element of the BoundNames of
    CatchParameter also occurs in the VarDeclaredNames of Block,
    unless that element is only bound by a VariableStatement or the
    VariableDeclarationList of a for statement, or the ForBinding of
    a for-in statement.

NOTE The Block of a Catch clause may contain VAR declarations that
bind a name that is also bound by the CatchParameter. At runtime, such
bindings are instantiated in the VariableDeclarationEnvironment. They do
not shadow the same-named bindings introduced by the CatchParameter
and hence the Initializer for such VAR declarations will assign to the
corresponding catch parameter rather than the VAR binding. The
relaxation of the normal static semantic rule does not apply to names
only bound by for-of statements.

(informative)
The Strict Mode of ECMAScript

THE STRICT MODE RESTRICTION AND EXCEPTIONS

-   "IMPLEMENTS", "INTERFACE", "LET", "PACKAGE", "PRIVATE", "PROTECTED",
      "PUBLIC", "STATIC", and "YIELD" are reserved words within strict
      mode code. (11.6.2.2).

-   A conforming implementation, when processing strict mode code, may
      not extend the syntax of NumericLiteral (11.8.3) to include
      LegacyOctalIntegerLiteral as described in B.1.1.

-   A conforming implementation, when processing strict mode code (see
      10.2.1), may not extend the syntax of EscapeSequence to include
      LegacyOctalEscapeSequence as described in B.1.2.

-   Assignment to an undeclared identifier or otherwise unresolvable
      reference does not create a property in the global object. When a
      simple assignment occurs within strict mode code, its
      LeftHandSide must not evaluate to an unresolvable Reference. If
      it does a REFERENCEERROR exception is thrown (6.2.3.2). The
      LeftHandSide also may not be a reference to a data property with
      the attribute value {[[Writable]]:FALSE}, to an accessor property
      with the attribute value {[[Set]]:UNDEFINED}, nor to a
      non-existent property of an object whose [[Extensible]] internal
      slot has the value FALSE. In these cases a TYPEERROR exception is
      thrown (12.14).

-   The identifier EVAL or ARGUMENTS may not appear as the
      LeftHandSideExpression of an Assignment operator (12.14) or of a
      PostfixExpression (12.14) or as the UnaryExpression operated
      upon by a Prefix Increment (12.5.7) or a Prefix Decrement (12.5.8)
      operator.

-   -   Arguments objects for strict mode functions define
      non-configurable accessor properties named "CALLER" and "CALLEE"
      which throw a TYPEERROR exception on access (9.2.8).

-   Arguments objects for strict mode functions do not dynamically share
      their array indexed property values with the corresponding formal
      parameter bindings of their functions. (9.4.4).

-   For strict mode functions, if an arguments object is created the
      binding of the local identifier ARGUMENTS to the arguments object
      is immutable and hence may not be the target of an assignment
      expression. (9.2.13).

-   It is a SYNTAXERROR if the IdentifierName EVAL or the
      IdentifierName ARGUMENTS occurs as a BindingIdentifier within
      strict mode code (12.1.1).

-   -   -   Strict mode eval code cannot instantiate variables or
      functions in the variable environment of the caller to eval.
      Instead, a new variable environment is created and that
      environment is used for declaration binding instantiation for the
      eval code (18.2.1).

-   If THIS is evaluated within strict mode code, then the THIS value is
      not coerced to an object. A THIS value of NULL or UNDEFINED is not
      converted to the global object and primitive values are not
      converted to wrapper objects. The THIS value passed via a function
      call (including calls made using FUNCTION.PROTOTYPE.APPLY and
      FUNCTION.PROTOTYPE.CALL) do not coerce the passed this value to an
      object (8.3.2, 12.2.1, 19.2.3.1, 19.2.3.3).

-   When a DELETE operator occurs within strict mode code, a SYNTAXERROR
      is thrown if its UnaryExpression is a direct reference to a
      variable, function argument, or function name (12.5.4).

-   When a DELETE operator occurs within strict mode code, a TYPEERROR
      is thrown if the property to be deleted has the attribute {
      [[Configurable]]:FALSE } (12.5.4).

-   -   Strict mode code may not include a WithStatement. The
      occurrence of a WithStatement in such a context is a SYNTAXERROR
      (13.10).

-   It is a SYNTAXERROR if a TryStatement with a Catch occurs within
      strict code and the Identifier of the Catch production is EVAL
      or ARGUMENTS (13.14)

-   -   It is a SYNTAXERROR if the same BindingIdentifier appears more
      than once in the FormalParameters of a strict mode function. An
      attempt to create such a function using a FUNCTION or GENERATOR
      constructor is a SYNTAXERROR (14.1.2, 19.2.1, 25.2.1).

-   An implementation may not extend, beyond that defined in this
      specification, the meanings within strict mode functions of
      properties named CALLER or ARGUMENTS of function instances.
      ECMAScript code may not create or modify properties with these
      names on function objects that correspond to strict mode functions
      (9.2.1, 9.4.4).

-   

(informative)
Corrections and Clarifications with Possible Compatibility Impact


In Edition 6

9.1.4.2.1, 9.1.4.2.2: The 5^th^ Edition moved the capture of the current
array length prior to the integer conversion of the array index or new
length value. However, the captured length value could become invalid if
the conversion process has the side-effect of changing the array length.
The 6^th^ Edition specifies that the current array length must be
captured after the possible occurrence of such side-effects.

20.3.1.14: Previous editions permitted the TimeClip abstract operation
to return either +0 or −0 as the representation of a 0 time value. The
6^th^ Edition specifies that +0 always returned. This means that for the
6^th^ Edition the time value of a Date object is never observably −0 and
methods that return time values never return −0.

20.3.1.15: If a time zone offset is not present, the local time zone is
used. Edition 5.1 incorrectly stated that a missing time zone should be
interpreted as “z”.

20.3.4.36: If the year cannot be represented using the Date Time String
Format specified in 20.3.1.15 a RangeError exception is thrown. Previous
editions did not specify the behaviour for that case.

20.3.4.41: Previous editions did not specify the value returned by
Date.prototype.toString when this time value is NaN. The 6^th^ Edition
specifies the result to be the String value is "INVALID DATE".

21.2.3.1, 21.2.3.3.4: If any LineTerminator code points in the value of
the SOURCE property of an RegExp instance must be expressed using an
escape sequence. Edition 5.1 only required the escaping of "/".

21.2.5.6, 21.2.5.8: In previous editions, the specifications for
STRING.PROTOTYPE.MATCH and STRING.PROTOTYPE.REPLACE was incorrect for
cases where the pattern argument was a RegExp value whose GLOBAL is flag
set. The previous specifications stated that for each attempt to match
the pattern, if LASTINDEX did not change it should be incremented by 1.
The correct behaviour is that LASTINDEX should be incremented by one
only if the pattern matched the empty string.

22.1.3.24, 22.1.3.24.1: Previous editions did not specify how a NAN
value returned by a comparefn was interpreted by ARRAY.PROTOTYPE.SORT.
Edition 6 specifies that such as value is treated as if +0 was returned
from the comparefn.


In Edition 5.1

Clause references in this list refer to the clause numbers used in
Edition 5.1.

7.8.4: CV definitions added for DoubleStringCharacter ::
LineContinuation and SingleStringCharacter :: LineContinuation.

10.2.1.1.3: The argument S is not ignored. It controls whether an
exception is thrown when attempting to set an immutable binding.

10.2.1.2.2: In algorithm step 5, TRUE is passed as the last argument to
[[DefineOwnProperty]].

10.5: Former algorithm step 5.e is now 5.f and a new step 5.e was added
to restore compatibility with 3^rd^ Edition when redefining global
functions.

11.5.3: In the final bullet item, use of IEEE 754 round-to-nearest mode
is specified.

12.6.3: Missing ToBoolean restored in step 3.a.ii of both algorithms.

12.6.4: Additional final sentences in each of the last two paragraphs
clarify certain property enumeration requirements.

12.7, 12.8, 12.9: BNF modified to clarify that a CONTINUE or BREAK
statement without an Identifier or a RETURN statement without an
Expression may have a LineTerminator before the semi-colon.

12.14: Step 3 of algorithm 1 and step 2.a of algorithm 3 are corrected
such that the value field of B is passed as a parameter rather than
B itself.

15.1.2.2: In step 2 of algorithm, clarify that S may be the empty
string.

15.1.2.3: In step 2 of algorithm clarify that trimmedString may be the
empty string.

15.1.3: Added notes clarifying that ECMAScript’s URI syntax is based
upon RFC 2396 and not the newer RFC 3986. In the algorithm for Decode, a
step was removed that immediately preceded the current step 4.d.vii.10.a
because it tested for a condition that cannot occur.

15.2.3.7: Corrected use of variable P in steps 5 and 6 of algorithm.

15.2.4.2: Edition 5 handling of UNDEFINED and NULL as THIS value caused
existing code to fail. Specification modified to maintain compatibility
with such code. New steps 1 and 2 added to the algorithm.

15.3.3.3: Steps 5 and 7 of Edition 5 algorithm have been deleted because
they imposed requirements upon the argArray argument that are
inconsistent with other uses of generic array-like objects.

15.4.3.12: In step 9.a, incorrect reference to relativeStart was
replaced with a reference to actualStart.

15.4.3.15: Clarified that the default value for fromIndex is the
length minus 1 of the array.

15.4.3.18: In step 10 (corresponding to step 8 in 5.1) of the algorithm,
UNDEFINED is now the specified return value.

15.4.3.22: In step 11.d.iii (corresponding to 9.c.ii in 5.1) the first
argument to the [[Call]] internal method has been changed to UNDEFINED
for consistency with the definition of Array.prototype.reduce.

15.4.5.1: In Algorithm steps 3.l.ii and 3.l.iii the variable name was
inverted resulting in an incorrectly inverted test.

15.5.4.9: Normative requirement concerning canonically equivalent
strings deleted from paragraph following algorithm because it is listed
as a recommendation in NOTE 2.

15.5.4.14: In split algorithm step 11.a and 13.a, the positional order
of the arguments to SplitMatch was corrected to match the actual
parameter signature of SplitMatch. In step 13.a.iii.7.d, lengthA
replaces A.length.

15.5.5.2: In first paragraph, removed the implication that the
individual character property access had “array index” semantics.
Modified algorithm steps 3 and 5 such that they do not enforce “array
index” requirement.

15.9.1.15: Specified legal value ranges for fields that lacked them.
Eliminated “time-only” formats. Specified default values for all
optional fields.

15.10.2.2: The step numbers of the algorithm for the internal closure
produced by step 2 were incorrectly numbered in a manner that implied
that they were steps of the outer algorithm.

15.10.2.6: In the abstract operation IsWordChar the first character in
the list in step 3 is “A” rather than “A”.

15.10.2.8: In the algorithm for the closure returned by the abstract
operation CharacterSetMatcher, the variable defined by step 3 and passed
as an argument in step 4 was renamed to ch in order to avoid a name
conflict with a formal parameter of the closure.

15.10.6.2: Step 9.e was deleted because It performed an extra increment
of i.

15.11.1.1: Removed requirement that the message own property is set to
the empty String when the message argument is UNDEFINED.

15.11.1.2: Removed requirement that the message own property is set to
the empty String when the message argument is UNDEFINED.

15.11.4.4: Steps 6-10 modified/added to correctly deal with missing or
empty message property value.

15.11.1.2: Removed requirement that the message own property is set to
the empty String when the message argument is UNDEFINED.

15.12.3: In step 10.b.iii of the JA abstract operation, the last
element of the concatenation is “]”.

B.2.1: Added to NOTE that the encoding is based upon RFC 1738 rather
than the newer RFC 3986.

Annex C: An item was added corresponding to 7.6.12 regarding
FutureReservedWords in strict mode.


In Edition 5

Clause references in this list refer to the clause numbers used in
Edition 5.

Throughout: In the Edition 3 specification the meaning of phrases such
as “as if by the expression NEW ARRAY()” are subject to
misinterpretation. In the Edition 5 specification text for all internal
references and invocations of standard built-in objects and methods has
been clarified by making it explicit that the intent is that the actual
built-in object is to be used rather than the current dynamically
resolved value of the correspondingly identifier binding.

11.8.1: ECMAScript generally uses a left to right evaluation order,
however the Edition 3 specification language for the > and <= operators
resulted in a partial right to left order. The specification has been
corrected for these operators such that it now specifies a full left to
right evaluation order. However, this change of order is potentially
observable if side-effects occur during the evaluation process.

11.1.4: Edition 5 clarifies the fact that a trailing comma at the end of
an ArrayLiteral does not add to the length of the array. This is not a
semantic change from Edition 3 but some implementations may have
previously misinterpreted this.

11.2.3: Edition 5 reverses the order of steps 2 and 3 of the algorithm.
The original order as specified in Editions 1 through 3 was incorrectly
specified such that side-effects of evaluating Arguments could affect
the result of evaluating MemberExpression.

12.4: In Edition 3, an object is created, as if by NEW OBJECT()to serve
as the scope for resolving the name of the exception parameter passed to
a CATCH clause of a TRY statement. If the actual exception object is a
function and it is called from within the CATCH clause, the scope object
will be passed as the THIS value of the call. The body of the function
can then define new properties on its THIS value and those property
names become visible identifiers bindings within the scope of the CATCH
clause after the function returns. In Edition 5, when an exception
parameter is called as a function, UNDEFINED is passed as the THIS
value.

(informative)
Additions and Changes That
Introduce Incompatibilities with Prior Editions


In the 6^th^ Edition

7.1.3.1: In Edition 6, ToNumber applied to a String value now recognizes
and converts BinaryIntegerLiteral and OctalIntegerLIteral numeric
strings. In previous editions such strings were converted to NAN,

11: In Edition 6, Function calls are not allowed to return a Reference
value.

12.2.5.1: In Edition 6, it is no longer an early error to have duplicate
property names in Object Initializers.

12.14.1: In Edition 6, strict mode code containing an assignment to an
immutable binding such as the function name of a FunctionExpression
does not produce an early error. Instead it produces a runtime error.

13.4: In Edition 6, a StatementListItem beginning with the token LET
followed by the token [ is the start of a LexicalDeclaration. In
previous editions such a sequence would be the start of an
ExpressionStatement.

13.6: In Edition 6, a terminating semi-colon is no longer required at
the end of a do-while statement.

13.6: Prior to Edition 6, an initialization expression could appear as
part of the VariableDeclaration that precedes the IN keyword. The
value of that expression was always discarded. In Edition 6, the
ForBind in that same position does not allow the occurrence of such an
initializer.

13.14: In Edition 6, it is an early error for a Catch clause to
contained a VAR declaration for the same Identifier that appears as
the Catch clause parameter. In previous editions, such a variable
declaration would be instantiated in the enclosing variable environment
but the declaration’s Initializer value would be assigned to the
Catch parameter.

14.3.9 In Edition 6, the function objects that are created as the values
of the [[Get]] or [[Set]] attribute of accessor properties in an
ObjectLiteral are not constructor functions and they do not have a
PROTOTYPE own property. In Edition 5, they were constructors and had a
PROTOTYPE property.

19.1.2.5: In Edition 6, if the argument to OBJECT.FREEZE is not an
object it is treated as if it was a non-extensible ordinary object with
no own properties. In Edition 5, a non-object argument always causes a
TYPEERROR to be thrown.

19.1.2.6: In Edition 6, if the argument to
OBJECT.GETOWNPROPERTYDESCRIPTOR is not an object an attempt is make to
coerce the argument using ToObject. If the coercion is successful the
result is used in place of the original argument value. In Edition 5, a
non-object argument always causes a TYPEERROR to be thrown.

19.1.2.7: In Edition 6, if the argument to OBJECT.GETOWNPROPERTYNAMES is
not an object an attempt is make to coerce the argument using ToObject.
If the coercion is successful the result is used in place of the
original argument value. In Edition 5, a non-object argument always
causes a TYPEERROR to be thrown.

19.1.2.9: In Edition 6, if the argument to OBJECT.GETPROTOTYPEOF is not
an object an attempt is make to coerce the argument using ToObject. If
the coercion is successful the result is used in place of the original
argument value. In Edition 5, a non-object argument always causes a
TYPEERROR to be thrown.

19.1.2.11: In Edition 6, if the argument to OBJECT.ISEXTENSIBLE is not
an object it is treated as if it was a non-extensible ordinary object
with no own properties. In Edition 5, a non-object argument always
causes a TYPEERROR to be thrown.

19.1.2.12: In Edition 6, if the argument to OBJECT.ISFROZEN is not an
object it is treated as if it was a non-extensible ordinary object with
no own properties. In Edition 5, a non-object argument always causes a
TYPEERROR to be thrown.

19.1.2.13: In Edition 6, if the argument to OBJECT.ISSEALED is not an
object it is treated as if it was a non-extensible ordinary object with
no own properties. In Edition 5, a non-object argument always causes a
TYPEERROR to be thrown.

19.1.2.14: In Edition 6, if the argument to OBJECT.KEYS is not an object
an attempt is made to coerce the argument using ToObject. If the
coercion is successful the result is used in place of the original
argument value. In Edition 5, a non-object argument always causes a
TYPEERROR to be thrown.

19.1.2.15: In Edition 6, if the argument to OBJECT.PREVENTEXTENSIONS is
not an object it is treated as if it was a non-extensible ordinary
object with no own properties. In Edition 5, a non-object argument
always causes a TYPEERROR to be thrown.

19.1.2.17: In Edition 6, if the argument to OBJECT.SEAL is not an object
it is treated as if it was a non-extensible ordinary object with no own
properties. In Edition 5, a non-object argument always causes a
TYPEERROR to be thrown.

19.2.4.1: In Edition 6, the LENGTH property of function instances is
configurable. In previous editions it was non-configurable.

19.3.3: In Edition 6, the Boolean prototype object is not a Boolean
instance. In previous editions it was a Boolean instance whose Boolean
value was FALSE.

19.5.6.2: In Edition 6, the [[Prototype]] internal slot of a
NativeError constructor is the Error constructor. In previous editions
it was the Function prototype object.

20.1.3 In Edition 6, the Number prototype object is not a Number
instance. In previous editions it was a Number instance whose number
value was +0.

20.3.4 In Edition 6, the Date prototype object is not a Date instance.
In previous editions it was a Date instance whose TimeValue was NaN.

22.1.3 In Edition 6, the Array prototype object is not an Array
instance. In previous editions it was an Array instance with a length
property whose value was +0.

21.1.3 In Edition 6, the String prototype object is not a String
instance. In previous editions it was a String instance whose String
value was the empty string.

21.1.3.22 and 21.1.3.24 In Edition 6, lowercase/upper conversion
processing operates on code points. In previous editions such the
conversion processing was only applied to individual code units. The
only affected code points are those in the Deseret block of Unicode

21.1.3.25 In Edition 6, the STRING.PROTOTYPE.TRIM method is defined to
recognize white space code points that may exists outside of the Unicode
BMP. However, as of Unicode 6.1 no such code points are defined. In
previous editions such code points would not have been recognized as
white space.

21.2.3.1In Edition 6, If the pattern argument is a RegExp instance and
the flags argument is not UNDEFINED, a new RegExp instance is created
just like pattern except that pattern’s flags are replaced by the
argument flags. In previous editions a TYPEERROR exception was thrown
when pattern was a RegExp instance and flags was not UNDEFINED.

21.2.5 In Edition 6, the RegExp prototype object is not a RegExp
instance. In previous editions it was a RegExp instance whose pattern is
the empty string.

21.2.5 In Edition 6, SOURCE, GLOBAL, IGNORECASE, and MULTILINE are
accessor properties defined on the RegExp prototype object. In previous
editions they were data properties defined on RegExp instances.

22.1.3 In Edition 6, the Array prototype object is not an Array
instance. In previous editions it was an Array instance with a length
property whose value was +0.


In the 5^th^ Edition

Clause references in this list refer to the clause numbers used in
Edition 5 and 5.1.

7.1: Unicode format control s are no longer stripped from ECMAScript
source text before processing. In Edition 5, if such a character appears
in a StringLiteral or RegularExpressionLiteral the character will be
incorporated into the literal where in Edition 3 the character would not
be incorporated into the literal.

7.2: Unicode character <ZWNBSP> is now treated as whitespace and its
presence in the middle of what appears to be an identifier could result
in a syntax error which would not have occurred in Edition 3

7.3: Line terminator characters that are preceded by an escape sequence
are now allowed within a string literal token. In Edition 3 a syntax
error would have been produced.

7.8.5: Regular expression literals now return a unique object each time
the literal is evaluated. This change is detectable by any programs that
test the object identity of such literal values or that are sensitive to
the shared side effects.

7.8.5: Edition 5 requires early reporting of any possible RegExp
constructor errors that would be produced when converting a
RegularExpressionLiteral to a RegExp object. Prior to Edition 5
implementations were permitted to defer the reporting of such errors
until the actual execution time creation of the object.

7.8.5: In Edition 5 unescaped “/” characters may appear as a
CharacterClass in a regular expression literal. In Edition 3 such a
character would have been interpreted as the final character of the
literal.

10.4.2: In Edition 5, indirect calls to the EVAL function use the global
environment as both the variable environment and lexical environment for
the eval code. In Edition 3, the variable and lexical environments of
the caller of an indirect EVAL was used as the environments for the eval
code.

15.4.3: In Edition 5 all methods of ARRAY.PROTOTYPE are intentionally
generic. In Edition 3 TOSTRING and TOLOCALESTRING were not generic and
would throw a TYPEERROR exception if applied to objects that were not
instances of Array.

10.6: In Edition 5 the array indexed properties of argument objects that
correspond to actual formal parameters are enumerable. In Edition 3,
such properties were not enumerable.

10.6: In Edition 5 the value of the [[Class]] internal slot of an
arguments object is "ARGUMENTS". In Edition 3, it was "OBJECT". This is
observable if TOSTRING is called as a method of an arguments object.

12.6.4: for-in statements no longer throw a TYPEERROR if the IN
expression evaluates to NULL or UNDEFINED. Instead, the statement
behaves as if the value of the expression was an object with no
enumerable properties.

15: In Edition 5, the following new properties are defined on built-in
objects that exist in Edition 3: OBJECT.GETPROTOTYPEOF,
OBJECT.GETOWNPROPERTYDESCRIPTOR, OBJECT.GETOWNPROPERTYNAMES,
OBJECT.CREATE, OBJECT.DEFINEPROPERTY, OBJECT.DEFINEPROPERTIES,
OBJECT.SEAL, OBJECT.FREEZE, OBJECT.PREVENTEXTENSIONS, OBJECT.ISSEALED,
OBJECT.ISFROZEN, OBJECT.ISEXTENSIBLE, OBJECT.KEYS,
FUNCTION.PROTOTYPE.BIND, ARRAY.PROTOTYPE.INDEXOF,
ARRAY.PROTOTYPE.LASTINDEXOF, ARRAY.PROTOTYPE.EVERY,
ARRAY.PROTOTYPE.SOME, ARRAY.PROTOTYPE.FOREACH, ARRAY.PROTOTYPE.MAP,
ARRAY.PROTOTYPE.FILTER, ARRAY.PROTOTYPE.REDUCE,
ARRAY.PROTOTYPE.REDUCERIGHT, STRING.PROTOTYPE.TRIM, DATE.NOW,
DATE.PROTOTYPE.TOISOSTRING, DATE.PROTOTYPE.TOJSON.

15: Implementations are now required to ignore extra arguments to
standard built-in methods unless otherwise explicitly specified. In
Edition 3 the handling of extra arguments was unspecified and
implementations were explicitly allowed to throw a TYPEERROR exception.

15.1.1: The value properties NAN, INFINITY, and UNDEFINED of the Global
Object have been changed to be read-only properties.

15.1.2.1. Implementations are no longer permitted to restrict the use of
eval in ways that are not a direct call. In addition, any invocation of
eval that is not a direct call uses the global environment as its
variable environment rather than the caller’s variable environment.

15.1.2.2: The specification of the function PARSEINT no longer allows
implementations to treat Strings beginning with a 0 as octal values.

15.3.3.3: In Edition 3, a TYPEERROR is thrown if the second argument
passed to FUNCTION.PROTOTYPE.APPLY is neither an array object nor an
arguments object. In Edition 5, the second argument may be any kind of
generic array-like object that has a valid LENGTH property.

15.3.3.3, 15.3.3.4: In Edition 3 passing UNDEFINED or NULL as the first
argument to either FUNCTION.PROTOTYPE.APPLY or FUNCTION.PROTOTYPE.CALL
causes the global object to be passed to the indirectly invoked target
function as the THIS value. If the first argument is a primitive value
the result of calling ToObject on the primitive value is passed as the
THIS value. In Edition 5, these transformations are not performed and
the actual first argument value is passed as the THIS value. This
difference will normally be unobservable to existing ECMAScript Edition
3 code because a corresponding transformation takes place upon
activation of the target function. However, depending upon the
implementation, this difference may be observable by host object
functions called using APPLY or CALL. In addition, invoking a standard
built-in function in this manner with NULL or UNDEFINED passed as the
THIS value will in many cases cause behaviour in Edition 5
implementations that differ from Edition 3 behaviour. In particular, in
Edition 5 built-in functions that are specified to actually use the
passed THIS value as an object typically throw a TYPEERROR exception if
passed NULL or UNDEFINED as the THIS value.

15.3.4.2: In Edition 5, the PROTOTYPE property of Function instances is
not enumerable. In Edition 3, this property was enumerable.

15.5.5.2: In Edition 5, the individual characters of a String object’s
[[StringData]] may be accessed as array indexed properties of the String
object. These properties are non-writable and non-configurable and
shadow any inherited properties with the same names. In Edition 3, these
properties did not exist and ECMAScript code could dynamically add and
remove writable properties with such names and could access inherited
properties with such names.

15.9.4.2: DATE.PARSE is now required to first attempt to parse its
argument as an ISO format string. Programs that use this format but
depended upon implementation specific behaviour (including failure) may
behave differently.

15.10.2.12: In Edition 5, \S now additionally matches <ZWNBSP>.

15.10.4.1: In Edition 3, the exact form of the String value of the
SOURCE property of an object created by the REGEXP constructor is
implementation defined. In Edition 5, the String must conform to certain
specified requirements and hence may be different from that produced by
an Edition 3 implementation.

15.10.6.4: In Edition 3, the result of REGEXP.PROTOTYPE.TOSTRING need
not be derived from the value of the RegExp object’s SOURCE property. In
Edition 5 the result must be derived from the SOURCE property in a
specified manner and hence may be different from the result produced by
an Edition 3 implementation.

15.11.2.1, 15.11.4.3: In Edition 5, if an initial value for the MESSAGE
property of an Error object is not specified via the ERROR constructor
the initial value of the property is the empty String. In Edition 3,
such an initial value is implementation defined.

15.11.4.4: In Edition 3, the result of ERROR.PROTOTYPE.TOSTRING is
implementation defined. In Edition 5, the result is fully specified and
hence may differ from some Edition 3 implementations.

15.12: In Edition 5, the name JSON is defined in the global environment.
In Edition 3, testing for the presence of that name will show it to be
UNDEFINED unless it is defined by the program or implementation.

Bibliography

_IANA Time Zone Database_ at <http://www.iana.org/time-zones>

ISO 8601:2004(E) _Data elements and interchange formats – Information
interchange_ — _Representation of dates and times_

RFC 1738 “Uniform Resource Locators (URL)”, available at
<http://tools.ietf.org/html/rfc1738>

RFC 2396 “Uniform Resource Identifiers (URI): Generic Syntax”, available
at <http://tools.ietf.org/html/rfc2396>

RFC 3629 “UTF-8, a transformation format of ISO 10646”, available at
<http://tools.ietf.org/html/rfc3629>

RFC 4627 “The application/json Media Type for JavaScript Object Notation
(JSON)” , available at <http://tools.ietf.org/html/rfc4627>

Unicode Inc. (2010), Unicode Technical Report #15: “Unicode
Normalization Forms”, available at
<http://www.unicode.org/reports/tr15/tr15-29.html>

[1] Note: Please note that for ECMAScript Edition 4 the Ecma standard
number “ECMA-262 Edition 4” was reserved but not used in the Ecma
publication process. Therefore “ECMA-262 Edition 4” as an Ecma
International publication does not exist.
