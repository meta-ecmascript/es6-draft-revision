Contents Page

Introduction vii

1 Scope 1

2 Conformance 1

3 _Normative references_ 1

4 Overview 1

4.1 _Web Scripting_ 2

4.2 _Language Overview_ 2

4.2.1 Objects 3

4.2.2 _The Strict Variant of ECMAScript_ 4

4.3 _Terms and definitions_ 4

5 _Notational Conventions_ 7

5.1 _Syntactic and Lexical Grammars_ 7

5.1.1 _Context-Free Grammars_ 7

5.1.2 _The Lexical and RegExp Grammars_ 8

5.1.3 _The Numeric String Grammar_ 8

5.1.4 _The Syntactic Grammar_ 8

5.1.5 _The JSON Grammar_ 9

5.1.6 _Grammar Notation_ 9

5.2 _Algorithm Conventions_ 12

_5.3 Static Semantic Rules_ 13

6 _Source Text_ 14

7 _Lexical Conventions_ 15

7.1 _Unicode Format-Control Characters_ 16

7.2 _White Space_ 16

7.3 _Line Terminators_ 17

7.4 Comments 17

7.5 Tokens 18

7.6 _Identifier Names and Identifiers_ 19

7.6.1 _Reserved Words_ 20

7.7 Punctuators 21

7.8 Literals 21

7.8.1 _Null Literals_ 21

7.8.2 _Boolean Literals_ 21

7.8.3 _Numeric Literals_ 22

7.8.4 _String Literals_ 24

7.8.5 _Regular Expression Literals_ 27

7.8.6 _Template Literal Lexical Components_ 28

7.9 _Automatic Semicolon Insertion_ 30

7.9.1 _Rules of Automatic Semicolon Insertion_ 30

7.9.2 _Examples of Automatic Semicolon Insertion_ 31

8 Types 32

8.1 _The Undefined Type_ 32

8.2 _The Null Type_ 32

8.3 _The Boolean Type_ 33

8.4 _The String Type_ 33

8.5 _The Number Type_ 33

8.6 _The Object Type_ 34

8.6.1 _Property Attributes_ 34

8.6.2 _Object Internal Properties and Methods_ 35

8.7 _The List and Record Specification Type_ 40

8.8 _The Completion Record Specification Type_ 40

_8.8.1 Implicit Completion Values_ 41

_8.8.2 NormalCompletion_ 41

_8.8.3 Throw an Exception_ 41

_8.8.4 ReturnIfAbrupt_ 41

8.9 _The Reference Specification Type_ 42

8.9.1 _GetValue (V)_ 42

8.9.2 _PutValue (V, W)_ 43

8.9.3 _GetThisValue (V)_ 44

8.10 _The Property Descriptor and Property Identifier Specification
Types_ 44

8.10.1 _IsAccessorDescriptor ( Desc )_ 44

8.10.2 _IsDataDescriptor ( Desc )_ 44

8.10.3 _IsGenericDescriptor ( Desc )_ 45

8.10.4 _FromPropertyDescriptor ( Desc )_ 45

8.10.5 _ToPropertyDescriptor ( Obj )_ 45

8.11 _The Lexical Environment and Environment Record Specification
Types_ 46

8.12 _Algorithms for Object Internal Methods_ 46

8.12.1 _[[GetOwnProperty]] (P)_ 46

8.12.2 _[[GetProperty]] (P)_ 46

8.12.3 _[[Get]] (P [, accessorThisValue] )_ 46

8.12.4 _[[CanPut]] (P)_ 47

8.12.5 _[[Put]] ( P, V, Throw[, accessorThisValue] )_ 47

8.12.6 _[[HasProperty]] (P)_ 48

8.12.7 _[[Delete]] (P, Throw)_ 48

8.12.8 _[[DefaultValue]] (hint)_ 48

8.12.9 _[[DefineOwnProperty]] (P, Desc, Throw)_ 49

8.12.10 _[[Enumerate]] (includePrototype, onlyEnumerable )_ 50

8.12.11 _[[Iterate]] ( )_ 50

_8.13 Data Blocks_ 51

_9 Abstract Operations_ 51

9.1 _Type Conversion and Testing_ 51

9.1.1 ToPrimitive 52

9.1.2 ToBoolean 52

9.1.3 ToNumber 53

9.1.4 ToInteger 55

9.1.5 _ToInt32: (Signed 32 Bit Integer)_ 56

9.1.6 _ToUint32: (Unsigned 32 Bit Integer)_ 56

9.1.7 _ToUint16: (Unsigned 16 Bit Integer)_ 56

9.1.8 ToString 57

9.1.9 ToObject 58

9.1.10 ToPropertyKey 58

9.2 _Testing and Comparison Operations_ 58

9.2.1 CheckObjectCoercible 58

9.2.2 IsCallable 59

9.2.3 _The SameValue Algorithm_ 59

9.2.4 IsConstructor 59

9.3 _Operations on Objects_ 60

9.3.1 Invoke 60

10 _Executable Code and Execution Contexts_ 60

10.1 _Types of Executable Code_ 60

10.1.1 _Strict Mode Code_ 61

10.1.2 _Non-ECMAScript Functions_ 61

10.2 _Lexical Environments_ 61

10.2.1 _Environment Records_ 62

10.2.2 _Lexical Environment Operations_ 73

10.3 _Code Realms_ 74

10.4 _Execution Contexts_ 75

10.4.1 _Identifier Resolution_ 76

10.4.2 GetThisEnvironment 76

10.4.3 _This Resolution_ 76

10.5 _Declaration Binding Instantiation_ 76

10.5.1 _Global Declaration Instantiation_ 76

10.5.2 _Module Declaration Instantiation_ 77

10.5.3 _Function Declaration Instantiation_ 78

10.5.4 _Block Declaration Instantiation_ 79

_10.5.5 Eval Declaration Instantiation_ 80

10.6 _Arguments Object_ 80

11 Expressions 83

11.1 _Primary Expressions_ 83

11.1.1 _The this Keyword_ 84

11.1.2 _Identifier Reference_ 84

11.1.3 Literals 84

11.1.4 _Array Initialiser_ 85

_ToDo_ 88

11.1.5 _Object Initialiser_ 88

11.1.6 _Function Defining Expressions_ 91

11.1.7 _Generator Comprehensions_ 91

11.1.8 _Regular Expression Literals_ 91

11.1.9 _Template Literals_ 92

11.1.10 _The Grouping Operator_ 95

11.2 _Left-Hand-Side Expressions_ 96

11.2.1 _Property Accessors_ 97

11.2.2 _The new Operator_ 98

11.2.3 _Function Calls_ 99

11.2.4 _The super Keyword_ 100

11.2.5 _Argument Lists_ 101

11.2.6 _Tagged Templates_ 102

11.3 _Postfix Expressions_ 102

11.3.1 _Postfix Increment Operator_ 103

11.3.2 _Postfix Decrement Operator_ 103

11.4 _Unary Operators_ 103

11.4.1 _The delete Operator_ 104

11.4.2 _The void Operator_ 104

11.4.3 _The typeof Operator_ 105

11.4.4 _Prefix Increment Operator_ 105

11.4.5 _Prefix Decrement Operator_ 105

11.4.6 _Unary + Operator_ 106

11.4.7 _Unary - Operator_ 106

11.4.8 _Bitwise NOT Operator ( ~ )_ 106

11.4.9 _Logical NOT Operator ( ! )_ 106

11.5 _Multiplicative Operators_ 107

11.5.1 _Applying the * Operator_ 107

11.5.2 _Applying the / Operator_ 108

11.5.3 _Applying the % Operator_ 108

11.6 _Additive Operators_ 109

11.6.1 _The Addition operator ( + )_ 109

11.6.2 _The Subtraction Operator ( - )_ 109

11.6.3 _Applying the Additive Operators to Numbers_ 110

11.7 _Bitwise Shift Operators_ 110

11.7.1 _The Left Shift Operator ( << )_ 110

11.7.2 _The Signed Right Shift Operator ( >> )_ 111

11.7.3 _The Unsigned Right Shift Operator ( >>> )_ 111

11.8 _Relational Operators_ 112

_11.8.1 Runtime Semantics_ 112

11.9 _Equality Operators_ 115

_11.9.1 Runtime Semantics_ 115

11.10 _Binary Bitwise Operators_ 118

11.11 _Binary Logical Operators_ 118

11.12 _Conditional Operator ( ? : )_ 119

11.13 _Assignment Operators_ 120

_Static Semantics_ 120

_Runtime Semantics_ 121

_11.13.1 Destructuring Assignment_ 122

11.14 _Comma Operator ( , )_ 125

12 _Statements and Declarations_ 126

_Static Semantics_ 126

_Runtime Semantics_ 127

12.1 Block 127

12.2 _Declarations and the Variable Statement_ 130

12.2.1 _Let and Const Declarations_ 130

12.2.2 _Variable Statement_ 133

12.2.4 _Destructuring Binding Patterns_ 135

12.3 _Empty Statement_ 140

12.4 _Expression Statement_ 140

12.5 _The if Statement_ 141

12.6 _Iteration Statements_ 142

12.6.1 _The do-while Statement_ 142

12.6.2 _The while Statement_ 143

12.6.3 _The for Statement_ 143

12.6.4 _The for-in and for-of Statements_ 145

12.7 _The continue Statement_ 148

12.8 _The break Statement_ 149

12.9 _The return Statement_ 149

12.10 _The with Statement_ 150

12.11 _The switch Statement_ 151

12.12 _Labelled Statements_ 155

12.13 _The throw Statement_ 156

12.14 _The try Statement_ 156

12.15 _The debugger statement_ 158

13 _Functions and Generators_ 159

13.1 _Function Definitions_ 159

13.2 _Arrow Function Definitions_ 164

13.3 _Method Definitions_ 167

13.4 _Generator Definitions_ 170

13.5 _Class Definitions_ 171

13.6 _Creating Function Objects and Constructors_ 175

_13.7 Tail Position Calls_ 177

14 _Scripts and Modules_ 178

_14.1 Script_ 178

14.1.1 _Directive Prologues and the Use Strict Directive_ 180

_14.2 Modules_ 181

15 _Standard Built-in ECMAScript Objects_ 181

15.1 _The Global Object_ 182

15.1.1 _Value Properties of the Global Object_ 182

15.1.2 _Function Properties of the Global Object_ 183

15.1.3 _URI Handling Function Properties_ 185

15.1.4 _Constructor Properties of the Global Object_ 190

15.1.5 _Other Properties of the Global Object_ 191

15.2 _Object Objects_ 191

15.2.1 _The Object Constructor Called as a Function_ 191

15.2.2 _The Object Constructor_ 191

15.2.3 _Properties of the Object Constructor_ 192

15.2.4 _Properties of the Object Prototype Object_ 195

15.2.5 _Properties of Object Instances_ 197

15.3 _Function Objects_ 198

15.3.1 _The Function Constructor Called as a Function_ 198

15.3.2 _The Function Constructor_ 198

15.3.3 _Properties of the Function Constructor_ 199

15.3.4 _Properties of the Function Prototype Object_ 199

15.3.5 _Properties of Function Instances_ 202

15.4 _Array Objects_ 203

15.4.1 _The Array Constructor Called as a Function_ 203

15.4.2 _The Array Constructor_ 204

15.4.3 _Properties of the Array Constructor_ 204

15.4.4 _Properties of the Array Prototype Object_ 206

15.4.5 _Properties of Array Instances_ 225

15.4.6 _Array Iterator Object Structure_ 227

15.5 _String Objects_ 228

15.5.1 _The String Constructor Called as a Function_ 228

15.5.2 _The String Constructor_ 229

15.5.3 _Properties of the String Constructor_ 229

15.5.4 _Properties of the String Prototype Object_ 230

15.5.5 _Properties of String Instances_ 243

15.6 _Boolean Objects_ 243

15.6.1 _The Boolean Constructor Called as a Function_ 243

15.6.2 _The Boolean Constructor_ 243

15.6.3 _Properties of the Boolean Constructor_ 244

15.6.4 _Properties of the Boolean Prototype Object_ 244

15.6.5 _Properties of Boolean Instances_ 245

15.7 _Number Objects_ 245

15.7.1 _The Number Constructor Called as a Function_ 245

15.7.2 _The Number Constructor_ 245

15.7.3 _Properties of the Number Constructor_ 245

15.7.4 _Properties of the Number Prototype Object_ 247

15.7.5 _Properties of Number Instances_ 251

15.8 _The Math Object_ 251

15.8.1 _Value Properties of the Math Object_ 252

15.8.2 _Function Properties of the Math Object_ 253

15.9 _Date Objects_ 260

15.9.1 _Overview of Date Objects and Definitions of Abstract
Operators_ 260

15.9.2 _The Date Constructor Called as a Function_ 265

15.9.3 _The Date Constructor_ 265

15.9.4 _Properties of the Date Constructor_ 266

15.9.5 _Properties of the Date Prototype Object_ 267

15.9.6 _Properties of Date Instances_ 275

15.10 _RegExp (Regular Expression) Objects_ 275

15.10.1 Patterns 275

15.10.2 _Pattern Semantics_ 277

15.10.3 _The RegExp Constructor Called as a Function_ 289

15.10.4 _The RegExp Constructor_ 289

15.10.5 _Properties of the RegExp Constructor_ 290

15.10.6 _Properties of the RegExp Prototype Object_ 290

15.10.7 _Properties of RegExp Instances_ 292

15.11 _Error Objects_ 293

15.11.1 _The Error Constructor Called as a Function_ 293

15.11.2 _The Error Constructor_ 293

15.11.3 _Properties of the Error Constructor_ 294

15.11.4 _Properties of the Error Prototype Object_ 294

15.11.5 _Properties of Error Instances_ 294

15.11.6 _Native Error Types Used in This Standard_ 294

15.11.7 NativeError Object Structure 295

15.12 _The JSON Object_ 297

15.12.1 _The JSON Grammar_ 297

15.12.2 _parse ( text [ , reviver ] )_ 299

15.12.3 _stringify ( value [ , replacer [ , space ] ] )_ 300

15.13 _Binary Data Objects_ 304

_15.13.1 The BinaryData Module_ 304

_15.13.2 The BinaryData.Type Object_ 304

_15.13.3 The BinaryData.ArrayType Object_ 304

_15.13.4 The BinaryData.StructType Object_ 304

_15.13.5 ArrayBufferObjects_ 305

_15.13.6 TypeArray Object Structures_ 306

_15.13.7 DataView Objects_ 310

_15.14 Map Objects_ 314

_15.14.1 Abstract Operations For Map Objects_ 314

15.14.2 _The Map Constructor Called as a Function_ 315

15.14.3 _The Map Constructor_ 315

15.14.4 _Properties of the Map Constructor_ 316

15.14.5 _Properties of the Map Prototype Object_ 316

15.14.6 _Properties of Map Instances_ 319

15.14.7 _Map Iterator Object Structure_ 319

_15.15 WeakMap Objects_ 320

_15.15.1 Abstract Operations For WeakMap Objects_ 321

15.15.2 _The WeakMap Constructor Called as a Function_ 321

15.15.3 _The WeakMap Constructor_ 322

15.15.4 _Properties of the WeakMap Constructor_ 322

15.15.5 _Properties of the WeakMap Prototype Object_ 322

15.15.6 _Properties of WeakMap Instances_ 324

_15.16 Set Objects_ 324

_15.16.1 Abstract Operations For Set Objects_ 324

15.16.2 _The Set Constructor Called as a Function_ 325

15.16.3 _The Set Constructor_ 325

15.16.4 _Properties of the Set Constructor_ 325

15.16.5 _Properties of the Set Prototype Object_ 325

15.16.6 _Properties of Set Instances_ 328

15.16.7 _Set Iterator Object Structure_ 328

_15.17 The Reflect Module_ 329

_15.18 Proxy Objects_ 329

16 Errors 329

_Annex A (informative) Grammar Summary_ 332

A.1 _Lexical Grammar_ 332

A.2 _Number Conversions_ 338

A.3 Expressions 339

A.4 Statements 343

A.5 _Functions and Scripts_ 345

A.6 _Universal Resource Identifier Character Classes_ 346

A.7 _Regular Expressions_ 346

A.8 JSON 348

A.8.1 _JSON Lexical Grammar_ 348

A.8.2 _JSON Syntactic Grammar_ 349

_Annex B (normative) Additional ECMAScript Features for Web Browsers_
352

B.1 _Additional Syntax_ 352

B.1.1 _Numeric Literals_ 352

B.1.2 _String Literals_ 352

B.2 _Additional Properties_ 353

B.2.1 _Additional Properties of the Global Object_ 353

B.2.2 _Additional Properties of the String.prototype Object_ 354

B.2.3 _Additional Properties of the Date.prototype Object_ 357

B.3 _Other Additional Features_ 358

B.3.1 _The _proto_ pseudo property._ 358

_Annex C (informative) The Strict Mode of ECMAScript_ 360

_Annex D (informative) Corrections and Clarifications with Possible
Compatibility Impact_ 362

_In Edition 6_ 362

_In 5.1 Edition 5.1_ 362

_In 5^th^ Edition 5_ 363

_Annex E (informative) Additions and Changes that Introduce
Incompatibilities with Prior Editions_ 366

_In the 6^th^ Edition_ 366

_In the 5^th^ Edition_ 366

_Annex F (informative) Static Semantic Rule Cross Reference_ 370

_Scrap Heap_ 372

10.5.3 _Function Declaration Instantiation_ 373

Introduction

This Ecma Standard is based on several originating technologies, the
most well known being JavaScript (Netscape) and JScript (Microsoft). The
language was invented by Brendan Eich at Netscape and first appeared in
that company’s Navigator 2.0 browser. It has appeared in all subsequent
browsers from Netscape and in all browsers from Microsoft starting with
Internet Explorer 3.0.

The development of this Standard started in November 1996. The first
edition of this Ecma Standard was adopted by the Ecma General Assembly
of June 1997.

That Ecma Standard was submitted to ISO/IEC JTC 1 for adoption under the
fast-track procedure, and approved as international standard ISO/IEC
16262, in April 1998. The Ecma General Assembly of June 1998 approved
the second edition of ECMA-262 to keep it fully aligned with ISO/IEC
16262. Changes between the first and the second edition are editorial in
nature.

The third edition of the Standard introduced powerful regular
expressions, better string handling, new control statements, try/catch
exception handling, tighter definition of errors, formatting for numeric
output and minor changes in anticipation of forthcoming
internationalisation facilities and future language growth. The third
edition of the ECMAScript standard was adopted by the Ecma General
Assembly of December 1999 and published as ISO/IEC 16262:2002 in June
2002.

Since publication of the third edition, ECMAScript has achieved massive
adoption in conjunction with the World Wide Web where it has become the
programming language that is supported by essentially all web browsers.
Significant work was done to develop a fourth edition of ECMAScript.
Although that work was not completed and not published[1] as the fourth
edition of ECMAScript, it informs continuing evolution of the language.
The fifth edition of ECMAScript (published as ECMA-262 5^th^ edition)
codifies de facto interpretations of the language specification that
have become common among browser implementations and adds support for
new features that have emerged since the publication of the third
edition. Such features include accessor properties, reflective creation
and inspection of objects, program control of property attributes,
additional array manipulation functions, support for the JSON object
encoding format, and a strict mode that provides enhanced error checking
and program security.

The edition 5.1 of the ECMAScript Standard has been fully aligned with
the third edition of the international standard ISO/IEC 16262:2011.

This present sixth edition of the Standard………

ECMAScript is a vibrant language and the evolution of the language is
not complete. Significant technical enhancement will continue with
future editions of this specification.

This Ecma Standard has been adopted by the General Assembly of <month>
<year>.

"DISCLAIMER

_This draft document may be copied and furnished to others, and
derivative works that comment on or otherwise explain it or assist in
its implementation may be prepared, copied, published, and distributed,
in whole or in part, without restriction of any kind, provided that the
above copyright notice and this section are included on all such copies
and derivative works. However, this document itself may not be modified
in any way, including by removing the copyright notice or references to
Ecma International, except as needed for the purpose of developing any
document or deliverable produced by Ecma International._

_This disclaimer is valid only prior to final version of this document.
After approval all rights on the standard are reserved by Ecma
International._

_The limited permissions are granted through the standardization phase
and will not be revoked by Ecma International or its successors or
assigns during this time._

_This document and the information contained herein is provided on an
"AS IS" basis and ECMA INTERNATIONAL DISCLAIMS ALL WARRANTIES, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
THE INFORMATION HEREIN WILL NOT INFRINGE ANY OWNERSHIP RIGHTS OR ANY
IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE."_

ECMAScript Language Specification



SCOPE


This Standard defines the ECMAScript scripting language.



CONFORMANCE


A conforming implementation of ECMAScript must provide and support all
the types, values, objects, properties, functions, and program syntax
and semantics described in this specification.

A conforming implementation of this Standard shall interpret characters
in conformance with the Unicode Standard, Version 5.1.0 or later and
ISO/IEC 10646. If the adopted ISO/IEC 10646-1 subset is not otherwise
specified, it is presumed to be the Unicode set, collection 10646.

A conforming implementation of ECMAScript is permitted to provide
additional types, values, objects, properties, and functions beyond
those described in this specification. In particular, a conforming
implementation of ECMAScript is permitted to provide properties not
described in this specification, and values for those properties, for
objects that are described in this specification.

A conforming implementation of ECMAScript is permitted to support
program and regular expression syntax not described in this
specification. In particular, a conforming implementation of ECMAScript
is permitted to support program syntax that makes use of the “future
reserved words” listed in 7.6.1.2 of this specification.



NORMATIVE REFERENCES


The following referenced documents are indispensable for the application
of this document. For dated references, only the edition cited applies.
For undated references, the latest edition of the referenced document
(including any amendments) applies.

ISO/IEC 9899:1996_, Programming Languages – C, including amendment 1 and
technical corrigenda 1 and 2_

ISO/IEC 10646:2003: _Information Technology – Universal Multiple-Octet
Coded Character Set (UCS) plus Amendment 1:2005, Amendment 2:2006,
Amendment 3:2008, and Amendment 4:2008_, plus additional amendments and
corrigenda, or successor

_The Unicode Standard, Version 5.0_, as amended by Unicode 5.1.0, or
successor

_Unicode Standard Annex #15, Unicode Normalization Forms, version
Unicode 5.1.0_, or successor

_Unicode Standard Annex #31, Unicode Identifiers and Pattern Syntax,
version Unicode 5.1.0_, or successor.

This section contains a non-normative overview of the ECMAScript
language.

ECMAScript is an object-oriented programming language for performing
computations and manipulating computational objects within a host
environment. ECMAScript as defined here is not intended to be
computationally self-sufficient; indeed, there are no provisions in this
specification for input of external data or output of computed results.
Instead, it is expected that the computational environment of an
ECMAScript program will provide not only the objects and other
facilities described in this specification but also certain
environment-specific objects, whose description and behaviour are beyond
the scope of this specification except to indicate that they may provide
certain properties that can be accessed and certain functions that can
be called from an ECMAScript program.

A _SCRIPTING LANGUAGE_ is a programming language that is used to
manipulate, customise, and automate the facilities of an existing
system. In such systems, useful functionality is already available
through a user interface, and the scripting language is a mechanism for
exposing that functionality to program control. In this way, the
existing system is said to provide a host environment of objects and
facilities, which completes the capabilities of the scripting language.
A scripting language is intended for use by both professional and
non-professional programmers. ECMAScript was originally designed to be
used as a scripting language, but has become widely used as a general
purpose programming language.

ECMAScript was originally designed to be a _WEB SCRIPTING LANGUAGE_,
providing a mechanism to enliven Web pages in browsers and to perform
server computation as part of a Web-based client-server architecture.
ECMAScript is now used both as a general propose programming language
and to provide core scripting capabilities for a variety of host
environments. Therefore the core language is specified in this document
apart from any particular host environment.

Some of the facilities of ECMAScript are similar to those used in other
programming languages; in particular Java, Self, and Scheme as
described in:

Gosling, James, Bill Joy and Guy Steele. The Java^^ Language
Specification. Addison Wesley Publishing Co., 1996.

Ungar, David, and Smith, Randall B. Self: The Power of Simplicity.
OOPSLA '87 Conference Proceedings, pp. 227–241, Orlando, FL, October
1987.

IEEE Standard for the Scheme Programming Language. IEEE Std 1178-1990.

A web browser provides an ECMAScript host environment for client-side
computation including, for instance, objects that represent windows,
menus, pop-ups, dialog boxes, text areas, anchors, frames, history,
cookies, and input/output. Further, the host environment provides a
means to attach scripting code to events such as change of focus, page
and image loading, unloading, error and abort, selection, form
submission, and mouse actions. Scripting code appears within the HTML
and the displayed page is a combination of user interface elements and
fixed and computed text and images. The scripting code is reactive to
user interaction and there is no need for a main program.

A web server provides a different host environment for server-side
computation including objects representing requests, clients, and files;
and mechanisms to lock and share data. By using browser-side and
server-side scripting together, it is possible to distribute computation
between the client and server while providing a customised user
interface for a Web-based application.

Each Web browser and server that supports ECMAScript supplies its own
host environment, completing the ECMAScript execution environment.

The following is an informal overview of ECMAScript—not all parts of the
language are described. This overview is not part of the standard
proper.

ECMAScript is object-based: basic language and host facilities are
provided by objects, and an ECMAScript program is a cluster of
communicating objects. An ECMAScript OBJECT is a collection of
PROPERTIES each with zero or more ATTRIBUTES that determine how each
property can be used—for example, when the Writable attribute for a
property is set to FALSE, any attempt by executed ECMAScript code to
change the value of the property fails. Properties are containers that
hold other objects, _PRIMITIVE VALUES_, or FUNCTIONS. A primitive
value is a member of one of the following built-in types: UNDEFINED,
NULL, BOOLEAN, NUMBER, and STRING; an object is a member of the
remaining built-in type OBJECT; and a function is a callable object. A
function that is associated with an object via a property is a METHOD.

ECMAScript defines a collection of _BUILT-IN OBJECTS_ that round out the
definition of ECMAScript entities. These built-in objects include the
global object, the OBJECT object, the FUNCTION object, the ARRAY object,
the STRING object, the BOOLEAN object, the NUMBER object, the MATH
object, the DATE object, the REGEXP object, the JSON object, and the
Error objects ERROR, EVALERROR, RANGEERROR, REFERENCEERROR, SYNTAXERROR,
TYPEERROR and URIERROR.

ECMAScript also defines a set of built-in OPERATORS. ECMAScript
operators include various unary operations, multiplicative operators,
additive operators, bitwise shift operators, relational operators,
equality operators, binary bitwise operators, binary logical operators,
assignment operators, and the comma operator.

ECMAScript syntax intentionally resembles Java syntax. ECMAScript syntax
is relaxed to enable it to serve as an easy-to-use scripting language.
For example, a variable is not required to have its type declared nor
are types associated with properties, and defined functions are not
required to have their declarations appear textually before calls to
them.

ECMAScript does not use classes such as those in C++, Smalltalk, or
Java. Instead objects may be created in various ways including via a
literal notation or via CONSTRUCTORS which create objects and then
execute code that initialises all or part of them by assigning initial
values to their properties. Each constructor is a function that has a
property named “PROTOTYPE” that is used to implement _PROTOTYPE-BASED
INHERITANCE_ and _SHARED PROPERTIES_. Objects are created by using
constructors in NEW expressions; for example, NEW DATE(2009,11) creates
a new Date object. Invoking a constructor without using NEW has
consequences that depend on the constructor. For example, DATE()
produces a string representation of the current date and time rather
than an object.

Every object created by a constructor has an implicit reference (called
the object’s prototype) to the value of its constructor’s “PROTOTYPE”
property. Furthermore, a prototype may have a non-null implicit
reference to its prototype, and so on; this is called the _prototype
chain_. When a reference is made to a property in an object, that
reference is to the property of that name in the first object in the
prototype chain that contains a property of that name. In other words,
first the object mentioned directly is examined for such a property; if
that object contains the named property, that is the property to which
the reference refers; if that object does not contain the named
property, the prototype for that object is examined next; and so on.

Figure 1 — Object/Prototype Relationships

In a class-based object-oriented language, in general, state is carried
by instances, methods are carried by classes, and inheritance is only of
structure and behaviour. In ECMAScript, the state and methods are
carried by objects, while structure, behaviour, and state are all
inherited.

All objects that do not directly contain a particular property that
their prototype contains share that property and its value. Figure 1
illustrates this:

CF is a constructor (and also an object). Five objects have been created
by using NEW expressions: CF~1~, CF~2~, CF~3~, CF~4~, and CF~5~. Each of
these objects contains properties named q1 and q2. The dashed lines
represent the implicit prototype relationship; so, for example, CF~3~’s
prototype is CF~P~. The constructor, CF, has two properties itself,
named P1 and P2, which are not visible to CF~P~, CF~1~, CF~2~, CF~3~,
CF~4~, or CF~5~. The property named CFP1 in CF~P~ is shared by CF~1~,
CF~2~, CF~3~, CF~4~, and CF~5~ (but not by CF), as are any properties
found in CF~P~’s implicit prototype chain that are not named q1, q2, or
CFP1. Notice that there is no implicit prototype link between CF and
CF~P~.

Unlike class-based object languages, properties can be added to objects
dynamically by assigning values to them. That is, constructors are not
required to name or assign values to all or any of the constructed
object’s properties. In the above diagram, one could add a new shared
property for CF~1~, CF~2~, CF~3~, CF~4~, and CF~5\ ~by assigning a new
value to the property in CF~P~.

The ECMAScript Language recognises the possibility that some users of
the language may wish to restrict their usage of some features available
in the language. They might do so in the interests of security, to avoid
what they consider to be error-prone features, to get enhanced error
checking, or for other reasons of their choosing. In support of this
possibility, ECMAScript defines a strict variant of the language. The
strict variant of the language excludes some specific syntactic and
semantic features of the regular ECMAScript language and modifies the
detailed semantics of some features. The strict variant also specifies
additional error conditions that must be reported by throwing error
exceptions in situations that are not specified as errors by the
non-strict form of the language.

The strict variant of ECMAScript is commonly referred to as the _strict
mode_ of the language. Strict mode selection and use of the strict mode
syntax and semantics of ECMAScript is explicitly made at the level of
individual ECMAScript code units. Because strict mode is selected at the
level of a syntactic code unit, strict mode only imposes restrictions
that have local effect within such a code unit. Strict mode does not
restrict or modify any aspect of the ECMAScript semantics that must
operate consistently across multiple code units. A complete ECMAScript
program may be composed for both strict mode and non-strict mode
ECMAScript code units. In this case, strict mode only applies when
actually executing code that is defined within a strict mode code unit.

In order to conform to this specification, an ECMAScript implementation
must implement both the full unrestricted ECMAScript language and the
strict mode variant of the ECMAScript language as defined by this
specification. In addition, an implementation must support the
combination of unrestricted and strict mode code units into a single
composite program.

For the purposes of this document, the following terms and definitions
apply.

4.3.1

type

set of data values as defined in Clause 8 of this specification

4.3.2

primitive value

member of one of the types Undefined, Null, Boolean, Number, or String
as defined in Clause 8

NOTE A primitive value is a datum that is represented directly at the
lowest level of the language implementation.

4.3.3

object

member of the type Object

NOTE An object is a collection of properties and has a single prototype
object. The prototype may be the null value.

4.3.4

constructor

function object that creates and initialises objects

NOTE The value of a constructor’s “prototype” property is a prototype
object that is used to implement inheritance and shared properties.

4.3.5

prototype

object that provides shared properties for other objects

NOTE When a constructor creates an object, that object implicitly
references the constructor’s “PROTOTYPE” property for the purpose of
resolving property references. The constructor’s “PROTOTYPE” property
can be referenced by the program expression constructor.PROTOTYPE, and
properties added to an object’s prototype are shared, through
inheritance, by all objects sharing the prototype. Alternatively, a new
object may be created with an explicitly specified prototype by using
the OBJECT.CREATE built-in function.

4.3.6

ordinary object

object that has the default behaviour for the internal methods that must
be supported by all ECMAScript objects.

4.3.7

built-in object

object supplied by an ECMAScript implementation, independent of the host
environment, that is present at the start of the execution of an
ECMAScript program

NOTE Standard built-in objects are defined in this specification, and an
ECMAScript implementation may specify and define others. A _built-in
constructor_ is a built-in object that is also a constructor.

4.3.8

exotic object

object that has some alternative behaviour for one or more of the
internal methods that must be supported by all ECMAScript objects.

NOTE Any object that is not an ordinary object is an exotic object.

4.3.9

undefined value

primitive value used when a variable has not been assigned a value

4.3.10

Undefined type

type whose sole value is the undefined value

4.3.11

null value

primitive value that represents the intentional absence of any object
value

4.3.12

Null type

type whose sole value is the null value

4.3.13

Boolean value

member of the Boolean type

NOTE There are only two Boolean values, TRUE and FALSE.

4.3.14

Boolean type

type consisting of the primitive values TRUE and FALSE

4.3.15

Boolean object

member of the Object type that is an instance of the standard built-in
BOOLEAN constructor

NOTE A Boolean object is created by using the BOOLEAN constructor in a
NEW expression, supplying a Boolean value as an argument. The resulting
object has an internal property whose value is the Boolean value. A
Boolean object can be coerced to a Boolean value.

4.3.16

String value

primitive value that is a finite ordered sequence of zero or more 16-bit
unsigned integer

NOTE A String value is a member of the String type. Each integer value
in the sequence usually represents a single 16-bit unit of UTF-16 text.
However, ECMAScript does not place any restrictions or requirements on
the values except that they must be 16-bit unsigned integers.

4.3.17

String type

set of all possible String values

4.3.18

String object

member of the Object type that is an instance of the standard built-in
STRING constructor

NOTE A String object is created by using the STRING constructor in a NEW
expression, supplying a String value as an argument. The resulting
object has an internal property whose value is the String value. A
String object can be coerced to a String value by calling the STRING
constructor as a function (15.5.1).

4.3.19

Number value

primitive value corresponding to a double-precision 64-bit binary format
IEEE 754 value

NOTE A Number value is a member of the Number type and is a direct
representation of a number.

4.3.20

Number type

set of all possible Number values including the special “Not-a-Number”
(NaN) value, positive infinity, and negative infinity

4.3.21

Number object

member of the Object type that is an instance of the standard built-in
NUMBER constructor

NOTE A Number object is created by using the NUMBER constructor in a NEW
expression, supplying a Number value as an argument. The resulting
object has an internal property whose value is the Number value. A
Number object can be coerced to a Number value by calling the NUMBER
constructor as a function (15.7.1).

4.3.22

Infinity

number value that is the positive infinite Number value

4.3.23

NaN

number value that is a IEEE 754 “Not-a-Number” value

4.3.24

function

member of the Object type that is an instance of the standard built-in
FUNCTION constructor and that may be invoked as a subroutine

NOTE In addition to its named properties, a function contains executable
code and state that determine how it behaves when invoked. A function’s
code may or may not be written in ECMAScript.

4.3.25

built-in function

built-in object that is a function

NOTE Examples of built-in functions include PARSEINT and MATH.EXP. An
implementation may provide implementation-dependent built-in functions
that are not described in this specification.

4.3.26

property

association between a name and a value that is a part of an object

NOTE Depending upon the form of the property the value may be
represented either directly as a data value (a primitive value, an
object, or a function object) or indirectly by a pair of accessor
functions.

4.3.27

method

function that is the value of a property

NOTE When a function is called as a method of an object, the object is
passed to the function as its THIS value.

4.3.28

built-in method

method that is a built-in function

NOTE Standard built-in methods are defined in this specification, and an
ECMAScript implementation may specify and provide other additional
built-in methods.

4.3.29

attribute

internal value that defines some characteristic of a property

4.3.30

own property

property that is directly contained by its object

4.3.31

inherited property

property of an object that is not an own property but is a property
(either own or inherited) of the object’s prototype

A _context-free grammar_ consists of a number of productions. Each
production has an abstract symbol called a nonterminal as its
_left-hand side_, and a sequence of zero or more nonterminal and
terminal symbols as its _right-hand side_. For each grammar, the
terminal symbols are drawn from a specified alphabet.

A chain production is a production that has exactly one nonterminal
symbol on its right-hand side along with zero or more terminal symbols.

Starting from a sentence consisting of a single distinguished
nonterminal, called the _goal symbol_, a given context-free grammar
specifies a language, namely, the (perhaps infinite) set of possible
sequences of terminal symbols that can result from repeatedly replacing
any nonterminal in the sequence with a right-hand side of a production
for which the nonterminal is the left-hand side.

A _lexical grammar_ for ECMAScript is given in clause 7. This grammar
has as its terminal symbols characters (Unicode code units) that conform
to the rules for SourceCharacter defined in Clause 6. It defines a set
of productions, starting from the goal symbol InputElementDiv or
InputElementRegExp, that describe how sequences of such characters are
translated into a sequence of input elements.

Input elements other than white space and comments form the terminal
symbols for the syntactic grammar for ECMAScript and are called
ECMAScript tokens. These tokens are the reserved words, identifiers,
literals, and punctuators of the ECMAScript language. Moreover, line
terminators, although not considered to be tokens, also become part of
the stream of input elements and guide the process of automatic
semicolon insertion (7.9). Simple white space and single-line comments
are discarded and do not appear in the stream of input elements for the
syntactic grammar. A MultiLineComment (that is, a comment of the form
“/*…*/” regardless of whether it spans more than one line) is likewise
simply discarded if it contains no line terminator; but if a
MultiLineComment contains one or more line terminators, then it is
replaced by a single line terminator, which becomes part of the stream
of input elements for the syntactic grammar.

A _RegExp grammar_ for ECMAScript is given in 15.10. This grammar also
has as its terminal symbols the characters as defined by
SourceCharacter. It defines a set of productions, starting from the
goal symbol Pattern, that describe how sequences of characters are
translated into regular expression patterns.

Productions of the lexical and RegExp grammars are distinguished by
having two colons “::” as separating punctuation. The lexical and RegExp
grammars share some productions.

Another grammar is used for translating Strings into numeric values.
This grammar is similar to the part of the lexical grammar having to do
with numeric literals and has as its terminal symbols SourceCharacter.
This grammar appears in 9.3.1.

Productions of the numeric string grammar are distinguished by having
three colons “:::” as punctuation.

The _syntactic grammar_ for ECMAScript is given in clauses 11, 12, 13
and 14. This grammar has ECMAScript tokens defined by the lexical
grammar as its terminal symbols (5.1.2). It defines a set of
productions, starting from the goal symbol Script, that describe how
sequences of tokens can form syntactically correct independent
components of an ECMAScript programs.

When a stream of characters is to be parsed as an ECMAScript script, it
is first converted to a stream of input elements by repeated application
of the lexical grammar; this stream of input elements is then parsed by
a single application of the syntactic grammar. The script is
syntactically in error if the tokens in the stream of input elements
cannot be parsed as a single instance of the goal nonterminal Script,
with no tokens left over.

Productions of the syntactic grammar are distinguished by having just
one colon “:” as punctuation.

The syntactic grammar as presented in clauses 11, 12, 13 and 14 is
actually not a complete account of which token sequences are accepted as
correct ECMAScript scripts. Certain additional token sequences are also
accepted, namely, those that would be described by the grammar if only
semicolons were added to the sequence in certain places (such as before
line terminator characters). Furthermore, certain token sequences that
are described by the grammar are not considered acceptable if a
terminator character appears in certain “awkward” places.

In certain cases in order to avoid ambiguities the syntactic grammar
uses generalize productions that permit token sequences that are not
valid ECMAScript scriptss. For example, this technique is used in with
object literals and object destructuring patterns. In such cases a more
restrictive supplemental grammar is provided that further restricts
the acceptable token sequences. In certain contexts, when explicitly
specific, the input elements corresponding to such a production are
parsed again using a goal symbol of a supplemental grammar. The script
is syntactically in error if the tokens in the stream of input elements
cannot be parsed as a single instance of the supplemental goal symbol,
with no tokens left over.

The JSON grammar is used to translate a String describing a set of
ECMAScript objects into actual objects. The JSON grammar is given in
15.12.1.

The JSON grammar consists of the JSON lexical grammar and the JSON
syntactic grammar. The JSON lexical grammar is used to translate
character sequences into tokens and is similar to parts of the
ECMAScript lexical grammar. The JSON syntactic grammar describes how
sequences of tokens from the JSON lexical grammar can form syntactically
correct JSON object descriptions.

Productions of the JSON lexical grammar are distinguished by having two
colons “::” as separating punctuation. The JSON lexical grammar uses
some productions from the ECMAScript lexical grammar. The JSON syntactic
grammar is similar to parts of the ECMAScript syntactic grammar.
Productions of the JSON syntactic grammar are distinguished by using one
colon “:” as separating punctuation.

Terminal symbols of the lexical, RegExp, and numeric string grammars,
and some of the terminal symbols of the other grammars, are shown in
FIXED WIDTH font, both in the productions of the grammars and throughout
this specification whenever the text directly refers to such a terminal
symbol. These are to appear in a script exactly as written. All terminal
symbol characters specified in this way are to be understood as the
appropriate Unicode character from the ASCII range, as opposed to any
similar-looking characters from other Unicode ranges.

Nonterminal symbols are shown in italic type. The definition of a
nonterminal (also called a “production”) is introduced by the name of
the nonterminal being defined followed by one or more colons. (The
number of colons indicates to which grammar the production belongs.) One
or more alternative right-hand sides for the nonterminal then follow on
succeeding lines. For example, the syntactic definition:

WhileStatement :

WHILE ( Expression ) Statement

states that the nonterminal WhileStatement represents the token WHILE,
followed by a left parenthesis token, followed by an Expression,
followed by a right parenthesis token, followed by a Statement. The
occurrences of Expression and Statement are themselves nonterminals.
As another example, the syntactic definition:

ArgumentList :

AssignmentExpression
ArgumentList , AssignmentExpression

states that an ArgumentList may represent either a single
AssignmentExpression or an ArgumentList, followed by a comma,
followed by an AssignmentExpression. This definition of ArgumentList
is recursive, that is, it is defined in terms of itself. The result is
that an ArgumentList may contain any positive number of arguments,
separated by commas, where each argument expression is an
AssignmentExpression. Such recursive definitions of nonterminals are
common.

The subscripted suffix “~opt~”, which may appear after a terminal or
nonterminal, indicates an optional symbol. The alternative containing
the optional symbol actually specifies two right-hand sides, one that
omits the optional element and one that includes it. This means that:

VariableDeclaration :

Identifier Initialiser~opt~

is a convenient abbreviation for:

VariableDeclaration :

Identifier
Identifier Initialiser

and that:

IterationStatement :

FOR ( ExpressionNoIn~opt~ ; Expression~opt~ ; Expression~opt~ )
Statement

is a convenient abbreviation for:

IterationStatement :

FOR ( ; Expression~opt~ ; Expression~opt~ ) Statement
FOR ( ExpressionNoIn ; Expression~opt~ ; Expression~opt~ ) Statement

which in turn is an abbreviation for:

IterationStatement :

FOR ( ; ; Expression~opt~ ) Statement
FOR ( ; Expression ; Expression~opt~ ) Statement
FOR ( ExpressionNoIn ; ; Expression~opt~ ) Statement
FOR ( ExpressionNoIn ; Expression ; Expression~opt~ ) Statement

which in turn is an abbreviation for:

IterationStatement :

FOR ( ; ; ) Statement
FOR ( ; ; Expression ) Statement
FOR ( ; Expression ; ) Statement
FOR ( ; Expression ; Expression ) Statement
FOR ( ExpressionNoIn ; ; ) Statement
FOR ( ExpressionNoIn ; ; Expression ) Statement
FOR ( ExpressionNoIn ; Expression ; ) Statement
FOR ( ExpressionNoIn ; Expression ; Expression ) Statement

so the nonterminal IterationStatement actually has eight alternative
right-hand sides.

When the words “ONE OF” follow the colon(s) in a grammar definition,
they signify that each of the terminal symbols on the following line or
lines is an alternative definition. For example, the lexical grammar for
ECMAScript contains the production:

NonZeroDigit :: ONE OF

1 2 3 4 5 6 7 8 9

which is merely a convenient abbreviation for:

NonZeroDigit ::

1
2
3
4
5
6
7
8
9

If the phrase “[empty]” appears as the right-hand side of a production,
it indicates that the production's right-hand side contains no terminals
or nonterminals.

If the phrase “[lookahead ∉ set]” appears in the right-hand side of a
production, it indicates that the production may not be used if the
immediately following input token is a member of the given set. The
set can be written as a list of terminals enclosed in curly braces.
For convenience, the set can also be written as a nonterminal, in which
case it represents the set of all terminals to which that nonterminal
could expand. For example, given the definitions

DecimalDigit :: ONE OF

0 1 2 3 4 5 6 7 8 9

DecimalDigits ::

DecimalDigit
DecimalDigits DecimalDigit

the definition

LookaheadExample ::

N [lookahead ∉ {1, 3, 5, 7, 9}] DecimalDigits
DecimalDigit [lookahead ∉ DecimalDigit ]

matches either the letter N followed by one or more decimal digits the
first of which is even, or a decimal digit not followed by another
decimal digit.

If the phrase “[no LineTerminator here]” appears in the right-hand
side of a production of the syntactic grammar, it indicates that the
production is _a restricted production_: it may not be used if a
LineTerminator occurs in the input stream at the indicated position.
For example, the production:

ThrowStatement :

THROW [no LineTerminator here] Expression ;

indicates that the production may not be used if a LineTerminator
occurs in the script between the THROW token and the Expression.

Unless the presence of a LineTerminator is forbidden by a restricted
production, any number of occurrences of LineTerminator may appear
between any two consecutive tokens in the stream of input elements
without affecting the syntactic acceptability of the script.

The lexical grammar has multiple goal symbols and the appropriate goal
symbol to use depends upon the syntactic grammar context. If a phrase of
the form “[Lexical goal LexicalGoalSymbol]” appears on the
right-hand-side of a syntactic production then the next token must be
lexically recognized using the indicated goal symbol. In the absence of
such a phrase the default lexical goal symbol is used.

When an alternative in a production of the lexical grammar or the
numeric string grammar appears to be a multi-character token, it
represents the sequence of characters that would make up such a token.

The right-hand side of a production may specify that certain expansions
are not permitted by using the phrase “BUT NOT” and then indicating the
expansions to be excluded. For example, the production:

Identifier ::

IdentifierName BUT NOT ReservedWord

means that the nonterminal Identifier may be replaced by any sequence
of characters that could replace IdentifierName provided that the same
sequence of characters could not replace ReservedWord.

Finally, a few nonterminal symbols are described by a descriptive phrase
in sans-serif type in cases where it would be impractical to list all
the alternatives:

SourceCharacter ::

any Unicode character

The specification often uses a numbered list to specify steps in an
algorithm. These algorithms are used to precisely specify the required
semantics of ECMAScript language constructs. The algorithms are not
intended to imply the use of any specific implementation technique. In
practice, there may be more efficient algorithms available to implement
a given feature.

Algorithms may be explicitly parameterized, in which case the names and
usage of the parameters must be provided as part of the algorithm’s
definition. In order to facilitate their use in multiple parts of this
specification, some algorithms, called abstract operations, are
named and written in parameterised functional form so that they may be
referenced by name from within other algorithms.

Algorithms may be associated with productions of one of the ECMAScript
grammars. A production that has multiple alternative definitions will
typically have a distinct algorithm for each alternative. When an
algorithm is associated with a grammar production, it may reference the
terminal and non-terminal symbols of the production alternative as if
they were parameters of the algorithm. When used in this manner,
non-terminal symbols refer to the actual alternative definition that is
matched when parsing the script souce code.

Unless explicitly specified otherwise, all chain productions have an
implicit associated definition for every algorithm that is might be
applied to that production’s left-hand side nonterminal. The implicit
simply reapplies the same algorithm name with the same parameters, if
any, to the chain production’s sole right-hand side nonterminal and then
result. For example, assume there is a production

Block :

{ StatementList }

but there is no evalution algorithm that is explicitly specified for
that production. If in some algorithm there is a statement of the form:
“Return the result of evaluating Block” it is implicit that the
algorithm has an evalution algorithm of the form:

  RUNTIME SEMANTICS: EVALUATION

  Block : { StatementList }

1.  Return the result of evaluating StatementList

For clarity of expression, algorithm steps may be subdivided into
sequential substeps. Substeps are indented and may themselves be further
divided into indented substeps. Outline numbering conventions are used
to identify substeps with the first level of substeps labelled with
lower case alphabetic characters and the second level of substeps
labelled with lower case roman numerals. If more than three levels are
required these rules repeat with the fourth level using numeric labels.
For example:

A step or substep may be written as an “if” predicate that conditions
its substeps. In this case, the substeps are only applied if the
predicate is true. If a step or substep begins with the word “else”, it
is a predicate that is the negation of the preceding “if” predicate step
at the same level.

A step may specify the iterative application of its substeps.

A step may assert an invariant condition of its algorithm. Such
assertions are used to make explicit algorithmic invariants that would
otherwise be implicit. Such assertions add no additional semantic
requirements and hence need not be checked by an implementation. They
are used simply to clarify algorithms.

Mathematical operations such as addition, subtraction, negation,
multiplication, division, and the mathematical functions defined later
in this clause should always be understood as computing exact
mathematical results on mathematical real numbers, which do not include
infinities and do not include a negative zero that is distinguished from
positive zero. Algorithms in this standard that model floating-point
arithmetic include explicit steps, where necessary, to handle infinities
and signed zero and to perform rounding. If a mathematical operation or
function is applied to a floating-point number, it should be understood
as being applied to the exact mathematical value represented by that
floating-point number; such a floating-point number must be finite, and
if it is +0 or −0 then the corresponding mathematical value is simply 0.

The mathematical function abs(x) yields the absolute value of x,
which is −x if x is negative (less than zero) and otherwise is x
itself.

The mathematical function sign(x) yields 1 if x is positive and −1
if x is negative. The sign function is not used in this standard for
cases when x is zero.

The notation “x modulo y” (y must be finite and nonzero) computes
a value k of the same sign as y (or zero) such that abs(k) <
abs(y) and x_−_k = q × y for some integer q.

The mathematical function floor(x) yields the largest integer (closest
to positive infinity) that is not larger than x.

NOTE floor(x) = x_−(_x modulo 1).

If an algorithm is defined to “throw an exception”, execution of the
algorithm is terminated and no result is returned. The calling
algorithms are also terminated, until an algorithm step is reached that
explicitly deals with the exception, using terminology such as “If an
exception was thrown…”. Once such an algorithm step has been encountered
the exception is no longer considered to have occurred.

Context-free grammars are not sufficiently powerful to express all the
rules that define whether a stream of input elements make up a valid
ECMAScript script that may be evaluated. In some situations additional
rules are needed that may be expressed using either ECMAScript algorithm
conventions or prose requirements. Such rules are always associated with
a production of a grammar and are called the _static semantics_ of the
production.

Static Semantic Rules have names and typically are defined using an
algorithm. Named Static Semantic Rules are associated with grammar
productions and a production that has multiple alternative definitions
will typically have for each alternative a distinct algorithm for each
applicable named static semantic rule.

Unless otherwise specified every grammar production alternative in this
specification implicitly has a definition for a static semantic rule
named Contains which takes an argument named symbol whose value is a
terminal or non-terminal of the grammer that includes the associated
production. The default definition of Contains is:

1.  For each terminal and non-terminal grammar symbol, sym, in the
    definition of this production do

    a.  If sym is the same grammar symbol as symbol, return TRUE.

    b.  If sym is a non-terminal, then

        i.  Let contained be the result of Contains for sym with
            argument symbol.

        ii. If contained is TRUE, return TRUE.

2.  Return FALSE.

The above definition is explicitly over-ridden for specific productions.

A special kind of static semantic rule is an Early Error Rule. Early
error rules define early error conditions (see clause 16) that are
associate with specific grammar productions. Evaluation of most early
error rules are not explicitly invoked within the algorithms of this
specification. A comforming implementation must, prior to the first
evaluation of a Script, validate all of the early error rules of the
productions used to parse that Script. If any of the early error rules
are violated the Script is invalid and can not be evaluated.

Syntax

SourceCharacter ::

any Unicode character

The ECMAScript code is expressed using Unicode, version 5.1 or later.
ECMAScript source text is a sequence of Unicode characters. The phrase
“Unicode character” refers to the abstract linguistic or typographical
unit represented by a single Unicode scalar value. The actual encodings
used to store and interchange ECMAScript source text is not relevant to
this specification. Any well defined encoding such as UTF-32 or UTF-16
may be used. Source text might even be externally represented using a
non-Unicode character encoding. Regardless of the external source text
encoding, a conforming ECMAScript implementation processes the source
text as if it was an equivalent sequence of SourceCharacter values.
Each SourceCharacter being an abstract Unicode character with a
corresponding Unicode scalar value. Conforming ECMAScript
implementations are not required to perform any normalisation of text,
or behave as though they were performing normalisation of text.

The phrase “code point” refers to such a Unicode scalar value. “Unicode
character” only refers to entities represented by single Unicode scalar
values: the components of a combining character sequence are still
individual “Unicode characters,” even though a user might think of the
whole sequence as a single character.

In string literals, regular expression literals,template literals and
identifiers, any Unicode characters may also be expressed as a Unicode
escape sequence that explicitly express a code point’s numeric value.
Within a comment, such an escape sequence is effectively ignored as part
of the comment. Within other contexts, such an escape sequence
contextually contributes one Unicode character.

NOTE

ECMAScript differs from the Java programming language in the behaviour
of Unicode escape sequences. In a Java program, if the Unicode escape
sequence \U000A, for example, occurs within a single-line comment, it is
interpreted as a line terminator (Unicode character 000A is line feed)
and therefore the next Unicode character is not part of the comment.
Similarly, if the Unicode escape sequence \U000A occurs within a string
literal in a Java program, it is likewise interpreted as a line
terminator, which is not allowed within a string literal—one must write
\N instead of \U000A to cause a line feed to be part of the string value
of a string literal. In an ECMAScript program, a Unicode escape sequence
occurring within a comment is never interpreted and therefore cannot
contribute to termination of the comment. Similarly, a Unicode escape
sequence occurring within a string literal in an ECMAScript program
always contributes a Unicode character to the literal and is never
interpreted as a line terminator or as a quote mark that might terminate
the string literal.

ECMAScript String values (8.4) are computational sequences of 16-bit
integer values called “code units”. ECMAScript language constructs that
generate string values from SourceCharacter sequences use UTF-16
encoding to generate the code unit values.

STATIC SEMANTICS: UTF-16 ENCODING

The UTF-16 Encoding of a numeric code point value, cp, is deterimined
as follows:

1.  Assert: 0 ≤ cp ≤ 0x10FFFF

2.  If cp ≤ 65535, then return cp.

3.  Let cu1 be floor((cp – 65536) / 1024) + 55296. NOTE 55296 is
    0xD800.

4.  Let cu2 be ((cp – 65536) modulo 1024) + 56320. NOTE 56320 is
    0xDC00.

5.  Return the code unit sequence consisting of cu1 followed by cu2.

The source text of an ECMAScript script is first converted into a
sequence of input elements, which are tokens, line terminators,
comments, or white space. The source text is scanned from left to right,
repeatedly taking the longest possible sequence of characters as the
next input element.

There are several situations where the identification of lexical input
elements is sensitive to the syntactic grammar context that is consuming
the input elements. This requires multiple goal symbols for the lexical
grammar. The InputElementDiv goal symbol is the default goal symbol
and is used in those syntactic grammar contexts where a leading division
(/) or division-assignment (/=) operator is permitted. The
InputElementRegExp goal symbol is used in all syntactic grammar
contexts where a RegularExpressionLiteral is permitted. The
InputElementTemplateTail goal is used in syntactic grammar contexts
where a TemplateLiteral logically continues after a substitution
element.

NOTE There are no syntactic grammar contexts where both a leading
division or division-assignment, and a leading
RegularExpressionLiteral are permitted. This is not affected by
semicolon insertion (see 7.9); in examples such as the following:

  A = B
  /HI/G.EXEC(C).MAP(D);

where the first non-whitespace, non-comment character after a
LineTerminator is slash (/) and the syntactic context allows division
or division-assignment, no semicolon is inserted at the
LineTerminator. That is, the above example is interpreted in the same
way as:

  A = B / HI / G.EXEC(C).MAP(D);

Syntax

InputElementDiv ::

WhiteSpace
LineTerminator
Comment
Token
DivPunctuator
RightBracePunctuator

InputElementRegExp ::

WhiteSpace
LineTerminator
Comment
Token
RightBracePunctuator
RegularExpressionLiteral

InputElementTemplateTail ::

WhiteSpace
LineTerminator
Comment
Token
DivPunctuator
TemplateSubstitutionTail

The Unicode format-control characters (i.e., the characters in category
“Cf” in the Unicode Character Database such as left-to-right mark or
right-to-left mark) are control codes used to control the formatting of
a range of text in the absence of higher-level protocols for this (such
as mark-up languages).

It is useful to allow format-control characters in source text to
facilitate editing and display. All format control characters may be
used within comments, and within string literals, template literals, and
regular expression literals.

<ZWNJ> and <ZWJ> are format-control characters that are used to make
necessary distinctions when forming words or phrases in certain
languages. In ECMAScript source text, <ZWNJ> and <ZWJ> may also be used
in an identifier after the first character.

<BOM> is a format-control character used primarily at the start of a
text to mark it as Unicode and to allow detection of the text's encoding
and byte order. <BOM> characters intended for this purpose can sometimes
also appear after the start of a text, for example as a result of
concatenating files. <BOM> characters are treated as white space
characters (see 7.2).

The special treatment of certain format-control characters outside of
comments, string literals, and regular expression literals is summarised
in Table 1.

Table 1 — Format-Control Character Usage

  ---------------- ----------------------- --------------- ------------------
  CODE POINT   NAME                  _FORMAL NAME_   USAGE
  U+200C           Zero width non-joiner   <ZWNJ>          IdentifierPart
  U+200D           Zero width joiner       <ZWJ>           IdentifierPart
  U+FEFF           Byte Order Mark         <BOM>           Whitespace
  ---------------- ----------------------- --------------- ------------------

White space characters are used to improve source text readability and
to separate tokens (indivisible lexical units) from each other, but are
otherwise insignificant. White space characters may occur between any
two tokens and at the start or end of input. White space characters may
occur within a StringLiteral, a RegularExpressionLiteral, a
Template, or a TemplateSubstitutionTail where they are considered
significant characters forming part of a literal value. They may also
occur within a Comment, but cannot appear within any other kind of
token.

The ECMAScript white space characters are listed in Table 2.

Table 2 — Whitespace Characters

  --------------------- ------------------------------------- ---------------
  CODE POINT        NAME                                _FORMAL NAME_

  U+0009                Tab                                   <TAB>

  U+000B                Vertical Tab                          <VT>

  U+000C                Form Feed                             <FF>

  U+0020                Space                                 <SP>

  U+00A0                No-break space                        <NBSP>

  U+FEFF                Byte Order Mark                       <BOM>
                                                              
  Other category “Zs”   Any other Unicode “space separator”   <USP>
  --------------------- ------------------------------------- ---------------

ECMAScript implementations must recognise all of the white space
characters defined in Unicode 5.1. Later editions of the Unicode
Standard may define other white space characters. ECMAScript
implementations may recognise white space characters from later editions
of the Unicode Standard.

Syntax

WhiteSpace ::

<TAB>
<VT>
<FF>
<SP>
<NBSP>
<BOM>
<USP>

Like white space characters, line terminator characters are used to
improve source text readability and to separate tokens (indivisible
lexical units) from each other. However, unlike white space characters,
line terminators have some influence over the behaviour of the syntactic
grammar. In general, line terminators may occur between any two tokens,
but there are a few places where they are forbidden by the syntactic
grammar. Line terminators also affect the process of automatic semicolon
insertion (7.9). A line terminator cannot occur within any token except
a StringLiteral, Template, or TemplateSubstitutionTail. Line
terminators may only occur within a StringLiteral token as part of a
LineContinuation.

A line terminator can occur within a MultiLineComment (7.4) but cannot
occur within a SingleLineComment.

Line terminators are included in the set of white space characters that
are matched by the \S class in regular expressions.

The ECMAScript line terminator characters are listed in Table 3.

Table 3 — Line Terminator Characters

  ---------------- --------------------- ---------------
  CODE POINT   NAME                _FORMAL NAME_
  U+000A           Line Feed             <LF>
  U+000D           Carriage Return       <CR>
  U+2028           Line separator        <LS>
  U+2029           Paragraph separator   <PS>
  ---------------- --------------------- ---------------

Only the Unicode characters in Table 3 are treated as line terminators.
Other new line or line breaking Unicode characters are treated as white
space but not as line terminators. The sequence <CR><LF> is commonly
used as a line terminator. It should be considered a single
SourceCharacter for the purpose of reporting line numbers.

Syntax

LineTerminator ::

<LF>
<CR>
<LS>
<PS>

LineTerminatorSequence ::

<LF>
<CR> [lookahead ∉ <LF> ]
<LS>
<PS>
<CR> <LF>

Comments can be either single or multi-line. Multi-line comments cannot
nest.

Because a single-line comment can contain any Unicode character except a
LineTerminator character, and because of the general rule that a token
is always as long as possible, a single-line comment always consists of
all characters from the // marker to the end of the line. However, the
LineTerminator at the end of the line is not considered to be part of
the single-line comment; it is recognised separately by the lexical
grammar and becomes part of the stream of input elements for the
syntactic grammar. This point is very important, because it implies that
the presence or absence of single-line comments does not affect the
process of automatic semicolon insertion (see 7.9).

Comments behave like white space and are discarded except that, if a
MultiLineComment contains a line terminator character, then the entire
comment is considered to be a LineTerminator for purposes of parsing
by the syntactic grammar.

Syntax

Comment ::

MultiLineComment
SingleLineComment

MultiLineComment ::

/* MultiLineCommentChars~opt~ */

MultiLineCommentChars ::

MultiLineNotAsteriskChar MultiLineCommentChars~opt~
* PostAsteriskCommentChars~opt~

PostAsteriskCommentChars ::

MultiLineNotForwardSlashOrAsteriskChar MultiLineCommentChars~opt~
* PostAsteriskCommentChars~opt~

MultiLineNotAsteriskChar ::

SourceCharacter BUT NOT *

MultiLineNotForwardSlashOrAsteriskChar ::

SourceCharacter BUT NOT ONE OF / OR *

SingleLineComment ::

// SingleLineCommentChars~opt~

SingleLineCommentChars ::

SingleLineCommentChar SingleLineCommentChars~opt~

SingleLineCommentChar ::

SourceCharacter BUT NOT LineTerminator

Syntax

Token ::

IdentifierName
Punctuator
NumericLiteral
StringLiteral
Template

NOTE The DivPunctuator, RegularExpressionLiteral,
RightBracePunctuator, and TemplateSubstitutionTail productions
define tokens, but are not included in the Token production.

IdentifierName, Identifier, and ReservedWord are tokens that are
interpreted according to the Default Identifier Syntax given in Unicode
Standard Annex #31, Identifier and Pattern Syntax, with some small
modifications. ReservedWord is is an enumerated subset of
IdentifierName and Identifier is an IdentifierName that is not a
ReservedWord (see 7.6.1). The Unicode identifier grammar is based on
character properties specified by the Unicode Standard. The Unicode
characters in the specified categories in version 5.1.0 of the Unicode
standard must be treated as in those categories by all conforming
ECMAScript implementations. ECMAScript implementations may recognise
identifier characters defined in later editions of the Unicode Standard.

NOTE 1 This standard specifies specific character additions: The dollar
sign (U+0024) and the underscore (U+005F) are permitted anywhere in an
IdentifierName, and the characters zero width non-joiner (U+200C) and
zero width joiner (U+200D) are permitted anywhere after the first
character of an IdentifierName.

Unicode escape sequences are permitted in an IdentifierName, where
they contribute a single Unicode character to the IdentifierName. The
code point of the contributed character is expressed by the HexDigits
of the UnicodeEscapeSequence (see 7.8.4). The \ preceding the
UnicodeEscapeSequence and the U and { } characters, if they appear, do
not contribute characters to the IdentifierName. A
UnicodeEscapeSequence cannot be used to put a character into an
IdentifierName that would otherwise be illegal. In other words, if a \
UnicodeEscapeSequence sequence were replaced by the Unicode character
it constributes, the result must still be a valid IdentifierName that
has the exact same sequence of characters as the original
IdentifierName. All interpretations of IdentifierName within this
specification are based upon their actual characters regardless of
whether or not an escape sequence was used to contribute any particular
characters.

Two IdentifierName that are canonically equivalent according to the
Unicode standard are not equal unless they are represented by the
exact same sequence of code units (in other words, conforming ECMAScript
implementations are only required to do bitwise comparison on
IdentifierName values).

NOTE 2 If maximal portability is a concern, programmers should only
employ the identifier characters that were defined in Unicode 3.0.

Syntax

Identifier ::

IdentifierName BUT NOT ReservedWord

IdentifierName ::

IdentifierStart
IdentifierName IdentifierPart

IdentifierStart ::

UnicodeIDStart
$
_
\ UnicodeEscapeSequence

IdentifierPart ::

UnicodeIDContinue
$
_
\ UnicodeEscapeSequence
<ZWNJ>
<ZWJ>

UnicodeIDStart ::

any Unicode character with the Unicode property “ID_Start”.

UnicodeIDContinue ::

any Unicode character with the Unicode property “ID_Continue”

The definitions of the nonterminal UnicodeEscapeSequence is given in
7.8.4

STATIC SEMANTICS: STRINGVALUE

Identifier :: IdentifierName BUT NOT ReservedWord

1.  Return the StringValue of IdentifierName.

IdentifierName ::

IdentifierStart
IdentifierName IdentifierPart

1.  Return the String value consisting of the sequence of code units
    corresponding to IdentifierName. In determining the sequence any
    occurrences of \ UnicodeEscapeSequence are first replaced with the
    code point represented by the UnicodeEscapeSequence and and then
    the code points of the entire IdentifierName are converted to code
    units by UTF-16 Encoding (clause 6) each code point.

A reserved word is an IdentifierName that cannot be used as an
Identifier.

Syntax

ReservedWord ::

Keyword
FutureReservedWord
NullLiteral
BooleanLiteral

The ReservedWord definitions are specified as literal sequences of
Unicode characters. However, any Unicode character in a ReservedWord
can also be expressed by a \ UnicodeEscapeSequence that expresses that
same Unicode character’s code point. Use of such escape sequences does
not change the meaning of the ReservedWord.

The following tokens are ECMAScript keywords and may not be used as
Identifiers in ECMAScript programs.

Syntax

Keyword :: ONE OF

  ---------- ---------- ------------ --------
  break      delete     import       this
  case       do         in           throw
  catch      else       instanceof   try
  class      export     let          typeof
  continue   finally    new          var
  const      for        return       void
  debugger   function   super        while
  default    if         switch       with
  ---------- ---------- ------------ --------

The following words are used as keywords in proposed extensions and are
therefore reserved to allow for the possibility of future adoption of
those extensions.

Syntax

FutureReservedWord :: ONE OF

  -- ------ --------- --
     enum   extends   
                      
  -- ------ --------- --

The following tokens are also considered to be FutureReservedWords
when they occur within strict mode code (see 10.1.1). The occurrence of
any of these tokens within strict mode code in any context where the
occurrence of a FutureReservedWord would produce an error must also
produce an equivalent error:

  ------------ --------- ----------- -------- -------
  implements             private     public   yield
  interface    package   protected   static   
  ------------ --------- ----------- -------- -------

Syntax

Punctuator :: ONE OF

  ----- ------ ----- ----- ----- -----
  {     (      )     [     ]     
  .     ;      ,     <     >     <=
  >=    ==     !=    ===   !==   
  +     -      *     %     ++    --
  <<    >>     >>>   &     |     ^
  !     ~      &&    ||    ?     :
  =     +=     -=    *=    %=    <<=
  >>=   >>>=   &=    |=    ^=    =>
  ----- ------ ----- ----- ----- -----

DivPunctuator :: ONE OF

  --- ---- -- -- -- --
  /   /=            
  --- ---- -- -- -- --

RightBracePunctuator ::

  --- -- -- -- -- --
  }               
  --- -- -- -- -- --

Syntax

NullLiteral ::

NULL

Syntax

BooleanLiteral ::

TRUE
FALSE

Syntax

NumericLiteral ::

DecimalLiteral
BinaryIntegerLiteral
OctalIntegerLiteral
HexIntegerLiteral

DecimalLiteral ::

DecimalIntegerLiteral . DecimalDigits~opt~ ExponentPart~opt~
. DecimalDigits ExponentPart~opt~
DecimalIntegerLiteral ExponentPart~opt~

DecimalIntegerLiteral ::

0
NonZeroDigit DecimalDigits~opt~

DecimalDigits ::

DecimalDigit
DecimalDigits DecimalDigit

DecimalDigit :: ONE OF

0 1 2 3 4 5 6 7 8 9

NonZeroDigit :: ONE OF

1 2 3 4 5 6 7 8 9

ExponentPart ::

ExponentIndicator SignedInteger

ExponentIndicator :: ONE OF

E E

SignedInteger ::

DecimalDigits
+ DecimalDigits
- DecimalDigits

BinaryIntegerLiteral ::

0B BinaryDigit
0B BinaryDigit
BinaryIntegerLiteral BinaryDigit

BinaryDigit :: ONE OF

0 1

OctalIntegerLiteral ::

0O OctalDigit
0O OctalDigit
OctalIntegerLiteral OctalDigit

OctalDigit :: ONE OF

0 1 2 3 4 5 6 7

HexIntegerLiteral ::

0X HexDigits
0X HexDigits

HexDigits ::

HexDigit
HexDigits HexDigit

HexDigit :: one of

0 1 2 3 4 5 6 7 8 9 A B C D E F A B C D E F

The SourceCharacter immediately following a NumericLiteral must not
be an IdentifierStart or DecimalDigit.

NOTE For example:

  3in

is an error and not the two input elements 3 and IN.

A conforming implementation, when processing strict mode code (see
10.1.1), must not extend the syntax of NumericLiteral to include
OctalIntegerLiteral as described in B.1.1.

Static Semantics: MV’s

A numeric literal stands for a value of the Number type. This value is
determined in two steps: first, a mathematical value (MV) is derived
from the literal; second, this mathematical value is rounded as
described below.

-   The MV of NumericLiteral :: DecimalLiteral is the MV of
    DecimalLiteral.

-   The MV of NumericLiteral :: BinaryIntegerLiteral is the MV of
    BinaryIntegerLiteral.

-   The MV of NumericLiteral :: OctalIntegerLiteral is the MV of
    OctalIntegerLiteral.

-   The MV of NumericLiteral :: HexIntegerLiteral is the MV of
    HexIntegerLiteral.

-   The MV of DecimalLiteral :: DecimalIntegerLiteral . is the MV of
    DecimalIntegerLiteral.

-   The MV of DecimalLiteral :: DecimalIntegerLiteral .
    DecimalDigits is the MV of DecimalIntegerLiteral plus (the MV of
    DecimalDigits times 10^–n^), where n is the number of
    characters in DecimalDigits.

-   The MV of DecimalLiteral :: DecimalIntegerLiteral .
    ExponentPart is the MV of DecimalIntegerLiteral times 10^e^,
    where e is the MV of ExponentPart.

-   The MV of DecimalLiteral :: DecimalIntegerLiteral .
    _DecimalDigits ExponentPart_ is (the MV of DecimalIntegerLiteral
    plus (the MV of DecimalDigits times 10^–n^)) times 10^e^,
    where n is the number of characters in DecimalDigits and e is
    the MV of ExponentPart.

-   The MV of DecimalLiteral ::. DecimalDigits is the MV of
    DecimalDigits times 10^–n^, where n is the number of
    characters in DecimalDigits.

-   The MV of DecimalLiteral ::. _DecimalDigits ExponentPart_ is the
    MV of DecimalDigits times 10^e_–_n^, where n is the number of
    characters in DecimalDigits and e is the MV of ExponentPart.

-   The MV of DecimalLiteral :: DecimalIntegerLiteral is the MV of
    DecimalIntegerLiteral.

-   The MV of DecimalLiteral :: _DecimalIntegerLiteral ExponentPart_
    is the MV of DecimalIntegerLiteral times 10^e^, where e is the
    MV of ExponentPart.

-   The MV of DecimalIntegerLiteral :: 0 is 0.

-   The MV of DecimalIntegerLiteral :: NonZeroDigit is the MV of
    NonZeroDigit.

-   The MV of DecimalIntegerLiteral :: NonZeroDigit DecimalDigits
    is (the MV of NonZeroDigit times 10^n^) plus the MV of
    DecimalDigits, where n is the number of characters in
    DecimalDigits.

-   The MV of DecimalDigits :: DecimalDigit is the MV of
    DecimalDigit.

-   The MV of DecimalDigits :: DecimalDigits DecimalDigit is (the
    MV of DecimalDigits times 10) plus the MV of DecimalDigit.

-   The MV of ExponentPart :: _ExponentIndicator SignedInteger_ is the
    MV of SignedInteger.

-   The MV of SignedInteger :: DecimalDigits is the MV of
    DecimalDigits.

-   The MV of SignedInteger :: + DecimalDigits is the MV of
    DecimalDigits.

-   The MV of SignedInteger :: - DecimalDigits is the negative of
    the MV of DecimalDigits.

-   The MV of DecimalDigit :: 0 or of HexDigit :: 0 or of
    OctalDigit :: 0 or of BinaryDigit :: 0 is 0.

-   The MV of DecimalDigit :: 1 or of NonZeroDigit :: 1 or of
    HexDigit :: 1 or of OctalDigit :: 1 or
    of BinaryDigit :: 1 is 1.

-   The MV of DecimalDigit :: 2 or of NonZeroDigit :: 2 or of
    HexDigit :: 2 or of OctalDigit :: 2 is 2.

-   The MV of DecimalDigit :: 3 or of NonZeroDigit :: 3 or of
    HexDigit :: 3 or of OctalDigit :: 3 is 3.

-   The MV of DecimalDigit :: 4 or of NonZeroDigit :: 4 or of
    HexDigit :: 4 or of OctalDigit :: 4 is 4.

-   The MV of DecimalDigit :: 5 or of NonZeroDigit :: 5 or of
    HexDigit :: 5 or of OctalDigit :: 5 is 5.

-   The MV of DecimalDigit :: 6 or of NonZeroDigit :: 6 or of
    HexDigit :: 6 or of OctalDigit :: 6 is 6.

-   The MV of DecimalDigit :: 7 or of NonZeroDigit :: 7 or of
    HexDigit :: 7 or of OctalDigit :: 7 is 7.

-   The MV of DecimalDigit :: 8 or of NonZeroDigit :: 8 or of
    HexDigit :: 8 is 8.

-   The MV of DecimalDigit :: 9 or of NonZeroDigit :: 9 or of
    HexDigit :: 9 is 9.

-   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   The
    MV of HexDigit :: A or of HexDigit :: A is 10.

-   The MV of HexDigit :: B or of HexDigit :: B is 11.

-   The MV of HexDigit :: C or of HexDigit :: C is 12.

-   The MV of HexDigit :: D or of HexDigit :: D is 13.

-   The MV of HexDigit :: E or of HexDigit :: E is 14.

-   The MV of HexDigit :: F or of HexDigit :: F is 15.

-   The MV of BinaryIntegerLiteral :: 0B BinaryDigit is the MV of
    BinaryDigit.

-   The MV of BinaryIntegerLiteral :: 0B BinaryDigit is the MV of
    BinaryDigit.

-   The MV of BinaryIntegerLiteral :: BinaryIntegerLiteral
    BinaryDigit is (the MV of BinaryIntegerLiteral times 2) plus the
    MV of BinaryDigit.

-   The MV of OctalIntegerLiteral :: 0O OctalDigit is the MV of
    OctalDigit.

-   The MV of OctalIntegerLiteral :: 0O OctalDigit is the MV of
    OctalDigit.

-   The MV of OctalIntegerLiteral :: OctalIntegerLiteral
    OctalDigit is (the MV of OctalIntegerLiteral times 8) plus the
    MV of OctalDigit.

-   The MV of HexIntegerLiteral :: 0X HexDigits is the MV of
    HexDigits.

-   The MV of HexIntegerLiteral :: 0X HexDigits is the MV of
    HexDigits.

-   The MV of HexDigits :: HexDigit is the MV of HexDigit.

-   The MV of HexDigits :: HexDigits HexDigit is (the MV of
    HexDigits times 16) plus the MV of HexDigit.

Once the exact MV for a numeric literal has been determined, it is then
rounded to a value of the Number type. If the MV is 0, then the rounded
value is +0; otherwise, the rounded value must be the Number value for
the MV (as specified in 8.5), unless the literal is a DecimalLiteral
and the literal has more than 20 significant digits, in which case the
Number value may be either the Number value for the MV of a literal
produced by replacing each significant digit after the 20th with a 0
digit or the Number value for the MV of a literal produced by replacing
each significant digit after the 20th with a 0 digit and then
incrementing the literal at the 20th significant digit position. A digit
is significant if it is not part of an ExponentPart and

-   it is not 0; or

-   there is a nonzero digit to its left and there is a nonzero digit,
    not in the ExponentPart, to its right.

NOTE A string literal is zero or more Unicode code points enclosed in
single or double quotes. Unicode code points may also be be represented
by an escape sequence. All characters may appear literally in a string
literal except for the closing quote character, backslash, carriage
return, line separator, paragraph separator, and line feed. Any
character may appear in the form of an escape sequence. String literals
evaluate to ECAMScript String values. When generating these string
values Unicode code points are UTF-16 encoded as defined in clause 6.
Code points belonging to Basic Multilingual Plane are encoded as a
single code unit element of the string. All other code points are
encoded as two code unit elements of the string.

Syntax

StringLiteral ::

" DoubleStringCharacters~opt~ "
' SingleStringCharacters~opt~ '

DoubleStringCharacters ::

DoubleStringCharacter DoubleStringCharacters~opt~

SingleStringCharacters ::

SingleStringCharacter SingleStringCharacters~opt~

DoubleStringCharacter ::

SourceCharacter BUT NOT ONE OF " OR \ OR LineTerminator
\ EscapeSequence
LineContinuation

SingleStringCharacter ::

SourceCharacter BUT NOT ONE OF ' OR \ OR LineTerminator
\ EscapeSequence
LineContinuation

LineContinuation ::

\ LineTerminatorSequence

EscapeSequence ::

CharacterEscapeSequence
0 [lookahead ∉ DecimalDigit]
HexEscapeSequence
UnicodeEscapeSequence

A conforming implementation, when processing strict mode code (see
10.1.1), must not extend the syntax of EscapeSequence to include
OctalEscapeSequence as described in B.1.2.

CharacterEscapeSequence ::

SingleEscapeCharacter
NonEscapeCharacter

SingleEscapeCharacter :: ONE OF

' " \ B F N R T V

NonEscapeCharacter ::

SourceCharacter BUT NOT ONE OF EscapeCharacter OR LineTerminator

EscapeCharacter ::

SingleEscapeCharacter
DecimalDigit
X
U

HexEscapeSequence ::

X HexDigit HexDigit

UnicodeEscapeSequence ::

U HexDigit HexDigit HexDigit HexDigit
U{ HexDigits }

The definition of the nonterminal HexDigit is given in 7.8.3.
SourceCharacter is defined in clause 6.

NOTE A line terminator character cannot appear in a string literal,
except as part of a LineContinuation to produce the empty character
sequence. The correct way to cause a line terminator character to be
part of the String value of a string literal is to use an escape
sequence such as \N or \U000A.

STATIC SEMANTICS

STATIC SEMANTICS: EARLY ERRORS

UnicodeEscapeSequence :: U{ HexDigits }

-   It is a Syntax Error if the MV of HexDigits > 1114111.

STATIC SEMANTICS: SV’S AND CV’S

A string literal stands for a value of the String type. The String value
(SV) of the literal is described in terms of code unit values (CV)
contributed by the various parts of the string literal. As part of this
process, some Unicode characters within the string literal are
interpreted as having a mathematical value (MV), as described below or
in 7.8.3.

-   The SV of StringLiteral :: "" is the empty code unit sequence.

-   The SV of StringLiteral :: '' is the empty code unit sequence.

-   The SV of StringLiteral :: " DoubleStringCharacters " is the SV
    of DoubleStringCharacters.

-   The SV of StringLiteral :: ' SingleStringCharacters ' is the SV
    of SingleStringCharacters.

-   The SV of DoubleStringCharacters :: DoubleStringCharacter is a
    sequence of one or two code units that is the CV of
    DoubleStringCharacter.

-   The SV of DoubleStringCharacters :: DoubleStringCharacter
    DoubleStringCharacters is a sequence of one or two code units that
    is the CV of DoubleStringCharacter followed by all the code units
    in the SV of DoubleStringCharacters in order.

-   The SV of SingleStringCharacters :: SingleStringCharacter is a
    sequence of one or two code units that is the CV of
    SingleStringCharacter.

-   The SV of SingleStringCharacters :: SingleStringCharacter
    SingleStringCharacters is a sequence of one or two code units that
    is the CV of SingleStringCharacter followed by all the code units
    in the SV of SingleStringCharacters in order.

-   The SV of LineContinuation :: \ LineTerminatorSequence is the
    empty code unit sequence.

-   The CV of DoubleStringCharacter :: SourceCharacter BUT NOT ONE
    OF " OR \ OR LineTerminator is the UTF-16 Encoding (clause 6) of
    the code point value of SourceCharacter.

-   The CV of DoubleStringCharacter :: \ EscapeSequence is the CV of
    the EscapeSequence.

-   The CV of DoubleStringCharacter :: LineContinuation is the empty
    character sequence.

-   The CV of SingleStringCharacter :: SourceCharacter BUT NOT ONE
    OF ' OR \ OR LineTerminator is the UTF-16 Encoding (clause 6) of
    the code point value of SourceCharacter .

-   The CV of SingleStringCharacter :: \ EscapeSequence is the CV of
    the EscapeSequence.

-   The CV of SingleStringCharacter :: LineContinuation is the empty
    character sequence.

-   The CV of EscapeSequence :: CharacterEscapeSequence is the CV of
    the CharacterEscapeSequence.

-   The CV of EscapeSequence :: 0 [lookahead ∉ DecimalDigit] is the
    code unit value 0.

-   The CV of EscapeSequence :: HexEscapeSequence is the CV of the
    HexEscapeSequence.

-   The CV of EscapeSequence :: UnicodeEscapeSequence is the CV of
    the UnicodeEscapeSequence.

-   The CV of CharacterEscapeSequence :: SingleEscapeCharacter is
    the character whose code unit value is determined by the
    SingleEscapeCharacter according to Table 4:

Table 4 — String Single Character Escape Sequences

  ------------------- ------------------- ---------------------- ----------
  _ESCAPE SEQUENCE_   _CODE UNIT VALUE_   NAME                 SYMBOL
  \B                  0X0008              backspace              <BS>
  \T                  0X0009              horizontal tab         <HT>
  \N                  0X000A              line feed (new line)   <LF>
  \V                  0X000B              vertical tab           <VT>
  \F                  0X000C              form feed              <FF>
  \R                  0X000D              carriage return        <CR>
  \"                  0X0022              double quote           "
  \'                  0X0027              single quote           '
  \\                  0X005C              backslash              \
  ------------------- ------------------- ---------------------- ----------

-   The CV of CharacterEscapeSequence :: NonEscapeCharacter is the
    CV of the NonEscapeCharacter.

-   The CV of NonEscapeCharacter :: SourceCharacter BUT NOT ONE OF
    EscapeCharacter OR LineTerminator is the UTF-16 Encoding (clause
    6) of the code point value of SourceCharacter .

-   The CV of HexEscapeSequence :: X HexDigit HexDigit is the code
    unit value that is (16 times the MV of the first HexDigit) plus
    the MV of the second HexDigit.

-   The CV of UnicodeEscapeSequence :: U HexDigit HexDigit
    HexDigit HexDigit is the code unit value that is (4096 times the
    MV of the first HexDigit) plus (256 times the MV of the second
    HexDigit) plus (16 times the MV of the third HexDigit) plus the
    MV of the fourth HexDigit.

-   The CV of UnicodeEscapeSequence :: U{ HexDigits }is the is the
    UTF-16 Encoding (clause 6) of the MV of HexDigits.

-   

NOTE A regular expression literal is an input element that is converted
to a RegExp object (see 15.10) each time the literal is evaluated. Two
regular expression literals in a program evaluate to regular expression
objects that never compare as === to each other even if the two
literals' contents are identical. A RegExp object may also be created at
runtime by NEW REGEXP (see 15.10.4) or calling the REGEXP constructor as
a function (15.10.3).

The productions below describe the syntax for a regular expression
literal and are used by the input element scanner to find the end of the
regular expression literal. The source code comprising the
RegularExpressionBody and the RegularExpressionFlags are
subsequently parsed using the more stringent ECMAScript Regular
Expression grammar (15.10.1).

An implementation may extend the ECMAScript Regular Expression grammar
defined in 15.10.1, but it must not extend the RegularExpressionBody
and RegularExpressionFlags productions defined below or the
productions used by these productions.

Syntax

RegularExpressionLiteral ::

/ RegularExpressionBody / RegularExpressionFlags

RegularExpressionBody ::

RegularExpressionFirstChar RegularExpressionChars

RegularExpressionChars ::

[empty]
RegularExpressionChars RegularExpressionChar

RegularExpressionFirstChar ::

RegularExpressionNonTerminator BUT NOT ONE OF * OR \ OR / OR [
RegularExpressionBackslashSequence
RegularExpressionClass

RegularExpressionChar ::

RegularExpressionNonTerminator BUT NOT ONE OF \ OR / OR [
RegularExpressionBackslashSequence
RegularExpressionClass

RegularExpressionBackslashSequence ::

\ RegularExpressionNonTerminator

RegularExpressionNonTerminator ::

SourceCharacter BUT NOT LineTerminator

RegularExpressionClass ::

[ RegularExpressionClassChars ]

RegularExpressionClassChars ::

[empty]
RegularExpressionClassChars RegularExpressionClassChar

RegularExpressionClassChar ::

RegularExpressionNonTerminator BUT NOT ONE OF ] OR \
RegularExpressionBackslashSequence

RegularExpressionFlags ::

[empty]
RegularExpressionFlags IdentifierPart

NOTE Regular expression literals may not be empty; instead of
representing an empty regular expression literal, the characters //
start a single-line comment. To specify an empty regular expression,
use: /(?:)/.

STATIC SEMANTICS: BODYTEXT

RegularExpressionLiteral :: / RegularExpressionBody /
RegularExpressionFlags

1.  Return the source code that was recognized as
    RegularExpressionBody.

STATIC SEMANTICS: FLAGTEXT

RegularExpressionLiteral :: / RegularExpressionBody /
RegularExpressionFlags

1.  Return the source code that was recognized as
    RegularExpressionFlags.

Syntax

Template ::

NoSubstitutionTemplate
TemplateHead

NoSubstitutionTemplate ::

` TemplateCharacters~opt~ `

TemplateHead ::

` TemplateCharacters~opt~ ${

TemplateSubstitutionTail ::

TemplateMiddle
TemplateTail

TemplateMiddle ::

} TemplateCharacters~opt~ ${

TemplateTail ::

} TemplateCharacters~opt~ `

TemplateCharacters ::

TemplateCharacter TemplateCharacters~opt~

TemplateCharacter ::

SourceCharacter BUT NOT ONE OF ` OR \ OR $
$ [lookahead ∉ { ]
\ EscapeSequence
LineContinuation

STATIC SEMANTICS: TV’S AND TRV’S

A template literal component is interpreted as a sequence of Unicode
characters. The Template Value (TV) of a literal component is described
in terms of code unit values (CV, 7.8.4) contributed by the various
parts of the template literal component. As part of this process, some
Unicode characters within the template component are interpreted as
having a mathematical value (MV, 7.8.3). In determining a TV, escape
sequences are replaced by the code unit of the Unicode characters
represented by the escape sequence. The Template Raw Value (TRV) is
similar to a Template Value with the difference that in TRVs escape
sequences are interpreted literally.

-   The TV and TRV of NoSubstitutionTemplate :: `` is the empty code
    unit sequence.

-   The TV and TRV of TemplateHead :: `${ is the empty code unit
    sequence.

-   The TV and TRV of TemplateMiddle :: }${ is the empty code unit
    sequence.

-   The TV and TRV of TemplateTail :: }` is the empty code unit
    sequence.

-   The TV of NoSubstitutionTemplate :: ` TemplateCharacters ` is
    the TV of TemplateCharacters.

-   The TV of TemplateHead :: ` TemplateCharacters ${ is the TV of
    TemplateCharacters.

-   The TV of TemplateMiddle :: } TemplateCharacters ${ is the TV of
    TemplateCharacters.

-   The TV of TemplateTail :: } TemplateCharacters ` is the TV of
    TemplateCharacters.

-   The TV of TemplateCharacters:: TemplateCharacter is the TV of
    TemplateCharacter.

-   The TV of TemplateCharacters :: TemplateCharacter
    TemplateCharacters is a sequence consisting of the code units in
    the TV of TemplateCharacter followed by all the code units in the
    TV of TemplateCharacters in order.

-   The TV of TemplateCharacter :: SourceCharacter BUT NOT ONE OF `
    OR \ OR $ is the UTF-16 Encoding (clause 6) of the code point value
    of SourceCharacter.

-   The TV of TemplateCharacter :: $ [lookahead ∉ { ] is the code unit
    value 0x0024.

-   The TV of TemplateCharacter :: \ EscapeSequence is the CV of
    EscapeSequence.

-   The TV of TemplateCharacter :: LineContinuation is the TV of
    LineContinuation.

-   The TV of LineContinuation :: \ LineTerminatorSequence is the
    empty code unit sequence.

-   The TRV of NoSubstitutionTemplate :: ` TemplateCharacters ` is
    the TRV of TemplateCharacters.

-   The TRV of TemplateHead :: ` TemplateCharacters ${ is the TRV of
    TemplateCharacters.

-   The TRV of TemplateMiddle :: } TemplateCharacters ${ is the TRV
    of TemplateCharacters.

-   The TRV of TemplateTail :: } TemplateCharacters ` is the TRV of
    TemplateCharacters.

-   The TRV of TemplateCharacters:: TemplateCharacter is the TRV of
    TemplateCharacter.

-   The TRV of TemplateCharacters:: TemplateCharacter
    TemplateCharacters is a sequence consisting of the code units in
    the TRV of TemplateCharacter followed by all the code units in the
    TRV of TemplateCharacters, in order.

-   The TRV of TemplateCharacter :: SourceCharacter BUT NOT ONE OF `
    OR \ OR $ is the UTF-16 Encoding (clause 6) of the code point value
    of SourceCharacter.

-   The TRV of TemplateCharacter :: $ [lookahead ∉ { ] is the code
    unit value 0x0024.

-   The TRV of TemplateCharacter :: \ EscapeSequence is the sequence
    consisting of the code unit value 0x005C followed by the code units
    of TRV of EscapeSequence.

-   The TRV of TemplateCharacter:: LineContinuation is the TRV of
    LineContinuation.

-   The TRV of EscapeSequence :: CharacterEscapeSequence is the TRV
    of the CharacterEscapeSequence.

-   The TRV of EscapeSequence :: 0 [lookahead ∉ DecimalDigit] is the
    code unit value 0x0030.

-   The TRV of EscapeSequence :: HexEscapeSequence is the TRV of the
    HexEscapeSequence.

-   The TRV of EscapeSequence :: UnicodeEscapeSequence is the TRV of
    the UnicodeEscapeSequence.

-   The TRV of CharacterEscapeSequence :: SingleEscapeCharacter is
    the TRV of the SingleEscapeCharacter.

-   The TRV of CharacterEscapeSequence :: NonEscapeCharacter is the
    CV of the NonEscapeCharacter.

-   The TRV of SingleEscapeCharacter :: ONE OF ' " \ B F N R T V is
    the CV of the SourceCharacter that is that single character.

-   The TRV of HexEscapeSequence :: X _HexDigit HexDigit_ is the
    sequence consisting of code unit value 0x0078 followed by TRV of the
    first HexDigit followed by the TRV of the second HexDigit.

-   The TRV of UnicodeEscapeSequence :: U HexDigit HexDigit
    HexDigit HexDigit is the sequence consisting of code unit value
    0x0075 followed by TRV of the first HexDigit followed by the TRV
    of the second HexDigit followed by TRV of the third HexDigit
    followed by the TRV of the fourth HexDigit.

-   The TRV of UnicodeEscapeSequence :: U{ HexDigits }is the
    sequence consisting of code unit value 0x0075 followed by code unit
    value 0x007B followed by TRV of HexDigit followed by code unit
    value 0x007D.

-   The TRV of HexDigits :: HexDigit is the TRV of HexDigit.

-   The TRV of HexDigits :: HexDigits HexDigit is the sequence
    consisting of TRV of HexDigits followed by TRV of HexDigit.

-   The TRV of a HexDigit is the CV of the SourceCharacter that is
    that HexDigit.

-   The TRV of LineContinuation :: \ LineTerminatorSequence is the
    sequence consisting of the code unit value 0x005C followed by the
    code units of TRV of LineTerminatorSequence.

-   The TRV of LineTerminatorSequence :: <LF> is the code unit value
    0x000A.

-   The TRV of LineTerminatorSequence :: <CR> [lookahead ∉ <LF> ] is
    the code unit value 0x000D.

-   The TRV of LineTerminatorSequence :: <LS> is the code unit value
    0x2028.

-   The TRV of LineTerminatorSequence :: <PS> is the code unit value
    0x2029.

-   The TRV of LineTerminatorSequence :: <CR><LF> is the sequence
    consisting of the code unit value 0x000D followed by the code unit
    value 0x000A.

NOTE TV excludes the code units of LineContinuation while TRV includes
them.

Certain ECMAScript statements (empty statement, variable statement,
expression statement, DO-WHILE statement, CONTINUE statement, BREAK
statement, RETURN statement, and THROW statement) must be terminated
with semicolons. Such semicolons may always appear explicitly in the
source text. For convenience, however, such semicolons may be omitted
from the source text in certain situations. These situations are
described by saying that semicolons are automatically inserted into the
source code token stream in those situations.

There are three basic rules of semicolon insertion:

1.  When, as the script is parsed from left to right, a token (called
    the _offending token_) is encountered that is not allowed by any
    production of the grammar, then a semicolon is automatically
    inserted before the offending token if one or more of the following
    conditions is true:

-   The offending token is separated from the previous token by at least
    one LineTerminator.

-   The offending token is }.

    1.  When, as the script is parsed from left to right, the end of the
        input stream of tokens is encountered and the parser is unable
        to parse the input token stream as a single complete ECMAScript
        script, then a semicolon is automatically inserted at the end
        of the input stream.

    2.  When, as the script is parsed from left to right, a token is
        encountered that is allowed by some production of the grammar,
        but the production is a _restricted production_ and the token
        would be the first token for a terminal or nonterminal
        immediately following the annotation “[no LineTerminator
        here]” within the restricted production (and therefore such a
        token is called a restricted token), and the restricted token is
        separated from the previous token by at least one
        LineTerminator, then a semicolon is automatically inserted
        before the restricted token.

However, there is an additional overriding condition on the preceding
rules: a semicolon is never inserted automatically if the semicolon
would then be parsed as an empty statement or if that semicolon would
become one of the two semicolons in the header of a FOR statement (see
12.6.3).

NOTE The following are the only restricted productions in the grammar:

PostfixExpression :

LeftHandSideExpression [no LineTerminator here] ++
LeftHandSideExpression [no LineTerminator here] --

ContinueStatement :

CONTINUE [no LineTerminator here] Identifier ;

BreakStatement :

BREAK [no LineTerminator here] Identifier ;

ReturnStatement :

RETURN [no LineTerminator here] Expression ;

ThrowStatement :

THROW [no LineTerminator here] Expression ;

The practical effect of these restricted productions is as follows:

  When a ++ or -- token is encountered where the parser would treat it
  as a postfix operator, and at least one LineTerminator occurred
  between the preceding token and the ++ or -- token, then a semicolon
  is automatically inserted before the ++ or -- token.

  When a CONTINUE, BREAK, RETURN, or THROW token is encountered and a
  LineTerminator is encountered before the next token, a semicolon is
  automatically inserted after the CONTINUE, BREAK, RETURN, or THROW
  token.

  The resulting practical advice to ECMAScript programmers is:

  A postfix ++ or -- operator should appear on the same line as its
  operand.

  An Expression in a RETURN or THROW statement should start on the
  same line as the RETURN or THROW token.

  An Identifier in a BREAK or CONTINUE statement should be on the same
  line as the BREAK or CONTINUE token.

The source

  { 1 2 } 3

is not a valid sentence in the ECMAScript grammar, even with the
automatic semicolon insertion rules. In contrast, the source

  { 1
  2 } 3

is also not a valid ECMAScript sentence, but is transformed by automatic
semicolon insertion into the following:

  { 1
  ;2 ;} 3;

which is a valid ECMAScript sentence.

The source

  for (a; b
  )

is not a valid ECMAScript sentence and is not altered by automatic
semicolon insertion because the semicolon is needed for the header of a
FOR statement. Automatic semicolon insertion never inserts one of the
two semicolons in the header of a FOR statement.

The source

  return
  a + b

is transformed by automatic semicolon insertion into the following:

  return;
  a + b;

NOTE The expression A + B is not treated as a value to be returned by
the RETURN statement, because a LineTerminator separates it from the
token RETURN.

The source

  a = b
  ++c

is transformed by automatic semicolon insertion into the following:

  a = b;
  ++c;

NOTE The token ++ is not treated as a postfix operator applying to the
variable B, because a LineTerminator occurs between B and ++.

The source

  if (a > b)
  else c = d

is not a valid ECMAScript sentence and is not altered by automatic
semicolon insertion before the ELSE token, even though no production of
the grammar applies at that point, because an automatically inserted
semicolon would then be parsed as an empty statement.

The source

  a = b + c
  (d + e).print()

is not transformed by automatic semicolon insertion, because the
parenthesised expression that begins the second line can be interpreted
as an argument list for a function call:

a = b + c(d + e).print()

In the circumstance that an assignment statement must begin with a left
parenthesis, it is a good idea for the programmer to provide an explicit
semicolon at the end of the preceding statement rather than to rely on
automatic semicolon insertion.

Algorithms within this specification manipulate values each of which has
an associated type. The possible value types are exactly those defined
in this clause. Types are further subclassified into ECMAScript language
types and specification types.

An ECMAScript language type corresponds to values that are directly
manipulated by an ECMAScript programmer using the ECMAScript language.
The ECMAScript language types are Undefined, Null, Boolean, String,
Number, and Object.

A specification type corresponds to meta-values that are used within
algorithms to describe the semantics of ECMAScript language constructs
and ECMAScript language types. The specification types are Reference,
List, Completion, Property Descriptor, Property Identifier, Lexical
Environment, Environment Record, and Data Block. Specification type
values are specification artefacts that do not necessarily correspond to
any specific entity within an ECMAScript implementation. Specification
type values may be used to describe intermediate results of ECMAScript
expression evaluation but such values cannot be stored as properties of
objects or values of ECMAScript language variables.

Within this specification, the notation “Type(x)” is used as shorthand
for “the type of x” where “type” refers to the ECMAScript language and
specification types defined in this clause.

The Undefined type has exactly one value, called UNDEFINED. Any variable
that has not been assigned a value has the value UNDEFINED.

The Null type has exactly one value, called NULL.

The Boolean type represents a logical entity having two values, called
TRUE and FALSE.

The String type is the set of all finite ordered sequences of zero or
more 16-bit unsigned integer values (“elements”). The String type is
generally used to represent textual data in a running ECMAScript
program, in which case each element in the String is treated as a UTF-16
code unit value. Each element is regarded as occupying a position within
the sequence. These positions are indexed with nonnegative integers. The
first element (if any) is at index 0, the next element (if any) at index
1, and so on. The length of a String is the number of elements (i.e.,
16-bit values) within it. The empty String has length zero and therefore
contains no elements.

Where ECMAScript operations interpret String values, each element is
interpreted as a single UTF-16 code unit. However, ECMAScript does not
place any restrictions or requirements on the sequence of code units in
a String value, so they may be ill-formed when interpreted as UTF-16
code unit sequences. Operations that do not interpret String contents
treat them as sequences of undifferentiated 16-bit unsigned integers. No
operations ensure that Strings are in a normalized form. Only operations
that are explicitly specified to be language or locale sensitive produce
language-sensitive results

-   

NOTE The rationale behind this design was to keep the implementation of
Strings as simple and high-performing as possible. If ECMAScript source
code is in Normalised Form C, string literals are guaranteed to also be
normalised, as long as they do not contain any Unicode escape sequences.

Some operations interpret String contents as UTF-16 encoded Unicode code
points. In that case the interpretation is:

-   A code unit in the range 0 to 0xD7FF or in the range 0xE000 to
    0xFFFF is interpreted as a code point with the same value.

-   A sequence of two code units, where the first code unit c1 is in
    the range 0xD800 to 0xDBFF and the second code unit c2 is in the
    range 0xDC00 to 0xDFFF, is a surrogate pair and is interpreted as a
    code point with the value (c1 - 0xD800) × 0x400 + (c2 –
    0xDC00) + 0x10000.

-   A code unit that is in the range 0xD800 to 0xDFFF, but is not part
    of a surrogate pair, is interpreted as a code point with the same
    value.

The Number type has exactly 18437736874454810627 (that is,
2^64^−2^53^+3) values, representing the double-precision 64-bit format
IEEE 754 values as specified in the IEEE Standard for Binary
Floating-Point Arithmetic, except that the 9007199254740990 (that is,
2^53^−2) distinct “Not-a-Number” values of the IEEE Standard are
represented in ECMAScript as a single special NAN value. (Note that the
NAN value is produced by the program expression NAN.) In some
implementations, external code might be able to detect a difference
between various Not-a-Number values, but such behaviour is
implementation-dependent; to ECMAScript code, all NaN values are
indistinguishable from each other.

There are two other special values, called POSITIVE INFINITY and
NEGATIVE INFINITY. For brevity, these values are also referred to for
expository purposes by the symbols +∞ and −∞, respectively. (Note that
these two infinite Number values are produced by the program expressions
+INFINITY (or simply INFINITY) and -INFINITY.)

The other 18437736874454810624 (that is, 2^64^−2^53^) values are called
the finite numbers. Half of these are positive numbers and half are
negative numbers; for every finite positive Number value there is a
corresponding negative value having the same magnitude.

Note that there is both a POSITIVE ZERO and a NEGATIVE ZERO. For
brevity, these values are also referred to for expository purposes by
the symbols +0 and −0, respectively. (Note that these two different zero
Number values are produced by the program expressions +0 (or simply 0)
and -0.)

The 18437736874454810622 (that is, 2^64^−2^53^−2) finite nonzero values
are of two kinds:

18428729675200069632 (that is, 2^64^−2^54^) of them are normalised,
having the form

  s × m × 2^e^

where s is +1 or −1, m is a positive integer less than 2^53^ but not
less than 2^52^, and e is an integer ranging from −1074 to 971,
inclusive.

The remaining 9007199254740990 (that is, 2^53^−2) values are
denormalised, having the form

  s × m × 2^e^

where s is +1 or −1, m is a positive integer less than 2^52^, and
e is −1074.

Note that all the positive and negative integers whose magnitude is no
greater than 2^53^ are representable in the Number type (indeed, the
integer 0 has two representations, +0 and -0).

A finite number has an _odd significand_ if it is nonzero and the
integer m used to express it (in one of the two forms shown above) is
odd. Otherwise, it has an _even significand_.

In this specification, the phrase “the Number value for x” where x
represents an exact nonzero real mathematical quantity (which might even
be an irrational number such as π) means a Number value chosen in the
following manner. Consider the set of all finite values of the Number
type, with −0 removed and with two additional values added to it that
are not representable in the Number type, namely 2^1024^ (which is +1 ×
2^53^ × 2^971^) and −2^1024^ (which is −1 × 2^53^ × 2^971^). Choose the
member of this set that is closest in value to x. If two values of the
set are equally close, then the one with an even significand is chosen;
for this purpose, the two extra values 2^1024^ and −2^1024^ are
considered to have even significands. Finally, if 2^1024^ was chosen,
replace it with +∞; if −2^1024^ was chosen, replace it with −∞; if +0
was chosen, replace it with −0 if and only if x is less than zero; any
other chosen value is used unchanged. The result is the Number value for
x. (This procedure corresponds exactly to the behaviour of the IEEE
754 “round to nearest” mode.)

Some ECMAScript operators deal only with integers in the range −2^31^
through 2^31^−1, inclusive, or in the range 0 through 2^32^−1,
inclusive. These operators accept any value of the Number type but first
convert each such value to one of 2^32^ integer values. See the
descriptions of the ToInt32 and ToUint32 operators in 9.5 and 9.6,
respectively.

An Object is a collection of properties. Each property is either a named
data property, a named accessor property, or an internal property:

-   A _named data property_ associates a name with an ECMAScript
    language value and a set of Boolean attributes.

-   A _named accessor property_ associates a name with one or two
    accessor functions, and a set of Boolean attributes. The accessor
    functions are used to store or retrieve an ECMAScript language value
    that is associated with the property.

-   An _internal property_ has no name and is not directly accessible
    via ECMAScript language operators. Internal properties exist purely
    for specification purposes.

There are two kinds of access for named (non-internal) properties: get
and put, corresponding to retrieval and assignment, respectively.

Attributes are used in this specification to define and explain the
state of named properties. A named data property associates a name with
the attributes listed in Table 5.

Table 5 — Attributes of a Named Data Property

  _ATTRIBUTE NAME_   _VALUE DOMAIN_                 DESCRIPTION
  ------------------ ------------------------------ -------------------------------------------------------------------------------------------------------------------------------------------------------
  [[Value]]          Any ECMAScript language type   The value retrieved by reading the property.
  [[Writable]]       Boolean                        If FALSE, attempts by ECMAScript code to change the property’s [[Value]] attribute using [[Put]] will not succeed.
  [[Enumerable]]     Boolean                        If TRUE, the property will be enumerated by a for-in enumeration (see 12.6.4). Otherwise, the property is said to be non-enumerable.
  [[Configurable]]   Boolean                        If FALSE, attempts to delete the property, change the property to be an accessor property, or change its attributes (other than [[Value]]) will fail.

A named accessor property associates a name with the attributes listed
in Table 6.

Table 6 — Attributes of a Named Accessor Property

  _ATTRIBUTE NAME_   _VALUE DOMAIN_          DESCRIPTION
  ------------------ ----------------------- --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  [[Get]]            Object or Undefined   If the value is an Object it must be a function Object. The function’s [[Call]] internal method (8.6.2) is called with an empty arguments list to return the property value each time a get access of the property is performed.
  [[Set]]            Object or Undefined   If the value is an Object it must be a function Object. The function’s [[Call]] internal method (8.6.2) is called with an arguments list containing the assigned value as its sole argument each time a set access of the property is performed. The effect of a property's [[Set]] internal method may, but is not required to, have an effect on the value returned by subsequent calls to the property's [[Get]] internal method.
  [[Enumerable]]     Boolean                 If TRUE, the property is to be enumerated by a for-in enumeration (see 12.6.4). Otherwise, the property is said to be non-enumerable.
  [[Configurable]]   Boolean                 If FALSE, attempts to delete the property, change the property to be a data property, or change its attributes will fail.

If the value of an attribute is not explicitly specified by this
specification for a named property, the default value defined in Table 7
is used.

Table 7 — Default Attribute Values

  ATTRIBUTE NAME     DEFAULT VALUE
  ------------------ ---------------
  [[Value]]          UNDEFINED
  [[Get]]            UNDEFINED
  [[Set]]            UNDEFINED
  [[Writable]]       FALSE
  [[Enumerable]]     FALSE
  [[Configurable]]   FALSE

This specification uses various internal properties to define the
semantics of object values. These internal properties are not part of
the ECMAScript language. They are defined by this specification purely
for expository purposes. An implementation of ECMAScript must behave as
if it produced and operated upon internal properties in the manner
described here. The names of internal properties are enclosed in double
square brackets [[ ]]. When an algorithm uses an internal property of an
object and the object does not implement the indicated internal
property, a TYPEERROR exception is thrown.

Table 8 summarises the internal properties used by this specification
that are applicable to all ECMAScript objects. Table 9 summarises the
internal properties used by this specification that are only applicable
to some ECMAScript objects.

Clause 8.12 provides the algorithms that defined the default behaviour
for the internal methods in Table 8. An _ordinary object_ is an object
that uses all of these default algorithms. An _exotic object_ is an
object that uses some other algorithm to provide alternative behaviour
for one or more of these internal methods.

The “Value Type Domain” columns of the following tables define the types
of values associated with internal properties. The type names refer to
the types defined in Clause 8 augmented by the following additional
names. “any” means the value may be any ECMAScript language type.
“primitive” means Undefined, Null, Boolean, String, or Number.
“SpecOp” means the internal property is an internal method, an
implementation provided procedure defined by an abstract operation
specification. “SpecOp” is followed by a list of descriptive parameter
names. If a parameter name is the same as a type name then the name
describes the type of the parameter. If a “SpecOp” returns a value, its
parameter list is followed by the symbol “→” and the type of the
returned value. A “SpecOp implicitly returns a Completion Record as
described in 8.8. In addition to its parameters, a “SpecOp” also has
access to the object upon which it is invoked as a method.

Table 8 — Internal Properties Common to All Objects

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  _INTERNAL PROPERTY_     _VALUE TYPE DOMAIN_                                                DESCRIPTION
  ----------------------- ------------------------------------------------------------------ -----------------------------------------------------------------------------------------------------------------------------------------------------------
  [[Prototype]]           Object or Null                                                   The prototype of this object.

                                                                                             

  [[Extensible]]          Boolean                                                            If TRUE, own properties may be added to the object.

  [[Get]]                 SpecOp(propertyName) → any                                     Returns the value of the named property.

  [[GetOwnProperty]]      SpecOp (propertyName) →                                        Returns the Property Descriptor of the named own property of this object, or UNDEFINED if absent.
                                                                                             
                          Undefined or Property Descriptor                                 

  [[GetProperty]]         SpecOp (propertyName) →                                        Returns the fully populated Property Descriptor of the named property of this object, or UNDEFINED if absent.
                                                                                             
                          Undefined or Property Descriptor                                 

  [[Put]]                 SpecOp (propertyName, _any, Boolean_)                            Sets the specified named property to the value of the second parameter. The flag controls failure handling.

  [[CanPut]]              SpecOp (propertyName) → Boolean                                Returns a Boolean value indicating whether a [[Put]] operation with PropertyName can be performed.

  [[HasProperty]]         SpecOp (propertyName) → Boolean                              Returns a Boolean value indicating whether the object already has a property with the given name.

  [[Delete]]              SpecOp (_propertyName, Boolean_) → Boolean                       Removes the specified named own property from the object. The flag controls failure handling.

  [[DefaultValue]]        SpecOp (Hint) → primitive                                    Hint is a String. Returns a default value for the object.

  [[DefineOwnProperty]]   SpecOp (_propertyName, PropertyDescriptor, Boolean_) → Boolean   Creates or alters the named own property to have the state described by a Property Descriptor. The flag controls failure handling.

  [[Enumerate]]           SpecOp()→Object                                                  Returns an object that can enumerate the string values of the keys of the enumerable properties of the object. The returned object is an Iterator object.

  [[Iterate]]             SpecOp()→Object                                                  Returns an object that can enumerate the logical component values of the object. The returned object is an Iterator object.
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Every object must implement all of the internal properties listed in
Table 8. However, the [[DefaultValue]] internal method may, for some
objects, simply throw a TYPEERROR exception.

All objects have an internal property called [[Prototype]]. The value of
this property is either NULL or an object and is used for implementing
inheritance. Whether or not an ordinary object can have an exotic object
as its [[Prototype]] depends on the implementation. Every [[Prototype]]
chain must have finite length (that is, starting from any object,
recursively accessing the [[Prototype]] internal property must
eventually lead to a NULL value). Named data properties of the
[[Prototype]] object are inherited (are visible as properties of the
child object) for the purposes of get access, but not for put access.
Named accessor properties are inherited for both get access and put
access.

Every ECMAScript object has a Boolean-valued [[Extensible]] internal
property that controls whether or not named properties may be added to
the object. If the value of the [[Extensible]] internal property is
FALSE then additional named properties may not be added to the object.
In addition, if [[Extensible]] is FALSE the value of [[Prototype]]
internal properties of the object may not be modified. Once the value of
an [[Extensible]] internal property has been set to FALSE it may not be
subsequently changed to TRUE.

NOTE This specification defines no ECMAScript language operators or
built-in functions that permit a program to modify an object’s
[[Prototype]] internal properties or to change the value of
[[Extensible]] from FALSE to TRUE. Implementation specific extensions
that modify [[Prototype]] or [[Extensible]] must not violate the
invariants defined in the preceding paragraph.

Unless otherwise specified, the common internal methods of native
ECMAScript objects behave as described in 8.12. Array objects have a
slightly different implementation of the [[DefineOwnProperty]] internal
method (see 15.4.5.1) and String objects have a slightly different
implementation of the [[GetOwnProperty]] internal method (see 15.5.5.2).
Arguments objects (10.6) have different implementations of [[Get]],
[[GetOwnProperty]], [[DefineOwnProperty]], and [[Delete]]. Function
objects (15.3) have a different implementation of [[Get]].

Exotic objects may implement these internal methods in any manner unless
specified otherwise; for example, one possibility is that [[Get]] and
[[Put]] for a particular exotic object indeed fetch and store property
values but [[HasProperty]] always generates FALSE. However, if any
specified manipulation of an exotic object's internal properties is not
supported by an implementation, that manipulation must throw a TYPEERROR
exception when attempted.

The [[GetOwnProperty]] internal method of all objects must conform to
the following invariants for each property of the object:

-   If a property is described as a data property and it may return
    different values over time, then either or both of the [[Writable]]
    and [[Configurable]] attributes must be TRUE even if no mechanism to
    change the value is exposed via the other internal methods.

-   If a property is described as a data property and its [[Writable]]
    and [[Configurable]] are both FALSE, then the SameValue (according
    to 9.12) must be returned for the [[Value]] attribute of the
    property on all calls to [[GetOwnProperty]].

-   If the attributes other than [[Writable]] may change over time or if
    the property might disappear, then the [[Configurable]] attribute
    must be TRUE.

-   If the [[Writable]] attribute may change from FALSE to TRUE, then
    the [[Configurable]] attribute must be TRUE.

-   If the value of the object’s [[Extensible]] internal property has
    been observed by ECMAScript code to be FALSE, then if a call to
    [[GetOwnProperty]] describes a property as non-existent all
    subsequent calls must also describe that property as non-existent.

The [[DefineOwnProperty]] internal method of all objects must not permit
the addition of a new property to an object if the [[Extensible]]
internal property of that object has been observed by ECMAScript code to
be FALSE.

If the [[Extensible]] internal property of an object has been observed
by ECMAScript code to be FALSE then it must not subsequently become
TRUE.

Table 9 — Internal Properties Only Defined for Some Objects

  _INTERNAL PROPERTY_    _VALUE TYPE DOMAIN_                                     DESCRIPTION
  ---------------------- ------------------------------------------------------- ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  [[NativeBrand]]        Members of the NativeBrand enumeration.                 A tag value used by this specification to categorize various kinds of native ECMAScript objects defined in this specification.
  [[PrimitiveValue]]     primitive                                             Internal state information associated with this object. Of the standard built-in ECMAScript objects, only Boolean, Date, Number, and String objects implement [[PrimitiveValue]].
  [[Construct]]          SpecOp(a List of any) → Object                      Creates an object. Invoked via the NEW operator. The arguments to the SpecOp are the arguments passed to the NEW operator. Objects that implement this internal method are called constructors.
  [[Call]]               SpecOp(any, a List of any) → any or Reference   Executes code associated with the object. Invoked via a function call expression. The arguments to the SpecOp are this object and a list containing the arguments passed to the function call expression. Objects that implement this internal method are callable. Only callable objects that are host objects may return Reference values.
  [[HasInstance]]        SpecOp(any) → Boolean                               Returns a Boolean value indicating whether the argument is likely an Object that was constructed by this object. Of the standard built-in ECMAScript objects, only Function objects implement [[HasInstance]].
  [[Scope]]              Lexical Environment                                     A lexical environment that is the environment in which a Function object is executed. Of the standard built-in ECMAScript objects, only Function objects implement [[Scope]].
  [[FormalParameters]]   Parse Tree                                              A parse tree for ECMAScript code parsed with FormalParameterList as the goal symbol. Of the standard built-in ECMAScript objects, only Function objects implement [[FormalParameters]].
  [[Code]]               Parse Tree                                              A parse tree for ECMAScript code parsed with FunctionBody as the goal symbol. Of the standard built-in ECMAScript objects, only Function objects implement [[Code]].
  [[Strict]]             Boolean                                                 True if a Function object is a strict mode function. Of the standard built-in ECMAScript objects, only Function objects implement [[Strict]].
  [[TargetFunction]]     Object                                                  The target function of a function object created using the standard built-in Function.prototype.bind method. Only ECMAScript objects created using Function.prototype.bind have a [[TargetFunction]] internal property.
  [[BoundThis]]          any                                                   The pre-bound this value of a function Object created using the standard built-in Function.prototype.bind method. Only ECMAScript objects created using Function.prototype.bind have a [[BoundThis]] internal property.
  [[BoundArguments]]     List of any                                           The pre-bound argument values of a function Object created by the standard built-in Function.prototype.bind method. Only objects created by Function.prototype.bind have a [[BoundArguments]] internal property.
  [[Match]]              SpecOp(String, index) → MatchResult             Tests for a regular expression match and returns a MatchResult value (see 15.10.2.1). Of the standard built-in ECMAScript objects, only RegExp objects implement [[Match]].
  [[ParameterMap]]       Object                                                  Provides a mapping between the properties of an arguments object (see 10.6) and the formal parameters of the associated function. Only objects that are arguments objects have a [[ParameterMap]] internal property.

The [[NativeBrand]] internal property is used to identify native
ECMASCript objects as objects that conform to specific parts of this
specification. The value of a [[NativeBrand]] property is a single
member of this set of enumerated values: NativeFunction, NativeArray,
StringWrapper, BooleanWrapper, NumberWrapper, NativeMath, NativeDate,
NativeRegExp, NativeError, NativeJSON, NativeArguments,
NativePrivateName. The actual value of the [[NativeBrand]] internal
property is only used to identify specific kinds of native ECMAScript
objects. Only the objects explicitly identified in Table 10 may have a
[[NativeBrand]] internal property.

Table 10 — Values of the [[NativeBrand]] Internal Property

  VALUE             CATEGORY             DESCRIPTION
  ------------------- ---------------------- ---------------
  NativeFunction      Function objects       
  NativeArray         Array objects          
  StringWrapper       String objects         
  BooleanWrapper      Boolean objects        
  NumberWrapper       Number objects         
  NativeMath          The Math object        
  NativeDate          Date objects           
  NativeRegExp        RegExp objects         
  NativeError         Error objects          
  NativeJSON          The JSON object        
  NativeArguments     Arguments objects      
  NativePrivateName   Private Name objects   
                                             

The List type is used to explain the evaluation of argument lists (see
11.2.4) in NEW expressions, in function calls, and in other algorithms
where a simple list of values is needed. Values of the List type are
simply ordered sequences of values. These sequences may be of any
length.

The Record type is used to describe data aggregations within the
algorithms of this specification. A Record type value consists of one or
more named fields. The value of each field is either an ECMAScript value
or an abstract value represented by a name associated with the Record
type. Field names are always enclosed in double brackets, for example
[[value]]

For notational convenience within this specification, an object
literal-like syntax can be used to express a Record value. For example,
{[[field1]]: 42, [[field2]]: FALSE, [[field3]]: EMPTY} defines a Record
value that has three fields each of which is initialized to a specific
value. Field name order is not significant. Any fields that are not
explicitly listed are considered to be absent.

In specification text and algorithms, dot notation may be used to refer
to a specific field of a Record value. For example, if R is the record
shown in the previous paragraph then R.[[field2]] is shorthand for “the
field of R named [[field2]]”.

Schema for commonly used Record field combinations may be named, and
that name may be used as a prefix to a literal Record value to identify
the specific kind of aggregations that is being described. For example:
Property Descriptor {[[Value]]: 42, [[Writable]]: FALSE,
[[Configurable]]: TRUE}.

The Completion type is a Record used to explain the runtime propagation
of values and control flow such as the behaviour of statements (BREAK,
CONTINUE, RETURN and THROW) that perform nonlocal transfers of control.

Values of the Completion type are Record values whole fields are defined
as by Table 11.

Table 11 — Completion Record Fields

  -------------- -------------------------------------------------- --------------------------------------------------
  _FIELD NAME_   VALUE                                            MEANING
  [[type]]       One of NORMAL, BREAK, CONTINUE, RETURN, or THROW   The type of completion that occurred.
  [[value]]      any ECMAScript language value or EMPTY             The value that was produced.
  [[target]]     any ECMAScript identifier or EMPTY                 The target label for directed control transfers.
  -------------- -------------------------------------------------- --------------------------------------------------

The term “abrupt completion” refers to any completion with a [[type]]
value other than NORMAL.

The algorithms of this specification often implicitly return Completion
Records whose [[type]] is NORMAL. Unless it is otherwise obvious from
the context, an algorithm statement that returns a value that is not a
Completion Record, such as:

mean the same things as:

1.  Return Completion {[[type]]: normal, [[value]]: String "INFINITY",
    [[target]]:empty}.

Similarly, any reference to a Completion Record value that is in a
context that does not explicitly require a complete Completion Record
value is equivalent to an explicit reference to the [[value]] field of
the Completion Record value unless the Completion Record is an abrupt
completion.

The abstract operation NormalCompletion with a single argument, such
as:

1.  Return NormalCompletion(argument).

Is a short hand that is defined as follows:

1.  Return Completion {[[type]]: normal, [[value]]: argument,
    [[target]]:empty}.

Algorithms steps that say to throw an exception, such as

1.  Throw a TYPEERROR exception.

Mean the same things as:

1.  Return Completion {[[type]]: throw, [[value]]: a newly created
    TYPEERROR object, [[target]]:empty}.

Algorithms steps that say

1.  ReturnIfAbrupt(argument).

mean the same things as:

1.  If argument is an abrupt completion, then return argument.

2.  Else if argument is a Completion Record, then let argument be
    argument.[[value]].

3.  

NOTE The Reference type is used to explain the behaviour of such
operators as DELETE, TYPEOF, the assignment operators, the SUPER keyword
and other lanauge features.. For example, the left-hand operand of an
assignment is expected to produce a reference.

A REFERENCE is a resolved name binding. A Reference consists of three
components, the base value, the _referenced name_ and the Boolean
valued _strict reference_ flag. The base value is either UNDEFINED, an
Object, a Boolean, a String, a Number, or an environment record
(10.2.1). A base value of UNDEFINED indicates that the Reference could
not be resolved to a binding. The _referenced name_ is a String.

A Super Reference is a Reference that is used to represents a name
binding that was expressed using the super keyword. A Super Reference
has an additional thisValue component and its base value will never
be an environment record.

The following abstract operations are used in this specification to
access the components of references:

-   GetBase(V). Returns the base value component of the reference V.

-   GetReferencedName(V). Returns the referenced name component of the
    reference V.

-   IsStrictReference(V). Returns the strict reference component of the
    reference V.

-   HasPrimitiveBase(V). Returns TRUE if the base value is a Boolean,
    String, or Number.

-   IsPropertyReference(V). Returns TRUE if either the base value is an
    object or HasPrimitiveBase(V) is TRUE; otherwise returns FALSE.

-   IsUnresolvableReference(V). Returns TRUE if the base value is
    UNDEFINED and FALSE otherwise.

-   IsSuperReference(V). Returns TRUE if this reference has a
    thisValue component.

The following abstract operations are used in this specification to
operate on references:

The following [[Get]](P [, accessorThisValue]) internal method is used
by GetValue when V is a property reference with a primitive base
value. base is the value the internal method is called upon with
property name P as its argument. The following steps are taken:

NOTE The object that may be created in step 1 is not accessible outside
of the above method. An implementation might choose to avoid the actual
creation of the object. The only situation where such an actual property
access that uses this internal method can have visible effect is when it
invokes an accessor function.

1.  ReturnIfAbrupt(V).

2.  ReturnIfAbrupt(W).

3.  4.  5.  If Type(V) is not Reference, throw a REFERENCEERROR
    exception.

6.  Let base be the result of calling GetBase(V).

7.  If IsUnresolvableReference(V), then

    a.  If IsStrictReference(V) is TRUE, then

        i.  Throw REFERENCEERROR exception.

    b.  Return the result of calling the [[Put]] internal method of the
        global object, passing GetReferencedName(V) for the property
        name, W for the value, and FALSE for the Throw flag.

8.  Else if IsPropertyReference(V), then

    a.  If HasPrimitiveBase(V) is FALSE, then let put be the [[Put]]
        internal method of base, otherwise let put be the special
        [[Put]] internal method defined below.

    b.  If IsSuperReference(V) is FALSE, then

        i.  Return the result of calling put as an internal method of
            base passing GetReferencedName(V) for the property name,
            W for the value, and IsStrictReference(V) for the
            Throw flag.

    c.  Else,

        i.  Return the result of calling put as an internal method of
            base passing GetReferencedName(V) for the property name,
            W for the value, IsStrictReference(V) for the Throw
            flag, and GetThisValue(V) as the accessorThisValue
            argument.

9.  Else base must be a reference whose base is an environment record.
    So,

    a.  Return the result of calling the SetMutableBinding (10.2.1)
        concrete method of base, passing GetReferencedName(V), W,
        and IsStrictReference(V) as arguments.

10. Return UNDEFINED.

The following [[Put]] internal method is used by PutValue when V is a
property reference with a primitive base value. base is the value the
internal method is called upon with property name P, value W, and
Boolean flag Throw as required arguments and optional argument
accessorThisValue. The following steps are taken:

NOTE The object that may be created in step 1 is not accessible outside
of the above method. An implementation might choose to avoid the actual
creation of that transient object. The only situations where such an
actual property assignment that uses this internal method can have
visible effect are when it either invokes an accessor function or is in
violation of a Throw predicated error check. When Throw is TRUE any
property assignment that would create a new property on the transient
object throws an error.

1.  ReturnIfAbrupt(V).

2.  If Type(V) is not Reference, return V.

3.  If IsUnresolvableReference(V), throw a REFERENCEERROR exception.

4.  If IsSuperReference(V), then

    a.  Return the value of the thisValue component of the reference
        V.

5.  Return GetBase(V).

The Property Descriptor type is used to explain the manipulation and
reification of named property attributes. Values of the Property
Descriptor type are records composed of named fields where each field’s
name is an attribute name and its value is a corresponding attribute
value as specified in 8.6.1. In addition, any field may be present or
absent.

Property Descriptor values may be further classified as data property
descriptors and accessor property descriptors based upon the existence
or use of certain fields. A data property descriptor is one that
includes any fields named either [[Value]] or [[Writable]]. An accessor
property descriptor is one that includes any fields named either [[Get]]
or [[Set]]. Any property descriptor may have fields named [[Enumerable]]
and [[Configurable]]. A Property Descriptor value may not be both a data
property descriptor and an accessor property descriptor; however, it may
be neither. A generic property descriptor is a Property Descriptor value
that is neither a data property descriptor nor an accessor property
descriptor. A fully populated property descriptor is one that is either
an accessor property descriptor or a data property descriptor and that
has all of the fields that correspond to the property attributes defined
in either 8.6.1 Table 5 or Table 6.

For notational convenience within this specification, an object
literal-like syntax can be used to define a property descriptor value.
For example, Property Descriptor {[[Value]]: 42, [[Writable]]: FALSE,
[[Configurable]]: TRUE} defines a data property descriptor. Field name
order is not significant. Any fields that are not explicitly listed are
considered to be absent.

In specification text and algorithms, dot notation may be used to refer
to a specific field of a Property Descriptor. For example, if D is a
property descriptor then D.[[Value]] is shorthand for “the field of D
named [[Value]]”.

The Property Identifier type is used to associate a property name with a
Property Descriptor. Values of the Property Identifier type are pairs of
the form (name, descriptor), where name is a String and descriptor is a
Property Descriptor value.

The following abstract operations are used in this specification to
operate upon Property Descriptor values:

When the abstract operation IsAccessorDescriptor is called with property
descriptor Desc, the following steps are taken:

1.  If Desc is UNDEFINED, then return FALSE.

2.  If both Desc.[[Get]] and Desc.[[Set]] are absent, then return
    FALSE.

3.  Return TRUE.

When the abstract operation IsDataDescriptor is called with property
descriptor Desc, the following steps are taken:

When the abstract operation IsGenericDescriptor is called with property
descriptor Desc, the following steps are taken:

When the abstract operation FromPropertyDescriptor is called with
property descriptor Desc, the following steps are taken:

The following algorithm assumes that Desc is a fully populated
Property Descriptor, such as that returned from [[GetOwnProperty]] (see
8.12.1).

When the abstract operation ToPropertyDescriptor is called with object
Obj, the following steps are taken:

The Lexical Environment and Environment Record types are used to explain
the behaviour of name resolution in nested functions and blocks. These
types and the operations upon them are defined in Clause 10.

In the following algorithm descriptions, assume O is a native
ECMAScript object, P is a String, Desc is a Property Description
record, and Throw is a Boolean flag.

When the [[GetOwnProperty]] internal method of O is called with
property name P, the following steps are taken:

However, if O is a String object it has a more elaborate
[[GetOwnProperty]] internal method defined in 15.5.5.2.

When the [[GetProperty]] internal method of O is called with property
name P, the following steps are taken:

When the [[Get]] internal method of O is called with property name
P, the following steps are taken:

1.  

2.  Let desc be the result of calling the [[GetProperty]] internal
    method of O with property name P.

3.  If desc is UNDEFINED, return UNDEFINED.

4.  If IsDataDescriptor(desc) is TRUE, return desc.[[Value]].

5.  Otherwise, IsAccessorDescriptor(desc) must be true so, let
    getter be desc.[[Get]].

6.  If getter is UNDEFINED, return UNDEFINED.

7.  If accessorThisValue is not present, then let accessorThisValue
    be O.

8.  Return the result calling the [[Call]] internal method of getter
    providing accessorThisValue as thisArgument and an empty List as
    argumentsList.

When the [[CanPut]] internal method of O is called with property name
P, the following steps are taken:

Exotic objects may define additional constraints upon [[Put]]
operations. If possible, exotic objects should not allow [[Put]]
operations in situations where this definition of [[CanPut]] returns
false.

When the [[Put]] internal method of O is called with property P,
value V, and Boolean flag Throw, the following steps are taken:

1.  2.  If the result of calling the [[CanPut]] internal method of O
    with argument P is FALSE, then

    a.  If Throw is TRUE, then throw a TYPEERROR exception.

    b.  Else return UNDEFINED.

3.  Let ownDesc be the result of calling the [[GetOwnProperty]]
    internal method of O with argument P.

4.  If IsDataDescriptor(ownDesc) is TRUE, then

    a.  Let valueDesc be the Property Descriptor {[[Value]]: V}.

    b.  Return the result of calling the [[DefineOwnProperty]] internal
        method of O passing P, valueDesc, and Throw as
        arguments.

    c.  

5.  Let desc be the result of calling the [[GetProperty]] internal
    method of O with argument P. This may be UNDEFINED or either an
    own or inherited accessor property descriptor or an inherited data
    property descriptor.

6.  If IsAccessorDescriptor(desc) is TRUE, then

    a.  Let setter be desc.[[Set]] which cannot be UNDEFINED.

    b.  If accessorThisValue is not present, then let
        accessorThisValue be O.

    c.  Return the result of calling the [[Call]] internal method of
        setter providing accessorThisValue as thisArgument and
        List containing V as argumentsList.

7.  Else create a named data property named P on object O as
    follows,

    a.  Let newDesc be the Property Descriptor
        {[[Value]]: V, [[Writable]]: TRUE, [[Enumerable]]: TRUE,
        [[Configurable]]: TRUE}.

    b.  Return the result of calling the [[DefineOwnProperty]] internal
        method of O passing P, newDesc, and Throw as arguments.

8.  

When the [[HasProperty]] internal method of O is called with property
name P, the following steps are taken:

When the [[Delete]] internal method of O is called with property name
P and the Boolean flag Throw, the following steps are taken:

When the [[DefaultValue]] internal method of O is called with hint
String, the following steps are taken:

When the [[DefaultValue]] internal method of O is called with hint
Number, the following steps are taken:

When the [[DefaultValue]] internal method of O is called with no hint,
then it behaves as if the hint were Number, unless O is a Date object
(see 15.9.6), in which case it behaves as if the hint were String.

The above specification of [[DefaultValue]] for ordinary objects can
return only primitive values. If an exotic object implements its own
[[DefaultValue]] internal method, it must ensure that its
[[DefaultValue]] internal method can return only primitive values.

In the following algorithm, the term “Reject” means “If Throw is TRUE,
then throw a TYPEERROR exception, otherwise return FALSE”. The algorithm
contains steps that test various fields of the Property Descriptor
Desc for specific values. The fields that are tested in this manner
need not actually exist in Desc. If a field is absent then its value
is considered to be FALSE.

When the [[DefineOwnProperty]] internal method of O is called with
property name P, property descriptor Desc, and Boolean flag Throw,
the following steps are taken:

1.  2.  Let current be the result of calling the [[GetOwnProperty]]
    internal method of O with property name P.

3.  Let extensible be the value of the [[Extensible]] internal
    property of O.

4.  If current is UNDEFINED and extensible is FALSE, then Reject.

5.  If current is UNDEFINED and extensible is TRUE, then

    a.  If IsGenericDescriptor(Desc) or IsDataDescriptor(Desc) is
        TRUE, then

        i.  Create an own data property named P of object O whose
            [[Value]], [[Writable]], [[Enumerable]] and [[Configurable]]
            attribute values are described by Desc. If the value of an
            attribute field of Desc is absent, the attribute of the
            newly created property is set to its default value.

    b.  Else Desc must be an accessor Property Descriptor,

        i.  Create an own accessor property named P of object O
            whose [[Get]], [[Set]], [[Enumerable]] and [[Configurable]]
            attribute values are described by Desc. If the value of an
            attribute field of Desc is absent, the attribute of the
            newly created property is set to its default value.

    c.  Return TRUE.

6.  Return TRUE, if every field in Desc is absent.

7.  Return TRUE, if every field in Desc also occurs in current and
    the value of every field in Desc is the same value as the
    corresponding field in current when compared using the SameValue
    algorithm (9.12).

8.  If the [[Configurable]] field of current is FALSE then

    a.  Reject, if the [[Configurable]] field of Desc is TRUE.

    b.  Reject, if the [[Enumerable]] field of Desc is present and the
        [[Enumerable]] fields of current and Desc are the Boolean
        negation of each other.

9.  If IsGenericDescriptor(Desc) is TRUE, then no further validation
    is required.

10. Else if IsDataDescriptor(current) and IsDataDescriptor(Desc)
    have different results, then

    a.  Reject, if the [[Configurable]] field of current is FALSE.

    b.  If IsDataDescriptor(current) is TRUE, then

        i.  Convert the property named P of object O from a data
            property to an accessor property. Preserve the existing
            values of the converted property’s [[Configurable]] and
            [[Enumerable]] attributes and set the rest of the property’s
            attributes to their default values.

    c.  Else,

        i.  Convert the property named P of object O from an
            accessor property to a data property. Preserve the existing
            values of the converted property’s [[Configurable]] and
            [[Enumerable]] attributes and set the rest of the property’s
            attributes to their default values.

11. Else if IsDataDescriptor(current) and IsDataDescriptor(Desc) are
    both TRUE, then

    a.  If the [[Configurable]] field of current is FALSE, then

        i.  Reject, if the [[Writable]] field of current is FALSE and
            the [[Writable]] field of Desc is TRUE.

        ii. If the [[Writable]] field of current is FALSE, then

            1.  Reject, if the [[Value]] field of Desc is present and
                SameValue(Desc.[[Value]], current.[[Value]]) is
                FALSE.

    b.  else the [[Configurable]] field of current is TRUE, so any
        change is acceptable.

12. Else IsAccessorDescriptor(current) and
    IsAccessorDescriptor(Desc) are both TRUE,

    a.  If the [[Configurable]] field of current is FALSE, then

        i.  Reject, if the [[Set]] field of Desc is present and
            SameValue(Desc.[[Set]], current.[[Set]]) is FALSE.

        ii. Reject, if the [[Get]] field of Desc is present and
            SameValue(Desc.[[Get]], current.[[Get]]) is FALSE.

13. For each attribute field of Desc that is present, set the
    correspondingly named attribute of the property named P of object
    O to the value of the field.

14. Return TRUE.

However, if O has an [[NativeBrand]] internal property whose value is
NativeArray O also has a more elaborate [[DefineOwnProperty]] internal
method defined in 15.4.5.1.

NOTE Step 10.b allows any field of Desc to be different from the
corresponding field of current if current’s [[Configurable]] field is
TRUE. This even permits changing the [[Value]] of a property whose
[[Writable]] attribute is FALSE. This is allowed because a TRUE
[[Configurable]] attribute would permit an equivalent sequence of calls
where [[Writable]] is first set to TRUE, a new [[Value]] is set, and
then [[Writable]] is set to FALSE.

When the [[Enumerate]] internal method of O is called with Boolean
arguments includePrototype and onlyEnumerable, the following steps
are taken:

1.  Return an Iterator object (reference xxxx) whose next method
    iterates over all the keys of enumerable property keys of O. If
    includePrototype is FALSE, then only own properties of O are
    included. If onlyEnumerable is FALSE, then all properties that do
    not have private name keys are included. The mechanics and order of
    enumerating the properties is not specified but must conform to the
    rules specified below.

Enumerated properties do not include properties whose property key is a
private name. Properties of the object being enumerated may be deleted
during enumeration. If a property that has not yet been visited during
enumeration is deleted, then it will not be visited. If new properties
are added to the object being enumerated during enumeration, the newly
added properties are not guaranteed to be visited in the active
enumeration. A property name must not be visited more than once in any
enumeration.

Enumerating the properties of an object includes enumerating properties
of its prototype, and the prototype of the prototype, and so on,
recursively; but a property of a prototype is not enumerated if it is
“shadowed” because some previous object in the prototype chain has a
property with the same name. The values of [[Enumerable]] attributes are
not considered when determining if a property of a prototype object is
shadowed by a previous object on the prototype chain.

The following is an informative algorithm that conforms to these rules

1.  Let obj be O.

2.  Let proto be the value of the [[Prototype]] internal property of
    O.

3.  If includePrototype is false or proto is the value NULL, then

    a.  Let propList be a new empty List.

4.  Else

    a.  Let propList be the result of calling the [[Enumerate]]
        internal method of proto with arguments TRUE and
        onlyEnumerable.

5.  For each string name that is the property key of an own property
    of O

    a.  Let desc be the result of calling the [[GetOwnProperty]]
        internal method of O with argument name.

    b.  If name is an element of propList, then remove name as an
        element of propList.

    c.  If onlyEnumerable is FALSE or desc.[[Enumerable]] is TRUE,
        then add name as an element of propList.

6.  Order the elements of propList in an implementation defined order.

7.  Return propList.

When the [[Iterate]] internal method of O is called the following
steps are taken:

1.  Let itr be the result of performing Invoke with arguments
    %iterator%, O and an empty argument List.

2.  Return itr.

_THIS SECTION IS A PLACEHOLDER FOR_ DESCRIBING _THE DATA BLOCK
INTERNAL TYPE. THE FOLLOWING MATERIAL IS VERBATIUM FROM THE THE BINARY
DATA ES WIKI PROPOSAL._ _THE MATERIAL HAS NOT YET BEEN REVIEWED OR
INTEGRATED WITH THE REST OF THIS SPEC._

This spec introduces a new, spec-internal block datatype, intuitively
representing a contiguously allocated block of binary data. Blocks are
not ECMAScript values and appear only in the program store (aka heap).

A block is one of:

-   a number-block

-   an array-block[t, n]

-   a struct-block[t1, ..., tn]

A number-block is one of:

-   an unsigned-integer; i.e., one of uint8, uint16, uint32, or uint64

-   a signed-integer; i.e., one of int8, int16, int32, or int64

-   a floating-point; i.e., one of float32 or float64

A uintk is an integer in the range [0, 2k). An intk is an integer in the
range [-2k-1, 2k-1). A floatk is a floating-point number representable
as a k-bit IEE754 value.

An array-block[t, n] is an ordered sequence of n blocks of homogeneous
block type t. Each element of the array is stored at in independently
addressable location in the program store, and multiple Data objects may
contain references to the element.

A struct-block[t1, ..., tn] is an ordered sequence of n blocks of
heterogeneous types t1 to tn, respectively. Each field of the struct is
stored at in independently addressable location in the program store,
and multiple Data objects may contain references to the field.

The spec also introduces a datatype of Data objects, which are
ECMAScript values that encapsulate references to block data in the
program store. Every Data object has the following properties:

[[Class]] = “Data”

[[Value]] : reference[block] – a reference to a block in the program
store

[[DataType]] : reference[Type] – a reference to a Type object describing
this object’s data block

These operations are not a part of the ECMAScript language; they are
defined here to solely to aid the specification of the semantics of the
ECMAScript Language. Other, more specialized abstract operations are
defined throughout this specification.

The ECMAScript language implicitly performs automatic type conversion as
needed. To clarify the semantics of certain constructs it is useful to
define a set of conversion abstract operations.. The conversion abstract
operations are polymorphic; that is, they can accept a value of any
ECMAScript language type, but not of specification types.

The abstract operation ToPrimitive takes an input argument and an
optional argument PreferredType. The abstract operation ToPrimitive
converts its input argument to a non-Object type. If an object is
capable of converting to more than one primitive type, it may use the
optional hint PreferredType to favour that type. Conversion occurs
according to Table 12:

Table 12 — ToPrimitive Conversions

  ------------------- ---------------------------------------------------------------------------------------------------------------------------------------
  _INPUT TYPE_        RESULT

  Completion Record   If argument is an abrupt completion, return argument. Otherwise return ToPrimitive(argument.[[value]])

  Undefined           Return argument t (no conversion).

  Null                Return argument (no conversion).

  Boolean             Return argument (no conversion).

  Number              Return argument (no conversion).

  String              Return argument (no conversion).

  Object              Perform the following steps:
                      
                      Let default be the result of calling the [[DefaultValue]] internal method of argument, passing the optional hint PreferredType.
                      
                      Return ToPrimitive(default).
                      
                      The behaviour of the [[DefaultValue]] internal method is defined by this specification for all native ECMAScript objects in 8.12.8.
  ------------------- ---------------------------------------------------------------------------------------------------------------------------------------

The abstract operation ToBoolean converts its argument to a value of
type Boolean according to Table 13:

Table 13 — ToBoolean Conversions

  ------------------- --------------------------------------------------------------------------------------------------------------
  _ARGUMENT TYPE_     RESULT
  Completion Record   If argument is an abrupt completion, return the argument. Otherwise return ToBoolean(argument.[[value]])
  Undefined           Return FALSE
  Null                Return FALSE
  Boolean             Return the input argument (no conversion).
  Number              Return FALSE if the argument is +0, −0, or NAN; otherwise return TRUE.
  String              Return FALSE if the argument is the empty String (its length is zero); otherwise return TRUE.
  Object              Return TRUE
  ------------------- --------------------------------------------------------------------------------------------------------------

The abstract operation ToNumber converts its argument to a value of
type Number according to Table 14:

Table 14 — To Number Conversions

  ------------------- -----------------------------------------------------------------------------------------------------------
  _ARGUMENT TYPE_     RESULT

  Completion Record   If argument is an abrupt completion, return argument. Otherwise return ToNumber(argument.[[value]])

  Undefined           Return NAN

  Null                Return +0

  Boolean             Return 1 if argument is TRUE. Return +0 if argument is FALSE.

  Number              Return argument (no conversion).

  String              See grammar and note below.

  Object              Apply the following steps:
                      
                      Let primValue be ToPrimitive(argument, hint Number).
                      
                      Return ToNumber(primValue).
  ------------------- -----------------------------------------------------------------------------------------------------------

ToNumber applied to Strings applies the following grammar to the input
String. If the grammar cannot interpret the String as an expansion of
StringNumericLiteral, then the result of ToNumber is NAN.

Syntax

StringNumericLiteral :::

StrWhiteSpace~opt~
StrWhiteSpace~opt~ StrNumericLiteral StrWhiteSpace~opt~

StrWhiteSpace :::

StrWhiteSpaceChar StrWhiteSpace~opt~

StrWhiteSpaceChar :::

WhiteSpace
LineTerminator

StrNumericLiteral :::

StrDecimalLiteral
HexIntegerLiteral

StrDecimalLiteral :::

StrUnsignedDecimalLiteral
+ StrUnsignedDecimalLiteral
- StrUnsignedDecimalLiteral

StrUnsignedDecimalLiteral :::

INFINITY
 DecimalDigits . DecimalDigits~opt~ ExponentPart~opt~
. DecimalDigits ExponentPart~opt~
DecimalDigits ExponentPart~opt~

DecimalDigits :::

DecimalDigit
DecimalDigits DecimalDigit

DecimalDigit ::: ONE OF

0 1 2 3 4 5 6 7 8 9

ExponentPart :::

ExponentIndicator SignedInteger

ExponentIndicator ::: ONE OF

E E

SignedInteger :::

DecimalDigits
+ DecimalDigits
- DecimalDigits

HexIntegerLiteral :::

0X HexDigit
0X HexDigit
HexIntegerLiteral HexDigit

HexDigit ::: ONE OF

0 1 2 3 4 5 6 7 8 9 A B C D E F A B C D E F

NOTE Some differences should be noted between the syntax of a
StringNumericLiteral and a NumericLiteral (see 7.8.3):

-   A StringNumericLiteral may be preceded and/or followed by white
    space and/or line terminators.

-   A StringNumericLiteral that is decimal may have any number of
    leading 0 digits.

-   A StringNumericLiteral that is decimal may be preceded by + or -
    to indicate its sign.

-   A StringNumericLiteral that is empty or contains only white space
    is converted to +0.

-   INFINITY AND –INFINITY are recognized as a StringNumericLiteral
    but not as a NumericLiteral.

RUNTIME SEMANTICS

The conversion of a String to a Number value is similar overall to the
determination of the Number value for a numeric literal (see 7.8.3), but
some of the details are different, so the process for converting a
String numeric literal to a value of Number type is given here in full.
This value is determined in two steps: first, a mathematical value (MV)
is derived from the String numeric literal; second, this mathematical
value is rounded as described below.

-   The MV of StringNumericLiteral ::: [empty] is 0.

-   The MV of StringNumericLiteral ::: StrWhiteSpace is 0.

-   The MV of StringNumericLiteral ::: StrWhiteSpace~opt~
      StrNumericLiteral StrWhiteSpace~opt~ is the MV of
      StrNumericLiteral, no matter whether white space is present or
      not.

-   The MV of StrNumericLiteral ::: StrDecimalLiteral is the MV of
      StrDecimalLiteral.

-   The MV of StrNumericLiteral ::: HexIntegerLiteral is the MV of
      HexIntegerLiteral.

-   The MV of StrDecimalLiteral ::: StrUnsignedDecimalLiteral is the
      MV of StrUnsignedDecimalLiteral.

-   The MV of StrDecimalLiteral ::: + StrUnsignedDecimalLiteral is
      the MV of StrUnsignedDecimalLiteral.

-   The MV of StrDecimalLiteral ::: - StrUnsignedDecimalLiteral is
      the negative of the MV of StrUnsignedDecimalLiteral. (Note that
      if the MV of StrUnsignedDecimalLiteral is 0, the negative of
      this MV is also 0. The rounding rule described below handles the
      conversion of this signless mathematical zero to a floating-point
      +0 or −0 as appropriate.)

-   The MV of StrUnsignedDecimalLiteral::: INFINITY is 10^10000^ (a
      value so large that it will round to +∞).

-   The MV of StrUnsignedDecimalLiteral::: DecimalDigits. is the MV
      of DecimalDigits.

-   The MV of StrUnsignedDecimalLiteral::: DecimalDigits .
      DecimalDigits is the MV of the first DecimalDigits plus (the
      MV of the second DecimalDigits times 10^−n^), where n is the
      number of characters in the second DecimalDigits.

-   The MV of StrUnsignedDecimalLiteral::: DecimalDigits.
      ExponentPart is the MV of DecimalDigits times 10^e^, where
      e is the MV of ExponentPart.

-   The MV of StrUnsignedDecimalLiteral::: DecimalDigits.
      _DecimalDigits ExponentPart_ is (the MV of the first
      DecimalDigits plus (the MV of the second DecimalDigits times
      10^−n^)) times 10^e^, where n is the number of characters in
      the second DecimalDigits and e is the MV of ExponentPart.

-   The MV of StrUnsignedDecimalLiteral:::. DecimalDigits is the MV
      of DecimalDigits times 10^−n^, where n is the number of
      characters in DecimalDigits.

-   The MV of StrUnsignedDecimalLiteral:::. _DecimalDigits
      ExponentPart_ is the MV of DecimalDigits times 10^e_−_n^,
      where n is the number of characters in DecimalDigits and e
      is the MV of ExponentPart.

-   The MV of StrUnsignedDecimalLiteral::: DecimalDigits is the MV
      of DecimalDigits.

-   The MV of StrUnsignedDecimalLiteral::: DecimalDigits
      ExponentPart is the MV of DecimalDigits times 10^e^, where
      e is the MV of ExponentPart.

-   The MV of DecimalDigits ::: DecimalDigit is the MV of
      DecimalDigit.

-   The MV of DecimalDigits ::: DecimalDigits DecimalDigit is (the
      MV of DecimalDigits times 10) plus the MV of DecimalDigit.

-   The MV of ExponentPart ::: _ExponentIndicator SignedInteger_ is
      the MV of SignedInteger.

-   The MV of SignedInteger ::: DecimalDigits is the MV of
      DecimalDigits.

-   The MV of SignedInteger ::: + DecimalDigits is the MV of
      DecimalDigits.

-   The MV of SignedInteger ::: - DecimalDigits is the negative of
      the MV of DecimalDigits.

-   The MV of DecimalDigit ::: 0 or of HexDigit ::: 0 is 0.

-   The MV of DecimalDigit ::: 1 or of HexDigit ::: 1 is 1.

-   The MV of DecimalDigit ::: 2 or of HexDigit ::: 2 is 2.

-   The MV of DecimalDigit ::: 3 or of HexDigit ::: 3 is 3.

-   The MV of DecimalDigit ::: 4 or of HexDigit ::: 4 is 4.

-   The MV of DecimalDigit ::: 5 or of HexDigit ::: 5 is 5.

-   The MV of DecimalDigit ::: 6 or of HexDigit ::: 6 is 6.

-   The MV of DecimalDigit ::: 7 or of HexDigit ::: 7 is 7.

-   The MV of DecimalDigit ::: 8 or of HexDigit ::: 8 is 8.

-   The MV of DecimalDigit ::: 9 or of HexDigit ::: 9 is 9.

-   The MV of HexDigit ::: A or of HexDigit ::: A is 10.

-   The MV of HexDigit ::: B or of HexDigit ::: B is 11.

-   The MV of HexDigit ::: C or of HexDigit ::: C is 12.

-   The MV of HexDigit ::: D or of HexDigit ::: D is 13.

-   The MV of HexDigit ::: E or of HexDigit ::: E is 14.

-   The MV of HexDigit ::: F or of HexDigit ::: F is 15.

-   The MV of HexIntegerLiteral ::: 0X HexDigit is the MV of
      HexDigit.

-   The MV of HexIntegerLiteral ::: 0X HexDigit is the MV of
      HexDigit.

-   The MV of HexIntegerLiteral ::: HexIntegerLiteral HexDigit is
      (the MV of HexIntegerLiteral times 16) plus the MV of
      HexDigit.

Once the exact MV for a String numeric literal has been determined, it
is then rounded to a value of the Number type. If the MV is 0, then the
rounded value is +0 unless the first non white space character in the
String numeric literal is ‘-’, in which case the rounded value is −0.
Otherwise, the rounded value must be the Number value for the MV (in the
sense defined in 8.5), unless the literal includes a
StrUnsignedDecimalLiteral and the literal has more than 20 significant
digits, in which case the Number value may be either the Number value
for the MV of a literal produced by replacing each significant digit
after the 20th with a 0 digit or the Number value for the MV of a
literal produced by replacing each significant digit after the 20th with
a 0 digit and then incrementing the literal at the 20th digit position.
A digit is significant if it is not part of an ExponentPart and

-   it is not 0; or

-   there is a nonzero digit to its left and there is a nonzero digit,
    not in the ExponentPart, to its right.

The abstract operation ToInteger converts its argument to an integral
numeric value. This abstract operation functions as follows:

The abstract operation ToInt32 converts its argument to one of 2^32^
integer values in the range −2^31^ through 2^31^−1, inclusive. This
abstract operation functions as follows:

NOTE Given the above definition of ToInt32:

-   The ToInt32 abstract operation is idempotent: if applied to a result
      that it produced, the second application leaves that value
      unchanged.

-   ToInt32(ToUint32(x)) is equal to ToInt32(x) for all values of
      x. (It is to preserve this latter property that +∞ and −∞ are
      mapped to +0.)

-   ToInt32 maps −0 to +0.

The abstract operation ToUint32 converts its argument to one of 2^32^
integer values in the range 0 through 2^32^−1, inclusive. This abstract
operation functions as follows:

NOTE Given the above definition of ToUInt32:

-   Step 5 is the only difference between ToUint32 and ToInt32.

-   The ToUint32 abstract operation is idempotent: if applied to a
      result that it produced, the second application leaves that value
      unchanged.

-   ToUint32(ToInt32(x)) is equal to ToUint32(x) for all values of
      x. (It is to preserve this latter property that +∞ and −∞ are
      mapped to +0.)

-   ToUint32 maps −0 to +0.

The abstract operation ToUint16 converts its argument to one of 2^16^
integer values in the range 0 through 2^16^−1, inclusive. This abstract
operation functions as follows:

NOTE Given the above definition of ToUint16:

-   The substitution of 2^16^ for 2^32^ in step 4 is the only difference
      between ToUint32 and ToUint16.

-   ToUint16 maps −0 to +0.

The abstract operation ToString converts its argument to a value of
type String according to Table 15:

Table 15 — ToString Conversions

  ------------------- -----------------------------------------------------------------------------------------------------------
  _ARGUMENT TYPE_     RESULT

  Completion Record   If argument is an abrupt completion, return argument. Otherwise return ToString(argument.[[value]])

  Undefined           "UNDEFINED"

  Null                "NULL"

  Boolean             If argument is TRUE, then return "TRUE".
                      
                      If argument is FALSE, then return "FALSE".

  Number              See 9.8.1.

  String              Return argument (no conversion)

  Object              Apply the following steps:
                      
                      1. Let primValue be ToPrimitive(argument, hint String).
                      
                      2. Return ToString(primValue).
  ------------------- -----------------------------------------------------------------------------------------------------------

The abstract operation ToString converts a Number m to String format
as follows:

1.  If m is NAN, return the String "NAN".

2.  If m is +0 or −0, return the String "0".

3.  If m is less than zero, return the String concatenation of the
    String "-" and ToString(−m).

4.  If m is infinity, return the String "INFINITY".

5.  Otherwise, let n, k, and s be integers such that k ≥ 1,
    10^k−1^ ≤ s < 10^k^, the Number value for s × 10^n−k^ is
    m, and k is as small as possible. Note that k is the number of
    digits in the decimal representation of s, that s is not
    divisible by 10, and that the least significant digit of s is not
    necessarily uniquely determined by these criteria.

6.  If k ≤ n ≤ 21, return the String consisting of the k digits of
    the decimal representation of s (in order, with no leading zeroes),
    followed by n−k occurrences of the character ‘0’.

7.  If 0 < n ≤ 21, return the String consisting of the most significant
    n digits of the decimal representation of s, followed by a
    decimal point ‘.’, followed by the remaining k−n digits of the
    decimal representation of s.

8.  If −6 < n ≤ 0, return the String consisting of the character ‘0’,
    followed by a decimal point ‘.’, followed by −n occurrences of the
    character ‘0’, followed by the k digits of the decimal
    representation of s.

9.  Otherwise, if k = 1, return the String consisting of the single
    digit of s, followed by lowercase character ‘E’, followed by a
    plus sign ‘+’ or minus sign ‘−’ according to whether n−1 is
    positive or negative, followed by the decimal representation of the
    integer abs(n−1) (with no leading zeroes).

10. Return the String consisting of the most significant digit of the
    decimal representation of s, followed by a decimal point ‘.’,
    followed by the remaining k−1 digits of the decimal representation
    of s, followed by the lowercase character ‘E’, followed by a plus
    sign ‘+’ or minus sign ‘−’ according to whether n−1 is positive or
    negative, followed by the decimal representation of the integer
    abs(n−1) (with no leading zeroes).

NOTE 1 The following observations may be useful as guidelines for
implementations, but are not part of the normative requirements of this
Standard:

-   If x is any Number value other than −0, then ToNumber(ToString(x))
      is exactly the same Number value as x.

-   The least significant digit of s is not always uniquely determined
      by the requirements listed in step 5.

NOTE 2 For implementations that provide more accurate conversions than
required by the rules above, it is recommended that the following
alternative version of step 5 be used as a guideline:

  Otherwise, let n, k, and s be integers such that k ≥ 1,
  10^k−1^ ≤ s < 10^k^, the Number value for s × 10^n_−_k^ is
  m, and k is as small as possible. If there are multiple
  possibilities for s, choose the value of s for which s ×
  10^n_−_k^ is closest in value to m. If there are two such possible
  values of s, choose the one that is even. Note that k is the
  number of digits in the decimal representation of s and that s is
  not divisible by 10.

NOTE 3 Implementers of ECMAScript may find useful the paper and code
written by David M. Gay for binary-to-decimal conversion of
floating-point numbers:

  Gay, David M. Correctly Rounded Binary-Decimal and Decimal-Binary
  Conversions. Numerical Analysis, Manuscript 90-10. AT&T Bell
  Laboratories (Murray Hill, New Jersey). November 30, 1990. Available
  as
  http://cm.bell-labs.com/cm/cs/doc/90/4-10.ps.gz. Associated code
  available as
  http://cm.bell-labs.com/netlib/fp/dtoa.c.gz and as
  http://cm.bell-labs.com/netlib/fp/g_fmt.c.gz and may also be found at
  the various NETLIB mirror sites.

The abstract operation ToObject converts its argument to a value of
type Object according to Table 16:

Table 16 — ToObject

  ------------------- ----------------------------------------------------------------------------------------------------------------------------------------------------------
  _ARGUMENT TYPE_     RESULT
  Completion Record   If argument is an abrupt completion, return argument. Otherwise return ToObject(argument.[[value]])
  Undefined           Throw a TYPEERROR exception.
  Null                Throw a TYPEERROR exception.
  Boolean             Return a new Boolean object whose [[PrimitiveValue]] internal property is set to the value of argument. See 15.6 for a description of Boolean objects.
  Number              Return a new Number object whose [[PrimitiveValue]] internal property is set to the value of argument. See 15.7 for a description of Number objects.
  String              Return a new String object whose [[PrimitiveValue]] internal property is set to the value of argument. See 15.5 for a description of String objects.
  Object              Return argument (no conversion).
  ------------------- ----------------------------------------------------------------------------------------------------------------------------------------------------------

The abstract operation ToPropertyKey converts its argument to a value
that can be used as a property key by performing the following steps:

1.  ReturnIfAbrupt(argument).

2.  If Type(argument) is Object, then

    a.  If argument has a [[NativeBrand]] internal property whose
        value is NativePrivateName, then

        i.  Return argument.

3.  Return ToString(argument).

The abstract operation CheckObjectCoercible throws an error if its
argument is a value that cannot be converted to an Object using
ToObject. It is defined by Table 17:

Table 17 — CheckObjectCoercible Results

  _ARGUMENT TYPE_     RESULT
  ------------------- -----------------------------------------------------------------------------------------------------------------------
  Completion Record   If argument is an abrupt completion, return argument. Otherwise return CheckObjectCoercible(argument.[[value]])
  Undefined           Throw a TYPEERROR exception.
  Null                Throw a TYPEERROR exception.
  Boolean             Return argument
  Number              Return argument
  String              Return argument
  Object              Return argument

The abstract operation IsCallable determines if its argument, which
must be an ECMAScript language value or a Completion Record, is a
callable function Object according to Table 18:

Table 18 — IsCallable Results

  ------------------- -------------------------------------------------------------------------------------------------------------
  _ARGUMENT TYPE_     RESULT
  Completion Record   If argument is an abrupt completion, return argument. Otherwise return IsCallable(argument.[[value]])
  Undefined           Return FALSE.
  Null                Return FALSE.
  Boolean             Return FALSE.
  Number              Return FALSE.
  String              Return FALSE.
  Object              If argument has a [[Call]] internal method, then return TRUE, otherwise return FALSE.
  ------------------- -------------------------------------------------------------------------------------------------------------

The internal comparison abstract operation SameValue(x, y), where
x and y are ECMAScript language values, produces TRUE or FALSE. Such
a comparison is performed as follows:

The abstract operation IsCallable determines if its argument, which
must be an ECMAScript language value value or a Completion Record, is a
function object with a [[Construct]] internal method.

1.  ReturnIfAbrupt(argument).

2.  If Type(argument) is not Object, return FALSE.

3.  If argument has a [[Construct]] internal method, return TRUE.

4.  Return FALSE.

The abstract operation Invoke is used to call a method property of an
object. The operation is called with arguments P, O, and args
where P is the property key, O serves as both the lookup point for
the property and the this value of the call, and args is the list of
arguments values passed to the method. This abstract operation perform,
the following steps:

There are three types of ECMAScript executable code:

-   _Global code_ is source text that is treated as an ECMAScript
      Script. The global code of a particular Script does not
      include any source text that is parsed as part of a
      FunctionBody, ConciseBody, ClassBody, or ModuleBody.

-   _Eval code_ is the source text supplied to the built-in EVAL
      function. More precisely, if the parameter to the built-in EVAL
      function is a String, it is treated as an ECMAScript Script. The
      eval code for a particular invocation of EVAL is the global code
      portion of that Script.

-   _Function code_ is source text that is parsed to supply the value of
      the [[Code]] internal property (see 13.6) of function and
      generator objects. The _function code_ of a particular function or
      generator does not include any source text that is parsed as the
      function code of a nested FunctionBody, ConciseBody, or
      ClassBody..

-   _Generator code_ is source text that is parsed to supply the value
      of the [[Code]] internal property (see 13.5) of generator objects.
      The generator code of a particular generator does not include
      any source text that is parsed as the function code of a nested
      FunctionBody, ConciseBody, or ClassBody. All generator code
      is also considered to be function code, but only function code
      that is defined within a generator is generator code.

-   _Module code_ is source text that is parse code that is provided as
      a ModuleBody. It is the code that is directly evaluated when a
      module is initialized. The module code of a particular module does
      not include any source text that is parsed as part of a nested
      FunctionBody, ConciseBody, ClassBody, or ModuleBody..

NOTE Function code is generally provided as the bodies of Function
Definitions (13.1), Arrow Function Definditions (13.2), Method
Definitions (13.3) and Generator Definitions (13.4). Function code is
also derived from the last argument to the Function constructor (15.3).
Generator code is provided as the bodies of Generator Definitions 13.4
and Generator Expressions (11.????).

An ECMAScript Script syntactic unit may be processed using either
unrestricted or strict mode syntax and semantics. When processed using
strict mode the three types of ECMAScript code are referred to as strict
global code, strict eval code, and strict function code. Code is
interpreted as strict mode code in the following situations:

-   Global code is strict global code if it begins with a Directive
      Prologue that contains a Use Strict Directive (see 14.1).

-   Module code is always strict code.

-   Eval code is strict eval code if it begins with a Directive Prologue
      that contains a Use Strict Directive or if the call to eval is a
      direct call (see 15.1.2.1.1) to the eval function that is
      contained in strict mode code.

-   Function code that is part of a FunctionDeclaration,
      FunctionExpression, or accessor PropertyDefinition is strict
      function code if its FunctionDeclaration, FunctionExpression,
      or PropertyDefinition is contained in strict mode code or if the
      function code begins with a Directive Prologue that contains a Use
      Strict Directive.

-   Function code that is supplied as the last argument to the built-in
      Function constructor is strict function code if the last argument
      is a String that when processed as a FunctionBody begins with a
      Directive Prologue that contains a Use Strict Directive.

-   -   -   -   -   -   

An ECMAScript implementation may support the evaluation of function
objects whose evaluative behaviour is expressed in some implementation
defined form of executable code other than via ECMAScript code. Whether
a function object is an ECMAScript code function or a non-ECMAScript
function is not semantically observable from the perspective of an
ECMAScript code function that calls or is called by such a
non-ECMAScript function.

A _Lexical Environment_ is a specification type used to define the
association of Identifiers to specific variables and functions based
upon the lexical nesting structure of ECMAScript code. A Lexical
Environment consists of an Environment Record and a possibly null
reference to an outer Lexical Environment. Usually a Lexical
Environment is associated with some specific syntactic structure of
ECMAScript code such as a FunctionDeclaration, a BlockStatement, or
a Catch clause of a TryStatement and a new Lexical Environment is
created each time such code is evaluated.

An _Environment Record_ records the identifier bindings that are created
within the scope of its associated Lexical Environment.

The outer environment reference is used to model the logical nesting of
Lexical Environment values. The outer reference of a (inner) Lexical
Environment is a reference to the Lexical Environment that logically
surrounds the inner Lexical Environment. An outer Lexical Environment
may, of course, have its own outer Lexical Environment. A Lexical
Environment may serve as the outer environment for multiple inner
Lexical Environments. For example, if a FunctionDeclaration contains
two nested FunctionDeclarations then the Lexical Environments of each
of the nested functions will have as their outer Lexical Environment the
Lexical Environment of the current evaluation of the surrounding
function.

A _global environment_ is a Lexical Environment which does not have an
outer environment. The global environment’s outer environment reference
is NULL. A global environment’s environment record may be prepopulated
with identifier bindings and includes an associated _global object_
whose properties provide some of the global environment’s identifier
bindings. This global object is the value of a global environment’s THIS
binding. As ECMAScript code is executed, additional properties may be
added to the global object and the initial properties may be modified.

A method environment is a Lexical Environment that corresponds to the
invocation of an ECMAScript function object that establishes a new THIS
binding. A method environment also captures the state necessary to
support SUPER method invocations.

Lexical Environments and Environment Record values are purely
specification mechanisms and need not correspond to any specific
artefact of an ECMAScript implementation. It is impossible for an
ECMAScript program to directly access or manipulate such values.

There are two primary kinds of Environment Record values used in this
specification: _declarative environment records_ and _object environment
records_. Declarative environment records are used to define the effect
of ECMAScript language syntactic elements such as
FunctionDeclarations, VariableDeclarations, and Catch clauses that
directly associate identifier bindings with ECMAScript language values.
Object environment records are used to define the effect of ECMAScript
elements such as WithStatement that associate identifier bindings with
the properties of some object. Global Environment Records and Function
Environment Records are specializations that are used for specifically
for Script global declarations and for top-level declarations within
funtions.

For specification purposes Environment Record values can be thought of
as existing in a simple object-oriented hierarchy where Environment
Record is an abstract class with three concrete subclasses, declarative
environment record, object environment record, and global environment
record. Function environment records are a subclass of declarative
environment record. The abstract class includes the abstract
specification methods defined in Table 19. These abstract methods have
distinct concrete algorithms for each of the concrete subclasses.

Table 19 — Abstract Methods of Environment Records

  METHOD                     PURPOSE
  ---------------------------- --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  HasBinding(N)                Determine if an environment record has a binding for an identifier. Return TRUE if it does and FALSE if it does not. The String value N is the text of the identifier.
  CreateMutableBinding(N, D)   Create a new but uninitialised mutable binding in an environment record. The String value N is the text of the bound name. If the optional Boolean argument D is TRUE the binding is may be subsequently deleted.
  CreateImmutableBinding(N)    Create a new but uninitialised immutable binding in an environment record. The String value N is the text of the bound name.
  InitializeBinding(N,V)       Set the value of an already existing but uninitialised binding in an environment record. The String value N is the text of the bound name. V is the value for the binding and is a value of any ECMAScript language type.
  SetMutableBinding(N,V, S)    Set the value of an already existing mutable binding in an environment record. The String value N is the text of the bound name. V is the value for the binding and may be a value of any ECMAScript language type. S is a Boolean flag. If S is TRUE and the binding cannot be set throw a TYPEERROR exception. S is used to identify strict mode references.
  GetBindingValue(N,S)         Returns the value of an already existing binding from an environment record. The String value N is the text of the bound name. S is used to identify strict mode references. If S is TRUE and the binding does not exist or is uninitialised throw a REFERENCEERROR exception.
  DeleteBinding(N)             Delete a binding from an environment record. The String value N is the text of the bound name If a binding for N exists, remove the binding and return TRUE. If the binding exists but cannot be removed return FALSE. If the binding does not exist return TRUE.
                               
  HasThisBinding()             Determine if an environment record establishes a THIS binding. Return TRUE if it does and FALSE if it does not.
  HasSuperBinding()            Determine if an environment record establishes a SUPER method binding. Return TRUE if it does and FALSE if it does not.
  WithBaseObject ()            If this environment record is associated with a WITH statement, return the with object. Otherwise, return UNDEFINED.

Each declarative environment record is associated with an ECMAScript
program scope containing variable, constant, let, class, module, import,
and/or function declarations. A declarative environment record binds the
set of identifiers defined by the declarations contained within its
scope.

The behaviour of the concrete specification methods for Declarative
Environment Records is defined by the following algorithms.

The concrete environment record method HasBinding for declarative
environment records simply determines if the argument identifier is one
of the identifiers bound by the record:

The concrete Environment Record method CreateMutableBinding for
declarative environment records creates a new mutable binding for the
name N that is uninitialised. A binding must not already exist in this
Environment Record for N. If Boolean argument D is provided and has
the value TRUE the new binding is marked as being subject to deletion.

The concrete Environment Record method CreateImmutableBinding for
declarative environment records creates a new immutable binding for the
name N that is uninitialised. A binding must not already exist in this
environment record for N.

The concrete Environment Record method InitializeBinding for declarative
environment records is used to set the bound value of the current
binding of the identifier whose name is the value of the argument N to
the value of argument V. An uninitialised binding for N must already
exist.

The concrete Environment Record method SetMutableBinding for declarative
environment records attempts to change the bound value of the current
binding of the identifier whose name is the value of the argument N to
the value of argument V. A binding for N must already exist. If the
binding is an immutable binding, a TYPEERROR is thrown if S is TRUE.

The concrete Environment Record method GetBindingValue for declarative
environment records simply returns the value of its bound identifier
whose name is the value of the argument N. The binding must already
exist. If S is TRUE and the binding is an uninitialised immutable
binding throw a REFERENCEERROR exception.

The concrete Environment Record method DeleteBinding for declarative
environment records can only delete bindings that have been explicitly
designated as being subject to deletion.

Regular Declarative Environment Records do not provide a THIS binding.

1.  Return FALSE.

Regular Declarative Environment Records do not provide a SUPER binding.

1.  Return FALSE.

Declarative Environment Records always return UNDEFINED as their
WithBaseObject.

Each object environment record is associated with an object called its
_binding object_. An object environment record binds the set of
identifier names that directly correspond to the property names of its
binding object. Property names that are not an IdentifierName are not
included in the set of bound identifiers. Both own and inherited
properties are included in the set regardless of the setting of their
[[Enumerable]] attribute. Because properties can be dynamically added
and deleted from objects, the set of identifiers bound by an object
environment record may potentially change as a side-effect of any
operation that adds or deletes properties. Any bindings that are created
as a result of such a side-effect are considered to be a mutable binding
even if the Writable attribute of the corresponding property has the
value FALSE. Immutable bindings do not exist for object environment
records.

Object environment records created for WITH statements (12.10) can
provide their binding object as an implicit this value for use in
function calls. The capability is controlled by a withEnvironment
Boolean value that is associated with each object environment record. By
default, the value of withEnvironment is FALSE for any object
environment record.

The behaviour of the concrete specification methods for Object
Environment Records is defined by the following algorithms.

The concrete Environment Record method HasBinding for object environment
records determines if its associated binding object has a property whose
name is the value of the argument N:

The concrete Environment Record method CreateMutableBinding for object
environment records creates in an environment record’s associated
binding object a property whose name is the String value and initialises
it to the value UNDEFINED. A property named N must not already exist
in the binding object. If Boolean argument D is provided and has the
value TRUE the new property’s [[Configurable]] attribute is set to TRUE,
otherwise it is set to FALSE.

The concrete Environment Record method CreateImmutableBinding is never
used within this specification in association with Object environment
records.

The concrete Environment Record method InitializeBinding for object
environment records is used to set the bound value of the current
binding of the identifier whose name is the value of the argument N to
the value of argument V. An uninitialised binding for N must already
exist.

1.  Let envRec be the object environment record for which the method
    was invoked.

2.  Assert: envRec must have an uninitialised binding for N.

3.  Record that the binding for N in envRec has been initialised.

4.  Call the SetMutableBinding concrete method of envRec with N,
    V, and FALSE as arguments.

The concrete Environment Record method SetMutableBinding for object
environment records attempts to set the value of the environment
record’s associated binding object’s property whose name is the value of
the argument N to the value of argument V. A property named N
normally already exists but if it does not or is not currently writable,
error handling is determined by the value of the Boolean argument S.

1.  Let envRec be the object environment record for which the method
    was invoked.

2.  Let bindings be the binding object for envRec.

3.  Return the result of calling the [[Put]] internal method of
    bindings with arguments N, V, and S.

The concrete Environment Record method GetBindingValue for object
environment records returns the value of its associated binding object’s
property whose name is the String value of the argument identifier N.
The property should already exist but if it does not the result depends
upon the value of the S argument:

The concrete Environment Record method DeleteBinding for object
environment records can only delete bindings that correspond to
properties of the environment object whose [[Configurable]] attribute
have the value TRUE.

Regular Object Environment Records do not provide a THIS binding.

1.  Return FALSE.

Regular Object Environment Records do not provide a SUPER binding.

1.  Return FALSE.

Object Environment Records return UNDEFINED as their WithBaseObject
unless their withEnvironment flag is TRUE.

A function environment record is a declarative environment record that
is used to represent the outer most scope of a function that provides a
THIS binding. In addition to its identifier bindings, a function
environment record contains the THIS value used within its scope. If
such a function references SUPER, its function environment record also
contains the state that is used to perform SUPER method invocations from
within the function.

Function environment records store their THIS binding as the value of
their thisValue. If the associated function references SUPER, the
environment record stores in HomeObject the object that the function
is bound to as a method and in MethodName the property key used for
unqualified super invocations from within the function. The default
value for HomeObject and MethodName is UNDEFINED.

Methods environment records support all of Declarative Environment
Record methods listed in Table 19 and share the same specifications for
all of those methods except for HasThisBinding and HasSuperBinding. In
addition, declarative environment records support the methods listed in
Table 20:

Table 20 — Additional Methods of Function Environment Records

  METHOD           PURPOSE
  ------------------ --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  GetThisBinding()   Return the value of this environment record’s THIS binding.
  GetSuperBase()     Return the object that is the base for SUPER property accesses bound in this environment record. The object is derived from this environment record’s HomeObject binding. If the value is Empty, return UNDEFINED.
  GetMethodName()    Return the value of this environment record’s MethodName binding.

The behaviour of the additional concrete specification methods for
Function Environment Records is defined by the following algorithms:

Function Environment Records always provide a THIS binding.

1.  Return TRUE.

1.  If this environment record’s HomeObject has the value Empty, then
    return FALSE. Otherwise, return TRUE.

1.  Return the value of this environment record’s thisValue.

1.  Let home be the value of this environment record’s HomeObject.

2.  If home has the value Empty, then return UNDEFINED.

3.  Assert Type(home) is Object.

4.  Return the value of home’s [[Prototype]] internal property..

1.  Return the value of this environment record’s MethodName.

A global environment record is used to represent the outer most scope
that is shared by all of the ECMAScript Script elements that are
processed in a common Realm (10.3). A global environment provides the
bindings for built-in globals (15.1), properties of the global object,
and for all declarations that are not function code and that occur
within Script productions.

A global environment record is logically a single record but it is
specified as a composit encapsulating an object environment record and a
declarative environment record. The object environment record has as its
base object the global object of the associated Realm. This global
object is also the value of the global environment record’s thisValue.
The object environment record component of a global environment record
contains the bindings for all built-in globals (15.1) and all bindings
introduced by a FunctionDeclaration or VarStatement contained in
global code. The bindings for all other ECMAScript declarations in
global code are contained in the declarative environment record
component of the global environment record.

Properties may be created directly on a global object. Hence, the object
environment record component of a global environment record may contain
both bindings created explicitly by FunctionDeclaration or
VarStatement declarations and binding created implicitly as properties
of the global object. In order to identify which bindings were
explicitly created using declarations, a global environment record
maintains a list of the names bound using its CreateGlobalVarBindings
and CreateGlobalFunctionBindings concrete methods.

Global environment records have the additional state components listed
in Table 22 and the additional methods listed in Table 23.

Table 22 -- Components of Global Environment Records

  COMPONENT              PURPOSE
  ------------------------ -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ObjectEnviornment        A Object Environment Record whose base object is the global object. Contains global built-in bindings as well as bindings for FunctionDeclaration or VarStatement declarations in global code for the associated Realm.
  DeclarativeEnvironment   A Declarative Environment Record that contains bindings for all declarations in global for the associated Realm code except for FunctionDeclaration and VarStatement declarations.
  VarNames                 A List containing the string names bound by FunctionDeclaration or VarStatement declarations in global code for the associated Realm.

Table 23 — Additional Methods of Global Environment Records

  METHOD                               PURPOSE
  -------------------------------------- ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  GetThisBinding()                       Return the value of this environment record’s THIS binding.
  HasVarDeclaration (N)                  Determines if the argument identifier has a binding in this environment record that was created using a VariableStatement or a FunctionDeclaration.
  HasLexicalDeclaration (N)              Determines if the argument identifier has a binding in this environment record that was created using a lexical declaration such as a LexicalDeclaration or a ClassDeclaration:
  CanDeclareGlobalVar (N)                Determines if a corresponding CreateGlobalVarBinding call would succeed if called for the same argument N.
  CanDeclareGlobalFunction (N)           Determines if a corresponding CreateGlobalFunctionBinding call would succeed if called for the same argument N.
  CreateGlobalVarBinding(N, D)           Used to create global VAR bindings in the ObjectEnviornmentComponent of the environment record. The binding will be a mutable binding. The corresponding global object property will have attribute values approate for a VAR. The String value N is the text of the bound name. V is the initial value of the binding If the optional Boolean argument D is TRUE the binding is may be subsequently deleted. This is logically equivalent to CreateMutableBinding but it allows var declarations to receive special treatment.
  CreateGlobalFunctionBinding(N, V, D)   Used to create and initialize global FUNCTION bindings in the ObjectEnviornmentComponent of the environment record. The binding will be a mutable binding. The corresponding global object property will have attribute values approate for a FUNCTION.The String value N is the text of the bound name. If the optional Boolean argument D is TRUE the binding is may be subsequently deleted. This is logically equivalent to CreateMutableBinding followed by a SetMutableBinding but it allows function declarations to receive special treatment.
                                         

The behaviour of the concrete specification methods for Global
Environment Records is defined by the following algorithms.

The concrete environment record method HasBinding for global environment
records simply determines if the argument identifier is one of the
identifiers bound by the record:

1.  Let envRec be the global environment record for which the method
    was invoked.

2.  Let DclRec be envRec’s DeclarativeEnvironment.

3.  If the result of calling DclRec’s HasBinding concrete method with
    argumentn N is TRUE, return TRUE.

4.  Let ObjRec be envRec’s ObjectEnvironment.

5.  Return the result of calling ObjRec’s HasBinding concrete method
    with argumentn N.

The concrete environment record method CreateMutableBinding for global
environment records creates a new mutable binding for the name N that
is uninitialised. The binding is created in the associated
DeclarativeEnvironment. A binding for N must not already exist in the
DeclarativeEnviornment. If Boolean argument D is provided and has the
value TRUE the new binding is marked as being subject to deletion.

1.  Let envRec be the global environment record for which the method
    was invoked.

2.  Let DclRec be envRec’s DeclarativeEnvironment.

3.  Assert: DclRec does not already have a binding for N.

4.  Create a mutable binding in DclRec for N and and record that it
    is uninitialised. If D is true record that the newly created
    binding may be deleted by a subsequent DeleteBinding call.

5.  Return NormalCompletion(empty)

The concrete Environment Record method CreateImmutableBinding for
declarative environment records creates a new immutable binding for the
name N that is uninitialised. A binding must not already exist in this
environment record for N.

The concrete Environment Record method InitializeBinding for global
environment records is used to set the bound value of the current
binding of the identifier whose name is the value of the argument N to
the value of argument V. An uninitialised binding for N must already
exist.

1.  Let envRec be the global environment record for which the method
    was invoked.

2.  Let DclRec be envRec’s DeclarativeEnvironment.

3.  If the result of calling DclRec’s HasBinding concrete method with
    argumentn N is TRUE, then

    a.  Return the result of calling the InitializeBinding concrete
        method with arguments N and V.

4.  Let ObjRec be envRec’s DeclarativeEnvironment.

5.  If the result of calling ObjRec HasBinding concrete method with
    argumentn N is TRUE, then

6.  Set the bound value for N in envRec to V.

7.  Record that the binding for N in envRec has been initialised.

The concrete Environment Record method SetMutableBinding for global
environment records attempts to change the bound value of the current
binding of the identifier whose name is the value of the argument N to
the value of argument V. If the binding is an immutable binding, a
TYPEERROR is thrown if S is TRUE. A property named N normally already
exists but if it does not or is not currently writable, error handling
is determined by the value of the Boolean argument S.

1.  Let envRec be the declarative environment record for which the
    method was invoked.

2.  Let DclRec be envRec’s DeclarativeEnvironment.

3.  If the result of calling DclRec’s HasBinding concrete method with
    argumentn N is TRUE, then

    a.  Return the result of calling the SetMutableBinding concrete
        method of DclRec with arguments N, V, and S.

4.  Let ObjRec be envRec’s DeclarativeEnvironment.

5.  Return the result of calling the SetMutableBinding concrete method
    of ObjRec with arguments N, V, and S.

The concrete Environment Record method GetBindingValue for global
environment records simply returns the value of its bound identifier
whose name is the value of the argument N. If S is TRUE and the
binding is an uninitialised binding throw a REFERENCEERROR exception. A
property named N normally already exists but if it does not or is not
currently writable, error handling is determined by the value of the
Boolean argument S.

1.  Let envRec be the declarative environment record for which the
    method was invoked.

2.  Let DclRec be envRec’s DeclarativeEnvironment.

3.  If the result of calling DclRec’s HasBinding concrete method with
    argumentn N is TRUE, then

    a.  Return the result of calling the GetBindingValue concrete method
        of DclRec with arguments N, V, and S.

4.  Let ObjRec be envRec’s DeclarativeEnvironment.

5.  Return the result of calling the GetBindingValue concrete method of
    ObjRec with arguments N, V, and S.

The concrete Environment Record method DeleteBinding for global
environment records can only delete bindings that have been explicitly
designated as being subject to deletion.

1.  Let envRec be the declarative environment record for which the
    method was invoked.

2.  Let DclRec be envRec’s DeclarativeEnvironment.

3.  If the result of calling DclRec’s HasBinding concrete method with
    argumentn N is TRUE, then

    a.  Return the result of calling the DeleteBinding concrete method
        of DclRec with argument N.

4.  Let ObjRec be envRec’s ObjectEnvironment.

5.  If the result of calling ObjRec HasBinding concrete method with
    argumentn N is TRUE, then

    a.  Let status result of calling the DeleteBinding concrete method
        of DclRec with argument N.

    b.  ReturnIfAbrupt(status).

    c.  If status is TRUE, then

        i.  Let varNames be envRec’s VarNames List.

        ii. If N is an element of varNames, then remove that element
            from the varNames.

    d.  Return status.

6.  Return TRUE.

Global Environment Records always provide a THIS binding whose value is
the associated global object.

1.  Return TRUE.

1.  Return FALSE.

Global Environment Records always return UNDEFINED as their
WithBaseObject.

1.  Return UNDEFINED.

1.  Let envRec be the global environment record for which the method
    was invoked.

2.  Let ObjRec be envRec’s ObjectEnvironment.

3.  Let bindings be the binding object for ObjRec.

4.  Return bindings.

The concrete environment record method HasVarDeclaration for global
environment records determines if the argument identifier has a binding
in this record that was created using a VariableStatement or a
FunctionDeclaration:

1.  Let envRec be the global environment record for which the method
    was invoked.

2.  Let varDeclaredNames be envRec’s VarNames List.

3.  If varDeclaredNames contains the value of N, return TRUE.

4.  Return FALSE.

The concrete environment record method HasLexicalDeclaration for global
environment records determines if the argument identifier has a binding
in this record that was created using a lexical declaration such as a
LexicalDeclaration or a ClassDeclaration:

1.  Let envRec be the global environment record for which the method
    was invoked.

2.  Let DclRec be envRec’s DeclarativeEnvironment.

3.  Return the result of calling DclRec’s HasBinding concrete method
    with argument N.

The concrete environment record method CanDeclareGlobalVar for global
environment records determines if a corresponding CreateGlobalVarBinding
call would succeed if called for the same argument N. Redundent var
declarations and var declarations for pre-existing global object
properties are allowed.

1.  Let envRec be the global environment record for which the method
    was invoked.

2.  Let ObjRec be envRec’s ObjectEnvironment.

3.  If the result of calling ObjRec’s HasBinding concrete method with
    argument N is TRUE, return TRUE.

4.  Let bindings be the binding object for ObjRec.

5.  If the [[Extensible]] internal property of bindings is TRUE,
    return TRUE.

6.  Return FALSE.

The concrete environment record method CanDeclareGlobalVar for global
environment records determines if a corresponding
CreateGlobalFunctionBinding call would succeed if called for the same
argument N.

1.  Let envRec be the global environment record for which the method
    was invoked.

2.  Let ObjRec be envRec’s ObjectEnvironment.

3.  Let globalObject be the binding object for ObjRec.

4.  Let extensible be the value of the [[Extensible]] internal
    property of globalObject.

5.  If the result of calling ObjRec’s HasBinding concrete method with
    argument N is FALSE, then return extensible.

6.  Let existingProp be the result of calling the [[GetOwnProperty]]
    internal method of globalObject with argument N.

7.  If existingProp is UNDEFINED, then return extensible.

8.  If existingProp.[[Configurable]] is TRUE, then return TRUE.

9.  If IsDataDescriptor(existingProp) is TRUE and existingProp has
    attribute values {[[Writable]]: TRUE, [[Enumerable]]: TRUE}, then
    return TRUE.

10. Return FALSE.

The concrete Environment Record method CreateVarBinding for global
environment records creates a mutable binding in the associated object
environment record and records the bound name in the associated VarNames
List. If a binding already exists, it is reused.

1.  Let envRec be the declarative environment record for which the
    method was invoked.

2.  Let ObjRec be envRec’s ObjectEnvironment.

3.  Assert: The result of calling envRec’s CanDeclareGlobalVar
    concrete method with argumentn N is TRUE.

4.  If the result of calling ObjRec HasBinding concrete method with
    argument N is FALSE, then

    a.  Call the CreateMutableBinding concrete method of ObjRec with
        arguments N and D.

5.  Let varDeclaredNames be envRec’s VarNames List.

6.  If varDeclaredNames does not contains the value of N, then

    a.  Append N to varDeclaredNames.

7.  Return.

The concrete Environment Record method CreateFunctionBinding for global
environment records creates a mutable binding in the associated object
environment record and records the bound name in the associated VarNames
List. If a binding already exists, it is replaced.

1.  Let envRec be the declarative environment record for which the
    method was invoked.

2.  Let ObjRec be envRec’s ObjectEnvironment.

3.  Assert: The result of calling envRec’s CanDeclareGlobalFunction
    concrete method with argumentn N is TRUE.

4.  Let globalObject be the binding object for ObjRec.

5.  Let existingProp be the result of calling the [[GetOwnProperty]]
    internal method of globalObject with argument N.

6.  If existingProp is UNDEFINED or existingProp.[[Configurable]] is
    TRUE, then

    a.  Call the [[DefineOwnProperty]] internal method of
        globalObject, passing N, Property Descriptor {[[Value]]:V,
        [[Writable]]: TRUE, [[Enumerable]]: TRUE , [[Configurable]]:
        D}, and FALSE as arguments.

7.  Else,

    a.  Call the [[DefineOwnProperty]] internal method of
        globalObject, passing N, Property Descriptor {[[Value]]:V
        }, and FALSE as arguments.

8.  NOTE The assertion in step 3 means that the above
    [[DefineOwnProperty]] calls will never return an abrupt completion.

9.  Let varDeclaredNames be envRec’s VarNames List.

10. If varDeclaredNames does not contains the value of N, then

    a.  Append N to varDeclaredNames.

11. Return.

NOTE Global unction declarations are always represented as a own
property of the global object. If possible, an existing own property is
reconfigured to have a standard set of attribute values.

The following abstract operations are used in this specification to
operate upon lexical environments:

The abstract operation GetIdentifierReference is called with a Lexical
Environment lex, a String name, and a Boolean flag strict. The
value of lex may be NULL. When called, the following steps are
performed:

When the abstract operation NewDeclarativeEnvironment is called with
either a Lexical Environment or NULL as argument E the following steps
are performed:

When the abstract operation NewObjectEnvironment is called with an
Object O and a Lexical Environment E (or NULL) as arguments, the
following steps are performed:

When the abstract operation NewFunctionEnvironment is called with an
ECMAScript function Object F and a ECMAScript value T as arguments,
the following steps are performed:

1.  Let env be a new Lexical Environment.

2.  Let envRec be a new Function environment record containing
    containing no bindings.

3.  Set envRec’s thisValue to T.

4.  If F has a [[HomeObject]] internal property, then

    a.  Set envRec’s HomeObject to the value of F’s [[HomeObject]]
        internal property.

    b.  Set envRec’s MethodName to the value of F’s [[MethodName]]
        internal property.

5.  Else,

    a.  Set envRec’s HomeObject to Empty.

6.  Set env’s environment record to be envRec.

7.  Set the outer lexical environment reference of env to the value of
    F’s [[Scope]] internal property.

8.  Return env.

Before it is evaluated, all ECMAScript code must be associated with a
Realm. Conceptually, a realm consists as of an set of intrinsic
objects, an ECMAScript global environment, all of the ECMAScript code
that is loaded within the scope of that global environment, a Loader
object that can associate new ECMAScript code with the realm, and other
associated state and resources.

A Realm is specified as a Record with the fields specified in Table 24:

Table 24 — Realm Record Fields

  ---------------- ---------------------------------------------------------------------------- ------------------------------------------------------------------------
  _FIELD NAME_     VALUE                                                                      MEANING
  [[intrinsics]]   A record whose field names are intrinsic keys and whose values are objects   These are the intrinsic values used by code associated with this Realm
  [[this]]         An ECMAScript object                                                         The global object for this Realm
  [[globalEnv]]    A ECMAScript environment                                                     The global environment for this Realm
  [[loader]]       any ECMAScript identifier or EMPTY                                           The Loader object that can associate ECMAScript code with this Realm
  ---------------- ---------------------------------------------------------------------------- ------------------------------------------------------------------------

An _execution context_ is a specification device that is used to track
the runtime evaluation of code by an ECMAScript implementation. At any
point in time, there is at most one execution context that is actually
executing code. This is known as the running execution context. A
stack is used to track execution contexts. The running execution context
is always the top element of this stack. A new execution context is
created whenever control is transferred from the executable code
associated with the currently running execution context to executable
code that is not associated with that execution context. The newly
created execution context is pushed onto the stack and becomes the
running execution context.

An execution context contains whatever implementation specific state is
necessary to track the execution progress of its associated code. Each
execution context has the state components listed in Table 23 .

Table 25 —State Components for All Execution Contexts

  COMPONENT             PURPOSE
  ----------------------- -----------------------------------------------------------------------------------------------------------------
  code evaluation state   Any state needed to perform, suspend, and resume evaluation of the code associated with this execution context.
                          
  Realm                   The Realm from which associated code accesses ECMAScript resources.
                          
                          
                          

Evaluation of code by the running execution context may be suspended at
various points defined within this specification. Once the running
execution context has been suspended a different execution context may
become the running execution context and commence evaluating its code.
At some latter time a suspended execution context may again become the
running execution context and continue evaluating its code at the point
where it had previously been suspended. Transition of the running
execution context status among execution contexts usually occurs in
stack-like last-in/first-out manner. However, some ECMAScript features
require non-LIFO transitions of the running execution context.

Execution contexts for ECMAScript code have the additional state
components listed in Table 24.

Table 26 —Additional State Components for ECMAScript Code Execution
Contexts

  COMPONENT           PURPOSE
  --------------------- -------------------------------------------------------------------------------------------------------------------------------------------
  LexicalEnvironment    Identifies the Lexical Environment used to resolve identifier references made by code within this execution context.
  VariableEnvironment   Identifies the Lexical Environment whose environment record holds bindings created by VariableStatements within this execution context.

The LexicalEnvironment and VariableEnvironment components of an
execution context are always Lexical Environments. When an execution
context is created its LexicalEnvironment and VariableEnvironment
components initially have the same value. The value of the
VariableEnvironment component never changes while the value of the
LexicalEnvironment component may change during execution of code within
an execution context.

In most situations only the running execution context (the top of the
execution context stack) is directly manipulated by algorithms within
this specification. Hence when the terms “LexicalEnvironment”, and
“VariableEnvironment” are used without qualification they are in
reference to those components of the running execution context.

An execution context is purely a specification mechanism and need not
correspond to any particular artefact of an ECMAScript implementation.
It is impossible for an ECMAScript program to directly access or observe
an execution context.

Identifier resolution is the process of determining the binding of an
IdentifierName using the LexicalEnvironment of the running execution
context. During execution of ECMAScript code, Identifier Resolution is
performed using the following algorithm:

The result of evaluating an identifier is always a value of type
Reference with its referenced name component equal to the Identifier
String.

The abstract operation GetThisEnviroment finds the lexical environment
that currently supplies the binding of the keyword THIS.
GetThisEnviroment performs the following steps:

1.  Let lex be the running execution context’s LexicalEnvironment.

2.  Repeat

    a.  Let envRec be lex’s environment record.

    b.  Let exists be the result of calling the HasThisBinding
        concrete method of envRec.

    c.  If exists is TRUE, then return envRec.

    d.  Let outer be the value of lex’s outer environment reference.

    e.  Let lex be outer.

NOTE The loop in step 4 will always terminate because the llst of
environment always end with the global environment which has a THIS
binding.

The abstract operation ThisResolution is the process of determining the
binding of the keyword THIS using the LexicalEnvironment of the running
execution context. ThisResolution performs the following steps:

1.  Let env be the result of performing the GetThisEnvironment
    abstract operation.

2.  Return the result of calling the GetThisBinding concrete method of
    env.

NOTE When an execution context is established for evaluating scripts,
declarations are instantiated in the current global environment. Each
global binding declarated in the code is instantiated.

Global Declaration Instantiation is performed as follows using arguments
script, env, and deletableBindings. script is the ScriptBody
that for which the execution context is being established. env is the
global environment record in which bindings are to be created.
deletableBindings is true if the bindings that are created should be
deletable.

NOTE Early errors specified in 14.1 prevent name conflicts between
function/var declarations and let/const/class/module declarations as
well as redeclaration of let/const/class/module bindings for declaration
contained within a single Script. However, such conflicts and
redeclarations that span more than one Script are detected as runtime
errors during Global Declaration Instantiation. If any such errors are
detected, no bindings are instantiated for the script.

Unlike explicit var or function declarations, properties that are
directly created on the global object result in global bindings that may
be shadowed by let, const, class, and module declarations.

10.5.3 Function Declaration Instantiation

This version reflects the concensus as of the Sept. 2012 TC39 meeting.
However, it now appears that the binding semantics of formal parameters
is like to change again.

NOTE When an execution context is established for evaluating function
code a new Declarative Environment Record is created and bindings for
each formal parameter, and each function level variable, constant, or
function declarated in the function are instantiated in the environment
record. Formal parameters and functions are initialized as part of this
process. All other bindings are initialized during execution of the
function code.

Function Declaration Instantiation is performed as follows using
arguments func, argumentsList, and env. func is the function
object that for which the execution context is being established. env
is the declarative environment record in which bindings are to be
created.

1.  Let code be the value of the [[Code]] internal property of func.

2.  Let strict be the value of the [[Strict]] internal property of
    func.

3.  Let formals be the value of the [[FormalParameters]] internal
    property of func.

4.  Let parameterNames be the BoundNames of formals.

5.  Let varDeclarations be the VarScopedDeclarations of code.

6.  Let functionsToInitialize be an emptyList.

7.  Let argumentsObjectNotNeeded be FALSE.

8.  For each d in varDeclarations, in reverse list order do

    a.  If d is a FunctionDeclaration then

        i.  NOTE If there are multiple FunctionDeclarations for the
            same name, the last declaration is used.

        ii. Let fn be the sole element of the BoundNames of d.

        iii. If fn is "ARGUMENTS", then let argumentsObjectNotNeeded
            be TRUE.

        iv. Let alreadyDeclared be the result of calling env’s
            HasBinding concrete method passing fn as the argument.

        v.  If alreadyDeclared is FALSE, then

            1.  Let status be the result of calling env’s
                CreateMutableBinding concrete method passing fn as the
                argument.

            2.  Assert: status is never an Abrupt Completion.

            3.  Append d to functionsToInitialize.

9.  For each String paramName in parameterNames, do

    a.  Let alreadyDeclared be the result of calling env’s
        HasBinding concrete method passing paramName as the argument.

    b.  NOTE Duplicate parameter names can only occur in non-strict
        functions. Parameter names that are the same as function
        declaration names do not get initialized to UNDEFINED.

    c.  If alreadyDeclared is FALSE, then

        i.  If paramName is "ARGUMENTS", then let
            argumentsObjectNotNeeded be TRUE.

        ii. Let status be the result of calling env’s
            CreateMutableBinding concrete method passing paramName as
            the argument.

        iii. Assert: status is never an Abrupt Completion

        iv. v.  Call env’s InitializeBinding concrete method passing
            paramName, and UNDEFINED as the arguments.

10. NOTE If there is a function declaration or formal parameter with the
    name "ARGUMENTS" then an argument object is not created.

11. If argumentsObjectNotNeeded is FALSE, then

    a.  If strict is TRUE, then

        i.  Call env’s CreateImmutableBinding concrete method passing
            the String "ARGUMENTS" as the argument.

    b.  Else,

        i.  Call env’s CreateMutableBinding concrete method passing
            the String "ARGUMENTS" as the argument.

12. Let varNames be the VarDeclaredNames of code.

13. For each String varName in varNames, in list order do

    a.  Let alreadyDeclared be the result of calling env’s
        HasBinding concrete method passing varName as the argument.

    b.  NOTE A VarDeclaredNames is only instantiated and initialied here
        if it is not also the name of a formal parameter or a
        FunctionDeclarations.

    c.  If alreadyDeclared is FALSE, then

        i.  Call env’s CreateMutableBinding concrete method passing
            varName as the argument.

14. Let lexDeclarations be the LexicalDeclarations of code.

15. For each element d in lexDeclarations do

    a.  NOTE A lexically declared name can not be the same as a function
        declaration, formal parameter, or a var name. Lexically
        declarated names are only instantiated here but not initialized.

    b.  For each element dn of the BoundNames of d do

        i.  If IsConstantDeclaration of d is TRUE, then

            1.  Call env’s CreateImmutableBinding concrete method
                passing dn as the argument.

        ii. Else,

            1.  Call env’s CreateMutableBinding concrete method
                passing dn and FALSE as the arguments.

16. For each FunctionDeclaration f in functionsToInitialize, do

    a.  Let fn be the sole element of the BoundNames of f.

    b.  Let fo be the result of performing InstantiateFunctionObject
        for f with argument env.

    c.  Call env’s SetMutableMinding concrete method passing fn,
        fo, and FALSE as the arguments.

17. NOTE Function declaration are initialised prior to parameter
    initialisation so that default value expressions may reference them.
    it is not extended code. "ARGUMENTS" is not initialized until after
    parameter initialization.

18. Let ao be the result of InstantiateArgumentsObject with argument
    argumentsList.

19. 20. a.  b.  

21. a.  b.  c.  d.  

22. 23. 24. a.  i.  ii. 1.  a.  

            2.  a.  

25. 26. NOTE If argumentsObjectNotNeeded is TRUE then the value of
    ao is not directly observable to ECMAScript code and need not
    actually exist. In that case, its use in the above steps is strictly
    as a device for specifying formal parameter initialisation
    semantics.

27. Let formalStatus be the result of performing Binding
    Initialisation for formals with ao and UNDEFINED as arguments.

28. ReturnIfAbrupt(formalStatus).

29. 30. If argumentsObjectNotNeeded is FALSE, then

    a.  If strict is TRUE, then

        i.  Perform the abstract operation CompleteStrictArgumentsObject
            with argument a0.

        ii. 

    b.  Else,

        i.  Perform the abstract operation CompleteMappedArgumentsObject
            with arguments _a0, func_, formals, and env.

        ii. 

    c.  Call env’s InitializeBinding concrete method passing
        "ARGUMENTS" and ao as arguments.

31. 32. a.  b.  c.  i.  ii. 

33. 34. a.  b.  c.  i.  ii. iii. 

35. Return NormalCompletion(empty)..

NOTE When a Block or CaseBlock production is evaluated a new
Declarative Environment Record is created and bindings for each block
scoped variable, constant, or function declarated in the block are
instantiated in the environment record.

Block Declaration Instantiation is performed as follows using arguments
code and env. code is the grammar production corresponding to the
body of the block. env is the declarative environment record in which
bindings are to be created.

1.  2.  Let declarations be the LexicalDeclarations of code.

3.  For each element d in declarations do

    a.  For each element dn of the BoundNames of d do

        i.  If IsConstantDeclaration of d is TRUE, then

            1.  Call env’s CreateImmutableBinding concrete method
                passing dn as the argument.

        ii. Else,

            1.  Call env’s CreateMutableBinding concrete method
                passing dn and FALSE as the arguments.

4.  For each FunctionDeclaration f in declarations, in list order
    do

    a.  Let fn be the sole element of the BoundNames of f.

    b.  Let fo be the result of performing InstantiateFunctionObject
        for f with argument env.

    c.  d.  Call env’s InitializeBinding concrete method passing fn,
        and fo as the arguments.

    e.  

When function code is evaluated, an arguments object is created unless
(as specified in 10.5) the identifier ARGUMENTS occurs as an
Identifier in the function’s FormalParameterList or occurs as the
BindingIdentifier of a FunctionDeclaration contained in the
outermost StatementList of the function code.

The abstract operation InstantiateArgumentsObject called with an
argument args performs the following steps:

The abstract operation CompleteStrictArgumentsObject called with
argument obj which must have been previous created by the abstraction
operation InstantiateArgumentsObject. The following steps are performed:

1.  2.  3.  4.  a.  b.  c.  

5.  6.  Perform the AddRestrictedFunctionProperties abstract operator
    with argument obj.

7.  8.  9.  Return.

The abstract operation CompleteMappedArgumentsObject is called with
object obj, object func, grammar production formals, and
environment record env. obj must have been previous created by the
abstraction operation InstantiateArgumentsObject.The following steps are
performed:

1.  Let len be the result of calling the [[Get]] internal method of
    obj with argument "LENGTH"..

2.  3.  4.  5.  Let mappedNames be an empty List.

6.  Let numberOfNonRestFormals be NumberOfParameters of formals.

7.  Let map be the result of the abstract operation ObjectCreate.

8.  Let indx = len - 1.

9.  Repeat while indx ≥ 0,

    a.  b.  c.  If indx is less than the numberOfNonRestFormals,
        then

        i.  Let param be getParameter of formals with argument
            indx.

        ii. If param is BindingIdentifier, then

            1.  Let name be the sole element of BoundNames of param.

            2.  If name is not an element of mappedNames, then

                a.  Add name as an element of the list mappedNames.

                b.  Let g be the result of calling the MakeArgGetter
                    abstract operation with arguments name and env.

                c.  Let p be the result of calling the MakeArgSetter
                    abstract operation with arguments name and env.

                d.  Call the [[DefineOwnProperty]] internal method of
                    map passing ToString(indx), the Property
                    Descriptor {[[Set]]: p, [[Get]]: g,
                    [[Configurable]]: TRUE}, and FALSE as arguments.

    d.  Let indx = indx - 1

10. If mappedNames is not empty, then

    a.  Set the [[ParameterMap]] internal property of obj to map.

    b.  Set the [[Get]], [[GetOwnProperty]], [[DefineOwnProperty]], and
        [[Delete]] internal methods of obj to the definitions provided
        below.

11. Call the [[DefineOwnProperty]] internal method on obj passing
    "CALLEE", the Property Descriptor {[[Value]]: func, [[Writable]]:
    TRUE, [[Enumerable]]: FALSE, [[Configurable]]: TRUE}, and FALSE as
    arguments.

12. Return obj

The abstract operation MakeArgGetter called with String name and
environment record env creates a function object that when executed
returns the value bound for name in env. It performs the following
steps:

1.  Let bodyText be the result of concatenating the Strings "RETURN ",
    name, and ";".

2.  Let body be the result of parsing bodyText using FunctionBody
    as the goal symbol.

3.  Let parameters be a FormalParameterList : [empty] production.

4.  Return the result of calling the abstract operation FunctionCreate
    using Normal as the kind, parameters as FormalParameterList,
    body for FunctionBody, env as Scope, and TRUE for Strict.

The abstract operation MakeArgSetter called with String name and
environment record env creates a function object that when executed
sets the value bound for name in env. It performs the following
steps:

The [[Get]] internal method of an arguments object for a non-strict mode
function with formal parameters when called with a property name P
performs the following steps:

The [[GetOwnProperty]] internal method of an arguments object for a
non-strict mode function with formal parameters when called with a
property name P performs the following steps:

The [[DefineOwnProperty]] internal method of an arguments object for a
non-strict mode function with formal parameters when called with a
property name P, Property Descriptor Desc, and Boolean flag Throw
performs the following steps:

1.  Let map be the value of the [[ParameterMap]] internal property of
    the arguments object.

2.  Let isMapped be the result of calling the [[GetOwnProperty]]
    internal method of map passing P as the argument.

3.  Let allowed be the result of calling the default
    [[DefineOwnProperty]] internal method (8.12.9) on the arguments
    object passing P, Desc, and FALSE as the arguments.

4.  If allowed is FALSE, then

    a.  If Throw is TRUE then throw a TYPEERROR exception, otherwise
        return FALSE.

5.  If the value of isMapped is not UNDEFINED, then

    a.  If IsAccessorDescriptor(Desc) is TRUE, then

        i.  Call the [[Delete]] internal method of map passing P,
            and FALSE as the arguments.

    b.  Else

        i.  If Desc.[[Value]] is present, then

            1.  Call the [[Put]] internal method of map passing P,
                Desc.[[Value]], and Throw as the arguments.

        ii. If Desc.[[Writable]] is present and its value is FALSE,
            then

            1.  Call the [[Delete]] internal method of map passing P
                and FALSE as arguments.

6.  Return TRUE.

The [[Delete]] internal method of an arguments object for a non-strict
mode function with formal parameters when called with a property name
P and Boolean flag Throw performs the following steps:

NOTE 1 For non-strict mode functions the array index (defined in 15.4)
named data properties of an arguments object whose numeric name values
are less than the number of formal parameters of the corresponding
function object initially share their values with the corresponding
argument bindings in the function’s execution context. This means that
changing the property changes the corresponding value of the argument
binding and vice-versa. This correspondence is broken if such a property
is deleted and then redefined or if the property is changed into an
accessor property. For strict mode functions, the values of the
arguments object’s properties are simply a copy of the arguments passed
to the function and there is no dynamic linkage between the property
values and the formal parameter values.

NOTE 2 The ParameterMap object and its property values are used as a
device for specifying the arguments object correspondence to argument
bindings. The ParameterMap object and the objects that are the values of
its properties are not directly accessible from ECMAScript code. An
ECMAScript implementation does not need to actually create or use such
objects to implement the specified semantics.

NOTE 3 Arguments objects for strict mode functions define
non-configurable accessor properties named "CALLER" and "CALLEE" which
throw a TYPEERROR exception on access. The "CALLEE" property has a more
specific meaning for non-strict mode functions and a "CALLER" property
has historically been provided as an implementation-defined extension by
some ECMAScript implementations. The strict mode definition of these
properties exists to ensure that neither of them is defined in any other
manner by conforming ECMAScript implementations.

Syntax

PrimaryExpression :

THIS
Identifier
Literal
ArrayInitialiser
ObjectLiteral
FunctionExpression
ClassExpression
GeneratorExpression
GeneratorComprehension
RegularExpressionLiteral
TemplateLiteral
CoverParenthesizedExpressionAndArrowParameterList

CoverParenthesizedExpressionAndArrowParameterList:

( Expression )
( )
( ... Identifier )
( Expression , ... Identifier)

Supplemental Syntax

When processing the production PrimaryExpression :
CoverParenthesizedExpressionAndArrowParameterList the following
grammar is used to refine the interpretation of
CoverParenthesizedExpressionAndArrowParameterList.

ParenthesizedExpression :

( Expression )

STATIC SEMANTICS

-   -   

STATIC SEMANTICS: COVEREDPARENTHESIZEDEXPRESSION

CoverParenthesizedExpressionAndArrowParameterList : ( Expression )

1.  Return the result of parsing the lexical token stream matched by
    CoverParenthesizedExpressionAndArrowParameterList using
    ParenthesizedExpression as the goal symbol.

STATIC SEMANTICS: ISVALIDSIMPLEASSIGNMENTTARGET

PrimaryExpression :

THIS
Literal
ArrayInitialiser
ObjectLiteral
FunctionExpression
ClassExpression
GeneratorExpression
GeneratorComprehension
RegularExpressionLiteral
TemplateLiteral

1.  Return FALSE.

PrimaryExpression : Identifier

1.  If this PrimaryExpression is contained in strict code and
    StringValue of Identifier is "EVAL" or "ARGUMENTS", then return
    FALSE.

2.  Return TRUE.

PrimaryExpression :
CoverParenthesizedExpressionAndArrowParameterList

1.  Let expr be CoveredParenthesizedExpression of
    CoverParenthesizedExpressionAndArrowParameterList.

2.  Return IsValidSimpleAssignmentTarget of expr.

RUNTIME SEMANTICS: EVALUATION

PrimaryExpression : THIS

1.  2.  Return the result of calling the ThisResolution abstract
    operation.

1.  

RUNTIME SEMANTICS: EVALUATION

PrimaryExpression : Identifier

1.  Let ref be the result of performing Identifier Resolution as
    specified in 10.3.1 using the IdentifierName corresponding to
    Identifier.

2.  Return ref.

NOTE: The result of evaluating an Identifier is always a value of type
Reference.

Syntax

Literal :

NullLiteral
ValueLiteral

ValueLiteral :

BooleanLiteral
NumericLiteral
StringLiteral

RUNTIME SEMANTICS

RUNTIME SEMANTICS: EVALUATION

Literal : NullLiteral

1.  Return NULL.

ValueLiteral : BooleanLiteral

1.  Return FALSE if BooleanLiteral is the token BooleanLiteral ::
    FALSE

2.  Return TRUE if BooleanLiteral is the token BooleanLiteral ::
    TRUE

ValueLiteral : NumericLiteral

1.  Return the number whose value is MV of NumericLiteral as defined
    in 7.8.3.

ValueLiteral : StringLiteral

1.  Return the string whose elements are the SV of StringLiteral as
    defined in 7.8.4.

Syntax

ArrayInitialiser :

ArrayLiteral
ArrayComprehension

NOTE An ArrayLiteral is an expression describing the initialisation of
an Array object, using a list, of zero or more expressions each of which
represents an array element, enclosed in square brackets. The elements
need not be literals; they are evaluated each time the array initialiser
is evaluated.

Array elements may be elided at the beginning, middle or end of the
element list. Whenever a comma in the element list is not preceded by an
AssignmentExpression (i.e., a comma at the beginning or after another
comma), the missing array element contributes to the length of the Array
and increases the index of subsequent elements. Elided array elements
are not defined. If an element is elided at the end of an array, that
element does not contribute to the length of the Array.

Syntax

ArrayLiteral :

[ Elision~opt~ ]
[ ElementList ]
[ ElementList , Elision~opt~ ]

ElementList :

Elision~opt~ AssignmentExpression
Elision~opt~ SpreadElement
ElementList , Elision~opt~ AssignmentExpression
ElementList , Elision~opt~ SpreadElement

Elision :

,
Elision ,

SpreadElement :

… AssignmentExpression

STATIC SEMANTICS

-   -   

STATIC SEMANTICS: ELISION WIDTH

1.  

Elision : ,

1.  Return the numeric value 1.

Elision : Elision ,

1.  Let preceding be the Elision Width of Elision.

2.  Return preceding+1.

RUNTIME SEMANTICS

RUNTIME SEMANTICS: ARRAY ACCUMULATION

  With parameters array and nextIndex.

ElementList : Elision~opt~ AssignmentExpression

1.  Let padding be the Elision Width of Elision; if Elision is not
    present, use the numeric value zero.

2.  Let initResult be the result of evaluating AssignmentExpression.

3.  Let initValue be GetValue(initResult).

4.  ReturnIfAbrupt(initValue).

5.  Call the [[DefineOwnProperty]] internal method of array with
    arguments ToString(ToUint32(nextIndex+padding)), the Property
    Descriptor { [[Value]]: initValue, [[Writable]]: TRUE,
    [[Enumerable]]: TRUE, [[Configurable]]: TRUE}, and FALSE.

6.  Return nextIndex+padding+1.

ElementList : Elision~opt~ SpreadElement

1.  Let padding be the Elision Width of Elision; if Elision is not
    present, use the numeric value zero.

2.  Return the result of performing Array Accumulation for
    SpreadElement with arguments array and nextIndex_+_padding.

ElementList : ElementList , Elision~opt~ AssignmentExpression

1.  Let postIndex be the result of performing Array Accumulation for
    ElementList with arguments array and nextIndex.

2.  ReturnIfAbrupt(postIndex).

3.  Let padding be the Elision Width of Elision; if Elision is not
    present, use the numeric value zero.

4.  Let initResult be the result of evaluating AssignmentExpression.

5.  Let initValue be GetValue(initResult).

6.  ReturnIfAbrupt(initValue).

7.  Call the [[DefineOwnProperty]] internal method of array with
    arguments ToString(ToUint32((postIndex_+_padding)) and the
    Property Descriptor { [[Value]]: initValue, [[Writable]]: TRUE,
    [[Enumerable]]: TRUE, [[Configurable]]: TRUE}, and FALSE.

8.  Return postIndex_+_padding+1.

ElementList : ElementList , Elision~opt~ SpreadElement

1.  Let postIndex be the result of performing Array Accumulation for
    ElementList with arguments array and nextIndex.

2.  ReturnIfAbrupt(postIndex).

3.  Let padding be the Elision Width of Elision; if Elision is not
    present, use the numeric value zero.

4.  Return the result of performing Array Accumulation for
    SpreadElement with arguments array and postIndex_+_padding.

SpreadElement : … AssignmentExpression

1.  Let spreadRef be the result of evaluating AssignmentExpression.

2.  Let spreadValue be GetValue(spreadRef).

3.  Let spreadObj be ToObject(spreadValue).

4.  ReturnIfAbrupt(spreadObj).

5.  Let lenVal be the result of calling the [[Get]] internal method of
    spreadObj with argument “LENGTH”.

6.  Let spreadLen be ToUint32(lenVal).

7.  ReturnIfAbrupt(spreadLen).

8.  Let n=0;

9.  Repeat, while n < spreadLen

    a.  Let exists be the result of calling the [[HasProperty]]
          internal method of spreadObj with ToString(n).

    b.  If exists is TRUE then,

        i.  Let v be the result of calling the [[Get]] internal method
              of spreadObj passing ToString(n) as the argument.

        ii. ReturnIfAbrupt(v).

        iii. Call the [[DefineOwnProperty]] internal method of array
              with arguments ToString(ToUint32(nextIndex)), Property
              Descriptor {[[Value]]: v, [[Writable]]: TRUE,
              [[Enumerable]]: TRUE, [[Configurable]]: TRUE}, and FALSE.

    c.  Let n = n+1.

    d.  Let nextIndex = nextIndex +1.

10. Return nextIndex.

NOTE [[DefineOwnProperty]] is used to ensure that own properties are
defined for the array even if the standard built-in Array prototype
object has been modified in a manner that would preclude the creation of
new own properties using [[Put]].

RUNTIME SEMANTICS: EVALUATION

ArrayLiteral : [ Elision~opt~ ]

1.  Let array be the result of the abstract operation ArrayCreate
    (15.4) with argument 0.

2.  Let pad be the Elision Width of Elision; if Elision is not
    present, use the numeric value zero.

3.  Call the [[Put]] internal method of array with arguments "LENGTH",
    pad, and FALSE.

4.  Return array.

ArrayLiteral : [ ElementList ]

1.  Let array be the result of the abstract operation ArrayCreate
    (15.4) with argument 0.

2.  Let len be result of performing Array Accumulation for
    ElementList with arguments array and 0.

3.  ReturnIfAbrupt(len).

4.  Call the [[Put]] internal method of array with arguments "LENGTH",
    len, and FALSE.

5.  Return array.

ArrayLiteral : [ ElementList , Elision~opt~ ]

1.  Let array be the result of the abstract operation ArrayCreate
    (15.4) with argument 0.

2.  3.  Let len be result of performing Array Accumulation for
    ElementList with arguments array and 0.

4.  ReturnIfAbrupt(len).

5.  Let padding be the Elision Width of Elision; if Elision is not
    present, use the numeric value zero.

6.  7.  Call the [[Put]] internal method of array with arguments
    "LENGTH", ToUint32(padding_+_len), and FALSE.

8.  Return array.

Syntax

ArrayComprehension :

[ AssignmentExpression ComprehensionForList ]
[ AssignmentExpression ComprehensionForList IF Expression ]

ComprehensionForList :

ComprehensionFor
ComprehensionForList ComprehensionFor

ComprehensionFor :

FOR ForBinding OF Expression

ForBinding :

BindingIdentifier
BindingPattern

1.  

1.  

RUNTIME SEMANTICS

RUNTIME SEMANTICS: BINDING INITIALISATION

  With arguments value and environment.

NOTE UNDEFINED is passed for environment to indicate that a PutValue
operation should be used to assign the initialisation value. This is the
case for VAR statements formal parameter lists of non-strict functions.
In those cases a lexical binding is hosted and preinitialized prior to
evaluation of its initializer.

ForBinding : BindingPattern

1.  Let obj be ToObject(value).

2.  ReturnIfAbrupt(obj).

3.  Return the result of performing Binding Initialisation for
    BindingPattern passing obj and environment as the arguments.

1.  

1.  

RUNTIME SEMANTICS: EVALUATION

1.  2.  3.  4.  5.  

1.  2.  3.  4.  5.  6.  

1.  2.  3.  4.  5.  6.  7.  a.  b.  i.  ii. 

    c.  d.  

8.  

1.  2.  3.  4.  5.  6.  7.  

-   

1.  2.  3.  4.  5.  6.  7.  8.  9.  10. a.  b.  i.  ii. 

    c.  d.  

11. 

1.  

1.  2.  

NOTE An object initialiser is an expression describing the
initialisation of an Object, written in a form resembling a literal. It
is a list of zero or more pairs of property names and associated values,
enclosed in curly braces. The values need not be literals; they are
evaluated each time the object initialiser is evaluated.

Syntax

ObjectLiteral :

{ }
{ PropertyDefinitionList }
{ PropertyDefinitionList , }

PropertyDefinitionList :

PropertyDefinition
PropertyDefinitionList , PropertyDefinition

PropertyDefinition :

IdentifierName
CoverInitialisedName
PropertyName : AssignmentExpression
MethodDefinition

PropertyName :

IdentifierName
StringLiteral
NumericLiteral

CoverInitialisedName :

IdentifierName Initialiser

Initialiser :

= AssignmentExpression

NOTE 1 MethodDefinition is defined in 13.3.

NOTE 2 In certain contexts, ObjectLiteral is used as a cover grammar
for a more restricted secondary grammar. The CoverInitialisedName
production is necessary to fully cover these secondary grammars.
However, use of this production results in an early Syntax Error in
normal contexts where an actual ObjectLiteral is expected.

STATIC SEMANTICS: EARLY ERRORS

In addition to describe an actual object initialiser the ObjectLiteral
productions are used as a cover grammar for ObjectAssignmentPattern
(11.13.1). When ObjectLiteral appears in a context where
ObjectAssignmentPattern is required, the following Early Error rules
are NOT applied.

ObjectLiteral : { PropertyDefinitionList }

and

ObjectLiteral : { PropertyDefinitionList , }

-   It is a Syntax Error if PropertyNameList of PropertyDefinitionList
    contains any duplicate entries, unless one of the following
    conditions are true for each duplicate entry:

    1.  The source code corresponding to PropertyDefinitionList is not
        strict code and all occurrences in the list of the duplicated
        entry were obtained from productions of the form
        PropertyDefinition : PropertyName : AssignmentExpression.

    2.  The duplicated entry occurs exactly twice in the list and one
        occurrence was obtained from a GET accessor MethodDefinition
        and the other occurrence was obtained from a SET accessor
        MethodDefinition.

PropertyDefinition : MethodDefinition

-   It is a Syntax Error if ReferencesSuper of MethodDefinition is
    TRUE.

PropertyDefinition : IdentifierName

-   It is a Syntax Error if IdentifierName is a ReservedWord.

PropertyDefinition : CoverInitialisedName

-   Always throw a Syntax Error if this production is present

NOTE This production exists so that ObjectLiteral can serve as a cover
grammar for ObjectAssignmentPattern (11.13.1). It can not occur in an
actual object initialiser.

-   -   -   -   -   -   -   -   -   -   -   -   -   -   

-   -   

-   -   -   -   -   -   

1.  

1.  

STATIC SEMANTICS: CONTAINS

  With parameter symbol.

PropertyDefinition : MethodDefinition

1.  If symbol is MethodDefinition, return TRUE.

2.  Return FALSE.

NOTE Static semantic rules that depend upon substructure generally do
not look into function definitions.

PropertyName : IdentifierName

1.  If symbol is a ReservedWord, return FALSE.

2.  If symbol is an Identifier and StringValue of symbol is the
    same value as the StringValue of IdentifierName, return TRUE;

3.  Return FALSE.

STATIC SEMANTICS: ISVALIDSIMPLEASSIGNMENTTARGET

PrimaryExpression : Literal

1.  Return FALSE.

1.  

1.  

1.  

1.  

1.  2.  

1.  2.  a.  

3.  

STATIC SEMANTICS: PROPNAME

PropertyDefinition : IdentifierName

1.  Return StringValue of IdentifierName.

PropertyDefinition : PropertyName : AssignmentExpression

1.  Return PropName of PropertyName.

1.  

1.  

1.  

1.  

1.  

1.  

PropertyName : StringLiteral

1.  Return a String value whose characters are the SV of the
    StringLiteral.

PropertyName : NumericLiteral

1.  Let nbr be the result of forming the value of the
    NumericLiteral.

2.  Return ToString(nbr).

STATIC SEMANTICS: PROPERTYNAMELIST

PropertyDefinitionList : PropertyDefinition

1.  Return a new List containing PropName of PropertyDefinition.

PropertyDefinitionList : PropertyDefinitionList ,
PropertyDefinition

1.  Let list be PropertyNameList of PropertyDefinitionList.

2.  Append PropName of PropertyDefinition to the end of list.

3.  Return list.

RUNTIME SEMANTICS: EVALUATION

ObjectLiteral : { }

1.  Return a new object created as if by the expression NEW OBJECT()
    where OBJECT is the standard built-in constructor with that name.

ObjectLiteral :

  { PropertyDefinitionList }_
  _{ PropertyDefinitionList , }

1.  Let obj be the result of the abstract operation ObjectCreate
    (15.2).

2.  Let status be the result of performing Property Definition
    Evaluation of PropertyDefinitionList with argument obj.

3.  ReturnIfAbrupt(status).

4.  Return obj.

RUNTIME SEMANTICS: PROPERTY DEFINITION EVALUATION

  With parameter object.

1.  2.  3.  4.  

PropertyDefinitionList : PropertyDefinitionList ,
PropertyDefinition

PropertyDefinition : IdentifierName

1.  Let propName be StringValue of IdentifierName.

2.  Let exprValue be the result of performing Identifier Resolution as
    specified in 10.3.1 using IdentifierName.

3.  Let propValue be GetValue(exprValue).

4.  ReturnIfAbrupt(propValue).

5.  Let desc be the Property Descriptor{[[Value]]: propValue,
    [[Writable]]: TRUE, [[Enumerable]]: TRUE, [[Configurable]]: TRUE}

6.  Return the result of calling the [[DefineOwnProperty]] internal
    method of object with arguments propName, desc, and FALSE.

7.  

PropertyDefinition : PropertyName : AssignmentExpression

1.  Let propName be PropName of PropertyName.

2.  Let exprValue be the result of evaluating AssignmentExpression.

3.  Let propValue be GetValue(exprValue).

4.  ReturnIfAbrupt(propValue).

5.  Let desc be the Property Descriptor{[[Value]]: propValue,
    [[Writable]]: TRUE, [[Enumerable]]: TRUE, [[Configurable]]: TRUE}

6.  Return the result of calling the [[DefineOwnProperty]] internal
    method of object with arguments propName, desc, and FALSE.

1.  

1.  2.  3.  4.  

1.  2.  3.  4.  

1.  2.  3.  4.  

1.  2.  3.  4.  5.  

See 13.1 for PrimaryExpression : FunctionExpression.

See 13.4 for PrimaryExpression : GeneratorExpression.

See 13.5 for PrimaryExpression : ClassExpression.

1.  

Syntax

GeneratorComprehension :

( Expression ComprehensionForList )
( Expression ComprehensionForList IF Expression )

Syntax

See 7.8.5.

STATIC SEMANTICS

STATIC SEMANTICS: EARLY ERRORS

PrimaryExpression : RegularExpressionLiteral

-   It is a Syntax Error if BodyText of RegularExpressionLiteral can
    not be recognized using the goal symbol Pattern of the ECMAScript
    RegExp grammar specified in 15.10.

-   It is a Syntax Error if FlagText of RegularExpressionLiteral
    contains any character other than "G", "I", "M", "U", or "Y", or if
    it contains the same character more than once.

RUNTIME SEMANTICS

RUNTIME SEMANTICS: EVALUATION

PrimaryExpression : RegularExpressionLiteral

1.  A regular expression literal evaluates to a value of the Object type
    that is an instance of the standard built-in constructor RegExp.
    This value is determined in two steps: first, the characters
    comprising the regular expression's RegularExpressionBody and
    RegularExpressionFlags production expansions are collected
    uninterpreted into two Strings Pattern and Flags, respectively. Then
    each time the literal is evaluated, a new object is created as if by
    the expression NEW REGEXP(Pattern, Flags) where RegExp is the
    standard built-in constructor with that name. The newly constructed
    object becomes the value of the RegularExpressionLiteral.

Syntax

TemplateLiteral :

NoSubstitutionTemplate
TemplateHead Expression [Lexical goal InputElementTemplateTail]
TemplateSpans

TemplateSpans:

TemplateTail
TemplateMiddleList [Lexical goal InputElementTemplateTail] TemplateTail

TemplateMiddleList:

TemplateMiddle Expression
TemplateMiddleList [Lexical goal InputElementTemplateTail]
TemplateMiddle Expression

STATIC SEMANTICS

STATIC SEMANTICS: TEMPLATESTRINGS

  With parameter raw.

TemplateLiteral : NoSubstitutionTemplate

1.  If raw is false, then

    a.  Let string be the TV of NoSubstitutionTemplate.

2.  Else,

    a.  Let string be the TRV of NoSubstitutionTemplate.

3.  Return a List containing the single element, string.

TemplateLiteral : _TemplateHead Expression_ [Lexical goal
InputElementTemplateTail] TemplateSpans

1.  If raw is false, then

    a.  Let head be the TV of TemplateHead.

    b.  

2.  Else,

    a.  Let head be the TRV of TemplateHead.

3.  Let tail be TemplateStrings of TemplateSpans with argument
    raw.

4.  Return a List containing head followed by the element, in order of
    tail.

TemplateSpans : TemplateTail

1.  If raw is false, then

    a.  Let tail be the TV of TemplateTail.

2.  Else,

    a.  Let tail be the TRV of TemplateTail.

3.  Return a List containing the single element, tail.

TemplateSpans : TemplateMiddleList [Lexical goal
InputElementTemplateTail] TemplateTail

1.  Let middle be TemplateStrings of TemplateMiddleList with
    argument raw.

2.  If raw is false, then

3.  a.  Let tail be the TV of TemplateTail.

4.  Else,

    a.  b.  Let tail be the TRV of TemplateTail.

5.  6.  Return a List containing the elements, in order, of middle
    followed by tail.

TemplateMiddleList : _TemplateMiddle Expression_

1.  If raw is false, then

    a.  Let string be the TV of TemplateMiddle.

2.  Else,

    a.  Let string be the TRV of TemplateMiddle.

3.  Return a List containing the single element, string.

TemplateMiddleList : TemplateMiddleList [Lexical goal
InputElementTemplateTail] _TemplateMiddle Expression_

1.  Let front be TemplateStrings of TemplateMiddleList with argument
    raw.

2.  If raw is false, then

    a.  Let last be the TV of TemplateMiddle.

3.  Else,

    a.  Let last be the TRV of TemplateMiddle.

4.  Append last as the last elemnt of the List front.

5.  Return front.

RUNTIME SEMANTICS

RUNTIME SEMANTICS: ARGUMENTLISTEVALUATION

TemplateLiteral : NoSubstitutionTemplate

1.  Let siteObj be the result of the abstraction operation
    GetTemplateCallSite passing this TemplateLiteral production as the
    argument.

2.  Return a List containing the one element which is siteObj.

1.  2.  3.  4.  

TemplateLiteral : _TemplateHead Expression_ [Lexical goal
InputElementTemplateTail] TemplateSpans

1.  Let siteObj be the result of the abstraction operation
    GetTemplateCallSite passing this TemplateLiteral production as the
    argument.

2.  Let firstSub be the result of evaluating Expression.

3.  ReturnIfAbrupt(firstSub).

4.  Let restSub be SubstitutionEvaluation of TemplateSpans.

5.  ReturnIfAbrupt(restSub).

6.  Assert, restSub is a List.

7.  Return a List whose first element is siteObj, whose second
    elements is firstSub, and whose subsequent elements are the
    elements of restSub, in order. restSub may contain no elements.

RUNTIME SEMANTICS: GETTEMPLATECALLSITE ABSTRACT OPERATION

The abstract operation GetTemplateCallSite is called with a grammar
production, templateLiteral, as an argument. It performs the following
steps:

1.  If a call site object for the source code corresponding to
    templateLiteral has already been created by a previous call to
    this abstract operation, then return that call site object.

2.  Let cookedStrings be TemplateStrings of templateLiteral with
    argument FALSE.

3.  Let rawStrings be TemplateStrings of templateLiteral with
    argument TRUE.

4.  Let count be the number of elements in the List cookedStrings.

5.  Let siteObj be the result of the abstraction operation ArrayCreate
    with argument count.

6.  Let rawObj be the result of the abstraction operation ArrayCreate
    with argument count.

7.  Let index be 0.

8.  Repeat while index < count

    a.  Let prop be ToString(index).

    b.  Let cookedValue be the string value at 0-based position
        index of the List cookedStrings.

    c.  Call the [[DefineOwnProperty]] internal method of siteObj with
        arguments prop, PROPERTY DESCRIPTOR {[[Value]]: cookedValue,
        [[Writable]]: FALSE, [[Configurable]]: FALSE}, and FALSE.

    d.  Let rawValue be the string value at 0-based position index
        of the List rawStrings.

    e.  Call the [[DefineOwnProperty]] internal method of rawObj with
        arguments prop, PROPERTY DESCRIPTOR {[[Value]]: rawValue,
        [[Writable]]: FALSE, [[Configurable]]: FALSE}, and FALSE.

    f.  Let index be index+1.

9.  Call the FreezeObject abstract operation with argument rawObj.

10. Call the [[DefineOwnProperty]] internal method of siteObj with
    arguments "RAW", Property Descriptor {[[Value]]: rawObj,
    [[Writable]]: FALSE, [[Enumerable]]: FALSE, [[Configurable]]:
    FALSE}, and FALSE.

11. Call the FreezeObject abstract operation with argument siteObj.

12. Remember an association between the source code corresponding to
    templateLiteral and siteObj such that siteObj can be retrieve in
    subsequent calls to this abstract operation.

13. Return siteObj.

NOTE 1 The creation of a call site object can not result in an abrupt
completion.

NOTE 2 Each TemplateLiteral in the program code is associated with a
unique Template call site object that is used in the evaluation of
tagged Templates (11.2.6). The same call site object is used each time a
specific tagged Template is evaluated. Whether call site objects are
created lazily upon first evaluation of the TemplateLiteral or eagerly
prior to first evaluation is an implementation choice that is not
observable to ECMAScript code.

RUNTIME SEMANTICS: SUBSTITUTIONEVALUATION

TemplateSpans : TemplateTail

1.  Return an empty List.

TemplateSpans : TemplateMiddleList [Lexical goal
InputElementTemplateTail] TemplateTail

1.  Return the result of SubstitutionEvaluation of TemplateMiddleList.

TemplateMiddleList : _TemplateMiddle Expression_

1.  Let sub be the result of evaluating Expression.

2.  ReturnIfAbrupt(sub).

3.  Return a List containing only sub.

TemplateMiddleList : TemplateMiddleList [Lexical goal
InputElementTemplateTail] _TemplateMiddle Expression_

1.  Let preceeding be the result of SubstitutionEvaluation of
    TemplateMiddleList .

2.  ReturnIfAbrupt(preceeding).

3.  Let next be the result of evaluating Expression.

4.  ReturnIfAbrupt(next).

5.  Append next as the list element of the List preceeding.

6.  Return preceeding.

RUNTIME SEMANTICS: EVALUATION

TemplateLiteral : NoSubstitutionTemplate

1.  Return the string value whose elements are the TV of
    NoSubstitutionTemplate as defined in 7.8.6.

TemplateLiteral : TemplateHead Expression [Lexical goal
InputElementTemplateTail] TemplateSpans

1.  Let head be the TV of TemplateHead as defined in 7.8.6.

2.  Let sub be the result of evaluating Expression.

3.  Let middle be ToString(sub).

4.  ReturnIfAbrupt(middle).

5.  Let tail be the result of evaluating TemplateSpans .

6.  ReturnIfAbrupt(tail).

7.  8.  Return the string value whose elements are the code units of
    head followed by the code units of tail.

TemplateSpans : TemplateTail

1.  Let tail be the TV of TemplateTail as defined in 7.8.6.

2.  Return the string whose elements are the code units of tail.

TemplateSpans : TemplateMiddleList [Lexical goal
InputElementTemplateTail] TemplateTail

1.  2.  3.  4.  5.  

1.  Let head be the result of evaluating TemplateMiddleList.

2.  ReturnIfAbrupt(head).

3.  Let tail be the TV of TemplateTail as defined in 7.8.6.

4.  Return the string whose elements are the elements of head followed
    by the elements of tail.

TemplateMiddleList : _TemplateMiddle Expression_

1.  Let head be the TV of TemplateMiddle as defined in 7.8.6.

2.  Let sub be the result of evaluating Expression.

3.  Let middle be ToString(sub).

4.  ReturnIfAbrupt(middle).

5.  Return the sequence of characters consisting of the code units of
    head followed by the elements of middle.

TemplateMiddleList : TemplateMiddleList [Lexical goal
InputElementTemplateTail] _TemplateMiddle Expression_

1.  Let rest be the result of evaluating TemplateMiddleList .

2.  ReturnIfAbrupt(rest).

3.  Let middle be the TV of TemplateMiddle as defined in 7.8.6.

4.  Let sub be the result of evaluating Expression.

5.  Let last be ToString(sub).

6.  ReturnIfAbrupt(last).

7.  Return the sequence of characters consisting of the elements of
    rest followed by the code units of middle followed by the
    elements of last.

1.  

1.  

1.  2.  

STATIC SEMANTICS: EARLY ERRORS

PrimaryExpression : _CoverParenthesizedExpressionAndArrowParameterList
_

-   It is a Syntax Error if the lexical token sequence matched by
    CoverParenthesizedExpressionAndArrowParameterList cannot be parsed
    with no tokens left over using ParenthesizedExpression as the goal
    symbol.

-   All Early Errors rules for ParenthesizedExpression and its derived
    productions also apply to the CoveredParenthesizedExpression of
    CoverParenthesizedExpressionAndArrowParameterList.

STATIC SEMANTICS: ISVALIDSIMPLEASSIGNMENTTARGET

PrimaryExpression :
CoverParenthesizedExpressionAndArrowParameterList

1.  Let expr be CoveredParenthesizedExpression of
    CoverParenthesizedExpressionAndArrowParameterList.

2.  Return IsValidSimpleAssignmentTarget of expr.

ParenthesizedExpression : ( Expression )

1.  Return IsValidSimpleAssignmentTarget of Expression.

RUNTIME SEMANTICS: EVALUATION

PrimaryExpression :
CoverParenthesizedExpressionAndArrowParameterList

1.  Let expr be CoveredParenthesizedExpression of
    CoverParenthesizedExpressionAndArrowParameterList.

2.  Return the result of evaluating expr.

ParenthesizedExpression : ( Expression )

1.  Return the result of evaluating Expression. This may be of type
    Reference.

NOTE This algorithm does not apply GetValue to the result of evaluating
Expression. The principal motivation for this is so that operators such
as DELETE and TYPEOF may be applied to parenthesised expressions.

Syntax

MemberExpression :

[Lexical goal InputElementRegExp] PrimaryExpression
MemberExpression [ Expression ]
MemberExpression . IdentifierName
MemberExpression TemplateLiteral
SUPER [ Expression ]
SUPER . IdentifierName
NEW MemberExpression Arguments

NewExpression :

MemberExpression
NEW NewExpression

CallExpression :

MemberExpression Arguments
SUPER Arguments
CallExpression Arguments
CallExpression [ Expression ]
CallExpression . IdentifierName
CallExpression TemplateLiteral

Arguments :

( )
( ArgumentList )

ArgumentList :

AssignmentExpression
... AssignmentExpression
ArgumentList , AssignmentExpression
ArgumentList , ... AssignmentExpression

LeftHandSideExpression :

NewExpression
CallExpression

STATIC SEMANTICS

STATIC SEMANTICS: CONTAINS

  With parameter symbol.

MemberExpression : MemberExpression . IdentifierName

1.  If MemberExpression contains symbol is TRUE, return TRUE.

2.  If symbol is a ReservedWord, return FALSE.

3.  If symbol is an Identifier and StringValue of symbol is the
    same value as the StringValue of IdentifierName, return TRUE;

4.  Return FALSE.

MemberExpression : SUPER . IdentifierName

1.  If symbol is the ReservedWord SUPER, return TRUE.

2.  If symbol is a ReservedWord, return FALSE.

3.  If symbol is an Identifier and StringValue of symbol is the
    same value as the StringValue of IdentifierName, return TRUE;

4.  Return FALSE.

CallExpression : CallExpression . IdentifierName

1.  If CallExpression contains symbol is TRUE, return TRUE.

2.  If symbol is a ReservedWord, return FALSE.

3.  If symbol is an Identifier and StringValue of symbol is the
    same value as the StringValue of IdentifierName, return TRUE;

4.  Return FALSE.

1.  a.  

2.  3.  

1.  

STATIC SEMANTICS: ISVALIDSIMPLEASSIGNMENTTARGET

CallExpression :

MemberExpression Arguments
SUPER Arguments
CallExpression Arguments
CallExpression [ Expression ]
CallExpression . IdentifierName

MemberExpression :

MemberExpression [ Expression ]
MemberExpression . IdentifierName
SUPER [ Expression ]
SUPER . IdentifierName

1.  Return TRUE.

CallExpression : CallExpression TemplateLiteral

NewExpression : NEW NewExpression

MemberExpression : NEW MemberExpression Arguments

1.  Return FALSE.

Properties are accessed by name, using either the dot notation:

MemberExpression . IdentifierName
CallExpression . IdentifierName

or the bracket notation:

MemberExpression [ Expression ]
CallExpression [ Expression ]

The dot notation is explained by the following syntactic conversion:

MemberExpression . IdentifierName

is identical in its behaviour to

MemberExpression [ <identifier-name-string> ]

and similarly

CallExpression . IdentifierName

is identical in its behaviour to

CallExpression [ <identifier-name-string> ]

where <identifier-name-string> is a string literal containing the same
sequence of characters after processing of Unicode escape sequences as
the IdentifierName.

RUNTIME SEMANTICS: EVALUATION

MemberExpression : MemberExpression [ Expression ]

CallExpression : CallExpression [ Expression ]

Is evaluated in exactly the same manner as MemberExpression :
MemberExpression [ Expression ] except that the contained
CallExpression is evaluated in step 1.

RUNTIME SEMANTICS: EVALUATION

NewExpression : NEW NewExpression

1.  Let ref be the result of evaluating NewExpression.

2.  Let constructor be GetValue(ref).

3.  ReturnIfAbrupt(constructor).

4.  If Type(constructor) is not Object, throw a TYPEERROR exception.

5.  If constructor does not implement the [[Construct]] internal
    method, throw a TYPEERROR exception.

6.  Return the result of calling the [[Construct]] internal method on
    constructor with an empty List as the argument.

MemberExpression : NEW MemberExpression Arguments

1.  Let ref be the result of evaluating MemberExpression.

2.  Let constructor be GetValue(ref).

3.  ReturnIfAbrupt(constructor).

4.  Let argList be the result of evaluating Arguments, producing an
    internal List of argument values (11.2.4).

5.  ReturnIfAbrupt(argList).

6.  If Type(constructor) is not Object, throw a TYPEERROR exception.

7.  If constructor does not implement the [[Construct]] internal
    method, throw a TYPEERROR exception.

8.  Return the result of calling the [[Construct]] internal method on
    constructor, passing argList as the argument.

RUNTIME SEMANTICS: EVALUATION

CallExpression : MemberExpression Arguments

1.  Let ref be the result of evaluating MemberExpression.

2.  If this CallExpression is in a tail position (13.7) then let
    tailCall be TRUE, otherwise let tailCall be FALSE.

3.  Return the result of the abstract operation EvaluateCall with
    arguments ref, Arguments, and tailCall.

CallExpression : CallExpression Arguments

1.  Let ref be the result of evaluating CallExpression.

2.  If this CallExpression is in a tail position (13.7) then let
    tailCall be TRUE, otherwise let tailCall be FALSE.

3.  Return the result of the abstract operation EvaluateCall with
    arguments ref, Arguments, and tailCall.

RUNTIME SEMANTICS: EVALUATECALL ABSTRACT OPERATION

The abstract operation EvaluateCall takes as arguments a value ref,
and a syntactic grammar production arguments, and a Boolean argument
tailPosition. It performs the following steps:

1.  2.  Let func be GetValue(ref).

3.  ReturnIfAbrupt(func).

4.  Let argList be the result of performing ArgumentListEvaluation of
    arguments.

5.  ReturnIfAbrupt(argList).

6.  If Type(func) is not Object, throw a TYPEERROR exception.

7.  If IsCallable(func) is FALSE, throw a TYPEERROR exception.

8.  If Type(ref) is Reference, then

    a.  If IsPropertyReference(ref) is TRUE, then

        i.  Let thisValue be GetThisValue(ref).

    b.  Else, the base of ref is an Environment Record

        i.  Let thisValue be the result of calling the WithBaseObject
            concrete method of GetBase(ref).

9.  Else Type(ref) is not Reference,

    a.  Let thisValue be UNDEFINED.

10. If tailPosition is true, then

    a.  Let leafContext be the running execution context.

    b.  c.  Suspend leafContext.

    d.  Pop leafContext from the execution context context stack. The
        execution context now on the top of the stack becomes the
        running execution context, however it remains in its suspended
        state.

    e.  Assert: leafContext has no further use. It will never be
        activated as the running execution context.

11. Let result be the result of calling the [[Call]] internal method
    on func, passing thisValue as the thisArgument and argList
    as the argumentsList.

12. Assert: If tailPosition is true, the above call will not return
    here, but instead evaluation will continue with the resumption of
    leafCallerContext as the running execution context.

13. Return result.

A tail position call must either release any transient internal
resources associated with the currently executing function execution
context before invoking the target function or reuse those resources in
support of the target function.

NOTE 1 For example, a tail position call should only grow an
implementation’s activication record stack by the amount that the size
of the target function’s activation record exceeds the size of the
calling function’s activation record. If the target function’s
activation record is smaller, then the total size of the stack should
decrease.

NOTE 2 The returned result will never be of type Reference if func is
an ordinary object. Whether calling an exotic object can return a value
of type Reference is implementation-dependent. If a value of type
Reference is returned, it must be a non-strict Property Reference.

STATIC SEMANTICS

STATIC SEMANTICS: EARLY ERRORS

MemberExpression :

SUPER [ Expression ]
SUPER . IdentifierName

-   It is a Syntax Error if the source code parsed with this production
    is global code that is not eval code.

-   It is a Syntax Error if the source code parsed with this production
    is eval code and the source code is not being processed by a direct
    call to eval that is contained in function code.

-   

CallExpression : SUPER Arguments

-   It is a Syntax Error if the source code parsed with this production
    is global code that is not eval code.

-   It is a Syntax Error if the source code parsed with this production
    is eval code and the source code is not being processed by a direct
    call to eval that is contained in function code.

-   

RUNTIME SEMANTICS: EVALUATION

MemberExpression : SUPER [ Expression ]

1.  Let env be the result of performing the GetThisEnvironment
    abstract operation.

2.  If the result of calling the HasSuperBinding concrete method of
    env is FALSE, then throw ReferenceError.

3.  Let actualThis be the result of calling the GetThisBinding
    concrete method of env.

4.  Let baseValue be the result of calling the GetSuperBase concrete
    method of env.

5.  6.  7.  Let propertyNameReference be the result of evaluating
    Expression.

8.  Let propertyNameValue be GetValue(propertyNameReference).

9.  ReturnIfAbrupt(CheckObjectCoercible(baseValue)).

10. Let propertyKey be ToPropertyKey(propertyNameValue).

11. If the code matched by the syntactic production that is being
    evaluated is strict mode code, let strict be TRUE, else let
    strict be FALSE.

12. Return a value of type Reference that is a Super Reference whose
    base value is baseValue, whose referenced name is propertyKey,
    whose thisValue is actualThis, and whose strict mode flag is
    strict.

MemberExpression : SUPER . IdentifierName

1.  Let env be the result of performing the GetThisEnvironment
    abstract operation.

2.  If the result of calling the HasSuperBinding concrete method of
    env is FALSE, then throw ReferenceError.

3.  Let actualThis be the result of calling the GetThisBinding
    concrete method of env.

4.  Let baseValue be the result of calling the GetSuperBase concrete
    method of env.

5.  ReturnIfAbrupt(CheckObjectCoercible(baseValue)).

6.  Let propertyKey be StringValue of IdentifierName.

7.  If the code matched by the syntactic production that is being
    evaluated is strict mode code, let strict be TRUE, else let
    strict be FALSE.

8.  Return a value of type Reference that is a Super Reference whose
    base value is baseValue, whose referenced name is propertyKey,
    whose thisValue is actualThis, and whose strict mode flag is
    strict.

CallExpression : SUPER Arguments

1.  Let env be the result of performing the GetThisEnvironment
    abstract operation.

2.  If the result of calling the HasSuperBinding concrete method of
    env is FALSE, then throw ReferenceError.

3.  Let actualThis be the result of calling the GetThisBinding
    concrete method of env.

4.  Let baseValue be the result of calling the GetSuperBase concrete
    method of env.

5.  ReturnIfAbrupt(CheckObjectCoercible(baseValue)).

6.  Let propertyKey be the result of calling the GetMethodName
    concrete method of env.

7.  If the code matched by the syntactic production that is being
    evaluated is strict mode code, let strict be TRUE, else let
    strict be FALSE.

8.  Let ref be a value of type Reference that is a Super Reference
    whose base value is baseValue, whose referenced name is
    propertyKey, whose thisValue.

9.  If this CallExpression is in a tail position (13.7) then let
    tailCall be TRUE, otherwise let tailCall be FALSE.

10. Return the result of the abstract operation EvaluateCall with
    arguments ref, Arguments, and tailCall.

The evaluation of an argument list produces a List of values (see 8.7).

1.  

1.  

1.  2.  3.  

-   

-   

RUNTIME SEMANTICS: ARGUMENTLISTEVALUATION

Arguments : ( )

1.  Return an empty List.

1.  

ArgumentList : AssignmentExpression

1.  Let ref be the result of evaluating AssignmentExpression.

2.  Let arg be GetValue(ref).

3.  ReturnIfAbrupt(arg).

4.  Return a List whose sole item is arg.

ArgumentList : _… AssignmentExpression_

1.  Let list be an empty List.

2.  Let spreadRef be the result of evaluating AssignmentExpression.

3.  Let spreadValue be GetValue(spreadRef).

4.  Let spreadObj be ToObject(spreadValue).

5.  ReturnIfAbrupt(spreadObj).

6.  Let lenVal be the result of calling the [[Get]] internal method of
    spreadObj with argument “LENGTH”.

7.  Let spreadLen be ToUint32(lenVal).

8.  ReturnIfAbrupt(spreadLen).

9.  Let n = 0.

10. Repeat, while n < spreadLen

    a.  Let nextArg be the result of calling the [[Get]] internal
          method of spreadObj passing ToString(n) as the argument.

    b.  ReturnIfAbrupt(nextArg).

    c.  Append nextArg as the last element of list.

    d.  Let n = n+1.

11. Return list.

ArgumentList : ArgumentList , AssignmentExpression

1.  Let precedingArgs be the result of evaluating ArgumentList.

2.  ReturnIfAbrupt(precedingArgs).

3.  Let ref be the result of evaluating AssignmentExpression.

4.  Let arg be GetValue(ref).

5.  ReturnIfAbrupt(arg).

6.  Return a List whose length is one greater than the length of
    precedingArgs and whose items are the items of precedingArgs, in
    order, followed at the end by arg which is the last item of the
    new list.

ArgumentList : ArgumentList , _… _AssignmentExpression

1.  Let precedingArgs be an empty List.

2.  Let spreadRef be the result of evaluating AssignmentExpression.

3.  Let spreadValue be GetValue(spreadRef).

4.  Let spreadObj be ToObject(spreadValue).

5.  ReturnIfAbrupt(spreadObj).

6.  Let lenVal be the result of calling the [[Get]] internal method of
    spreadObj with argument “LENGTH”.

7.  Let spreadLen be ToUint32(lenVal).

8.  ReturnIfAbrupt(spreadLen).

9.  Let n = 0.

10. Repeat, while n < spreadLen

    a.  Let nextArg be the result of calling the [[Get]] internal
          method of spreadObj passing ToString(n) as the argument.

    b.  ReturnIfAbrupt(nextArg).

    c.  Append nextArg as the last element of precedingArgs.

    d.  Let n = n+1.

11. Return precedingArgs.

RUNTIME SEMANTICS: EVALUATION

MemberExpression : _MemberExpression TemplateLiteral_

1.  Let tagRef be the result of evaluating MemberExpression.

2.  If this MemberExpression is in a tail position (13.7) then let
    tailCall be TRUE, otherwise let tailCall be FALSE.

3.  Return the result of the abstract operation EvaluateCall with
    arguments tagRef, TemplateLiteral, and tailCall.

CallExpression : _CallExpression TemplateLiteral_

1.  Let tagRef be the result of evaluating CallExpression.

2.  If this CallExpression is in a tail position (13.7) then let
    tailCall be TRUE, otherwise let tailCall be FALSE.

3.  Return the result of the abstract operation EvaluateCall with
    arguments tagRef, TemplateLiteral, and tailCall.

Syntax

PostfixExpression :

LeftHandSideExpression
LeftHandSideExpression [no LineTerminator here] ++
LeftHandSideExpression [no LineTerminator here] --

STATIC SEMANTICS

STATIC SEMANTICS: EARLY ERRORS

-   -   

PostfixExpression :

LeftHandSideExpression [no LineTerminator here] ++
LeftHandSideExpression [no LineTerminator here] --

-   It is an early Reference Error if IsValidSimpleAssignmentTarget of
    LeftHandSideExpression is FALSE.

-   -   -   

STATIC SEMANTICS: ISVALIDSIMPLEASSIGNMENTTARGET

PostfixExpression :

LeftHandSideExpression [no LineTerminator here] ++
LeftHandSideExpression [no LineTerminator here] --

1.  Return FALSE.

RUNTIME SEMANTICS: EVALUATION

PostfixExpression : LeftHandSideExpression [no LineTerminator
here] ++

1.  Let lhs be the result of evaluating LeftHandSideExpression.

2.  

-   -   -   -   

1.  Let oldValue be ToNumber(GetValue(lhs)).

2.  ReturnIfAbrupt(oldValue).

3.  Let newValue be the result of adding the value 1 to oldValue,
    using the same rules as for the + operator (see 11.6.3).

4.  Let status be PutValue(lhs, newValue).

5.  ReturnIfAbrupt(status).

6.  Return oldValue.

RUNTIME SEMANTICS: EVALUATION

PostfixExpression : LeftHandSideExpression [no LineTerminator
here] --

1.  Let lhs be the result of evaluating LeftHandSideExpression.

2.  

-   -   -   -   

1.  Let oldValue be ToNumber(GetValue(lhs)).

2.  Let newValue be the result of subtracting the value 1 from
    oldValue, using the same rules as for the - operator (11.6.3).

3.  Let status be PutValue(lhs, newValue).

4.  ReturnIfAbrupt(status).

5.  Return oldValue.

Syntax

UnaryExpression :

PostfixExpression
DELETE UnaryExpression
VOID UnaryExpression
TYPEOF UnaryExpression
++ UnaryExpression
-- UnaryExpression
+ UnaryExpression
- UnaryExpression
~ UnaryExpression
! UnaryExpression

STATIC SEMANTICS

STATIC SEMANTICS: EARLY ERRORS

UnaryExpression :

DELETE UnaryExpression

-   -   It is a Syntax Error if the UnaryExpression is contained in
    strict code and the derived UnaryExpression is the Identifier EVAL
    or the Identifier ARGUMENTS.

-   -   -   It is a Syntax Error if the derived UnaryExpression is
    PrimaryExpression : ( Expression ) and Expression derived a
    production that if used in place of UnaryExpression would produce
    a Syntax Error according to these rules. This rule is recursively
    applied.

UnaryExpression :

++ UnaryExpression
-- UnaryExpression

-   It is an early Reference Error if IsValidSimpleAssignmentTarget of
    UnaryExpression is FALSE.

STATIC SEMANTICS: ISVALIDSIMPLEASSIGNMENTTARGET

UnaryExpression :

DELETE UnaryExpression
VOID UnaryExpression
TYPEOF UnaryExpression
++ UnaryExpression
-- UnaryExpression
+ UnaryExpression
- UnaryExpression
~ UnaryExpression
! UnaryExpression

1.  Return FALSE.

STATIC SEMANTICS: EARLY ERRORS

UnaryExpression : DELETE UnaryExpression

-   It is a Syntax Error if the UnaryExpression is contained in strict
    code and the UnaryExpression derives an Identifier that
    statically resolves to a environment record.

RUNTIME SEMANTICS: EVALUATION

UnaryExpression : DELETE UnaryExpression

1.  Let ref be the result of evaluating UnaryExpression.

2.  ReturnIfAbrupt(ref).

3.  If Type(ref) is not Reference, return TRUE.

4.  If IsUnresolvableReference(ref) is TRUE, then,

    a.  If IsStrictReference(ref) is TRUE, throw a SYNTAXERROR
        exception.

    b.  Else, return TRUE.

5.  If IsPropertyReference(ref) is TRUE, then

    a.  If IsSuperReference(ref), then throw a REFERENCEERROR
        exception.

    b.  Return the result of calling the [[Delete]] internal method on
        ToObject(GetBase(ref)) providing GetReferencedName(ref) and
        IsStrictReference(ref) as the arguments.

6.  Else ref is a Reference to an Environment Record binding,

    a.  b.  Let bindings be GetBase(ref).

    c.  Return the result of calling the DeleteBinding concrete method
        of bindings, providing GetReferencedName(ref) as the
        argument.

NOTE When a DELETE operator occurs within strict mode code, a
SYNTAXERROR exception is thrown if its UnaryExpression is a direct
reference to a variable, function argument, or function name. In
addition, if a DELETE operator occurs within strict mode code and the
property to be deleted has the attribute { [[Configurable]]: FALSE }, a
TYPEERROR exception is thrown.

RUNTIME SEMANTICS: EVALUATION

UnaryExpression : VOID UnaryExpression

1.  Let expr be the result of evaluating UnaryExpression.

2.  Let status be Call GetValue(expr).

3.  ReturnIfAbrupt(status).

4.  5.  Return UNDEFINED.

NOTE GetValue must be called even though its value is not used because
it may have observable side-effects.

RUNTIME SEMANTICS: EVALUATION

UnaryExpression : TYPEOF UnaryExpression

1.  Let val be the result of evaluating UnaryExpression.

2.  If Type(val) is Reference, then

    a.  If IsUnresolvableReference(val) is TRUE, return "UNDEFINED".

    b.  Let val be GetValue(val).

3.  ReturnIfAbrupt(val).

4.  Return a String determined by Type(val) according to Table 25.

Table 27 — typeof Operator Results

  ----------------------------------------------------- -----------------------------------------------------------------------------------------
  _TYPE OF val_                                         RESULT
  Undefined                                             "UNDEFINED"
  Null                                                  "OBJECT"
  Boolean                                               "BOOLEAN"
  Number                                                "NUMBER"
  String                                                "STRING"
  Object (native and does not implement [[Call]])       "OBJECT"
  Object (native or host and does implement [[Call]])   "FUNCTION"
  Object (host and does not implement [[Call]])         Implementation-defined except may not be "UNDEFINED", "BOOLEAN", "NUMBER", or "STRING".
  ----------------------------------------------------- -----------------------------------------------------------------------------------------

RUNTIME SEMANTICS: EVALUATION

UnaryExpression : ++ UnaryExpression

1.  Let expr be the result of evaluating UnaryExpression.

2.  

-   -   -   -   

1.  Let oldValue be ToNumber(GetValue(expr)).

2.  ReturnIfAbrupt(oldValue).

3.  Let newValue be the result of adding the value 1 to oldValue,
    using the same rules as for the + operator (see 11.6.3).

4.  Let status be PutValue(expr, newValue).

5.  ReturnIfAbrupt(status).

6.  Return newValue.

RUNTIME SEMANTICS: EVALUATION

UnaryExpression : -- UnaryExpression

1.  Let expr be the result of evaluating UnaryExpression.

2.  

-   -   -   -   

1.  Let oldValue be ToNumber(GetValue(expr)).

2.  ReturnIfAbrupt(oldValue).

3.  Let newValue be the result of subtracting the value 1 from
    oldValue, using the same rules as for the - operator (see 11.6.3).

4.  Let status be PutValue(expr, newValue).

5.  ReturnIfAbrupt(status).

6.  Return newValue.

NOTE The unary + operator converts its operand to Number type.

RUNTIME SEMANTICS: EVALUATION

UnaryExpression : + UnaryExpression

1.  Let expr be the result of evaluating UnaryExpression.

2.  Return ToNumber(GetValue(expr)).

NOTE The unary - operator converts its operand to Number type and then
negates it. Negating +0 produces −0, and negating −0 produces +0.

RUNTIME SEMANTICS: EVALUATION

UnaryExpression : - UnaryExpression

1.  Let expr be the result of evaluating UnaryExpression.

2.  Let oldValue be ToNumber(GetValue(expr)).

3.  ReturnIfAbrupt(oldValue).

4.  If oldValue is NAN, return NAN.

5.  Return the result of negating oldValue; that is, compute a Number
    with the same magnitude but opposite sign.

RUNTIME SEMANTICS: EVALUATION

UnaryExpression : ~ UnaryExpression

1.  Let expr be the result of evaluating UnaryExpression.

2.  Let oldValue be ToInt32(GetValue(expr)).

3.  ReturnIfAbrupt(oldValue).

4.  Return the result of applying bitwise complement to oldValue. The
    result is a signed 32-bit integer.

RUNTIME SEMANTICS: EVALUATION

UnaryExpression : ! UnaryExpression

1.  Let expr be the result of evaluating UnaryExpression.

2.  Let oldValue be ToBoolean(GetValue(expr)).

3.  ReturnIfAbrupt(oldValue).

4.  If oldValue is TRUE, return FALSE.

5.  Return TRUE.

Syntax

MultiplicativeExpression :

UnaryExpression
MultiplicativeExpression * UnaryExpression
MultiplicativeExpression / UnaryExpression
MultiplicativeExpression % UnaryExpression

STATIC SEMANTICS: ISVALIDSIMPLEASSIGNMENTTARGET

MultiplicativeExpression :

MultiplicativeExpression * UnaryExpression
MultiplicativeExpression / UnaryExpression
MultiplicativeExpression % UnaryExpression

1.  Return FALSE.

RUNTIME SEMANTICS: EVALUATION

The production MultiplicativeExpression : _MultiplicativeExpression @
UnaryExpression_, where @ stands for one of the operators in the above
definitions, is evaluated as follows:

1.  Let left be the result of evaluating MultiplicativeExpression.

2.  Let leftValue be GetValue(left).

3.  ReturnIfAbrupt(leftValue).

4.  Let right be the result of evaluating UnaryExpression.

5.  Let rightValue be GetValue(right).

6.  Let lnum be ToNumber(leftValue).

7.  ReturnIfAbrupt(lnum).

8.  Let rnum be ToNumber(rightValue).

9.  ReturnIfAbrupt(rnum).

10. Return the result of applying the specified operation (*, /, or %)
    to lnum and rnum. See the Notes below 11.5.1, 11.5.2, 11.5.3.

The * operator performs multiplication, producing the product of its
operands. Multiplication is commutative. Multiplication is not always
associative in ECMAScript, because of finite precision.

The result of a floating-point multiplication is governed by the rules
of IEEE 754 binary double-precision arithmetic:

-   If either operand is NAN, the result is NAN.

-   The sign of the result is positive if both operands have the same
      sign, negative if the operands have different signs.

-   Multiplication of an infinity by a zero results in NAN.

-   Multiplication of an infinity by an infinity results in an infinity.
      The sign is determined by the rule already stated above.

-   Multiplication of an infinity by a finite nonzero value results in a
      signed infinity. The sign is determined by the rule already stated
      above.

-   In the remaining cases, where neither an infinity or NaN is
      involved, the product is computed and rounded to the nearest
      representable value using IEEE 754 round-to-nearest mode. If the
      magnitude is too large to represent, the result is then an
      infinity of appropriate sign. If the magnitude is too small to
      represent, the result is then a zero of appropriate sign. The
      ECMAScript language requires support of gradual underflow as
      defined by IEEE 754.

The / operator performs division, producing the quotient of its
operands. The left operand is the dividend and the right operand is the
divisor. ECMAScript does not perform integer division. The operands and
result of all division operations are double-precision floating-point
numbers. The result of division is determined by the specification of
IEEE 754 arithmetic:

-   If either operand is NAN, the result is NAN.

-   The sign of the result is positive if both operands have the same
      sign, negative if the operands have different signs.

-   Division of an infinity by an infinity results in NAN.

-   Division of an infinity by a zero results in an infinity. The sign
      is determined by the rule already stated above.

-   Division of an infinity by a nonzero finite value results in a
      signed infinity. The sign is determined by the rule already stated
      above.

-   Division of a finite value by an infinity results in zero. The sign
      is determined by the rule already stated above.

-   Division of a zero by a zero results in NAN; division of zero by any
      other finite value results in zero, with the sign determined by
      the rule already stated above.

-   Division of a nonzero finite value by a zero results in a signed
      infinity. The sign is determined by the rule already stated above.

-   In the remaining cases, where neither an infinity, nor a zero, nor
      NAN is involved, the quotient is computed and rounded to the
      nearest representable value using IEEE 754 round-to-nearest mode.
      If the magnitude is too large to represent, the operation
      overflows; the result is then an infinity of appropriate sign. If
      the magnitude is too small to represent, the operation underflows
      and the result is a zero of the appropriate sign. The ECMAScript
      language requires support of gradual underflow as defined by IEEE
      754.

The % operator yields the remainder of its operands from an implied
division; the left operand is the dividend and the right operand is the
divisor.

NOTE In C and C++, the remainder operator accepts only integral
operands; in ECMAScript, it also accepts floating-point operands.

The result of a floating-point remainder operation as computed by the %
operator is not the same as the “remainder” operation defined by IEEE
754. The IEEE 754 “remainder” operation computes the remainder from a
rounding division, not a truncating division, and so its behaviour is
not analogous to that of the usual integer remainder operator. Instead
the ECMAScript language defines % on floating-point operations to behave
in a manner analogous to that of the Java integer remainder operator;
this may be compared with the C library function fmod.

The result of an ECMAScript floating-point remainder operation is
determined by the rules of IEEE arithmetic:

-   If either operand is NAN, the result is NAN.

    -   The sign of the result equals the sign of the dividend.

    -   If the dividend is an infinity, or the divisor is a zero, or
          both, the result is NAN.

    -   If the dividend is finite and the divisor is an infinity, the
          result equals the dividend.

    -   If the dividend is a zero and the divisor is nonzero and finite,
          the result is the same as the dividend.

    -   In the remaining cases, where neither an infinity, nor a zero,
          nor NAN is involved, the floating-point remainder r from a
          dividend n and a divisor d is defined by the mathematical
          relation r = n − (d × q) where q is an integer that is
          negative only if n/d is negative and positive only if n/d is
          positive, and whose magnitude is as large as possible without
          exceeding the magnitude of the true mathematical quotient of n
          and d. r is computed and rounded to the nearest representable
          value using IEEE 754 round-to-nearest mode.

Syntax

AdditiveExpression :

MultiplicativeExpression
AdditiveExpression + MultiplicativeExpression
AdditiveExpression - MultiplicativeExpression

STATIC SEMANTICS: ISVALIDSIMPLEASSIGNMENTTARGET

AdditiveExpression :

AdditiveExpression + MultiplicativeExpression
AdditiveExpression - MultiplicativeExpression

1.  Return FALSE.

NOTE The addition operator either performs string concatenation or
numeric addition.

RUNTIME SEMANTICS: EVALUATION

AdditiveExpression : AdditiveExpression + MultiplicativeExpression

NOTE 1 No hint is provided in the calls to ToPrimitive in steps 5 and 6.
All native ECMAScript objects except Date objects handle the absence of
a hint as if the hint Number were given; Date objects handle the absence
of a hint as if the hint String were given. Exotic objects may handle
the absence of a hint in some other manner.

NOTE 2 Step 7 differs from step 3 of the comparison algorithm for the
relational operators (11.8.1), by using the logical-or operation instead
of the logical-and operation.

RUNTIME SEMANTICS: EVALUATION

AdditiveExpression : AdditiveExpression - MultiplicativeExpression

The + operator performs addition when applied to two operands of numeric
type, producing the sum of the operands. The - operator performs
subtraction, producing the difference of two numeric operands.

Addition is a commutative operation, but not always associative.

The result of an addition is determined using the rules of IEEE 754
binary double-precision arithmetic:

-   If either operand is NAN, the result is NAN.

-   The sum of two infinities of opposite sign is NAN.

-   The sum of two infinities of the same sign is the infinity of that
      sign.

-   The sum of an infinity and a finite value is equal to the infinite
      operand.

-   The sum of two negative zeroes is −0. The sum of two positive
      zeroes, or of two zeroes of opposite sign, is +0.

-   The sum of a zero and a nonzero finite value is equal to the nonzero
      operand.

-   The sum of two nonzero finite values of the same magnitude and
      opposite sign is +0.

-   In the remaining cases, where neither an infinity, nor a zero, nor
      NaN is involved, and the operands have the same sign or have
      different magnitudes, the sum is computed and rounded to the
      nearest representable value using IEEE 754 round-to-nearest mode.
      If the magnitude is too large to represent, the operation
      overflows and the result is then an infinity of appropriate sign.
      The ECMAScript language requires support of gradual underflow as
      defined by IEEE 754.

The - operator performs subtraction when applied to two operands of
numeric type, producing the difference of its operands; the left operand
is the minuend and the right operand is the subtrahend. Given numeric
operands a and b, it is always the case that a–b produces the same
result as _a +(–b)_.

Syntax

ShiftExpression :

AdditiveExpression
ShiftExpression << AdditiveExpression
ShiftExpression >> AdditiveExpression
ShiftExpression >>> AdditiveExpression

STATIC SEMANTICS: ISVALIDSIMPLEASSIGNMENTTARGET

ShiftExpression :

ShiftExpression << AdditiveExpression
ShiftExpression >> AdditiveExpression
ShiftExpression >>> AdditiveExpression

1.  Return FALSE.

NOTE Performs a bitwise left shift operation on the left operand by the
amount specified by the right operand.

RUNTIME SEMANTICS: EVALUATION

ShiftExpression : ShiftExpression << AdditiveExpression

NOTE Performs a sign-filling bitwise right shift operation on the left
operand by the amount specified by the right operand.

RUNTIME SEMANTICS: EVALUATION

ShiftExpression : ShiftExpression >> AdditiveExpression

NOTE Performs a zero-filling bitwise right shift operation on the left
operand by the amount specified by the right operand.

RUNTIME SEMANTICS: EVALUATION

ShiftExpression : ShiftExpression >>> AdditiveExpression

NOTE The result of evaluating a relational operator is always of type
Boolean, reflecting whether the relationship named by the operator holds
between its two operands.

Syntax

RelationalExpression :

ShiftExpression
RelationalExpression < ShiftExpression
RelationalExpression > ShiftExpression
RelationalExpression <= ShiftExpression
RelationalExpression >= ShiftExpression
RelationalExpression INSTANCEOF ShiftExpression
RelationalExpression IN ShiftExpression

RelationalExpressionNoIn :

ShiftExpression
RelationalExpressionNoIn < ShiftExpression
RelationalExpressionNoIn > ShiftExpression
RelationalExpressionNoIn <= ShiftExpression
RelationalExpressionNoIn >= ShiftExpression
RelationalExpressionNoIn INSTANCEOF ShiftExpression

The semantics of the RelationalExpressionNoIn productions are the same
as the RelationalExpression productions except that the contained
RelationalExpressionNoIn is used in place of the contained
RelationalExpression.

NOTE The “NoIn” variants are needed to avoid confusing the in operator
in a relational expression with the in operator in a for statement.

STATIC SEMANTICS: ISVALIDSIMPLEASSIGNMENTTARGET

RelationalExpression :

RelationalExpression < ShiftExpression
RelationalExpression > ShiftExpression
RelationalExpression <= ShiftExpression
RelationalExpression >= ShiftExpression
RelationalExpression INSTANCEOF ShiftExpression
RelationalExpression IN ShiftExpression

1.  Return FALSE.

RUNTIME SEMANTICS: THE ABSTRACT RELATIONAL COMPARISON ALGORITHM

The comparison x < y, where x and y are values, produces TRUE,
FALSE, or UNDEFINED (which indicates that at least one operand is NAN).
In addition to x and y the algorithm takes a Boolean flag named
LeftFirst as a parameter. The flag is used to control the order in
which operations with potentially visible side-effects are performed
upon x and y. It is necessary because ECMAScript specifies left to
right evaluation of expressions. The default value of LeftFirst is
TRUE and indicates that the x parameter corresponds to an expression
that occurs to the left of the y parameter’s corresponding expression.
If LeftFirst is FALSE, the reverse is the case and operations must be
performed upon y before x. Such a comparison is performed as
follows:

NOTE 1 Step 3 differs from step 7 in the algorithm for the addition
operator + (11.6.1) in using and instead of or.

NOTE 2 The comparison of Strings uses a simple lexicographic ordering on
sequences of code unit values. There is no attempt to use the more
complex, semantically oriented definitions of character or string
equality and collating order defined in the Unicode specification.
Therefore String values that are canonically equal according to the
Unicode standard could test as unequal. In effect this algorithm assumes
that both Strings are already in normalised form. Also, note that for
strings containing supplementary characters, lexicographic ordering on
sequences of UTF-16 code unit values differs from that on sequences of
code point values.

RUNTIME SEMANTICS: EVALUATION

RelationalExpression : RelationalExpression < ShiftExpression

RelationalExpression : RelationalExpression > ShiftExpression

RelationalExpression : RelationalExpression <= ShiftExpression

RelationalExpression : RelationalExpression >= ShiftExpression

RelationalExpression: RelationalExpression INSTANCEOF
ShiftExpression

RelationalExpression : RelationalExpression IN ShiftExpression

NOTE The result of evaluating an equality operator is always of type
Boolean, reflecting whether the relationship named by the operator holds
between its two operands.

Syntax

EqualityExpression :

RelationalExpression
EqualityExpression == RelationalExpression
EqualityExpression != RelationalExpression
EqualityExpression === RelationalExpression
EqualityExpression !== RelationalExpression
EqualityExpression [no LineTerminator here] IS RelationalExpression
EqualityExpression [no LineTerminator here] ISNT RelationalExpression

EqualityExpressionNoIn :

RelationalExpressionNoIn
EqualityExpressionNoIn == RelationalExpressionNoIn
EqualityExpressionNoIn != RelationalExpressionNoIn
EqualityExpressionNoIn === RelationalExpressionNoIn
EqualityExpressionNoIn !== RelationalExpressionNoIn
EqualityExpression [no LineTerminator here] IS RelationalExpression
EqualityExpression [no LineTerminator here] ISNT RelationalExpression

The semantics of the EqualityExpressionNoIn productions are the same
as the EqualityExpression productions except that the contained
EqualityExpressionNoIn and RelationalExpressionNoIn are used in
place of the contained EqualityExpression and RelationalExpression,
respectively.

STATIC SEMANTICS: ISVALIDSIMPLEASSIGNMENTTARGET

EqualityExpression :

EqualityExpression == RelationalExpression
EqualityExpression != RelationalExpression
EqualityExpression === RelationalExpression
EqualityExpression !== RelationalExpression
EqualityExpression [no LineTerminator here] IS RelationalExpression
EqualityExpression [no LineTerminator here] ISNT RelationalExpression

1.  Return FALSE.

RUNTIME SEMANTICS: THE ABSTRACT EQUALITY COMPARISON ALGORITHM

The comparison x == y, where x and y are values, produces TRUE
or FALSE. Such a comparison is performed as follows:

NOTE 1 Given the above definition of equality:

-   String comparison can be forced by: "" + A == "" + B.

-   Numeric comparison can be forced by: +A == +B.

-   Boolean comparison can be forced by: !A == !B.

NOTE 2 The equality operators maintain the following invariants:

-   A != B is equivalent to !(A == B).

-   A == B is equivalent to B == A, except in the order of evaluation of
      A and B.

NOTE 3 The equality operator is not always transitive. For example,
there might be two distinct String objects, each representing the same
String value; each String object would be considered equal to the String
value by the == operator, but the two String objects would not be equal
to each other. For Example:

-   NEW STRING("A") == "A" and "A" == NEW STRING("A")are both TRUE.

-   NEW STRING("A") == NEW STRING("A") is FALSE.

NOTE 4 Comparison of Strings uses a simple equality test on sequences of
code unit values. There is no attempt to use the more complex,
semantically oriented definitions of character or string equality and
collating order defined in the Unicode specification. Therefore Strings
values that are canonically equal according to the Unicode standard
could test as unequal. In effect this algorithm assumes that both
Strings are already in normalised form.

RUNTIME SEMANTICS: THE STRICT EQUALITY COMPARISON ALGORITHM

The comparison x === y, where x and y are values, produces TRUE
or FALSE. Such a comparison is performed as follows:

NOTE This algorithm differs from the SameValue Algorithm (9.12) in its
treatment of signed zeroes and NaNs.

RUNTIME SEMANTICS: EVALUATION

EqualityExpression : EqualityExpression == RelationalExpression

EqualityExpression : EqualityExpression != RelationalExpression

EqualityExpression : EqualityExpression === RelationalExpression

EqualityExpression : EqualityExpression !== RelationalExpression

EqualityExpression : EqualityExpression [no LineTerminator here]
IS RelationalExpression

1.  Let lref be the result of evaluating EqualityExpression.

2.  Let lval be GetValue(lref).

3.  ReturnIfAbrupt(lval).

4.  Let rref be the result of evaluating RelationalExpression.

5.  Let rval be GetValue(rref).

6.  7.  Return the result of performing SameValue(rval, lval).

EqualityExpression : EqualityExpression [no LineTerminator here]
ISNT RelationalExpression

1.  Let lref be the result of evaluating EqualityExpression.

2.  Let lval be GetValue(lref).

3.  ReturnIfAbrupt(lval).

4.  Let rref be the result of evaluating RelationalExpression.

5.  Let rval be GetValue(rref).

6.  Let r be the result of performing SameValue(rval, lval).

7.  ReturnIfAbrupt(r).

8.  If r is TRUE, return FALSE. Otherwise, return TRUE.

Syntax

BitwiseANDExpression :

EqualityExpression
BitwiseANDExpression & EqualityExpression

BitwiseANDExpressionNoIn :

EqualityExpressionNoIn
BitwiseANDExpressionNoIn & EqualityExpressionNoIn

BitwiseXORExpression :

BitwiseANDExpression
BitwiseXORExpression ^ BitwiseANDExpression

BitwiseXORExpressionNoIn :

BitwiseANDExpressionNoIn
BitwiseXORExpressionNoIn ^ BitwiseANDExpressionNoIn

BitwiseORExpression :

BitwiseXORExpression
BitwiseORExpression | BitwiseXORExpression

BitwiseORExpressionNoIn :

BitwiseXORExpressionNoIn
BitwiseORExpressionNoIn | BitwiseXORExpressionNoIn

STATIC SEMANTICS: ISVALIDSIMPLEASSIGNMENTTARGET

BitwiseANDExpression : BitwiseANDExpression & EqualityExpression

BitwiseXORExpression : BitwiseXORExpression ^ BitwiseANDExpression

BitwiseORExpression : BitwiseORExpression | BitwiseXORExpression

1.  Return FALSE.

RUNTIME SEMANTICS: EVALUATION

The production A : _A @ B_, where @ is one of the bitwise operators in
the productions above, is evaluated as follows:

Syntax

LogicalANDExpression :

BitwiseORExpression
LogicalANDExpression && BitwiseORExpression

LogicalANDExpressionNoIn :

BitwiseORExpressionNoIn
LogicalANDExpressionNoIn && BitwiseORExpressionNoIn

LogicalORExpression :

LogicalANDExpression
LogicalORExpression || LogicalANDExpression

LogicalORExpressionNoIn :

LogicalANDExpressionNoIn
LogicalORExpressionNoIn || LogicalANDExpressionNoIn

The semantics of the LogicalANDExpressionNoIn and
LogicalORExpressionNoIn productions are the same manner as the
LogicalANDExpression and LogicalORExpression productions except that
the contained LogicalANDExpressionNoIn, BitwiseORExpressionNoIn and
LogicalORExpressionNoIn are used in place of the contained
LogicalANDExpression, BitwiseORExpression and LogicalORExpression,
respectively.

NOTE The value produced by a && or || operator is not necessarily of
type Boolean. The value produced will always be the value of one of the
two operand expressions.

STATIC SEMANTICS: ISVALIDSIMPLEASSIGNMENTTARGET

LogicalANDExpression : LogicalANDExpression && BitwiseORExpression

LogicalORExpression : LogicalORExpression || LogicalANDExpression

1.  Return FALSE.

RUNTIME SEMANTICS: EVALUATION

LogicalANDExpression : LogicalANDExpression && BitwiseORExpression

LogicalORExpression : LogicalORExpression || LogicalANDExpression

Syntax

ConditionalExpression :

LogicalORExpression
LogicalORExpression ? AssignmentExpression : AssignmentExpression

ConditionalExpressionNoIn :

LogicalORExpressionNoIn
LogicalORExpressionNoIn ? AssignmentExpression :
AssignmentExpressionNoIn

The semantics of the ConditionalExpressionNoIn production is the same
as the ConditionalExpression production except that the contained
LogicalORExpressionNoIn, AssignmentExpression and
AssignmentExpressionNoIn are used in place of the contained
LogicalORExpression, first AssignmentExpression and second
AssignmentExpression, respectively.

NOTE The grammar for a ConditionalExpression in ECMAScript is a little
bit different from that in C and Java, which each allow the second
subexpression to be an Expression but restrict the third expression to
be a ConditionalExpression. The motivation for this difference in
ECMAScript is to allow an assignment expression to be governed by either
arm of a conditional and to eliminate the confusing and fairly useless
case of a comma expression as the centre expression.

STATIC SEMANTICS: ISVALIDSIMPLEASSIGNMENTTARGET

ConditionalExpression : LogicalORExpression ? AssignmentExpression :
AssignmentExpression

1.  Return FALSE.

RUNTIME SEMANTICS: EVALUATION

ConditionalExpression : LogicalORExpression ? AssignmentExpression
: AssignmentExpression

Syntax

AssignmentExpression :

ConditionalExpression
YieldExpression
ArrowFunction
LeftHandSideExpression = AssignmentExpression
LeftHandSideExpression AssignmentOperator AssignmentExpression

AssignmentExpressionNoIn :

ConditionalExpressionNoIn
YieldExpression
ArrowFunction
LeftHandSideExpression = AssignmentExpressionNoIn
LeftHandSideExpression AssignmentOperator AssignmentExpressionNoIn

AssignmentOperator : ONE OF

  ---- ---- ---- ---- ---- ----- ----- ------ ---- ---- ----
  *=   /=   %=   +=   -=   <<=   >>=   >>>=   &=   ^=   |=
  ---- ---- ---- ---- ---- ----- ----- ------ ---- ---- ----

The semantics of the AssignmentExpressionNoIn productions are the same
manner as the AssignmentExpression productions except that the
contained ConditionalExpressionNoIn and AssignmentExpressionNoIn are
used in place of the contained ConditionalExpression and
AssignmentExpression, respectively.

STATIC SEMANTICS: EARLY ERRORS

-   -   

-   -   -   -   -   -   

AssignmentExpression : LeftHandSideExpression = AssignmentExpression

-   It is a Syntax Error if LeftHandSideExpression is either an
    ObjectLiteral or an ArrayLiteral and if the lexical token
    sequence matched by LeftHandSideExpression cannot be parsed with
    no tokens left over using AssignmentPattern as the goal symbol.

-   If LeftHandSideExpression is either an ObjectLiteral or an
    ArrayLiteral and if the lexical token sequence matched by
    LeftHandSideExpression can be parsed with no tokens left over
    using AssignmentPattern as the goal symbol then the following
    rules are not applied. Instead, the Early Error rules for
    AssignmentPattern are used.

-   It is a Syntax Error if LeftHandSideExpression is an Identifier
    that can be statically determined to always resolve to a declarative
    environment record binding and the resolved binding is an immutable
    binding.

-   It is an early Reference Error if LeftHandSideExpression is
    neither an ObjectLiteral nor an ArrayLiteral and
    IsValidSimpleAssignmentTarget of LeftHandSideExpression is FALSE.

-   

AssignmentExpression : LeftHandSideExpression AssignmentOperator
AssignmentExpression

-   It is a Syntax Error if the LeftHandSideExpression is an
    Identifier that can be statically determined to always resolve to
    a declarative environment record binding and the resolved binding is
    an immutable binding.

-   It is an early Reference Error if IsValidSimpleAssignmentTarget of
    LeftHandSideExpression is FALSE.

STATIC SEMANTICS: ISVALIDSIMPLEASSIGNMENTTARGET

AssignmentExpression :

YieldExpression
ArrowFunction
LeftHandSideExpression = AssignmentExpression
LeftHandSideExpression AssignmentOperator AssignmentExpression

1.  Return FALSE.

RUNTIME SEMANTICS: EVALUATION

AssignmentExpression : LeftHandSideExpression =
AssignmentExpression

AssignmentExpression : _LeftHandSideExpression AssignmentOperator
AssignmentExpression_

-   -   -   -   

NOTE When an assignment occurs within strict mode code, it is an runtime
error if lref in step 1.e of the first algorithm or step 9 of the
second algorithm it is an unresolvable reference. If it is, a
REFERENCEERROR exception is thrown. The LeftHandSide also may not be a
reference to a data property with the attribute value
{[[Writable]]:FALSE}, to an accessor property with the attribute value
{[[Set]]:UNDEFINED}, nor to a non-existent property of an object whose
[[Extensible]] internal property has the value FALSE. In these cases a
TYPEERROR exception is thrown.

Supplemental Syntax

In certain circumstances when processing the production
AssignmentExpression : LeftHandSideExpression =
AssignmentExpression the following grammar is used to refine the
interpretation of LeftHandSideExpression.

AssignmentPattern :

ObjectAssignmentPattern
ArrayAssignmentPattern

ObjectAssignmentPattern :

{ }
{ AssignmentPropertyList }
{ AssignmentPropertyList , }

ArrayAssignmentPattern :

[ Elision~opt~ AssignmentRestElement~opt~ ]
[ AssignmentElementList ]
[ AssignmentElementList , Elision~opt~ AssignmentRestElement~opt~ ]

AssignmentPropertyList :

AssignmentProperty
AssignmentPropertyList , AssignmentProperty

AssignmentElementList :

Elision~opt~ AssignmentElement
AssignmentElementList , Elision~opt~ AssignmentElement

AssignmentProperty :

Identifier Initialiser~opt~
PropertyName : AssignmentElement

AssignmentElement :

DestructuringAssignmentTarget Initialiser~opt~

AssignmentRestElement :

… DestructuringAssignmentTarget

DestructuringAssignmentTarget :

LeftHandSideExpression

STATIC SEMANTICS: EARLY ERRORS

AssignmentProperty : Identifier Initialiser~opt~

-   It is a Syntax Error if Identifier is the Identifier EVAL or the
    Identifier ARGUMENTS.

-   -   It is a Syntax Error if Identifier does not statically resolve
    to a declarative environment record binding or if the resolved
    binding is an immutable binding.

DestructuringAssignmentTarget : LeftHandSideExpression

-   It is a Syntax Error LeftHandSideExpression is either an
    ObjectLiteral or an ArrayLiteral and if the lexical token
    sequence matched by LeftHandSideExpression cannot be parsed with
    no tokens left over using AssignmentPattern as the goal symbol.

-   It is a Syntax Error if LeftHandSideExpression is neither an
    ObjectLiteral nor an ArrayLiteral and
    IsValidSimpleAssignmentTarget of LeftHandSideExpression is FALSE.

-   It is a Syntax Error if the LeftHandSideExpression is an
    Identifier that can be statically determined to always resolve to
    a declarative environment record binding and the resolved binding is
    an immutable binding.

-   It is a Syntax Error if LeftHandSideExpression is the Identifier
    EVAL or the Identifier ARGUMENTS.

-   -   -   -   It is a Syntax Error if IsInvalidAssignmentPattern of
    LeftHandSideExpression is TRUE.

-   It is a Syntax Error if the LeftHandSideExpression is
    CoverParenthesizedExpressionAndArrowParameterList : ( Expression
    )
    and Expression derived a production that would produce a Syntax
    Error according to these rules. This rule is recursively applied.

-   -   -   -   -   

RUNTIME SEMANTICS: DESTRUCTURING ASSIGNMENT EVALUATION

  with parameter obj

1.  2.  

1.  2.  

ObjectAssignmentPattern : { }

and

ArrayAssignmentPattern :

[]
[Elision]

1.  Return NormalCompletion(empty).

1.  2.  

1.  2.  

AssignmentPropertyList : AssignmentPropertyList ,
AssignmentProperty

  Let status be

1.  the result of performing Destructuring Assignment Evaluation for
    AssignmentPropertyList using obj as the argument.

2.  ReturnIfAbrupt(status).

3.  Return the result of performing Destructuring Assignment Evaluation
    for AssignmentProperty using obj as the argument.

AssignmentProperty : Identifier Initialiser~opt~

1.  Let P be StringValue of Identifier.

2.  3.  4.  5.  Let v be the result of calling the [[Get]] internal
    method of obj with argument P.

6.  ReturnIfAbrupt(v).

7.  8.  If Initialiser~opt~ is present and v is UNDEFINED, then

    a.  Let defaultValue be the result of evaluating Initialiser.

    b.  Let v be ToObject(defaultValue).

        i.  

9.  ReturnIfAbrupt(v).

10. Let lref be the result of performing Identifier Resolution(10.3.1)
    with the IdentifierName corresponding to Identifier.

11. Return PutValue(lref_,_v).

12. 

-   -   -   -   -   -   

AssignmentProperty : PropertyName : AssignmentElement

1.  Let name be PropName of PropertyName.

2.  Return the result of performing Keyed Destructuring Assignment
    Evaluation of AssignmentElement with obj and name as the
    arguments.

3.  4.  5.  a.  b.  c.  d.  e.  

6.  7.  8.  

ArrayAssignmentPattern : [ Elision~opt~ AssignmentRestElement ]

1.  Let skip be the Elision Width of Elision; if Elision is not
    present, use the numeric value zero.

2.  Return the result of performing Indexed Destructuring Assignment
    Evaluation of AssignmentRestElement with obj and skip as the
    arguments.

3.  

ArrayAssignmentPattern : [ AssignmentElementList ]

1.  Return the result of performing Indexed Destructuring Assignment
    Evaluation of AssignmentElementList using obj and 0 as the
    arguments.

2.  

ArrayAssignmentPattern : [ AssignmentElementList , Elision~opt~
AssignmentRestElement~opt~ ]

1.  2.  Let lastIndex be the result of performing Indexed
    Destructuring Assignment Evaluation of AssignmentElementList using
    obj and 0 as the arguments.

3.  ReturnIfAbrupt(lastIndex).

4.  Let skip be the Elision Width of Elision; if Elision is not
    present, use the numeric value zero.

5.  If AssignmentRestElement is present, then return the result of
    performing Indexed Destructuring Assignment Evaluation of
    AssignmentRestElement with obj and lastIndex_+_skip as the
    arguments.

6.  7.  Return lastIndex.

RUNTIME SEMANTICS: INDEXED DESTRUCTURING ASSIGNMENT EVALUATION

  with parameters obj and index

AssignmentElementList : Elision~opt~ _AssignmentElement _

1.  Let skip be the Elision Width of Elision; if Elision is not
    present, use the numeric value zero.

2.  Let name be ToString(index_+_skip).

3.  Let status be the result of performing Keyed Destructuring
    Assignment Evaluation of AssignmentElement with obj and name
    as the arguments.

4.  ReturnIfAbrupt(status).

5.  Return index_+_skip+1.

6.  

AssignmentElementList : AssignmentElementList , Elision~opt~
_AssignmentElement _

1.  Let listNext be the result of performing Indexed Destructuring
    Assignment Evaluation of AssignmentElementList using obj as the
    obj parameter and index as the index parameter

2.  Let skip be the Elision Width of Elision; if Elision is not
    present, use the numeric value zero.

3.  ReturnIfAbrupt(listNext).

4.  Let name be ToString(listNext_+_skip).

5.  Let status be the result of performing Keyed Destructuring
    Assignment Evaluation of AssignmentElement with obj and name
    as the arguments.

6.  ReturnIfAbrupt(status).

7.  Return listNext_+_skip+1.

8.  

1.  2.  3.  4.  5.  6.  a.  b.  i.  

7.  8.  9.  10. a.  b.  c.  d.  e.  

11. 12. 13. 

AssignmentRestElement : … DestructuringAssignmentTarget

1.  Let lref be the result of evaluating
    DestructuringAssignmentTarget.

2.  ReturnIfAbrupt(lref).

3.  Let lenVal be the result of calling the [[Get]] internal method of
    obj with argument “LENGTH”.

4.  Let len be ToUint32(lenVal).

5.  ReturnIfAbrupt(len).

6.  Let A be the result of the abstract operation ArrayCreate (15.4)
    with argument 0.

7.  Let n=0;

8.  Repeat, while index < len

    a.  Let P be ToString(index).

    b.  Let exists be the result of calling the [[HasProperty]]
        internal method of obj with argument P.

    c.  If exists is TRUE, then

        i.  Let v be the result of calling the [[Get]] internal method
              of obj passing ToString(index) as the argument.

        ii. ReturnIfAbrupt(len).

        iii. Call the [[DefineOwnProperty]] internal method of A with
              arguments ToString(n), Property Descriptor {[[Value]]:
              v, [[Writable]]: TRUE, [[Enumerable]]: TRUE,
              [[Configurable]]: TRUE}, and FALSE.

    d.  Let n = n+1.

    e.  Let index = index+1.

9.  Return PutValue(lref_,_A).

10. 

RUNTIME SEMANTICS: KEYED DESTRUCTURING ASSIGNMENT EVALUATION

  with parameters obj and propertyName

AssignmentElement : DestructuringAssignmentTargetInitialiser~opt~

1.  Let v be the result of calling the [[Get]] internal method of
    obj with argument propertyName.

2.  ReturnIfAbrupt(v).

3.  If Initialiser~opt~ is present and v is UNDEFINED, then

    a.  Let v be the result of evaluating Initialiser.

4.  If DestructuringAssignmentTarget is an ObjectLiteral or an
    ArrayLiteral then

    a.  Let AssignmentPattern be the parse of the source code
        corresponding to DestructuringAssignmentTarget using
        AssignmentPattern as the goal symbol

    b.  Let vObj be ToObject(v).

    c.  ReturnIfAbrupt(vObj).

    d.  Return the result of performing Destructuring Assignment
        Evaluation of AssignmentPattern with vObj as the argument.

5.  ReturnIfAbrupt(v).

6.  Let lref be the result of evaluating
    DestructuringAssignmentTarget.

7.  Return PutValue(lref_,_v).

Syntax

Expression :

AssignmentExpression
Expression , AssignmentExpression

ExpressionNoIn :

AssignmentExpressionNoIn
ExpressionNoIn , AssignmentExpressionNoIn

The semantics of the ExpressionNoIn production is the same manner as
the Expression production except that the contained ExpressionNoIn
and AssignmentExpressionNoIn are used in place of the contained
Expression and AssignmentExpression, respectively.

STATIC SEMANTICS: ISVALIDSIMPLEASSIGNMENTTARGET

Expression : Expression , AssignmentExpression

1.  Return FALSE.

RUNTIME SEMANTICS: EVALUATION

Expression : Expression , AssignmentExpression

NOTE GetValue must be called even though its value is not used because
it may have observable side-effects.

Syntax

Statement :

BlockStatement
VariableStatement
EmptyStatement
ExpressionStatement
IfStatement
BreakableStatement
ContinueStatement
BreakStatement
ReturnStatement
WithStatement
LabelledStatement
ThrowStatement
TryStatement
DebuggerStatement

Declaration :

FunctionDeclaration
GeneratorDeclaration
ClassDeclaration
LexicalDeclaration

BreakableStatement :

IterationStatement
SwitchStatement

1.  

STATIC SEMANTICS: VARDECLAREDNAMES

Statement :

EmptyStatement
ExpressionStatement
ContinueStatement
BreakStatement
ReturnStatement
ThrowStatement
DebuggerStatement

1.  Return a new empty List.

1.  

1.  

RUNTIME SEMANTICS: LABELLED EVALUATION

  With argument labelSet.

BreakableStatement : IterationStatement

1.  Let stmtResult be the result of performing Labelled Evaluation of
    IterationStatement with argument labelSet.

2.  If stmtResult.[[type]] is break and stmtResult.[[target]] is
    empty, then

    a.  Let stmtResult be NormalCompletion(stmtResult.[[value]])

3.  Return stmtResult.

BreakableStatement : SwitchStatement

1.  Let stmtResult be the result of evaluating SwitchStatement.

2.  If stmtResult.[[type]] is break and stmtResult.[[target]] is
    empty, then

    a.  Let stmtResult be NormalCompletion(stmtResult.[[value]])

3.  Return stmtResult.

NOTE A BreakableStatement is one that can be exited via an unlabelled
BreakStatement.

RUNTIME SEMANTICS: EVALUATION

1.  

1.  

BreakableStatement :

IterationStatement
SwitchStatement

1.  Let newLabelSet be a new empty List.

2.  Return the result of performing Labelled Evaluation of this
    BreakableStatement with argument newLabelSet.

1.  

1.  

Syntax

BlockStatement :

Block

Block :

{ StatementList~opt~ }

StatementList :

StatementListItem
StatementList StatementListItem

StatementListItem :

Statement
Declaration

STATIC SEMANTICS: EARLY ERRORS

Block : { StatementList }

-   -   It is a Syntax Error if the LexicallyDeclaredNames of
    StatementList contains any duplicate entries.

-   It is a Syntax Error if any element of the LexicallyDeclaredNames of
    StatementList also occurs in the VarDeclaredNames of
    StatementList.

STATIC SEMANTICS: LEXICALDECLARATIONS

1.  

StatementList : _StatementList StatementListItem_

1.  Let declarations be LexicalDeclarations of StatementList.

2.  Append to declarations the elements of the LexicalDeclarations of
    StatementListItem.

3.  Return declarations.

StatementListItem : Statement

1.  Return a new empty List.

StatementListItem : Declaration

1.  Return a new List containing Declaration.

1.  

1.  

STATIC SEMANTICS: LEXICALLYDECLAREDNAMES

Block : { }

1.  Return a new empty List.

1.  

1.  

StatementList : _StatementList StatementListItem_

1.  Let names be LexicallyDeclaredNames of StatementList.

2.  Append to names the elements of the LexicallyDeclaredNames of
    StatementListItem.

3.  Return names.

StatementListItem : Statement

1.  Return a new empty List.

StatementListItem : Declaration

1.  Return the BoundNames of Declaration.

STATIC SEMANTICS: TOPLEVELLEXICALLYDECLAREDNAMES

StatementList : _StatementList StatementListItem_

1.  Let names be TopLevelLexicallyDeclaredNames of StatementList.

2.  Append to names the elements of the TopLevelLexicallyDeclaredNames
    of StatementListItem.

3.  Return names.

StatementListItem : Statement

1.  Return a new empty List.

StatementListItem : Declaration

1.  If Declaration is Declaration : FunctionDeclaration, then
    return a new empty List.

2.  Return the BoundNames of Declaration.

NOTE At the top level of a function, or script, function declarations
are treated like var declarations rather than like lexical
declarations..

STATIC SEMANTICS: TOPLEVELLEXICALLYSCOPEDDECLARATIONS

StatementList : _StatementList StatementListItem_

1.  Let declarations be TopLevelLexicallyScopedDeclarations of
    StatementList.

2.  Append to declarations the elements of the
    TopLevelLexicallyScopedDeclarations of StatementListItem.

3.  Return declarations.

StatementListItem : Statement

1.  Return a new empty List.

StatementListItem : Declaration

1.  If Declaration is Declaration : FunctionDeclaration, then
    return a new empty List.

2.  Return a new List containing Declaration.

STATIC SEMANTICS: TOPLEVELVARDECLAREDNAMES

StatementList : _StatementList StatementListItem_

1.  Let names be TopLevelVarDeclaredNames of StatementList.

2.  Append to names the elements of the TopLevelVarDeclaredNames of
    StatementListItem.

3.  Return names.

StatementListItem : Declaration

1.  If Declaration is Declaration : FunctionDeclaration, then
    return the LexicallyDeclaredNames of Declaration.

2.  Return a new empty List.

StatementListItem : Statement

1.  Return VarDeclaredNames of Statement.

NOTE At the top level of a function or script, inner function
declarations are treated like var declarations.

STATIC SEMANTICS: TOPLEVELVARSCOPEDDECLARATIONS

StatementList : _StatementList StatementListItem_

1.  Let declarations be TopLevelVarScopedDeclarations of
    StatementList.

2.  Append to declarations the elements of the
    TopLevelVarScopedDeclarations of StatementListItem.

3.  Return declarations.

StatementListItem : Statement

1.  If Statement is Statement : VariableStatement, then return a
    new List containing VariableStatement.

2.  Return a new empty List.

StatementListItem : Declaration

1.  If Declaration is Declaration : FunctionDeclaration, then
    return a new List containing Declaration.

2.  Return a new empty List.

STATIC SEMANTICS: VARDECLAREDNAMES

1.  

Block : { }

1.  Return a new empty List.

1.  

1.  

StatementList : _StatementList StatementListItem_

1.  Let names be VarDeclaredNames of StatementList.

2.  Append to names the elements of the VarDeclaredNames of
    StatementListItem.

3.  Return names.

1.  

StatementListItem : Declaration

1.  Return a new empty List.

RUNTIME SEMANTICS: EVALUATION

1.  

Block : { }

1.  Return NormalCompletion(empty).

-   -   -   

1.  

1.  

Block : { StatementList }

NOTE No matter how control leaves the Block the LexicalEnvironment is
always restored to its former state.

1.  

1.  

1.  

1.  2.  3.  

1.  2.  3.  

1.  2.  3.  

StatementList : _StatementList StatementListItem_

NOTE Steps 4 and 5 of the above algoritm ensure that the value of a
StatementList is the value of the last value producing Statement in
the StatementList. For example, the following calls to the EVAL
function all return the value 1:

  EVAL("1;;;;;")

  EVAL("1;{}")

  EVAL("1;VAR A;")

1.  

1.  

1.  

1.  

1.  

1.  

1.  

NOTE A LET and CONST declarations define variables that are scoped to
the running execution context’s LexicalEnvironment. The variables are
created when their containing Lexical Environment is instantiated but
may not be accessed in any way until the variable’s LexicalBinding is
evaluated. A variable defined by a LexicalBinding with an
Initialiser is assigned the value of its Initialiser’s
AssignmentExpression when the LexicalBinding is evaluated, not when
the variable is created. If a LexicalBinding in a LET declaration does
not have an an Initialiser the variable is assigned the value
UNDEFINED when the LexicalBinding is evaluated.

Syntax

LexicalDeclaration :

LetOrConst BindingList ;

LexicalDeclarationNoIn :

LetOrConst BindingListNoIn

LetOrConst :

LET
CONST

BindingList :

LexicalBinding
BindingList , LexicalBinding

BindingListNoIn :

LexicalBindingNoIn
BindingListNoIn , LexicalBindingNoIn

LexicalBinding :

BindingIdentifier Initialiser~opt
~BindingPattern Initialiser

LexicalBindingNoIn :

BindingIdentifier InitialiserNoIn~opt
~BindingPattern InitialiserNoIn

BindingIdentifier :

Identifier

InitialiserNoIn :

= AssignmentExpressionNoIn

The semantics of the LexicalDeclarationNoIn, BindingListNoIn,
LexicalBindingNoIn and InitialiserNoIn productions are the same as
the LexicalDeclaration, BindingList, LexicalBinding and
Initialiser productions except that the contained BindingListNoIn,
LexicalBindingNoIn, InitialiserNoIn and AssignmentExpressionNoIn
are used in place of the contained BindingList, LexicalBinding,
Initialiser and AssignmentExpression, respectively.

STATIC SEMANTICS: EARLY ERRORS

LexicalBinding : BindingIdentifier

-   It is a Syntax Error if IsConstantDeclaration of the
    LexicalDeclaration containing this production is TRUE.

-   

BindingIdentifier : Identifier

-   It is a Syntax Error if the BindingIdentifier is contained in
    strict code and if the Identifier is EVAL or ARGUMENTS.

STATIC SEMANTICS: BOUNDNAMES

LexicalDeclaration : _LetOrConst BindingList_ ;

1.  Return the BoundNames of BindingList.

1.  

BindingList : BindingList , LexicalBinding

1.  Let names be the BoundNames of BindingList.

2.  Append to names the elements of the BoundNames of
    LexicalBinding.

3.  Return names.

LexicalBinding : _BindingIdentifier Initialiser_~opt~

1.  Return the BoundNames of BindingIdentifier.

LexicalBinding: _BindingPattern Initialiser_

1.  Return the BoundNames of BindingPattern.

BindingIdentifier : Identifier

1.  Return a new List containing the StringValue of Identifier.

STATIC SEMANTICS: ISCONSTANTDECLARATION

LexicalDeclaration : _LetOrConst BindingList_ ;

1.  Return IsConstantDeclaration of LetOrConst.

LetOrConst : LET

1.  Return FALSE.

LetOrConst : CONST

1.  Return TRUE.

1.  

RUNTIME SEMANTICS: BINDING INITIALISATION

  With arguments value and environment.

NOTE UNDEFINED is passed for environment to indicate that a PutValue
operation should be used to assign the initialisation value. This is the
case for VAR statements formal parameter lists of non-strict functions.
In those cases a lexical binding is hosted and preinitialized prior to
evaluation of its initializer.

BindingIdentifier : Identifier

1.  

1.  If environment is not UNDEFINED, then

    a.  Let name be StringValue of Identifier.

    b.  Let env be the environment record component of environment.

    c.  Call the InitializeBinding concrete method of env passing
        name and value as the arguments.

    d.  Return NormalCompletion(undefined).

2.  Else

    a.  Let lhs be the result of evaluating Identifier as described
        in 11.1.2.

    b.  Return PutValue(lhs, value).

RUNTIME SEMANTICS: EVALUATION

LexicalDeclaration : _LetOrConst BindingList_ ;

1.  Let next be the result of evaluating BindingList.

2.  ReturnIfAbrupt(next).

3.  Return NormalCompletion(empty).

1.  

BindingList : BindingList , LexicalBinding

1.  Let next be the result of evaluating BindingList.

2.  ReturnIfAbrupt(next).

3.  Return the result of evaluating LexicalBinding.

LexicalBinding : _BindingIdentifier _

1.  Let env be the running execution context’s LexicalEnvironment.

2.  Return the result of performing Binding Initialisation for
    BindingIdentifier passing UNDEFINED and env as the arguments.

NOTE A static semantics rule ensures that this form of LexicalBinding
never occurs in a CONST declaration.

LexicalBinding : _BindingIdentifier Initialiser_

1.  Let rhs be the result of evaluating Initialiser.

2.  Let value be GetValue(rhs).

3.  ReturnIfAbrupt(value).

4.  Let env be the running execution context’s LexicalEnvironment.

5.  Return the result of performing Binding Initialisation for
    BindingIdentifier passing value and env as the arguments.

LexicalBinding: _BindingPattern Initialiser_

1.  Let rhs be the result of evaluating Initialiser.

2.  Let value be ToObject(GetValue(rhs)).

3.  ReturnIfAbrupt(value).

4.  Let env be the running execution context’s LexicalEnvironment.

5.  Return the result of performing Binding Initialisation for
    BindingPattern using value and env as the arguments.

1.  

1.  

-   

1.  

1.  

1.  2.  3.  

1.  

1.  

1.  2.  

1.  

1.  

1.  2.  3.  

1.  2.  

1.  

1.  2.  3.  4.  

1.  

1.  2.  3.  4.  

NOTE A VAR statement declares variables that are scoped to the running
execution context’s VariableEnvironment. Var variables are created when
their containing Lexical Environment is instantiated and are initialised
to UNDEFINED when created. Within the scope of any VariableEnvironemnt a
common Identifier may appear in more than one VariableDeclaration
but those declarations collective define only one variable. A variable
defined by a VariableDeclaration with an Initialiser is assigned the
value of its Initialiser’s AssignmentExpression when the
VariableDeclaration is executed, not when the variable is created.

Syntax

VariableStatement :

VAR VariableDeclarationList ;

VariableDeclarationList :

VariableDeclaration
VariableDeclarationList , VariableDeclaration

VariableDeclarationListNoIn :

VariableDeclarationNoIn
VariableDeclarationListNoIn , VariableDeclarationNoIn

VariableDeclaration :

BindingIdentifier Initialiser~opt
~BindingPattern Initialiser

VariableDeclarationNoIn :

BindingIdentifier InitialiserNoIn~opt
~BindingPattern InitialiserNoIn

The semantics of the VariableDeclarationListNoIn,
VariableDeclarationNoIn and InitialiserNoIn productions are the same
as the VariableDeclarationList, VariableDeclaration and
Initialiser productions except that the contained
VariableDeclarationListNoIn, VariableDeclarationNoIn,
InitialiserNoIn and AssignmentExpressionNoIn are used in of the
contained VariableDeclarationList, VariableDeclaration,
Initialiser and AssignmentExpression, respectively.

-   

STATIC SEMANTICS: BOUNDNAMES

1.  

1.  

VariableDeclarationList : VariableDeclarationList ,
VariableDeclaration

1.  Let names be BoundNames of VariableDeclarationList.

2.  Append to names the elements of BoundNames of
    VariableDeclaration.

3.  Return names.

VariableDeclaration : _BindingIdentifier Initialiser_~opt~

1.  Return the BoundNames of BindingIdentifier.

VariableDeclaration : _BindingPattern Initialiser_

1.  Return the BoundNames of BindingPattern.

RUNTIME SEMANTICS: BINDING INITIALISATION

  With arguments value and environment.

NOTE UNDEFINED is passed for environment to indicate that a PutValue
operation should be used to assign the initialisation value. This is the
case for VAR statements formal parameter lists of non-strict functions.
In those cases a lexical binding is hosted and preinitialized prior to
evaluation of its initializer.

VariableDeclaration : BindingIdentifier

VariableDeclaration : _BindingIdentifier Initialiser_

1.  Return the result of performing Binding Initialisation for
    BindingIdentifier passing value and UNDEFINED as the arguments.

VariableDeclaration : _BindingPattern Initialiser_

1.  Return the result of performing Binding Initialisation for
    BindingPattern passing value and UNDEFINED as the arguments.

RUNTIME SEMANTICS: EVALUATION

VariableStatement : VAR VariableDeclarationList ;

1.  Let next be the result of evaluating VariableDeclarationList.

2.  ReturnIfAbrupt(next).

3.  Return NormalCompletion( empty).

1.  

1.  

1.  2.  3.  

VariableDeclarationList : VariableDeclarationList ,
VariableDeclaration

1.  Let next be the result of evaluating VariableDeclarationList.

2.  ReturnIfAbrupt(next).

3.  Return the result of evaluating VariableDeclaration.

1.  

VariableDeclaration : BindingIdentifier

1.  Return NormalCompletion(empty).

VariableDeclaration : _BindingIdentifier Initialiser_

1.  Let rhs be the result of evaluating Initialiser.

2.  Let value be GetValue(rhs).

3.  ReturnIfAbrupt(value).

4.  Return the result of performing Binding Initialisation for
    BindingIdentifier passing value and UNDEFINED as the arguments.

NOTE If a VariableDeclaration is nested within a with statement and
the Identifier in the VariableDeclaration is the same as a property
name of the binding object of the with statement’s object environment
record, then step 3 will assign value to the property instead of to the
VariableEnvironment binding of the Identifier.

-   

1.  

VariableDeclaration : _BindingPattern Initialiser_

1.  Let rhs be the result of evaluating Initialiser.

2.  Let rval be ToObject(GetValue(rhs)).

3.  ReturnIfAbrupt(rval).

4.  Return the result of performing Binding Initialisation for
    BindingPattern passing rval and UNDEFINED as arguments.

Syntax

BindingPattern :

ObjectBindingPattern
ArrayBindingPattern

ObjectBindingPattern :

{ }
{ BindingPropertyList }
{ BindingPropertyList , }

ArrayBindingPattern :

[ Elision~opt~ BindingRestElement~opt~ ]
[ BindingElementList ]
[ BindingElementList , Elision~opt~ BindingRestElement~opt~ ]

BindingPropertyList :

BindingProperty
BindingPropertyList , BindingProperty

BindingElementList :

Elision~opt~ BindingElement
BindingElementList , Elision~opt~ BindingElement

BindingProperty :

SingleNameBinding ~
~ PropertyName : BindingElement

BindingElement :

SingleNameBinding
BindingPattern Initialiser~opt~

SingleNameBinding :

BindingIdentifier Initialiser~opt~

BindingRestElement :

... BindingIdentifier

STATIC SEMANTICS: EARLY ERRORS

BindingPattern : ObjectBindingPattern

-   It is a Syntax Error if the BoundNames of ObjectBindingPattern
    contains the string “EVAL” or the string “ARGUMENTS”.

BindingPattern : ArrayBindingPattern

-   It is a Syntax Error if the BoundNames of ArrayBindingPattern
    contains the string “EVAL” or the string “ARGUMENTS”.

STATIC SEMANTICS: BOUNDNAMES

1.  2.  3.  4.  5.  

1.  

1.  

1.  

ObjectBindingPattern: { }

1.  Return an empty List.

1.  

ArrayBindingPattern : [ Elision~opt~ ]

1.  Return an empty List.

ArrayBindingPattern : [ Elision~opt~ BindingRestElement ]

1.  Return the BoundNames of BindingRestElement.

1.  

ArrayBindingPattern : [ BindingElementList , Elision~opt~ ]

1.  Return the BoundNames of BindingElementList.

ArrayBindingPattern : [ BindingElementList , Elision~opt~
BindingRestElement ]

1.  Let names be BoundNames of BindingElementList.

2.  Append to names the elements of BoundNames of
    BindingRestElement.

3.  Return names.

1.  

BindingPropertyList : BindingPropertyList , BindingProperty

1.  Let names be BoundNames of BindingPropertyList.

2.  Append to names the elements of BoundNames of BindingProperty.

3.  Return names.

BindingElementList : Elision~opt~ BindingElement

1.  Return BoundNames of BindingElement.

BindingElementList : BindingElementList , Elision~opt~
BindingElement

1.  Let names be BoundNames of BindingElementList.

2.  Append to names the elements of BoundNames of BindingElement.

3.  Return names.

1.  

BindingProperty : PropertyName : _BindingElement _

1.  Return the BoundNames of BindingElement.

SingleNameBinding : _BindingIdentifier Initialiser_~opt~

1.  Return the BoundNames of BindingIdentifier.

1.  

BindingElement : _BindingPattern Initialiser_~opt~

1.  Return the BoundNames of BindingPattern.

1.  

STATIC SEMANTICS: HASINITIALISER

1.  

BindingElement : _BindingPattern _

1.  Return FALSE.

BindingElement : _BindingPattern Initialiser_

1.  Return TRUE.

SingleNameBinding : _BindingIdentifier _

1.  Return FALSE.

SingleNameBinding : _BindingIdentifier Initialiser_

1.  Return TRUE.

RUNTIME SEMANTICS: BINDING INITIALISATION

  With parameters value and environment.

NOTE When UNDEFINED is passed for environment it indicates that a
PutValue operation should be used to assign the initialisation value.
This is the case for formal parameter lists of non-strict functions. In
that case the formal parameter bindings are preinitialized in order to
deal with the possibility of multiple parameters with the same name.

BindingPattern : ObjectBindingPattern

1.  Assert: Type(value) is Object

    a.  

2.  3.  Return the result of performing Binding Initialisation for
    ObjectBindingPattern using value and environment as arguments.

1.  

BindingPattern : ArrayBindingPattern

1.  Assert: Type(value) is Object

    a.  b.  c.  

2.  a.  b.  

3.  Return the result of performing Indexed Binding Initialisation for
    ArrayBindingPattern using value, 0, and environment as
    arguments.

1.  

ObjectBindingPattern: { }

1.  Return NormalCompletion(empty).

1.  

1.  a.  

2.  3.  

1.  

1.  

1.  

1.  2.  a.  

3.  4.  

1.  

1.  a.  

2.  3.  4.  

1.  2.  3.  

1.  a.  

2.  3.  4.  5.  

1.  

1.  

1.  2.  3.  

BindingPropertyList : BindingPropertyList , BindingProperty

1.  Let status be the result of performing Binding Initialisation for
    BindingPropertyList using value and environment as arguments.

2.  ReturnIfAbrupt(status).

3.  Return the result of performing Binding Initialisation for
    BindingProperty using value and environment as arguments.

BindingProperty : SingleNameBinding

1.  Let name be the string that is the only element of BoundNames of
    SingleNameBinding.

2.  Return the result of performing Keyed Binding Initialisation for
    SingleNameBinding using value, environment, and name as the
    arguments.

BindingProperty : PropertyName : _BindingElement _

1.  Let P be the PropName of PropertyName

2.  Return the result of performing Keyed Binding Initialisation for
    BindingElement using value, environment, and P as arguments.

RUNTIME SEMANTICS: INDEXED BINDING INITIALISATION

  With parameters array, nextIndex, and environment.

NOTE When UNDEFINED is passed for environment it indicates that a
PutValue operation should be used to assign the initialisation value.
This is the case for formal parameter lists of non-strict functions. In
that case the formal parameter bindings are preinitialized in order to
deal with the possibility of multiple parameters with the same name.

ArrayBindingPattern : [ Elision~opt~ ]

1.  Return NormalCompletion(empty).

ArrayBindingPattern: [ Elision~opt~ BindingRestElement ]

1.  Let nextIndex be the Elision Width of Elision; if Elision is
    not present, use the numeric value zero.

2.  Return the result of performing Indexed Binding Initialisation for
    BindingRestElement using _array, nextIndex_, and environment as
    arguments.

ArrayBindingPattern: [ BindingElementList ]

1.  Return the result of performing Indexed Binding Initialisation for
    BindingElementList using array, nextIndex, and environment
    as arguments.

ArrayBindingPattern: [ BindingElementList , Elision~opt~]

1.  Return the result of performing Indexed Binding Initialisation for
    BindingElementList using array, nextIndex, and environment
    as arguments.

ArrayBindingPattern: [ BindingElementList , Elision~opt~
BindingRestElement ]

1.  Let next be the result of performing Indexed Binding
    Initialisation for BindingElementList using _array , nextIndex_,
    and environment as arguments.

2.  ReturnIfAbrupt(next).

3.  Let skip be the Elision Width of Elision; if Elision is not
    present, use the numeric value zero.

4.  Return the result of performing Indexed Binding Initialisation for
    BindingRestElement using array, next_+_skip , and
    environment as arguments.

1.  

BindingElementList : Elision~opt~ BindingElement

1.  Let skip be the Elision Width of Elision; if Elision is not
    present, use the numeric value zero.

2.  Let status be the result of performing Indexed Binding
    Initialisation for BindingElement using array,
    nextIndex_+_skip , and environment as arguments.

3.  ReturnIfAbrupt(status).

4.  Return nextIndex +skip+1.

1.  2.  3.  

BindingElementList : BindingElementList , Elision~opt~
_BindingElement _

1.  Let listNext be the result of performing Indexed Binding
    Initialisation for BindingElementList using _array, nextIndex_,
    and environment as arguments.

2.  ReturnIfAbrupt(listNext).

3.  Let skip be the Elision Width of Elision; if Elision is not
    present, use the numeric value zero.

4.  Let status be the result of performing Indexed Binding
    Initialisation for BindingElement using array, listNext_+_skip
    , and environment as arguments.

5.  ReturnIfAbrupt(status).

6.  Return listNext +skip+1.

7.  

1.  

1.  2.  3.  

1.  2.  

1.  

1.  2.  3.  a.  

4.  a.  i.  

    b.  i.  

5.  

1.  

1.  2.  a.  

3.  a.  i.  

    b.  i.  

4.  

1.  

BindingElement: SingleNameBinding

1.  a.  

2.  3.  Return the result of performing Keyed Binding Initialisation for
    SingleNameBinding using array, environment, and
    ToString(nextIndex) as the arguments.

1.  

BindingElement: _BindingPattern Initialiser_~opt~

1.  Let P be ToString(nextIndex).

2.  3.  4.  5.  6.  7.  8.  9.  Let v be the result of calling the
    [[Get]] internal method of array with argument P.

10. ReturnIfAbrupt(v).

11. 12. If Initialiser~opt~ is present and v is UNDEFINED, then

    a.  Let defaultValue be the result of evaluating Initialiser.

    b.  Let v be ToObject(defaultValue).

    c.  

    a.  i.  

13. ReturnIfAbrupt(v).

14. Return the result of performing Binding Initialisation for
    BindingPattern passing v and environment as arguments.

BindingRestElement : … BindingIdentifier

1.  Let A be the result of the abstract operation ArrayCreate (15.4)
    with argument 0.

2.  Let lenVal be the result of calling the [[Get]] internal method of
    array with argument “LENGTH”.

3.  Let arrayLength be ToUint32(lenVal).

4.  ReturnIfAbrupt(arrayLength).

5.  Let n=0.

6.  Let index = nextIndex.

7.  Repeat, while index < arrayLength

    a.  Let P be ToString(index).

    b.  Let exists be the result of calling the [[HasProperty]]
          internal method of array with argument P.

    c.  If exists is TRUE, then

        i.  Let v be the result of calling the [[Get]] internal method
              of array passing P as the argument.

        ii. ReturnIfAbrupt(v).

        iii. Call the [[DefineOwnProperty]] internal method of A with
              arguments ToString(n), Property Descriptor {[[Value]]:
              v, [[Writable]]: TRUE, [[Enumerable]]: TRUE,
              [[Configurable]]: TRUE}, and FALSE.

    d.  Let n = n+1.

    e.  Let index = index+1.

8.  Return the result of performing Binding Initialisation for
    BindingIdentifier using A and environment as arguments.

RUNTIME SEMANTICS: KEYED BINDING INITIALISATION

  With parameters obj, environment, and propertyName.

NOTE When UNDEFINED is passed for environment it indicates that a
PutValue operation should be used to assign the initialisation value.
This is the case for formal parameter lists of non-strict functions. In
that case the formal parameter bindings are preinitialized in order to
deal with the possibility of multiple parameters with the same name.

1.  

BindingElement: BindingPattern Initialiser~opt~

1.  2.  3.  

1.  Let v be the result of calling the [[Get]] internal method of obj
    with argument propertyName.

2.  ReturnIfAbrupt(v).

3.  4.  If Initialiser~opt~ is present and v is UNDEFINED, then

    a.  Let defaultValue be the result of evaluating Initialiser.

    b.  Let v be ToObject(defaultValue).

1.  2.  

1.  ReturnIfAbrupt(v).

2.  Return the result of performing Binding Initialisation for
    BindingPattern passing v and environment as arguments.

SingleNameBinding : _BindingIdentifier Initialiser_~opt~

1.  2.  

1.  

1.  Let v be the result of calling the [[Get]] internal method of
    obj passing propertyName as the argument.

1.  ReturnIfAbrupt(v).

2.  3.  If Initialiser~opt~ is present and v is UNDEFINED, then

    a.  Let v be the result of evaluating Initialiser.

    b.  i.  

4.  ReturnIfAbrupt(v).

5.  Return the result of performing Binding Initialisation for
    BindingIdentifier passing v and environment as arguments.

1.  

1.  

1.  2.  3.  4.  5.  a.  b.  c.  i.  ii. 

    d.  e.  

6.  

Syntax

EmptyStatement :

;

RUNTIME SEMANTICS: EVALUATION

EmptyStatement : ;

Syntax

ExpressionStatement :

[lookahead ∉ {{, FUNCTION, CLASS }] Expression ;

NOTE An ExpressionStatement cannot start with an opening curly brace
because that might make it ambiguous with a Block. Also, an
ExpressionStatement cannot start with the FUNCTION or CLASS keywords
because that would make it ambiguous with a FunctionDeclaration, a
GeneratorDeclaration, or a ClassDeclaration.

RUNTIME SEMANTICS: EVALUATION

ExpressionStatement : [lookahead ∉ {{, FUNCTION, CLASS }]
Expression;

Syntax

IfStatement :

IF ( Expression ) Statement ELSE Statement
IF ( Expression ) Statement

Each ELSE for which the choice of associated IF is ambiguous shall be
associated with the nearest possible IF that would otherwise have no
corresponding ELSE.

STATIC SEMANTICS: VARDECLAREDNAMES

IfStatement : IF ( Expression ) Statement ELSE Statement

1.  Let names be VarDeclaredNames of the first Statement.

2.  Append to names the elements of the VarDeclaredNames of the second
    Statement.

3.  Return names.

IfStatement : IF ( Expression ) _Statement _

1.  Return the VarDeclaredNames of Statement.

RUNTIME SEMANTICS: EVALUATION

IfStatement : IF ( Expression ) Statement ELSE Statement

1.  

IfStatement : IF ( Expression ) Statement

Syntax

IterationStatement :

DO Statement WHILE ( Expression )
WHILE ( Expression ) Statement
FOR (ExpressionNoIn~opt~; Expression~opt~ ; Expression~opt~ ) Statement
FOR ( VAR VariableDeclarationListNoIn; Expression~opt~ ; Expression~opt~
) Statement
FOR ( LexicalDeclarationNoIn; Expression~opt~ ; Expression~opt~ )
Statement
FOR ( LeftHandSideExpression IN Expression ) Statement
FOR ( VAR ForBinding IN Expression ) Statement
FOR ( ForDeclaration IN Expression ) Statement
FOR ( LeftHandSideExpression OF Expression ) Statement
FOR ( VAR ForBinding OF Expression ) Statement
FOR ( ForDeclaration OF Expression ) Statement

ForDeclaration :

LetOrConst ForBinding

NOTE 1 ForBinding is defined in 11.1.4.2.

NOTE 2 A semicolon is not required after a DO-WHILE statement.

RUNTIME SEMANTICS

RUNTIME SEMANTICS: LOOPCONTINUES ABSTRACT OPERATION

The abstract operation LoopContinues with arguments completion and
labelSet is defined by the following step:

NOTE Within the Statement part of an IterationStatement a
ContinueStatement may be used to begin a new iteration.

STATIC SEMANTICS: VARDECLAREDNAMES

IterationStatement : DO Statement WHILE ( Expression )

1.  Return the VarDeclaredNames of Statement.

RUNTIME SEMANTICS: LABELLED EVALUATION

  With argument labelSet.

IterationStatement : DO Statement WHILE ( Expression )

1.  Let V = UNDEFINED.

2.  3.  Repeat

    a.  Let stmt be the result of evaluating Statement.

    b.  If stmt.[[value]] is not empty, let V = stmt_.[[value]]_.

    c.  i.  

    d.  If stmt is an abrupt completion and LoopContinues
        (stmt_,_labelSet) is FALSE, return stmt.

    e.  Let exprRef be the result of evaluating Expression.

    f.  Let exprValue be ToBoolean(GetValue(exprRef)).

    g.  If exprValue is FALSE, Return NormalCompletion(V).

    h.  Else if exprValue is a Completion Record, then

        i.  Assert: exprValue is an abrupt completion.

        ii. If LoopContinues (exprValue_,_labelSet) is FALSE, return
              exprValue.

4.  

STATIC SEMANTICS: VARDECLAREDNAMES

IterationStatement : WHILE ( Expression ) Statement

1.  Return the VarDeclaredNames of Statement.

RUNTIME SEMANTICS: LABELLED EVALUATION

  With argument labelSet.

IterationStatement : WHILE ( Expression ) Statement

STATIC SEMANTICS: VARDECLAREDNAMES

IterationStatement : FOR (ExpressionNoIn~opt~ ; Expression~opt~ ;
Expression~opt~) Statement

1.  Return the VarDeclaredNames of Statement.

IterationStatement : FOR ( VAR VariableDeclarationListNoIn ;
Expression~opt~ ; Expression~opt~ ) Statement

1.  Let names be BoundNames of VariableDeclarationListNoIn.

2.  Append to names the elements of the VarDeclaredNames of
    Statement.

3.  Return names.

IterationStatement : FOR (LexicalDeclarationNoIn; Expression~opt~
; Expression~opt~) Statement

1.  Return the VarDeclaredNames of Statement.

RUNTIME SEMANTICS: LABELLED EVALUATION

  With argument labelSet.

IterationStatement : FOR (ExpressionNoIn~opt~ ; Expression~opt~ ;
Expression~opt~) Statement

1.  2.  a.  i.  ii. iii. iv. 

    b.  c.  d.  e.  f.  g.  i.  ii. iii. 

IterationStatement : FOR ( VAR VariableDeclarationListNoIn ;
Expression~opt~ ; Expression~opt~ ) Statement

IterationStatement : FOR ( LexicalDeclarationNoIn ;
Expression~opt~ ; Expression~opt~ ) Statement

1.  Let oldEnv be the running execution context’s LexicalEnvironment.

2.  Let loopEnv be the result of calling NewDeclarativeEnvironment
    passing oldEnv as the argument.

3.  Let isConst be the result of performing IsConstantDeclaration of
    LexicalDeclarationNoIn.

4.  For each element dn of the BoundNames of LexicalDeclarationNoIn
    do

    a.  If isConst is TRUE, then

        i.  Call loopEnv’s CreateImmutableBinding concrete method
            passing dn as the argument.

    b.  Else,

        i.  Call loopEnv’s CreateMutableBinding concrete method
            passing dn and FALSE as the arguments.

5.  Set the running execution context’s LexicalEnvironment to loopEnv.

6.  Let forDcl be the result of evaluating LexicalDeclarationNoIn.

7.  If LoopContinues(forDcl_,_labelSet) is FALSE, then

    a.  Set the running execution context’s LexicalEnvironment to
        oldEnv.

    b.  Return forDcl.

8.  Let bodyResult be the result of performing For Body Evaluation
    with the first Expression as the testExpr argument, the second
    Expression as the incrementExpr argument, Statement as the
    stmt argument, and with labelSet.

9.  Set the running execution context’s LexicalEnvironment to oldEnv.

10. Return bodyResult.

RUNTIME SEMANTICS: FOR BODY EVALUATION ABSTRACT OPERATION

The abstract operation For Body Evaluation with arguments testExpr,
incrementExpr, stmt, and labelSet is performed as follows:

1.  Let V = UNDEFINED,.

2.  Repeat

    a.  If testExpr is not [empty], then

        i.  Let testExprRef be the result of evaluating testExpr.

        ii. Let testExprValue be ToBoolean(GetValue(testExprRef))

        iii. If testExprValue is FALSE, return NormalCompletion(V).

        iv. Else if LoopContinues (testExprValue_,_labelSet) is FALSE,
            return testExprValue.

    b.  Let result be the result of evaluating stmt.

    c.  If result.[[value]] is not empty, let V =
        result.[[value]].

    d.  If LoopContinues (result_,_labelSet) is FALSE, return
        result.

    e.  If incrementExpr is not [empty], then

        i.  Let incExprRef be the result of evaluating
            incrementExpr.

        ii. Let incExprValue be GetValue(incExprRef).

        iii. If LoopContinues(incExprValue_,_labelSet) is FALSE,
            return incExprValue.

STATIC SEMANTICS: EARLY ERRORS

IterationStatement :

  FOR (LeftHandSideExpression IN Expression ) Statement

  FOR (LeftHandSideExpression OF Expression ) Statement

-   It is a Syntax Error LeftHandSideExpression is either an
    ObjectLiteral or an ArrayLiteral and if the lexical token
    sequence matched by LeftHandSideExpression cannot be parsed with
    no tokens left over using AssignmentPattern as the goal symbol.

-   If LeftHandSideExpression is either an ObjectLiteral or an
    ArrayLiteral and if the lexical token sequence matched by
    LeftHandSideExpression can be parsed with no tokens left over
    using AssignmentPattern as the goal symbol then the following
    rules are not applied. Instead, the Early Error rules for
    AssignmentPattern are used.

-   It is a Syntax Error if the LeftHandSideExpression is an
    Identifier that can be statically determined to always resolve to
    a declarative environment record binding and the resolved binding is
    an immutable binding.

-   It is a Syntax Error if LeftHandSideExpression is neither an
    ObjectLiteral nor an ArrayLiteral and
    IsValidSimpleAssignmentTarget of LeftHandSideExpression is FALSE.

-   -   -   It is a Syntax Error if the LeftHandSideExpression is
    CoverParenthesizedExpressionAndArrowParameterList : ( Expression
    )
    and Expression derived a production that would produce a Syntax
    Error according to these rules. This rule is recursively applied.

-   -   

IterationStatement :

  FOR (ForDeclaration IN Expression ) Statement

  FOR (ForDeclaration OF Expression ) Statement

-   It is a Syntax Error if any element of the BoundNames of
    ForDeclaration also occurs in the VarDeclaredNames of Statement.

STATIC SEMANTICS: BOUNDNAMES

1.  

1.  

ForDeclaration : _LetOrConst ForBinding _

1.  Return the BoundNames of ForBinding.

1.  

1.  

STATIC SEMANTICS: VARDECLAREDNAMES

IterationStatement : FOR ( LeftHandSideExpression IN Expression )
Statement

1.  Return the VarDeclaredNames of Statement.

IterationStatement : FOR ( VAR ForBinding IN Expression )
Statement

1.  Let names be the BoundNames of ForBinding.

2.  Append to names the elements of the VarDeclaredNames of
    Statement.

3.  Return names

IterationStatement : FOR ( ForDeclaration IN Expression )
Statement

1.  Return the VarDeclaredNames of Statement.

IterationStatement : FOR ( LeftHandSideExpression OF Expression )
Statement

1.  Return the VarDeclaredNames of Statement.

IterationStatement : FOR ( VAR ForBinding OF Expression )
Statement

1.  Let names be the BoundNames of ForBinding.

2.  Append to names the elements of the VarDeclaredNames of
    Statement.

3.  Return names

IterationStatement : FOR ( ForDeclaration OF Expression )
Statement

1.  Return the VarDeclaredNames of Statement.

RUNTIME SEMANTICS: BINDING INSTANTIATION

  With arguments value and environment.

ForDeclaration : _LetOrConst ForBinding _

1.  For each element name of the BoundNames of ForBinding do

    a.  If IsConstantDeclaration of LetOrConst is FALSE, then

        i.  Call environment’s CreateMutableBinding concrete method
            with argument name.

    b.  Else,

        i.  Call environment’s CreateImmutableBinding concrete method
            with argument name.

2.  Return the result of performing Binding Initialisation for
    ForBinding passing value and environment as the arguments.

1.  

1.  

1.  

1.  

RUNTIME SEMANTICS: LABELLED EVALUATION

  With argument labelSet.

IterationStatement : FOR ( LeftHandSideExpression IN Expression )
Statement

1.  Let keyResult be the result of performing For In/Of Expression
    Evaluation with Statement, enumerate, and labelSet.

2.  ReturnIfAbrupt(keyResult).

3.  Return the result of performing For In/Of Body Evaluation with
    LeftHandSideExpression, Statement, keyResult, assignment, and
    labelSet.

IterationStatement : FOR ( VAR ForBinding IN Expression )
Statement

IterationStatement : FOR (ForDeclaration IN Expression )
Statement

1.  Let keyResult be the result of performing For In/Of Expression
    Evaluation with Statement, enumerate, and labelSet.

2.  ReturnIfAbrupt(keyResult).

3.  Return the result of performing For In/Of Body Evaluation with
    ForDeclaration, Statement, keyResult, lexicalBinding, and
    labelSet.

IterationStatement : FOR ( LeftHandSideExpression OF Expression )
Statement

1.  Let keyResult be the result of performing For In/Of Expression
    Evaluation with Expression, iterate, and labelSet.

2.  ReturnIfAbrupt(keyResult).

3.  Return the result of performing For In/Of Body Evaluation with
    LeftHandSideExpression, Statement, keyResult, assignment, and
    labelSet.

IterationStatement : FOR ( VAR ForBinding OF Expression )
Statement

1.  Let keyResult be the result of performing For In/Of Expression
    Evaluation with Expression, iterate, and labelSet.

2.  ReturnIfAbrupt(keyResult).

3.  Return the result of performing For In/Of Body Evaluation with
    ForBinding, Statement, keyResult, varBinding, and labelSet.

IterationStatement : FOR (ForDeclaration OF Expression )
Statement

1.  Let keyResult be the result of performing For In/Of Expression
    Evaluation with Expression, iterate, and labelSet.

2.  ReturnIfAbrupt(keyResult).

3.  Return the result of performing For In/Of Body Evaluation with
    ForDeclaration, Statement, keyResult, lexicalBinding, and
    labelSet.

RUNTIME SEMANTICS: FOR IN/OF EXPRESSION EVALUATION ABSTRACT OPERATION

The abstract operation For In/Of Expression Evaluation is called with
arguments expr, iterationKind, and labelSet. The value of
iterationKind is either ENUMERATE or ITERATE.

1.  Let exprRef be the result of evaluating the production that is
    expr.

2.  Let experValue be GetValue(exprRef).

3.  If experValue is an abrupt completion,

    a.  If LoopContinues(experValue_,_labelSet) is FALSE, then return
        experValue.

    b.  Else, return Completion {[[type]]: break, [[value]]: empty,
        [[target]]: empty}.

4.  If experValue.[[value]] is NULL or UNDEFINED, return Completion
    {[[type]]: break, [[value]]: empty, [[target]]: empty}.

5.  Let obj be ToObject(experValue).

6.  If iterationKind is enumerate, then

    a.  Let keys be the result of calling the [[Enumerate]] internal
        method of obj with arguments TRUE and TRUE.

7.  Else,

    a.  Assert iterationKind is iterate.

    b.  Let keys be the result of calling the [[Iterate]] internal
        method of obj.

8.  If keys is an abrupt completion, then

    a.  If LoopContinues(experValue_,_labelSet) is FALSE, then return
        experValue.

    b.  Assert: keys.[[type]] is continue

    c.  Return Completion {[[type]]: break, [[value]]: empty,
        [[target]]: empty}.

9.  Return keys.

RUNTIME SEMANTICS: FOR IN/OF BODY EVALUATION ABSTRACT OPERATION

The abstract operation For In/Of Body Evaluation is called with
arguments lhs, stmt, keys, lhsKind, and labelSet. The value of
lhsKind is either ASSIGNMENT, VARBINDING or LEXICALBINDING.

1.  Let oldEnv be the running execution context’s LexicalEnvironment.

2.  Let V = UNDEFINED .

3.  Repeat

    a.  Let next be the result of performing Invoke with arguments
        "NEXT", keys, and an empty arguments List.

    b.  If IteratorComplete(next) is TRUE, then return
        NormalCompletion(V).

    c.  If LoopContinues(next_,_labelSet) is FALSE, then return
        next.

    d.  If next is an abrupt completion, then let status be next.

    e.  Else,

        i.  Assert next.[[type]] is normal.

        ii. Let nextValue be next.[[value]].

        iii. If lhsKind is assignment, then

            1.  Assert: lhs is a LeftHandSideExpression.

            2.  If lhs is neither an ObjectLiteral nor an
                ArrayLiteral then

                a.  b.  Let lhsRef be the result of evaluating lhs (
                    it may be evaluated repeatedly).

                c.  Let status be the result of performing
                    PutValue(lhsRef, nextValue).

            3.  Else

                a.  Let AssignmentPattern be the parse of the source
                    code corresponding to lhs using
                    AssignmentPattern as the goal symbol.

                b.  Let rval be ToObject(nextValue).

                c.  If rval is an abrupt completion, then let status
                    be rval.

                d.  Else, let status be the result of performing
                    Destructuring Assignment Evaluation of
                    AssignmentPattern using rval as the argument.

        iv. Else if lhsKind is varBinding, then

            1.  Assert: lhs is a ForBinding.

            2.  Let status be the result of performing Binding
                Initialisation for lhs passing nextValue and
                UNDEFINED as the arguments.

        v.  Else,

            1.  Assert lhsKind is lexicalBinding.

            2.  Assert: lhs is a ForDeclaration.

            3.  Let iterationEnv be the result of calling
                NewDeclarativeEnvironment passing oldEnv as the
                argument.

            4.  Perform Binding Instantiation for lhs passing
                nextValue and iterationEnv as arguments.

            5.  Let status be NormalCompletion(empty)

            6.  Set the running execution context’s LexicalEnvironment
                to iterationEnv.

        vi. If status.[[type]] is normal, then

            1.  Let status be the result of evaluating stmt.

            2.  If status.[[type]] is normal and status.[[value]] is
                not empty, then

                a.  Let V = status.[[value]].

        vii. Set the running execution context’s LexicalEnvironment to
            oldEnv.

        viii. If status is an abrupt completion and
            LoopContinues(status_,_labelSet) is FALSE, then return
            status.

            1.  2.  a.  

1.  2.  3.  

Syntax

ContinueStatement :

CONTINUE ;
CONTINUE [no LineTerminator here] Identifier;

STATIC SEMANTICS: EARLY ERRORS

ContinueStatement : CONTINUE ;

-   It is a Syntax Error if this production is not nested, directly or
      indirectly (but not crossing function boundaries), within an
      IterationStatement.

ContinueStatement : CONTINUE [no LineTerminator here] Identifier;

-   It is a Syntax Error if Identifier does not appear in the
      CurrentLabelSet of an enclosing (but not crossing function
      boundaries) IterationStatement.

RUNTIME SEMANTICS: EVALUATION

ContinueStatement : CONTINUE ;

ContinueStatement : CONTINUE [no LineTerminator here] Identifier;

Syntax

BreakStatement :

BREAK ;
BREAK [no LineTerminator here] Identifier ;

STATIC SEMANTICS: EARLY ERRORS

BreakStatement : BREAK ;

-   It is a Syntax Error if this production not nested, directly or
      indirectly (but not crossing function boundaries), within an
      IterationStatement or a SwitchStatement.

BreakStatement : BREAK [no LineTerminator here] Identifier;

-   It is a Syntax Error if Identifier does not appear in the
      CurrentLabelSet of an enclosing (but not crossing function
      boundaries) Statement.

RUNTIME SEMANTICS: EVALUATION

BreakStatement : BREAK ;

BreakStatement : BREAK [no LineTerminator here] Identifier;

Syntax

ReturnStatement :

RETURN ;
RETURN [no LineTerminator here] Expression ;

NOTE A RETURN statement causes a function to cease execution and return
a value to the caller. If Expression is omitted, the return value is
UNDEFINED. Otherwise, the return value is the value of Expression.

STATIC SEMANTICS

STATIC SEMANTICS: EARLY ERRORS

-   -   It is a Syntax Error if a RETURN statement is not within a
    FunctionBody.

RUNTIME SEMANTICS: EVALUATION

ReturnStatement : RETURN ;

ReturnStatement : RETURN [no LineTerminator here] Expression;

1.  Let exprRef be the result of evaluating Expression.

2.  Let exprValue be GetValue(exprRef).

3.  ReturnIfAbrupt(exprValue).

4.  Return Completion {[[type]]: return, [[value]]: exprValue,
    [[target]]: empty}.

Syntax

WithStatement :

WITH ( Expression ) Statement

NOTE The WITH statement adds an object environment record for a computed
object to the lexical environment of the running execution context. It
then executes a statement using this augmented lexical environment.
Finally, it restores the original lexical environment.

STATIC SEMANTICS

STATIC SEMANTICS: EARLY ERRORS

WithStatement : WITH ( Expression ) Statement

-   It is a Syntax Error if the code that matches this production is
    contained in strict code.

STATIC SEMANTICS: VARDECLAREDNAMES

WithStatement : WITH ( Expression ) Statement

1.  Return the VarDeclaredNames of Statement.

RUNTIME SEMANTICS: EVALUATION

WithStatement : WITH ( Expression ) Statement

NOTE No matter how control leaves the embedded Statement, whether
normally or by some form of abrupt completion or exception, the
LexicalEnvironment is always restored to its former state.

Syntax

SwitchStatement :

SWITCH ( Expression ) CaseBlock

CaseBlock :

{ CaseClauses~opt~ }
{ CaseClauses~opt~ DefaultClause CaseClauses~opt~ }

CaseClauses :

CaseClause
CaseClauses CaseClause

CaseClause :

CASE Expression : StatementList~opt~

DefaultClause :

DEFAULT : StatementList~opt~

STATIC SEMANTICS: EARLY ERRORS

CaseBlock : { CaseClauses }

-   It is a Syntax Error if the LexicallyDeclaredNames of CaseClauses
    contains any duplicate entries.

-   It is a Syntax Error if any element of the LexicallyDeclaredNames of
    CaseClauses also occurs in the VarDeclaredNames of CaseClauses.

-   

STATIC SEMANTICS: LEXICALDECLARATIONS

CaseBlock : { }

1.  Return a new empty List.

1.  

CaseBlock : { CaseClauses~opt~ _DefaultClause CaseClauses_~opt~ }

1.  If the first CaseClauses is present, let declarations be the
    LexicalDeclarations of the first CaseClauses.

2.  Else let declarations be a new empty List.

3.  Append to declarations the elements of the LexicalDeclarations of
    the DefaultClause.

4.  If the second CaseClauses is not present, return declarations.

5.  Else return the result of appending to declarations the elements
    of the LexicalDeclarations of the second CaseClauses.

1.  

CaseClauses : _CaseClauses CaseClause_

1.  Let declarations be LexicalDeclarations of CaseClauses.

2.  Append to declarations the elements of the LexicalDeclarations of
    CaseClause.

3.  Return declarations.

CaseClause : CASE Expression : StatementList~opt~

1.  If the StatementList is present, return the LexicalDeclarations of
    StatementList.

2.  Else return a new empty List.

DefaultClause : DEFAULT : StatementList~opt~

1.  If the StatementList is present, return the LexicalDeclarations of
    StatementList.

2.  Else return a new empty List.

STATIC SEMANTICS: LEXICALLYDECLAREDNAMES

CaseBlock : { }

1.  Return a new empty List.

1.  

CaseBlock : { CaseClauses~opt~ _DefaultClause CaseClauses_~opt~ }

1.  If the first CaseClauses is present, let names be the
    LexicallyDeclaredNames of the first CaseClauses.

2.  Else let names be a new empty List.

3.  Append to names the elements of the LexicallyDeclaredNames of the
    DefaultClause.

4.  If the second CaseClauses is not present, return names.

5.  Else return the result of appending to names the elements of the
    LexicallyDeclaredNames of the second CaseClauses.

1.  

CaseClauses : _CaseClauses CaseClause_

1.  Let names be LexicallyDeclaredNames of CaseClauses.

2.  Append to names the elements of the LexicallyDeclaredNames of
    CaseClause.

3.  Return names.

CaseClause : CASE Expression : StatementList~opt~

1.  If the StatementList is present, return the LexicallyDeclaredNames
    of StatementList.

2.  Else return a new empty List.

DefaultClause : DEFAULT : StatementList~opt~

1.  If the StatementList is present, return the LexicallyDeclaredNames
    of StatementList.

2.  Else return a new empty List.

STATIC SEMANTICS: VARDECLAREDNAMES

SwitchStatement : SWITCH ( Expression ) CaseBlock

1.  Return the VarDeclaredNames of CaseBlock.

CaseBlock : { }

1.  Return a new empty List.

1.  

CaseBlock : { CaseClauses~opt~ _DefaultClause CaseClauses_~opt~ }

1.  If the first CaseClauses is present, let names be the
    VarDeclaredNames of the first CaseClauses.

2.  Else let names be a new empty List.

3.  Append to names the elements of the VarDeclaredNames of the
    DefaultClause.

4.  If the second CaseClauses is not present, return names.

5.  Else return the result of appending to names the elements of the
    VarDeclaredNames of the second CaseClauses.

1.  

CaseClauses : _CaseClauses CaseClause_

1.  Let names be VarDeclaredNames of CaseClauses.

2.  Append to names the elements of the VarDeclaredNames of
    CaseClause.

3.  Return names.

CaseClause : CASE Expression : StatementList~opt~

1.  If the StatementList is present, return the VarDeclaredNames of
    StatementList.

2.  Else return a new empty List.

DefaultClause : DEFAULT : StatementList~opt~

1.  If the StatementList is present, return the VarDeclaredNames of
    StatementList.

2.  Else return a new empty List.

RUNTIME SEMANTICS: CASE BLOCK EVALUATION

  With argument input.

CaseBlock : { CaseClauses~opt~ }

1.  Let V = UNDEFINED.

2.  Let A be the list of CaseClause items in source text order.

3.  Let searching be TRUE.

4.  Repeat, while searching is TRUE

    a.  Let C be the next CaseClause in A. If there is no such
        CaseClause, return NormalCompletion(V).

    b.  Let clauseSelector be the result of evaluating C.

    c.  ReturnIfAbrupt(clauseSelector).

    d.  If input is equal to clauseSelector as defined by the Strict
        Equality Comparison Algorithm (11.9.1), then

        i.  Set searching to FALSE.

        ii. If C has a StatementList, then

            1.  Evaluate C’s StatementList and let R be the
                result.

            2.  ReturnIfAbrupt(R).

            3.  Let V = R.[[value]].

5.  Repeat

    a.  Let C be the next CaseClause in A. If there is no such
        CaseClause, return NormalCompletion(V).

    b.  If C has a StatementList, then

        i.  Evaluate C’s StatementList and let R be the result.

        ii. If R.[[value]] is not empty, then let V = R.[[value]].

        iii. If R is an abrupt completion, then return Completion
            {[[type]]: R.[[type]], [[value]]: V, [[target]]:
            R.[[target]]}.

CaseBlock : { CaseClauses~opt~ _DefaultClause CaseClauses_~opt~ }

1.  Let V = UNDEFINED..

2.  Let A be the list of CaseClause items in the first
    CaseClauses, in source text order.

3.  4.  Let found be FALSE.

5.  Repeat letting C be in order each CaseClause in A

    a.  If found is FALSE, then

        i.  Let clauseSelector be the result of Case Selector
            Evaluation of C.

        ii. If clauseSelector is an abrupt completion, then

            1.  If clauseSelector.[[value]] is empty, then return
                Completion {[[type]]: clauseSelector.[[type]],
                [[value]]: UNDEFINED, [[target]]:
                clauseSelector.[[target]]}.

            2.  Else, return clauseSelector.

        iii. If input is equal to clauseSelector as defined by the
            Strict Equality Comparison Algorithm (11.9.1), then set
            found to TRUE.

    b.  If found is TRUE, then

        i.  ii. Evaluate CaseClause C and let R be the result.

        iii. If R.[[value]] is not empty, then let V =
            R.[[value]].

        iv. If R is an abrupt completion, then return Completion
            {[[type]]: R.[[type]], [[value]]: V, [[target]]:
            R.[[target]]}.

6.  Let foundInB be FALSE.

7.  If found is FALSE, then

    a.  Let B be a new list of the CaseClause items in the second
        CaseClauses, in source text order.

    b.  Repeat, letting C be in order each CaseClause in B

        i.  If foundInB is FALSE, then

            1.  2.  Let clauseSelector be the result of Case Selector
                Evaluation of C.

            3.  If clauseSelector is an abrupt completion, then.

                a.  If clauseSelector.[[value]] is empty, then return
                    Completion {[[type]]: clauseSelector.[[type]],
                    [[value]]: UNDEFINED, [[target]]:
                    clauseSelector.[[target]]}.

                b.  Else, return clauseSelector.

            2.  If input is equal to clauseSelector as defined by
                the Strict Equality Comparison Algorithm (11.9.1), then

            3.  set foundInB to TRUE.

        i.  If foundInB is TRUE, then

6.  If foundInB is TRUE, then return NormalCompletion(V).

7.  8.  Evaluate DefaultClause and let R be the result.

9.  If R.[[value]] is not empty, then let V = R.[[value]].

10. If R is an abrupt completion, then return Completion {[[type]]:
    R.[[type]], [[value]]: V, [[target]]: R.[[target]]}.

11. Let B be a new list of the CaseClause items in the second
    CaseClauses, in source text order.

12. Repeat, letting C be in order each CaseClause in B (NOTE this
    is another complete iteration of the second CaseClauses)

    b.  c.  d.  Evaluate CaseClause C and let R be the result.

    e.  If R.[[value]] is not empty, then let V = R.[[value]].

    f.  If R is an abrupt completion, then return Completion
        {[[type]]: R.[[type]], [[value]]: V, [[target]]:
        R.[[target]]}.

13. Return NormalCompletion(V).

RUNTIME SEMANTICS: CASE SELECTOR EVALUATION

CaseClause : CASE Expression : StatementList~opt~

NOTE Case Selector Evaluation does not execute the associated
StatementList. It simply evaluates the Expression and returns the
value, which the CaseBlock algorithm uses to determine which
StatementList to start executing.

RUNTIME SEMANTICS: EVALUATION

SwitchStatement : SWITCH ( Expression ) CaseBlock

NOTE No matter how control leaves the SwitchStatement the
LexicalEnvironment is always restored to its former state.

CaseClause : CASE Expression : [empty]

1.  Return NormalCompletion(empty).

CaseClause : CASE Expression : StatementList

1.  Return the result of evaluating StatementList.

DefaultClause : DEFAULT: [empty]

1.  Return NormalCompletion(empty).

DefaultClause : DEFAULT: StatementList

1.  Return the result of evaluating StatementList.

1.  2.  

Syntax

LabelledStatement :

Identifier : Statement

NOTE A Statement may be prefixed by a label. Labelled statements are
only used in conjunction with labelled BREAK and CONTINUE statements.
ECMAScript has no GOTO statement. A Statement can be part of a
LabelledStatement, which itself can be part of a LabelledStatement,
and so on. The labels introduced this way are collectively referred to
as the “current label set” when describing the semantics of individual
statements. A LabelledStatement has no semantic meaning other than the
introduction of a label to a _label set_. The label set of an
IterationStatement or a SwitchStatement initially contains the
single element EMPTY. The label set of any other statement is initially
empty.

STATIC SEMANTICS: EARLY ERRORS

-   It is a Syntax Error if a LabelledStatement is enclosed by a
    LabelledStatement with the same Identifier as the enclosed
    LabelledStatement. This does not apply to a LabelledStatement
    appearing within the body of a FunctionDeclaration and a
    LabelledStatement that encloses, directly or indirectly the
    FunctionDeclaration .

STATIC SEMANTICS: VARDECLAREDNAMES

LabelledStatement : Identifier : Statement

1.  Return the VarDeclaredNames of Statement.

RUNTIME SEMANTICS: LABELLED EVALUATION

  With argument labelSet.

LabelledStatement : Identifier : Statement

1.  Let label be the StringValue of Identifier.

2.  Let newLabelSet be a new List containing label and the elements
    of labelSet.

3.  If Statement is either LabelledStatement or BreakableStatement,
    then

    a.  Let stmtResult be the result of performing Labelled Evaluation
        of Statement with argument newLabelSet.

4.  Else,

    a.  Let stmtResult be the result of evaluating Statement.

5.  If stmtResult.[[type]] is BREAK and stmtResult.[[target]] is the
    same value as label, then

    a.  Let result be NormalCompletion(stmtResult.[[value]]).

6.  Else,

    a.  Let result be stmtResult.

7.  Return result.

RUNTIME SEMANTICS: EVALUATION

LabelledStatement : Identifier : Statement

1.  Let newLabelSet be a new empty List.

2.  Return the result of performing Labelled Evaluation of this
    LabelledStatement with argument newLabelSet.

Syntax

ThrowStatement :

THROW [no LineTerminator here] Expression ;

RUNTIME SEMANTICS: EVALUATION

The production ThrowStatement : THROW [no LineTerminator here]
Expression ; is evaluated as follows:

Syntax

TryStatement :

TRY Block Catch~
~TRY Block Finally~
~TRY Block Catch Finally

Catch :

CATCH ( CatchParameter ) Block

Finally :

FINALLY Block

CatchParameter :

BindingIdentifier~
~BindingPattern

NOTE The TRY statement encloses a block of code in which an exceptional
condition can occur, such as a runtime error or a THROW statement. The
CATCH clause provides the exception-handling code. When a catch clause
catches an exception, its Identifier is bound to that exception.

STATIC SEMANTICS: EARLY ERRORS

Catch : CATCH ( CatchParameter ) Block

-   It is a Syntax Error if any element of the BoundNames of
    CatchParameter also occurs in the LexicallyDeclaredNames of
    Block.

-   It is a Syntax Error if any element of the BoundNames of
    CatchParameter also occurs in the VarDeclaredNames of Block.

1.  

1.  

STATIC SEMANTICS: VARDECLAREDNAMES

TryStatement : TRY Block Catch

1.  Let names be VarDeclaredNames of Block.

2.  Append to names the elements of the VarDeclaredNames of Catch.

3.  Return names.

TryStatement : TRY Block Finally

1.  Let names be VarDeclaredNames of Block.

2.  Append to names the elements of the VarDeclaredNames of Finally.

3.  Return names.

TryStatement : TRY Block Catch Finally

1.  Let names be VarDeclaredNames of Block.

2.  Append to names the elements of the VarDeclaredNames of Catch.

3.  Append to names the elements of the VarDeclaredNames of Finally.

4.  Return names.

Catch : CATCH ( CatchParameter ) Block

1.  Return the VarDeclaredNames of Block.

1.  

RUNTIME SEMANTICS: BINDING INITIALISATION

  With arguments value and environment.

NOTE UNDEFINED is passed for environment to indicate that a PutValue
operation should be used to assign the initialisation value. This is the
case for VAR statements formal parameter lists of non-strict functions.
In those cases a lexical binding is hosted and preinitialized prior to
evaluation of its initializer.

1.  

CatchParameter: BindingPattern

1.  Let exceptionObj be ToObject(value).

2.  ReturnIfAbrupt(exceptionObj).

3.  Return the result of performing Binding Initialisation for
    BindingPattern passing exceptionObj and environment as the
    arguments.

RUNTIME SEMANTICS: CATCH CLAUSE EVALUATION

with parameter thrownValue

Catch : CATCH ( CatchParameter ) Block

NOTE No matter how control leaves the Block the LexicalEnvironment is
always restored to its former state.

RUNTIME SEMANTICS: EVALUATION

TryStatement : TRY Block Catch

TryStatement : TRY Block Finally

TryStatement : TRY Block Catch Finally

1.  Let B be the result of evaluating Block.

2.  If B.[[type]] is throw, then

    a.  Let C be the result of performing Catch Clause Evaluation of
        Catch with parameter B.value.

3.  Else B.[[type]] is not throw,

    a.  Let C be B.

4.  Let F be the result of evaluating Finally.

5.  If F.[[type]] is normal, return C.

6.  Return F.

1.  

1.  

1.  2.  

1.  

1.  2.  3.  4.  

Syntax

DebuggerStatement :

DEBUGGER ;

RUNTIME SEMANTICS: EVALUATION

NOTE Evaluating the DebuggerStatement production may allow an
implementation to cause a breakpoint when run under a debugger. If a
debugger is not present or active this statement has no observable
effect.

The production DebuggerStatement : DEBUGGER ; is evaluated as follows:

Syntax

FunctionDeclaration :

FUNCTION BindingIdentifier ( FormalParameterList ) { FunctionBody }

FunctionExpression :

FUNCTION BindingIdentifier~opt~ ( FormalParameterList ) { FunctionBody }

FormalParameterList :

[empty]
FunctionRestParameter
FormalsList
FormalsList, FunctionRestParameter

FormalsList :

FormalParameter
FormalsList , FormalParameter

FunctionRestParameter :

... BindingIdentifier

FormalParameter :

BindingElement

FunctionBody :

StatementList~opt~

STATIC SEMANTICS: EARLY ERRORS

FunctionDeclaration : FUNCTION BindingIdentifier (
FormalParameterList ) { FunctionBody }
and
FunctionExpression : FUNCTION BindingIdentifier~opt~ (
FormalParameterList ) { FunctionBody }

-   -   -   -   It is a Syntax Error if IsSimpleParameterList of
    FormalParameterList is TRUE and any element of the BoundNames of
    FormalParameterList also occurs in the VarDeclaredNames of
    FunctionBody.

-   It is a Syntax Error if IsSimpleParameterList of
    FormalParameterList is FALSE and BoundNames of
    FormalsParameterList contains any duplicate elements.

-   It is a Syntax Error if IsSimpleParameterList of
    FormalParameterList is FALSE and BoundNames of
    FormalParameterList contains either ″EVAL″ or ″ARGUMENTS″.

-   It is a Syntax Error if the source code matching this production is
    strict code and BoundNames of FormalsParameterList contains any
    duplicate elements.

-   It is a Syntax Error if any element of the BoundNames of
    FormalParameterList also occurs in the LexicallyDeclaredNames of
    FunctionBody.

-   It is a Syntax Error if FunctionBody Contains YieldExpression.

NOTE The LexicallyDeclaredNames of a FunctionBody does not include
identifiers bound using var or function declarations. Simple parameter
lists bind identifiers as VarDeclaredNames. Parameter lists that contain
destructuring patterns, default value initialisers, or a rest parameter
bind identifiers as LexicallyDeclaredNames. Multiple occurrences of the
same Identifier in a FormalParamterList is only allowed for
non-strict functions with simple parameter lists.

FunctionBody : _StatementList _

-   It is a Syntax Error if the LexicallyDeclaredNames of
    StatementList contains any duplicate entries.

-   It is a Syntax Error if any element of the LexicallyDeclaredNames of
    StatementList also occurs in the VarDeclaredNames of
    StatementList.

-   -   -   -   -   -   -   

-   -   

FormalParameter : BindingElement

-   It is a Syntax Error if BindingElement Contains YieldExpression.

STATIC SEMANTICS: BOUNDNAMES

FunctionDeclaration : FUNCTION BindingIdentifier (
FormalParameterList ) { FunctionBody }

1.  Return the BoundNames of BindingIdentifier.

FormalParameterList : [empty]

1.  Return an empty List.

1.  

1.  

FormalParameterList : FormalsList , FunctionRestParameter

1.  Let names be BoundNames of FormalsList.

2.  Append to names the BoundNames of FunctionRestParameter.

3.  Return names.

FormalsList : _FormalsList ,_ FormalParameter

1.  Let names be BoundNames of FormalsList.

2.  Append to names the elements of BoundNames of FormalParameter.

3.  Return names.

1.  

1.  

STATIC SEMANTICS: CONTAINS

  With parameter symbol.

FunctionDeclaration : FUNCTION BindingIdentifier (
FormalParameterList ) { FunctionBody }

1.  Return FALSE.

FunctionExpression : FUNCTION BindingIdentifier~opt~ (
FormalParameterList ) { FunctionBody }

1.  Return FALSE.

NOTE Static semantic rules that depend upon substructure generally do
not look into function definitions.

STATIC SEMANTICS: EXPECTEDARGUMENTCOUNT

FormalParameterList :

[empty]
FunctionRestParameter

1.  Return 0.

FormalParameterList :

FormalsList , FunctionRestParameter

1.  Return the ExpectedArgumentCount of FormalsList.

NOTE The ExpectedArgumentCount of a FormalParameterList is the number
of FormalParameters to the left of either the rest parameter or the
first FormalParameter with an Initialiser. A FormalParameter without
an initializer is allowed after the first parameter with an initializer
but such parameters are considered to be optional with UNDEFINED as
their default value.

FormalsList : FormalParameter

1.  If HasInitialiser of FormalParameter is FALSE return 0

2.  Return 1.

FormalsList : FormalsList, FormalParameter

1.  Let count be the ExpectedArgumentCount of FormalsList.

2.  If HasInitialiser of FormalsList is TRUE or HasInitialiser of
    FormalParameter is TRUE, then return count.

3.  Return count+1.

STATIC SEMANTICS: HASINITIALISER

1.  

FormalsList : _FormalsList ,_ FormalParameter

1.  If HasInitialiser of FormalsList is TRUE, then return TRUE.

2.  Return HasInitialiser of FormalParameter.

1.  

STATIC SEMANTICS: ISCONSTANTDECLARATION

FunctionDeclaration : FUNCTION BindingIdentifier (
FormalParameterList ) { FunctionBody }

1.  Return FALSE.

STATIC SEMANTICS: ISSIMPLEPARAMETERLIST

FormalParameterList : [empty]

1.  Return TRUE.

FormalParameterList : FunctionRestParameter

1.  Return FALSE.

FormalParameterList : FormalsList , FunctionRestParameter

1.  Return FALSE.

FormalsList : _FormalsList ,_ FormalParameter

1.  If IsSimpleParameterList of FormalsList is FALSE, return FALSE.

2.  Return IsSimpleParameterList of FormalParameter.

FormalParameter : BindingElement

1.  If HasInitialiser of BindingElement is TRUE, return FALSE.

2.  If FormalParameter Contains BindingPattern is TRUE, return
    FALSE.

3.  Return TRUE.

STATIC SEMANTICS: ISSTRICT

FunctionBody : StatementList~opt~

1.  If this FunctionBody is contained in strict code or if
    StatementList is strict code, then return TRUE. Otherwise, return
    FALSE.

2.  

STATIC SEMANTICS: LEXICALLYDECLAREDNAMES

FunctionDeclaration : FUNCTION BindingIdentifier (
FormalParameterList ) { FunctionBody }

1.  Return the BoundNames of BindingIdentifier.

FunctionBody : [empty]

1.  Return an empty List.

FunctionBody : StatementList

1.  Return TopLevelLexicallyDeclaredNames of StatementList.

1.  

STATIC SEMANTICS: VARDECLAREDNAMES

FunctionDeclaration : FUNCTION BindingIdentifier (
FormalParameterList ) { FunctionBody }

1.  Return an empty List.

FunctionBody : [empty]

1.  Return an empty List.

FunctionBody : StatementList

1.  Return TopLevelVarDeclaredNames of StatementList.

1.  

RUNTIME SEMANTICS: BINDING INITIALISATION

  With parameters value and environment.

NOTE When UNDEFINED is passed for environment it indicates that a
PutValue operation should be used to assign the initialisation value.
This is the case for formal parameter lists of non-strict functions. In
that case the formal parameter bindings are preinitialized in order to
deal with the possibility of multiple parameters with the same name.

FormalParameterList : [empty]

1.  Return NormalCompletion(empty).

FormalParameterList : FunctionRestParameter

1.  Return the result of performing Indexed Binding Initialisation for
    FunctionRestParameter using value, 0, and environment as the
    arguments.

2.  .

FormalParameterList : FormalsList

1.  2.  3.  Return the result of performing Indexed Binding
    Initialisation for FormalsList using value, 0, and environment
    as the arguments.

4.  

FormalParameterList : FormalsList , FunctionRestParameter

1.  Let restIndex be the result of performing Indexed Binding
    Initialisation for FormalsList using value, 0, and environment
    as the arguments.

2.  ReturnIfAbrupt(restIndex).

3.  Return the result of performing Indexed Binding Initialisation for
    FunctionRestParameter using value, restIndex, and
    environment as the arguments.

4.  

RUNTIME SEMANTICS: INDEXED BINDING INITIALISATION

  With parameters array, nextIndex, and environment.

FormalsList : FormalParameter

1.  Let status be the result of performing Indexed Binding
    Initialisation for FormalParameter using array, nextIndex, and
    environment as the arguments.

2.  ReturnIfAbrupt(status).

3.  Return nextIndex + 1.

FormalsList : FormalsList , FormalParameter

1.  Let lastIndex be the result of performing Indexed Binding
    Initialisation for FormalsList using array, nextIndex, and
    environment as the arguments.

2.  ReturnIfAbrupt(lastIndex).

3.  Let status be the result of performing Indexed Binding
    Initialisation for FormalParameter using array, lastIndex, and
    environment as the arguments.

4.  ReturnIfAbrupt(status).

5.  Return lastIndex + 1.

FunctionRestParameter : ... BindingIdentifier

1.  Assert: array is a well formed arguments object and hence it has a
    valid integer valued "LENGTH" property.

2.  Let status be the result of calling the [[Get]] internal method of
    array with argument "LENGTH".

3.  Let argumentsLength be status.[[value]].

4.  Let A be the result of the abstract operation ArrayCreate (15.4)
    with argument 0.

5.  Let n=0;

6.  Repeat, while nextIndex < argumentsLength

    a.  Let P be ToString(nextIndex).

    b.  Assert: array is a well formed arguments object, hence it must
          have a property _P_.

    c.  Let v be the result of calling the [[Get]] internal method of
        array passing P as the argument.

    d.  Call the [[DefineOwnProperty]] internal method of A with
          arguments ToString(n), Property Descriptor {[[Value]]:
          v.[[value]], [[Writable]]: TRUE, [[Enumerable]]: TRUE,
          [[Configurable]]: TRUE}, and FALSE.

    e.  Let n = n+1.

    f.  Let nextIndex = nextIndex +1.

7.  Return the result of performing Binding Initialisation for
    BindingIdentifier using A and environment as arguments.

1.  

RUNTIME SEMANTICS: INSTANTIATEFUNCTIONOBJECT

  With parameter scope.

FunctionDeclaration : FUNCTION BindingIdentifier (
FormalParameterList ) { FunctionBody }

RUNTIME SEMANTICS: EVALUATION

FunctionDeclaration : FUNCTION BindingIdentifier (
FormalParameterList ) { FunctionBody }

FunctionExpression : FUNCTION ( FormalParameterList ) {
FunctionBody }

1.  If the FunctionExpression is contained in strict code or if its
    FunctionBody is strict code, then let strict be TRUE. Otherwise
    let strict be FALSE.

2.  Let scope be the LexicalEnvironment of the running execution
    context.

3.  Let closure be the result of performing the FunctionCreate
    abstract operation with arguments Normal, FormalParameterList,
    _FunctionBody, scope_, and strict.

4.  Perform the abstract operation MakeConstructor with argument
    closure.

5.  Return closure.

FunctionExpression : FUNCTION BindingIdentifier (
FormalParameterList ) { FunctionBody }

NOTE 1 The BindingIdentifier in a FunctionExpression can be
referenced from inside the FunctionExpression's FunctionBody to
allow the function to call itself recursively. However, unlike in a
FunctionDeclaration, the BindingIdentifier in a FunctionExpression
cannot be referenced from and does not affect the scope enclosing the
FunctionExpression.

NOTE 2 A PROTOTYPE property is automatically created for every function
defined using a FunctionDeclaration or FunctionExpression, to allow
for the possibility that the function will be used as a constructor.

FunctionBody : StatementList~opt~

Syntax

ArrowFunction :

ArrowParameters => ConciseBody

ArrowParameters :

BindingIdentifier
CoverParenthesizedExpressionAndArrowParameterList

ConciseBody :

[lookahead ∉ { { }] AssignmentExpression
{ FunctionBody }

Supplemental Syntax

When processing the production ArrowParameters :
CoverParenthesizedExpressionAndArrowParameterList the following
grammar is used to refine the interpretation of
CoverParenthesizedExpressionAndArrowParameterList.

ArrowFormalParameterList :

( FormalParameterList )

STATIC SEMANTICS: EARLY ERRORS

ArrowFunction : ArrowParameters => ConciseBody

-   It is a Syntax Error if IsSimpleParameterList of ArrowParameters
    is TRUE and any element of the BoundNames of FormalParameterList
    also occurs in the VarDeclaredNames of ConciseBody.

-   It is a Syntax Error if IsSimpleParameterList of ArrowParameters
    is FALSE and BoundNames of ArrowParameters contains any duplicate
    elements.

-   It is a Syntax Error if IsSimpleParameterList of ArrowParameters
    is FALSE and BoundNames of ArrowParameters contains either ″EVAL″
    or ″ARGUMENTS″.

-   It is a Syntax Error if the source code matching this production is
    strict code and BoundNames of ArrowParameters contains any
    duplicate elements.

-   -   It is a Syntax Error if any element of the BoundNames of
    ArrowParameters also occurs in the LexicallyDeclaredNames of
    ConciseBody.

-   It is a Syntax Error if ConciseBody Contains YieldExpression.

ArrowParameters : BindingIdentifier

-   It is a Syntax Error if the StringValue of the sole element of the
    BoundNames of BindingIdentifier is EVAL or ARGUMENTS.

-   

ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList

-   It is a Syntax Error if the lexical token sequence matched by
    CoverParenthesizedExpressionAndArrowParameterList cannot be parsed
    with no tokens left over using ArrowFormalParameterList as the
    goal symbol.

-   

STATIC SEMANTICS: BOUNDNAMES

ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList

1.  Let formals be CoveredFormalsList of
    CoverParenthesizedExpressionAndArrowParameterList.

2.  Return the BoundNames of formals.

1.  

1.  

1.  

1.  

1.  

1.  2.  3.  

1.  

STATIC SEMANTICS: CONTAINS

  With parameter symbol.

ArrowFunction : _ArrowParameters =>_ ConciseBody

1.  If ArrowParameters Contains symbol is TRUE, return TRUE;

2.  Return ConciseBody Contains symbol .

ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList

1.  Let formals be CoveredFormalsList of
    CoverParenthesizedExpressionAndArrowParameterList.

2.  Return formals Contains symbol.

NOTE Contains is used to detect YIELD and SUPER usage within an
ArrowFunction.

STATIC SEMANTICS: COVEREDFORMALSLIST

CoverParenthesizedExpressionAndArrowParameterList:

( Expression )
( )
( ... Identifier )
( Expression , ... Identifier)

1.  Return the result of parsing the lexical token stream matched by
    CoverParenthesizedExpressionAndArrowParameterList using
    ArrowFormalParameterList as the goal symbol.

STATIC SEMANTICS: EXPECTEDARGUMENTCOUNT

ArrowParameters : BindingIdentifier

1.  Return 1.

1.  

1.  

ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList

1.  Let formals be CoveredFormalsList of
    CoverParenthesizedExpressionAndArrowParameterList.

2.  Return the ExpectedArgumentCount of formals.

STATIC SEMANTICS: ISSIMPLEPARAMETERLIST

ArrowParameters : BindingIdentifier

1.  Return TRUE.

ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList

1.  Let formals be CoveredFormalsList of
    CoverParenthesizedExpressionAndArrowParameterList.

2.  Return the IsSimpleParameterList of formals.

STATIC SEMANTICS: LEXICALLYDECLAREDNAMES

ConciseBody : [lookahead ∉ { { }] AssignmentExpression

1.  Return an empty List.

1.  

1.  

1.  

RUNTIME SEMANTICS: BINDING INITIALISATION

  With parameters value and environment.

NOTE When UNDEFINED is passed for environment it indicates that a
PutValue operation should be used to assign the initialisation value.
This is the case for formal parameter lists of non-strict functions. In
that case the formal parameter bindings are preinitialized in order to
deal with the possibility of multiple parameters with the same name.

ArrowParameters : BindingIdentifier

1.  Return the result of performing Binding Initialisation for
    BindingIdentifier using value and environment as the
    arguments.

ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList

1.  Let formals be CoveredFormalsList of
    CoverParenthesizedExpressionAndArrowParameterList.

2.  Return the result of performing Binding initialisation of formals
    with arguments value and environment.

1.  

1.  

1.  

1.  

1.  2.  3.  

RUNTIME SEMANTICS: EVALUATION

ArrowFunction : ArrowParameters => ConciseBody

1.  Let strict be TRUE.

2.  Let scope be the LexicalEnvironment of the running execution
    context.

3.  Let closure be the result of performing the FunctionCreate
    abstract operation with arguments Arrow, ArrowParameters,
    _ConciseBody, scope_, and strict.

4.  Return closure.

ConciseBody : [lookahead ∉ { { }] AssignmentExpression

1.  The code of this ConciseBody is strict mode code if it is
    contained in strict mode code or if any of the conditions in 10.1.1
    apply If the code of this ConciseBody is strict mode code,
    AssignmentExpression is evaluated in the following steps as strict
    mode code. Otherwise, AssignmentExpression is evaluated in the
    following steps as non-strict mode code.

2.  Let exprRef be the result of evaluating AssignmentExpression.

3.  Let exprValue be GetValue(exprRef).

4.  ReturnIfAbrupt(exprValue).

5.  Return Completion {[[type]]: return, [[value]]: exprValue,
    [[target]]: empty}.

1.  

Syntax

MethodDefinition :

PropertyName ( FormalParameterList ) { FunctionBody }
* PropertyName ( FormalParameterList ) { FunctionBody }
GET PropertyName ( ) { FunctionBody }
SET PropertyName ( PropertySetParameterList ) { FunctionBody }

PropertySetParameterList :

BindingIdentifier
BindingPattern

NOTE The single elemented of a PropertySetParameterList may not have a
default value Initialiser because.

STATIC SEMANTICS: EARLY ERRORS

MethodDefinition : PropertyName ( FormalParameterList ) {
FunctionBody }

and

MethodDefinition : * PropertyName ( FormalParameterList ) {
FunctionBody }

-   -   It is a Syntax Error if IsSimpleParameterList of
    FormalParameterList is TRUE and any element of the BoundNames of
    FormalParameterList also occurs in the VarDeclaredNames of
    FunctionBody.

-   It is a Syntax Error if IsSimpleParameterList of
    FormalParameterList is FALSE and BoundNames of
    FormalsParameterList contains any duplicate elements.

-   It is a Syntax Error if IsSimpleParameterList of
    FormalParameterList is FALSE and BoundNames of
    FormalParameterList contains either ″EVAL″ or ″ARGUMENTS″.

-   It is a Syntax Error if the source code matching this production is
    strict code and BoundNames of FormalsParameterList contains any
    duplicate elements.

-   It is a Syntax Error if any element of the BoundNames of
    FormalParameterList also occurs in the LexicallyDeclaredNames of
    FunctionBody.

-   

MethodDefinition : PropertyName ( FormalParameterList ) {
FunctionBody }

-   It is a Syntax Error if FunctionBody Contains YieldExpression.

MethodDefinition : * PropertyName ( FormalParameterList ) {
FunctionBody }

-   It is a Syntax Error if FunctionBody Contains YieldExpression is
    FALSE.

MethodDefinition : GET PropertyName ( ) { FunctionBody }

-   It is a Syntax Error if FunctionBody Contains YieldExpression.

MethodDefinition : SET PropertyName ( PropertySetParameterList ) {
FunctionBody }

-   It is a Syntax Error if IsSimpleParameterList of
    FormalParameterList is TRUE and any element of the BoundNames of
    FormalParameterList also occurs in the VarDeclaredNames of
    FunctionBody.

-   It is a Syntax Error if IsSimpleParameterList of
    FormalParameterList is FALSE and BoundNames of
    FormalsParameterList contains any duplicate elements.

-   It is a Syntax Error if IsSimpleParameterList of
    FormalParameterList is FALSE and BoundNames of
    FormalParameterList contains either ″EVAL″ or ″ARGUMENTS″.

-   It is a Syntax Error if BoundNames of PropertySetParameterList
    contains any duplicate elements.

-   It is a Syntax Error if any element of the BoundNames of
    PropertySetParameterList also occurs in the LexicallyDeclaredNames
    of FunctionBody.

-   It is a Syntax Error if PropertySetParameterList Contains
    YieldExpression.

-   It is a Syntax Error if FunctionBody Contains YieldExpression.

-   

1.  

1.  

STATIC SEMANTICS: EXPECTEDARGUMENTCOUNT

PropertySetParameterList : _BindingIdentifier _

1.  Return 1.

PropertySetParameterList : _BindingPattern _

1.  Return 1.

STATIC SEMANTICS: PROPNAME

MethodDefinition :

PropertyName ( FormalParameterList ) { FunctionBody }
* PropertyName ( FormalParameterList ) { FunctionBody }
GET PropertyName ( ) { FunctionBody }
SET PropertyName ( PropertySetParameterList ) { FunctionBody }

1.  Return PropName of PropertyName.

1.  

1.  

1.  

STATIC SEMANTICS: REFERENCESSUPER

MethodDefinition :

PropertyName ( FormalParameterList ) { FunctionBody }
* PropertyName ( FormalParameterList ) { FunctionBody }
GET PropertyName ( ) { FunctionBody }
SET PropertyName ( PropertySetParameterList ) { FunctionBody }

1.  Return FunctionBody Contains SUPER.

STATIC SEMANTICS: SPECIALMETHOD

MethodDefinition : PropertyName ( FormalParameterList ) {
FunctionBody }

1.  Return FALSE.

MethodDefinition :

* PropertyName ( FormalParameterList ) { FunctionBody }
GET PropertyName ( ) { FunctionBody }
SET PropertyName ( PropertySetParameterList ) { FunctionBody }

1.  Return TRUE.

RUNTIME SEMANTICS: PROPERTY DEFINITION EVALUATION

  With parameter object.

MethodDefinition : PropertyName ( FormalParameterList ) {
FunctionBody }

1.  Let propName be PropName of PropertyName.

2.  Let strict be IsStrict of FunctionBody.

3.  Let scope be the running execution context’s LexicalEnvironment.

4.  Let needsSuperBinding be the result of FunctionBody Contains
    SUPER.

5.  If needsSuperBinding is FALSE, then let needsSuperBinding be the
    result of FormalParameterList Contains SUPER.

6.  If needsSuperBinding, then

    a.  Let closure be the result of performing the FunctionCreate
        abstract operation with arguments Method, FormalParameterList,
        _FunctionBody, scope_, and strict and with object as the
        homeObject optional argument and propName as the
        methodName optional argument.

7.  Else

    a.  Let closure be the result of performing the FunctionCreate
        abstract operation with arguments Method, FormalParameterList,
        _FunctionBody, scope_, and strict.

8.  Let desc be the Property Descriptor{[[Value]]: closure,
    [[Writable]]: TRUE, [[Enumerable]]: TRUE, [[Configurable]]: TRUE}.

9.  Let status be the result of calling the [[DefineOwnProperty]]
    internal method of object with arguments propName, desc, and
    FALSE.

10. ReturnIfAbrupt(status).

11. NormalCompletion(closure).

MethodDefinition : * PropertyName ( FormalParameterList ) {
FunctionBody }

1.  Let propName be PropName of PropertyName.

2.  Let strict be IsStrict of FunctionBody.

3.  Let scope be the running execution context’s LexicalEnvironment.

4.  Let needsSuperBinding be the result of FunctionBody Contains
    SUPER.

5.  If needsSuperBinding is FALSE, then let needsSuperBinding be the
    result of FormalParameterList Contains SUPER.

6.  If needsSuperBinding, then

    a.  Let closure be the result of performing the FunctionCreate
        abstract operation with arguments Method, FormalParameterList,
        _FunctionBody, scope_, and strict and with object as the
        homeObject optional argument and propName as the
        methodName optional argument.

7.  Else

    a.  Let closure be the result of performing the FunctionCreate
        abstract operation with arguments Method, FormalParameterList,
        _FunctionBody, scope_, and strict.

8.  9.  Let desc be the Property Descriptor{[[Value]]: closure,
    [[Writable]]: TRUE, [[Enumerable]]: TRUE, [[Configurable]]: TRUE}.

10. Let status be the result of calling the [[DefineOwnProperty]]
    internal method of object with arguments propName, desc, and
    FALSE.

11. ReturnIfAbrupt(status).

12. Return NormalCompletion(closure).

MethodDefinition : GET PropertyName ( ) { FunctionBody }

1.  Let propName be PropName of PropertyName.

2.  Let strict be IsStrict of FunctionBody.

3.  Let scope be the running execution context’s LexicalEnvironment.

4.  Let formalParameterList be the production FormalParameterList :
    [empty]

5.  Let needsSuperBinding be the result of FunctionBody Contains
    SUPER.

6.  If needsSuperBinding, then

    a.  Let closure be the result of performing the FunctionCreate
        abstract operation with arguments Method, formalParameterList,
        _FunctionBody, scope_, and strict and with object as the
        homeObject optional argument and propName as the
        methodName optional argument.

7.  Else

    a.  Let closure be the result of performing the FunctionCreate
        abstract operation with arguments Method, formalParameterList,
        _FunctionBody, scope_, and strict.

8.  9.  10. Let desc be the Property Descriptor {[[Get]]: closure,
    [[Enumerable]]: TRUE, [[Configurable]]: TRUE}

11. Let status be the result of calling the [[DefineOwnProperty]]
    internal method of object with arguments propName, desc, and
    FALSE.

12. ReturnIfAbrupt(status).

13. Return NormalCompletion(closure).

MethodDefinition : SET PropertyName ( PropertySetParameterList ) {
FunctionBody }

1.  Let propName be PropName of PropertyName.

2.  Let strict be IsStrict of FunctionBody.

3.  Let scope be the running execution context’s LexicalEnvironment.

4.  Let needsSuperBinding be the result of FunctionBody Contains
    SUPER.

5.  If needsSuperBinding is FALSE, then let needsSuperBinding be the
    result of PropertySetParameterList Contains SUPER.

6.  If needsSuperBinding, then

    a.  Let closure be the result of performing the FunctionCreate
        abstract operation with arguments Method,
        PropertySetParameterList, _FunctionBody, scope_, and strict
        and with object as the homeObject optional argument and
        propName as the methodName optional argument.

7.  Else

    a.  Let closure be the result of performing the FunctionCreate
        abstract operation with arguments Method,
        PropertySetParameterList, _FunctionBody, scope_, and strict.

8.  9.  10. Let desc be the Property Descriptor {[[Set]]: closure,
    [[Enumerable]]: TRUE, [[Configurable]]: TRUE}

11. Let status be the result of calling the [[DefineOwnProperty]]
    internal method of object with arguments propName, desc, and
    FALSE.

12. ReturnIfAbrupt(status).

13. Return NormalCompletion(closure).

Syntax

GeneratorDeclaration :

FUNCTION * BindingIdentifier ( FormalParameterList ) { FunctionBody }

GeneratorExpression :

FUNCTION * BindingIdentifier~opt~ ( FormalParameterList ) { FunctionBody
}

YieldExpression :

YIELD YieldDelegator~opt~ [Lexical goal InputElementRegExp]
AssignmentExpression

YieldDelegator :

*

STATIC SEMANTICS: EARLY ERRORS

GeneratorDeclaration : FUNCTION * BindingIdentifier (
FormalParameterList ) { FunctionBody }
and
GeneratorExpression : FUNCTION * BindingIdentifier~opt~ (
FormalParameterList ) { FunctionBody }

-   It is a Syntax Error if any element of the BoundNames of
    FormalParameterList also occurs in the LexicallyDeclaredNames of
    FunctionBody.

-   It is a Syntax Error if FunctionBody Contains YieldExpression is
    FALSE.

YieldExpression : YIELD YieldDelegator~opt~ AssignmentExpression

-   It is a Syntax Error if AssignmentExpression Contains
    YieldExpression.

STATIC SEMANTICS: BOUNDNAMES

GeneratorDeclaration : FUNCTION * BindingIdentifier (
FormalParameterList ) { FunctionBody }

1.  Return the BoundNames of BindingIdentifier.

STATIC SEMANTICS: CONTAINS

  With parameter symbol.

GeneratorDeclaration : FUNCTION * BindingIdentifier (
FormalParameterList ) { FunctionBody }

1.  Return FALSE.

GeneratorExpression : FUNCTION * BindingIdentifier~opt~ (
FormalParameterList ) { FunctionBody }

1.  Return FALSE.

NOTE Static semantic rules that depend upon substructure generally do
not look into function definitions.

STATIC SEMANTICS: ISCONSTANTDECLARATION

GeneratorDeclaration : FUNCTION * BindingIdentifier (
FormalParameterList ) { FunctionBody }

1.  Return FALSE.

STATIC SEMANTICS: LEXICALLYDECLAREDNAMES

GeneratorDeclaration : FUNCTION * BindingIdentifier (
FormalParameterList ) { FunctionBody }

1.  Return the BoundNames of BindingIdentifier.

STATIC SEMANTICS: VARDECLAREDNAMES

GeneratorDeclaration : FUNCTION * BindingIdentifier (
FormalParameterList ) { FunctionBody }

1.  Return an empty List.

Syntax

ClassDeclaration:

CLASS BindingIdentifier ClassTail

ClassExpression :

CLASS BindingIdentifier~opt~ ClassTail

ClassTail :

ClassHeritage~opt~ { ClassBody~opt~ }

ClassHeritage:

EXTENDS AssignmentExpression

ClassBody :

ClassElementList

ClassElementList :

ClassElement
ClassElementList ClassElement

ClassElement :

MethodDefinition
;

STATIC SEMANTICS: EARLY ERRORS

ClassDeclaration : CLASS BindingIdentifier ClassTail
and
ClassExpression : CLASS BindingIdentifier ClassTail

-   It is a Syntax Error if BoundNames of BindingIdentifier contains
    either ″EVAL″ or ″ARGUMENTS″

ClassBody : ClassElementList

-   It is a Syntax Error if PropertyNameList of ClassElementList
    contains any duplicate entries, unless the following condition is
    true for each duplicate entry: The duplicated entry occurs exactly
    twice in the list and one occurrence was obtained from a GET
    accessor MethodDefinition and the other occurrence was obtained
    from a SET accessor MethodDefinition.

-   

ClassElement : MethodDefinition

-   It is a Syntax Error if PropName of MethodDefinition is
    ″CONSTRUCTOR″ and SpecialMethod of MethodDefinition is TRUE.

STATIC SEMANTICS: BOUNDNAMES

ClassDeclaration: CLASS BindingIdentifier ClassTail

1.  Return the BoundNames of BindingIdentifier.

STATIC SEMANTICS: CONSTRUCTORMETHOD

ClassBody : ClassElementList

1.  Let list be MethodDefinitions of ClassElementList.

2.  For each MethodDefinition m in list, do

    a.  If PropName of m is ″CONSTRUCTOR″, return m.

3.  Return empty.

NOTE Early Error rules ensure that there is only one method definition
named ″CONSTRUCTOR″ and that it isn’t an accessor property or generator
definition.

STATIC SEMANTICS: CONTAINS

  With parameter symbol.

ClassTail : ClassHeritage~opt~ { ClassBody }

1.  If symbol is ClassBody, return TRUE.

2.  If ClassHeritage is not present, return FALSE.

3.  If symbol is ClassHeritage, return TRUE.

4.  Return the result of Contains for ClassHeritage with argument
    symbol.

NOTE Static semantic rules that depend upon substructure generally do
not look into class bodies.

STATIC SEMANTICS: ISCONSTANTDECLARATION

ClassDeclaration: CLASS BindingIdentifier ClassTail

1.  Return FALSE.

STATIC SEMANTICS: LEXICALLYDECLAREDNAMES

ClassDeclaration: CLASS BindingIdentifier ClassTail

1.  Return the BoundNames of BindingIdentifier.

STATIC SEMANTICS: METHODDEFINITIONS

ClassElementList : ClassElement

1.  If PropName of ClassElement is empty, return a new empty List.

2.  Return a List containing ClassElement.

ClassElementList : ClassElementList ClassElement

1.  Let list be MethodDefinitions of ClassElementList.

2.  If PropName of ClassElement is empty, return list.

3.  Append ClassElement to the end of list.

4.  Return list.

STATIC SEMANTICS: PROPNAME

ClassElement : ;

1.  Return empty.

STATIC SEMANTICS: PROPERTYNAMELIST

ClassElementList : ClassElement

1.  If PropName of ClassElement is empty, return a new empty List.

2.  Return a List containing PropName of ClassElement.

ClassElementList : ClassElementList ClassElement

1.  Let list be PropertyNameList of ClassElementList.

2.  If PropName of ClassElement is empty, return list.

3.  Append PropName of ClassElement to the end of list.

4.  Return list.

STATIC SEMANTICS: VARDECLAREDNAMES

ClassDeclaration: CLASS BindingIdentifier ClassTail

1.  Return an empty List.

RUNTIME SEMANTICS: CLASSDEFINITIONEVALUATION

  With parameter className.

ClassTail : ClassHeritage~opt~ { ClassBody }

1.  If ClassHeritage~opt~ is not present, then

    a.  let protoParent be the intrinsic object %ObjectPrototype%.

    b.  Let constructorParent be the intrinsic object
        %FunctionPrototype%.

2.  Else

    a.  Let superclass be the result of evaluating ClassHeritage.

    b.  ReturnIfAbrupt(superclass).

    c.  If superclass is NULL, then

        i.  Let protoParent be NULL.

        ii. Let constructorParent be the intrinsic object
            %FunctionPrototype%.

    d.  Else if Type(superclass) is not Object, throw a TypeError
        exception.

    e.  Else if superclass does not have a [[Construct]] internal
        property, then

        i.  Let protoParent be superclass.

        ii. Let constructorParent be the intrinsic object
            %FunctionPrototype%.

    f.  Else

        i.  Let protoParent be the result of calling the [[Get]]
            internal method of superclass passing "PROTOTYPE" as the
            argument.

        ii. ReturnIfAbrupt(protoParent).

        iii. If Type(protoParent) is neither Object or Null, throw a
            TypeError exception.

        iv. Let constructorParent be superclass.

3.  Let proto be the result of the abstract operation ObjectCreate
    with argument protoParent.

4.  5.  Let lex be the LexicalEnvironment of the running execution
    context.

6.  If className is not UNDEFINED, then

    a.  Let scope be the result of calling NewDeclarativeEnvironment
        passing lex as the argument

    b.  Let envRec be scope’s environment record.

    c.  Call the CreateImmutableBinding concrete method of envRec
        passing className as the argument.

    d.  Set the running execution context’s LexicalEnvironment to
        scope.

7.  Let constructor be ConstructorMethod of ClassBody.

8.  If constructor is empty, then

    a.  Let constructor be the result of parsing the String
        "CONSTRUCTOR(... ARGS){SUPER.CONSTRUCTOR(...ARGS);}" using the
        syntactic grammar with the goal symbol MethodDefinition.

9.  If the ClassTail is contained in strict code or if constructor
    is strict code, then let strict be TRUE. Otherwise let strict be
    FALSE.

10. Let F be the result of performing Property Definition Evaluation
    for constructor with argument proto.

11. Perform the abstract operation MakeConstructor with argument F and
    FALSE as the optional writablePrototype argument and proto as
    the optional prototype argument.

12. Let desc be the Property Descriptor{[[Enumerable]]: false,
    [[Writable]]: TRUE, [[Configurable]]: TRUE}.

13. Call the [[DefineOwnProperty]] internal method of proto with
    arguments "CONSTRUCTOR", desc, and FALSE.

14. Let methods be MethodDefinitions of ClassBody.

15. For each MethodDefinition m in order from methods

    a.  Perform Property Definition Evaluation for m with argument
        proto.

16. Set the running execution context’s LexicalEnvironment to lex.

17. Return F.

RUNTIME SEMANTICS: EVALUATION

ClassDeclaration: CLASS BindingIdentifier ClassTail

1.  2.  Let value be the result of ClassDefinitionEvaluation of
    ClassTail with argument UNDEFINED.

3.  ReturnIfAbrupt(value).

4.  Let env be the running execution context’s LexicalEnvironment.

5.  Let status be the result of performing Binding Initialisation for
    BindingIdentifier passing value and env as the arguments.

6.  ReturnIfAbrupt(status).

7.  Return NormalCompletion(empty).

NOTE The argument to ClassDefinitionEvaluation controls whether or not
the class that is defined with a BindingIdentifier has a local binding
to the identifier. Only a ClassExpression gets a local name binding of
its name. A ClassDeclaration never has such a binding. This maintains
the parallel with FunctionExpression and FunctionDeclaration.

ClassExpression: CLASS BindingIdentifier~opt~ ClassTail

1.  If BindingIdentifier~opt~ is not present, then let className be
    UNDEFINED.

2.  Else, let className be StringValue of BindingIdentifier.

3.  Let value be the result of ClassDefinitionEvaluation of
    ClassTail with argument className.

4.  ReturnIfAbrupt(value).

5.  Return NormalCompletion(value).

RUNTIME SEMANTICS: FUNCTIONCREATE ABSTRACT OPERATION

The abstract operation FunctionCreate requires the arguments: kind
which is one of (Normal, Method, Arrow), an parameter list specified by
ParameterList, a body specified by Body, a Lexical Environment
specified by Scope, a Boolean flag Strict, and optionally, an object
functionPrototype, an object homeObject and a string methodName.
FunctionCreate performs the following steps:

RUNTIME SEMANTICS: MAKECONSTRUCTOR ABSTRACT OPERATION

The abstract operation MakeConstructor requires a Function argument F
and optionally, a Boolean writablePrototype and an object prototype.
If prototype is provided it is assume to already contain a
"CONSTRUCTOR" whose value is F. It converts F into a constructor by
performs the following steps:

1.  Let installNeeded be FALSE.

2.  If the prototype argument was not provided,then

3.  If the writablePrototype argument was not provided,then

    a.  Let writablePrototype be TRUE.

4.  Set the [[Construct]] internal property of F as described in
    13.5.2.

5.  Set the [[HasInstance]] internal property of F as described in
    15.3.5.3.

6.  If installNeeded, then

7.  a.  b.  c.  d.  Call the [[DefineOwnProperty]] internal method of
        prototype with arguments "CONSTRUCTOR", Property Descriptor
        {[[Value]]: F, [[Writable]]: writablePrototype,
        [[Enumerable]]: FALSE, [[Configurable]]: writablePrototype },
        and FALSE.

7.  Call the [[DefineOwnProperty]] internal method of F with arguments
    "PROTOTYPE", Property Descriptor {[[Value]]: prototype ,
    [[Writable]]: writablePrototype , [[Enumerable]]: FALSE,
    [[Configurable]]: FALSE}, and FALSE.

1.  

8.  Return.

The [[Call]] internal method for a Function object F is called with
parameters thisArgument and argumentsList, a List of ECMAScript
values. The following steps are taken:

The [[Construct]] internal method for a Function object F is called
with a single parameter argumentsList which is a possibly empty List
of ECMAScript values. The following steps are taken:

The [[ThrowTypeError]] object is a unique function object that is
defined once as follows:

RUNTIME SEMANTICS: ADDRESTRICTEDFUNCTIONPROPERTIES ABSTRACT OPERATION

The abstraction operation is call with a function object F as its
argument. It performs the following steps:

1.  2.  Let thrower be the [[ThrowTypeError]] function Object defined
    above.

3.  Call the [[DefineOwnProperty]] internal method of F with arguments
    "CALLER", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
    thrower, [[Enumerable]]: FALSE, [[Configurable]]: FALSE}, and
    FALSE.

4.  Call the [[DefineOwnProperty]] internal method of F with arguments
    "ARGUMENTS", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
    thrower, [[Enumerable]]: FALSE, [[Configurable]]: FALSE}, and
    FALSE.

The wiki proposal has a preliminary attempt at defining tail position.
See http://wiki.ecmascript.org/doku.php?id=harmony:proper_tail_calls.

This material still needs to be reviewed and updated for incorporation
here.

Syntax

Script :

ScriptBody~opt~

ScriptBody :

OuterStatementList

OuterStatementList :

OuterItem
OuterStatementList OuterItem

OuterItem :

ModuleDeclaration
ImportDeclaration
StatementListItem

STATIC SEMANTICS: EARLY ERRORS

ScriptBody : OuterStatementList

-   It is a Syntax Error if the LexicallyDeclaredNames of
    OuterStatementList contains any duplicate entries.

-   It is a Syntax Error if any element of the LexicallyDeclaredNames of
    OuterStatementList also occurs in the VarDeclaredNames of
    OuterStatementList.

-   It is a Syntax Error if OuterStatementList Contains
    ReturnStatement.

-   It is a Syntax Error if OuterStatementList Contains SUPER.

-   It is a Syntax Error if OuterStatementList Contains
    YieldExpression.

NOTE Additional error conditions relating to conflicting or duplicate
declarations are checked during module linking prior to evaluation of a
Script. If any such errors are detected the Script is not evaluated.

STATIC SEMANTICS: ISSTRICT

ScriptBody : OuterStatementList

1.  If this ScriptBody is contained in strict code or if
    OuterStatementList is strict code, then return TRUE. Otherwise,
    return FALSE.

STATIC SEMANTICS: LEXICALLYDECLAREDNAMES

OuerStatementList : _OuterStatementList OuterItem_

1.  Let names be LexicallyDeclaredNames of OuterStatementList.

2.  Append to names the elements of the LexicallyDeclaredNames of
    OuterItem.

3.  Return names.

OuterItem : ModuleDeclaration

1.  Return the BoundNames of ImportDeclaration.

OuterItem : ImportDeclaration

1.  Return the BoundNames of ImportDeclaration.

OuterItem : StatementListItem

1.  Return TopLevelLexicallyDeclaredNames of StatementListItem.

NOTE At the top level of a Script, function declarations are treated
like var declarations rather than like lexical declarations.

STATIC SEMANTICS: LEXICALLYSCOPEDDECLARATIONS

OuerStatementList : _OuterStatementList OuterItem_

1.  Let declarations be LexicallyScopedDeclarations of
    OuterStatementList.

2.  Append to declarations the elements of the
    LexicallyScopedDeclarations of OuterItem.

3.  Return declarations.

OuterItem : ModuleDeclaration

1.  Return a new List containing ModuleDeclaration.

OuterItem : ImportDeclaration

1.  Return a new List containing ImportDeclaration.

OuterItem : StatementListItem

1.  Return TopLevelLexicallyScopedDeclarations of StatementListItem.

STATIC SEMANTICS: VARDECLAREDNAMES

OuerStatementList : _OuterStatementList OuterItem_

1.  Let names be VarDeclaredNames of OuterStatementList.

2.  Append to names the elements of the VarDeclaredNames of
    OuterItem.

3.  Return names.

OuterItem : ModuleDeclaration

1.  Return an empty List.

OuterItem : ImportDeclaration

1.  Return an empty List.

OuterItem : StatementListItem

1.  Return TopLevelVarDeclaredNames of StatementListItem.

STATIC SEMANTICS: VARSCOPEDDECLARATIONS

OuerStatementList : _OuterStatementList OuterItem_

1.  Let declarations be VarScopedDeclarations of OuterStatementList.

2.  Append to declarations the elements of the VarScopedDeclarations
    of OuterItem.

3.  Return declarations.

OuterItem : ModuleDeclaration

1.  Return a new empty List.

OuterItem : ImportDeclaration

1.  Return a new empty List.

OuterItem : StatementListItem

1.  Return the TopLevelVarScopedDeclarations of StatementListItem.

RUNTIME SEMANTICS: SCRIPT EVALUATION

  With argument realm and deletableBindings.

Script : ScriptBody~opt~

NOTE The processes for initiating the evaluation of a Script and for
dealing with the result of such an evaluation are defined by an
ECMAScript implementation and not by this specification.

RUNTIME SEMANTICS: EVALUATION

OuterStatementList : OuterStatementList OuterItem

1.  Let sl be the result of evaluating OuterSatementList.

2.  ReturnIfAbrupt(sl).

3.  Let s be the result of evaluating OuterItem.

4.  If s.[[type]] is throw, return s.

5.  If s.[[value]] is empty, let V = sl.[[value]], otherwise let
    V = s.[[value]].

6.  Return Completion {[[type]]: s.[[type]], [[value]]: V,
    [[target]]: s.[[target]]}.

NOTE See the 12.1 NOTE regarding evaluation of StatementList :
_StatementList StatementListItem._

A Directive Prologue is the longest sequence of ExpressionStatement
productions occurring as the initial StatementListItem productions of
a ScriptBody or FunctionBody and where each ExpressionStatement in
the sequence consists entirely of a StringLiteral token followed a
semicolon. The semicolon may appear explicitly or may be inserted by
automatic semicolon insertion. A Directive Prologue may be an empty
sequence.

A Use Strict Directive is an ExpressionStatement in a Directive
Prologue whose StringLiteral is either the exact character sequences
"USE STRICT" or 'USE STRICT'. A Use Strict Directive may not contain an
EscapeSequence or LineContinuation.

A Directive Prologue may contain more than one Use Strict Directive.
However, an implementation may issue a warning if this occurs.

NOTE The ExpressionStatement productions of a Directive Prologue are
evaluated normally during evaluation of the containing production.
Implementations may define implementation specific meanings for
ExpressionStatement productions which are not a Use Strict Directive
and which occur in a Directive Prologue. If an appropriate notification
mechanism exists, an implementation should issue a warning if it
encounters in a Directive Prologue an ExpressionStatement that is not
a Use Strict Directive or which does not have a meaning defined by the
implementation.

There are certain built-in objects available whenever an ECMAScript
program begins execution. One, the global object, is part of the lexical
environment of the executing program. Others are accessible as initial
properties of the global object.

Unless specified otherwise, a built-in object has the [[NativeBrand]]
internal property with value NativeFunction if that built-in object has
a [[Call]] internal property. Unless specified otherwise, the
[[Extensible]] internal property of a built-in object initially has the
value TRUE.

Many built-in objects are functions: they can be invoked with arguments.
Some of them furthermore are constructors: they are functions intended
for use with the NEW operator. For each built-in function, this
specification describes the arguments required by that function and
properties of the Function object. For each built-in constructor, this
specification furthermore describes properties of the prototype object
of that constructor and properties of specific object instances returned
by a NEW expression that invokes that constructor.

Unless otherwise specified in the description of a particular function,
if a function or constructor described in this clause is given fewer
arguments than the function is specified to require, the function or
constructor shall behave exactly as if it had been given sufficient
additional arguments, each such argument being the UNDEFINED value.

Unless otherwise specified in the description of a particular function,
if a function or constructor described in this clause is given more
arguments than the function is specified to allow, the extra arguments
are evaluated by the call and then ignored by the function. However, an
implementation may define implementation specific behaviour relating to
such arguments as long as the behaviour is not the throwing of a
TYPEERROR exception that is predicated simply on the presence of an
extra argument.

NOTE Implementations that add additional capabilities to the set of
built-in functions are encouraged to do so by adding new functions
rather than adding new parameters to existing functions.

Every built-in function and every built-in constructor has the Function
prototype object, which is the initial value of the expression
FUNCTION.PROTOTYPE (15.3.4), as the value of its [[Prototype]] internal
property.

Unless otherwise specified every built-in prototype object has the
Object prototype object, which is the initial value of the expression
OBJECT.PROTOTYPE (15.2.4), as the value of its [[Prototype]] internal
property, except the Object prototype object itself.

None of the built-in functions described in this clause that are not
constructors shall implement the [[Construct]] internal method unless
otherwise specified in the description of a particular function. The
behavior specified in this clause for each built-in function is the
specification of the [[Call]] internal method behavior for that
function. None of the built-in functions described in this clause shall
have a PROTOTYPE property unless otherwise specified in the description
of a particular function.

This clause generally describes distinct behaviours for when a
constructor is “called as a function” and for when it is “called as part
of a NEW expression”. The “called as a function” behaviour corresponds
to the invocation of the constructor’s [[Call]] internal method and the
“called as part of a new expression” behaviour corresponds to the
invocation of the constructor’s [[Construct]] internal method.

Every built-in Function object, F, described in this clause—whether as
a constructor, an ordinary function, or both—has the properties that are
defined by performing the following step when the function object is
created:

1. Perform the AddRestrictedFunctionProperties (13.6.3) abstract
operator with argument F.

Every built-in Function object described in this clause—whether as a
constructor, an ordinary function, or both—has a LENGTH property whose
value is an integer. Unless otherwise specified, this value is equal to
the largest number of named arguments shown in the subclause headings
for the function description, including optional parameters.

NOTE For example, the Function object that is the initial value of the
slice property of the String prototype object is described under the
subclause heading “String.prototype.slice (start, end)” which shows the
two named arguments start and end; therefore the value of the length
property of that Function object is 2.

In every case, the LENGTH property of a built-in Function object
described in this clause has the attributes { [[Writable]]: FALSE,
[[Enumerable]]: FALSE, [[Configurable]]: FALSE }. Every other property
described in this clause has the attributes { [[Writable]]: TRUE,
[[Enumerable]]: FALSE, [[Configurable]]: TRUE } unless otherwise
specified.

The unique _global object_ is created before control enters any
execution context.

Unless otherwise specified, the standard built-in properties of the
global object have attributes {[[Writable]]: TRUE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE}.

The global object does not have a [[Construct]] internal property; it is
not possible to use the global object as a constructor with the NEW
operator.

The global object does not have a [[Call]] internal property; it is not
possible to invoke the global object as a function.

The value of the [[Prototype]] internal property of the global object is
implementation-dependent.

In addition to the properties defined in this specification the global
object may have additional host defined properties. This may include a
property whose value is the global object itself; for example, in the
HTML document object model the WINDOW property of the global object is
the global object itself.

The value of NAN is NAN (see 8.5). This property has the attributes {
[[Writable]]: FALSE, [[Enumerable]]: FALSE, [[Configurable]]: FALSE }.

The value of INFINITY is +∞ (see 8.5). This property has the attributes
{ [[Writable]]: FALSE, [[Enumerable]]: FALSE, [[Configurable]]: FALSE }.

The value of UNDEFINED is UNDEFINED (see 8.1). This property has the
attributes { [[Writable]]: FALSE, [[Enumerable]]: FALSE,
[[Configurable]]: FALSE }.

When the EVAL function is called with one argument x, the following
steps are taken:

NOTE The eval code cannot instantiate variable or function bindings in
the variable environment of the calling context that invoked the eval if
either the code of the calling context or the eval code is strict code.
Instead such bindings are instantiated in a new VariableEnvironment that
is only accessible to the eval code.

A direct call to the eval function is one that is expressed as a
CallExpression that meets the following two conditions:

The Reference that is the result of evaluating the MemberExpression in
the CallExpression has an environment record as its base value and its
reference name is "EVAL".

The result of calling the abstract operation GetValue with that
Reference as the argument is the standard built-in function defined in
15.1.2.1.

The PARSEINT function produces an integer value dictated by
interpretation of the contents of the string argument according to the
specified radix. Leading white space in string is ignored. If
radix is UNDEFINED or 0, it is assumed to be 10 except when the number
begins with the character pairs 0X or 0X, in which case a radix of 16 is
assumed. If radix is 16, the number may also optionally begin with the
character pairs 0X or 0X.

When the PARSEINT function is called, the following steps are taken:

NOTE PARSEINT may interpret only a leading portion of string as an
integer value; it ignores any characters that cannot be interpreted as
part of the notation of an integer, and no indication is given that any
such characters were ignored.

The PARSEFLOAT function produces a Number value dictated by
interpretation of the contents of the string argument as a decimal
literal.

When the PARSEFLOAT function is called, the following steps are taken:

NOTE PARSEFLOAT may interpret only a leading portion of string as a
Number value; it ignores any characters that cannot be interpreted as
part of the notation of an decimal literal, and no indication is given
that any such characters were ignored.

Returns TRUE if the argument coerces to NAN, and otherwise returns
FALSE.

NOTE A reliable way for ECMAScript code to test if a value X is a NAN is
an expression of the form X !== X. The result will be TRUE if and only
if X is a NAN.

Returns FALSE if the argument coerces to NAN, +∞, or −∞, and otherwise
returns TRUE.

Uniform Resource Identifiers, or URIs, are Strings that identify
resources (e.g. web pages or files) and transport protocols by which to
access them (e.g. HTTP or FTP) on the Internet. The ECMAScript language
itself does not provide any support for using URIs except for functions
that encode and decode URIs as described in 15.1.3.1, 15.1.3.2, 15.1.3.3
and 15.1.3.4.

NOTE Many implementations of ECMAScript provide additional functions and
methods that manipulate web pages; these functions are beyond the scope
of this standard.

A URI is composed of a sequence of components separated by component
separators. The general form is:

Scheme : First / Second ; Third ? Fourth

where the italicised names represent components and “:”, “/”, “;” and
“?” are reserved characters used as separators. The ENCODEURI and
DECODEURI functions are intended to work with complete URIs; they assume
that any reserved characters in the URI are intended to have special
meaning and so are not encoded. The ENCODEURICOMPONENT and
DECODEURICOMPONENT functions are intended to work with the individual
component parts of a URI; they assume that any reserved characters
represent text and so must be encoded so that they are not interpreted
as reserved characters when the component is part of a complete URI.

The following lexical grammar specifies the form of encoded URIs.

Syntax

uri :::

uriCharacters~opt~

uriCharacters :::

uriCharacter uriCharacters~opt~

uriCharacter :::

uriReserved
uriUnescaped
uriEscaped

uriReserved ::: ONE OF

; / ? : @ & = + $ ,

uriUnescaped :::

uriAlpha
DecimalDigit
uriMark

uriEscaped :::

% HexDigit HexDigit

uriAlpha ::: ONE OF

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

uriMark ::: ONE OF

- _ . ! ~ * ' ( )

NOTE The above syntax is based upon RFC 2396 and does not reflect
changes introduced by the more recent RFC 3986.

RUNTIME SEMANTICS

When a character to be included in a URI is not listed above or is not
intended to have the special meaning sometimes given to the reserved
characters, that character must be encoded. The character is transformed
into its UTF-8 encoding, with surrogate pairs first converted from
UTF-16 to the corresponding code point value. (Note that for code units
in the range [0,127] this results in a single octet with the same
value.) The resulting sequence of octets is then transformed into a
String with each octet represented by an escape sequence of the form
“%xx”.

RUNTIME SEMANTICS: ENCODE ABSTRACT OPERATION

The encoding and escaping process is described by the abstract operation
Encode taking two String arguments string and unescapedSet.

RUNTIME SEMANTICS: DECODE ABSTRACT OPERATION

The unescaping and decoding process is described by the abstract
operation Decode taking two String arguments string and reservedSet.

NOTE This syntax of Uniform Resource Identifiers is based upon RFC 2396
and does not reflect the more recent RFC 3986 which replaces RFC 2396. A
formal description and implementation of UTF-8 is given in RFC 3629.

In UTF-8, characters are encoded using sequences of 1 to 6 octets. The
only octet of a "sequence" of one has the higher-order bit set to 0, the
remaining 7 bits being used to encode the character value. In a sequence
of n octets, n>1, the initial octet has the n higher-order bits set to
1, followed by a bit set to 0. The remaining bits of that octet contain
bits from the value of the character to be encoded. The following octets
all have the higher-order bit set to 1 and the following bit set to 0,
leaving 6 bits in each to contain bits from the character to be encoded.
The possible UTF-8 encodings of ECMAScript characters are specified in
Table 26.

Table 28 — UTF-8 Encodings

  ------------------- --------------------- --------------- --------------- --------------- ---------------
  _CODE UNIT VALUE_   REPRESENTATION      _1^ST^ OCTET_   _2^ND^ OCTET_   _3^RD^ OCTET_   _4^TH^ OCTET_

  0X0000 - 0X007F     00000000 0zzzzzzz   0zzzzzzz                                      

  0X0080 - 0X07FF     00000_yyy yyzzzzzz_   110yyyyy      10zzzzzz                      

  0X0800 - 0XD7FF     _xxxxyyyy yyzzzzzz_   1110xxxx      10yyyyyy      10zzzzzz      

  0XD800 - 0XDBFF     110110_vv vvwwwwxx_   11110uuu      10uuwwww      10xxyyyy      10zzzzzz
                                                                                            
  _followed by_       _followed by_                                                         
                                                                                            
  0XDC00 – 0XDFFF     110111_yy yyzzzzzz_                                                   

  0XD800 - 0XDBFF     causes URIError                                                     
                                                                                            
  _not followed by_                                                                         
                                                                                            
  0XDC00 – 0XDFFF                                                                           

  0XDC00 – 0XDFFF     causes URIError                                                     

  0XE000 - 0XFFFF     _xxxxyyyy yyzzzzzz_   1110xxxx      10yyyyyy      10zzzzzz      
  ------------------- --------------------- --------------- --------------- --------------- ---------------

Where

uuuuu = vvvv + 1

to account for the addition of 0x10000 as in Surrogates, section 3.7, of
the Unicode Standard.

The range of code unit values 0xD800-0xDFFF is used to encode surrogate
pairs; the above transformation combines a UTF-16 surrogate pair into a
UTF-32 representation and encodes the resulting 21-bit value in UTF-8.
Decoding reconstructs the surrogate pair.

RFC 3629 prohibits the decoding of invalid UTF-8 octet sequences. For
example, the invalid sequence C0 80 must not decode into the character
U+0000. Implementations of the Decode algorithm are required to throw a
URIERROR when encountering such invalid sequences.

The DECODEURI function computes a new version of a URI in which each
escape sequence and UTF-8 encoding of the sort that might be introduced
by the ENCODEURI function is replaced with the character that it
represents. Escape sequences that could not have been introduced by
ENCODEURI are not replaced.

When the DECODEURI function is called with one argument encodedURI,
the following steps are taken:

NOTE The character “#” is not decoded from escape sequences even though
it is not a reserved URI character.

The DECODEURICOMPONENT function computes a new version of a URI in which
each escape sequence and UTF-8 encoding of the sort that might be
introduced by the ENCODEURICOMPONENT function is replaced with the
character that it represents.

When the DECODEURICOMPONENT function is called with one argument
encodedURIComponent, the following steps are taken:

The ENCODEURI function computes a new version of a URI in which each
instance of certain characters is replaced by one, two, three, or four
escape sequences representing the UTF-8 encoding of the character.

When the ENCODEURI function is called with one argument uri, the
following steps are taken:

NOTE The character “#” is not encoded to an escape sequence even though
it is not a reserved or unescaped URI character.

The ENCODEURICOMPONENT function computes a new version of a URI in which
each instance of certain characters is replaced by one, two, three, or
four escape sequences representing the UTF-8 encoding of the character.

When the ENCODEURICOMPONENT function is called with one argument
uriComponent, the following steps are taken:

See 15.2.1 and 15.2.2.

See 15.3.1 and 15.3.2.

See 15.4.1 and 15.4.2.

See 15.5.1 and 15.5.2.

See 15.6.1 and 15.6.2.

See 15.7.1 and 15.7.2.

See 15.9.2.

See 15.10.3 and 15.10.4.

See 15.11.1 and 15.11.2.

See 15.11.6.1.

See 15.11.6.2.

See 15.11.6.3.

See 15.11.6.4.

See 15.11.6.5.

See 15.11.6.6.

See 15.8.

See 15.12.

RUNTIME SEMANTICS: OBJECTCREATE ABSTRACT OPERATION

The abstract operation ObjectCreate with optional argument proto (an
object or null) is used to specify the creation of new Object objects.
It performs the following steps:

When OBJECT is called as a function rather than as a constructor, it
performs a type conversion.

When the OBJECT function is called with no arguments or with one
argument value, the following steps are taken:

When OBJECT is called as part of a NEW expression, it is a constructor
that may create an object.

When the OBJECT constructor is called with no arguments or with one
argument value, the following steps are taken:

The value of the [[Prototype]] internal property of the Object
constructor is the standard built-in Function prototype object.

Besides the internal properties and the LENGTH property (whose value is
1), the Object constructor has the following properties:

The initial value of OBJECT.PROTOTYPE is the standard built-in Object
prototype object (15.2.4).

This property has the attributes {[[Writable]]: false, [[Enumerable]]:
false, [[Configurable]]: false }.

When the GETPROTOTYPEOF function is called with argument O, the
following steps are taken:

When the GETOWNPROPERTYDESCRIPTOR function is called, the following
steps are taken:

When the GETOWNPROPERTYNAMES function is called, the following steps are
taken:

NOTE If O is a String instance, the set of own properties processed in
step 4 includes the implicit properties defined in 15.5.5.2 that
correspond to character positions within the object’s [[PrimitiveValue]]
String.

The CREATE function creates a new object with a specified prototype.
When the CREATE function is called, the following steps are taken:

The DEFINEPROPERTY function is used to add an own property and/or update
the attributes of an existing own property of an object. When the
DEFINEPROPERTY function is called, the following steps are taken:

The DEFINEPROPERTIES function is used to add own properties and/or
update the attributes of existing own properties of an object. When the
DEFINEPROPERTIES function is called, the following steps are taken:

1.  Return the result of the abstract operation ObjectDefineProperties
    with arguments O and Properties.

RUNTIME SEMANTICS: OBJECTDEFINEPROPERTIES ABSTRACT OPERATION

The abstract operation ObjectDefineProperties with arguments O and
Properties performs the following steps:

If an implementation defines a specific order of enumeration for the
for-in statement, that same enumeration order must be used to order the
list elements in step 3 of this algorithm.

NOTE An exception in defining an individual property in step 7 does not
terminate the process of defining other properties. All valid property
definitions are processed.

When the SEAL function is called, the following steps are taken:

When the FREEZE function is called, the following steps are taken:

When the PREVENTEXTENSIONS function is called, the following steps are
taken:

When the ISSEALED function is called with argument O, the following
steps are taken:

When the ISFROZEN function is called with argument O, the following
steps are taken:

When the ISEXTENSIBLE function is called with argument O, the
following steps are taken:

When the KEYS function is called with argument O, the following steps
are taken:

If an implementation defines a specific order of enumeration for the
for-in statement, that same enumeration order must be used in step 5 of
this algorithm.

TODO :

-   Only enumerable own properties of source

-   Invoke [[Get]] on property list derived from source, for each
    property in list [[Put]] on target

-   private names are not copied

-   unique names are copied

-   super mechanism (rebind super)

-   Returns modified "target"

1.  2.  

The value of the [[Prototype]] internal property of the Object prototype
object is NULL and the initial value of the [[Extensible]] internal
property is TRUE.

The initial value of OBJECT.PROTOTYPE.CONSTRUCTOR is the standard
built-in OBJECT constructor.

When the TOSTRING method is called, the following steps are taken:

Table 29 — [[NativeBrand]] Tag Values

  [[NATIVEBRAND]] VALUE   TAG VALUE
  ----------------------- -------------
  NativeFunction          "FUNCTION"
  NativeArray             "ARRAY"
  StringWrapper           "STRING"
  BooleanWrapper          "BOOLEAN"
  NumberWrapper           "NUMBER"
  NativeMath              "MATH"
  NativeDate              "DATE"
  NativeRegExp            "REGEXP"
  NativeError             "ERROR"
  NativeJSON              "JSON"
  NativeArguments         "ARGUMENTS"

NOTE Historically, this function was occasionally used to access the
string value of the [[Class]] internal property that was used in
previous editions of this specification as a nominal type tag for
various built-in objects. This definition of TOSTRING preserves the
ability to use it as a reliable test for those specific kinds of
built-in objects but it does not provide a reliable type testing
mechanism for other kinds of built-in or program defined objects.

When the TOLOCALESTRING method is called, the following steps are taken:

1.  Let O be the THIS value.

2.  ReturnIfAbrupt(O).

3.  4.  5.  Return the result of the abstract operation Invoke with
    arguments "TOSTRING", O, and an empty arguments List.

NOTE 1 This function is provided to give all Objects a generic
TOLOCALESTRING interface, even though not all may use it. Currently,
ARRAY, NUMBER, and DATE provide their own locale-sensitive
TOLOCALESTRING methods.

NOTE 2 The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that implementations
do not use this parameter position for anything else.

When the VALUEOF method is called, the following steps are taken:

When the HASOWNPROPERTY method is called with argument V, the
following steps are taken:

NOTE 1 Unlike [[HasProperty]] (8.12.6), this method does not consider
objects in the prototype chain.

NOTE 2 The ordering of steps 1 and 2 is chosen to ensure that any
exception that would have been thrown by step 1 in previous editions of
this specification will continue to be thrown even if the THIS value is
UNDEFINED or NULL.

When the ISPROTOTYPEOF method is called with argument V, the following
steps are taken:

NOTE The ordering of steps 1 and 2 is chosen to preserve the behaviour
specified by previous editions of this specification for the case where
V is not an object and the this value is undefined or null.

When the PROPERTYISENUMERABLE method is called with argument V, the
following steps are taken:

NOTE 1 This method does not consider objects in the prototype chain.

NOTE 2 The ordering of steps 1 and 2 is chosen to ensure that any
exception that would have been thrown by step 1 in previous editions of
this specification will continue to be thrown even if the THIS value is
UNDEFINED or NULL.

Object instances have no special properties beyond those inherited from
the Object prototype object.

When FUNCTION is called as a function rather than as a constructor, it
creates and initialises a new Function object. Thus the function call
FUNCTION(…) is equivalent to the object creation expression NEW
FUNCTION(…) with the same arguments.

When the FUNCTION function is called with some arguments p1, p2, … ,
pn, body (where n might be 0, that is, there are no “p”
arguments, and where body might also not be provided), the following
steps are taken:

When FUNCTION is called as part of a NEW expression, it is a
constructor: it initialises the newly created object.

The last argument specifies the body (executable code) of a function;
any preceding arguments specify formal parameters.

When the FUNCTION constructor is called with some arguments p1, p2,
… , pn, body (where n might be 0, that is, there are no “p”
arguments, and where body might also not be provided), the following
steps are taken:

A PROTOTYPE property is automatically created for every function, to
provide for the possibility that the function will be used as a
constructor.

NOTE It is permissible but not necessary to have one argument for each
formal parameter to be specified. For example, all three of the
following expressions produce the same result:

  new Function("a", "b", "c", "return a+b+c")

  new Function("a, b, c", "return a+b+c")

  new Function("a,b", "c", "return a+b+c")

The Function constructor is itself a Function object and has a
[[NativeBrand]] internal property whose value is NativeFunction. The
value of the [[Prototype]] internal property of the Function constructor
is the standard built-in Function prototype object (15.3.4).

The value of the [[Extensible]] internal property of the Function
constructor is TRUE.

The Function constructor has the following properties:

The initial value of FUNCTION.PROTOTYPE is the standard built-in
Function prototype object (15.3.4).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

This is a data property with a value of 1. This property has the
attributes { [[Writable]]: FALSE, [[Enumerable]]: FALSE,
[[Configurable]]: FALSE }.

The Function prototype object is itself a Function object and has a
[[NativeBrand]] internal property whose value is NativeFunction . When
invoked, it accepts any arguments and returns UNDEFINED.

The value of the [[Prototype]] internal property of the Function
prototype object is the standard built-in Object prototype object
(15.2.4). The initial value of the [[Extensible]] internal property of
the Function prototype object is TRUE.

The function prototype object does not have a PROTOTYPE property.

The Function prototype object does not have a VALUEOF property of its
own; however, it inherits the VALUEOF property from the Object prototype
Object.

The LENGTH property of the Function prototype object is 0.

The initial value of FUNCTION.PROTOTYPE.CONSTRUCTOR is the built-in
FUNCTION constructor.

An implementation-dependent representation of the function is returned.
This representation has the syntax of a FunctionDeclaration. Note in
particular that the use and placement of white space, line terminators,
and semicolons within the representation String is
implementation-dependent.

The TOSTRING function is not generic; it throws a TYPEERROR exception if
its THIS value is not a Function object. Therefore, it cannot be
transferred to other kinds of objects for use as a method.

When the APPLY method is called on an object func with arguments
thisArg and argArray, the following steps are taken:

The LENGTH property of the APPLY method is 2.

NOTE The thisArg value is passed without modification as the THIS value.
This is a change from Edition 3, where a UNDEFINED or NULL thisArg is
replaced with the global object and ToObject is applied to all other
values and that result is passed as the THIS value.

When the CALL method is called on an object func with argument
thisArg and optional arguments arg1, arg2 etc, the following steps
are taken:

The LENGTH property of the CALL method is 1.

NOTE The thisArg value is passed without modification as the THIS value.
This is a change from Edition 3, where a UNDEFINED or NULL thisArg is
replaced with the global object and ToObject is applied to all other
values and that result is passed as the THIS value.

The bind method takes one or more arguments, thisArg and (optionally)
arg1, arg2, etc, and returns a new function object by performing the
following steps:

The LENGTH property of the BIND method is 1.

NOTE Function objects created using FUNCTION.PROTOTYPE.BIND do not have
a PROTOTYPE property or the [[Code]], [[FormalParameters]], and
[[Scope]] internal properties.

When the [[Call]] internal method of a function object, F, which was
created using the bind function is called with parameters thisArgument
and argumentsList, a List of ECMAScript, the following steps are
taken:

When the [[Construct]] internal method of a function object, F that
was created using the bind function is called with a list of arguments
ExtraArgs, the following steps are taken:

When the [[HasInstance]] internal method of a function object F, that
was created using the bind function is called with argument V, the
following steps are taken:

In addition to the required internal properties, every function instance
has a [[Call]] internal property and in most cases uses a different
version of the [[Get]] internal property. Depending on how they are
created (see 8.6.2, 13.6, 15, and 15.3.4.5), function instances may have
a [[HasInstance]] internal property, a [[Scope]] internal property, a
[[Construct]] internal property, a [[FormalParameters]] internal
property, a [[Code]] internal property, a [[TargetFunction]] internal
property, a [[BoundThis]] internal property, and a [[BoundArgs]]
internal property.

Every function instance has a [[NativeBrand]] internal property whose
value is NativeFunction.

Function instances that correspond to strict mode functions (13.6) and
function instances created using the FUNCTION.PROTOTYPE.BIND METHOD
(15.3.4.5) have properties named “caller” and “arguments” that throw a
TYPEERROR exception. An ECMAScript implementation must not associate any
implementation specific behaviour with accesses of these properties from
strict mode function code.

The value of the LENGTH property is an integer that indicates the
“typical” number of arguments expected by the function. However, the
language permits the function to be invoked with some other number of
arguments. The behaviour of a function when invoked on a number of
arguments other than the number specified by its LENGTH property depends
on the function. This property has the attributes { [[Writable]]: FALSE,
[[Enumerable]]: FALSE, [[Configurable]]: FALSE }.

The value of the PROTOTYPE property is used to initialise the
[[Prototype]] internal property of a newly created object before the
Function object is invoked as a constructor for that newly created
object. This property has the attribute { [[Writable]]: TRUE,
[[Enumerable]]: FALSE, [[Configurable]]: FALSE }.

NOTE Function objects created using FUNCTION.PROTOTYPE.BIND do not have
a PROTOTYPE property.

Assume F is a Function object.

When the [[HasInstance]] internal method of F is called with value
V, the following steps are taken:

NOTE Function objects created using FUNCTION.PROTOTYPE.BIND have a
different implementation of [[HasInstance]] defined in 15.3.4.5.3.

Function objects use a variation of the [[Get]] internal method used for
other native ECMAScript objects (8.12.3).

Assume F is a Function object. When the [[Get]] internal method of F
is called with property name P, the following steps are taken:

NOTE Function objects created using FUNCTION.PROTOTYPE.BIND use the
default [[Get]] internal method.

Array objects give special treatment to a certain class of property
names. A property name P (in the form of a String value) is an _array
index_ if and only if ToString(ToUint32(P)) is equal to P and
ToUint32(P) is not equal to 2^32^−1. A property whose property name is
an array index is also called an element. Every Array object has a
LENGTH property whose value is always a nonnegative integer less than
2^32^. The value of the LENGTH property is numerically greater than the
name of every property whose name is an array index; whenever a property
of an Array object is created or changed, other properties are adjusted
as necessary to maintain this invariant. Specifically, whenever a
property is added whose name is an array index, the LENGTH property is
changed, if necessary, to be one more than the numeric value of that
array index; and whenever the LENGTH property is changed, every property
whose name is an array index whose value is not smaller than the new
length is automatically deleted. This constraint applies only to own
properties of an Array object and is unaffected by LENGTH or array index
properties that may be inherited from its prototypes.

An object, O, is said to be sparse if the following algorithm
returns TRUE:

1.  Let len be the result of calling the [[Get]] internal method of
    O with argument "LENGTH".

2.  For each integer i in the range 0≤i_<ToUint32(_len)

    a.  Let elem be the result of calling the [[GetOwnProperty]]
        internal method of O with argument ToString(i).

    b.  If elem is UNDEFINED, return TRUE.

3.  Return FALSE.

RUNTIME SEMANTICS: ARRAYCREATE ABSTRACT OPERATION

The abstract operation ArrayCreate with argument length (a positive
integer) is used to specify the creation of new Array objects. It
performs the following steps:

1.  Let A be a newly created ECMAScript object.

2.  Set the [[Prototype]] internal property of A to the intrinsic
    object %ArrayPrototype%.

3.  Set A’s common internal methods except for [[DefineOwnProperty]]
    to the default definitions specified in 8.12.

4.  Set A’s [[DefineOwnProperty]] internal method to the definition
    given in 15.4.5.1.

5.  Set the [[NativeBrand]] internal property of A to the value
    NativeArray.

6.  Set the [[Extensible]] internal property of A to TRUE.

7.  Call the default [[DefineOwnProperty]] internal method (8.12.9) on
    A with arguments "LENGTH", Property Descriptor {[[Value]]:
    length, [[Writable]]: TRUE, [[Enumerable]]: FALSE,
    [[Configurable]]: FALSE}, and FALSE.

8.  Return A.

NOTE When ARRAY is called as a function rather than as a constructor, it
creates and initialises a new Array object. Thus the function call
ARRAY(…) is equivalent to the object creation expression NEW ARRAY(…)
with the same arguments.

When the ARRAY function is called the following steps are taken:

NOTE When ARRAY is called as part of a NEW expression, it is a
constructor: it initialises the newly created object.

This description applies if and only if the Array constructor is given
no arguments or at least two arguments.

This description applies if and only if the Array constructor is given
exactly one argument.

1.  If Type(len) is not Number, then

    a.  Let array be the result of the abstract operation ArrayCreate
        (15.4) with argument 1.

    b.  ReturnIfAbrupt(array).

    c.  Let defineStatus be the result of calling the
        [[DefineOwnProperty]] internal method of array with arguments
        "0", Property Descriptor {[[Value]]: len, [[Writable]]: TRUE,
        [[Enumerable]]: TRUE, [[Configurable]]: TRUE}, and TRUE.

    d.  ReturnIfAbrupt(defineStatus).

    e.  Return array.

2.  Let intLen be ToUint32(len).

3.  If intLen ≠ len, then throw a RangeError exception.

4.  Let array be the result of the abstract operation ArrayCreate
    (15.4) with argument intLen.

5.  Return array.

The value of the [[Prototype]] internal property of the Array
constructor is the Function prototype object (15.3.4).

Besides the internal properties and the LENGTH property (whose value is
1), the Array constructor has the following properties:

The initial value of ARRAY.PROTOTYPE is the Array prototype object
(15.4.4).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

The isArray function takes one argument arg, and returns the Boolean
value TRUE if the argument is an object whose class internal property is
"ARRAY"; otherwise it returns FALSE. The following steps are taken:

1.  If Type(arg) is not Object, return FALSE.

2.  If arg has the [[NativeBrand]] internal property with value
    NativeArray, then return TRUE.

3.  Return FALSE.

When the OF method is called with any number of arguments, the following
steps are taken:

1.  Let lenValue be the result of calling the [[Get]] internal method
    of items with the argument "LENGTH".

2.  Let len be ToInteger(lenValue).

3.  Let C be the THIS value.

4.  If isConstructor(C) is TRUE, then

    a.  Let newObj be the result of calling the [[Construct]] internal
        method of C with an argument list containing the single item
        len.

    b.  Let A be ToObject(newObj).

5.  Else,

    a.  Let A be the result of the abstract operation ArrayCreate
        (15.4) with argument len.

6.  ReturnIfAbrupt(A).

7.  Let k be 0.

8.  Repeat, while k < len

    a.  Let Pk be ToString(k).

    b.  Let kValue be the result of calling the [[Get]] internal
        method of items with argument Pk.

    c.  Let defineStatus be the result of calling the
        [[DefineOwnProperty]] internal method of A with arguments
        Pk, Property Descriptor {[[Value]]: kValue.[[value]],
        [[Writable]]: TRUE, [[Enumerable]]: TRUE, [[Configurable]]:
        TRUE}, and TRUE.

    d.  ReturnIfAbrupt(defineStatus).

    e.  Increase k by 1.

9.  Let putStatus be the result of calling the [[Put]] internal method
    of A with arguments "LENGTH", len, and TRUE.

10. ReturnIfAbrupt(putStatus).

11. Return A.

The LENGTH property of the OF method is 0.

NOTE 1 The items argument is assume to be a well-formed rest argument
value.

NOTE 2 The OF function is an intentionally generic factory method; it
does not require that its THIS value be the Array constructor. Therefore
it can be transferred to or inherited by other constructors that may be
called with a single numeric argument.

When the FROM method is called with argument arrayLike, the following
steps are taken:

1.  Let items be ToObject(arrayLike).

2.  ReturnIfAbrupt(items).

3.  Let lenValue be the result of calling the [[Get]] internal method
    of items with the argument "LENGTH".

4.  Let len be ToInteger(lenValue).

5.  ReturnIfAbrupt(len).

6.  Let C be the THIS value.

7.  If isConstructor(C) is TRUE, then

    a.  Let newObj be the result of calling the [[Construct]] internal
        method of C with an argument list containing the single item
        len.

    b.  Let A be ToObject(newObj).

8.  Else,

    a.  Let A be the result of the abstract operation ArrayCreate
        (15.4) with argument len.

9.  ReturnIfAbrupt(A).

10. Let k be 0.

11. Repeat, while k < len

    a.  Let Pk be ToString(k).

    b.  Let kPresent be the result of calling the [[HasProperty]]
        internal method of items with argument Pk.

    c.  If kPresent is TRUE, then

        i.  Let kValue be the result of calling the [[Get]] internal
            method of items with argument Pk.

        ii. ReturnIfAbrupt(kValue).

        iii. Let defineStatus be the result of calling the
            [[DefineOwnProperty]] internal method of A with arguments
            Pk, Property Descriptor {[[Value]]: kValue.[[value]],
            [[Writable]]: TRUE, [[Enumerable]]: TRUE, [[Configurable]]:
            TRUE}, and TRUE.

        iv. ReturnIfAbrupt(defineStatus).

    d.  Increase k by 1.

12. Let putStatus be the result of calling the [[Put]] internal method
    of A with arguments "LENGTH", len, and TRUE.

13. ReturnIfAbrupt(putStatus).

14. Return A.

NOTE The FROM function is an intentionally generic factory method; it
does not require that its THIS value be the Array constructor. Therefore
it can be transferred to or inherited by any other constructors that may
be called with a single numeric argument.

The value of the [[Prototype]] internal property of the Array prototype
object is the standard built-in Object prototype object (15.2.4).

The Array prototype object is itself an array; it has an [[NativeBrand]]
internal property with value NativeArray, and it has a LENGTH property
(whose initial value is +0) and the special [[DefineOwnProperty]]
internal method described in 15.4.5.1.

In following descriptions of functions that are properties of the Array
prototype object, the phrase “this object” refers to the object that is
the THIS value for the invocation of the function. It is permitted for
the THIS to be an object which does not have an [[NativeBrand]] internal
property with value NativeArray.

NOTE The Array prototype object does not have a VALUEOF property of its
own; however, it inherits the VALUEOF property from the standard
built-in Object prototype Object.

The initial value of ARRAY.PROTOTYPE.CONSTRUCTOR is the standard
built-in ARRAY constructor.

When the TOSTRING method is called, the following steps are taken:

1.  Let array be the result of calling ToObject on the THIS value.

2.  ReturnIfAbrupt(array).

3.  Let func be the result of calling the [[Get]] internal method of
    array with argument "JOIN".

4.  ReturnIfAbrupt(func).

5.  If IsCallable(func) is FALSE, then let func be the standard
    built-in method Object.prototype.toString (15.2.4.2).

6.  Return the result of calling the [[Call]] internal method of func
    providing array as thisArgument and an empty List as
    argumentsList.

NOTE The TOSTRING function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the TOSTRING
function can be applied successfully to an exotic object that is not an
Array is implementation-dependent.

The elements of the array are converted to Strings using their
TOLOCALESTRING methods, and these Strings are then concatenated,
separated by occurrences of a separator String that has been derived in
an implementation-defined locale-specific way. The result of calling
this function is intended to be analogous to the result of TOSTRING,
except that the result of this function is intended to be
locale-specific.

The result is calculated as follows:

NOTE 1 The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that implementations
do not use this parameter position for anything else.

NOTE 2 The TOLOCALESTRING function is intentionally generic; it does not
require that its THIS value be an Array object. Therefore it can be
transferred to other kinds of objects for use as a method. Whether the
TOLOCALESTRING function can be applied successfully to an exotic object
that is not an Array is implementation-dependent.

When the CONCAT method is called with zero or more arguments item1,
item2, etc., it returns an array containing the array elements of the
object followed by the array elements of each argument in order.

The following steps are taken:

The LENGTH property of the CONCAT method is 1.

NOTE 1 The explicit setting of the LENGTH property in step 7 is
necessary to ensure that its value is correct in situations where the
trailing elements of the result Array are not present.

NOTE 2 The CONCAT function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the CONCAT
function can be applied successfully to an exotic object that is not an
Array is implementation-dependent.

The elements of the array are converted to Strings, and these Strings
are then concatenated, separated by occurrences of the separator. If
no separator is provided, a single comma is used as the separator.

The JOIN method takes one argument, separator, and performs the
following steps:

The LENGTH property of the JOIN method is 1.

NOTE The JOIN function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore, it can be transferred
to other kinds of objects for use as a method. Whether the JOIN function
can be applied successfully to an exotic object that is not an Array is
implementation-dependent.

The last element of the array is removed from the array and returned.

NOTE The POP function is intentionally generic; it does not require that
its THIS value be an Array object. Therefore it can be transferred to
other kinds of objects for use as a method. Whether the POP function can
be applied successfully to an exotic object that is not an Array is
implementation-dependent.

The arguments are appended to the end of the array, in the order in
which they appear. The new length of the array is returned as the result
of the call.

When the PUSH method is called with zero or more arguments item1,
item2, etc., the following steps are taken:

The LENGTH property of the PUSH method is 1.

NOTE The PUSH function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the PUSH function
can be applied successfully to an exotic object that is not an Array is
implementation-dependent.

The elements of the array are rearranged so as to reverse their order.
The object is returned as the result of the call.

NOTE The REVERSE function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore, it can be transferred
to other kinds of objects for use as a method. Whether the REVERSE
function can be applied successfully to an exotic object that is not an
Array is implementation-dependent.

The first element of the array is removed from the array and returned.

1.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(O).

3.  Let lenVal be the result of calling the [[Get]] internal method of
    O with argument "LENGTH".

4.  Let len be ToUint32(lenVal).

5.  ReturnIfAbrupt(len).

6.  If len is zero, then

    a.  Let putStatus be the result of calling the [[Put]] internal
        method of O with arguments "LENGTH", 0, and TRUE.

    b.  ReturnIfAbrupt(putStatus).

    c.  Return UNDEFINED.

7.  Let first be the result of calling the [[Get]] internal method of
    O with argument "0".

8.  ReturnIfAbrupt(first).

9.  Let k be 1.

10. Repeat, while k < len

    a.  Let from be ToString(k).

    b.  Let to be ToString(k–1).

    c.  Let fromPresent be the result of calling the [[HasProperty]]
        internal method of O with argument from.

    d.  If fromPresent is TRUE, then

        i.  Let fromVal be the result of calling the [[Get]] internal
            method of O with argument from.

        ii. ReturnIfAbrupt(fromVal).

        iii. Let putStatus be the result of calling the [[Put]]
            internal method of O with arguments to, fromVal, and
            TRUE.

        iv. ReturnIfAbrupt(putStatus).

    e.  Else fromPresent is FALSE,

        i.  Let deleteStatus be the result of calling the [[Delete]]
            internal method of O with arguments to and TRUE.

        ii. ReturnIfAbrupt(deleteStatus).

    f.  Increase k by 1.

11. Let deleteStatus be the result of calling the [[Delete]] internal
    method of O with arguments ToString(len–1) and TRUE.

12. ReturnIfAbrupt(deleteStatus).

13. Let putStatus be the result of calling the [[Put]] internal method
    of O with arguments "LENGTH", (len–1) , and TRUE.

14. ReturnIfAbrupt(putStatus).

15. Return first.

NOTE The SHIFT function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the SHIFT
function can be applied successfully to an exotic object that is not an
Array is implementation-dependent.

The SLICE method takes two arguments, start and end, and returns an
array containing the elements of the array from element start up to,
but not including, element end (or through the end of the array if
end is UNDEFINED). If start is negative, it is treated as
length_+_start where length is the length of the array. If end is
negative, it is treated as length_+_end where length is the length
of the array. The following steps are taken:

The LENGTH property of the SLICE method is 2.

NOTE 1 The explicit setting of the LENGTH property of the result Array
in step 15 is necessary to ensure that its value is correct in
situations where the trailing elements of the result Array are not
present.

NOTE 2 The SLICE function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the SLICE
function can be applied successfully to an exotic object that is not an
Array is implementation-dependent.

The elements of this array are sorted. The sort is not necessarily
stable (that is, elements that compare equal do not necessarily remain
in their original order). If comparefn is not UNDEFINED, it should be
a function that accepts two arguments x and y and returns a negative
value if x < y, zero if x = y, or a positive value if x > y.

Let obj be the result of calling ToObject passing the THIS value as
the argument.

Let len be the result of applying Uint32 to the result of calling the
[[Get]] internal method of obj with argument "LENGTH".

If comparefn is not UNDEFINED and is not a consistent comparison
function for the elements of this array (see below), the behaviour of
SORT is implementation-defined.

Let proto be the value of the [[Prototype]] internal property of
obj. If proto is not NULL and there exists an integer j such that
all of the conditions below are satisfied then the behaviour of SORT is
implementation-defined:

-   obj is sparse (15.4)

-   0 ≤ j < len

-   The result of calling the [[HasProperty]] internal method of proto
    with argument ToString(j) is TRUE.

The behaviour of SORT is also implementation defined if obj is sparse
and any of the following conditions are true:

-   The [[Extensible]] internal property of obj is FALSE.

-   Any array index property of obj whose name is a nonnegative
    integer less than len is a data property whose [[Configurable]]
    attribute is FALSE.

The behaviour of SORT is also implementation defined if any array index
property of obj whose name is a nonnegative integer less than len is
an accessor property or is a data property whose [[Writable]] attribute
is FALSE.

Otherwise, the following steps are taken.

The returned object must have the following two properties.

-   There must be some mathematical permutation π of the nonnegative
    integers less than len, such that for every nonnegative integer
    j less than len, if property old[j] existed, then new[π(j)]
    is exactly the same value as old[j],. But if property old[j] did
    not exist, then new[π(j)] does not exist.

-   Then for all nonnegative integers j and k, each less than len,
    if SortCompare(j_,_k) < 0 (see SortCompare below), then Π(j) <
    Π(k).

Here the notation old[j] is used to refer to the hypothetical result
of calling the [[Get]] internal method of obj with argument j before
this function is executed, and the notation new[j] to refer to the
hypothetical result of calling the [[Get]] internal method of obj with
argument j after this function has been executed.

A function comparefn is a consistent comparison function for a set of
values S if all of the requirements below are met for all values a,
b, and c (possibly the same value) in the set S: The notation
a_ <~CF~ _b means comparefn_(_a_,_b) < 0; a_ =~CF~ _b means
comparefn_(_a_,_b) = 0 (of either sign); and a_ >~CF~ _b means
comparefn_(_a_,_b) > 0.

-   Calling comparefn_(_a_,_b) always returns the same value v when
    given a specific pair of values a and b as its two arguments.
    Furthermore, Type(v) is Number, and v is not NaN. Note that this
    implies that exactly one of a_ <~CF~ _b, a_ =~CF~ _b, and
    a_ >~CF~ _b will be true for a given pair of a and b.

-   Calling comparefn_(_a_,_b) does not modify the THIS object.

-   a_ =~CF~ _a (reflexivity)

-   If a_ =~CF~ _b, then b_ =~CF~ _a (symmetry)

-   If a_ =~CF~ _b and b_ =~CF~ _c, then a_ =~CF~ _c (transitivity
    of =~CF~)

-   If a_ <~CF~ _b and b_ <~CF~ _c, then a_ <~CF~ _c (transitivity
    of <~CF~)

-   If a_ >~CF~ _b and b_ >~CF~ _c, then a_ >~CF~ _c (transitivity
    of >~CF~)

NOTE The above conditions are necessary and sufficient to ensure that
comparefn divides the set S into equivalence classes and that these
equivalence classes are totally ordered.

RUNTIME SEMANTICS: SORTCOMPARE ABSTRACT OPERATION

When the SortCompare abstract operation is called with two arguments j
and k, the following steps are taken:

NOTE 1 Because non-existent property values always compare greater than
UNDEFINED property values, and UNDEFINED always compares greater than
any other value, undefined property values always sort to the end of the
result, followed by non-existent property values.

NOTE 2 The SORT function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore, it can be transferred
to other kinds of objects for use as a method. Whether the SORT function
can be applied successfully to an exotic object that is not an Array is
implementation-dependent.

When the SPLICE method is called with two or more arguments start,
deleteCount and (optionally) item1, item2, etc., the deleteCount
elements of the array starting at array index start are replaced by
the arguments item1, item2, etc. An Array object containing the
deleted elements (if any) is returned. The following steps are taken:

The LENGTH property of the SPLICE method is 2.

NOTE 1 The explicit setting of the LENGTH property of the result Array
in step 13 is necessary to ensure that its value is correct in
situations where its trailing elements are not present.

NOTE 2 The SPLICE function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the SPLICE
function can be applied successfully to an exotic object that is not an
Array is implementation-dependent.

The arguments are prepended to the start of the array, such that their
order within the array is the same as the order in which they appear in
the argument list.

When the UNSHIFT method is called with zero or more arguments item1,
item2, etc., the following steps are taken:

The LENGTH property of the UNSHIFT method is 1.

NOTE The UNSHIFT function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the UNSHIFT
function can be applied successfully to an exotic object that is not an
Array is implementation-dependent.

INDEXOF compares searchElement to the elements of the array, in
ascending order, using the internal Strict Equality Comparison Algorithm
(11.9.1), and if found at one or more positions, returns the index of
the first such position; otherwise, -1 is returned.

The optional second argument fromIndex defaults to 0 (i.e. the whole
array is searched). If it is greater than or equal to the length of the
array, -1 is returned, i.e. the array will not be searched. If it is
negative, it is used as the offset from the end of the array to compute
fromIndex. If the computed index is less than 0, the whole array will
be searched.

When the INDEXOF method is called with one or two arguments, the
following steps are taken:

1.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(O).

3.  Let lenValue be the result of calling the [[Get]] internal method
    of O with the argument "LENGTH".

4.  Let len be ToUint32(lenValue).

5.  ReturnIfAbrupt(len).

6.  If len is 0, return -1.

7.  If argument fromIndex was passed let n be
    ToInteger(fromIndex); else let n be 0.

8.  ReturnIfAbrupt(n).

9.  If n ≥ len, return -1.

10. If n ≥ 0, then

    a.  Let k be n.

11. Else n<0,

    a.  Let k be len - abs(n).

    b.  If k < 0, then let k be 0.

12. Repeat, while k_<_len

    a.  Let kPresent be the result of calling the [[HasProperty]]
        internal method of O with argument ToString(k).

    b.  If kPresent is TRUE, then

        i.  Let elementK be the result of calling the [[Get]] internal
            method of O with the argument ToString(k).

        ii. ReturnIfAbrupt(elementK).

        iii. Let same be the result of performing the Strict Equality
            Comparison Algorithm searchElement === elementK.

        iv. If same is TRUE, return k.

    c.  Increase k by 1.

13. Return -1.

The LENGTH property of the INDEXOF method is 1.

NOTE The INDEXOF function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the INDEXOF
function can be applied successfully to an exotic object that is not an
Array is implementation-dependent.

LASTINDEXOF compares searchElement to the elements of the array in
descending order using the internal Strict Equality Comparison Algorithm
(11.9.1), and if found at one or more positions, returns the index of
the last such position; otherwise, -1 is returned.

The optional second argument fromIndex defaults to the array's length
minus one (i.e. the whole array is searched). If it is greater than or
equal to the length of the array, the whole array will be searched. If
it is negative, it is used as the offset from the end of the array to
compute fromIndex. If the computed index is less than 0, -1 is
returned.

When the LASTINDEXOF method is called with one or two arguments, the
following steps are taken:

The LENGTH property of the LASTINDEXOF method is 1.

NOTE The LASTINDEXOF function is intentionally generic; it does not
require that its THIS value be an Array object. Therefore it can be
transferred to other kinds of objects for use as a method. Whether the
LASTINDEXOF function can be applied successfully to an exotic object
that is not an Array is implementation-dependent.

callbackfn should be a function that accepts three arguments and
returns a value that is coercible to the Boolean value TRUE or FALSE.
EVERY calls callbackfn once for each element present in the array, in
ascending order, until it finds one where callbackfn returns FALSE. If
such an element is found, EVERY immediately returns FALSE. Otherwise, if
callbackfn returned TRUE for all elements, EVERY will return TRUE.
callbackfn is called only for elements of the array which actually
exist; it is not called for missing elements of the array.

If a thisArg parameter is provided, it will be used as the THIS value
for each invocation of callbackfn. If it is not provided, UNDEFINED is
used instead.

callbackfn is called with three arguments: the value of the element,
the index of the element, and the object being traversed.

EVERY does not directly mutate the object on which it is called but the
object may be mutated by the calls to callbackfn.

The range of elements processed by EVERY is set before the first call to
callbackfn. Elements which are appended to the array after the call to
EVERY begins will not be visited by callbackfn. If existing elements
of the array are changed, their value as passed to callbackfn will be
the value at the time EVERY visits them; elements that are deleted after
the call to EVERY begins and before being visited are not visited. EVERY
acts like the "for all" quantifier in mathematics. In particular, for an
empty array, it returns TRUE.

When the EVERY method is called with one or two arguments, the following
steps are taken:

The LENGTH property of the EVERY method is 1.

NOTE The EVERY function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the EVERY
function can be applied successfully to an exotic object that is not an
Array is implementation-dependent.

callbackfn should be a function that accepts three arguments and
returns a value that is coercible to the Boolean value TRUE or FALSE.
SOME calls callbackfn once for each element present in the array, in
ascending order, until it finds one where callbackfn returns TRUE. If
such an element is found, SOME immediately returns TRUE. Otherwise, SOME
returns FALSE. callbackfn is called only for elements of the array
which actually exist; it is not called for missing elements of the
array.

If a thisArg parameter is provided, it will be used as the THIS value
for each invocation of callbackfn. If it is not provided, UNDEFINED is
used instead.

callbackfn is called with three arguments: the value of the element,
the index of the element, and the object being traversed.

SOME does not directly mutate the object on which it is called but the
object may be mutated by the calls to callbackfn.

The range of elements processed by SOME is set before the first call to
callbackfn. Elements that are appended to the array after the call to
SOME begins will not be visited by callbackfn. If existing elements of
the array are changed, their value as passed to callbackfn will be the
value at the time that SOME visits them; elements that are deleted after
the call to SOME begins and before being visited are not visited. SOME
acts like the "exists" quantifier in mathematics. In particular, for an
empty array, it returns FALSE.

When the SOME method is called with one or two arguments, the following
steps are taken:

The LENGTH property of the SOME method is 1.

NOTE The SOME function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the SOME function
can be applied successfully to an exotic object that is not an Array is
implementation-dependent.

callbackfn should be a function that accepts three arguments. FOREACH
calls callbackfn once for each element present in the array, in
ascending order. callbackfn is called only for elements of the array
which actually exist; it is not called for missing elements of the
array.

If a thisArg parameter is provided, it will be used as the THIS value
for each invocation of callbackfn. If it is not provided, UNDEFINED is
used instead.

callbackfn is called with three arguments: the value of the element,
the index of the element, and the object being traversed.

FOREACH does not directly mutate the object on which it is called but
the object may be mutated by the calls to callbackfn.

The range of elements processed by FOREACH is set before the first call
to callbackfn. Elements which are appended to the array after the call
to FOREACH begins will not be visited by callbackfn. If existing
elements of the array are changed, their value as passed to callback
will be the value at the time FOREACH visits them; elements that are
deleted after the call to FOREACH begins and before being visited are
not visited.

When the FOREACH method is called with one or two arguments, the
following steps are taken:

1.  Let O be the result of calling ToObject passing the THIS value as
    the argument.

2.  ReturnIfAbrupt(O).

3.  Let lenValue be the result of calling the [[Get]] internal method
    of O with the argument "LENGTH".

4.  Let len be ToUint32(lenValue).

5.  ReturnIfAbrupt(len).

6.  If IsCallable(callbackfn) is FALSE, throw a TYPEERROR exception.

7.  If thisArg was supplied, let T be thisArg; else let T be
    UNDEFINED.

8.  Let k be 0.

9.  Repeat, while k < len

    a.  Let Pk be ToString(k).

    b.  Let kPresent be the result of calling the [[HasProperty]]
        internal method of O with argument Pk.

    c.  If kPresent is TRUE, then

        i.  Let kValue be the result of calling the [[Get]] internal
            method of O with argument Pk.

        ii. ReturnIfAbrupt(kValue).

        iii. Let funcResult be the result of calling the [[Call]]
            internal method of callbackfn with T as thisArgument
            and a List containing kValue, k, and O as
            argumentsList.

        iv. ReturnIfAbrupt(funcResult).

    d.  Increase k by 1.

10. Return UNDEFINED.

The LENGTH property of the FOREACH method is 1.

NOTE The FOREACH function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the FOREACH
function can be applied successfully to an exotic object that is not an
Array is implementation-dependent.

callbackfn should be a function that accepts three arguments. MAP
calls callbackfn once for each element in the array, in ascending
order, and constructs a new Array from the results. callbackfn is
called only for elements of the array which actually exist; it is not
called for missing elements of the array.

If a thisArg parameter is provided, it will be used as the THIS value
for each invocation of callbackfn. If it is not provided, UNDEFINED is
used instead.

callbackfn is called with three arguments: the value of the element,
the index of the element, and the object being traversed.

MAP does not directly mutate the object on which it is called but the
object may be mutated by the calls to callbackfn.

The range of elements processed by MAP is set before the first call to
callbackfn. Elements which are appended to the array after the call to
MAP begins will not be visited by callbackfn. If existing elements of
the array are changed, their value as passed to callbackfn will be the
value at the time MAP visits them; elements that are deleted after the
call to MAP begins and before being visited are not visited.

When the MAP method is called with one or two arguments, the following
steps are taken:

The LENGTH property of the MAP method is 1.

NOTE The MAP function is intentionally generic; it does not require that
its THIS value be an Array object. Therefore it can be transferred to
other kinds of objects for use as a method. Whether the MAP function can
be applied successfully to an exotic object that is not an Array is
implementation-dependent.

callbackfn should be a function that accepts three arguments and
returns a value that is coercible to the Boolean value TRUE or FALSE.
FILTER calls callbackfn once for each element in the array, in
ascending order, and constructs a new array of all the values for which
callbackfn returns TRUE. callbackfn is called only for elements of
the array which actually exist; it is not called for missing elements of
the array.

If a thisArg parameter is provided, it will be used as the THIS value
for each invocation of callbackfn. If it is not provided, UNDEFINED is
used instead.

callbackfn is called with three arguments: the value of the element,
the index of the element, and the object being traversed.

FILTER does not directly mutate the object on which it is called but the
object may be mutated by the calls to callbackfn.

The range of elements processed by FILTER is set before the first call
to callbackfn. Elements which are appended to the array after the call
to FILTER begins will not be visited by callbackfn. If existing
elements of the array are changed their value as passed to callbackfn
will be the value at the time FILTER visits them; elements that are
deleted after the call to FILTER begins and before being visited are not
visited.

When the FILTER method is called with one or two arguments, the
following steps are taken:

The LENGTH property of the FILTER method is 1.

NOTE The FILTER function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the FILTER
function can be applied successfully to an exotic object that is not an
Array is implementation-dependent.

callbackfn should be a function that takes four arguments. REDUCE
calls the callback, as a function, once for each element present in the
array, in ascending order.

callbackfn is called with four arguments: the previousValue (or
value from the previous call to callbackfn), the currentValue (value
of the current element), the currentIndex, and the object being
traversed. The first time that callback is called, the previousValue
and currentValue can be one of two values. If an initialValue was
provided in the call to REDUCE, then previousValue will be equal to
initialValue and currentValue will be equal to the first value in
the array. If no initialValue was provided, then previousValue will
be equal to the first value in the array and currentValue will be
equal to the second. It is a TYPEERROR if the array contains no elements
and initialValue is not provided.

REDUCE does not directly mutate the object on which it is called but the
object may be mutated by the calls to callbackfn.

The range of elements processed by REDUCE is set before the first call
to callbackfn. Elements that are appended to the array after the call
to REDUCE begins will not be visited by callbackfn. If existing
elements of the array are changed, their value as passed to callbackfn
will be the value at the time REDUCE visits them; elements that are
deleted after the call to REDUCE begins and before being visited are not
visited.

When the REDUCE method is called with one or two arguments, the
following steps are taken:

The LENGTH property of the REDUCE method is 1.

NOTE The REDUCE function is intentionally generic; it does not require
that its THIS value be an Array object. Therefore it can be transferred
to other kinds of objects for use as a method. Whether the REDUCE
function can be applied successfully to an exotic object that is not an
Array is implementation-dependent.

callbackfn should be a function that takes four arguments. REDUCERIGHT
calls the callback, as a function, once for each element present in the
array, in descending order.

callbackfn is called with four arguments: the previousValue (or
value from the previous call to callbackfn), the currentValue (value
of the current element), the currentIndex, and the object being
traversed. The first time the function is called, the previousValue
and currentValue can be one of two values. If an initialValue was
provided in the call to REDUCERIGHT, then previousValue will be equal
to initialValue and currentValue will be equal to the last value in
the array. If no initialValue was provided, then previousValue will
be equal to the last value in the array and currentValue will be equal
to the second-to-last value. It is a TYPEERROR if the array contains no
elements and initialValue is not provided.

REDUCERIGHT does not directly mutate the object on which it is called
but the object may be mutated by the calls to callbackfn.

The range of elements processed by REDUCERIGHT is set before the first
call to callbackfn. Elements that are appended to the array after the
call to REDUCERIGHT begins will not be visited by callbackfn. If
existing elements of the array are changed by callbackfn, their value
as passed to callbackfn will be the value at the time REDUCERIGHT
visits them; elements that are deleted after the call to REDUCERIGHT
begins and before being visited are not visited.

When the REDUCERIGHT method is called with one or two arguments, the
following steps are taken:

The LENGTH property of the REDUCERIGHT method is 1.

NOTE The REDUCERIGHT function is intentionally generic; it does not
require that its this value be an Array object. Therefore it can be
transferred to other kinds of objects for use as a method. Whether the
REDUCERIGHT function can be applied successfully to an exotic object
that is not an Array is implementation-dependent.

The following steps are taken:

1.  Let O be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(O).

3.  Return the result of calling the CreateArrayIterator abstract
    operation with arguments O and "KEY+VALUE".

The following steps are taken:

1.  Let O be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(O).

3.  Return the result of calling the CreateArrayIterator abstract
    operation with arguments O and "KEY".

The following steps are taken:

1.  Let O be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(O).

3.  Return the result of calling the CreateArrayIterator abstract
    operation with arguments O and "VALUE".

The initial value of the @@iterator property is the same function object
as the initial value of the ARRAY.PROTOTYPE.ITEMS property.

Array instances inherit properties from the Array prototype object and
have the [[NativeBrand]] internal property with value NativeArray. Array
instances also have the following properties.

Array objects use a variation of the [[DefineOwnProperty]] internal
method used for other native ECMAScript objects (8.12.9).

Assume A is an Array object, Desc is a Property Descriptor, and
Throw is a Boolean flag.

In the following algorithm, the term “Reject” means “If Throw is TRUE,
then throw a TYPEERROR exception, otherwise return FALSE.”

When the [[DefineOwnProperty]] internal method of A is called with
property P, Property Descriptor Desc, and Boolean flag Throw, the
following steps are taken:

The LENGTH property of this Array object is a data property whose value
is always numerically greater than the name of every deletable property
whose name is an array index.

The LENGTH property initially has the attributes { [[Writable]]: TRUE,
[[Enumerable]]: FALSE, [[Configurable]]: FALSE }.

NOTE Attempting to set the length property of an Array object to a value
that is numerically less than or equal to the largest numeric property
name of an existing array indexed non-deletable property of the array
will result in the length being set to a numeric value that is one
greater than that largest numeric property name. See 15.4.5.1.

An Array Iterator is an object, with the structure defined below, that
represent a specific iteration over some specific Array instance object.
There is not a named constructor for Array Iterator objects. Instead,
Array iterator objects are created by calling certain methods of Array
instance objects.

Several methods of Array objects return interator objects. The abstract
operation CreateArrayIterator with arguments array and kind is used
to create and such iterator objects. It performs the following steps:

1.  Let O be the result of calling ToObject(array).

2.  ReturnIfAbrupt(O).

3.  Let itr be the result of the abstract operation ObjectCreate with
    the intrinsic object %ArrayIteratorPrototype% as its argument.

4.  Add a [[IteratedObject]] internal property to itr with value O.

5.  Add a [[ArrayIteratorNextIndex]] internal property to itr with
    value 0.

6.  Add a [[ArrayIterationKind]] internal property of itr with value
    kind.

7.  Return itr.

All Array Iterator Objects inherit properties from a common Array
Iterator Prototype object. The [[Prototype]] internal property of the
Array Iterator Prototype is the %ObjectPrototype% intrinsic object. In
addition, the Array Iterator Prototype as the following properties:

1.  Let O be the THIS value.

2.  If Type(O) is not Object, throw a TYPEERROR exception.

3.  If O does not have all of the internal properties of a Array
    Iterator Instance (15.4.6.1.2), throw a TYPEERROR exception.

4.  Let a be the value of the [[IteratedObject]] internal property of
    O.

5.  Let index be the value of the [[ArrayIteratorNextIndex]] internal
    property of O.

6.  Let itemKind be the value of the [[ArrayIterationKind]] internal
    property of O.

7.  Let lenValue be the result of calling the [[Get]] internal method
    of a with the argument "LENGTH".

8.  Let len be ToUint32(lenValue).

9.  ReturnIfAbrupt(len).

10. If itemKind contains the substring "SPARSE", then

    a.  Let found be FALSE.

    b.  Repeat, while found is FALSE and index < len

        i.  Let elementKey be ToString(index).

        ii. Let found be the result of calling the [[HasProperty]]
            internal method of a with argument elementKey.

        iii. If found is FALSE, then

            1.  Increase index by 1.

11. If index ≥ len, then

    a.  Set the value of the [[ArrayIteratorNextIndex]] internal
        property of O to +Infinity.

    b.  Return Completion {[[type]]: throw, [[value]]: %StopIteration%,
        [[target]]: empty}.

12. Let elementKey be ToString(index).

13. Set the value of the [[ArrayIteratorNextIndex]] internal property of
    O to index+1.

14. If itemKind contains the substring "VALUE", then

    a.  Let elementValue be the result of calling the [[Get]] internal
        method of a with argument elementKey.

    b.  ReturnIfAbrupt(elementValue).

15. If itemKind contains the substring "KEY+VALUE", then

    a.  Let result be the result of the abstract operation ArrayCreate
        with argument 2.

    b.  Assert: result is a new, well-formed Array object so the
        following operations will never fail.

    c.  Call the [[DefineOwnProperty]] internal method of result with
        arguments "0", Property Descriptor {[[Value]]: elementKey,
        [[Writable]]: TRUE, [[Enumerable]]: TRUE, [[Configurable]]:
        TRUE}, and FALSE.

    d.  Call the [[DefineOwnProperty]] internal method of result with
        arguments "1", Property Descriptor {[[Value]]: elementValue,
        [[Writable]]: TRUE, [[Enumerable]]: TRUE, [[Configurable]]:
        TRUE}, and FALSE.

    e.  Return result.

16. Else If itemKind contains the substring "KEY" then, return
    elementKey,.

17. Else itemKind is "VALUE",

    a.  Return elementValue.

The following steps are taken:

1.  Return the THIS value.

The initial value of the @@toStringTag property is the string value
"ARRAY ITERATOR".

Array Iterator instances inherit properties from the Array Iterator
prototype (the intrinsic, %ArrayIteratorPrototype%.) Array Iterator
instances are initially created with the internal properties listed in
Table 29.

Table 29 — Internal Properties of Array Iterator Instances

  ---------------------------- --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  INTERNAL PROPERTY NAME       DESCRIPTION
  [[IteratedObject]]           The object whose array elements are being iterated.
  [[ArrayIteratorNextIndex]]   The integer index of the next array index to be examined by this iteration.
  [[ArrayIterationKind]]       A string value that identifies what is to be returned for each element of the iteration. The possible values are: "KEY", "VALUE", "KEY+VALUE", "SPARSE:KEY", "SPARSE:VALUE", "SPARSE:KEY+VALUE".
  ---------------------------- --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

When STRING is called as a function rather than as a constructor, it
performs a type conversion.

Returns a String value (not a String object) computed by
ToString(value). If value is not supplied, the empty String "" is
returned.

When STRING is called as part of a NEW expression, it is a constructor:
it initialises the newly created object.

The [[Prototype]] internal property of the newly constructed object is
set to the standard built-in String prototype object that is the initial
value of STRING.PROTOTYPE (15.5.3.1).

The newly constructed object has the [[NativeBrand]] internal property
with value StringWrapper.

The [[Extensible]] internal property of the newly constructed object is
set to TRUE.

The [[PrimitiveValue]] internal property of the newly constructed object
is set to ToString(value), or to the empty String if value is not
supplied.

The value of the [[Prototype]] internal property of the String
constructor is the standard built-in Function prototype object (15.3.4).

Besides the internal properties and the LENGTH property (whose value is
1), the String constructor has the following properties:

The initial value of STRING.PROTOTYPE is the standard built-in String
prototype object (15.5.4).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

The STRING.FROMCHARCODE function may be called with a variable number of
arguments which form the rest parameter codeUnits. The following steps
are taken:

The LENGTH property of the FROMCHARCODE function is 1.

The STRING.FROMCODEPOINT function may be called with a variable number
of arguments which form the rest parameter codePoints. The following
steps are taken:

1.  Assert: codePoints is a well-formed rest parameter object.

2.  Let length be the result of calling the [[Get]] internal method of
    codePoints with argument "LENGTH".

3.  Let elements be a new List.

4.  Let nextIndex be 0.

5.  Repeat while nextIndex < length

    a.  Let next be the result of calling the [[Get]] internal method
        of codePoints with argument ToString(nextIndex).

    b.  Let nextCP be ToNumber(next).

    c.  ReturnIfAbrupt(nextCP).

    d.  If SameValue(nextCP, ToInteger(nextCP)) is FALSE,then throw
        a RANGEERROR exception.

    e.  If nextCP < 0 or nextCP > 0x10FFFF, then throw a RANGEERROR
        exception.

    f.  Append the elements of the UTF-16 Encoding (clause 6) of
        nextCP to the end of elements.

    g.  Let nextIndex be nextIndex + 1.

6.  Return the string value whose elements are, in order, the elements
    in the List elements. If length is 0, the empty string is
    returned.

The LENGTH property of the FROMCODEPOINT function is 0.

The STRING.RAW function may be called with a variable number of
arguments. The first argument is callSite and the remainder of the
arguments form the rest parameter substitutions. The following steps
are taken:

1.  Assert: substitutions is a well-formed rest parameter object.

2.  Let cooked be ToObject(callSite).

3.  ReturnIfAbrupt(cooked).

4.  Let rawValue be the result of calling the [[Get]] internal method
    of cooked with argument "RAW".

5.  Let raw be ToObject(rawValue).

6.  ReturnIfAbrupt(raw).

7.  Let len be the result of calling the [[Get]] internal method of
    raw with argument "LENGTH".

8.  Let literalSegments be ToUint(len).

9.  ReturnIfAbrupt(literalSegments).

10. If literalSegments = 0, then return the empty string.

11. Let stringElements be a new List.

12. Let nextIndex be 0.

13. Repeat while nextIndex < literalSegments

    a.  Let nextKey be ToString(nextIndex).

    b.  Let next be the result of calling the [[Get]] internal method
        of raw with argument nextKey.

    c.  Let nextSeg be ToString(next).

    d.  ReturnIfAbrupt(nextSeg).

    e.  Append in order the code unit elements of nextSeg to the end
        of stringElements.

    f.  If nextIndex + 1 = literalSegments, then

        i.  Return the string value whose elements are, in order, the
            elements in the List stringElements. If length is 0, the
            empty string is returned.

    g.  Let next be the result of calling the [[Get]] internal method
        of substitutions with argument nextKey.

    h.  Let nextSub be ToString(next).

    i.  ReturnIfAbrupt(nextSub).

    j.  Append in order the code unit elements of nextSub to the end
        of stringElements.

    k.  Let nextIndex be nextIndex + 1.

The LENGTH property of the RAW function is 1.

NOTE String.raw is intended for use as a tag function of a Tagged
Template String (11.2.6). When called as such the first argument will be
a well formed template call site object and the rest parameter will
contain the substitution values.

The String prototype object is itself a String object whose value is an
empty String. The String prototype object has the [[NativeBrand]]
internal property with value StringWrapper.

The value of the [[Prototype]] internal property of the String prototype
object is the standard built-in Object prototype object (15.2.4).

The initial value of STRING.PROTOTYPE.CONSTRUCTOR is the built-in STRING
constructor.

Returns this String value. (Note that, for a String object, the TOSTRING
method happens to return the same thing as the VALUEOF method.)

The TOSTRING function is not generic; it throws a TYPEERROR exception if
its THIS value is not a String or a String object. Therefore, it cannot
be transferred to other kinds of objects for use as a method.

Returns this String value.

The VALUEOF function is not generic; it throws a TYPEERROR exception if
its THIS value is not a String or String object. Therefore, it cannot be
transferred to other kinds of objects for use as a method.

NOTE Returns a single element String containing the code unit at element
position pos in the String value resulting from converting this object
to a String. If there is no element at that position, the result is the
empty String. The result is a String value, not a String object.

If pos is a value of Number type that is an integer, then the result
of X.CHARAT(pos) is equal to the result of X.SUBSTRING(pos,
pos+1).

When the CHARAT method is called with one argument pos, the following
steps are taken:

1.  ReturnIfAbrupt(CheckObjectCoercible(THIS value)).

2.  Let S be the result of calling ToString, giving it the THIS value
    as its argument.

3.  ReturnIfAbrupt(S).

4.  Let position be ToInteger(pos).

5.  ReturnIfAbrupt(position).

6.  Let size be the number of elements in S.

7.  If position < 0 or position ≥ size, return the empty String.

8.  Return a String of length 1, containing one code unit from S,
    namely the code unit at position position, where the first
    (leftmost) code unit in S is considered to be at position 0, the
    next one at position 1, and so on.

NOTE The CHARAT function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

NOTE Returns a Number (a nonnegative integer less than 2^16^) that is
the code unit value of the string element at position pos in the
String resulting from converting this object to a String. If there is no
element at that position, the result is NAN.

When the CHARCODEAT method is called with one argument pos, the
following steps are taken:

NOTE The CHARCODEAT function is intentionally generic; it does not
require that its THIS value be a String object. Therefore it can be
transferred to other kinds of objects for use as a method.

NOTE When the CONCAT method is called with zero or more arguments, it
returns a String consisting of the string elements of this object
(converted to a String) followed by the string elements of each of the
arguments converted to a String. The result is a String value, not a
String object.

The following steps are taken:

The LENGTH property of the CONCAT method is 1.

NOTE The CONCAT function is intentionally generic; it does not require
that its THIS value be a String object. Therefore it can be transferred
to other kinds of objects for use as a method.

If searchString appears as a substring of the result of converting
this object to a String, at one or more positions that are greater than
or equal to position, then the index of the smallest such position is
returned; otherwise, 1 is returned. If position is UNDEFINED, 0 is
assumed, so as to search all of the String.

The INDEXOF method takes two arguments, searchString and position,
and performs the following steps:

The LENGTH property of the INDEXOF method is 1.

NOTE The INDEXOF function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

If searchString appears as a substring of the result of converting
this object to a String at one or more positions that are smaller than
or equal to position, then the index of the greatest such position is
returned; otherwise, 1 is returned. If position is UNDEFINED, the
length of the String value is assumed, so as to search all of the
String.

The LASTINDEXOF method takes two arguments, searchString and
position, and performs the following steps:

The LENGTH property of the LASTINDEXOF method is 1.

NOTE The LASTINDEXOF function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

When the LOCALECOMPARE method is called with one argument that, it
returns a Number other than NAN that represents the result of a
locale-sensitive String comparison of the this value (converted to a
String) with that (converted to a String). The two Strings are S and
That. The two Strings are compared in an implementation-defined
fashion. The result is intended to order String values in the sort order
specified by the system default locale, and will be negative, zero, or
positive, depending on whether S comes before That in the sort
order, the Strings are equal, or S comes after That in the sort
order, respectively.

Before perform the comparisons the following steps are performed to
prepare the Strings:

The LOCALECOMPARE method, if considered as a function of two arguments
THIS and that, is a consistent comparison function (as defined in
15.4.4.11) on the set of all Strings.

The actual return values are implementation-defined to permit
implementers to encode additional information in the value, but the
function is required to define a total ordering on all Strings and to
return 0 when comparing Strings that are considered canonically
equivalent by the Unicode standard.

If no language-sensitive comparison at all is available from the host
environment, this function may perform a bitwise comparison.

NOTE 1 The LOCALECOMPARE method itself is not directly suitable as an
argument to ARRAY.PROTOTYPE.SORT because the latter requires a function
of two arguments.

NOTE 2 This function is intended to rely on whatever language-sensitive
comparison functionality is available to the ECMAScript environment from
the host environment, and to compare according to the rules of the host
environment’s current locale. It is strongly recommended that this
function treat Strings that are canonically equivalent according to the
Unicode standard as identical (in other words, compare the Strings as if
they had both been converted to Normalised Form C or D first). It is
also recommended that this function not honour Unicode compatibility
equivalences or decompositions.

NOTE 3 The second parameter to this function is likely to be used in a
future version of this standard; it is recommended that implementations
do not use this parameter position for anything else.

NOTE 4 The LOCALECOMPARE function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

When the MATCH method is called with argument regexp, the following
steps are taken:

NOTE The MATCH function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

First set string according to the following steps:

1.  ReturnIfAbrupt(CheckObjectCoercible(THIS value)).

2.  Let string be the result of calling ToString, giving it the THIS
    value as its argument.

3.  ReturnIfAbrupt(string).

If searchValue is a regular expression (an object that has a
[[NativeBrand]] internal property whose value is NativeRegExp), do the
following: If searchValue.global is FALSE, then search string for
the first match of the regular expression searchValue. If
searchValue.global is TRUE, then search string for all matches of
the regular expression searchValue. Do the search in the same manner
as in STRING.PROTOTYPE.MATCH, including the update of
searchValue.LASTINDEX. Let m be the number of left capturing
parentheses in searchValue (using NcapturingParens as specified in
15.10.2.1).

If searchValue is not a regular expression, let searchString be
ToString(searchValue) and search string for the first occurrence of
searchString. Let m be 0.

If replaceValue is a function, then for each matched substring, call
the function with the following m + 3 arguments. Argument 1 is the
substring that matched. If searchValue is a regular expression, the
next m arguments are all of the captures in the MatchResult (see
15.10.2.1). Argument m + 2 is the offset within string where the
match occurred, and argument m + 3 is string. The result is a String
value derived from the original input by replacing each matched
substring with the corresponding return value of the function call,
converted to a String if need be.

Otherwise, let newstring denote the result of converting
replaceValue to a String. The result is a String value derived from
the original input String by replacing each matched substring with a
String derived from newstring by replacing elements in newstring by
replacement text as specified in Table 28. These $ replacements are done
left-to-right, and, once such a replacement is performed, the new
replacement text is not subject to further replacements. For example,
"$1,$2".REPLACE(/(\$(\D))/G, "$$1-$1$2") returns "$1-$11,$1-$22". A $ in
newstring that does not match any of the forms below is left as is.

Table 30 — Replacement Text Symbol Substitutions

  --------------------- --------------------------------- --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  Code unit             Unicode Characters                Replacement text

  0x0024, 0x0024        $$                                $

  0x0024, 0x0026        $&                                The matched substring.

  0x0024, 0x0060        $`                                The portion of string that precedes the matched substring.

  0x0024, 0x0027        $'                                The portion of string that follows the matched substring.

  0x0024, N where       $N where                          The n^th^ capture, where n is a single digit in the range 1 to 9 and $n is not followed by a decimal digit. If n_≤_m and the nth capture is UNDEFINED, use the empty String instead. If n_>_m, the result is implementation-defined.
  0x0030 ≤ N ≤ 0x0039   N is one of 0 1 2 3 4 5 6 7 8 9   

  0x0024, N, N where    $NN where                         The nn^th^ capture, where nn is a two-digit decimal number in the range 01 to 99. If nn_≤_m and the nn^th^ capture is UNDEFINED, use the empty String instead. If nn_>_m, the result is implementation-defined.
  0x0030 ≤ N ≤ 0x0039   N is one of 0 1 2 3 4 5 6 7 8 9   
  --------------------- --------------------------------- --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

NOTE The REPLACE function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

When the search method is called with argument regexp, the following
steps are taken:

NOTE The SEARCH function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

The SLICE method takes two arguments, start and end, and returns a
substring of the result of converting this object to a String, starting
from element position start and running to, but not including, element
position end (or through the end of the String if end is UNDEFINED).
If start is negative, it is treated as sourceLength_+_start where
sourceLength is the length of the String. If end is negative, it is
treated as sourceLength_+_end where sourceLength is the length of
the String. The result is a String value, not a String object. The
following steps are taken:

The LENGTH property of the SLICE method is 2.

NOTE The SLICE function is intentionally generic; it does not require
that its THIS value be a String object. Therefore it can be transferred
to other kinds of objects for use as a method.

Returns an Array object into which substrings of the result of
converting this object to a String have been stored. The substrings are
determined by searching from left to right for occurrences of
separator; these occurrences are not part of any substring in the
returned array, but serve to divide up the String value. The value of
separator may be a String of any length or it may be a RegExp object
(i.e., an object with a [[NativeBrand]] internal property whose value is
NativeRegExp ; see 15.10).

The value of separator may be an empty String, an empty regular
expression, or a regular expression that can match an empty String. In
this case, separator does not match the empty substring at the
beginning or end of the input String, nor does it match the empty
substring at the end of the previous separator match. (For example, if
separator is the empty String, the String is split up into individual
code unit elements; the length of the result array equals the length of
the String, and each substring contains one code unit.) If separator
is a regular expression, only the first match at a given position of the
THIS String is considered, even if backtracking could yield a
non-empty-substring match at that position. (For example,
"AB".SPLIT(/A*?/) evaluates to the array ["A","B"], while
"AB".SPLIT(/A*/) evaluates to the array["","B"].)

If the THIS object is (or converts to) the empty String, the result
depends on whether separator can match the empty String. If it can,
the result array contains no elements. Otherwise, the result array
contains one element, which is the empty String.

If separator is a regular expression that contains capturing
parentheses, then each time separator is matched the results
(including any UNDEFINED results) of the capturing parentheses are
spliced into the output array. For example,

  "A<B>BOLD</B>AND<CODE>CODED</CODE>".SPLIT(/<(\/)?([^<>]+)>/)

evaluates to the array

  ["A", UNDEFINED, "B", "BOLD", "/", "B", "AND", UNDEFINED,
   "CODE", "CODED", "/", "CODE", ""]

If separator is UNDEFINED, then the result array contains just one
String, which is the THIS value (converted to a String). If limit is
not UNDEFINED, then the output array is truncated so that it contains no
more than limit elements.

When the SPLIT method is called, the following steps are taken:

RUNTIME SEMANTICS: SPLITMATCH ABSTRACT OPERATION

The abstract operation SplitMatch takes three parameters, a String
S, an integer q, and a String or RegExp R, and performs the
following in order to return a MatchResult (see 15.10.2.1):

The LENGTH property of the SPLIT method is 2.

NOTE 1 The SPLIT method ignores the value of separator.GLOBAL for
separators that are RegExp objects.

NOTE 2 The SPLIT function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

The SUBSTRING method takes two arguments, start and end, and returns
a substring of the result of converting this object to a String,
starting from element position start and running to, but not
including, element position end of the String (or through the end of
the String is end is UNDEFINED). The result is a String value, not a
String object.

If either argument is NAN or negative, it is replaced with zero; if
either argument is larger than the length of the String, it is replaced
with the length of the String.

If start is larger than end, they are swapped.

The following steps are taken:

The LENGTH property of the SUBSTRING method is 2.

NOTE The SUBSTRING function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

This function interprets a string value as a sequence of code points, as
described in 8.4. The following steps are taken:

The result must be derived according to the case mappings in the Unicode
character database (this explicitly includes not only the
UnicodeData.txt file, but also the SpecialCasings.txt file that
accompanies it).

NOTE 1 The case mapping of some code points may produce multiple code
points . In this case the result String may not be the same length as
the source String. Because both TOUPPERCASE and TOLOWERCASE have
context-sensitive behaviour, the functions are not symmetrical. In other
words, S.TOUPPERCASE().TOLOWERCASE() is not necessarily equal to
S.TOLOWERCASE().

NOTE 2 The TOLOWERCASE function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

This function interprets a string value as a sequence of code points, as
described in 8.4.

This function works exactly the same as TOLOWERCASE except that its
result is intended to yield the correct result for the host
environment’s current locale, rather than a locale-independent result.
There will only be a difference in the few cases (such as Turkish) where
the rules for that language conflict with the regular Unicode case
mappings.

NOTE 1 The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that implementations
do not use this parameter position for anything else.

NOTE 2 The TOLOCALELOWERCASE function is intentionally generic; it does
not require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

This function interprets a string value as a sequence of code points, as
described in 8.4.

This function behaves in exactly the same way as
STRING.PROTOTYPE.TOLOWERCASE, except that code points are mapped to
their uppercase equivalents as specified in the Unicode Character
Database.

NOTE The TOUPPERCASE function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

This function interprets a string value as a sequence of code points, as
described in 8.4.

This function works exactly the same as TOUPPERCASE except that its
result is intended to yield the correct result for the host
environment’s current locale, rather than a locale-independent result.
There will only be a difference in the few cases (such as Turkish) where
the rules for that language conflict with the regular Unicode case
mappings.

NOTE 1 The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that implementations
do not use this parameter position for anything else.

NOTE 2 The TOLOCALEUPPERCASE function is intentionally generic; it does
not require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

This function interprets a string value as a sequence of code points, as
described in 8.4.

The following steps are taken:

NOTE The TRIM function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

15.5.4.21 STRING.PROTOTYPE.REPEAT (COUNT)

The following steps are taken:

1.  ReturnIfAbrupt(CheckObjectCoercible(THIS value)).

2.  Let S be the result of calling ToString, giving it the THIS value
    as its argument.

3.  ReturnIfAbrupt(S).

4.  Let n be the result of calling ToInteger(count).

5.  ReturnIfAbrupt(n).

6.  If n ≤ 0, then throw a RANGEERROR exception.

7.  If n is +∞, then throw a RANGEERROR exception.

8.  Let T be a String value that is made from n copies of S
    appended together.

9.  Return T.

NOTE 1 This method creates a String consisting of the string elements of
this object (converted to String) repeated count time.

NOTE 2 The REPEAT function is intentionally generic; it does not require
that its THIS value be a String object. Therefore, it can be transferred
to other kinds of objects for use as a method.

15.5.4.22 STRING.PROTOTYPE.STARTSWITH (SEARCHSTRING [, POSITION ] )

The following steps are taken:

1.  ReturnIfAbrupt(CheckObjectCoercible(THIS value)).

2.  Let S be the result of calling ToString, giving it the THIS value
    as its argument.

3.  ReturnIfAbrupt(S).

4.  Let searchStr be ToString(searchString).

5.  ReturnIfAbrupt(searchStr).

6.  Let pos be ToInteger(position). (If position is UNDEFINED,
    this step produces the value 0).

7.  ReturnIfAbrupt(pos).

8.  Let len be the number of elements in S.

9.  Let start be min(max(pos, 0), len).

10. Let searchLength be the number of elements in searchString.

11. If searchLength+start is greater than len, return FALSE.

12. If the searchLength sequence of elements of S starting at
    start is the same as the full element sequence of searchString,
    return TRUE.

13. Otherwise, return FALSE.

The LENGTH property of the STARTSWITH method is 1.

NOTE 1 This method returns TRUE if the sequence of elements of
searchString converted to a String is the same as the corresponding
elements of this object (converted to a String) starting at position.
Otherwise returns FALSE.

NOTE 2 The STARTSWITH function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

15.5.4.23 STRING.PROTOTYPE.ENDSWITH (SEARCHSTRING [, ENDPOSITION] )

The following steps are taken:

1.  ReturnIfAbrupt(CheckObjectCoercible(THIS value)).

2.  Let S be the result of calling ToString, giving it the THIS value
    as its argument.

3.  ReturnIfAbrupt(S).

4.  Let searchStr be ToString(searchString).

5.  ReturnIfAbrupt(searchStr).

6.  Let len be the number of elements in S.

7.  If endPosition is UNDEFINED, let pos be len, else let pos be
    ToInteger(endPosition).

8.  ReturnIfAbrupt(pos).

9.  Let end be min(max(pos, 0), len).

10. Let searchLength be the number of elements in searchString.

11. Let start be end - searchLength.

12. If start is less than 0, return FALSE.

13. If the searchLength sequence of elements of S starting at
    start is the same as the full element sequence of searchString,
    return TRUE.

14. Otherwise, return FALSE.

The LENGTH property of the ENDSWITH method is 1.

NOTE 1 Returns TRUE if the sequence of elements of searchString
converted to a String is the same as the corresponding elements of this
object (converted to a String) starting at endPosition – length(this).
Otherwise returns FALSE.

NOTE 2 The ENDSWITH function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

15.5.4.24 STRING.PROTOTYPE.CONTAINS (SEARCHSTRING, POSITION = 0 )

The CONTAINS method takes two arguments, searchString and position,
and performs the following steps:

1.  ReturnIfAbrupt(CheckObjectCoercible(THIS value)).

2.  Let S be the result of calling ToString, giving it the THIS value
    as its argument.

3.  ReturnIfAbrupt(S).

4.  Let searchStr be ToString(searchString).

5.  ReturnIfAbrupt(searchStr).

6.  Let pos be ToInteger(position). (If position is UNDEFINED,
    this step produces the value 0).

7.  ReturnIfAbrupt(pos).

8.  Let len be the number of elements in S.

9.  Let start be min(max(pos, 0), len).

10. Let searchLen be the number of characters in searchStr.

11. If there exists any integer k not smaller than start such that
    k + searchLen is not greater than len, and for all nonnegative
    integers j less than searchLen, the character at position
    k_+_j of S is the same as the character at position j of
    searchStr, return TRUE; but if there is no such integer k,
    return FALSE.

The LENGTH property of the CONTAINS method is 1.

NOTE 1 If searchString appears as a substring of the result of
converting this object to a String, at one or more positions that are
greater than or equal to position, then return TRUE; otherwise,
returns FALSE. If position is UNDEFINED, 0 is assumed, so as to search
all of the String.

NOTE 2 The CONTAINS function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

NOTE Returns a Number (a nonnegative integer less than 1114112) that is
the UTF-16 encoded code point value starting at the string element at
position pos in the String resulting from converting this object to a
String. If there is no element at that position, the result is NAN. If a
valid UTF-16 surrogate pair does not begin at pos, the result is the
code unit at pos.

When the CODEPOINTAT method is called with one argument pos, the
following steps are taken:

1.  ReturnIfAbrupt(CheckObjectCoercible(THIS value)).

2.  Let S be the result of calling ToString, giving it the THIS value
    as its argument.

3.  ReturnIfAbrupt(S).

4.  Let position be ToInteger(pos).

5.  ReturnIfAbrupt(position).

6.  Let size be the number of elements in S.

7.  If position < 0 or position ≥ size, return UNDEFINED.

8.  Let first be the code unit value of the element at index
    position in the String S..

9.  If first < 0xD800 or first > 0xDBFF or position+1 = size,
    then return first.

10. Let second be the code unit value of the element at index
    position+1 in the String S.

11. If second < 0xDC00 or first > 0xDFFF, then return first.

12. Return ((first – 0xD800) × 1024) + (second – 0xDC00) + 0x10000.

NOTE The CODEPOINTAT function is intentionally generic; it does not
require that its THIS value be a String object. Therefore it can be
transferred to other kinds of objects for use as a method.

1.  2.  3.  4.  5.  6.  7.  a.  b.  c.  

8.  

String instances inherit properties from the String prototype object and
have a [[NativeBrand]] internal property with value StringWrapper.
String instances also have a [[PrimitiveValue]] internal property, a
LENGTH property, and a set of enumerable properties with array index
names.

The [[PrimitiveValue]] internal property is the String value represented
by this String object. The array index named properties correspond to
the individual elements of the String value. A special
[[GetOwnProperty]] internal method is used to specify the number,
values, and attributes of the array index named properties.

The number of elements in the String value represented by this String
object.

Once a String object is created, this property is unchanging. It has the
attributes { [[Writable]]: FALSE, [[Enumerable]]: FALSE,
[[Configurable]]: FALSE }.

String objects use a variation of the [[GetOwnProperty]] internal method
used for other native ECMAScript objects (8.12.1). This special internal
method provides access to named properties corresponding to the
individual elements of String objects.

Assume S is a String object and P is a String.

When the [[GetOwnProperty]] internal method of S is called with
property name P, the following steps are taken:

When BOOLEAN is called as a function rather than as a constructor, it
performs a type conversion.

Returns a Boolean value (not a Boolean object) computed by
ToBoolean(value).

When BOOLEAN is called as part of a NEW expression it is a constructor:
it initialises the newly created object.

The [[Prototype]] internal property of the newly constructed object is
set to the original Boolean prototype object, the one that is the
initial value of BOOLEAN.PROTOTYPE (15.6.3.1).

The newly constructed Boolean object has a [[NativeBrand]] internal
property with value BooleanWrapper.

The [[PrimitiveValue]] internal property of the newly constructed
Boolean object is set to ToBoolean(value).

The [[Extensible]] internal property of the newly constructed object is
set to TRUE.

The value of the [[Prototype]] internal property of the Boolean
constructor is the Function prototype object (15.3.4).

Besides the internal properties and the LENGTH property (whose value is
1), the Boolean constructor has the following property:

The initial value of BOOLEAN.PROTOTYPE is the Boolean prototype object
(15.6.4).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

The Boolean prototype object is itself a Boolean object whose value is
FALSE. The Boolean prototype object has a [[NativeBrand]] internal
property whose value is BooleanWrapper.

The value of the [[Prototype]] internal property of the Boolean
prototype object is the standard built-in Object prototype object
(15.2.4).

The initial value of BOOLEAN.PROTOTYPE.CONSTRUCTOR is the built-in
BOOLEAN constructor.

The following steps are taken:

The following steps are taken:

Boolean instances inherit properties from the Boolean prototype object
and have a [[NativeBrand]] internal property whose value is
BooleanWrapper. Boolean instances also have a [[PrimitiveValue]]
internal property.

The [[PrimitiveValue]] internal property is the Boolean value
represented by this Boolean object.

When NUMBER is called as a function rather than as a constructor, it
performs a type conversion.

Returns a Number value (not a Number object) computed by
ToNumber(value) if value was supplied, else returns +0.

When NUMBER is called as part of a NEW expression it is a constructor:
it initialises the newly created object.

The [[Prototype]] internal property of the newly constructed object is
set to the original Number prototype object, the one that is the initial
value of NUMBER.PROTOTYPE (15.7.3.1).

The newly constructed object is has a [[NativeBrand]] internal property
whose value is NumberWrapper.

The [[PrimitiveValue]] internal property of the newly constructed object
is set to ToNumber(value) if value was supplied, else to +0.

The [[Extensible]] internal property of the newly constructed object is
set to TRUE.

The value of the [[Prototype]] internal property of the Number
constructor is the Function prototype object (15.3.4).

Besides the internal properties and the LENGTH property (whose value is
1), the Number constructor has the following properties:

The initial value of NUMBER.PROTOTYPE is the Number prototype object
(15.7.4).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

The value of NUMBER.MAX_VALUE is the largest positive finite value of
the Number type, which is approximately 1.7976931348623157 × 10^308^.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

The value of NUMBER.MIN_VALUE is the smallest positive value of the
Number type, which is approximately 5 × 10^324^.

In the IEEE-764 double precission binary representation, the smallest
possible value is a denormalized numbered. If an implementation does not
support denormalized values, the value of NUMBER.MIN_VALUE must be the
smallest non-zero positive value that can actually be represented by the
implementation.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

The value of NUMBER.NAN is NAN.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

The value of Number.NEGATIVE_INFINITY is −∞.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

The value of Number.POSITIVE_INFINITY is +∞.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

15.7.3.7 NUMBER.EPSILON

The value of Number.EPSILON is the difference between 1 and the smallest
value greater than 1 that is representable as a Number value, which is
approximately 2.2204460492503130808472633361816 x 10^-16^.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

15.7.3.8 NUMBER.MAX_INTEGER

The value of Number.MAX_INTEGER is the largest integer value that can be
represented as a Number value without losing precision, which is
9007199254740991.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

15.7.3.9 NUMBER.PARSEINT (STRING, RADIX)

Same as 15.1.2.2.

15.7.3.10 NUMBER.PARSEFLOAT (STRING)

Same as 15.1.2.3.

15.7.3.11 NUMBER.ISNAN (NUMBER)

When the NUMBER.ISNAN is called with one argument number, the
following steps are taken:

1.  If Type(number) is not Number, return FALSE.

2.  If number is NAN, return TRUE.

3.  Otherwise, return FALSE.

NOTE This function differs from the global isNaN function (15.1.2.4) is
that it does not convert its argument to a Number before determining
whether it is NaN.

15.7.3.12 NUMBER.ISFINITE (NUMBER)

When the NUMBER.ISFINITE is called with one argument number, the
following steps are taken:

15.7.3.13 NUMBER.ISINTEGER (NUMBER)

When the NUMBER.ISINTEGER is called with one argument number, the
following steps are taken:

1.  If Type(number) is not Number, return FALSE.

2.  Let integer be ToInteger(number).

3.  If integer is not equal to number, return FALSE.

4.  Otherwise, return TRUE.

15.7.3.14 NUMBER.TOINT (NUMBER)

When the NUMBER.TOINT is called with one argument number, the
following steps are taken:

1.  Return ToInteger(number).

The Number prototype object is itself a Number object with a
[[NativeBrand]] internal property whose value is NumberWrapper. Its
value is +0.

The value of the [[Prototype]] internal property of the Number prototype
object is the standard built-in Object prototype object (15.2.4).

Unless explicitly stated otherwise, the methods of the Number prototype
object defined below are not generic and the this value passed to them
must be either a Number value or an object that has a [[NativeBrand]]
internal property whose value is NumberWrapper.

In the following descriptions of functions that are properties of the
Number prototype object, the phrase “this Number object” refers to
either the object that is the THIS value for the invocation of the
function or, if Type(THIS value) is Number, an object that is created as
if by the expression NEW NUMBER(THIS value) where NUMBER is the standard
built-in constructor with that name. Also, the phrase “this Number
value” refers to either the Number value represented by this Number
object, that is, the value of the [[PrimitiveValue]] internal property
of this Number object or the THIS value if its type is Number. A
TYPEERROR exception is thrown if the THIS value is neither an object
that has a [[NativeBrand]] internal property whose value is
NumberWrapper or a value whose type is Number.

The initial value of NUMBER.PROTOTYPE.CONSTRUCTOR is the built-in NUMBER
constructor.

The optional radix should be an integer value in the inclusive range 2
to 36. If radix not present or is UNDEFINED the Number 10 is used as
the value of radix. If ToInteger(radix) is the Number 10 then this
Number value is given as an argument to the ToString abstract operation;
the resulting String value is returned.

If ToInteger(radix) is not an integer between 2 and 36 inclusive throw
a RANGEERROR exception. If ToInteger(radix) is an integer from 2 to
36, but not 10, the result is a String representation of this Number
value using the specified radix. Letters A-Z are used for digits with
values 10 through 35. The precise algorithm is implementation-dependent
if the radix is not 10, however the algorithm should be a generalisation
of that specified in 9.8.1.

The TOSTRING function is not generic; it throws a TYPEERROR exception if
its THIS value is not a Number or a Number object. Therefore, it cannot
be transferred to other kinds of objects for use as a method.

Produces a String value that represents this Number value formatted
according to the conventions of the host environment’s current locale.
This function is implementation-dependent, and it is permissible, but
not encouraged, for it to return the same thing as TOSTRING.

NOTE The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that implementations
do not use this parameter position for anything else.

The VALUEOF function is not generic; it throws a TYPEERROR exception if
its THIS value is not a Number or a Number object. Therefore, it cannot
be transferred to other kinds of objects for use as a method.

Return a String containing this Number value represented in decimal
fixed-point notation with fractionDigits digits after the decimal
point. If fractionDigits is UNDEFINED, 0 is assumed. Specifically,
perform the following steps:

The LENGTH property of the TOFIXED method is 1.

If the TOFIXED method is called with more than one argument, then the
behaviour is undefined (see clause 15).

An implementation is permitted to extend the behaviour of TOFIXED for
values of fractionDigits less than 0 or greater than 20. In this case
TOFIXED would not necessarily throw RANGEERROR for such values.

NOTE The output of TOFIXED may be more precise than TOSTRING for some
values because toString only prints enough significant digits to
distinguish the number from adjacent number values. For example,

(1000000000000000128).TOSTRING() returns "1000000000000000100",
while (1000000000000000128).TOFIXED(0) returns "1000000000000000128".

Return a String containing this Number value represented in decimal
exponential notation with one digit before the significand's decimal
point and fractionDigits digits after the significand's decimal point.
If fractionDigits is UNDEFINED, include as many significand digits as
necessary to uniquely specify the Number (just like in ToString except
that in this case the Number is always output in exponential notation).
Specifically, perform the following steps:

The LENGTH property of the TOEXPONENTIAL method is 1.

If the TOEXPONENTIAL method is called with more than one argument, then
the behaviour is undefined (see clause 15).

An implementation is permitted to extend the behaviour of TOEXPONENTIAL
for values of fractionDigits less than 0 or greater than 20. In this
case TOEXPONENTIAL would not necessarily throw RANGEERROR for such
values.

NOTE For implementations that provide more accurate conversions than
required by the rules above, it is recommended that the following
alternative version of step 9.b.i be used as a guideline:

Return a String containing this Number value represented either in
decimal exponential notation with one digit before the significand's
decimal point and precision–1 digits after the significand's decimal
point or in decimal fixed notation with precision significant digits.
If precision is UNDEFINED, call ToString (9.8.1) instead.
Specifically, perform the following steps:

The LENGTH property of the TOPRECISION method is 1.

If the TOPRECISION method is called with more than one argument, then
the behaviour is undefined (see clause 15).

An implementation is permitted to extend the behaviour of TOPRECISION
for values of precision less than 1 or greater than 21. In this case
TOPRECISION would not necessarily throw RANGEERROR for such values.

15.7.4.8 NUMBER.PROTOTYPE.CLZ ()

When the NUMBER.PROTOTYPE.CLZ is called with one argument number, the
following steps are taken:

1.  Let x be this Number value.

2.  Let n be ToUint32(x).

3.  ReturnIfAbrupt(n).

4.  Let p be the number of leading zero bits in the 32-bit binary
    representation of n.

5.  Return p.

NOTE If n is 0, p will be 32. If the most significant bit of the
32-bit binary encoding of n is 1, p will be 0.

Number instances inherit properties from the Number prototype object and
have a [[NativeBrand]] internal property whose value is NumberWrapper.
Number instances also have a [[PrimitiveValue]] internal property.

The [[PrimitiveValue]] internal property is the Number value represented
by this Number object.

The Math object is a single object that has some named properties, some
of which are functions.

The value of the [[Prototype]] internal property of the Math object is
the standard built-in Object prototype object (15.2.4). The Math object
has a [[NativeBrand]] internal property whose value is NativeMath.

The Math object does not have a [[Construct]] internal property; it is
not possible to use the Math object as a constructor with the NEW
operator.

The Math object does not have a [[Call]] internal property; it is not
possible to invoke the Math object as a function.

NOTE In this specification, the phrase “the Number value for x” has a
technical meaning defined in 8.5.

The Number value for e, the base of the natural logarithms, which is
approximately 2.7182818284590452354.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

The Number value for the natural logarithm of 10, which is approximately
2.302585092994046.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

The Number value for the natural logarithm of 2, which is approximately
0.6931471805599453.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

The Number value for the base-2 logarithm of e, the base of the
natural logarithms; this value is approximately 1.4426950408889634.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

NOTE The value of MATH.LOG2E is approximately the reciprocal of the
value of MATH.LN2.

The Number value for the base-10 logarithm of e, the base of the
natural logarithms; this value is approximately 0.4342944819032518.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

NOTE The value of MATH.LOG10E is approximately the reciprocal of the
value of MATH.LN10.

The Number value for π, the ratio of the circumference of a circle to
its diameter, which is approximately 3.1415926535897932.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

The Number value for the square root of ½, which is approximately
0.7071067811865476.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

NOTE The value of MATH.SQRT1_2 is approximately the reciprocal of the
value of MATH.SQRT2.

The Number value for the square root of 2, which is approximately
1.4142135623730951.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Each of the following MATH object functions applies the ToNumber
abstract operator to each of its arguments (in left-to-right order if
there is more than one). If ToNumber returns an abrupt completion, that
completion record is immediately returned. Otherwise, functction
performs a computation on the resulting Number value(s).

In the function descriptions below, the symbols NaN, −0, +0, −∞ and +∞
refer to the Number values described in 8.5.

NOTE The behaviour of the functions ACOS, ASIN, ATAN, ATAN2, COS, EXP,
LOG, POW, SIN, SQRT, and TAN is not precisely specified here except to
require specific results for certain argument values that represent
boundary cases of interest. For other argument values, these functions
are intended to compute approximations to the results of familiar
mathematical functions, but some latitude is allowed in the choice of
approximation algorithms. The general intent is that an implementer
should be able to use the same mathematical library for ECMAScript on a
given hardware platform that is available to C programmers on that
platform.

Although the choice of algorithms is left to the implementation, it is
recommended (but not specified by this standard) that implementations
use the approximation algorithms for IEEE 754 arithmetic contained in
FDLIBM, the freely distributable mathematical library from Sun
Microsystems (http://www.netlib.org/fdlibm).

Returns the absolute value of x; the result has the same magnitude as
x but has positive sign.

-   If x is NaN, the result is NaN.

-   If x is −0, the result is +0.

-   If x is −∞, the result is +∞.

Returns an implementation-dependent approximation to the arc cosine of
x. The result is expressed in radians and ranges from +0 to +π.

-   If x is NaN, the result is NaN.

-   If x is greater than 1, the result is NaN.

-   If x is less than −1, the result is NaN.

-   If x is exactly 1, the result is +0.

Returns an implementation-dependent approximation to the arc sine of
x. The result is expressed in radians and ranges from −π/2 to +π/2.

-   If x is NaN, the result is NaN.

-   If x is greater than 1, the result is NaN.

-   If x is less than –1, the result is NaN.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

Returns an implementation-dependent approximation to the arc tangent of
x. The result is expressed in radians and ranges from −π/2 to +π/2.

-   If x is NaN, the result is NaN.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

-   If x is +∞, the result is an implementation-dependent
      approximation to +π/2.

-   If x is −∞, the result is an implementation-dependent
      approximation to −π/2.

Returns an implementation-dependent approximation to the arc tangent of
the quotient y_/_x of the arguments y and x, where the signs of
y and x are used to determine the quadrant of the result. Note that
it is intentional and traditional for the two-argument arc tangent
function that the argument named y be first and the argument named x
be second. The result is expressed in radians and ranges from −π to +π.

-   If either x or y is NaN, the result is NaN.

-   If y>0 and x is +0, the result is an implementation-dependent
      approximation to +π/2.

-   If y>0 and x is −0, the result is an implementation-dependent
      approximation to +π/2.

-   If y is +0 and x>0, the result is +0.

-   If y is +0 and x is +0, the result is +0.

-   If y is +0 and x is −0, the result is an
      implementation-dependent approximation to +π.

-   If y is +0 and x<0, the result is an implementation-dependent
      approximation to +π.

-   If y is −0 and x>0, the result is −0.

-   If y is −0 and x is +0, the result is −0.

-   If y is −0 and x is −0, the result is an
      implementation-dependent approximation to −π.

-   If y is −0 and x<0, the result is an implementation-dependent
      approximation to −π.

-   If y<0 and x is +0, the result is an implementation-dependent
      approximation to −π/2.

-   If y<0 and x is −0, the result is an implementation-dependent
      approximation to −π/2.

-   If y>0 and y is finite and x is +∞, the result is +0.

-   If y>0 and y is finite and x is −∞, the result if an
      implementation-dependent approximation to +π.

-   If y<0 and y is finite and x is +∞, the result is −0.

-   If y<0 and y is finite and x is −∞, the result is an
      implementation-dependent approximation to −π.

-   If y is +∞ and x is finite, the result is an
      implementation-dependent approximation to +π/2.

-   If y is −∞ and x is finite, the result is an
      implementation-dependent approximation to −π/2.

-   If y is +∞ and x is +∞, the result is an
      implementation-dependent approximation to +π/4.

-   If y is +∞ and x is −∞, the result is an
      implementation-dependent approximation to +3π/4.

-   If y is −∞ and x is +∞, the result is an
      implementation-dependent approximation to −π/4.

-   If y is −∞ and x is −∞, the result is an
      implementation-dependent approximation to −3π/4.

Returns the smallest (closest to −∞) Number value that is not less than
x and is equal to a mathematical integer. If x is already an
integer, the result is x.

-   If x is NaN, the result is NaN.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

-   If x is +∞, the result is +∞.

-   If x is −∞, the result is −∞.

-   If x is less than 0 but greater than -1, the result is −0.

The value of MATH.CEIL(X) is the same as the value of -MATH.FLOOR(-X).

Returns an implementation-dependent approximation to the cosine of x.
The argument is expressed in radians.

-   If x is NaN, the result is NaN.

-   If x is +0, the result is 1.

-   If x is −0, the result is 1.

-   If x is +∞, the result is NaN.

-   If x is −∞, the result is NaN.

Returns an implementation-dependent approximation to the exponential
function of x (e raised to the power of x, where e is the base
of the natural logarithms).

-   If x is NaN, the result is NaN.

-   If x is +0, the result is 1.

-   If x is −0, the result is 1.

-   If x is +∞, the result is +∞.

-   If x is −∞, the result is +0.

Returns the greatest (closest to +∞) Number value that is not greater
than x and is equal to a mathematical integer. If x is already an
integer, the result is x.

-   If x is NaN, the result is NaN.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

-   If x is +∞, the result is +∞.

-   If x is −∞, the result is −∞.

-   If x is greater than 0 but less than 1, the result is +0.

NOTE The value of MATH.FLOOR(X) is the same as the value of
-MATH.CEIL(-X).

-   Returns an implementation-dependent approximation to the natural
      logarithm of x.

-   If x is NaN, the result is NaN.

-   If x is less than 0, the result is NaN.

-   If x is +0 or −0, the result is −∞.

-   If x is 1, the result is +0.

-   If x is +∞, the result is +∞.

Given zero or more arguments, calls ToNumber on each of the arguments
and returns the largest of the resulting values.

-   If no arguments are given, the result is −∞.

-   If any value is NaN, the result is NaN.

-   The comparison of values to determine the largest value is done
      using the Abstract Relational Comparison Algorithm ( 11.8.1)
      except that +0 is considered to be larger than −0.

The LENGTH property of the MAX method is 2.

Given zero or more arguments, calls ToNumber on each of the arguments
and returns the smallest of the resulting values.

-   If no arguments are given, the result is +∞.

-   If any value is NaN, the result is NaN.

-   The comparison of values to determine the smallest value is done
      using the Abstract Relational Comparison Algorithm (11.8.1) except
      that +0 is considered to be larger than −0.

The LENGTH property of the MIN method is 2.

Returns an implementation-dependent approximation to the result of
raising x to the power y.

-   If y is NaN, the result is NaN.

-   If y is +0, the result is 1, even if x is NaN.

-   If y is −0, the result is 1, even if x is NaN.

-   If x is NaN and y is nonzero, the result is NaN.

-   If abs(x)>1 and y is +∞, the result is +∞.

-   If abs(x)>1 and y is −∞, the result is +0.

-   If abs(x) is 1 and y is +∞, the result is NaN.

-   If abs(x) is 1 and y is −∞, the result is NaN.

-   If abs(x)<1 and y is +∞, the result is +0.

-   If abs(x)<1 and y is −∞, the result is +∞.

-   If x is +∞ and y>0, the result is +∞.

-   If x is +∞ and y<0, the result is +0.

-   If x is −∞ and y>0 and y is an odd integer, the result is −∞.

-   If x is −∞ and y>0 and y is not an odd integer, the result
      is +∞.

-   If x is −∞ and y<0 and y is an odd integer, the result is −0.

-   If x is −∞ and y<0 and y is not an odd integer, the result
      is +0.

-   If x is +0 and y>0, the result is +0.

-   If x is +0 and y<0, the result is +∞.

-   If x is −0 and y>0 and y is an odd integer, the result is −0.

-   If x is −0 and y>0 and y is not an odd integer, the result
      is +0.

-   If x is −0 and y<0 and y is an odd integer, the result is −∞.

-   If x is −0 and y<0 and y is not an odd integer, the result
      is +∞.

-   If x<0 and x is finite and y is finite and y is not an
      integer, the result is NaN.

Returns a Number value with positive sign, greater than or equal to 0
but less than 1, chosen randomly or pseudo randomly with approximately
uniform distribution over that range, using an implementation-dependent
algorithm or strategy. This function takes no arguments.

Returns the Number value that is closest to x and is equal to a
mathematical integer. If two integer Number values are equally close to
x, then the result is the Number value that is closer to +∞. If x is
already an integer, the result is x.

-   If x is NaN, the result is NaN.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

-   If x is +∞, the result is +∞.

-   If x is −∞, the result is −∞.

-   If x is greater than 0 but less than 0.5, the result is +0.

-   If x is less than 0 but greater than or equal to -0.5, the result
      is −0.

NOTE 1 MATH.ROUND(3.5) returns 4, but MATH.ROUND(–3.5) returns –3.

NOTE 2 The value of MATH.ROUND(X) is the same as the value of
MATH.FLOOR(X+0.5), except when X is −0 or is less than 0 but greater
than or equal to -0.5; for these cases MATH.ROUND(X) returns −0, but
MATH.FLOOR(X+0.5) returns +0.

Returns an implementation-dependent approximation to the sine of x.
The argument is expressed in radians.

-   If x is NaN, the result is NaN.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

-   If x is +∞ or −∞, the result is NaN.

Returns an implementation-dependent approximation to the square root of
x.

-   If x is NaN, the result is NaN.

-   If x is less than 0, the result is NaN.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

-   If x is +∞, the result is +∞.

Returns an implementation-dependent approximation to the tangent of x.
The argument is expressed in radians.

-   If x is NaN, the result is NaN.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

-   If x is +∞ or −∞, the result is NaN.

Returns an implementation-dependent approximation to the base 10
logarithm of x.

-   If x is NaN, the result is NaN.

-   If x is less than 0, the result is NaN.

-   If x is +0, the result is −∞.

-   If x is −0, the result is −∞.

-   If x is 1, the result is +0.

-   If x is +∞, the result is +∞.

Returns an implementation-dependent approximation to the base 2
logarithm of x.

-   If x is NaN, the result is NaN.

-   If x is less than 0, the result is NaN.

-   If x is +0, the result is −∞.

-   If x is −0, the result is −∞.

-   If x is 1, the result is +0.

-   If x is +∞, the result is +∞.

Returns an implementation-dependent approximation to the natural
logarithm of 1 + x. The result is computed in a way that is accurate
even when the value of x is close to zero.

-   If x is NaN, the result is NaN.

-   If x is less than -1, the result is NaN.

-   If x is -1, the result is -∞.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

-   If x is +∞, the result is +∞.

Returns an implementation-dependent approximation to subtracting 1 from
the exponential function of x (e raised to the power of x, where
e is the base of the natural logarithms). The result is computed in a
way that is accurate even when the value of x is close 0.

-   If x is NaN, the result is NaN.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

-   If x is +∞, the result is +∞.

-   If x is −∞, the result is -1.

Returns an implementation-dependent approximation to the hyperbolic
cosine of x.

-   If x is NaN, the result is NaN.

-   If x is +0, the result is 1.

-   If x is −0, the result is 1.

-   If x is +∞, the result is +∞.

-   If x is −∞, the result is +∞.

NOTE The value of cosh(x) is the same as _(exp(x) + exp(-x))/2_.

Returns an implementation-dependent approximation to the hyperbolic sine
of x.

-   If x is NaN, the result is NaN.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

-   If x is +∞, the result is +∞.

-   If x is −∞, the result is −∞.

NOTE The value of cosh(x) is the same as _(exp(x) - exp(-x))/2_.

Returns an implementation-dependent approximation to the hyperbolic
tangent of x.

-   If x is NaN, the result is NaN.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

-   If x is +∞, the result is +1.

-   If x is −∞, the result is -1.

NOTE The value of tanh(x) is the same as _(exp(x) - exp(-x))/(exp(x) +
exp(-x))_.

Returns an implementation-dependent approximation to the inverse
hyperbolic cosine of x.

-   If x is NaN, the result is NaN.

-   If x is less than 1, the result is NaN.

-   If x is 1, the result is +0.

-   If x is +∞, the result is +∞.

Returns an implementation-dependent approximation to the inverse
hyperbolic sine of x.

-   If x is NaN, the result is NaN.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

-   If x is +∞, the result is +∞.

-   If x is −∞, the result is −∞.

Returns an implementation-dependent approximation to the inverse
hyperbolic tangent of x.

-   If x is NaN, the result is NaN.

-   If x is less than −1, the result is NaN.

-   If x is greater than 1, the result is NaN.

-   If x is −1, the result is −∞.

-   If x is +1, the result is +∞.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

Given two or three arguments, hypot returns an implementation-dependent
approximation of the square root of the sum of squares of up to three
arguments.

-   If any argument is +∞, the result is +∞.

-   If any argument is −∞, the result is +∞.

-   If no argument is +∞ or −∞, and any argument is NaN, the result is
      NaN.

-   If all arguments are either +0 or -0, the result is +0.

~~Given two or three arguments, hypot2 returns an
implementation-dependent approximation of the sum of squares of its
arguments. ~~

-   ~~If no arguments are given, the result is +0.~~

-   ~~If any argument is +∞, the result is +∞.~~

-   ~~If any argument is −∞, the result is +∞.~~

-   ~~If no argument is +∞ or −∞, and any argument is NaN, the result is
      NaN.~~

-   ~~If all arguments are either +0 or -0, the result is +0.~~

Returns the integral part of the number x, removing any fractional
digits. If x is already an integer, the result is x.

-   If x is NaN, the result is NaN.

-   If x is −0, the result is −0.

-   If x is +0, the result is +0.

-   If x is +∞, the result is +∞.

-   If x is −∞, the result is −∞.

Returns the sign of the x, indicating whether x is positive, negative or
zero.

-   If x is NaN, the result is NaN.

-   If x is −0, the result is −0.

-   If x is +0, the result is +0.

-   If x is negative and not −0, the result is −1.

-   If x is positive and not +0, the result is +1.

Returns an implementation-dependent approximation to the cube root of
x.

-   If x is NaN, the result is NaN.

-   If x is +0, the result is +0.

-   If x is −0, the result is −0.

-   If x is +∞, the result is +∞.

-   If x is −∞, the result is −∞.

The following functions are abstract operations that operate on time
values (defined in 15.9.1.1). Note that, in every case, if any argument
to one of these functions is NAN, the result will be NAN.

A Date object contains a Number indicating a particular instant in time
to within a millisecond. Such a Number is called a _time value_. A time
value may also be NAN, indicating that the Date object does not
represent a specific instant of time.

Time is measured in ECMAScript in milliseconds since 01 January, 1970
UTC. In time values leap seconds are ignored. It is assumed that there
are exactly 86,400,000 milliseconds per day. ECMAScript Number values
can represent all integers from –9,007,199,254,740,992 to
9,007,199,254,740,992; this range suffices to measure times to
millisecond precision for any instant that is within approximately
285,616 years, either forward or backward, from 01 January, 1970 UTC.

The actual range of times supported by ECMAScript Date objects is
slightly smaller: exactly –100,000,000 days to 100,000,000 days measured
relative to midnight at the beginning of 01 January, 1970 UTC. This
gives a range of 8,640,000,000,000,000 milliseconds to either side of 01
January, 1970 UTC.

The exact moment of midnight at the beginning of 01 January, 1970 UTC is
represented by the value +0.

A given time value t belongs to day number

  Day(t) = floor(t / msPerDay)

where the number of milliseconds per day is

  msPerDay = 86400000

The remainder is called the time within the day:

  TimeWithinDay(t) = t modulo msPerDay

ECMAScript uses an extrapolated Gregorian system to map a day number to
a year number and to determine the month and date within that year. In
this system, leap years are precisely those which are (divisible by 4)
and ((not divisible by 100) or (divisible by 400)). The number of days
in year number y is therefore defined by

  DaysInYear(y) = 365 if (y modulo 4) ≠ 0
  = 366 if (y modulo 4) = 0 and (y modulo 100) ≠ 0
  = 365 if (y modulo 100) = 0 and (y modulo 400) ≠ 0
  = 366 if (y modulo 400) = 0

All non-leap years have 365 days with the usual number of days per month
and leap years have an extra day in February. The day number of the
first day of year y is given by:

  DayFromYear(y) = 365 × (y−1970) + floor((y−1969)/4) −
  floor((y−1901)/100) + floor((y−1601)/400)

The time value of the start of a year is:

  TimeFromYear(y) = msPerDay × DayFromYear(y)

A time value determines a year by:

  YearFromTime(t) = the largest integer y (closest to positive
  infinity) such that TimeFromYear(y) ≤ t

The leap-year function is 1 for a time within a leap year and otherwise
is zero:

  InLeapYear(t) = 0 if DaysInYear(YearFromTime(t)) = 365
  = 1 if DaysInYear(YearFromTime(t)) = 366

Months are identified by an integer in the range 0 to 11, inclusive. The
mapping MonthFromTime(t) from a time value t to a month number is
defined by:

  MonthFromTime(t) = 0 if 0 ≤ DayWithinYear(t) < 31
   = 1 if 31 ≤ DayWithinYear (t) < 59+InLeapYear(t)
   = 2 if 59+InLeapYear(t) ≤ DayWithinYear (t) < 90+InLeapYear(t)
   = 3 if 90+InLeapYear(t) ≤ DayWithinYear (t) < 120+InLeapYear(t)
   = 4 if 120+InLeapYear(t) ≤ DayWithinYear (t) <
  151+InLeapYear(t)
   = 5 if 151+InLeapYear(t) ≤ DayWithinYear (t) <
  181+InLeapYear(t)
   = 6 if 181+InLeapYear(t) ≤ DayWithinYear (t) <
  212+InLeapYear(t)
   = 7 if 212+InLeapYear(t) ≤ DayWithinYear (t) <
  243+InLeapYear(t)
   = 8 if 243+InLeapYear(t) ≤ DayWithinYear (t) <
  273+InLeapYear(t)
   = 9 if 273+InLeapYear(t) ≤ DayWithinYear (t) <
  304+InLeapYear(t)
   = 10 if 304+InLeapYear(t) ≤ DayWithinYear (t) <
  334+InLeapYear(t)
   = 11 if 334+InLeapYear(t) ≤ DayWithinYear (t) <
  365+InLeapYear(t)

where

  DayWithinYear(t) = Day(t_)−DayFromYear(YearFromTime(_t))

A month value of 0 specifies January; 1 specifies February; 2 specifies
March; 3 specifies April; 4 specifies May; 5 specifies June; 6 specifies
July; 7 specifies August; 8 specifies September; 9 specifies October; 10
specifies November; and 11 specifies December. Note that
MonthFromTime(0) = 0, corresponding to Thursday, 01 January, 1970.

A date number is identified by an integer in the range 1 through 31,
inclusive. The mapping DateFromTime(t) from a time value t to a
month number is defined by:

  DateFromTime(t) = DayWithinYear(t)+1 if MonthFromTime(t)=0
   = DayWithinYear(t)−30 if MonthFromTime(t)=1
   = DayWithinYear(t_)−58−InLeapYear(_t) if MonthFromTime(t)=2
   = DayWithinYear(t_)−89−InLeapYear(_t) if MonthFromTime(t)=3
   = DayWithinYear(t_)−119−InLeapYear(_t) if MonthFromTime(t)=4
   = DayWithinYear(t_)−150−InLeapYear(_t) if MonthFromTime(t)=5
   = DayWithinYear(t_)−180−InLeapYear(_t) if MonthFromTime(t)=6
   = DayWithinYear(t_)−211−InLeapYear(_t) if MonthFromTime(t)=7
   = DayWithinYear(t_)−242−InLeapYear(_t) if MonthFromTime(t)=8
   = DayWithinYear(t_)−272−InLeapYear(_t) if MonthFromTime(t)=9
   = DayWithinYear(t_)−303−InLeapYear(_t) if MonthFromTime(t)=10
   = DayWithinYear(t_)−333−InLeapYear(_t) if MonthFromTime(t)=11

The weekday for a particular time value t is defined as

  WeekDay(t) = (Day(t) + 4) modulo 7

A weekday value of 0 specifies Sunday; 1 specifies Monday; 2 specifies
Tuesday; 3 specifies Wednesday; 4 specifies Thursday; 5 specifies
Friday; and 6 specifies Saturday. Note that WeekDay(0) = 4,
corresponding to Thursday, 01 January, 1970.

An implementation of ECMAScript is expected to determine the local time
zone adjustment. The local time zone adjustment is a value LocalTZA
measured in milliseconds which when added to UTC represents the local
standard time. Daylight saving time is not reflected by LocalTZA.

NOTE It is recommended that implementations use the time zone
information of the IANA Time Zone Database.

An implementation of ECMAScript is expected to make its best effort to
determine the local daylight saving time adjustment. An implementation
dependent algorithm using best available information on time zones to
determine the local daylight saving time adjustment
DaylightSavingTA(t), measured in milliseconds.

Conversion from UTC to local time is defined by

  LocalTime(t) = t + LocalTZA + DaylightSavingTA(t)

Conversion from local time to UTC is defined by

  UTC(t) = t – LocalTZA – DaylightSavingTA(t – LocalTZA)

Note that UTC(LocalTime(t)) is not necessarily always equal to t.

The following functions are useful in decomposing time values:

  HourFromTime(t) = floor(t / msPerHour) modulo HoursPerDay

  MinFromTime(t) = floor(t / msPerMinute) modulo MinutesPerHour

  SecFromTime(t) = floor(t / msPerSecond) modulo SecondsPerMinute

  msFromTime(t) = t modulo msPerSecond

where

  HoursPerDay = 24

  MinutesPerHour = 60

  SecondsPerMinute = 60

  msPerSecond = 1000

  msPerMinute = 60000 = msPerSecond × SecondsPerMinute

  msPerHour = 3600000 = msPerMinute × MinutesPerHour

The operator MakeTime calculates a number of milliseconds from its four
arguments, which must be ECMAScript Number values. This operator
functions as follows:

The operator MakeDay calculates a number of days from its three
arguments, which must be ECMAScript Number values. This operator
functions as follows:

The operator MakeDate calculates a number of milliseconds from its two
arguments, which must be ECMAScript Number values. This operator
functions as follows:

The operator TimeClip calculates a number of milliseconds from its
argument, which must be an ECMAScript Number value. This operator
functions as follows:

NOTE The point of step 3 is that an implementation is permitted a choice
of internal representations of time values, for example as a 64-bit
signed integer or as a 64-bit floating-point value. Depending on the
implementation, this internal representation may or may not distinguish
−0 and +0.

ECMAScript defines a string interchange format for date-times based upon
a simplification of the ISO 8601 Extended Format. The format is as
follows: YYYY-MM-DDTHH:MM:SS.SSSZ

Where the fields are as follows:

This format includes date-only forms:

YYYY
YYYY-MM
YYYY-MM-DD

It also includes “date-time” forms that consist of one of the above
date-only forms immediately followed by one of the following time forms
with an optional time zone offset appended:

THH:MM
THH:MM:SS
THH:MM:SS.SSS

All numbers must be base 10. If the MM or DD fields are absent “01” is
used as the value. If the HH, MM, or SS fields are absent “00” is used
as the value and the value of an absent SSS field is “000”. If the time
zone offset is absent, the date-time is interpreted as a local time.

Illegal values (out-of-bounds as well as syntax errors) in a format
string means that the format string is not a valid instance of this
format.

NOTE 1 As every day both starts and ends with midnight, the two
notations 00:00 and 24:00 are available to distinguish the two midnights
that can be associated with one date. This means that the following two
notations refer to exactly the same point in time: 1995-02-04T24:00 and
1995-02-05T00:00

NOTE 2 There exists no international standard that specifies
abbreviations for civil time zones like CET, EST, etc. and sometimes the
same abbreviation is even used for two very different time zones. For
this reason, ISO 8601 and this format specifies numeric representations
of date and time.

ECMAScript requires the ability to specify 6 digit years (extended
years); approximately 285,426 years, either forward or backward, from 01
January, 1970 UTC. To represent years before 0 or after 9999, ISO 8601
permits the expansion of the year representation, but only by prior
agreement between the sender and the receiver. In the simplified
ECMAScript format such an expanded year representation shall have 2
extra year digits and is always prefixed with a + or – sign. The year 0
is considered positive and hence prefixed with a + sign.

NOTE Examples of extended years:

  -283457-03-21T15:00:59.008Z   283458 B.C.
  -000001-01-01T00:00:00Z          2 B.C.
  +000000-01-01T00:00:00Z         1 B.C.
  +000001-01-01T00:00:00Z         1 A.D.
  +001970-01-01T00:00:00Z         1970 A.D.
  +002009-12-15T00:00:00Z         2009 A.D.
  +287396-10-12T08:59:00.992Z 287396 A.D.

When DATE is called as a function rather than as a constructor, it
returns a String representing the current time (UTC).

NOTE The function call DATE(…) is not equivalent to the object creation
expression NEW DATE(…) with the same arguments.

All of the arguments are optional; any arguments supplied are accepted
but are completely ignored. A String is created and returned as if by
the expression (NEW DATE()).TOSTRING() where DATE is the standard
built-in constructor with that name and TOSTRING is the standard
built-in method DATE.PROTOTYPE.TOSTRING.

When DATE is called as part of a NEW expression, it is a constructor: it
initialises the newly created object.

When DATE is called with two to seven arguments, it computes the date
from year, month, and (optionally) date, hours, minutes,
seconds and ms.

The [[Prototype]] internal property of the newly constructed object is
set to the original Date prototype object, the one that is the initial
value of DATE.PROTOTYPE (15.9.4.1).

The newly constructed object has a [[NativeBrand]] internal property
whose value is NativeDate.

The [[Extensible]] internal property of the newly constructed object is
set to TRUE.

The [[PrimitiveValue]] internal property of the newly constructed object
is set as follows:

The [[Prototype]] internal property of the newly constructed object is
set to the original Date prototype object, the one that is the initial
value of DATE.PROTOTYPE (15.9.4.1).

The newly constructed object has a [[NativeBrand]] internal property
whose value is NativeDate.

The [[Extensible]] internal property of the newly constructed object is
set to TRUE.

The [[PrimitiveValue]] internal property of the newly constructed object
is set as follows:

The [[Prototype]] internal property of the newly constructed object is
set to the original Date prototype object, the one that is the initial
value of DATE.PROTOTYPE (15.9.4.1).

The newly constructed object has a [[NativeBrand]] internal property
whose value is NativeDate.

The [[Extensible]] internal property of the newly constructed object is
set to TRUE.

The [[PrimitiveValue]] internal property of the newly constructed object
is set to the time value (UTC) identifying the current time.

The value of the [[Prototype]] internal property of the Date constructor
is the Function prototype object (15.3.4).

Besides the internal properties and the LENGTH property (whose value is
7), the Date constructor has the following properties:

The initial value of DATE.PROTOTYPE is the built-in Date prototype
object (15.9.5).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

The PARSE function applies the ToString operator to its argument. If
ToString results in an abrupt completion the Completion Record is
immediately returned. Otherwise, PARSE interprets the resulting String
as a date and time; it returns a Number, the UTC time value
corresponding to the date and time. The String may be interpreted as a
local time, a UTC time, or a time in some other time zone, depending on
the contents of the String. The function first attempts to parse the
format of the String according to the rules called out in Date Time
String Format (15.9.1.15). If the String does not conform to that format
the function may fall back to any implementation-specific heuristics or
implementation-specific date formats. Unrecognisable Strings or dates
containing illegal element values in the format String shall cause
DATE.PARSE to return NAN.

If x is any Date object whose milliseconds amount is zero within a
particular implementation of ECMAScript, then all of the following
expressions should produce the same numeric value in that
implementation, if all the properties referenced have their initial
values:

  X.VALUEOF()

  DATE.PARSE(X.TOSTRING())

  DATE.PARSE(X.TOUTCSTRING())

  DATE.PARSE(X.TOISOSTRING())

However, the expression

  DATE.PARSE(x.TOLOCALESTRING())

is not required to produce the same Number value as the preceding three
expressions and, in general, the value produced by DATE.PARSE is
implementation-dependent when given any String value that does not
conform to the Date Time String Format (15.9.1.15) and that could not be
produced in that implementation by the TOSTRING or TOUTCSTRING method.

When the UTC function is called with fewer than two arguments, the
behaviour is implementation-dependent. When the UTC function is called
with two to seven arguments, it computes the date from year, month
and (optionally) date, hours, minutes, seconds and ms. The
following steps are taken:

The LENGTH property of the UTC function is 7.

NOTE The UTC function differs from the Date constructor in two ways: it
returns a time value as a Number, rather than creating a Date object,
and it interprets the arguments in UTC rather than as local time.

The NOW function return a Number value that is the time value
designating the UTC date and time of the occurrence of the call to NOW.

The Date prototype object is itself a Date object and has a
[[NativeBrand]] internal property whose value is NativeDate. Its
[[PrimitiveValue]] is NAN.

The value of the [[Prototype]] internal property of the Date prototype
object is the standard built-in Object prototype object (15.2.4).

In following descriptions of functions that are properties of the Date
prototype object, the phrase “this Date object” refers to the object
that is the THIS value for the invocation of the function. Unless
explicitly noted otherwise, none of these functions are generic; a
TYPEERROR exception is thrown if the THIS value is not an object with a
[[NativeBrand]] internal property whose value is NativeDate. Also, the
phrase “this time value” refers to the Number value for the time
represented by this Date object, that is, the value of the
[[PrimitiveValue]] internal property of this Date object.

The initial value of DATE.PROTOTYPE.CONSTRUCTOR is the built-in DATE
constructor.

This function returns a String value. If this time value is NaN, the
String value is "INVALID DATE", otherwise the contents of the String are
implementation-dependent, but are intended to represent the Date in the
current time zone in a convenient, human-readable form.

NOTE For any Date value d whose milliseconds amount is zero, the
result of Date.parse(d.toString()) is equal to d.valueOf(). See
15.9.4.2.

This function returns a String value. The contents of the String are
implementation-dependent, but are intended to represent the “date”
portion of the Date in the current time zone in a convenient,
human-readable form.

This function returns a String value. The contents of the String are
implementation-dependent, but are intended to represent the “time”
portion of the Date in the current time zone in a convenient,
human-readable form.

This function returns a String value. The contents of the String are
implementation-dependent, but are intended to represent the Date in the
current time zone in a convenient, human-readable form that corresponds
to the conventions of the host environment’s current locale.

NOTE The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that implementations
do not use this parameter position for anything else.

This function returns a String value. The contents of the String are
implementation-dependent, but are intended to represent the “date”
portion of the Date in the current time zone in a convenient,
human-readable form that corresponds to the conventions of the host
environment’s current locale.

NOTE The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that implementations
do not use this parameter position for anything else.

This function returns a String value. The contents of the String are
implementation-dependent, but are intended to represent the “time”
portion of the Date in the current time zone in a convenient,
human-readable form that corresponds to the conventions of the host
environment’s current locale.

NOTE The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that implementations
do not use this parameter position for anything else.

The VALUEOF function returns a Number, which is this time value.

1.  Let t be this time value.

2.  ReturnIfAbrupt(t).

3.  If t is NAN, return NAN.

4.  Return MinFromTime(LocalTime(t)).

1.  Let t be this time value.

2.  ReturnIfAbrupt(t).

3.  If t is NAN, return NAN.

4.  Return msFromTime(t).

Returns the difference between local time and UTC time in minutes.

If ms is not specified, this behaves as if ms were specified with
the value GETMILLISECONDS().

The LENGTH property of the SETSECONDS method is 2.

If ms is not specified, this behaves as if ms were specified with
the value GETUTCMILLISECONDS().

The LENGTH property of the SETUTCSECONDS method is 2.

If sec is not specified, this behaves as if sec were specified with
the value GETSECONDS().

If ms is not specified, this behaves as if ms were specified with
the value GETMILLISECONDS().

The LENGTH property of the SETMINUTES method is 3.

If sec is not specified, this behaves as if sec were specified with
the value GETUTCSECONDS().

If ms is not specified, this function behaves as if ms were
specified with the value return by GETUTCMILLISECONDS().

The LENGTH property of the SETUTCMINUTES method is 3.

If min is not specified, this behaves as if min were specified with
the value GETMINUTES().

If sec is not specified, this behaves as if sec were specified with
the value GETSECONDS().

If ms is not specified, this behaves as if ms were specified with
the value GETMILLISECONDS().

The LENGTH property of the SETHOURS method is 4.

If min is not specified, this behaves as if min were specified with
the value GETUTCMINUTES().

If sec is not specified, this behaves as if sec were specified with
the value GETUTCSECONDS().

If ms is not specified, this behaves as if ms were specified with
the value GETUTCMILLISECONDS().

The LENGTH property of the SETUTCHOURS method is 4.

If date is not specified, this behaves as if date were specified
with the value GETDATE().

The LENGTH property of the SETMONTH method is 2.

If date is not specified, this behaves as if date were specified
with the value GETUTCDATE().

The LENGTH property of the SETUTCMONTH method is 2.

If month is not specified, this behaves as if month were specified
with the value GETMONTH().

If date is not specified, this behaves as if date were specified
with the value GETDATE().

The LENGTH property of the SETFULLYEAR method is 3.

If month is not specified, this behaves as if month were specified
with the value GETUTCMONTH().

If date is not specified, this behaves as if date were specified
with the value GETUTCDATE().

The LENGTH property of the SETUTCFULLYEAR method is 3.

This function returns a String value. The contents of the String are
implementation-dependent, but are intended to represent the Date in a
convenient, human-readable form in UTC.

NOTE The intent is to produce a String representation of a date that is
more readable than the format specified in 15.9.1.15. It is not
essential that the chosen format be unambiguous or easily machine
parsable. If an implementation does not have a preferred human-readable
format it is recommended to use the format defined in 15.9.1.15 but with
a space rather than a “T” used to separate the date and time elements.

This function returns a String value represent the instance in time
represented by this Date object. The format of the String is the Date
Time string format defined in 15.9.1.15. All fields are present in the
String. The time zone is always UTC, denoted by the suffix Z. If the
time value of this object is not a finite Number a RANGEERROR exception
is thrown.

This function provides a String representation of a Date object for use
by JSON.STRINGIFY (15.12.3).

When the TOJSON method is called with argument key, the following
steps are taken:

NOTE 1 The argument is ignored.

NOTE 2 The TOJSON function is intentionally generic; it does not require
that its THIS value be a Date object. Therefore, it can be transferred
to other kinds of objects for use as a method. However, it does require
that any such object have a TOISOSTRING method. An object is free to use
the argument key to filter its stringification.

Date instances inherit properties from the Date prototype object and
have a [[NativeBrand]] internal whose value is NativeDate. Date
instances also have a [[PrimitiveValue]] internal property.

The [[PrimitiveValue]] internal property is time value represented by
this Date object.

A RegExp object contains a regular expression and the associated flags.

NOTE The form and functionality of regular expressions is modelled after
the regular expression facility in the Perl 5 programming language.

The REGEXP constructor applies the following grammar to the input
pattern String. An error occurs if the grammar cannot interpret the
String as an expansion of Pattern.

Syntax

Pattern ::

Disjunction

Disjunction ::

Alternative
 Alternative | Disjunction

Alternative ::

[empty]
Alternative Term

Term ::

Assertion
Atom
Atom Quantifier

Assertion ::

^
$
\ B
\ B
( ? = Disjunction )
( ? ! Disjunction )

Quantifier ::

QuantifierPrefix
QuantifierPrefix ?

QuantifierPrefix ::

*
+
?
{ DecimalDigits }
{ DecimalDigits , }
{ DecimalDigits , DecimalDigits }

Atom ::

PatternCharacter
.
\ AtomEscape
CharacterClass
( Disjunction )
( ? : Disjunction )

PatternCharacter ::

SourceCharacter BUT NOT ONE OF
 ^ $ \ . * + ? ( ) [ ] { } |

AtomEscape ::

DecimalEscape
CharacterEscape
CharacterClassEscape

CharacterEscape ::

ControlEscape
C ControlLetter
HexEscapeSequence
UnicodeEscapeSequence
IdentityEscape

ControlEscape :: ONE OF

F N R T V

ControlLetter :: ONE OF

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

IdentityEscape ::

SourceCharacter BUT NOT IdentifierPart
<ZWJ>
<ZWNJ>

DecimalEscape ::

DecimalIntegerLiteral [lookahead ∉ DecimalDigit]

CharacterClassEscape :: ONE OF

D D S S W W

CharacterClass ::

[ [lookahead ∉ {^}] ClassRanges ]
[ ^ ClassRanges ]

ClassRanges ::

[empty]
NonemptyClassRanges

NonemptyClassRanges ::

ClassAtom
ClassAtom NonemptyClassRangesNoDash
ClassAtom - ClassAtom ClassRanges

NonemptyClassRangesNoDash ::

ClassAtom
ClassAtomNoDash NonemptyClassRangesNoDash
ClassAtomNoDash - ClassAtom ClassRanges

ClassAtom ::

-
ClassAtomNoDash

ClassAtomNoDash ::

SourceCharacter BUT NOT ONE OF \ OR ] OR -
\ ClassEscape

ClassEscape ::

DecimalEscape
B
CharacterEscape
CharacterClassEscape

A regular expression pattern is converted into an internal procedure
using the process described below. An implementation is encouraged to
use more efficient algorithms than the ones listed below, as long as the
results are the same. The internal procedure is used as the value of a
RegExp object’s [[Match]] internal property.

The descriptions below use the following variables:

-   Input is the String being matched by the regular expression
      pattern. The notation input_[_n] means the n^th^ character of
      input, where n can range between 0 (inclusive) and
      InputLength (exclusive).

-   InputLength is the number of characters in the Input String.

-   NcapturingParens is the total number of left capturing parentheses
      (i.e. the total number of times the Atom :: ( Disjunction )
      production is expanded) in the pattern. A left capturing
      parenthesis is any ( pattern character that is matched by the (
      terminal of the Atom :: ( Disjunction ) production.

-   IgnoreCase is the setting of the RegExp object's IGNORECASE
      property.

-   Multiline is the setting of the RegExp object’s MULTILINE
      property.

Furthermore, the descriptions below use the following internal data
structures:

-   A CharSet is a mathematical set of characters.

-   A State is an ordered pair (endIndex, captures) where
      endIndex is an integer and captures is an internal array of
      NcapturingParens values. States are used to represent partial
      match states in the regular expression matching algorithms. The
      endIndex is one plus the index of the last input character
      matched so far by the pattern, while captures holds the results
      of capturing parentheses. The n^th^ element of captures is
      either a String that represents the value obtained by the n^th^
      set of capturing parentheses or UNDEFINED if the n^th^ set of
      capturing parentheses hasn’t been reached yet. Due to
      backtracking, many States may be in use at any time during the
      matching process.

-   A MatchResult is either a State or the special token FAILURE
      that indicates that the match failed.

-   A Continuation procedure is an internal closure (i.e. an internal
      procedure with some arguments already bound to values) that takes
      one State argument and returns a MatchResult result. If an
      internal closure references variables bound in the function that
      creates the closure, the closure uses the values that these
      variables had at the time the closure was created. The
      Continuation attempts to match the remaining portion (specified
      by the closure's already-bound arguments) of the pattern against
      the input String, starting at the intermediate state given by its
      State argument. If the match succeeds, the Continuation
      returns the final State that it reached; if the match fails, the
      Continuation returns FAILURE.

-   A Matcher procedure is an internal closure that takes two
      arguments -- a State and a Continuation -- and returns a
      MatchResult result. A Matcher attempts to match a middle
      subpattern (specified by the closure's already-bound arguments) of
      the pattern against the input String, starting at the intermediate
      state given by its State argument. The Continuation argument
      should be a closure that matches the rest of the pattern. After
      matching the subpattern of a pattern to obtain a new State, the
      Matcher then calls Continuation on that new State to test if
      the rest of the pattern can match as well. If it can, the
      Matcher returns the State returned by Continuation; if not,
      the Matcher may try different choices at its choice points,
      repeatedly calling Continuation until it either succeeds or all
      possibilities have been exhausted.

-   An AssertionTester procedure is an internal closure that takes a
      State argument and returns a Boolean result. The assertion
      tester tests a specific condition (specified by the closure's
      already-bound arguments) against the current place in the input
      String and returns TRUE if the condition matched or FALSE if not.

-   An EscapeValue is either a character or an integer. An
      EscapeValue is used to denote the interpretation of a
      DecimalEscape escape sequence: a character ch means that the
      escape sequence is interpreted as the character ch, while an
      integer n means that the escape sequence is interpreted as a
      backreference to the n^th^ set of capturing parentheses.

The production Pattern :: Disjunction evaluates as follows:

1.  Let Input be the given String str. This variable will be used
      throughout the algorithms in 15.10.2.

2.  Let InputLength be the length of Input. This variable will be
      used throughout the algorithms in 15.10.2.

3.  Let c be a Continuation that always returns its State argument as
      a successful MatchResult.

4.  Let cap be an internal array of NcapturingParens UNDEFINED
      values, indexed 1 through NcapturingParens.

5.  Let x be the State (index, cap).

6.  Call m_(_x, c) and return its result.

NOTE A Pattern evaluates ("compiles") to an internal procedure value.
REGEXP.PROTOTYPE.EXEC can then apply this procedure to a String and an
offset within the String to determine whether the pattern would match
starting at exactly that offset within the String, and, if it does
match, what the values of the capturing parentheses would be. The
algorithms in 15.10.2 are designed so that compiling a pattern may throw
a SYNTAXERROR exception; on the other hand, once the pattern is
successfully compiled, applying its result internal procedure to find a
match in a String cannot throw an exception (except for any host-defined
exceptions that can occur anywhere such as out-of-memory).

The production Disjunction :: Alternative evaluates by evaluating
Alternative to obtain a Matcher and returning that Matcher.

The production Disjunction :: Alternative | Disjunction evaluates
as follows:

NOTE The | regular expression operator separates two alternatives. The
pattern first tries to match the left Alternative (followed by the
sequel of the regular expression); if it fails, it tries to match the
right Disjunction (followed by the sequel of the regular expression).
If the left Alternative, the right Disjunction, and the sequel all
have choice points, all choices in the sequel are tried before moving on
to the next choice in the left Alternative. If choices in the left
Alternative are exhausted, the right Disjunction is tried instead of
the left Alternative. Any capturing parentheses inside a portion of
the pattern skipped by | produce UNDEFINED values instead of Strings.
Thus, for example,

  /a|ab/.exec("abc")

returns the result "A" and not "AB". Moreover,

  /((a)|(ab))((c)|(bc))/.exec("abc")

returns the array

  ["abc", "a", "a", undefined, "bc", undefined, "bc"]

and not

  ["abc", "ab", undefined, "ab", "c", "c", undefined]

The production Alternative :: [empty] evaluates by returning a Matcher
that takes two arguments, a State x and a Continuation c, and
returns the result of calling c_(_x).

The production Alternative :: Alternative Term evaluates as
follows:

NOTE Consecutive Terms try to simultaneously match consecutive
portions of the input String. If the left Alternative, the right
Term, and the sequel of the regular expression all have choice points,
all choices in the sequel are tried before moving on to the next choice
in the right Term, and all choices in the right Term are tried
before moving on to the next choice in the left Alternative.

The production Term :: Assertion evaluates by returning an internal
Matcher closure that takes two arguments, a State x and a Continuation
c, and performs the following:

The production Term :: Atom evaluates by evaluating Atom to obtain
a Matcher and returning that Matcher.

The production Term :: Atom Quantifier evaluates as follows:

RUNTIME SEMANTICS: REPEATMATCHER ABSTRACT OPERATION

The abstract operation RepeatMatcher takes eight parameters, a Matcher
m, an integer min, an integer (or ∞) max, a Boolean greedy, a
State x, a Continuation c, an integer parenIndex, and an integer
parenCount, and performs the following:

NOTE 1 An Atom followed by a Quantifier is repeated the number of
times specified by the Quantifier. A Quantifier can be non-greedy,
in which case the Atom pattern is repeated as few times as possible
while still matching the sequel, or it can be greedy, in which case the
Atom pattern is repeated as many times as possible while still
matching the sequel. The Atom pattern is repeated rather than the
input String that it matches, so different repetitions of the Atom can
match different input substrings.

NOTE 2 If the Atom and the sequel of the regular expression all have
choice points, the Atom is first matched as many (or as few, if
non-greedy) times as possible. All choices in the sequel are tried
before moving on to the next choice in the last repetition of Atom.
All choices in the last (n^th^) repetition of Atom are tried before
moving on to the next choice in the next-to-last (n–1)^st^ repetition of
Atom; at which point it may turn out that more or fewer repetitions of
Atom are now possible; these are exhausted (again, starting with
either as few or as many as possible) before moving on to the next
choice in the (n-1)^st^ repetition of Atom and so on.

Compare

  /a[a-z]{2,4}/.exec("abcdefghi")

which returns "ABCDE" with

  /a[a-z]{2,4}?/.exec("abcdefghi")

which returns "ABC".

Consider also

  /(aa|aabaac|ba|b|c)*/.exec("aabaac")

which, by the choice point ordering above, returns the array

  ["aaba", "ba"]

and not any of:

  ["aabaac", "aabaac"]

  ["aabaac", "c"]

The above ordering of choice points can be used to write a regular
expression that calculates the greatest common divisor of two numbers
(represented in unary notation). The following example calculates the
gcd of 10 and 15:

  "aaaaaaaaaa,aaaaaaaaaaaaaaa".replace(/^(a+)\1*,\1+$/,"$1")

which returns the gcd in unary notation "AAAAA".

NOTE 3 Step 4 of the RepeatMatcher clears Atom's captures each time
Atom is repeated. We can see its behaviour in the regular expression

  /(z)((a+)?(b+)?(c))*/.exec("zaacbbbcac")

which returns the array

  ["zaacbbbcac", "z", "ac", "a", undefined, "c"]

and not

  ["zaacbbbcac", "z", "ac", "a", "bbb", "c"]

because each iteration of the outermost * clears all captured Strings
contained in the quantified Atom, which in this case includes capture
Strings numbered 2, 3, 4, and 5.

NOTE 4 Step 1 of the RepeatMatcher's d closure states that, once the
minimum number of repetitions has been satisfied, any more expansions of
Atom that match the empty String are not considered for further
repetitions. This prevents the regular expression engine from falling
into an infinite loop on patterns such as:

  /(a*)*/.exec("b")

or the slightly more complicated:

  /(a*)b\1+/.exec("baaaac")

which returns the array

  ["b", ""]

The production Assertion :: ^ evaluates by returning an internal
AssertionTester closure that takes a State argument x and performs the
following:

The production Assertion :: $ evaluates by returning an internal
AssertionTester closure that takes a State argument x and performs the
following:

The production Assertion :: \ B evaluates by returning an internal
AssertionTester closure that takes a State argument x and performs the
following:

The production Assertion :: \ B evaluates by returning an internal
AssertionTester closure that takes a State argument x and performs the
following:

The production Assertion :: ( ? = Disjunction ) evaluates as
follows:

The production Assertion :: ( ? ! Disjunction ) evaluates as
follows:

RUNTIME SEMANTICS: ISWORDCHAR ABSTRACT OPERATION

The abstract operation IsWordChar takes an integer parameter e and
performs the following:

  --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
  a   b   c   d   e   f   g   h   i   j   k   l   m   n   o   p   q   r   s   t   u   v   w   x   y   z
  A   B   C   D   E   F   G   H   I   J   K   L   M   N   O   P   Q   R   S   T   U   V   W   X   Y   Z
  0   1   2   3   4   5   6   7   8   9   _                                                           
  --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---

The production Quantifier :: QuantifierPrefix evaluates as follows:

The production Quantifier :: QuantifierPrefix ? evaluates as
follows:

The production QuantifierPrefix :: * evaluates by returning the two
results 0 and ∞.

The production QuantifierPrefix :: + evaluates by returning the two
results 1 and ∞.

The production QuantifierPrefix :: ? evaluates by returning the two
results 0 and 1.

The production QuantifierPrefix :: { DecimalDigits } evaluates as
follows:

The production QuantifierPrefix :: { DecimalDigits , } evaluates as
follows:

The production QuantifierPrefix :: { DecimalDigits , DecimalDigits
} evaluates as follows:

The production Atom :: PatternCharacter evaluates as follows:

The production Atom :: . evaluates as follows:

The production Atom :: \ AtomEscape evaluates by evaluating
AtomEscape to obtain a Matcher and returning that Matcher.

The production Atom :: CharacterClass evaluates as follows:

The production Atom :: ( Disjunction ) evaluates as follows:

The production Atom :: ( ? : Disjunction ) evaluates by evaluating
Disjunction to obtain a Matcher and returning that Matcher.

RUNTIME SEMANTICS: CHARACTERSETMATCHER ABSTRACT OPERATION

The abstract operation CharacterSetMatcher takes two arguments, a
CharSet A and a Boolean flag invert, and performs the following:

a.  If there exists a member a of set A such that
      Canonicalize_(_a) is cc, return FAILURE.

RUNTIME SEMANTICS: CANONICALIZE ABSTRACT OPERATION

The abstract operation Canonicalize takes a character parameter ch
and performs the following steps:

NOTE 1 Parentheses of the form ( Disjunction ) serve both to group the
components of the Disjunction pattern together and to save the result
of the match. The result can be used either in a backreference (\
followed by a nonzero decimal number), referenced in a replace String,
or returned as part of an array from the regular expression matching
internal procedure. To inhibit the capturing behaviour of parentheses,
use the form (?: Disjunction ) instead.

NOTE 2 The form (?= Disjunction ) specifies a zero-width positive
lookahead. In order for it to succeed, the pattern inside Disjunction
must match at the current position, but the current position is not
advanced before matching the sequel. If Disjunction can match at the
current position in several ways, only the first one is tried. Unlike
other regular expression operators, there is no backtracking into a (?=
form (this unusual behaviour is inherited from Perl). This only matters
when the Disjunction contains capturing parentheses and the sequel of
the pattern contains backreferences to those captures.

For example,

  /(?=(a+))/.exec("baaabac")

matches the empty String immediately after the first B and therefore
returns the array:

  ["", "aaa"]

To illustrate the lack of backtracking into the lookahead, consider:

  /(?=(a+))a*b\1/.exec("baaabac")

This expression returns

  ["aba", "a"]

and not:

  ["aaaba", "a"]

NOTE 3 The form (?! Disjunction ) specifies a zero-width negative
lookahead. In order for it to succeed, the pattern inside Disjunction
must fail to match at the current position. The current position is not
advanced before matching the sequel. Disjunction can contain capturing
parentheses, but backreferences to them only make sense from within
Disjunction itself. Backreferences to these capturing parentheses from
elsewhere in the pattern always return UNDEFINED because the negative
lookahead must fail for the pattern to succeed. For example,

  /(.*?)a(?!(a+)b\2c)\2(.*)/.exec("baaabaac")

looks for an A not immediately followed by some positive number n of
A's, a B, another n A's (specified by the first \2) and a C. The second
\2 is outside the negative lookahead, so it matches against UNDEFINED
and therefore always succeeds. The whole expression returns the array:

  ["baaabaac", "ba", undefined, "abaac"]

In case-insignificant matches all characters are implicitly converted to
upper case immediately before they are compared. However, if converting
a character to upper case would expand that character into more than one
character (such as converting "SS" (\u00DF) into "SS"), then the
character is left as-is instead. The character is also left as-is if it
is not an ASCII character but converting it to upper case would make it
into an ASCII character. This prevents Unicode characters such as \u0131
and \u017F from matching regular expressions such as /[AZ]/I, which are
only intended to match ASCII letters. Furthermore, if these conversions
were allowed, then /[^\W]/I would match each of A, B, …, H, but not I or
S.

The production AtomEscape :: DecimalEscape evaluates as follows:

The production AtomEscape :: CharacterEscape evaluates as follows:

The production AtomEscape :: CharacterClassEscape evaluates as
follows:

NOTE An escape sequence of the form \ followed by a nonzero decimal
number n matches the result of the nth set of capturing parentheses
(see 15.10.2.11). It is an error if the regular expression has fewer
than n capturing parentheses. If the regular expression has n or
more capturing parentheses but the nth one is UNDEFINED because it has
not captured anything, then the backreference always succeeds.

The production CharacterEscape :: ControlEscape evaluates by
returning the character according to Table 29.

Table 31 — ControlEscape Character Values

  ------------------ ------------- ---------------------- ----------
  _CONTROLESCAPE _   _CODE UNIT_   NAME                 SYMBOL
  T                  \U0009        horizontal tab         <HT>
  N                  \U000A        line feed (new line)   <LF>
  V                  \U000B        vertical tab           <VT>
  F                  \U000C        form feed              <FF>
  R                  \U000D        carriage return        <CR>
  ------------------ ------------- ---------------------- ----------

The production CharacterEscape :: C ControlLetter evaluates as
follows:

The production CharacterEscape :: HexEscapeSequence evaluates by
evaluating the CV of the HexEscapeSequence (see 7.8.4) and returning
its character result.

The production CharacterEscape :: UnicodeEscapeSequence evaluates by
evaluating the CV of the UnicodeEscapeSequence (see 7.8.4) and
returning its character result.

The production CharacterEscape :: IdentityEscape evaluates by
returning the character represented by IdentityEscape.

The production DecimalEscape :: DecimalIntegerLiteral [lookahead ∉
DecimalDigit] evaluates as follows:

The definition of “the MV of DecimalIntegerLiteral” is in 7.8.3.

NOTE If \ is followed by a decimal number n whose first digit is not
0, then the escape sequence is considered to be a backreference. It is
an error if n is greater than the total number of left capturing
parentheses in the entire regular expression. \0 represents the <NUL>
character and cannot be followed by a decimal digit.

The production CharacterClassEscape :: D evaluates by returning the
ten-element set of characters containing the characters 0 through 9
inclusive.

The production CharacterClassEscape :: D evaluates by returning the
set of all characters not included in the set returned by
CharacterClassEscape :: D.

The production CharacterClassEscape :: S evaluates by returning the
set of characters containing the characters that are on the right-hand
side of the WhiteSpace (7.2) or LineTerminator (7.3) productions.

The production CharacterClassEscape :: S evaluates by returning the
set of all characters not included in the set returned by
CharacterClassEscape :: S.

The production CharacterClassEscape :: W evaluates by returning the
set of characters containing the sixty-three characters:

  --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
  a   b   c   d   e   f   g   h   i   j   k   l   m   n   o   p   q   r   s   t   u   v   w   x   y   z
  A   B   C   D   E   F   G   H   I   J   K   L   M   N   O   P   Q   R   S   T   U   V   W   X   Y   Z
  0   1   2   3   4   5   6   7   8   9   _                                                           
  --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---

The production CharacterClassEscape :: W evaluates by returning the
set of all characters not included in the set returned by
CharacterClassEscape :: W.

The production CharacterClass :: [ [lookahead ∉ {^}] ClassRanges ]
evaluates by evaluating ClassRanges to obtain a CharSet and returning
that CharSet and the Boolean FALSE.

The production CharacterClass :: [ ^ ClassRanges ] evaluates by
evaluating ClassRanges to obtain a CharSet and returning that CharSet
and the Boolean TRUE.

The production ClassRanges :: [empty] evaluates by returning the empty
CharSet.

The production ClassRanges :: NonemptyClassRanges evaluates by
evaluating NonemptyClassRanges to obtain a CharSet and returning that
CharSet.

The production NonemptyClassRanges :: ClassAtom evaluates by
evaluating ClassAtom to obtain a CharSet and returning that CharSet.

The production NonemptyClassRanges :: ClassAtom
NonemptyClassRangesNoDash evaluates as follows:

1.  Evaluate ClassAtom to obtain a CharSet A.

2.  Evaluate NonemptyClassRangesNoDash to obtain a CharSet B.

3.  Return the union of CharSets A and B.

The production NonemptyClassRanges :: ClassAtom - ClassAtom
ClassRanges evaluates as follows:

RUNTIME SEMANTICS: CHARACTERRANGE ABSTRACT OPERATION

The abstract operation CharacterRange takes two CharSet parameters A
and B and performs the following:

The production NonemptyClassRangesNoDash :: ClassAtom evaluates by
evaluating ClassAtom to obtain a CharSet and returning that CharSet.

The production NonemptyClassRangesNoDash :: ClassAtomNoDash
NonemptyClassRangesNoDash evaluates as follows:

The production NonemptyClassRangesNoDash :: ClassAtomNoDash -
ClassAtom ClassRanges evaluates as follows:

NOTE 1 ClassRanges can expand into single ClassAtoms and/or ranges
of two ClassAtoms separated by dashes. In the latter case the
ClassRanges includes all characters between the first ClassAtom and
the second ClassAtom, inclusive; an error occurs if either ClassAtom
does not represent a single character (for example, if one is \W) or if
the first ClassAtom's code unit value is greater than the second
ClassAtom's code unit value.

NOTE 2 Even if the pattern ignores case, the case of the two ends of a
range is significant in determining which characters belong to the
range. Thus, for example, the pattern /[E-F]/I matches only the letters
E, F, E, and F, while the pattern /[E-F]/I matches all upper and
lower-case ASCII letters as well as the symbols [, \, ], ^, _, and `.

NOTE 3 A - character can be treated literally or it can denote a range.
It is treated literally if it is the first or last character of
ClassRanges, the beginning or end limit of a range specification, or
immediately follows a range specification.

The production ClassAtom :: - evaluates by returning the CharSet
containing the one character -.

The production ClassAtom :: ClassAtomNoDash evaluates by evaluating
ClassAtomNoDash to obtain a CharSet and returning that CharSet.

The production ClassAtomNoDash :: SourceCharacter BUT NOT ONE OF \
OR ] OR - evaluates by returning a one-element CharSet containing the
character represented by SourceCharacter.

The production ClassAtomNoDash :: \ ClassEscape evaluates by
evaluating ClassEscape to obtain a CharSet and returning that CharSet.

The production ClassEscape :: DecimalEscape evaluates as follows:

The production ClassEscape :: B evaluates by returning the CharSet
containing the one character <BS> (Unicode value 0008).

The production ClassEscape :: CharacterEscape evaluates by
evaluating CharacterEscape to obtain a character and returning a
one-element CharSet containing that character.

The production ClassEscape :: CharacterClassEscape evaluates by
evaluating CharacterClassEscape to obtain a CharSet and returning that
CharSet.

NOTE A ClassAtom can use any of the escape sequences that are allowed
in the rest of the regular expression except for \B, \B, and
backreferences. Inside a CharacterClass, \B means the backspace
character, while \B and backreferences raise errors. Using a
backreference inside a ClassAtom causes an error.

The following steps are taken:

When REGEXP is called as part of a NEW expression, it is a constructor:
it initialises the newly created object.

The following steps are taken:

1.  Return the result of the abstract operation RegExpCreate with
    arguments pattern and flags.

RUNTIME SEMANTICS: REGEXPCREATE ABSTRACT OPERATION

The abstract operation RegExpCreate with arguments pattern and flags
does the following:

If pattern is an object R that has a [[NativeBrand]] internal
property whose value is NativeRegExp and flags is UNDEFINED, then let
P be the pattern used to construct R and let F be the flags used
to construct R. If pattern is an object R that has a
[[NativeBrand]] internal property whose value is NativeRegExp and
flags is not UNDEFINED, then throw a TYPEERROR exception. Otherwise,
let P be the empty String if pattern is UNDEFINED and
ToString(pattern) otherwise, and let F be the empty String if
flags is UNDEFINED and ToString(flags) otherwise.

If the characters of P do not have the syntactic form Pattern, then
throw a SYNTAXERROR exception. Otherwise let the newly constructed
object have a [[Match]] internal property obtained by evaluating
("compiling") the characters of P as a Pattern as described in
15.10.2.

If F contains any character other than "G", "I", or "M", or if it
contains the same character more than once, then throw a SYNTAXERROR
exception.

If a SYNTAXERROR exception is not thrown, then:

Let S be a String in the form of a Pattern equivalent to P, in
which certain characters are escaped as described below. S may or may
not be identical to P or pattern; however, the internal procedure
that would result from evaluating S as a Pattern must behave
identically to the internal procedure given by the constructed object's
[[Match]] internal property.

The characters / occurring in the pattern shall be escaped in S as
necessary to ensure that the String value formed by concatenating the
Strings "/", S, "/", and F can be parsed (in an appropriate lexical
context) as a RegularExpressionLiteral that behaves identically to the
constructed regular expression. For example, if P is "/", then S
could be "\/" or "\U002F", among other possibilities, but not "/",
because /// followed by F would be parsed as a SingleLineComment
rather than a RegularExpressionLiteral. If P is the empty String,
this specification can be met by letting S be "(?:)".

The following properties of the newly constructed object are data
properties with the attributes that are specified in 15.10.7. The
[[Value]] of each property is set as follows:

The SOURCE property of the newly constructed object is set to S.

The GLOBAL property of the newly constructed object is set to a Boolean
value that is TRUE if F contains the character "G" and FALSE
otherwise.

The IGNORECASE property of the newly constructed object is set to a
Boolean value that is TRUE if F contains the character "I" and FALSE
otherwise.

The MULTILINE property of the newly constructed object is set to a
Boolean value that is TRUE if F contains the character "M" and FALSE
otherwise.

The LASTINDEX property of the newly constructed object is set to 0.

The [[Prototype]] internal property of the newly constructed object is
set to the standard built-in RegExp prototype object as specified in
15.10.6.

The newly constructed object has a [[NativeBrand]] internal property
whose value is NativeRegExp

NOTE If pattern is a StringLiteral, the usual escape sequence
substitutions are performed before the String is processed by RegExp. If
pattern must contain an escape sequence to be recognised by RegExp, any
backslash \ characters must be escaped within the StringLiteral to
prevent them being removed when the contents of the StringLiteral are
formed.

The value of the [[Prototype]] internal property of the RegExp
constructor is the standard built-in Function prototype object (15.3.4).

Besides the internal properties and the LENGTH property (whose value is
2), the RegExp constructor has the following properties:

The initial value of REGEXP.PROTOTYPE is the RegExp prototype object
(15.10.6).

This property shall have the attributes { [[Writable]]: FALSE,
[[Enumerable]]: FALSE, [[Configurable]]: FALSE }.

The value of the [[Prototype]] internal property of the RegExp prototype
object is the standard built-in Object prototype object (15.2.4). The
RegExp prototype object is itself a regular expression object; it has a
[[NativeBrand]] internal property whose value is NativeRegExp . The
initial values of the RegExp prototype object’s data properties
(15.10.7) are set as if the object was created by the expression NEW
REGEXP() where REGEXP is that standard built-in constructor with that
name.

The RegExp prototype object does not have a VALUEOF property of its own;
however, it inherits the VALUEOF property from the Object prototype
object.

In the following descriptions of functions that are properties of the
RegExp prototype object, the phrase “this RegExp object” refers to the
object that is the THIS value for the invocation of the function; a
TYPEERROR exception is thrown if the THIS value is not an object that
has a [[NativeBrand]] internal property whose value is NativeRegExp.

The initial value of REGEXP.PROTOTYPE.CONSTRUCTOR is the standard
built-in REGEXP constructor.

Performs a regular expression match of string against the regular
expression and returns an Array object containing the results of the
match, or NULL if string did not match.

The String ToString(string) is searched for an occurrence of the
regular expression pattern as follows:

1.  Let R be this RegExp object.

2.  ReturnIfAbrupt(R).

3.  Let S be the value of ToString(string)

4.  ReturnIfAbrupt(S).

5.  Return the result of the RegExpExec abstract operation with
    arguments R and S.

RUNTIME SEMANTICS: REGEXPEXEC ABSTRACT OPERATION

The abstract operation RegExpExec with arguments R (an object) and S
(a string) performs the following steps:

1.  Let length be the length of S.

2.  Let lastIndex be the result of calling the [[Get]] internal method
    of R with argument "LASTINDEX".

3.  Let i be the value of ToInteger(lastIndex).

4.  ReturnIfAbrupt(i).

5.  Let global be the result of calling the [[Get]] internal method of
    R with argument "GLOBAL".

6.  ReturnIfAbrupt(global).

7.  If global is FALSE, then let i = 0.

8.  Let matchSucceeded be FALSE.

9.  Repeat, while matchSucceeded is FALSE

    a.  If i < 0 or i > length, then

        i.  Let putStatus be the result of calling the [[Put]]
            internal method of R with arguments "LASTINDEX", 0, and
            TRUE.

        ii. ReturnIfAbrupt(putStatus).

        iii. Return NULL.

    b.  Let r be the result of calling the [[Match]] internal method
        of R with arguments S and i.

    c.  If r is FAILURE, then

        i.  _Let i = i+1._

    d.  else

        i.  Assert: r is a State.

        ii. Set matchSucceeded to TRUE.

10. Let e be r's endIndex value.

11. If global is TRUE,

    a.  Let putStatus be the result of calling the [[Put]] internal
        method of R with arguments "LASTINDEX", e, and TRUE.

    b.  ReturnIfAbrupt(putStatus).

12. Let n be the length of r's captures array. (This is the same
    value as 15.10.2.1's NCapturingParens.)

13. Let A be the result of the abstract operation ArrayCreate with
    argument 0.

14. Let matchIndex be i.

15. Assert: The following [DefineOwnProperty]] calls will not result in
    an abrupt completion.

16. Call the [[DefineOwnProperty]] internal method of A with arguments
    "INDEX", Property Descriptor {[[Value]]: matchIndex, [[Writable]]:
    TRUE, [[Enumerable]]: TRUE, [[Configurable]]: TRUE}, and TRUE.

17. Call the [[DefineOwnProperty]] internal method of A with arguments
    "INPUT", Property Descriptor {[[Value]]: S, [[Writable]]: TRUE,
    [[Enumerable]]: TRUE, [[Configurable]]: TRUE}, and TRUE.

18. Call the [[DefineOwnProperty]] internal method of A with arguments
    "LENGTH", Property Descriptor {[[Value]]: n + 1}, and TRUE.

19. Let matchedSubstr be the matched substring (i.e. the portion of
    S between offset i inclusive and offset e exclusive).

20. Call the [[DefineOwnProperty]] internal method of A with arguments
    "0", Property Descriptor {[[Value]]: matchedSubstr, [[Writable]]:
    TRUE, [[Enumerable]]: TRUE, [[Configurable]]: TRUE}, and TRUE.

21. For each integer i such that i > 0 and i ≤ n

    a.  Let captureI be i^th^ element of r's captures array.

    b.  Call the [[DefineOwnProperty]] internal method of A with
        arguments ToString(i), Property Descriptor {[[Value]]:
        captureI, [[Writable]]: TRUE, [[Enumerable]]: TRUE,
        [[Configurable]]: TRUE}, and TRUE.

22. Return A.

The following steps are taken:

Return the String value formed by concatenating the Strings "/", the
String value of the SOURCE property of this RegExp object, and "/"; plus
"G" if the GLOBAL property is TRUE, "I" if the IGNORECASE property is
TRUE, and "M" if the MULTILINE property is TRUE.

NOTE The returned String has the form of a RegularExpressionLiteral
that evaluates to another RegExp object with the same behaviour as this
object.

RegExp instances inherit properties from the RegExp prototype object and
have a [[NativeBrand]] internal property whose value is NativeRegExp.
RegExp instances also have a [[Match]] internal property and a LENGTH
property.

The value of the [[Match]] internal property is an implementation
dependent representation of the Pattern of the RegExp object.

RegExp instances also have the following properties.

The value of the SOURCE property is a String in the form of a Pattern
representing the current regular expression. This property shall have
the attributes { [[Writable]]: FALSE, [[Enumerable]]: FALSE,
[[Configurable]]: FALSE }.

The value of the GLOBAL property is a Boolean value indicating whether
the flags contained the character “G”. This property shall have the
attributes { [[Writable]]: FALSE, [[Enumerable]]: FALSE,
[[Configurable]]: FALSE }.

The value of the IGNORECASE property is a Boolean value indicating
whether the flags contained the character “I”. This property shall have
the attributes { [[Writable]]: FALSE, [[Enumerable]]: FALSE,
[[Configurable]]: FALSE }.

The value of the MULTILINE property is a Boolean value indicating
whether the flags contained the character “M”. This property shall have
the attributes { [[Writable]]: FALSE, [[Enumerable]]: FALSE,
[[Configurable]]: FALSE }.

The value of the LASTINDEX property specifies the String position at
which to start the next match. It is coerced to an integer when used
(see 15.10.6.2). This property shall have the attributes { [[Writable]]:
TRUE, [[Enumerable]]: FALSE, [[Configurable]]: FALSE }.

NOTE Unlike the other standard built-in properties of RegExp instances,
LASTINDEX is writable.

Instances of Error objects are thrown as exceptions when runtime errors
occur. The Error objects may also serve as base objects for user-defined
exception classes.

When ERROR is called as a function rather than as a constructor, it
creates and initialises a new Error object. Thus the function call
ERROR(…) is equivalent to the object creation expression NEW ERROR(…)
with the same arguments.

The [[Prototype]] internal property of the newly constructed object is
set to the original Error prototype object, the one that is the initial
value of ERROR.PROTOTYPE (15.11.3.1).

The newly constructed object has a [[NativeBrand]] internal property
whose value is NativeError.

The [[Extensible]] internal property of the newly constructed object is
set to TRUE.

If the argument message is not UNDEFINED, the MESSAGE own property of
the newly constructed object is set to ToString(message).

When ERROR is called as part of a NEW expression, it is a constructor:
it initialises the newly created object.

The [[Prototype]] internal property of the newly constructed object is
set to the original Error prototype object, the one that is the initial
value of ERROR.PROTOTYPE (15.11.3.1).

The newly constructed object has a [[NativeBrand]] internal property
whose value is NativeError .

The [[Extensible]] internal property of the newly constructed object is
set to TRUE.

If the argument message is not UNDEFINED, the MESSAGE own property of
the newly constructed object is set to ToString(message).

The value of the [[Prototype]] internal property of the Error
constructor is the Function prototype object (15.3.4).

Besides the internal properties and the LENGTH property (whose value is
1), the Error constructor has the following property:

The initial value of ERROR.PROTOTYPE is the Error prototype object
(15.11.4).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

The Error prototype object is itself an Error object and has a
[[NativeBrand]] internal property whose value is NativeError .

The value of the [[Prototype]] internal property of the Error prototype
object is the standard built-in Object prototype object (15.2.4).

The initial value of ERROR.PROTOTYPE.CONSTRUCTOR is the built-in ERROR
constructor.

The initial value of ERROR.PROTOTYPE.NAME is "ERROR".

The initial value of ERROR.PROTOTYPE.MESSAGE is the empty String.

The following steps are taken:

Error instances inherit properties from the Error prototype object and
have a [[NativeBrand]] internal property whose value is NativeError .
Error instances have no special properties.

One of the NativeError objects below is thrown when a runtime error is
detected. All of these objects share the same structure, as described in
15.11.7.

This exception is not currently used within this specification. This
object remains for compatibility with previous editions of this
specification.

Indicates a numeric value has exceeded the allowable range. See
15.4.2.2, 15.4.5.1, 15.7.4.2, 15.7.4.5, 15.7.4.6, 15.7.4.7, and
15.9.5.43.

Indicate that an invalid reference value has been detected. See 8.9.1,
8.9.2, 10.2.1, 10.2.1.1.4, 10.2.1.2.4, and 11.13.1.

Indicates that a parsing error has occurred. See 11.1.5, 11.3.1, 11.3.2,
11.4.1, 11.4.4, 11.4.5, 11.13.1, 11.13.2, 12.2.1, 12.10.1, 12.14.1,
13.1, 15.1.2.1, 15.3.2.1, 15.10.2.2, 15.10.2.5, 15.10.2.9, 15.10.2.15,
15.10.2.19, 15.10.4.1, and 15.12.2.

Indicates the actual type of an operand is different than the expected
type. See 8.6.2, 8.9.2, 8.10.5, 8.12.5, 8.12.7, 8.12.8, 8.12.9, 9.9,
9.10, 10.2.1, 10.2.1.1.3, 10.6, 11.2.2, 11.2.3, 11.4.1, 11.8.6, 11.8.7,
11.3.1, 13.2, 13.2.3, 15, 15.2.3.2, 15.2.3.3, 15.2.3.4, 15.2.3.5,
15.2.3.6, 15.2.3.7, 15.2.3.8, 15.2.3.9, 15.2.3.10, 15.2.3.11, 15.2.3.12,
15.2.3.13, 15.2.3.14, 15.2.4.3, 15.3.4.2, 15.3.4.3, 15.3.4.4, 15.3.4.5,
15.3.4.5.2, 15.3.4.5.3, 15.3.5, 15.3.5.3, 15.3.5.4, 15.4.4.3, 15.4.4.11,
15.4.4.16, 15.4.4.17, 15.4.4.18, 15.4.4.19, 15.4.4.20, 15.4.4.21,
15.4.4.22, 15.4.5.1, 15.5.4.2, 15.5.4.3, 15.6.4.2, 15.6.4.3, 15.7.4,
15.7.4.2, 15.7.4.4, 15.9.5, 15.9.5.44, 15.10.4.1, 15.10.6, 15.11.4.4 and
15.12.3.

Indicates that one of the global URI handling functions was used in a
way that is incompatible with its definition. See 15.1.3.

When an ECMAScript implementation detects a runtime error, it throws an
instance of one of the NativeError objects defined in 15.11.6. Each of
these objects has the structure described below, differing only in the
name used as the constructor name instead of NativeError, in the NAME
property of the prototype object, and in the implementation-defined
MESSAGE property of the prototype object.

For each error object, references to NativeError in the definition
should be replaced with the appropriate error object name from 15.11.6.

When a NativeError constructor is called as a function rather than as
a constructor, it creates and initialises a new object. A call of the
object as a function is equivalent to calling it as a constructor with
the same arguments.

The [[Prototype]] internal property of the newly constructed object is
set to the prototype object for this error constructor. The newly
constructed object has a [[NativeBrand]] internal property whose value
is NativeError . The [[Extensible]] internal property of the newly
constructed object is set to TRUE.

If the argument message is not UNDEFINED, the MESSAGE own property of
the newly constructed object is set to ToString(message).

When a NativeError constructor is called as part of a NEW expression,
it is a constructor: it initialises the newly created object.

The [[Prototype]] internal property of the newly constructed object is
set to the prototype object for this NativeError constructor. The
newly constructed object has a [[NativeBrand]] internal property whose
value is NativeError . The [[Extensible]] internal property of the newly
constructed object is set to TRUE.

If the argument message is not UNDEFINED, the MESSAGE own property of
the newly constructed object is set to ToString(message).

The value of the [[Prototype]] internal property of a NativeError
constructor is the Function prototype object (15.3.4).

Besides the internal properties and the LENGTH property (whose value is
1), each NativeError constructor has the following property:

The initial value of NATIVEERROR.PROTOTYPE is a NativeError
prototype object (15.11.7.7). Each NativeError constructor has a
separate prototype object.

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

Each NativeError prototype object is an Error object and has a
[[NativeBrand]] internal property whose value is NativeError .

The value of the [[Prototype]] internal property of each NativeError
prototype object is the standard built-in Error prototype object
(15.11.4).

The initial value of the CONSTRUCTOR property of the prototype for a
given NativeError constructor is the NativeError constructor
function itself (15.11.7).

The initial value of the NAME property of the prototype for a given
NativeError constructor is the name of the constructor (the name used
instead of NativeError).

The initial value of the MESSAGE property of the prototype for a given
NativeError constructor is the empty String.

NOTE The prototypes for the NativeError constructors do not themselves
provide a TOSTRING function, but instances of errors will inherit it
from the Error prototype object.

NativeError instances inherit properties from their NativeError
prototype object and have a [[NativeBrand]] internal property whose
value is NativeError . NativeError instances have no special
properties.

The JSON object is a single object that contains two functions, PARSE
and STRINGIFY, that are used to parse and construct JSON texts. The JSON
Data Interchange Format is described in RFC 4627
<http://www.ietf.org/rfc/rfc4627.txt>. The JSON interchange format used
in this specification is exactly that described by RFC 4627 with two
exceptions:

-   The top level JSONText production of the ECMAScript JSON grammar
    may consist of any JSONValue rather than being restricted to being
    a JSONObject or a JSONArray as specified by RFC 4627.

-   Conforming implementations of JSON.PARSE and JSON.STRINGIFY must
    support the exact interchange format described in this specification
    without any deletions or extensions to the format. This differs from
    RFC 4627 which permits a JSON parser to accept non-JSON forms and
    extensions.

The value of the [[Prototype]] internal property of the JSON object is
the standard built-in Object prototype object (15.2.4). The JSON object
has a [[NativeBrand]] internal property whose value is NativeJSON . The
value of the [[Extensible]] internal property of the JSON object is set
to TRUE.

The JSON object does not have a [[Construct]] internal property; it is
not possible to use the JSON object as a constructor with the NEW
operator.

The JSON object does not have a [[Call]] internal property; it is not
possible to invoke the JSON object as a function.

JSON.stringify produces a String that conforms to the following JSON
grammar. JSON.parse accepts a String that conforms to the JSON grammar.

JSON is similar to ECMAScript source text in that it consists of a
sequence of Unicode characters conforming to the rules of
SourceCharacter. The JSON Lexical Grammar defines the tokens that make
up a JSON text similar to the manner that the ECMAScript lexical grammar
defines the tokens of an ECMAScript source text. The JSON Lexical
grammar only recognises the white space character specified by the
production JSONWhiteSpace. The JSON lexical grammar shares some
productions with the ECMAScript lexical grammar. All nonterminal symbols
of the grammar that do not begin with the characters “JSON” are defined
by productions of the ECMAScript lexical grammar.

Syntax

JSONWhiteSpace ::

<TAB>
<CR>
<LF>
<SP>

JSONString ::

" JSONStringCharacters~opt~ "

JSONStringCharacters ::

JSONStringCharacter JSONStringCharacters~opt~

JSONStringCharacter ::

SourceCharacter BUT NOT ONE OF " OR \ OR U+0000 THROUGH U+001F

\ JSONEscapeSequence

JSONEscapeSequence ::

JSONEscapeCharacter

U HexDigit HexDigit HexDigit HexDigit

JSONEscapeCharacter :: ONE OF

" / \ B F N R T

JSONNumber ::

-~opt~ DecimalIntegerLiteral JSONFraction~opt~ ExponentPart~opt~

JSONFraction ::

. DecimalDigits

JSONNullLiteral ::

NullLiteral

JSONBooleanLiteral ::

BooleanLiteral

The JSON Syntactic Grammar defines a valid JSON text in terms of tokens
defined by the JSON lexical grammar. The goal symbol of the grammar is
JSONText.

Syntax

JSONText :

JSONValue

JSONValue :

JSONNullLiteral
JSONBooleanLiteral
JSONObject
JSONArray
JSONString
JSONNumber

JSONObject :

{ }
{ JSONMemberList }

JSONMember :

JSONString : JSONValue

JSONMemberList :

JSONMember
JSONMemberList , JSONMember

JSONArray :

[ ]
[ JSONElementList ]

JSONElementList :

JSONValue
JSONElementList , JSONValue

The PARSE function parses a JSON text (a JSON-formatted String) and
produces an ECMAScript value. The JSON format is a restricted form of
ECMAScript literal. JSON objects are realized as ECMAScript objects.
JSON arrays are realized as ECMAScript arrays. JSON strings, numbers,
booleans, and null are realized as ECMAScript Strings, Numbers,
Booleans, and NULL. JSON uses a more limited set of white space
characters than WhiteSpace and allows Unicode code points U+2028 and
U+2029 to directly appear in JSONString literals without using an
escape sequence. The process of parsing is similar to 11.1.4 and 11.1.5
as constrained by the JSON grammar.

The optional reviver parameter is a function that takes two
parameters, (key and value). It can filter and transform the
results. It is called with each of the key_/_value pairs produced by
the parse, and its return value is used instead of the original value.
If it returns what it received, the structure is not modified. If it
returns UNDEFINED then the property is deleted from the result.

RUNTIME SEMANTICS: WALK ABSTRACT OPERATION

The abstract operation Walk is a recursive abstract operation that takes
two parameters: a holder object and the String name of a property in
that object. Walk uses the value of reviver that was originally passed
to the above parse function.

It is not permitted for a conforming implementation of JSON.PARSE to
extend the JSON grammars. If an implementation wishes to support a
modified or extended JSON interchange format it must do so by defining a
different parse function.

NOTE In the case where there are duplicate name Strings within an
object, lexically preceding values for the same key shall be
overwritten.

The STRINGIFY function returns a String in UTF-16 encoded JSON format
representing an ECMAScript value. It can take three parameters. The
value parameter is an ECMAScript value, which is usually an object or
array, although it can also be a String, Boolean, Number or NULL. The
optional replacer parameter is either a function that alters the way
objects and arrays are stringified, or an array of Strings and Numbers
that acts as a white list for selecting the object properties that will
be stringified. The optional space parameter is a String or Number
that allows the result to have white space injected into it to improve
human readability.

These are the steps in stringifying an object:

RUNTIME SEMANTICS: STR ABSTRACT OPERATION

The abstract operation Str_(_key, holder) has access to
ReplacerFunction from the invocation of the STRINGIFY method. Its
algorithm is as follows:

1.  Let value be the result of calling the [[Get]] internal method of
    holder with argument key.

2.  ReturnIfAbrupt(value).

3.  If Type(value) is Object, then

    a.  Let toJSON be the result of calling the [[Get]] internal
        method of value with argument "TOJSON".

    b.  If IsCallable(toJSON) is TRUE

        i.  Let value be the result of calling the [[Call]] internal
            method of toJSON passing value as thisArgument and a
            List containing key as argumentsList.

        ii. ReturnIfAbrupt(value).

4.  If ReplacerFunction is not UNDEFINED, then

    a.  Let value be the result of calling the [[Call]] internal
        method of ReplacerFunction passing holder as the THIS value
        and with an argument list consisting of key and value.

    b.  ReturnIfAbrupt(value).

5.  If Type(value) is Object then,

    a.  If value has an [[NativeBrand]] internal property with value
        NumberWrapper then,

        i.  Let value be ToNumber(value).

    b.  Else if value has an [[NativeBrand]] internal property with
        value StringWrapper then,

        i.  Let value be ToString(value).

    c.  Else if value has an [[NativeBrand]] internal property with
        value BooleanWrapper then,

        i.  Let value be the value of the [[PrimitiveValue]] internal
            property of value.

6.  If value is NULL then return "NULL".

7.  If value is TRUE then return "TRUE".

8.  If value is FALSE then return "FALSE".

9.  If Type(value) is String, then return the result of calling the
    abstract operation Quote with argument value.

10. If Type(value) is Number

    a.  If value is finite then return ToString(value).

    b.  Else, return "NULL".

11. If Type(value) is Object, and IsCallable(value) is FALSE

    a.  If value has an [[NativeBrand]] internal property with value
        NativeArray then

        i.  Return the result of calling the abstract operation JA
            with argument value.

    b.  Else, return the result of calling the abstract operation JO
        with argument value.

12. Return UNDEFINED.

RUNTIME SEMANTICS: QUOTE ABSTRACT OPERATION

The abstract operation Quote(value) wraps a String value in double
quotes and escapes characters within it.

  backspace "B"

  formfeed "F"

  newline "N"

  carriage return "R"

  tab "T"

RUNTIME SEMANTICS: JO ABSTRACT OPERATION

The abstract operation JO_(_value) serializes an object. It has access
to the stack, indent, gap, and PropertyList of the invocation of
the stringify method.

RUNTIME SEMANTICS: JA ABSTRACT OPERATION

The abstract operation JA_(_value) serializes an array. It has access
to the stack, indent, and gap of the invocation of the stringify
method. The representation of arrays includes only the elements between
zero and ARRAY.LENGTH – 1 inclusive. Named properties are excluded from
the stringification. An array is stringified as an open left bracket,
elements separated by comma, and a closing right bracket.

NOTE 1 JSON structures are allowed to be nested to any depth, but they
must be acyclic. If value is or contains a cyclic structure, then the
stringify function must throw a TYPEERROR exception. This is an example
of a value that cannot be stringified:

  a = [];

  a[0] = a;

  my_text = JSON.stringify(a); // This must throw an TypeError.

NOTE 2 Symbolic primitive values are rendered as follows:

-   The NULL value is rendered in JSON text as the String null.

-   The UNDEFINED value is not rendered.

-   The TRUE value is rendered in JSON text as the String true.

-   The FALSE value is rendered in JSON text as the String false.

NOTE 3 String values are wrapped in double quotes. The characters " and
\ are escaped with \ prefixes. Control characters are replaced with
escape sequences \UHHHH, or with the shorter forms, \B (backspace), \F
(formfeed), \N (newline), \R (carriage return), \T (tab).

NOTE 4 Finite numbers are stringified as if by calling
ToString(number). NAN and Infinity regardless of sign are represented
as the String NULL.

NOTE 5 Values that do not have a JSON representation (such as UNDEFINED
and functions) do not produce a String. Instead they produce the
undefined value. In arrays these values are represented as the String
NULL. In objects an unrepresentable value causes the property to be
excluded from stringification.

NOTE 6 An object is rendered as an opening left brace followed by zero
or more properties, separated with commas, closed with a right brace. A
property is a quoted String representing the key or property name, a
colon, and then the stringified property value. An array is rendered as
an opening left bracket followed by zero or more values, separated with
commas, closed with a right bracket.

The following sections defined “typed arrays” derived from the Kronos
specification. This material is a very early draft based upon the
strawman at
http://wiki.ecmascript.org/doku.php?id=strawman:typed_arrays . This
material still needs significant work to fully integrate it into the ES6
spec. and also to integrate typed arrays with ES6 binary data.

Don’t waste a lot of time reviewing this material until it is closer to
a finished state.

When ArrayBuffer is called as a function rather than as a constructor,
it creates and initialises a new ArrayBuffer object. Thus the function
call ArrayBuffer(…) is equivalent to the object creation expression new
ArrayBuffer (…) with the same arguments.

When ArrayBuffer is called as part of a new expression, it is a
constructor: it initialises the newly created object.

The [[Prototype]] internal property of the newly constructed object is
set to the original ArrayBuffer prototype object, the one that is the
initial value of ArrayBuffer.prototype (16.1.3.1). The [[Class]]
internal property of the newly constructed object is set to
“ArrayBuffer”. The [[Extensible]] internal property of the newly
constructed object is set to true.

The length property of the newly constructed object is set to
ToUInt32(len).

A fresh native buffer nativeBuffer of length bytes is allocated. The
contents of this native buffer are zero initialized. If the requested
number of bytes could not be allocated, a RangeError is raised. The
[[NativeBuffer]] internal property of the newly constructed object is
set to nativeBuffer.

The value of the [[Prototype]] internal property of the ArrayBuffer
constructor is the Function prototype object (15.3.4).

Besides the internal properties and the length property (whose value is
1), the ArrayBuffer constructor has the following properties:

The initial value of ArrayBuffer.prototype is the ArrayBuffer prototype
object (16.1.4).

This property has the attributes { [[Writable]]: false, [[Enumerable]]:
false, [[Configurable]]: false }.

The value of the [[Prototype]] internal property of the Array prototype
object is the standard built-in Object prototype object (15.2.4). The
[[Class]] internal property of the newly constructed object is set to
“Object”. The [[Extensible]] internal property of the newly constructed
object is set to true.

The initial value of ArrayBuffer.prototype.constructor is the standard
built-in ArrayBuffer constructor.

ArrayBuffer instances inherit properties from the ArrayBuffer prototype
object and their [[Class]] internal property value is “ArrayBuffer”.
ArrayBuffer instances also have the following properties.

The byteLength property of this ArrayBuffer object is a data property
whose value is the length of the ArrayBuffer in bytes, as fixed at
construction time.

The length property has the attributes { [[Writable]]: false,
[[Enumerable]]: false, [[Configurable]]: false }.

For each constructor in the following table is a separate TypeArray
constructor object, with corresponding prototype and instances. Each of
these TypeArray constructor objects has the structure described below,
differing only in the name used as the constructor name instead of
TypeArray, in XXXXXXX.

  Constructor Name   Element Type   Size Element   Description                            Equivalent C Type
  ------------------ -------------- -------------- -------------------------------------- -------------------
  Int8Array          Int8           1              8-bit 2’s complement signed integer    signed char
  Uint8Array         Uint8          1              8-bit unsigned integer                 unsigned char
  Int16Array         Int16          2              16-bit 2’s complement signed integer   Short
  Uint16Array        Uint16         2              16-bit unsigned integer                unsigned short
  Int32Array         Int32          4              32-bit 2’s complement signed integer   Int
  Uint32Array        Uint32         4              32-bit unsigned integer                unsigned int
  Float32Array       Float32        4              32-bit IEEE floating point             Float
  Float64Array       Float64        8              64-bit IEEE floating point             Double

In the definitions below, references to TypeArray should be replaced
with the appropriate constructor name from the above table. The phrase
“the element size in bytes” refers to the value in the Element Size
column of the table in the row corresponding to the constructor. The
phrase “element Type” refers to the value in the Element Type column for
that row.

When a TypeArray constructor is called as a function rather than as a
constructor, it creates and initialises a new object. A call of the
constructor as a function is equivalent to calling it as a constructor
with the same arguments.

When a TypeArray constructor is called as part of a new expression, it
is a constructor: it initialises the newly created object.

The [[Prototype]] internal property of the newly constructed object is
set to the original TypeArray prototype object, the one that is the
initial value of TypeArray.prototype (16.2.3.1). The [[Class]]
internal property of the newly constructed object is set to “TypeArray”.
The [[Extensible]] internal property of the newly constructed object is
set to true.

The remaining properties of the newly constructed object are set as
follows:

1.  If Type(arg0) is Number, then

    a.  Let length be ToUInt32(arg0).

    b.  ReturnIfAbrupt(length).

    c.  The length property of the newly constructed object is set to
        length.

    d.  The byteLength property of the newly constructed object is set
        to length multiplied by the element size in bytes.

    e.  Let arrayBuffer be an object constructed as if by a call to the
        built-in ArrayBuffer constructor, as “new
        ArrayBuffer(byteLength)”.

    f.  The buffer property of the newly constructed object is set to
        arrayBuffer.

    g.  The byteOffset property of the newly constructed object is set
        to 0.

2.  Else,

    a.  Let O be the result of calling ToObject(arg0).

    b.  ReturnIfAbrupt(O).

    c.  Let class be the value of the [[Class]] internal property of
        O.

    d.  If class is “ArrayBuffer”, then

        i.  Let byteOffset be the result of calling ToUInt32 on arg1,
            if provided, or else 0.

        ii. If byteOffset is not an integer multiple of the element
            size in bytes, throw a RangeError exception.

        iii. Let bufferLength be the result of calling [[Get]] on O
            with property name “byteLength”.

        iv. Let byteLength be the result of calling ToUInt32 on arg2,
            if provided, or else bufferLength – byteOffset.

        v.  If byteOffset + byteLength is greater than
            bufferLength, throw a RangeError exception.

        vi. Let length be the result of dividing byteLength by the
            element size in bytes.

        vii. If ToUInt32(length) ≠ length, throw a RangeError
            exception.

        viii. The length property of the newly constructed object is set
            to length.

        ix. The byteLength property of the newly constructed object is
            set to byteLength.

        x.  The buffer property of the newly constructed object is set
            to O.

        xi. The byteOffset property of the newly constructed object is
            set to byteOffset.

    e.  Else,

        i.  Let n to be the result of calling [[Get]] on V with
            property name “length”.

        ii. Let length be the result of calling ToUInt32(n).

        iii. The length property of the newly constructed object is set
            to length.

        iv. The byteLength property of the newly constructed object is
            set to length multiplied by the element size in bytes.

        v.  Let arrayBuffer be an object constructed as if by a call
            to the built-in ArrayBuffer constructor, as “new
            ArrayBuffer(byteLength)”.

        vi. Let i to be 0.

        vii. While i < length:

            1.  Let x be the result of calling [[Get]] on
                arrayBuffer with property name ToString(i).

            2.  Let indexDesc be Property Descriptor {[[Value]]:
                x,[[Writable]]: TRUE, [[Enumerable]]: TRUE,
                [[Configurable]]: FALSE}.

            3.  Call [[DefineOwnProperty]] on the newly constructed
                object with arguments ToString(i), indexDesc, and
                FALSE.

            4.  Set i to i + 1.

        viii. The buffer property of the newly constructed object is set
            to arrayBuffer.

        ix. The byteOffset property of the newly constructed object is
            set to 0.

The value of the [[Prototype]] internal property of each TypeArray
constructor is the Function prototype object (15.3.4).

Besides the internal properties and the length property (whose value is
3), each TypeArray constructor has the following properties:

The initial value of TypeArray.prototype is the TypeArray prototype
object (15.13.2.4).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

The initial value of TypeArray_.BYTES_PERELEMENT is the element size
in bytes.

This property has the attributes { [[Writable]]: false, [[Enumerable]]:
false, [[Configurable]]: false }.

The value of the [[Prototype]] internal property of each TypeArray
prototype object is the standard built-in Object prototype object
(15.2.4). It’s [[Class]] is “TypeArray”.

The initial value of TypeArray.prototype.constructor is the standard
built-in TypeArray constructor.

Set multiple values in the TypedArray, reading from the array
input., reading input values from the array. The optional offset value
indicates the index in the current array where values are written. If
omitted, it is assumed to be 0.

1.  If this does not have class “TypeArray”, throw a TYPEERROR
    exception.

2.  Let offsetIndex be ToUInt32(offset)

3.  Let O be the result of calling ToObject(array).

4.  Let srcLength be the result of calling [[Get]] on O with property
    name “length”.

5.  Let targetLength be the result of calling [[Get]] on this with
    property name “length”

6.  If srcLength + offset > targetLength, throw a RANGEERROR exception.

7.  Let temp be a new TypeArray created as if by a call to “new
    TypeArray(srcLength)”

8.  Let k be 0

9.  While k < srcLength

    a.  Let v be the result of calling [[Get]] on src with property name
        toString(k)

    b.  Call [[Put]] on temp with arguments ToString(k), v, and false

10. Let k be offset

11. While k < targetLength

    a.  Let v be the result of calling [[Get]] on temp with property
        name ToString(k-offset)

    b.  Call [[Put]] on temp with arguments ToString(k), v, and false

Returns a new TypedArray view of the ArrayBuffer store for this
TypedArray, referencing the elements at begin, inclusive, up to end,
exclusive. If either begin or end is negative, it refers to an index
from the end of the array, as opposed to from the beginning.

1.  If this does not have class “TypeArray”, throw a TYPEERROR
    exception.

2.  Let srcLength be the result of calling [[Get]] on this with property
    name “length”

3.  Let beginInt be ToInt32(begin)

4.  If beginInt < 0, let beginInt be srcLength + beginInt

5.  Let beginIndex be min(srcLength, max(0, beginInt))

6.  Let endInt be ToInt32(end) if end was provided, else srcLength.

7.  If endInt <0, let endInt be srcLength + endInt

8.  Let endIndex be max(0,min(srcLength, endInt))

9.  If endIndex < beginIndex, let endIndex be beginIndex

10. Return a new TypeArray with the following values for it’s
    properties:

-   The length property of the newly constructed object is set to
    endIndex - beginIndex

-   The byteLength property of the newly constructed object is set to
    length multiplied by the size in bytes of Type.

-   The buffer property of the newly constructed object is set to
    this.buffer.

-   The byteOffset property of the newly constructed object is set to
    this.offset + beginIndex.

TypeArray instances inherit properties from the TypeArray prototype
object and their [[Class]] internal property value is “TypeArray”.
TypeArray instances also have the following properties.

TypeArray objects use a variation of the [[DefineOwnProperty]] internal
method used for other native ECMAScript objects (8.12.9).

When the [[DefineOwnProperty]] internal method of A is called with
property P, Property Descriptor Desc and Boolean flag Throw, the
following steps are taken:

1.  Let succeeded be the result of calling the default
    [[DefineOwnProperty]] internal method (8.12.9) on A passing P, Desc,
    and Throw as arguments.

2.  If succeeded is false, return false.

3.  If Desc contains a Value field, let newValue be Desc.Value

4.  Let convertedValue to ToType(newValue)

5.  Let index be ToUInt32(P)

6.  Call the SetValueInBuffer internal operation with arguments
    A.buffer.[[NativeBuffer]], A.byteOffset, index, convertedValue, and
    Type.

7.  Return true.

The internal operation SetValueInBuffer takes five parameters, a native
buffer nativeBuffer, an integer byteOffset, an integer index, a value of
type Type newValue, and a Type valueType. It operates as follows:

1.  Let size be the size in bytes of the type valueType.

2.  Let bytes be the array of bytes from nativeBuffer between offset
    byteOffset+(index*size) and offset byteOffset+( (index+1)*size)-1
    inclusive.

3.  Let newValueBytes be the result of converting newValue to an array
    of bytes, using the platform endianness.

4.  Set each byte of bytes from the corresponding byte of newValueBytes.

TypeArray objects use a variation of the [[GetOwnProperty]] internal
method used for other native ECMAScript objects (8.12.1). This special
internal method provides access to named properties corresponding to the
individual index values of the TypeArray objects.

When the [[GetOwnProperty]] internal method of A is called with property
name P, the following steps are taken:

1.  Let desc be the result of calling the default [[GetOwnProperty]]
    internal method (8.12.1) on A with argument P.

2.  If desc is not undefined return desc.

3.  If ToString(abs(ToInteger(P) ) ) is not the same value as P, return
    undefined.

4.  Let length be the result of calling [[Get]] on A with parameter
    “length”

5.  Let index be ToInteger(P).

6.  If length ≤ index, return undefined.

7.  Let isLittleEndian be true if the platform endianness is little
    endian, else false.

8.  Let value be the result of calling the GetValueFromBuffer internal
    operation with arguments A.buffer.[[NativeBuffer]], A.byteOffset,
    index, Type, and isLittleEndian.

9.  Return a Property Descriptor { [[Value]]: value, [[Enumerable]]:
    true, [[Writable]]: true, [[Configurable]]: false }

The internal operation GetValueFromBuffer takes three parameters, a
native buffer nativeBuffer, an integer byteOffset, an integer index, a
Type valueType, and a boolean isLittleEndian. It operates as follows:

1.  Let size be the size in bytes of the type valueType.

2.  Let bytes be the array of bytes from nativeBuffer between offset
    byteOffset+(index*size) and offset byteOffset+( (index+1)*size)-1
    inclusive.

3.  Let rawValue be the result of convert the array bytes to a value of
    type valueType, using little endian if isLittleEndian is true,
    otherwise big endian.

4.  If valueType is Float32 and rawValue is a Float32 representation of
    IEEE754 NaN, return the NaN Number value.

5.  Else, if valueType is Float64 and rawValue is a Float64
    representation of IEEE754 NaN, return the NaN Number value.

6.  Else, return the Number value that that represents the same numeric
    value as rawValue

The value of the length property is the length of the TypeArray
object, which was fixed at creation. This property has attributes {
[[Writable]]: false, [[Enumerable]]: false, [[Configurable]]:false }.

The value of the byteLength property is the length of the TypeArray
object, which was fixed at creation. This property has attributes {
[[Writable]]: false, [[Enumerable]]: false, [[Configurable]]:false }.

The value of the buffer property is the length of the TypeArray
object, which was fixed at creation. This property has attributes {
[[Writable]]: false, [[Enumerable]]: false, [[Configurable]]:false }.

The value of the byteOffset property is the length of the TypeArray
object, which was fixed at creation. This property has attributes {
[[Writable]]: false, [[Enumerable]]: false, [[Configurable]]:false }.

When DataView is called as a function rather than as a constructor, it
creates and initialises a new DataView object. Thus the function call
DataView(…) is equivalent to the object creation expression new
DataView(…) with the same arguments.

When DataView is called as part of a new expression, it is a
constructor: it initialises the newly created object.

The [[Prototype]] internal property of the newly constructed object is
set to the original DataView prototype object, the one that is the
initial value of DataView.prototype (15.13.3.3.1). The [[Class]]
internal property of the newly constructed object is set to “DataView”.
The [[Extensible]] internal property of the newly constructed object is
set to true.

The remaining properties are set as follows:

1.  Let O be ToObject(buffer)

2.  If the [[Class]] internal property of O is not “ArrayBuffer”, throw
    a TypeError exception.

3.  Let byteOffset be the result of calling ToUInt32 on byteOffset, if
    provided, or else 0.

4.  Let bufferLength be the result of calling [[Get]] on O with property
    name “byteLength”.

5.  Let byteLength be the result of calling ToUInt32 on byteLength, if
    provided, or else bufferLength – byteOffset.

6.  If byteOffset + byteLength is greater than bufferLength, throw a
    RangeError exception.

7.  The byteLength property of the newly constructed object is set to
    byteLength.

8.  The buffer property of the newly constructed object is set to O.

9.  The byteOffset property of the newly constructed object is set to
    byteOffset.

The value of the [[Prototype]] internal property of the DataView
constructor is the Function prototype object (15.3.4).

Besides the internal properties and the length property (whose value is
3), the DataView constructor has the following properties:

The initial value of DataView.prototype is the DataView prototype object
(15.13.3.4).

This property has the attributes { [[Writable]]: false, [[Enumerable]]:
false, [[Configurable]]: false }.

The value of the [[Prototype]] internal property of the DataView
prototype object is the standard built-in Object prototype object
(15.2.4). The [[Class]] internal property of the newly constructed
object is set to “Object”. The [[Extensible]] internal property of the
newly constructed object is set to true.

The abstract operation GetValue(byteOffset, isLittleEndian, type) used
by functions on DataView instances is defined as follows:

1.  Let byteOffsetInt be ToUInt32(byteOffset)

2.  Let totalOffset be byteOffsetInt plus the result of calling [[Get]]
    on this with parameter “byteOffset”

3.  Let byteLength be the result of calling [[Get]] on this with
    parameter “byteLength”

4.  If totalOffset ≥ byteLength, throw a RangeError exception.

5.  Let value be the result of calling the GetValueFromBuffer internal
    operation (2.5.2) with arguments this.buffer.[[NativeBuffer]],
    totalOffset, 0 and type.

6.  Return value

The internal operation SetValue(byteOffset, isLittleEndian, type, value)
used by functions on DataView instances is defined as follows:

1.  Let byteOffsetInt be ToUInt32(byteOffset)

2.  Let totalOffset be byteOffsetInt plus the result of calling [[Get]]
    on this with parameter “byteOffset”

3.  Let byteLength be the result of calling [[Get]] on this with
    parameter “byteLength”

4.  If totalOffset ≥ byteLength, throw a RangeError exception.

5.  Let value be the result of calling the SetValueInBuffer internal
    operation (2.5.2) with arguments this.buffer.[[NativeBuffer]],
    totalOffset, 0, value and type.

6.  Return value

The initial value of DataView.prototype.constructor is the standard
built-in DataView constructor.

Gets the Int8 value at offset byteOffset in the DataView.

1.  Let O be ToObject(this)

2.  If the [[Class]] internal property of O is not “DataView”, throw a
    TypeError exception.

3.  Return GetValue(byteOffset, true, Int8)

Gets the UInt8 value at offset byteOffset in the DataView.

1.  Let O be ToObject(this)

2.  If the [[Class]] internal property of O is not “DataView”, throw a
    TypeError exception.

3.  Return GetValue(byteOffset, true, UInt8)

Gets the Int16 value at offset byteOffset in the DataView, using the
provided endianness.

1.  Let O be ToObject(this)

2.  Let isLittleEndian be ToBoolean(littleEndian) if provided, else
    false

3.  If the [[Class]] internal property of O is not “DataView”, throw a
    TypeError exception.

4.  Return GetValue(byteOffset, isLittleEndian, Int16)

Gets the Uint16 value at offset byteOffset in the DataView, using the
provided endianness.

1.  Let O be ToObject(this)

2.  Let isLittleEndian be ToBoolean(littleEndian) if provided, else
    false

3.  If the [[Class]] internal property of O is not “DataView”, throw a
    TypeError exception.

4.  Return GetValue(byteOffset, isLittleEndian, Uint16)

Gets the Int32 value at offset byteOffset in the DataView, using the
provided endianness.

1.  Let O be ToObject(this)

2.  Let isLittleEndian be ToBoolean(littleEndian) if provided, else
    false

3.  If the [[Class]] internal property of O is not “DataView”, throw a
    TypeError exception.

4.  Return GetValue(byteOffset, isLittleEndian, Int32)

Gets the Uint32 value at offset byteOffset in the DataView, using the
provided endianness.

1.  Let O be ToObject(this)

2.  Let isLittleEndian be ToBoolean(littleEndian) if provided, else
    false

3.  If the [[Class]] internal property of O is not “DataView”, throw a
    TypeError exception.

4.  Return GetValue(byteOffset, isLittleEndian, Uint32)

Gets the Float32 value at offset byteOffset in the DataView, using the
provided endianness.

1.  Let O be ToObject(this)

2.  Let isLittleEndian be ToBoolean(littleEndian) if provided, else
    false

3.  If the [[Class]] internal property of O is not “DataView”, throw a
    TypeError exception.

4.  Return GetValue(byteOffset, isLittleEndian, Float32)

Gets the Float64 value at offset byteOffset in the DataView, using the
provided endianness.

1.  Let O be ToObject(this)

2.  Let isLittleEndian be ToBoolean(littleEndian) if provided, else
    false

3.  If the [[Class]] internal property of O is not “DataView”, throw a
    TypeError exception.

4.  Return GetValue(byteOffset, isLittleEndian, Float64)

Sets the Int8 value at offset byteOffset in the DataView.

1.  Let O be ToObject(this)

2.  If the [[Class]] internal property of O is not “DataView”, throw a
    TypeError exception.

3.  Return SetValue(byteOffset, true, Int8, ToInt8(value) )

Sets the Uint8 value at offset byteOffset in the DataView.

1.  Let O be ToObject(this)

2.  If the [[Class]] internal property of O is not “DataView”, throw a
    TypeError exception.

3.  Return SetValue(byteOffset, true, Uint8, ToUint8(value) )

Sets the Int16 value at offset byteOffset in the DataView.

1.  Let O be ToObject(this)

2.  Let isLittleEndian be ToBoolean(littleEndian) if provided, else
    false

3.  If the [[Class]] internal property of O is not “DataView”, throw a
    TypeError exception.

4.  Return SetValue(byteOffset, isLittleEndian, Int16, ToInt16(value))

Sets the Uint16 value at offset byteOffset in the DataView.

1.  Let O be ToObject(this)

2.  Let isLittleEndian be ToBoolean(littleEndian) if provided, else
    false

3.  If the [[Class]] internal property of O is not “DataView”, throw a
    TypeError exception.

4.  Return SetValue(byteOffset, isLittleEndian, Uint16, ToUint16(value))

Sets the Int32 value at offset byteOffset in the DataView.

1.  Let O be ToObject(this)

2.  Let isLittleEndian be ToBoolean(littleEndian) if provided, else
    false

3.  If the [[Class]] internal property of O is not “DataView”, throw a
    TypeError exception.

4.  Return SetValue(byteOffset, isLittleEndian, Int32, ToInt32(value))

Sets the Uint32 value at offset byteOffset in the DataView.

1.  Let O be ToObject(this)

2.  Let isLittleEndian be ToBoolean(littleEndian) if provided, else
    false

3.  If the [[Class]] internal property of O is not “DataView”, throw a
    TypeError exception.

4.  Return GetValue(byteOffset, isLittleEndian, Uint32, ToUint32(value))

Sets the Float32 value at offset byteOffset in the DataView.

1.  Let O be ToObject(this)

2.  Let isLittleEndian be ToBoolean(littleEndian) if provided, else
    false

3.  If the [[Class]] internal property of O is not “DataView”, throw a
    TypeError exception.

4.  Return SetValue(byteOffset, isLittleEndian, Float32,
    ToFloat32(value))

Sets the Float64 value at offset byteOffset in the DataView.

1.  Let O be ToObject(this)

2.  Let isLittleEndian be ToBoolean(littleEndian) if provided, else
    false

3.  If the [[Class]] internal property of O is not “DataView”, throw a
    TypeError exception.

4.  Return SetValue(byteOffset, isLittleEndian, Float64,
    ToFloat64(value))

DataView instances inherit properties from the DataView prototype object
and their [[Class]] internal property value is “DataView”. DataView
instances also have the following properties.

The value of the byteLength property is the length of the DataView
object, which was fixed at creation. This property has attributes {
[[Writable]]: false, [[Enumerable]]: false, [[Configurable]]:false }.

The value of the buffer property is the length of the DataView object,
which was fixed at creation. This property has attributes {
[[Writable]]: false, [[Enumerable]]: false, [[Configurable]]:false }.

The value of the byteOffset property is the length of the DataView
object, which was fixed at creation. This property has attributes {
[[Writable]]: false, [[Enumerable]]: false, [[Configurable]]:false }.

Map objects are collections of key/value pairs where both the keys and
values may be arbitrary ECMAScript values. A Map object can also iterate
its elements in insertion order. Map object must be implemented using
hash tables or other mechanisms that, on average, provide access times
that are sublinear on the number of elements in the collection. The data
structures used in this Map objects specification is only intended to
describe the required observable semantics of Map objects. It is not
intended to be a viable implementation model.

The abstract operation MapInitialisation with arguments obj and
iterable is used to initialize an object as a map. It performs the
following steps:

1.  If Type(obj) is not Object, throw a TYPEERROR exception.

2.  If obj already has a [[MapData]] internal property, throw a
    TYPEERROR exception.

3.  If the [[Extensible]] internal property of obj is FALSE, throw a
    TypeError exception.

4.  If iterable is not UNDEFINED, then

    a.  Let iterable be ToObject(iterable).

    b.  ReturnIfAbrupt(iterable)

    c.  Let iterator be the intrinsic symbol @@iterator.

    d.  Let itr be the result of calling the Invoke abstraction
        operation with iterator, obj, and an empty List as
        arguments.

    e.  ReturnIfAbrupt(itr).

    f.  Let adder be the result of calling the [[Get]] internal method
        of obj with argument "SET".

    g.  ReturnIfAbrupt(adder).

    h.  If IsCallable(adder) is FALSE, throw a TYPEERROR Exception.

5.  Add a [[MapData]] internal property to obj.

6.  Set obj’s [[MapData]] internal property to a new empty List.

7.  If iterable is UNDEFINED, return obj.

8.  Repeat

    a.  Let next be the result of performing Invoke with arguments
        "NEXT", itr, and an empty arguments List.

    b.  If IteratorComplete(next) is TRUE, then return
        NormalCompletion(obj).

    c.  Let next be ToObject(next).

    d.  ReturnIfAbrupt(next).

    e.  Let k be the result of calling the [[Get]] internal method of
        next with argument "0".

    f.  ReturnIfAbrupt(k).

    g.  Let v be the result of calling the [[Get]] internal method of
        next with argument "1".

    h.  ReturnIfAbrupt(v).

    i.  Let status be the result of calling the [[Call]] internal
        method of adder with obj as thisArgument and a List whose
        elements are k and v as argumentsList.

    j.  ReturnIfAbrupt(status).

When MAP is called as a function rather than as a constructor, it
initializes its THIS value with the internal state necessary to support
the MAP.PROTOTYPE internal methods. This premits super invocation of the
MAP constructor by MAP subclasses.

1.  Let m be the THIS value.

2.  If m is UNDEFINED or the intrinsic %MapPrototype%

    a.  Let map be the result of the abstract operation ObjectCreate
        (15.2) with the intrinsic %MapPrototype% as the argument.

3.  Else

    a.  Let map be the result of ToObject(m).

4.  ReturnIfAbrupt(map).

5.  If iterable is not present, let iterable be UNDEFINED.

6.  Let status be the result of MapInitialisation with map and
    iterable as arguments.

7.  ReturnIfAbrupt(status).

8.  Return map.

NOTE If the parameter iterable is present, it is expected to be an
object that implements an @@iterator method that returns an iterator
object that produces two element array-like objects whose first element
is a value that will be used as an Map key and whose second element is
the value to associate with that key.

When MAP is called as part of a NEW expression it is a constructor: it
initialises the newly created object.

1.  Let map be the result of the abstract operation ObjectCreate
    (15.2) with the intrinsic %MapPrototype% as the argument.

2.  If iterable is not present, let iterable be UNDEFINED.

3.  Let status be the result of MapInitialisation with map and
    iterable as arguments.

4.  ReturnIfAbrupt(status).

5.  Return map.

NOTE If the parameter iterable is present, it is expected to be an
object that implements an @@iterator method that returns an iterator
object that produces two element array-like objects whose first element
is a value that will be used as an Map key and whose second element is
the value to associate with that key.

The value of the [[Prototype]] internal property of the Map constructor
is the Function prototype object (15.3.4).

Besides the internal properties and the LENGTH property (whose value is
0), the Map constructor has the following property:

The initial value of MAP.PROTOTYPE is the Map prototype object
(15.14.4).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

The value of the [[Prototype]] internal property of the Map prototype
object is the standard built-in Object prototype object (15.2.4).

The initial value of MAP.PROTOTYPE.CONSTRUCTOR is the built-in MAP
constructor.

The following steps are taken:

1.  Let M be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(M).

3.  If M does not have a [[MapData]] internal property throw a
    TYPEERROR exception.

4.  Set the value of M’s [[MapData]] internal property to a new empty
    List.

5.  Return UNDEFINED.

The following steps are taken:

1.  Let M be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(M).

3.  If M does not have a [[MapData]] internal property throw a
    TYPEERROR exception.

4.  Let entries be the List that is the value of M’s [[MapData]]
    internal property.

5.  Repeat for each Record {[[key]], [[value]]} p that is an element
    of entries,

    a.  If SameValue(p.[[key]], key), then

        i.  Set p.[[key]] to empty.

        ii. Set p.[[value]] to empty.

        iii. Return TRUE.

6.  Return FALSE.

callbackfn should be a function that accepts three arguments. FOREACH
calls callbackfn once for each key/value pair present in the map
object, in key insertion order. callbackfn is called only for keys of
the map which actually exist; it is not called for keys that have been
deleted from the map.

If a thisArg parameter is provided, it will be used as the THIS value
for each invocation of callbackfn. If it is not provided, UNDEFINED is
used instead.

NOTE If callbackfn is an Arrow Function, THIS was lexically bound when
the function was created so thisArg will have no effect.

callbackfn is called with three arguments: the value of the item, the
key of the item, and the Map object being traversed.

FOREACH does not directly mutate the object on which it is called but
the object may be mutated by the calls to callbackfn.

NOTE Each key is visited only once with the value that is current at the
time of the visit. If the value associated with a key is modified after
it has been visited, it is not re-visited. Keys that are deleted after
the call to FOREACH begins and before being visited are not visited. New
keys added, after the call to FOREACH begins are visited.

When the FOREACH method is called with one or two arguments, the
following steps are taken:

1.  Let M be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(M).

3.  If M does not have a [[MapData]] internal property throw a
    TYPEERROR exception.

4.  If IsCallable(callbackfn) is FALSE, throw a TYPEERROR exception.

5.  If thisArg was supplied, let T be thisArg; else let T be
    UNDEFINED.

6.  Let entries be the List that is the value of M’s [[MapData]]
    internal property.

7.  Repeat for each Record {[[key]], [[value]]} e that is an element
    of entries,in original key insertion order

    a.  If e.[[key]] is not empty, then

        i.  Let funcResult be the result of calling the [[Call]]
            internal method of callbackfn with T as thisArgument
            and a List containing e.[[value]], e.[[key]], and M
            _as argumentsList_.

        ii. ReturnIfAbrupt(funcResult).

8.  Return UNDEFINED.

The LENGTH property of the FOREACH method is 1.

The following steps are taken:

1.  Let M be the result of calling ToObject with the THIS value the as
    its argument.

2.  ReturnIfAbrupt(M).

3.  If M does not have a [[MapData]] internal property throw a
    TYPEERROR exception.

4.  Let entries be the List that is the value of M’s [[MapData]]
    internal property.

5.  Repeat for each Record {[[key]], [[value]]} p that is an element
    of entries,

    a.  If SameValue(p.[[key]], key), then return p.[[value]]

6.  Return UNDEFINED.

The following steps are taken:

1.  Let M be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(M).

3.  If M does not have a [[MapData]] internal property throw a
    TYPEERROR exception.

4.  Let entries be the List that is the value of M’s [[MapData]]
    internal property.

5.  Repeat for each Record {[[key]], [[value]]} p that is an element
    of entries,

    a.  If SameValue(p.[[key]], key), then return TRUE.

6.  Return FALSE.

The following steps are taken:

1.  Let M be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(M).

3.  Return the result of calling the CreateMapIterator abstract
    operation with arguments M and "KEY+VALUE".

The following steps are taken:

1.  Let M be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(M).

3.  Return the result of calling the CreateMapIterator abstract
    operation with arguments M and "KEY".

The following steps are taken:

1.  Let M be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(M).

3.  If M does not have a [[MapData]] internal property throw a
    TYPEERROR exception.

4.  Let entries be the List that is the value of M’s [[MapData]]
    internal property.

5.  Repeat for each Record {[[key]], [[value]]} p that is an element
    of entries,

    a.  If SameValue(p.[[key]], key), then

        i.  Set p.[[value]] to value.

        ii. Return UNDEFINED.

6.  Let p be the Record {[[key]]: key, [[value]]: value}

7.  Append p as the last element of entries.

8.  Return UNDEFINED.

Map.prototype.size is an accessor property whose set accessor function
is UNDEFINED. Its get accessor function performs the following steps are
taken:

1.  Let M be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(M).

3.  If M does not have a [[MapData]] internal property throw a
    TYPEERROR exception.

4.  Let entries be the List that is the value of M’s [[MapData]]
    internal property.

5.  Let count be 0.

6.  For each Record {[[key]], [[value]]} p that is an element of
    entries

    a.  If p.[[key]] is not empty then

        i.  Set count to count+1.

7.  Return count.

The following steps are taken:

1.  Let M be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(M).

3.  Return the result of calling the CreateMapIterator abstract
    operation with arguments M and "VALUE".

The initial value of the @@iterator property is the same function object
as the initial value of the ITEMS property.

The initial value of the @@toStringTag property is the string value
"MAP".

Map instances inherit properties from the Map prototype. After
initialisation by the Map constructor, Map instances also have a
[[MapData]] internal property.

A Map Iterator is an object, with the structure defined below, that
represent a specific iteration over some specific Map instance object.
There is not a named constructor for Map Iterator objects. Instead, map
iterator objects are created by calling certain methods of Map instance
objects.

Several methods of Map objects return interator objects. The abstract
operation CreateMapIterator with arguments map and kind is used to
create and such iterator objects. It performs the following steps:

1.  Let M be the result of calling ToObject(map).

2.  ReturnIfAbrupt(M).

3.  If M does not have a [[MapData]] internal property throw a
    TYPEERROR exception.

4.  Let entries be the List that is the value of M’s [[MapData]]
    internal property.

5.  Let itr be the result of the abstract operation ObjectCreate with
    the intrinsic object %MapIteratorPrototype% as its argument.

6.  Add a [[Map]] internal property to itr with value M.

7.  Add a [[MapNextIndex]] internal property to itr with value 0.

8.  Add a [[MapIterationKind]] internal property of itr with value
    kind.

9.  Return itr.

All Map Iterator Objects inherit properties from a common Map Iterator
Prototype object. The [[Prototype]] internal property of the Map
Iterator Prototype is the %ObjectPrototype% intrinsic object. In
addition, the Map Iterator Prototype as the following properties:

1.  Let O be the THIS value.

2.  If Type(O) is not Object, throw a TYPEERROR exception.

3.  If O does not have all of the internal properties of a Map
    Iterator Instance (15.14.7.1.2), throw a TYPEERROR exception.

4.  Let m be the value of the [[Map]] internal property of O.

5.  Let index be the value of the [[MapNextIndex]] internal property
    of O.

6.  Let itemKind be the value of the [[MapIterationKind]] internal
    property of O.

7.  Assert: m has a [[MapData]] internal property.

8.  Let entries be the List that is the value of the [[MapData]]
    internal property of m.

9.  Repeat while index is less than the total number of element of
    entries. The number of elements must be redetermined each time
    this method is evaluated.

    a.  Let e be the Record {[[key]], [[value]]} at 0-origined
        insertion position index of entries.

    b.  Set index to index+1;

    c.  Set the [[MapNextIndex]] internal property of O to index.

    d.  If e.[[key]] is not empty, then

        i.  If itemKind is "KEY" then, let result be e.[[key]].

        ii. Else if itemKind is "VALUE" then, let result be
            e.[[value]].

        iii. Else,

            1.  Assert: itemKind is "KEY+VALUE".

            2.  Let result be the result of the abstract operation
                ArrayCreate with argument 2.

            3.  Assert: result is a new, well-formed Array object so
                the following operations will never fail.

            4.  Call the [[DefineOwnProperty]] internal method of
                result with arguments "0", Property Descriptor
                {[[Value]]: e.[[key]], [[Writable]]: TRUE,
                [[Enumerable]]: TRUE, [[Configurable]]: TRUE}, and
                FALSE.

            5.  Call the [[DefineOwnProperty]] internal method of
                result with arguments "1", Property Descriptor
                {[[Value]]: e.[[value]], [[Writable]]: TRUE,
                [[Enumerable]]: TRUE, [[Configurable]]: TRUE}, and
                FALSE.

        iv. Return result.

10. Return Completion {[[type]]: throw, [[value]]: %StopIteration%,
    [[target]]: empty}.

The following steps are taken:

1.  Return the THIS value.

The initial value of the @@toStringTag property is the string value "MAP
ITERATOR".

Map Iterator instances inherit properties from the Map Iterator
prototype (the intrinsic, %MapIteratorPrototype%.) Map Iterator
instances are initially created with the following internal properties.

Table 32 — Internal Properties of Map Iterator Instances

  ------------------------ ------------------------------------------------------------------------------------------------------------------------------------------------
  INTERNAL PROPERTY NAME   DESCRIPTION
  [[Map]]                  The Map object that is being iterated.
  [[MapNextIndex]]         The integer index of the next Map data element to be examined by this iteration.
  [[MapIterationKind]]     A string value that identifies what is to be returned for each element of the iteration. The possible values are: "KEY", "VALUE", "KEY+VALUE".
  ------------------------ ------------------------------------------------------------------------------------------------------------------------------------------------

WeakMap objects are collections of key/value pairs where the keys are
ECMAScript objects and values may be arbitrary ECMAScript values. A
WeakMap may be querried to see if it contains an key/value pair with a
specifiec key, but no mechansims is provided for enumerating the objects
it holds as keys. If an object that is being used as the key of a
WeakMap key/value pair is only reachable by following a chain of
references that starts with that WeakMap, then that key/value pair is
inaccessible and is automatically removed from the WeakMap. WeakMap
implementations should make detect and remove such key/value pairs and
any associate resources.

WeakMap objects must be implemented using hash tables or other
mechanisms that, on average, provide access times that are sublinear on
the number of key/value pairs in the collection. The data structures
used in this WeakMap objects specification are only intended to describe
the required observable semantics of WeakMap objects. It is not intended
to be a viable implementation model.

NOTE WeakMap are intended to provide a mechanism for dynamically
associating state with an object in a manner that does not “leak” memory
resources if the object would other wise become inaccessible and subject
to resource reclaimation by the implementation’s garbage collection.
Achieving this characteristic requires coordination between the WeakMap
implementation and the garbage collections. The following references
describe mechanism that may be useful to implementations of WeakMap:

  Barry Hayes. 1997. Ephemerons: a new finalization mechanism. In
  _Proceedings of the 12th ACM SIGPLAN conference on Object-oriented
  programming, systems, languages, and applications (OOPSLA '97)_, A.
  Michael Berman (Ed.). ACM, New York, NY, USA, 176-183.
  http://doi.acm.org/10.1145/263698.263733

  Alexandra Barros, Roberto Ierusalimschy, Eliminating Cycles in Weak
  Tables. Journal of Universal Computer Science - J.UCS , vol. 14, no.
  21, pp. 3481-3497, 2008.
  http://www.jucs.org/jucs_14_21/eliminating_cycles_in_weak

The abstract operation WeakMapInitialisation with arguments obj and
iterable is used to initialize an object as a map. It performs the
following steps:

1.  If Type(obj) is not Object, throw a TYPEERROR exception.

2.  If obj already has a [[WeakMapData]] internal property, throw a
    TYPEERROR exception.

3.  If the [[Extensible]] internal property of obj is FALSE, throw a
    TypeError exception.

4.  If iterable is not UNDEFINED, then

    a.  Let iterable be ToObject(iterable).

    b.  ReturnIfAbrupt(iterable)

    c.  Let iterator be the intrinsic symbol @@iterator.

    d.  Let itr be the result of calling the Invoke abstraction
        operation with iterator, obj, and an empty List as
        arguments.

    e.  ReturnIfAbrupt(itr).

    f.  Let adder be the result of calling the [[Get]] internal method
        of obj with argument "SET".

    g.  ReturnIfAbrupt(adder).

    h.  If IsCallable(adder) is FALSE, throw a TYPEERROR Exception.

5.  Add a [[WeakMapData]] internal property to obj.

6.  Set obj’s [[WeakMapData]] internal property to a new empty List.

7.  If iterable is UNDEFINED, return obj.

8.  Repeat

    a.  Let next be the result of performing Invoke with arguments
        "NEXT", itr, and an empty arguments List.

    b.  If IteratorComplete(next) is TRUE, then return
        NormalCompletion(obj).

    c.  Let next be ToObject(next).

    d.  ReturnIfAbrupt(next).

    e.  Let k be the result of calling the [[Get]] internal method of
        next with argument "0".

    f.  ReturnIfAbrupt(k).

    g.  Let v be the result of calling the [[Get]] internal method of
        next with argument "1".

    h.  ReturnIfAbrupt(v).

    i.  Let status be the result of calling the [[Call]] internal
        method of adder with obj as thisArgument and a List whose
        elements are k and v as argumentsList.

    j.  ReturnIfAbrupt(status).

When WEAKMAP is called as a function rather than as a constructor, it
initializes its THIS value with the internal state necessary to support
the WEAKMAP.PROTOTYPE internal methods. This premits super invocation of
the WEAKMAP constructor by WEAKMKAP subclasses.

1.  Let m be the THIS value.

2.  If m is UNDEFINED or the intrinsic %WeakMapPrototype%

    a.  Let map be the result of the abstract operation ObjectCreate
        (15.2) with the intrinsic %WeakWeakMapPrototype% as the
        argument.

3.  Else

    a.  Let map be the result of ToObject(m).

4.  ReturnIfAbrupt(map).

5.  If iterable is not present, let iterable be UNDEFINED.

6.  Let status be the result of MapInitialisation with map and
    iterable as arguments.

7.  ReturnIfAbrupt(status).

8.  Return map.

NOTE If the parameter iterable is present, it is expected to be an
object that implements an @@iterator method that returns an iterator
object that produces two element array-like objects whose first element
is a value that will be used as a WeakMap key and whose second element
is the value to associate with that key.

When WEAKMAP is called as part of a NEW expression it is a constructor:
it initialises the newly created object.

1.  Let map be the result of the abstract operation ObjectCreate
    (15.2) with the intrinsic %WeakMapPrototype% as the argument.

2.  If iterable is not present, let iterable be UNDEFINED.

3.  Let status be the result of WeakMapInitialisation with map and
    iterable as arguments.

4.  ReturnIfAbrupt(status).

5.  Return map.

NOTE If the parameter iterable is present, it is expected to be an
object that implements an @@iterator method that returns an iterator
object that produces two element array-like objects whose first element
is a value that will be used as a WeakMap key and whose second element
is the value to associate with that key.

The value of the [[Prototype]] internal property of the WeakMap
constructor is the Function prototype object (15.3.4).

Besides the internal properties and the LENGTH property (whose value is
0), the Map constructor has the following property:

The initial value of WEAKMAP.PROTOTYPE is the WeakMap prototype object
(15.15.4).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

The value of the [[Prototype]] internal property of the WeakMap
prototype object is the standard built-in Object prototype object
(15.2.4).

The initial value of WEAKMAP.PROTOTYPE.CONSTRUCTOR is the built-in
WEAKMAP constructor.

The following steps are taken:

1.  Let M be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(M).

3.  If M does not have a [[WeakMapData]] internal property throw a
    TYPEERROR exception.

4.  Set the value of M’s [[WeakMapData]] internal property to a new
    empty List.

5.  Return UNDEFINED.

The following steps are taken:

1.  Let M be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(M).

3.  If M does not have a [[WeakMapData]] internal property throw a
    TYPEERROR exception.

4.  Let entries be the List that is the value of M’s [[WeakMapData]]
    internal property.

5.  Let k be ToObject(key).

6.  ReturnIfAbrupt(k).

7.  Repeat for each Record {[[key]], [[value]]} p that is an element
    of entries,

    a.  If SameValue(p.[[key]], k), then

        i.  Set p.[[key]] to empty.

        ii. Set p.[[value]] to empty.

        iii. Return TRUE.

8.  Return FALSE.

The following steps are taken:

1.  Let M be the result of calling ToObject with the THIS value the as
    its argument.

2.  ReturnIfAbrupt(M).

3.  If M does not have a [[WeakMapData]] internal property throw a
    TYPEERROR exception.

4.  Let entries be the List that is the value of M’s [[WeakMapData]]
    internal property.

5.  Let k be ToObject(key).

6.  ReturnIfAbrupt(k).

7.  Repeat for each Record {[[key]], [[value]]} p that is an element
    of entries,

    a.  If SameValue(p.[[key]], k), then return p.[[value]]

8.  Return UNDEFINED.

The following steps are taken:

1.  Let M be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(M).

3.  If M does not have a [[WeakMapData]] internal property throw a
    TYPEERROR exception.

4.  Let entries be the List that is the value of M’s [[WeakMapData]]
    internal property.

5.  Let k be ToObject(key).

6.  ReturnIfAbrupt(k).

7.  Repeat for each Record {[[key]], [[value]]} p that is an element
    of entries,

    a.  If SameValue(p.[[key]], k), then return TRUE.

8.  Return FALSE.

The following steps are taken:

1.  Let M be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(M).

3.  If M does not have a [[WeakMapData]] internal property throw a
    TYPEERROR exception.

4.  Let entries be the List that is the value of M’s [[WeakMapData]]
    internal property.

5.  Let k be ToObject(key).

6.  ReturnIfAbrupt(k).

7.  Repeat for each Record {[[key]], [[value]]} p that is an element
    of entries,

    a.  If SameValue(p.[[key]], key), then

        i.  Set p.[[value]] to value.

        ii. Return UNDEFINED.

8.  Let p be the Record {[[key]]: k, [[value]]: value}

9.  Append p as the last element of entries.

10. Return UNDEFINED.

The initial value of the @@toStringTag property is the string value
"WEAKMAP".

WeakMap instances inherit properties from the WeakMap prototype. After
initialisation by the WeakWeakMap constructor, Map instances also have a
[[WeakMapData]] internal property.

Set objects are collections of arbitrary ECMAScript values. Each
distinct value, as determined using the SaveValue algorithm, may only
occur once within a Set. A Set object can also iterate its elements in
insertion order. Set objects must be implemented using hash tables or
other mechanisms that, on average, provide access times that are
sublinear on the number of elements in the collection. The data
structures used in this Set objects specification is only intended to
describe the required observable semantics of Set objects. It is not
intended to be a viable implementation model.

The abstract operation SetInitialisation with arguments obj and
iterable is used to initialize an object as a set instance. It
performs the following steps:

1.  If Type(obj) is not Object, throw a TYPEERROR exception.

2.  If obj already has a [[SetData]] internal property, throw a
    TYPEERROR exception.

3.  If the [[Extensible]] internal property of obj is FALSE, throw a
    TypeError exception.

4.  If iterable is not UNDEFINED, then

    a.  Let iterable be ToObject(iterable).

    b.  ReturnIfAbrupt(iterable)

    c.  Let hasValues be the result of calling the [[HasProperty]]
        internal method of iterable with argument "VALUES"

    d.  If hasValues is TRUE, then

        i.  Let itr be the result of calling the Invoke abstraction
            operation with "VALUES", obj, and an empty List as
            arguments.

    e.  Else,

        i.  Let iterator be the @@iterator symbol.

        ii. Let itr be the result of calling the Invoke abstraction
            operation with iterator, obj, and an empty List as
            arguments.

    f.  ReturnIfAbrupt(itr).

    g.  Let adder be the result of calling the [[Get]] internal method
        of obj with argument "ADD".

    h.  ReturnIfAbrupt(adder).

    i.  If IsCallable(adder) is FALSE, throw a TYPEERROR Exception.

5.  Add a [[SetData]] internal property to obj.

6.  Set obj’s [[SetData]] internal property to a new empty List.

7.  If iterable is UNDEFINED, return obj.

8.  Repeat

    a.  Let next be the result of performing Invoke with arguments
        "NEXT", itr, and an empty arguments List.

    b.  If IteratorComplete(next) is TRUE, then return
        NormalCompletion(obj).

    c.  Let next be ToObject(next).

    d.  ReturnIfAbrupt(next).

    e.  Let status be the result of calling the [[Call]] internal
        method of adder with obj as thisArgument and a List whose
        sole element is v as argumentsList.

    f.  ReturnIfAbrupt(status).

When SET is called as a function rather than as a constructor, it
initializes its THIS value with the internal state necessary to support
the SET.PROTOTYPE internal methods. This premits super invocation of the
SET constructor by SET subclasses.

1.  Let O be the THIS value.

2.  If O is UNDEFINED or the intrinsic %SetPrototype%

    a.  Let set be the result of the abstract operation ObjectCreate
        (15.2) with the intrinsic %SetPrototype% as the argument.

3.  Else

    a.  Let set be the result of ToObject(O).

4.  ReturnIfAbrupt(map).

5.  If iterable is not present, let iterable be UNDEFINED.

6.  Let status be the result of SetInitialisation with set and
    iterable as arguments.

7.  ReturnIfAbrupt(status).

8.  Return set.

NOTE If the parameter iterable is present, it is expected to be an
object that implements an @@iterator method that returns an iterator
object that produces two element array-like objects whose first element
is a value that will be used as an Map key and whose second element is
the value to associate with that key.

When SET is called as part of a NEW expression it is a constructor: it
initialises the newly created object.

1.  Let set be the result of the abstract operation ObjectCreate
    (15.2) with the intrinsic %SetPrototype% as the argument.

2.  If iterable is not present, let iterable be UNDEFINED.

3.  Let status be the result of SetInitialisation with set and
    iterable as arguments.

4.  ReturnIfAbrupt(status).

5.  Return set.

NOTE If the parameter iterable is present, it is expected to be an
object that implements either a VALUES method or an @@iterator method.
Either method is expected to return an interator object that returns the
values that will be the initial elements of the set.

The value of the [[Prototype]] internal property of the Set constructor
is the Function prototype object (15.3.4).

Besides the internal properties and the LENGTH property (whose value is
0), the Set constructor has the following property:

The initial value of SET.PROTOTYPE is the intrinsic %SetPrototype%
object (15.16.4).

This property has the attributes { [[Writable]]: FALSE, [[Enumerable]]:
FALSE, [[Configurable]]: FALSE }.

The value of the [[Prototype]] internal property of the Set prototype
object is the standard built-in Object prototype object (15.2.4).

The initial value of SET.PROTOTYPE.CONSTRUCTOR is the built-in SET
constructor.

The following steps are taken:

1.  Let S be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(S).

3.  If S does not have a [[SetData]] internal property throw a
    TYPEERROR exception.

4.  Let entries be the List that is the value of S’s [[SetData]]
    internal property.

5.  Repeat for each p that is an element of entries,

    a.  If p is not empty and SameValue(p, value) is TRUE, then

        i.  Return UNDEFINED.

6.  Append p as the last element of entries.

7.  Return UNDEFINED.

The following steps are taken:

1.  Let S be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(S).

3.  If S does not have a [[SetData]] internal property throw a
    TYPEERROR exception.

4.  Set the value of S’s [[SetData]] internal property to a new empty
    List.

5.  Return UNDEFINED.

The following steps are taken:

1.  Let S be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(S).

3.  If S does not have a [[SetData]] internal property throw a
    TYPEERROR exception.

4.  Let entries be the List that is the value of S’s [[SetData]]
    internal property.

5.  Repeat for each e that is an element of entries, in original
    insertion order

    a.  If e is not empty and SameValue(e, value) is TRUE, then

        i.  Replace the element of entries whose value is e with an
            element whose value is empty.

        ii. Return TRUE.

6.  Return FALSE.

callbackfn should be a function that accepts two arguments. FOREACH
calls callbackfn once for each value present in the set object, in
value insertion order. callbackfn is called only for values of the map
which actually exist; it is not called for keys that have been deleted
from the set.

If a thisArg parameter is provided, it will be used as the THIS value
for each invocation of callbackfn. If it is not provided, UNDEFINED is
used instead.

NOTE If callbackfn is an Arrow Function, THIS was lexically bound when
the function was created so thisArg will have no effect.

callbackfn is called with two arguments: the value of the item and the
Set object being traversed.

FOREACH does not directly mutate the object on which it is called but
the object may be mutated by the calls to callbackfn.

NOTE Each value is normally visited only once. However, if a value will
be revisited if it is deleted after it has been visited and then
re-added before the to FOREACH call completes. Values that are deleted
after the call to FOREACH begins and before being visited are not
visited unless the value is added again before the to FOREACH call
completes. New values added, after the call to FOREACH begins are
visited.

When the FOREACH method is called with one or two arguments, the
following steps are taken:

1.  Let S be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(S).

3.  If S does not have a [[SetData]] internal property throw a
    TYPEERROR exception.

4.  If IsCallable(callbackfn) is FALSE, throw a TYPEERROR exception.

5.  If thisArg was supplied, let T be thisArg; else let T be
    UNDEFINED.

6.  Let entries be the List that is the value of S’s [[SetData]]
    internal property.

7.  Repeat for each e that is an element of entries,in original
    insertion order

    a.  If e is not empty, then

        i.  Let funcResult be the result of calling the [[Call]]
            internal method of callbackfn with T as thisArgument
            and a List containing e and S as argumentsList.

        ii. ReturnIfAbrupt(funcResult).

8.  Return UNDEFINED.

The LENGTH property of the FOREACH method is 1.

The following steps are taken:

1.  Let S be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(S).

3.  If S does not have a [[SetData]] internal property throw a
    TYPEERROR exception.

4.  Let entries be the List that is the value of S’s [[SetData]]
    internal property.

5.  Repeat for each e that is an element of entries,

    a.  If e is not empty and SameValue(e, value), then return
        TRUE.

6.  Return FALSE.

SET.PROTOTYPE.SIZE is an accessor property whose set accessor function
is UNDEFINED. Its get accessor function performs the following steps are
taken:

1.  Let S be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(S).

3.  If S does not have a [[SetData]] internal property throw a
    TYPEERROR exception.

4.  Let entries be the List that is the value of S’s [[SetData]]
    internal property.

5.  Let count be 0.

6.  For each e that is an element of entries

    a.  If e is not empty then

        i.  Set count to count+1.

7.  Return count.

The following steps are taken:

1.  Let S be the result of calling ToObject with the THIS value as its
    argument.

2.  ReturnIfAbrupt(S).

3.  Return the result of calling the CreateSetIterator abstract
    operation with argument S.

The initial value of the @@iterator property is the same function object
as the initial value of the VALUES property.

The initial value of the @@toStringTag property is the string value
"SET".

Set instances inherit properties from the Set prototype. After
initialisation by the Set constructor, Set instances also have a
[[SetData]] internal property.

A Set Iterator is an object, with the structure defined below, that
represent a specific iteration over some specific Map instance object.
There is not a named constructor for Set Iterator objects. Instead, set
iterator objects are created by calling certain methods of Set instance
objects.

The VALUE and @@iterator methods of Set objects return interator
objects. The abstract operation CreateSetIterator with argument set is
used to create and such iterator objects. It performs the following
steps:

1.  Let S be the result of calling ToObject(set).

2.  ReturnIfAbrupt(S).

3.  If S does not have a [[SetData]] internal property throw a
    TYPEERROR exception.

4.  Let entries be the List that is the value of S’s [[SetData]]
    internal property.

5.  Let itr be the result of the abstract operation ObjectCreate with
    the intrinsic object %SetIteratorPrototype% as its argument.

6.  Add a [[IteratedSet]] internal property to itr with value S.

7.  Add a [[SetNextIndex]] internal property to itr with value 0.

8.  Return itr.

All Set Iterator Objects inherit properties from a common Set Iterator
Prototype object. The [[Prototype]] internal property of the Set
Iterator Prototype is the %ObjectPrototype% intrinsic object. In
addition, the Set Iterator Prototype as the following properties:

1.  Let O be the THIS value.

2.  If Type(O) is not Object, throw a TYPEERROR exception.

3.  If O does not have all of the internal properties of a Set
    Iterator Instance (15.16.7.1.2), throw a TYPEERROR exception.

4.  Let s be the value of the [[IteratedSet]] internal property of
    O.

5.  Let index be the value of the [[SetNextIndex]] internal property
    of O.

6.  Assert: s has a [[SetData]] internal property.

7.  Let entries be the List that is the value of the [[SetData]]
    internal property of s.

8.  Repeat while index is less than the total number of element of
    entries. The number of elements must be redetermined each time
    this method is evaluated.

    a.  Let e be the element at 0-origined insertion position index
        of entries.

    b.  Set index to index+1;

    c.  Set the [[SetNextIndex]] internal property of O to index.

    d.  If e is not empty, then

        i.  If itemKind is "KEY" then, return e.

9.  Return Completion {[[type]]: throw, [[value]]: %StopIteration%,
    [[target]]: empty}.

The following steps are taken:

1.  Return the THIS value.

The initial value of the @@toStringTag property is the string value "SET
ITERATOR".

Set Iterator instances inherit properties from the Set Iterator
prototype (the intrinsic, %SetIteratorPrototype%.) Set Iterator
instances are initially created with the internal properties specified
in Table 33.

Table 33 — Internal Properties of Set Iterator Instances

  ------------------------ ----------------------------------------------------------------------------------
  INTERNAL PROPERTY NAME   DESCRIPTION
  [[IteratedSet]]          The Set object that is being iterated.
  [[SetNextIndex]]         The integer index of the next Set data element to be examined by this iteration.
  ------------------------ ----------------------------------------------------------------------------------

This is a place holder for the material in
http://wiki.ecmascript.org/doku.php?id=harmony:reflect_api

An implementation must report most errors at the time the relevant
ECMAScript language construct is evaluated. An _early error_ is an error
that can be detected and reported prior to the evaluation of any
construct in the Script containing the error. An implementation must
report early errors in a Script prior to the first evaluation of that
Script. Early errors in EVAL code are reported at the time EVAL is
called but prior to evaluation of any construct within the EVAL code.
All errors that are not early errors are runtime errors.

An implementation must treat any instance of the following kinds of
errors as an early error:

-   Any syntax error.

-   Attempts to define an ObjectLiteral that has multiple GET property
    assignments with the same name or multiple SET property assignments
    with the same name.

-   Attempts to define an ObjectLiteral that has both a data property
    assignment and a GET or SET property assignment with the same name.

-   Errors in regular expression literals that are not
    implementation-defined syntax extensions.

-   Attempts in strict mode code to define an ObjectLiteral that has
    multiple data property assignments with the same name.

-   The occurrence of a WithStatement in strict mode code.

-   The occurrence of an Identifier value appearing more than once
    within a FormalParameterList of an individual strict mode
    FunctionDeclaration or FunctionExpression.

-   Improper uses of RETURN, BREAK, and CONTINUE.

-   Attempts to call PutValue on any value for which an early
    determination can be made that the value is not a Reference (for
    example, executing the assignment statement 3=4).

An implementation shall not treat other kinds of errors as early errors
even if the compiler can prove that a construct cannot execute without
error under any circumstances. An implementation may issue an early
warning in such a case, but it should not report the error until the
relevant construct is actually executed.

An implementation shall report all errors as specified, except for the
following:

-   An implementation may extend script syntax and regular expression
      pattern or flag syntax. To permit this, all operations (such as
      calling EVAL, using a regular expression literal, or using the
      FUNCTION or REGEXP constructor) that are allowed to throw
      SYNTAXERROR are permitted to exhibit implementation-defined
      behaviour instead of throwing SYNTAXERROR when they encounter an
      implementation-defined extension to the script syntax or regular
      expression pattern or flag syntax.

-   An implementation may provide additional types, values, objects,
      properties, and functions beyond those described in this
      specification. This may cause constructs (such as looking up a
      variable in the global scope) to have implementation-defined
      behaviour instead of throwing an error (such as REFERENCEERROR).

-   An implementation may define behaviour other than throwing
      RANGEERROR for TOFIXED, TOEXPONENTIAL, and TOPRECISION when the
      fractionDigits or precision argument is outside the specified
      range.

(informative)
Grammar Summary


Lexical Grammar

SourceCharacter :: See clause 6

any Unicode code unit

InputElementDiv :: See clause 7

WhiteSpace
LineTerminator
Comment
Token
DivPunctuator

InputElementRegExp :: See clause 7

WhiteSpace
LineTerminator
Comment
Token
RegularExpressionLiteral

WhiteSpace :: See 7.2

<TAB>
<VT>
<FF>
<SP>
<NBSP>
<BOM>
<USP>

LineTerminator :: See 7.3

<LF>
<CR>
<LS>
<PS>

LineTerminatorSequence :: See 7.3

<LF>
<CR> [lookahead ∉ <LF> ]
<LS>
<PS>
<CR> <LF>

Comment :: See 7.4

MultiLineComment
SingleLineComment

MultiLineComment :: See 7.4

/* MultiLineCommentChars~opt~ */

MultiLineCommentChars :: See 7.4

MultiLineNotAsteriskChar MultiLineCommentChars~opt~
* PostAsteriskCommentChars~opt~

PostAsteriskCommentChars :: See 7.4

MultiLineNotForwardSlashOrAsteriskChar MultiLineCommentChars~opt~
* PostAsteriskCommentChars~opt~

MultiLineNotAsteriskChar :: See 7.4

SourceCharacter BUT NOT *

MultiLineNotForwardSlashOrAsteriskChar :: See 7.4

SourceCharacter BUT NOT ONE OF / OR *

SingleLineComment :: See 7.4

// SingleLineCommentChars~opt~

SingleLineCommentChars :: See 7.4

SingleLineCommentChar SingleLineCommentChars~opt~

SingleLineCommentChar :: See 7.4

SourceCharacter BUT NOT LineTerminator

Token :: See 7.5

IdentifierName
Punctuator
NumericLiteral
StringLiteral

Identifier :: See 7.6

IdentifierName BUT NOT ReservedWord

IdentifierName :: See 7.6

IdentifierStart
IdentifierName IdentifierPart

IdentifierStart :: See 7.6

UnicodeLetter
$
_
\ UnicodeEscapeSequence

IdentifierPart :: See 7.6

IdentifierStart
UnicodeCombiningMark
UnicodeDigit
UnicodeConnectorPunctuation
<ZWNJ>
<ZWJ>

UnicodeLetter :: See 7.6

any character in the Unicode categories “Uppercase letter (Lu)”,
“Lowercase letter (Ll)”, “Titlecase letter (Lt)”, “Modifier letter
(Lm)”, “Other letter (Lo)”, or “Letter number (Nl)”.

UnicodeCombiningMark :: See 7.6

any character in the Unicode categories “Non-spacing mark (Mn)” or
“Combining spacing mark (Mc)”

UnicodeDigit :: See 7.6

any character in the Unicode category “Decimal number (Nd)”

UnicodeConnectorPunctuation :: See 7.6

any character in the Unicode category “Connector punctuation (Pc)”

ReservedWord :: See 7.6.1

Keyword
FutureReservedWord
NullLiteral
BooleanLiteral

Keyword :: ONE OF See 7.6.1.1

  ---------- ---------- ------------ --------
  break      do         instanceof   typeof
  case       else       new          var
  catch      finally    return       void
  continue   for        switch       while
  debugger   function   this         with
  default    if         throw        
  delete     in         try          
  ---------- ---------- ------------ --------

FutureReservedWord :: ONE OF See 7.6.1.2

  ------- -------- --------- -------
  class   enum     extends   super
  const   export   import    
  ------- -------- --------- -------

  The following tokens are also considered to be FutureReservedWords
  when parsing strict mode code (see 10.1.1).

  ------------ --------- ----------- --------
  implements   let       private     public
  interface    package   protected   static
  yield                              
  ------------ --------- ----------- --------

Punctuator :: ONE OF See 7.7

  ----- ------ ----- ----- ----- -----
  {     }      (     )     [     ]
  .     ;      ,     <     >     <=
  >=    ==     !=    ===   !==   
  +     -      *     %     ++    --
  <<    >>     >>>   &     |     ^
  !     ~      &&    ||    ?     :
  =     +=     -=    *=    %=    <<=
  >>=   >>>=   &=    |=    ^=    
  ----- ------ ----- ----- ----- -----

DivPunctuator :: ONE OF See 7.7

  --- ---- -- -- -- --
  /   /=            
  --- ---- -- -- -- --

Literal :: See 7.8

NullLiteral
BooleanLiteral
NumericLiteral
StringLiteral
RegularExpressionLiteral

NullLiteral :: See 7.8.1

NULL

BooleanLiteral :: See 7.8.2

TRUE
FALSE

NumericLiteral :: See 7.8.3

DecimalLiteral
HexIntegerLiteral

DecimalLiteral :: See 7.8.3

DecimalIntegerLiteral . DecimalDigits~opt~ ExponentPart~opt~
. DecimalDigits ExponentPart~opt~
DecimalIntegerLiteral ExponentPart~opt~

DecimalIntegerLiteral :: See 7.8.3

0
NonZeroDigit DecimalDigits~opt~

DecimalDigits :: See 7.8.3

DecimalDigit
DecimalDigits DecimalDigit

DecimalDigit :: ONE OF See 7.8.3

0 1 2 3 4 5 6 7 8 9

NonZeroDigit :: ONE OF See 7.8.3

1 2 3 4 5 6 7 8 9

ExponentPart :: See 7.8.3

ExponentIndicator SignedInteger

ExponentIndicator :: ONE OF See 7.8.3

E E

SignedInteger :: See 7.8.3

DecimalDigits
+ DecimalDigits
- DecimalDigits

HexIntegerLiteral :: See 7.8.3

0X HexDigit
0X HexDigit
HexIntegerLiteral HexDigit

HexDigit :: ONE OF See 7.8.3

0 1 2 3 4 5 6 7 8 9 A B C D E F A B C D E F

StringLiteral :: See 7.8.4

" DoubleStringCharacters~opt~ "
' SingleStringCharacters~opt~ '

DoubleStringCharacters :: See 7.8.4

DoubleStringCharacter DoubleStringCharacters~opt~

SingleStringCharacters :: See 7.8.4

SingleStringCharacter SingleStringCharacters~opt~

DoubleStringCharacter :: See 7.8.4

SourceCharacter BUT NOT ONE OF " OR \ OR LineTerminator
\ EscapeSequence
LineContinuation

SingleStringCharacter :: See 7.8.4

SourceCharacter BUT NOT ONE OF ' OR \ OR LineTerminator
\ EscapeSequence
LineContinuation

LineContinuation :: See 7.8.4

\ LineTerminatorSequence

EscapeSequence :: See 7.8.4

CharacterEscapeSequence
0 [lookahead ∉ DecimalDigit]
HexEscapeSequence
UnicodeEscapeSequence

CharacterEscapeSequence :: See 7.8.4

SingleEscapeCharacter
NonEscapeCharacter

SingleEscapeCharacter :: ONE OF See 7.8.4

' " \ B F N R T V

NonEscapeCharacter :: See 7.8.4

SourceCharacter BUT NOT ONE OF EscapeCharacter OR LineTerminator

EscapeCharacter :: See 7.8.4

SingleEscapeCharacter
DecimalDigit
X
U

HexEscapeSequence :: See 7.8.4

X HexDigit HexDigit

UnicodeEscapeSequence :: See 7.8.4

U HexDigit HexDigit HexDigit HexDigit

RegularExpressionLiteral :: See 7.8.5

/ RegularExpressionBody / RegularExpressionFlags

RegularExpressionBody :: See 7.8.5

RegularExpressionFirstChar RegularExpressionChars

RegularExpressionChars :: See 7.8.5

[empty]
RegularExpressionChars RegularExpressionChar

RegularExpressionFirstChar :: See 7.8.5

RegularExpressionNonTerminator BUT NOT ONE OF * OR \ OR / OR [
RegularExpressionBackslashSequence
RegularExpressionClass

RegularExpressionChar :: See 7.8.5

RegularExpressionNonTerminator BUT NOT \ OR / OR [
RegularExpressionBackslashSequence
RegularExpressionClass

RegularExpressionBackslashSequence :: See 7.8.5

\ RegularExpressionNonTerminator

RegularExpressionNonTerminator :: See 7.8.5

SourceCharacter BUT NOT LineTerminator

RegularExpressionClass :: See 7.8.5

[ RegularExpressionClassChars ]

RegularExpressionClassChars :: See 7.8.5

[empty]
RegularExpressionClassChars RegularExpressionClassChar

RegularExpressionClassChar :: See 7.8.5

RegularExpressionNonTerminator BUT NOT ] OR \
RegularExpressionBackslashSequence

RegularExpressionFlags :: See 7.8.5

[empty]
RegularExpressionFlags IdentifierPart


Number Conversions

StringNumericLiteral ::: See 9.1.3.1

StrWhiteSpace~opt~
StrWhiteSpace~opt~ StrNumericLiteral StrWhiteSpace~opt~

StrWhiteSpace ::: See 9.1.3.1

StrWhiteSpaceChar StrWhiteSpace~opt~

StrWhiteSpaceChar ::: See 9.1.3.1

WhiteSpace
LineTerminator

StrNumericLiteral ::: See 9.1.3.1

StrDecimalLiteral
HexIntegerLiteral

StrDecimalLiteral ::: See 9.1.3.1

StrUnsignedDecimalLiteral
+ StrUnsignedDecimalLiteral
- StrUnsignedDecimalLiteral

StrUnsignedDecimalLiteral ::: See 9.1.3.1

INFINITY
DecimalDigits . DecimalDigits~opt~ ExponentPart~opt~
. DecimalDigits ExponentPart~opt~
DecimalDigits ExponentPart~opt~

DecimalDigits ::: See 9.1.3.1

DecimalDigit
DecimalDigits DecimalDigit

DecimalDigit ::: ONE OF See 9.1.3.1

0 1 2 3 4 5 6 7 8 9

ExponentPart ::: See 9.1.3.1

ExponentIndicator SignedInteger

ExponentIndicator ::: ONE OF See 9.1.3.1

E E

SignedInteger ::: See 9.1.3.1

DecimalDigits
+ DecimalDigits
- DecimalDigits

HexIntegerLiteral ::: See 9.1.3.1

0X HexDigit
0X HexDigit
HexIntegerLiteral HexDigit

HexDigit ::: ONE OF See 9.1.3.1

0 1 2 3 4 5 6 7 8 9 A B C D E F A B C D E F


Expressions

PrimaryExpression : See 11.1

THIS
Identifier
Literal
ArrayLiteral
ObjectLiteral
( Expression )

ArrayLiteral : See 11.1.4

[ Elision~opt~ ]
[ ElementList ]
[ ElementList , Elision~opt~ ]

ElementList : See 11.1.4

Elision~opt~ AssignmentExpression
ElementList , Elision~opt~ AssignmentExpression

Elision : See 11.1.4

,
Elision ,

ObjectLiteral : See 11.1.5

{ }
{ PropertyDefinitionList }
{ PropertyDefinitionList , }

PropertyDefinitionList : See 11.1.5

PropertyDefinition
PropertyDefinitionList , PropertyDefinition

PropertyDefinition : See 11.1.5

PropertyName : AssignmentExpression
GET PropertyName ( ) { FunctionBody }
SET PropertyName ( PropertySetParameterList ) { FunctionBody }

PropertyName : See 11.1.5

IdentifierName
StringLiteral
NumericLiteral

PropertySetParameterList : See 11.1.5

Identifier

MemberExpression : See 11.2

PrimaryExpression
FunctionExpression
MemberExpression [ Expression ]
MemberExpression . IdentifierName
NEW MemberExpression Arguments

NewExpression : See 11.2

MemberExpression
NEW NewExpression

CallExpression : See 11.2

MemberExpression Arguments
CallExpression Arguments
CallExpression [ Expression ]
CallExpression . IdentifierName

Arguments : See 11.2

( )
( ArgumentList )

ArgumentList : See 11.2

AssignmentExpression
ArgumentList , AssignmentExpression

LeftHandSideExpression : See 11.2

NewExpression
CallExpression

PostfixExpression : See 11.3

LeftHandSideExpression
LeftHandSideExpression [no LineTerminator here] ++
LeftHandSideExpression [no LineTerminator here] --

UnaryExpression : See 11.4

PostfixExpression
DELETE UnaryExpression
VOID UnaryExpression
TYPEOF UnaryExpression
++ UnaryExpression
-- UnaryExpression
+ UnaryExpression
- UnaryExpression
~ UnaryExpression
! UnaryExpression

MultiplicativeExpression : See 11.5

UnaryExpression
MultiplicativeExpression * UnaryExpression
MultiplicativeExpression / UnaryExpression
MultiplicativeExpression % UnaryExpression

AdditiveExpression : See 11.6

MultiplicativeExpression
AdditiveExpression + MultiplicativeExpression
AdditiveExpression - MultiplicativeExpression

ShiftExpression : See 11.7

AdditiveExpression
ShiftExpression << AdditiveExpression
ShiftExpression >> AdditiveExpression
ShiftExpression >>> AdditiveExpression

RelationalExpression : See 11.8

ShiftExpression
RelationalExpression < ShiftExpression
RelationalExpression > ShiftExpression
RelationalExpression <= ShiftExpression
RelationalExpression >= ShiftExpression
RelationalExpression INSTANCEOF ShiftExpression
RelationalExpression IN ShiftExpression

RelationalExpressionNoIn : See 11.8

ShiftExpression
RelationalExpressionNoIn < ShiftExpression
RelationalExpressionNoIn > ShiftExpression
RelationalExpressionNoIn <= ShiftExpression
RelationalExpressionNoIn >= ShiftExpression
RelationalExpressionNoIn INSTANCEOF ShiftExpression

EqualityExpression : See 11.9

RelationalExpression
EqualityExpression == RelationalExpression
EqualityExpression != RelationalExpression
EqualityExpression === RelationalExpression
EqualityExpression !== RelationalExpression

EqualityExpressionNoIn : See 11.9

RelationalExpressionNoIn
EqualityExpressionNoIn == RelationalExpressionNoIn
EqualityExpressionNoIn != RelationalExpressionNoIn
EqualityExpressionNoIn === RelationalExpressionNoIn
EqualityExpressionNoIn !== RelationalExpressionNoIn

BitwiseANDExpression : See 11.10

EqualityExpression
BitwiseANDExpression & EqualityExpression

BitwiseANDExpressionNoIn : See 11.10

EqualityExpressionNoIn
BitwiseANDExpressionNoIn & EqualityExpressionNoIn

BitwiseXORExpression : See 11.10

BitwiseANDExpression
BitwiseXORExpression ^ BitwiseANDExpression

BitwiseXORExpressionNoIn : See 11.10

BitwiseANDExpressionNoIn
BitwiseXORExpressionNoIn ^ BitwiseANDExpressionNoIn

BitwiseORExpression : See 11.10

BitwiseXORExpression
BitwiseORExpression | BitwiseXORExpression

BitwiseORExpressionNoIn : See 11.10

BitwiseXORExpressionNoIn
BitwiseORExpressionNoIn | BitwiseXORExpressionNoIn

LogicalANDExpression : See 11.11

BitwiseORExpression
LogicalANDExpression && BitwiseORExpression

LogicalANDExpressionNoIn : See 11.11

BitwiseORExpressionNoIn
LogicalANDExpressionNoIn && BitwiseORExpressionNoIn

LogicalORExpression : See 11.11

LogicalANDExpression
LogicalORExpression || LogicalANDExpression

LogicalORExpressionNoIn : See 11.11

LogicalANDExpressionNoIn
LogicalORExpressionNoIn || LogicalANDExpressionNoIn

ConditionalExpression : See 11.12

LogicalORExpression
LogicalORExpression ? AssignmentExpression : AssignmentExpression

ConditionalExpressionNoIn : See 11.12

LogicalORExpressionNoIn
LogicalORExpressionNoIn ? AssignmentExpression :
AssignmentExpressionNoIn

AssignmentExpression : See 11.13

ConditionalExpression
LeftHandSideExpression = AssignmentExpression
LeftHandSideExpression AssignmentOperator AssignmentExpression

AssignmentExpressionNoIn : See 11.13

ConditionalExpressionNoIn
LeftHandSideExpression = AssignmentExpressionNoIn
LeftHandSideExpression AssignmentOperator AssignmentExpressionNoIn

AssignmentOperator : ONE OF See 11.13

  ---- ---- ---- ---- ---- ----- ----- ------ ---- ---- ----
  *=   /=   %=   +=   -=   <<=   >>=   >>>=   &=   ^=   |=
  ---- ---- ---- ---- ---- ----- ----- ------ ---- ---- ----

Expression : See 11.14

AssignmentExpression
Expression , AssignmentExpression

ExpressionNoIn : See 11.14

AssignmentExpressionNoIn
ExpressionNoIn , AssignmentExpressionNoIn


Statements

Statement : See clause 12

Block
VariableStatement
EmptyStatement
ExpressionStatement
IfStatement
IterationStatement
ContinueStatement
BreakStatement
ReturnStatement
WithStatement
LabelledStatement
SwitchStatement
ThrowStatement
TryStatement
DebuggerStatement

Block : See 12.1

{ StatementList~opt~ }

StatementList : See 12.1

Statement
StatementList Statement

VariableStatement : See 12.2

VAR VariableDeclarationList ;

VariableDeclarationList : See 12.2

VariableDeclaration
VariableDeclarationList , VariableDeclaration

VariableDeclarationListNoIn : See 12.2

VariableDeclarationNoIn
VariableDeclarationListNoIn , VariableDeclarationNoIn

VariableDeclaration : See 12.2

Identifier Initialiser~opt~

VariableDeclarationNoIn : See 12.2

Identifier InitialiserNoIn~opt~

Initialiser : See 12.2

= AssignmentExpression

InitialiserNoIn : See 12.2

= AssignmentExpressionNoIn

EmptyStatement : See 12.3

;

ExpressionStatement : See 12.4

[lookahead ∉ {{, FUNCTION}] Expression ;

IfStatement : See 12.5

IF ( Expression ) Statement ELSE Statement
IF ( Expression ) Statement

IterationStatement : See 12.6

DO Statement WHILE ( Expression );
WHILE ( Expression ) Statement
FOR (ExpressionNoIn~opt~; Expression~opt~ ; Expression~opt~ ) Statement
FOR ( VAR VariableDeclarationListNoIn; Expression~opt~ ; Expression~opt~
) Statement
FOR ( LeftHandSideExpression IN Expression ) Statement
FOR ( VAR VariableDeclarationNoIn IN Expression ) Statement

ContinueStatement : See 12.7

CONTINUE ;
CONTINUE [no LineTerminator here] Identifier ;

BreakStatement : See 12.8

BREAK ;
BREAK [no LineTerminator here] Identifier ;

ReturnStatement : See 12.9

RETURN ;
RETURN [no LineTerminator here] Expression ;

WithStatement : See 12.10

WITH ( Expression ) Statement

SwitchStatement : See 12.11

SWITCH ( Expression ) CaseBlock

CaseBlock : See 12.11

{ CaseClauses~opt~ }
{ CaseClauses~opt~ DefaultClause CaseClauses~opt~ }

CaseClauses : See 12.11

CaseClause
CaseClauses CaseClause

CaseClause : See 12.11

CASE Expression : StatementList~opt~

DefaultClause : See 12.11

DEFAULT : StatementList~opt~

LabelledStatement : See 12.12

Identifier : Statement

ThrowStatement : See 12.13

THROW [no LineTerminator here] Expression ;

TryStatement : See 12.14

TRY Block Catch~
~TRY Block Finally~
~TRY Block Catch Finally

Catch : See 12.14

CATCH ( Identifier ) Block

Finally : See 12.14

FINALLY Block

DebuggerStatement : See 12.15

DEBUGGER ;


Functions and Scripts

FunctionDeclaration : See clause 13

FUNCTION Identifier ( FormalParameterList~opt~ ) { FunctionBody }

FunctionExpression : See clause 13

FUNCTION Identifier~opt~ ( FormalParameterList~opt~ ) { FunctionBody }

FormalParameterList : See clause 13

Identifier
FormalParameterList , Identifier

FunctionBody : See clause 13

SourceElements~opt~

Program : See clause 14

SourceElements~opt~

SourceElements : See clause 14

SourceElement
SourceElements SourceElement

SourceElement : See clause 14

Statement
FunctionDeclaration


Universal Resource Identifier Character Classes

uri ::: See 15.1.3

uriCharacters~opt~

uriCharacters ::: See 15.1.3

uriCharacter uriCharacters~opt~

uriCharacter ::: See 15.1.3

uriReserved
uriUnescaped
uriEscaped

uriReserved ::: ONE OF See 15.1.3

; / ? : @ & = + $ ,

uriUnescaped ::: See 15.1.3

uriAlpha
DecimalDigit
uriMark

uriEscaped ::: See 15.1.3

% HexDigit HexDigit

uriAlpha ::: ONE OF See 15.1.3

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

uriMark ::: ONE OF See 15.1.3

- _ . ! ~ * ' ( )


Regular Expressions

Pattern :: See 15.10.1

Disjunction

Disjunction :: See 15.10.1

Alternative
 Alternative | Disjunction

Alternative :: See 15.10.1

[empty]
Alternative Term

Term :: See 15.10.1

Assertion
Atom
Atom Quantifier

Assertion :: See 15.10.1

^
$
\ B
\ B
( ? = Disjunction )
( ? ! Disjunction )

Quantifier :: See 15.10.1

QuantifierPrefix
QuantifierPrefix ?

QuantifierPrefix :: See 15.10.1

*
+
?
{ DecimalDigits }
{ DecimalDigits , }
{ DecimalDigits , DecimalDigits }

Atom :: See 15.10.1

PatternCharacter
.
\ AtomEscape
CharacterClass
( Disjunction )
( ? : Disjunction )

PatternCharacter :: See 15.10.1

SourceCharacter BUT NOT ONE OF-
 ^ $ \ . * + ? ( ) [ ] { } |

AtomEscape :: See 15.10.1

DecimalEscape
CharacterEscape
CharacterClassEscape

CharacterEscape :: See 15.10.1

ControlEscape
C ControlLetter
HexEscapeSequence
UnicodeEscapeSequence
IdentityEscape

ControlEscape :: ONE OF See 15.10.1

F N R T V

ControlLetter :: ONE OF See 15.10.1

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

IdentityEscape :: See 15.10.1

SourceCharacter BUT NOT IdentifierPart
<ZWJ>
<ZWNJ>

DecimalEscape :: See 15.10.1

DecimalIntegerLiteral [lookahead ∉ DecimalDigit]

CharacterClassEscape :: ONE OF See 15.10.1

D D S S W W

CharacterClass :: See 15.10.1

[ [lookahead ∉ {^}] ClassRanges ]
[ ^ ClassRanges ]

ClassRanges :: See 15.10.1

[empty]
NonemptyClassRanges

NonemptyClassRanges :: See 15.10.1

ClassAtom
ClassAtom NonemptyClassRangesNoDash
ClassAtom – ClassAtom ClassRanges

NonemptyClassRangesNoDash :: See 15.10.1

ClassAtom
ClassAtomNoDash NonemptyClassRangesNoDash
ClassAtomNoDash – ClassAtom ClassRanges

ClassAtom :: See 15.10.1

-
ClassAtomNoDash

ClassAtomNoDash :: See 15.10.1

SourceCharacter BUT NOT ONE OF \ OR ] OR -
\ ClassEscape

ClassEscape :: See 15.10.1

DecimalEscape
B
CharacterEscape
CharacterClassEscape


JSON

JSON Lexical Grammar

JSONWhiteSpace :: See 15.12.1.1

_<TAB>
<CR>
<LF>
<SP>_

JSONString :: See 15.12.1.1

" JSONStringCharacters~opt~ "

JSONStringCharacters :: See 15.12.1.1

JSONStringCharacter JSONStringCharacters~opt~

JSONStringCharacter :: See 15.12.1.1

SourceCharacter BUT NOT ONE OF " OR \ OR U+0000 THROUGH U+001F

\ JSONEscapeSequence

JSONEscapeSequence :: See 15.12.1.1

JSONEscapeCharacter

UnicodeEscapeSequence

JSONEscapeCharacter :: ONE OF See 15.12.1.1

" / \ B F N R T

JSONNumber :: See 15.12.1.1

-~opt~ DecimalIntegerLiteral JSONFraction~opt~ ExponentPart~opt~

JSONFraction :: See 15.12.1.1

. DecimalDigits

JSONNullLiteral :: See 15.12.1.1

NullLiteral

JSONBooleanLiteral :: See 15.12.1.1

BooleanLiteral

JSON Syntactic Grammar

JSONText : See 15.12.1.2

JSONValue

JSONValue : See 15.12.1.2

JSONNullLiteral
JSONBooleanLiteral
JSONObject
JSONArray
JSONString
JSONNumber

JSONObject : See 15.12.1.2

{ }
{ JSONMemberList }

JSONMember : See 15.12.1.2

JSONString : JSONValue

JSONMemberList : See 15.12.1.2

JSONMember
JSONMemberList , JSONMember

JSONArray : See 15.12.1.2

[ ]
[ JSONElementList ]

JSONElementList : See 15.12.1.2

JSONValue
JSONElementList , JSONValue

(normative)
Additional ECMAScript Features for Web Browsers

The ECMAScript language syntax and semantics defined in this annex are
required when the ECMAScript host is a web browser. The content of this
annex is normative but optional if the ECMAScript host is not a web
browser.


Additional Syntax

Numeric Literals

The syntax and semantics of 7.8.3 is extended as follows except that
this extension is not allowed for strict mode code:

Syntax

NumericLiteral ::

DecimalLiteral
BinaryIntegerLiteral
OctalIntegerLiteral
HexIntegerLiteral
LegacyOctalIntegerLiteral

LegacyOctalIntegerLiteral ::

0 OctalDigit
LegacyOctalIntegerLiteral OctalDigit

STATIC

SEMANTICS

-   -   -   -   -   -   -   -   -   -   The MV of
      LegacyOctalIntegerLiteral :: 0 OctalDigit is the MV of
      OctalDigit.

-   The MV of LegacyOctalIntegerLiteral :: LegacyOctalIntegerLiteral
      OctalDigit is (the MV of LegacyOctalIntegerLiteral times 8)
      plus the MV of OctalDigit.

String Literals

The syntax and semantics of 7.8.4 is extended as follows except that
this extension is not allowed for strict mode code:

Syntax

EscapeSequence ::

CharacterEscapeSequence
OctalEscapeSequence
HexEscapeSequence
UnicodeEscapeSequence

OctalEscapeSequence ::

OctalDigit [lookahead ∉ DecimalDigit]
ZeroToThree OctalDigit [lookahead ∉ DecimalDigit]
FourToSeven OctalDigit
ZeroToThree OctalDigit OctalDigit

ZeroToThree :: ONE OF

0 1 2 3

FourToSeven :: ONE OF

4 5 6 7

Static Semantics

-   The CV of EscapeSequence :: OctalEscapeSequence is the CV of the
    OctalEscapeSequence.

-   The CV of OctalEscapeSequence :: OctalDigit [lookahead ∉
    DecimalDigit] is the character whose code unit value is the MV of
    the OctalDigit.

-   The CV of OctalEscapeSequence :: ZeroToThree OctalDigit
    [lookahead ∉ DecimalDigit] is the character whose code unit value
    is (8 times the MV of the ZeroToThree) plus the MV of the
    OctalDigit.

-   The CV of OctalEscapeSequence :: FourToSeven OctalDigit is the
    character whose code unit value is (8 times the MV of the
    FourToSeven) plus the MV of the OctalDigit.

-   The CV of OctalEscapeSequence :: ZeroToThree OctalDigit
    OctalDigit is the character whose code unit value is (64 (that is,
    8^2^) times the MV of the ZeroToThree) plus (8 times the MV of the
    first OctalDigit) plus the MV of the second OctalDigit.

-   The MV of ZeroToThree :: 0 is 0.

-   The MV of ZeroToThree :: 1 is 1.

-   The MV of ZeroToThree :: 2 is 2.

-   The MV of ZeroToThree :: 3 is 3.

-   The MV of FourToSeven :: 4 is 4.

-   The MV of FourToSeven :: 5 is 5.

-   The MV of FourToSeven :: 6 is 6.

-   The MV of FourToSeven :: 7 is 7.


Additional Properties

When the ECMAScript host is a web browser the following additional
properties of the standard built-in objects are defined.

Additional Properties of the Global Object

escape (string)

The ESCAPE function is a property of the global object. It computes a
new version of a String value in which certain characters have been
replaced by a hexadecimal escape sequence.

For those characters being replaced whose code unit value is 0XFF or
less, a two-digit escape sequence of the form %xx is used. For those
characters being replaced whose code unit value is greater than 0XFF, a
four-digit escape sequence of the form %Uxxxx is used.

When the ESCAPE function is called with one argument string, the
following steps are taken:

NOTE The encoding is partly based on the encoding described in RFC 1738,
but the entire encoding specified in this standard is described above
without regard to the contents of RFC 1738. This encoding does not
reflect changes to RFC 1738 made by RFC 3986.

unescape (string)

The UNESCAPE function is a property of the global object. It computes a
new version of a String value in which each escape sequence of the sort
that might be introduced by the ESCAPE function is replaced with the
character that it represents.

When the UNESCAPE function is called with one argument string, the
following steps are taken:

Additional Properties of the String.prototype Object

String.prototype.substr (start, length)

The SUBSTR method takes two arguments, start and length, and returns
a substring of the result of converting the this object to a String,
starting from character position start and running for length
characters (or through the end of the String if length is UNDEFINED).
If start is negative, it is treated as (sourceLength_+_start) where
sourceLength is the length of the String. The result is a String
value, not a String object. The following steps are taken:

The LENGTH property of the SUBSTR method is 2.

NOTE The SUBSTR function is intentionally generic; it does not require
that its THIS value be a String object. Therefore it can be transferred
to other kinds of objects for use as a method.

String.prototype.anchor ( name )

When the ANCHOR method is called with argument name, the following
steps are taken:

The abstract operation CreateHTML is called with arguments _string,
tag_, attribute, and value. The arguments tag and attribute must
be string values. The following steps are taken:

1.  ReturnIfAbrupt(CheckObjectCoercible(string)).

2.  Let S be the result of performing ToString(string).

3.  ReturnIfAbrupt(S).

4.  a.  b.  

5.  Let p1 be the string value that is the concatenation of "<" and
    tag.

6.  If attribute is not the empty String, then

    a.  Let V be the result of performing ToString(value).

    b.  ReturnIfAbrupt(V).

    c.  Let escapedV be the string value that is the same as V
        except that each occurrence of the character " (code unit value
        0x0022) in V has been replaced with the six character sequence
        "&QUOT;".

    d.  Let p1 be the string value that is the concatenation of the
        following string values:

-   p1

-   a single space code unit 0x0020

-   attribute

-   "="

-   ′"′

-   escapedV

-   ′"′

1.  Let p2 be the string value that is the concatenation of p1 and
    ">".

2.  Let p3 be the string value that is the concatenation of p2,
    "</", tag, and ">".

3.  Return p3.

String.prototype.big ()

When the BIG method is called with no arguments, the following steps are
taken:

1.  Let S be the THIS value.

2.  Return the result of performing the abstract operation CreateHTML
    with arguments S, "BIG", "" and "".

String.prototype.blink ()

When the BLINK method is called with no arguments, the following steps
are taken:

1.  Let S be the THIS value.

2.  Return the result of performing the abstract operation CreateHTML
    with arguments S, "BLINK", "" and "".

String.prototype.bold ()

When the BOLD method is called with no arguments, the following steps
are taken:

1.  Let S be the THIS value.

2.  Return the result of performing the abstract operation CreateHTML
    with arguments S, "B", "" and "".

String.prototype.fixed ()

When the FIXED method is called with no arguments, the following steps
are taken:

1.  Let S be the THIS value.

2.  Return the result of performing the abstract operation CreateHTML
    with arguments S, "TT", "" and "".

String.prototype.fontcolor ( color )

When the FONTCOLOR method is called with argument color, the following
steps are taken:

1.  Let S be the THIS value.

2.  Return the result of performing the abstract operation CreateHTML
    with arguments S, "FONT", "COLOR" and color.

String.prototype.fontsize ( size )

When the FONTSIZE method is called with argument size, the following
steps are taken:

1.  Let S be the THIS value.

2.  Return the result of performing the abstract operation CreateHTML
    with arguments S, "FONT", "SIZE" and size.

String.prototype.italics ()

When the ITALICS method is called with no arguments, the following steps
are taken:

1.  Let S be the THIS value.

2.  Return the result of performing the abstract operation CreateHTML
    with arguments S, "I", "" and "".

String.prototype.link ( url )

When the LINK method is called with argument url, the following steps
are taken:

1.  Let S be the THIS value.

2.  Return the result of performing the abstract operation CreateHTML
    with arguments S, "A", "HREF" and url.

String.prototype.small ()

When the SMALL method is called with no arguments, the following steps
are taken:

1.  Let S be the THIS value.

2.  Return the result of performing the abstract operation CreateHTML
    with arguments S, "SMALL", "" and "".

String.prototype.strike ()

When the STRIKE method is called with no arguments, the following steps
are taken:

1.  Let S be the THIS value.

2.  Return the result of performing the abstract operation CreateHTML
    with arguments S, "STRIKE", "" and "".

String.prototype.sub ()

When the SUB method is called with no arguments, the following steps are
taken:

1.  Let S be the THIS value.

2.  Return the result of performing the abstract operation CreateHTML
    with arguments S, "SUB", "" and "".

String.prototype.sup ()

When the SUP method is called with no arguments, the following steps are
taken:

1.  Let S be the THIS value.

2.  Return the result of performing the abstract operation CreateHTML
    with arguments S, "SUP", "" and "".

Additional Properties of the Date.prototype Object

Date.prototype.getYear ( )

NOTE The GETFULLYEAR method is preferred for nearly all purposes,
because it avoids the “year 2000 problem.”

When the GETYEAR method is called with no arguments, the following steps
are taken:

1.  Let t be this time value.

2.  ReturnIfAbrupt(t).

3.  If t is NAN, return NAN.

4.  Return YearFromTime(LocalTime(t)) − 1900.

Date.prototype.setYear (year)

NOTE The SETFULLYEAR method is preferred for nearly all purposes,
because it avoids the “year 2000 problem.”

When the SETYEAR method is called with one argument year, the
following steps are taken:

Date.prototype.toGMTString ( )

NOTE The property TOUTCSTRING is preferred. The TOGMTSTRING property is
provided principally for compatibility with old code. It is recommended
that the TOUTCSTRING property be used in new ECMAScript code.

The Function object that is the initial value of
DATE.PROTOTYPE.TOGMTSTRING is the same Function object that is the
initial value of DATE.PROTOTYPE.TOUTCSTRING.


Other Additional Features

The _proto_ pseudo property.

Object.prototype._proto_

The initial value of the _PROTO_ property of the Object prototype
object is a data property whose initial value is NULL. This property
initially has the attributes { [[Writable]]: TRUE, [[Enumerable]]:
FALSE, [[Configurable]]: TRUE }.

Manipulations of this property as tracked by the Boolean valued
primordial internal variable UnderscoreProtoEnabled. The default initial
value of UnderscoreProtoEnabled is true only if this property is
initially present on the primordial Object prototype object.

NOTE Any modification of this property or its attributes causes
UnderscoreProtoEnabled to be set to FALSE.

 Changes To Internal Methods

The definition of the [[Get]] internal method given in 8.12.3 is
replaced with the following:

1.  If P is the string value "_PROTO_" and UnderscoreProtoEnabled is
    TRUE, then

    a.  Let desc be the result of calling the [[GetProperty]] internal
        method of O with property name P.

    b.  If desc is not UNDEFINED and was created by step 1.a to
        describe the property defined in B.3.1.1 then,

        i.  Return the value of the [[Prototype]] internal property of
            O.

2.  Continue by executing the steps of 8.12.3 starting with step 1.

The definition of the [[Put]] internal method given in 8.12.5 is
replaced with the following:

1.  If P is the string value "_PROTO_" and UnderscoreProtoEnabled is
    TRUE and O is not the standard built-in Object prototype object,
    then

    a.  Let desc be the result of calling the [[GetProperty]] internal
        method of O with property name P.

    b.  If desc is not UNDEFINED and was created by step 1.a to
        describe the property defined in B.3.1.1 then,

        i.  If the type of V is neither Object or Null, return

        ii. Set the value of the [[Prototype]] internal property of O to
            V.

        iii. Return.

2.  Continue by executing the steps of 8.12.5 starting with step 1.

The definition of the [[Delete]] internal method given in 8.12.7 is
replaced with the following:

1.  If UnderscoreProtoEnabled is TRUE and P is the string value
    "_PROTO_" and O is the standard built-in Object prototype
    object, then

    a.  Set UnderscoreProtoEnabled to FALSE.

2.  Continue by executing the steps of 8.12.7 starting with step 1.

The definition of the [[DefineOwnProperty]] internal method given in
8.12.9 is replaced with the following:

1.  If UnderscoreProtoEnabled is TRUE and P is the string value
    "_PROTO_" and O is the standard built-in Object prototype
    object, then

    a.  If any attribute contained in Desc is not present or has a
        different value from the corresponding attribute in {
        [[Writable]]: TRUE, [[Enumerable]]: TRUE, [[Configurable]]: TRUE
        }then,

        i.  Set UnderscoreProtoEnabled to FALSE.

2.  Continue by executing the steps of 8.12.9 starting with step 1.

_proto__ Object Initialisers _

Definitions of two algorithms in 11.1.5 are replaced with the following:

The production PropertyDefinitionList : PropertyDefinition is
evaluated as follows:

1.  Let obj be the result of creating a new object as if by the
    expression NEW OBJECT() where OBJECT is the standard built-in
    constructor with that name.

2.  Let propId be the result of evaluating PropertyDefinition.

3.  If propId.name is the string value "_PROTO_" and
    UnderscoreProtoEnabled is TRUE and
    IsDataDescriptor(propId.descriptor) is TRUE, then

    a.  Let v be propId.descriptor.value.

    b.  If _desc be propId_.descriptor

    c.  If the type of v is either Object or Null,

        i.  Set the value of the [[Prototype]] internal property of
            obj to v.

        ii. Return obj.

4.  Call the [[DefineOwnProperty]] internal method of obj with
    arguments propId.name, propId.descriptor, and FALSE.

5.  Return obj.

The production
 PropertyDefinitionList : PropertyDefinitionList ,
PropertyDefinition
is evaluated as follows:

5.  Call the [[DefineOwnProperty]] internal method of obj with
    arguments propId.name, propId.descriptor, and FALSE.

6.  Return obj.

(informative)
The Strict Mode of ECMAScript

THE STRICT MODE RESTRICTION AND EXCEPTIONS

-   The identifiers "IMPLEMENTS", "INTERFACE", "LET", "PACKAGE",
      "PRIVATE", "PROTECTED", "PUBLIC", "STATIC", and "YIELD" are
      classified as FutureReservedWord tokens within strict mode code.
      (7.6.12).

-   A conforming implementation, when processing strict mode code, may
      not extend the syntax of NumericLiteral (7.8.3) to include
      OctalIntegerLiteral as described in B.1.1.

-   A conforming implementation, when processing strict mode code (see
      10.1.1), may not extend the syntax of EscapeSequence to include
      OctalEscapeSequence as described in B.1.2.

-   Assignment to an undeclared identifier or otherwise unresolvable
      reference does not create a property in the global object. When a
      simple assignment occurs within strict mode code, its
      LeftHandSide must not evaluate to an unresolvable Reference. If
      it does a REFERENCEERROR exception is thrown (8.9.2). The
      LeftHandSide also may not be a reference to a data property with
      the attribute value {[[Writable]]:FALSE}, to an accessor property
      with the attribute value {[[Set]]:UNDEFINED}, nor to a
      non-existent property of an object whose [[Extensible]] internal
      property has the value FALSE. In these cases a TYPEERROR exception
      is thrown (11.13.1).

-   The identifier EVAL or ARGUMENTS may not appear as the
      LeftHandSideExpression of an Assignment operator (11.13) or of a
      PostfixExpression (11.3) or as the UnaryExpression operated
      upon by a Prefix Increment (11.4.4) or a Prefix Decrement (11.4.5)
      operator.

-   Arguments objects for strict mode functions define non-configurable
      accessor properties named "CALLER" and "CALLEE" which throw a
      TYPEERROR exception on access (10.6).

-   Arguments objects for strict mode functions do not dynamically share
      their array indexed property values with the corresponding formal
      parameter bindings of their functions. (10.6).

-   For strict mode functions, if an arguments object is created the
      binding of the local identifier ARGUMENTS to the arguments object
      is immutable and hence may not be the target of an assignment
      expression. (10.5).

-   It is a SYNTAXERROR if strict mode code contains an ObjectLiteral
      with more than one definition of any data property (11.1.5).

-   It is a SYNTAXERROR if the Identifier "EVAL" or the Identifier
      "ARGUMENTS" occurs as the Identifier in a
      PropertySetParameterList of a PropertyDefinition that is
      contained in strict code or if its FunctionBody is strict code
      (11.1.5).

-   Strict mode eval code cannot instantiate variables or functions in
      the variable environment of the caller to eval. Instead, a new
      variable environment is created and that environment is used for
      declaration binding instantiation for the eval code (10.4.2).

-   If THIS is evaluated within strict mode code, then the THIS value is
      not coerced to an object. A THIS value of NULL or UNDEFINED is not
      converted to the global object and primitive values are not
      converted to wrapper objects. The THIS value passed via a function
      call (including calls made using FUNCTION.PROTOTYPE.APPLY and
      FUNCTION.PROTOTYPE.CALL) do not coerce the passed this value to an
      object (10.4.3, 11.1.1, 15.3.4.3, 15.3.4.4).

-   When a DELETE operator occurs within strict mode code, a SYNTAXERROR
      is thrown if its UnaryExpression is a direct reference to a
      variable, function argument, or function name(11.4.1).

-   When a DELETE operator occurs within strict mode code, a TYPEERROR
      is thrown if the property to be deleted has the attribute {
      [[Configurable]]:FALSE } (11.4.1).

-   It is a SYNTAXERROR if a VariableDeclaration or
      VariableDeclarationNoIn occurs within strict code and its
      Identifier is EVAL or ARGUMENTS (12.2.1).

-   Strict mode code may not include a WithStatement. The occurrence
      of a WithStatement in such a context is an SYNTAXERROR (12.10).

-   It is a SYNTAXERROR if a TryStatement with a Catch occurs within
      strict code and the Identifier of the Catch production is EVAL
      or ARGUMENTS (12.14.1)

-   It is a SYNTAXERROR if the identifier EVAL or ARGUMENTS appears
      within a FormalParameterList of a strict mode
      FunctionDeclaration or FunctionExpression (13.1)

-   A strict mode function may not have two or more formal parameters
      that have the same name. An attempt to create such a function
      using a FunctionDeclaration, FunctionExpression, or FUNCTION
      constructor is a SYNTAXERROR (13.1, 15.3.2).

-   An implementation may not extend, beyond that defined in this
      specification, the meanings within strict mode functions of
      properties named CALLER or ARGUMENTS of function instances.
      ECMAScript code may not create or modify properties with these
      names on function objects that correspond to strict mode functions
      (10.6, 13.6, 15.3.4.5.3).

-   It is a SYNTAXERROR to use within strict mode code the identifiers
      EVAL or ARGUMENTS as the Identifier of a FunctionDeclaration
      or FunctionExpression or as a formal parameter name (13.1).
      Attempting to dynamically define such a strict mode function using
      the FUNCTION constructor (15.3.2) will throw a SYNTAXERROR
      exception.

(informative)
Corrections and Clarifications with Possible Compatibility Impact

15.9.1.15: If a time zone offset is not present, the local time zone is
used. Edition 5.1 incorrectly stated that a missing time zone should be
interpreted as “z”.

15.9.5.2: Previous editions did not specify the value returned by
Date.prototype.toString when this time value is NaN. The 6^th^ Edition
species the result to be the String value is "INVALID DATE"

7.8.4: CV definitions added for DoubleStringCharacter ::
LineContinuation and SingleStringCharacter :: LineContinuation.

10.2.1.1.3: The argument S is not ignored. It controls whether an
exception is thrown when attempting to set an immutable binding.

10.2.1.2.2: In algorithm step 5, TRUE is passed as the last argument to
[[DefineOwnProperty]].

10.5: Former algorithm step 5.e is now 5.f and a new step 5.e was added
to restore compatibility with 3^rd^ Edition when redefining global
functions.

11.5.3: In the final bullet item, use of IEEE 754 round-to-nearest mode
is specified.

12.6.3: Missing ToBoolean restored in step 3.a.ii of both algorithms.

12.6.4: Additional final sentences in each of the last two paragraphs
clarify certain property enumeration requirements.

12.7, 12.8, 12.9: BNF modified to clarify that a CONTINUE or BREAK
statement without an Identifier or a RETURN statement without an
Expression may have a LineTerminator before the semi-colon.

12.14: Step 3 of algorithm 1 and step 2.a of algorithm 3 are corrected
such that the value field of B is passed as a parameter rather than
B itself.

15.1.2.2: In step 2 of algorithm, clarify that S may be the empty
string.

15.1.2.3: In step 2 of algorithm clarify that trimmedString may be the
empty string.

15.1.3: Added notes clarifying that ECMAScript’s URI syntax is based
upon RFC 2396 and not the newer RFC 3986. In the algorithm for Decode, a
step was removed that immediately preceded the current step 4.d.vii.10.a
because it tested for a condition that cannot occur.

15.2.3.7: Corrected use of variable P in steps 5 and 6 of algorithm.

15.2.4.2: Edition 5 handling of UNDEFINED and NULL as THIS value caused
existing code to fail. Specification modified to maintain compatibility
with such code. New steps 1 and 2 added to the algorithm.

15.3.4.3: Steps 5 and 7 of Edition 5 algorithm have been deleted because
they imposed requirements upon the argArray argument that are
inconsistent with other uses of generic array-like objects.

15.4.4.12: In step 9.a, incorrect reference to relativeStart was
replaced with a reference to actualStart.

15.4.4.15: Clarified that the default value for fromIndex is the
length minus 1 of the array.

15.4.4.18: In step 9 of the algorithm, UNDEFINED is now the specified
return value.

15.4.4.22: In step 9.c.ii the first argument to the [[Call]] internal
method has been changed to UNDEFINED for consistency with the definition
of Array.prototype.reduce.

15.4.5.1: In Algorithm steps 3.l.ii and 3.l.iii the variable name was
inverted resulting in an incorrectly inverted test.

15.5.4.9: Normative requirement concerning canonically equivalent
strings deleted from paragraph following algorithm because it is listed
as a recommendation in NOTE 2.

15.5.4.14: In split algorithm step 11.a and 13.a, the positional order
of the arguments to SplitMatch was corrected to match the actual
parameter signature of SplitMatch. In step 13.a.iii.7.d, lengthA
replaces A.length.

15.5.5.2: In first paragraph, removed the implication that the
individual character property access had “array index” semantics.
Modified algorithm steps 3 and 5 such that they do not enforce “array
index” requirement.

15.9.1.15: Specified legal value ranges for fields that lacked them.
Eliminated “time-only” formats. Specified default values for all
optional fields.

15.10.2.2: The step numbers of the algorithm for the internal closure
produced by step 2 were incorrectly numbered in a manner that implied
that they were steps of the outer algorithm.

15.10.2.6: In the abstract operation IsWordChar the first character in
the list in step 3 is “A” rather than “A”.

15.10.2.8: In the algorithm for the closure returned by the abstract
operation CharacterSetMatcher, the variable defined by step 3 and
passed as an argument in step 4 was renamed to ch in order to avoid a
name conflict with a formal parameter of the closure.

15.10.6.2: Step 9.e was deleted because It performed an extra increment
of i.

15.11.1.1: Removed requirement that the message own property is set to
the empty String when the message argument is UNDEFINED.

15.11.1.2: Removed requirement that the message own property is set to
the empty String when the message argument is UNDEFINED.

15.11.4.4: Steps 6-10 modified/added to correctly deal with missing or
empty message property value.

15.11.1.2: Removed requirement that the message own property is set to
the empty String when the message argument is UNDEFINED.

15.12.3: In step 10.b.iii of the JA internal operation, the last
element of the concatenation is “]”.

B.2.1: Added to NOTE that the encoding is based upon RFC 1738 rather
than the newer RFC 3986.

Annex C: An item was added corresponding to 7.6.12 regarding
FutureReservedWords in strict mode.

Throughout: In the Edition 3 specification the meaning of phrases such
as “as if by the expression NEW ARRAY()” are subject to
misinterpretation. In the Edition 5 specification text for all internal
references and invocations of standard built-in objects and methods has
been clarified by making it explicit that the intent is that the actual
built-in object is to be used rather than the current dynamic value of
the correspondingly named property.

11.8.1: ECMAScript generally uses a left to right evaluation order,
however the Edition 3 specification language for the > and <= operators
resulted in a partial right to left order. The specification has been
corrected for these operators such that it now specifies a full left to
right evaluation order. However, this change of order is potentially
observable if side-effects occur during the evaluation process.

11.1.4: Edition 5 clarifies the fact that a trailing comma at the end of
an ArrayInitialiser does not add to the length of the array. This is
not a semantic change from Edition 3 but some implementations may have
previously misinterpreted this.

11.2.3: Edition 5 reverses the order of steps 2 and 3 of the algorithm.
The original order as specified in Editions 1 through 3 was incorrectly
specified such that side-effects of evaluating Arguments could affect
the result of evaluating MemberExpression.

12.4: In Edition 3, an object is created, as if by NEW OBJECT()to serve
as the scope for resolving the name of the exception parameter passed to
a CATCH clause of a TRY statement. If the actual exception object is a
function and it is called from within the CATCH clause, the scope object
will be passed as the THIS value of the call. The body of the function
can then define new properties on its THIS value and those property
names become visible identifiers bindings within the scope of the CATCH
clause after the function returns. In Edition 5, when an exception
parameter is called as a function, UNDEFINED is passed as the THIS
value.

13: In Edition 3, the algorithm for the production FunctionExpression
with an Identifier adds an object created as if by NEW OBJECT() to the
scope chain to serve as a scope for looking up the name of the function.
The identifier resolution rules (10.1.4 in Edition 3) when applied to
such an object will, if necessary, follow the object’s prototype chain
when attempting to resolve an identifier. This means all the properties
of Object.prototype are visible as identifiers within that scope. In
practice most implementations of Edition 3 have not implemented this
semantics. Edition 5 changes the specified semantics by using a
Declarative Environment Record to bind the name of the function.

14: In Edition 3, the algorithm for the production SourceElements :
_SourceElements SourceElement_ did not correctly propagate statement
result values in the same manner as Block. This could result in the
EVAL function producing an incorrect result when evaluating a Program
text. In practice most implementations of Edition 3 have implemented the
correct propagation rather than what was specified in Edition 5.

15.10.6: RegExp.prototype is now a RegExp object rather than an instance
of Object. The value of its [[Class]] internal property which is
observable using Object.prototype.toString is now “RegExp” rather than
“Object”.

(informative)
Additions and Changes that
Introduce Incompatibilities with Prior Editions

12.6: In Edition 6, a terminating semi-colon is no longer required at
the end of a do-while statement.

12.14: In Edition 6, it is an early error for a Catch clause to
contained a VAR declaration for the same Identifier that appears as
the Catch clause parameter. In previous editions, such a variable
declaration would be instantiated in the enclosing variable environment
but the declaration’s Initializer value would be assigned to the
Catch parameter.

13.3 In Edition 6, the function objects that are created as the values
of the [[Get]] or [[Set]] attribute of accessor properties in an
ObjectLiteral are not constructor functions. In Edition 5, they were
constructors.

15.2.3.5 and 15.2.3.7: In Edition 6, all property additions and changes
are processed, even if one of them throws an acception. If an exception
occurs during such processing, the first such exception is thrown after
all propertie are processed. In Edition 5, processing of property
additions and changes immediately terminated when the first exception
occurred.

7.1: Unicode format control characters are no longer stripped from
ECMAScript source text before processing. In Edition 5, if such a
character appears in a StringLiteral or RegularExpressionLiteral the
character will be incorporated into the literal where in Edition 3 the
character would not be incorporated into the literal.

7.2: Unicode character <BOM> is now treated as whitespace and its
presence in the middle of what appears to be an identifier could result
in a syntax error which would not have occurred in Edition 3

7.3: Line terminator characters that are preceded by an escape sequence
are now allowed within a string literal token. In Edition 3 a syntax
error would have been produced.

7.8.5: Regular expression literals now return a unique object each time
the literal is evaluated. This change is detectable by any programs that
test the object identity of such literal values or that are sensitive to
the shared side effects.

7.8.5: Edition 5 requires early reporting of any possible RegExp
constructor errors that would be produced when converting a
RegularExpressionLiteral to a RegExp object. Prior to Edition 5
implementations were permitted to defer the reporting of such errors
until the actual execution time creation of the object.

7.8.5: In Edition 5 unescaped “/” characters may appear as a
CharacterClass in a regular expression literal. In Edition 3 such a
character would have been interpreted as the final character of the
literal.

10.4.2: In Edition 5, indirect calls to the EVAL function use the global
environment as both the variable environment and lexical environment for
the eval code. In Edition 3, the variable and lexical environments of
the caller of an indirect EVAL was used as the environments for the eval
code.

15.4.4: In Edition 5 all methods of ARRAY.PROTOTYPE are intentionally
generic. In Edition 3 TOSTRING and TOLOCALESTRING were not generic and
would throw a TYPEERROR exception if applied to objects that were not
instances of Array.

10.6: In Edition 5 the array indexed properties of argument objects that
correspond to actual formal parameters are enumerable. In Edition 3,
such properties were not enumerable.

10.6: In Edition 5 the value of the [[Class]] internal property of an
arguments object is "ARGUMENTS". In Edition 3, it was "OBJECT". This is
observable if TOSTRING is called as a method of an arguments object.

12.6.4: for-in statements no longer throw a TYPEERROR if the IN
expression evaluates to NULL or UNDEFINED. Instead, the statement
behaves as if the value of the expression was an object with no
enumerable properties.

15: In Edition 5, the following new properties are defined on built-in
objects that exist in Edition 3: OBJECT.GETPROTOTYPEOF,
OBJECT.GETOWNPROPERTYDESCRIPTOR, OBJECT.GETOWNPROPERTYNAMES,
OBJECT.CREATE, OBJECT.DEFINEPROPERTY, OBJECT.DEFINEPROPERTIES,
OBJECT.SEAL, OBJECT.FREEZE, OBJECT.PREVENTEXTENSIONS, OBJECT.ISSEALED,
OBJECT.ISFROZEN, OBJECT.ISEXTENSIBLE, OBJECT.KEYS,
FUNCTION.PROTOTYPE.BIND, ARRAY.PROTOTYPE.INDEXOF,
ARRAY.PROTOTYPE.LASTINDEXOF, ARRAY.PROTOTYPE.EVERY,
ARRAY.PROTOTYPE.SOME, ARRAY.PROTOTYPE.FOREACH, ARRAY.PROTOTYPE.MAP,
ARRAY.PROTOTYPE.FILTER, ARRAY.PROTOTYPE.REDUCE,
ARRAY.PROTOTYPE.REDUCERIGHT, STRING.PROTOTYPE.TRIM, DATE.NOW,
DATE.PROTOTYPE.TOISOSTRING, DATE.PROTOTYPE.TOJSON.

15: Implementations are now required to ignore extra arguments to
standard built-in methods unless otherwise explicitly specified. In
Edition 3 the handling of extra arguments was unspecified and
implementations were explicitly allowed to throw a TYPEERROR exception.

15.1.1: The value properties NAN, INFINITY, and UNDEFINED of the Global
Object have been changed to be read-only properties.

15.1.2.1. Implementations are no longer permitted to restrict the use of
eval in ways that are not a direct call. In addition, any invocation of
eval that is not a direct call uses the global environment as its
variable environment rather than the caller’s variable environment.

15.1.2.2: The specification of the function PARSEINT no longer allows
implementations to treat Strings beginning with a 0 character as octal
values.

15.3.4.3: In Edition 3, a TYPEERROR is thrown if the second argument
passed to FUNCTION.PROTOTYPE.APPLY is neither an array object nor an
arguments object. In Edition 5, the second argument may be any kind of
generic array-like object that has a valid LENGTH property.

15.3.4.3, 15.3.4.4: In Edition 3 passing UNDEFINED or NULL as the first
argument to either FUNCTION.PROTOTYPE.APPLY or FUNCTION.PROTOTYPE.CALL
causes the global object to be passed to the indirectly invoked target
function as the THIS value. If the first argument is a primitive value
the result of calling ToObject on the primitive value is passed as the
THIS value. In Edition 5, these transformations are not performed and
the actual first argument value is passed as the THIS value. This
difference will normally be unobservable to existing ECMAScript Edition
3 code because a corresponding transformation takes place upon
activation of the target function. However, depending upon the
implementation, this difference may be observable by host object
functions called using APPLY or CALL. In addition, invoking a standard
built-in function in this manner with NULL or UNDEFINED passed as the
THIS value will in many cases cause behaviour in Edition 5
implementations that differ from Edition 3 behaviour. In particular, in
Edition 5 built-in functions that are specified to actually use the
passed THIS value as an object typically throw a TYPEERROR exception if
passed NULL or UNDEFINED as the THIS value.

15.3.5.2: In Edition 5, the PROTOTYPE property of Function instances is
not enumerable. In Edition 3, this property was enumerable.

15.5.5.2: In Edition 5, the individual characters of a String object’s
[[PrimitiveValue] may be accessed as array indexed properties of the
String object. These properties are non-writable and non-configurable
and shadow any inherited properties with the same names. In Edition 3,
these properties did not exist and ECMAScript code could dynamically add
and remove writable properties with such names and could access
inherited properties with such names.

15.9.4.2: DATE.PARSE is now required to first attempt to parse its
argument as an ISO format string. Programs that use this format but
depended upon implementation specific behaviour (including failure) may
behave differently.

15.10.2.12: In Edition 5, \S now additionally matches <BOM>.

15.10.4.1: In Edition 3, the exact form of the String value of the
SOURCE property of an object created by the REGEXP constructor is
implementation defined. In Edition 5, the String must conform to certain
specified requirements and hence may be different from that produced by
an Edition 3 implementation.

15.10.6.4: In Edition 3, the result of REGEXP.PROTOTYPE.TOSTRING need
not be derived from the value of the RegExp object’s SOURCE property. In
Edition 5 the result must be derived from the SOURCE property in a
specified manner and hence may be different from the result produced by
an Edition 3 implementation.

15.11.2.1, 15.11.4.3: In Edition 5, if an initial value for the MESSAGE
property of an Error object is not specified via the ERROR constructor
the initial value of the property is the empty String. In Edition 3,
such an initial value is implementation defined.

15.11.4.4: In Edition 3, the result of ERROR.PROTOTYPE.TOSTRING is
implementation defined. In Edition 5, the result is fully specified and
hence may differ from some Edition 3 implementations.

15.12: In Edition 5, the name JSON is defined in the global environment.
In Edition 3, testing for the presence of that name will show it to be
undefined unless it is defined by the program or implementation.

(informative)
Static Semantic Rule Cross Reference

  ROUTINE NAME                 PURPOSE                                                                                                                                                                                            DEFINITIONS                                                     USES
  ---------------------------- -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- --------------------------------------------------------------- ------
  BoundNames                   Produces a list of the Identifiers bound by a production. Does not include Identifiers that are bound within inner environments associated with the production.                                    12.2.1, 12.2.2, 12.2.4, 12.6.4, 13.1, 13.2, 13.5                
  ConstructorMethod            From a ClassBody return the first ClassElement whose PropName is ″CONSTRUCTOR″. Returns empty if the ClassBody does not contain one.                                                         13.5                                                            
  Contains                     Determine if a grammar production either directly or indirectly includes a grammar symbol.                                                                                                         5.3, 13.1, 13.2, 13.5                                           
  CoveredFormalsList           Reparse a covered Expression using FormalsList as the goal symbol.                                                                                                                             13.2                                                            
  CV                           Determines the “character value” of a component of a StringLiteral.                                                                                                                              7.8.4                                                           
  Elision Width                Determine the number of commas in an Elision.                                                                                                                                                    11.1.4.1                                                        
  ExpectedArgumentCount        Determine the “length” of an argument list for the purpose of initializing the “length” property of a function object.                                                                             13.1, 13.2, 13.3                                                
  HasInitialiser               Determines whether the production contains an Initialiser production.                                                                                                                            12.2.4, 13.1                                                    
  IsConstantDeclaration        Determines whether the production introduces a immutable environment record binding                                                                                                                12.2, 13.1, 13.5                                                
  IsInvalidAssignmentPattern   Determines if a LeftHandSideExpression is a valid assignment target. Primarily for dealing with destructuring assignment targets.                                                                11.2                                                            
  LexicalDeclarations          Return a List containing the components of a production that are processed as lexical declarations                                                                                                 12.1, 12.11, 12.5                                               
  LexicallyDeclaredNames       Returns a list of the lexically scoped identifiers declared by a production.                                                                                                                       12.1, 13.1, 13.2, 13.5                                          
  MethodDefinitions            Return a list of the MethodDefinition productions that are part of a ClassElementList.                                                                                                         13.5                                                            
  MV                           Determines the “mathematical value” of a numeric lirteral or component of a numeric literal.                                                                                                       7.8.3                                                           
  PropName                     Determines the string value of the property name referenced by a production.                                                                                                                       11.1.5.1, 13.3, 13.5                                            
  PropNameList                 Returns a List of the string values of the property names referenced by a production. The list reflects the order of the references in the source text. The list may contain duplicate elements.   11.5.1, 13.5                                                    
  ReferencesSuper              Determine if a MethodDefinition contains any references to the ReservedWord SUPER.                                                                                                             13.3                                                            
  SpecialMethod                Determine if a MethodDefinition defines a generator method or an accessor property.                                                                                                              13.3                                                            
  SV                           Determines the “string value” of a StringLiteral or component of a StringLiteral.                                                                                                              7.8.4                                                           
                                                                                                                                                                                                                                                                                                  
  VarDeclaredNames             Returns a list of the local top-level scoped identifiers declared by a production. These are identifier that are scoped as if by a var statement.                                                  12.1, 12.5, 12.6.1, 12.6.2, 12.6.3, 12.6.4, 12.12, 13.1, 13.5   

A place to temporarily hand on to stuff that’s been deleted

MemberExpression :

MemberExpression <| TriangleLiteral

TriangleLiteral :

SealedArrayLiteral
SealedObjectLiteral
FunctionExpression
ArrowFunction
ValueLiteral

CallExpression :

CallExpression <| TriangleLiteral

When the ISOBJECT function is called with argument O, the following
steps are taken:

1.  If Type(O) is Object return TRUE.

2.  Return FALSE.

15.5.4.25 STRING.PROTOTYPE.TOARRAY()

The following steps are taken:

1.  ReturnIfAbrupt(CheckObjectCoercible(THIS value)).

2.  Let S be the result of calling ToString, giving it the THIS value
    as its argument.

3.  ReturnIfAbrupt(S).

4.  Let len be the number of characters in S.

5.  Let array be the result of the abstract operation ArrayCreate
    (15.4) with argument len.

6.  Let n be 0

7.  Repeat, while n < len:

    a.  Let c be the character at position n in S.

    b.  Call the [[DefineOwnProperty]] internal method of array with
        arguments ToString(n), the PropertyDescriptor {[[Value]]: c,
        [[Writable]]: TRUE, [[Enumerable]]: TRUE, [[Configurable]]:
        TRUE}, and FALSE.

    c.  Increment n by 1.

8.  Return array.

The LENGTH property of the TOARRAY method is 0.

NOTE 1 Returns an Array object with elements corresponding to the
characters of this object (converted to a String).

NOTE 2 The TOARRAY function is intentionally generic; it does not
require that its THIS value be a String object. Therefore, it can be
transferred to other kinds of objects for use as a method.

STATIC SEMANTICS: TOPLEVELLEXICALLYDECLAREDNAMES

OuerStatementList : _OuterStatementList OuterItem_

1.  Let names be TopLevelLexicallyDeclaredNames of
    OuterStatementList.

2.  Append to names the elements of the TopLevelLexicallyDeclaredNames
    of OuterItem.

3.  Return names.

OuterItem : StatementListItem

1.  Return a new empty List.

StatementListItem : Declaration

1.  If Declaration is Declaration : FunctionDeclaration, then
    return a new empty List.

2.  Return the BoundNames of Declaration.

_This follow version places function body declarations in_ _scope of
parameter initializers_

NOTE When an execution context is established for evaluating function
code a new Declarative Environment Record is created and bindings for
each formal parameter, and each function level variable, constant, or
function declarated in the function are instantiated in the environment
record. Formal parameters and functions are initialized as part of this
process. All other bindings are initialized during execution of the
function code.

Function Declaration Instantiation is performed as follows using
arguments _func, argumentsList_, and env. func is the function
object that for which the execution context is being established. env
is the declarative environment record in which bindings are to be
created.

1.  Let code be the value of the [[Code]] internal property of func.

2.  Let strict be the value of the [[Strict]] internal property of
    func.

3.  Let formals be the value of the [[FormalParameterList]] internal
    property of func.

4.  Let parameterNames be the BoundNames of formals.

5.  Let varDeclarations be the VarScopedDeclarations of code.

6.  Let functionsToInitialize be an emptyList.

7.  Let argumentsObjectNotNeeded be FALSE.

8.  For each d in varDeclarations, in reverse list order do

    a.  If d is a FunctionDeclaration then

        i.  NOTE If there are multiple FunctionDeclarations for the
            same name, the last declaration is used.

        ii. Let fn be the sole element of the BoundNames of d.

        iii. If fn is "ARGUMENTS", then let argumentsObjectNotNeeded
            be TRUE.

        iv. Let alreadyDeclared be the result of calling env’s
            HasBinding concrete method passing fn as the argument.

        v.  If alreadyDeclared is FALSE, then

            1.  Let status be the result of calling env’s
                CreateMutableBinding concrete method passing fn as the
                argument.

            2.  Assert: status is never an Abrupt Completion.

            3.  Append d to functionsToInitialize.

9.  For each String paramName in parameterNames, do

    a.  Let alreadyDeclared be the result of calling env’s
        HasBinding concrete method passing paramName as the argument.

    b.  NOTE Duplicate parameter names can only occur in non-strict
        functions. Parameter names that are the same as function
        declaration names do not get initialized to UNDEFINED.

    c.  If alreadyDeclared is FALSE, then

        i.  If paramName is "ARGUMENTS", then let
            argumentsObjectNotNeeded be TRUE.

        ii. Let status be the result of calling env’s
            CreateMutableBinding concrete method passing paramName as
            the argument.

        iii. Assert: status is never an Abrupt Completion

        iv. Call env’s InitializeBinding concrete method passing
            paramName, and UNDEFINED as the arguments.

10. NOTE If there is a function declaration or formal parameter with the
    name "ARGUMENTS" then an argument object is not created.

11. If argumentsObjectNotNeeded is FALSE, then

    a.  If strict is TRUE, then

        i.  Call env’s CreateImmutableBinding concrete method passing
            the String "ARGUMENTS" as the argument.

    b.  Else,

        i.  Call env’s CreateMutableBinding concrete method passing
            the String "ARGUMENTS" as the argument.

12. Let varNames be the VarDeclaredNames of code.

13. For each String varName in varNames, in list order do

    a.  Let alreadyDeclared be the result of calling env’s
        HasBinding concrete method passing varName as the argument.

    b.  NOTE A VarDeclaredNames is only instantiated and initialied here
        if it is not also the name of a formal parameter or a
        FunctionDeclarations.

    c.  If alreadyDeclared is FALSE, then

        i.  Call env’s CreateMutableBinding concrete method passing
            varName as the argument.

14. Let lexDeclarations be the LexicalDeclarations of code.

15. For each element d in lexDeclarations do

    a.  NOTE A lexically declared name can not be the same as a function
        declaration, formal parameter, or a var name. Lexically
        declarated names are only instantiated here but not initialized.

    b.  For each element dn of the BoundNames of d do

        i.  If IsConstantDeclaration of d is TRUE, then

            1.  Call env’s CreateImmutableBinding concrete method
                passing dn as the argument.

        ii. Else,

            1.  Call env’s CreateMutableBinding concrete method
                passing dn and FALSE as the arguments.

16. For each FunctionDeclaration f in functionsToInitialize, do

    a.  Let fn be the sole element of the BoundNames of f.

    b.  Let fo be the result of performing InstantiateFunctionObject
        for f with argument env.

    c.  Call env’s SetMutableMinding concrete method passing fn,
        fo, and FALSE as the arguments.

17. NOTE Function declaration are initialised prior to parameter
    initialisation so that default value expressions may reference them.
    it is not extended code. "ARGUMENTS" is not initialized until after
    parameter initialization.

18. Let ao be the result of InstantiateArgumentsObject with argument
    argumentsList.

19. NOTE If argumentsObjectNotNeeded is TRUE then the value of ao is
    not directly observable to ECMAScript code and need not actually
    exist. In that case, its use in the above steps is strictly as a
    device for specifying formal parameter initialisation semantics.

20. If argumentsObjectNotNeeded is FALSE, then

    a.  If strict is TRUE, then

        i.  Perform the abstract operation CompleteStrictArgumentsObject
            with argument a0.

    b.  Else,

        i.  Perform the abstract operation CompleteMappedArgumentsObject
            with arguments _a0, func_, formals, and env.

    c.  Call env’s InitializeBinding concrete method passing
        "ARGUMENTS" and ao as arguments.

21. Let formalStatus be the result of performing Binding
    Initialisation for formals with ao and UNDEFINED as arguments.

22. ReturnIfAbrupt(formalStatus).

23. Return NormalCompletion(empty)..

Bibliography

IEEE Std 754-2008: IEEE Standard for Floating-Point Arithmetic.
Institute of Electrical and Electronic Engineers, New York (2008)

The Unicode Consortium. The Unicode Standard, Version 3.0, defined by:
The Unicode Standard, Version 3.0 (Reading, MA, Addison-Wesley, 2000.
ISBN 0-201-61633-5)

Unicode Inc. (2010), Unicode Technical Report #15: Unicode Normalization
Forms

ISO 8601:2004(E) _Data elements and interchange formats – Information
interchange -- Representation of dates and times_

RFC 1738 "Uniform Resource Locators (URL)", available at
<http://tools.ietf.org/html/rfc1738>

RFC 2396 "Uniform Resource Identifiers (URI): Generic Syntax", available
at <http://tools.ietf.org/html/rfc2396>

RFC 3629 "UTF-8, a transformation format of ISO 10646", available at
<http://tools.ietf.org/html/rfc3629>

RFC 4627 "The application/json Media Type for JavaScript Object Notation
(JSON)" , available at <http://tools.ietf.org/html/rfc4627>

[1] Note: Please note that for ECMAScript Edition 4 the Ecma standard
number “ECMA-262 Edition 4” was reserved but not used in the Ecma
publication process. Therefore “ECMA-262 Edition 4” as an Ecma
International publication does not exist.
